{
    "bug_classes": {},
    "bug_functions": {
        "1": {
            "function_name": "  (not found) ",
            "file_path": "components/prism-elixir.js",
            "function_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 89
                }
            ],
            "function_code": [
                "Prism.languages.elixir = {",
                "\t'comment': /#.*/m,",
                "\t// ~r\"\"\"foo\"\"\" (multi-line), ~r'''foo''' (multi-line), ~r/foo/, ~r|foo|, ~r\"foo\", ~r'foo', ~r(foo), ~r[foo], ~r{foo}, ~r<foo>",
                "\t'regex': {",
                "\t\tpattern: /~[rR](?:(\"\"\"|''')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1|([\\/|\"'])(?:\\\\.|(?!\\2)[^\\\\\\r\\n])+\\2|\\((?:\\\\.|[^\\\\)\\r\\n])+\\)|\\[(?:\\\\.|[^\\\\\\]\\r\\n])+\\]|\\{(?:\\\\.|[^\\\\}\\r\\n])+\\}|<(?:\\\\.|[^\\\\>\\r\\n])+>)[uismxfr]*/,",
                "\t\tgreedy: true",
                "\t},",
                "\t'string': [",
                "\t\t{",
                "\t\t\t// ~s\"\"\"foo\"\"\" (multi-line), ~s'''foo''' (multi-line), ~s/foo/, ~s|foo|, ~s\"foo\", ~s'foo', ~s(foo), ~s[foo], ~s{foo} (with interpolation care), ~s<foo>",
                "\t\t\tpattern: /~[cCsSwW](?:(\"\"\"|''')(?:\\\\[\\s\\S]|(?!\\1)[^\\\\])+\\1|([\\/|\"'])(?:\\\\.|(?!\\2)[^\\\\\\r\\n])+\\2|\\((?:\\\\.|[^\\\\)\\r\\n])+\\)|\\[(?:\\\\.|[^\\\\\\]\\r\\n])+\\]|\\{(?:\\\\.|#\\{[^}]+\\}|[^\\\\}\\r\\n])+\\}|<(?:\\\\.|[^\\\\>\\r\\n])+>)[csa]?/,",
                "\t\t\tgreedy: true,",
                "\t\t\tinside: {",
                "\t\t\t\t// See interpolation below",
                "\t\t\t}",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(\"\"\"|''')[\\s\\S]*?\\1/,",
                "\t\t\tgreedy: true,",
                "\t\t\tinside: {",
                "\t\t\t\t// See interpolation below",
                "\t\t\t}",
                "\t\t},",
                "\t\t{",
                "\t\t\t// Multi-line strings are allowed",
                "\t\t\tpattern: /(\"|')(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,",
                "\t\t\tgreedy: true,",
                "\t\t\tinside: {",
                "\t\t\t\t// See interpolation below",
                "\t\t\t}",
                "\t\t}",
                "\t],",
                "\t'atom': {",
                "\t\t// Look-behind prevents bad highlighting of the :: operator",
                "\t\tpattern: /(^|[^:]):\\w+/,",
                "\t\tlookbehind: true,",
                "\t\talias: 'symbol'",
                "\t},",
                "\t// Look-ahead prevents bad highlighting of the :: operator",
                "\t'attr-name': /\\w+:(?!:)/,",
                "\t'capture': {",
                "\t\t// Look-behind prevents bad highlighting of the && operator",
                "\t\tpattern: /(^|[^&])&(?:[^&\\s\\d()][^\\s()]*|(?=\\())/,",
                "\t\tlookbehind: true,",
                "\t\talias: 'function'",
                "\t},",
                "\t'argument': {",
                "\t\t// Look-behind prevents bad highlighting of the && operator",
                "\t\tpattern: /(^|[^&])&\\d+/,",
                "\t\tlookbehind: true,",
                "\t\talias: 'variable'",
                "\t},",
                "\t'attribute': {",
                "\t\tpattern: /@\\w+/,",
                "\t\talias: 'variable'",
                "\t},",
                "\t'number': /\\b(?:0[box][a-f\\d_]+|\\d[\\d_]*)(?:\\.[\\d_]+)?(?:e[+-]?[\\d_]+)?\\b/i,",
                "\t'keyword': /\\b(?:after|alias|and|case|catch|cond|def(?:callback|exception|impl|module|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|require|rescue|try|unless|use|when)\\b/,",
                "\t'boolean': /\\b(?:true|false|nil)\\b/,",
                "\t'operator': [",
                "\t\t/\\bin\\b|&&?|\\|[|>]?|\\\\\\\\|::|\\.\\.\\.?|\\+\\+?|-[->]?|<[-=>]|>=|!==?|\\B!|=(?:==?|[>~])?|[*\\/^]/,",
                "\t\t{",
                "\t\t\t// We don't want to match <<",
                "\t\t\tpattern: /([^<])<(?!<)/,",
                "\t\t\tlookbehind: true",
                "\t\t},",
                "\t\t{",
                "\t\t\t// We don't want to match >>",
                "\t\t\tpattern: /([^>])>(?!>)/,",
                "\t\t\tlookbehind: true",
                "\t\t}",
                "\t],",
                "\t'punctuation': /<<|>>|[.,%\\[\\]{}()]/",
                "};",
                "",
                "Prism.languages.elixir.string.forEach(function(o) {",
                "\to.inside = {",
                "\t\t'interpolation': {",
                "\t\t\tpattern: /#\\{[^}]+\\}/,",
                "\t\t\tinside: {",
                "\t\t\t\t'delimiter': {",
                "\t\t\t\t\tpattern: /^#\\{|\\}$/,",
                "\t\t\t\t\talias: 'punctuation'",
                "\t\t\t\t},",
                "\t\t\t\trest: Prism.languages.elixir",
                "\t\t\t}",
                "\t\t}",
                "\t};",
                "});"
            ]
        }
    }
}