{
    "components/prism-rest.js": [
        "Prism.languages.rest = {",
        "\t'table': [",
        "\t\t{",
        "\t\t\tpattern: /(^[\\t ]*)(?:\\+[=-]+)+\\+(?:\\r?\\n|\\r)(?:\\1[+|].+[+|](?:\\r?\\n|\\r))+\\1(?:\\+[=-]+)+\\+/m,",
        "\t\t\tlookbehind: true,",
        "\t\t\tinside: {",
        "\t\t\t\t'punctuation': /\\||(?:\\+[=-]+)+\\+/",
        "\t\t\t}",
        "\t\t},",
        "\t\t{",
        "\t\t\tpattern: /(^[\\t ]*)=+ [ =]*=(?:(?:\\r?\\n|\\r)\\1.+)+(?:\\r?\\n|\\r)\\1=+ [ =]*=(?=(?:\\r?\\n|\\r){2}|\\s*$)/m,",
        "\t\t\tlookbehind: true,",
        "\t\t\tinside: {",
        "\t\t\t\t'punctuation': /[=-]+/",
        "\t\t\t}",
        "\t\t}",
        "\t],",
        "",
        "\t// Directive-like patterns",
        "",
        "\t'substitution-def': {",
        "\t\tpattern: /(^[\\t ]*\\.\\. )\\|(?:[^|\\s](?:[^|]*[^|\\s])?)\\| [^:]+::/m,",
        "\t\tlookbehind: true,",
        "\t\tinside: {",
        "\t\t\t'substitution': {",
        "\t\t\t\tpattern: /^\\|(?:[^|\\s]|[^|\\s][^|]*[^|\\s])\\|/,",
        "\t\t\t\talias: 'attr-value',",
        "\t\t\t\tinside: {",
        "\t\t\t\t\t'punctuation': /^\\||\\|$/",
        "\t\t\t\t}",
        "\t\t\t},",
        "\t\t\t'directive': {",
        "\t\t\t\tpattern: /( )(?! )[^:]+::/,",
        "\t\t\t\tlookbehind: true,",
        "\t\t\t\talias: 'function',",
        "\t\t\t\tinside: {",
        "\t\t\t\t\t'punctuation': /::$/",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t},",
        "\t'link-target': [",
        "\t\t{",
        "\t\t\tpattern: /(^[\\t ]*\\.\\. )\\[[^\\]]+\\]/m,",
        "\t\t\tlookbehind: true,",
        "\t\t\talias: 'string',",
        "\t\t\tinside: {",
        "\t\t\t\t'punctuation': /^\\[|\\]$/",
        "\t\t\t}",
        "\t\t},",
        "\t\t{",
        "\t\t\tpattern: /(^[\\t ]*\\.\\. )_(?:`[^`]+`|(?:[^:\\\\]|\\\\.)+):/m,",
        "\t\t\tlookbehind: true,",
        "\t\t\talias: 'string',",
        "\t\t\tinside: {",
        "\t\t\t\t'punctuation': /^_|:$/",
        "\t\t\t}",
        "\t\t}",
        "\t],",
        "\t'directive': {",
        "\t\tpattern: /(^[\\t ]*\\.\\. )[^:]+::/m,",
        "\t\tlookbehind: true,",
        "\t\talias: 'function',",
        "\t\tinside: {",
        "\t\t\t'punctuation': /::$/",
        "\t\t}",
        "\t},",
        "\t'comment': {",
        "\t\t// The two alternatives try to prevent highlighting of blank comments",
        "\t\tpattern: /(^[\\t ]*\\.\\.)(?:(?: .+)?(?:(?:\\r?\\n|\\r).+)+| .+)(?=(?:\\r?\\n|\\r){2}|$)/m,",
        "\t\tlookbehind: true",
        "\t},",
        "",
        "\t'title': [",
        "\t\t// Overlined and underlined",
        "\t\t{",
        "\t\t\tpattern: /^(([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\2+)(?:\\r?\\n|\\r).+(?:\\r?\\n|\\r)\\1$/m,",
        "\t\t\tinside: {",
        "\t\t\t\t'punctuation': /^[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+|[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+$/,",
        "\t\t\t\t'important': /.+/",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\t// Underlined only",
        "\t\t{",
        "\t\t\tpattern: /(^|(?:\\r?\\n|\\r){2}).+(?:\\r?\\n|\\r)([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\2+(?=\\r?\\n|\\r|$)/,",
        "\t\t\tlookbehind: true,",
        "\t\t\tinside: {",
        "\t\t\t\t'punctuation': /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]+$/,",
        "\t\t\t\t'important': /.+/",
        "\t\t\t}",
        "\t\t}",
        "\t],",
        "\t'hr': {",
        "\t\tpattern: /((?:\\r?\\n|\\r){2})([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\2{3,}(?=(?:\\r?\\n|\\r){2})/,",
        "\t\tlookbehind: true,",
        "\t\talias: 'punctuation'",
        "\t},",
        "\t'field': {",
        "\t\tpattern: /(^[\\t ]*):[^:\\r\\n]+:(?= )/m,",
        "\t\tlookbehind: true,",
        "\t\talias: 'attr-name'",
        "\t},",
        "\t'command-line-option': {",
        "\t\tpattern: /(^[\\t ]*)(?:[+-][a-z\\d]|(?:--|\\/)[a-z\\d-]+)(?:[ =](?:[a-z][\\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\\d]|(?:--|\\/)[a-z\\d-]+)(?:[ =](?:[a-z][\\w-]*|<[^<>]+>))?)*(?=(?:\\r?\\n|\\r)? {2,}\\S)/im,",
        "\t\tlookbehind: true,",
        "\t\talias: 'symbol'",
        "\t},",
        "\t'literal-block': {",
        "\t\tpattern: /::(?:\\r?\\n|\\r){2}([ \\t]+)(?![ \\t]).+(?:(?:\\r?\\n|\\r)\\1.+)*/,",
        "\t\tinside: {",
        "\t\t\t'literal-block-punctuation': {",
        "\t\t\t\tpattern: /^::/,",
        "\t\t\t\talias: 'punctuation'",
        "\t\t\t}",
        "\t\t}",
        "\t},",
        "\t'quoted-literal-block': {",
        "\t\tpattern: /::(?:\\r?\\n|\\r){2}([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~]).*(?:(?:\\r?\\n|\\r)\\1.*)*/,",
        "\t\tinside: {",
        "\t\t\t'literal-block-punctuation': {",
        "\t\t\t\tpattern: /^(?:::|([!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~])\\1*)/m,",
        "\t\t\t\talias: 'punctuation'",
        "\t\t\t}",
        "\t\t}",
        "\t},",
        "\t'list-bullet': {",
        "\t\tpattern: /(^[\\t ]*)(?:[*+\\-\u2022\u2023\u2043]|\\(?(?:\\d+|[a-z]|[ivxdclm]+)\\)|(?:\\d+|[a-z]|[ivxdclm]+)\\.)(?= )/im,",
        "\t\tlookbehind: true,",
        "\t\talias: 'punctuation'",
        "\t},",
        "\t'doctest-block': {",
        "\t\tpattern: /(^[\\t ]*)>>> .+(?:(?:\\r?\\n|\\r).+)*/m,",
        "\t\tlookbehind: true,",
        "\t\tinside: {",
        "\t\t\t'punctuation': /^>>>/",
        "\t\t}",
        "\t},",
        "",
        "\t'inline': [",
        "\t\t{",
        "\t\t\tpattern: /(^|[\\s\\-:\\/'\"<(\\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\\*\\*?|``?|\\|)(?!\\s).*?\\S\\2(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$))/m,",
        "\t\t\tlookbehind: true,",
        "\t\t\tinside: {",
        "\t\t\t\t'bold': {",
        "\t\t\t\t\tpattern: /(^\\*\\*).+(?=\\*\\*$)/,",
        "\t\t\t\t\tlookbehind: true",
        "\t\t\t\t},",
        "\t\t\t\t'italic': {",
        "\t\t\t\t\tpattern: /(^\\*).+(?=\\*$)/,",
        "\t\t\t\t\tlookbehind: true",
        "\t\t\t\t},",
        "\t\t\t\t'inline-literal': {",
        "\t\t\t\t\tpattern: /(^``).+(?=``$)/,",
        "\t\t\t\t\tlookbehind: true,",
        "\t\t\t\t\talias: 'symbol'",
        "\t\t\t\t},",
        "\t\t\t\t'role': {",
        "\t\t\t\t\tpattern: /^:[^:]+:|:[^:]+:$/,",
        "\t\t\t\t\talias: 'function',",
        "\t\t\t\t\tinside: {",
        "\t\t\t\t\t\t'punctuation': /^:|:$/",
        "\t\t\t\t\t}",
        "\t\t\t\t},",
        "\t\t\t\t'interpreted-text': {",
        "\t\t\t\t\tpattern: /(^`).+(?=`$)/,",
        "\t\t\t\t\tlookbehind: true,",
        "\t\t\t\t\talias: 'attr-value'",
        "\t\t\t\t},",
        "\t\t\t\t'substitution': {",
        "\t\t\t\t\tpattern: /(^\\|).+(?=\\|$)/,",
        "\t\t\t\t\tlookbehind: true,",
        "\t\t\t\t\talias: 'attr-value'",
        "\t\t\t\t},",
        "\t\t\t\t'punctuation': /\\*\\*?|``?|\\|/",
        "\t\t\t}",
        "\t\t}",
        "\t],",
        "",
        "\t'link': [",
        "\t\t{",
        "\t\t\tpattern: /\\[[^\\[\\]]+\\]_(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$)/,",
        "\t\t\talias: 'string',",
        "\t\t\tinside: {",
        "\t\t\t\t'punctuation': /^\\[|\\]_$/",
        "\t\t\t}",
        "\t\t},",
        "\t\t{",
        "\t\t\tpattern: /(?:\\b[a-z\\d]+(?:[_.:+][a-z\\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\\s\\-.,:;!?\\\\\\/'\")\\]}]|$)/i,",
        "\t\t\talias: 'string',",
        "\t\t\tinside: {",
        "\t\t\t\t'punctuation': /^_?`|`$|`?_?_$/",
        "\t\t\t}",
        "\t\t}",
        "\t],",
        "",
        "\t// Line block start,",
        "\t// quote attribution,",
        "\t// explicit markup start,",
        "\t// and anonymous hyperlink target shortcut (__)",
        "\t'punctuation': {",
        "\t\tpattern: /(^[\\t ]*)(?:\\|(?= |$)|(?:---?|\u2014|\\.\\.|__)(?= )|\\.\\.$)/m,",
        "\t\tlookbehind: true",
        "\t}",
        "};"
    ],
    "components/prism-core.js": [
        "...",
        "\t\t * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the",
        "\t\t * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load",
        "\t\t * additional languages or plugins yourself.",
        "\t\t *",
        "\t\t * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.",
        "\t\t *",
        "\t\t * You obviously have to change this value before the automatic highlighting started. To do this, you can add an",
        "\t\t * empty Prism object into the global scope before loading the Prism script like this:",
        "\t\t *",
        "\t\t * ```js",
        "\t\t * window.Prism = window.Prism || {};",
        "\t\t * Prism.manual = true;",
        "\t\t * // add a new <script> to load Prism's script",
        "\t\t * ```",
        "\t\t *",
        "\t\t * @default false",
        "\t\t * @type {boolean}",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\tmanual: _self.Prism && _self.Prism.manual,",
        "\t\tdisableWorkerMessageHandler: _self.Prism && _self.Prism.disableWorkerMessageHandler,",
        "",
        "\t\t/**",
        "\t\t * A namespace for utility methods.",
        "\t\t *",
        "\t\t * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may",
        "\t\t * change or disappear at any time.",
        "\t\t *",
        "\t\t * @namespace",
        "\t\t * @memberof Prism",
        "\t\t */",
        "\t\tutil: {",
        "\t\t\tencode: function encode(tokens) {",
        "\t\t\t\tif (tokens instanceof Token) {",
        "\t\t\t\t\treturn new Token(tokens.type, encode(tokens.content), tokens.alias);",
        "\t\t\t\t} else if (Array.isArray(tokens)) {",
        "\t\t\t\t\treturn tokens.map(encode);",
        "\t\t\t\t} else {",
        "\t\t\t\t\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\u00a0/g, ' ');",
        "\t\t\t\t}",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Returns the name of the type of the given value.",
        "\t\t\t *",
        "\t\t\t * @param {any} o",
        "\t\t\t * @returns {string}",
        "\t\t\t * @example",
        "\t\t\t * type(null)      === 'Null'",
        "\t\t\t * type(undefined) === 'Undefined'",
        "\t\t\t * type(123)       === 'Number'",
        "\t\t\t * type('foo')     === 'String'",
        "\t\t\t * type(true)      === 'Boolean'",
        "\t\t\t * type([1, 2])    === 'Array'",
        "\t\t\t * type({})        === 'Object'",
        "\t\t\t * type(String)    === 'Function'",
        "\t\t\t * type(/abc+/)    === 'RegExp'",
        "\t\t\t */",
        "\t\t\ttype: function (o) {",
        "\t\t\t\treturn Object.prototype.toString.call(o).slice(8, -1);",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Returns a unique number for the given object. Later calls will still return the same number.",
        "\t\t\t *",
        "\t\t\t * @param {Object} obj",
        "\t\t\t * @returns {number}",
        "\t\t\t */",
        "\t\t\tobjId: function (obj) {",
        "\t\t\t\tif (!obj['__id']) {",
        "\t\t\t\t\tObject.defineProperty(obj, '__id', { value: ++uniqueId });",
        "\t\t\t\t}",
        "\t\t\t\treturn obj['__id'];",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Creates a deep clone of the given object.",
        "\t\t\t *",
        "\t\t\t * The main intended use of this function is to clone language definitions.",
        "\t\t\t *",
        "\t\t\t * @param {T} o",
        "\t\t\t * @param {Record<number, any>} [visited]",
        "\t\t\t * @returns {T}",
        "\t\t\t * @template T",
        "\t\t\t */",
        "\t\t\tclone: function deepClone(o, visited) {",
        "\t\t\t\tvisited = visited || {};",
        "",
        "\t\t\t\tvar clone; var id;",
        "\t\t\t\tswitch (_.util.type(o)) {",
        "\t\t\t\t\tcase 'Object':",
        "\t\t\t\t\t\tid = _.util.objId(o);",
        "\t\t\t\t\t\tif (visited[id]) {",
        "\t\t\t\t\t\t\treturn visited[id];",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t\tclone = /** @type {Record<string, any>} */ ({});",
        "\t\t\t\t\t\tvisited[id] = clone;",
        "",
        "\t\t\t\t\t\tfor (var key in o) {",
        "\t\t\t\t\t\t\tif (o.hasOwnProperty(key)) {",
        "\t\t\t\t\t\t\t\tclone[key] = deepClone(o[key], visited);",
        "\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t}",
        "",
        "\t\t\t\t\t\treturn /** @type {any} */ (clone);",
        "",
        "\t\t\t\t\tcase 'Array':",
        "\t\t\t\t\t\tid = _.util.objId(o);",
        "\t\t\t\t\t\tif (visited[id]) {",
        "\t\t\t\t\t\t\treturn visited[id];",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t\tclone = [];",
        "\t\t\t\t\t\tvisited[id] = clone;",
        "",
        "\t\t\t\t\t\t(/** @type {Array} */(/** @type {any} */(o))).forEach(function (v, i) {",
        "\t\t\t\t\t\t\tclone[i] = deepClone(v, visited);",
        "\t\t\t\t\t\t});",
        "",
        "\t\t\t\t\t\treturn /** @type {any} */ (clone);",
        "",
        "\t\t\t\t\tdefault:",
        "\t\t\t\t\t\treturn o;",
        "\t\t\t\t}",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.",
        "\t\t\t *",
        "\t\t\t * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.",
        "\t\t\t *",
        "\t\t\t * @param {Element} element",
        "\t\t\t * @returns {string}",
        "\t\t\t */",
        "\t\t\tgetLanguage: function (element) {",
        "\t\t\t\twhile (element && !lang.test(element.className)) {",
        "\t\t\t\t\telement = element.parentElement;",
        "\t\t\t\t}",
        "\t\t\t\tif (element) {",
        "\t\t\t\t\treturn (element.className.match(lang) || [, 'none'])[1].toLowerCase();",
        "\t\t\t\t}",
        "\t\t\t\treturn 'none';",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Returns the script element that is currently executing.",
        "\t\t\t *",
        "\t\t\t * This does __not__ work for line script element.",
        "\t\t\t *",
        "\t\t\t * @returns {HTMLScriptElement | null}",
        "\t\t\t */",
        "\t\t\tcurrentScript: function () {",
        "\t\t\t\tif (typeof document === 'undefined') {",
        "\t\t\t\t\treturn null;",
        "\t\t\t\t}",
        "\t\t\t\tif ('currentScript' in document && 1 < 2 /* hack to trip TS' flow analysis */) {",
        "\t\t\t\t\treturn /** @type {any} */ (document.currentScript);",
        "\t\t\t\t}",
        "",
        "\t\t\t\t// IE11 workaround",
        "\t\t\t\t// we'll get the src of the current script by parsing IE11's error stack trace",
        "\t\t\t\t// this will not work for inline scripts",
        "",
        "\t\t\t\ttry {",
        "\t\t\t\t\tthrow new Error();",
        "\t\t\t\t} catch (err) {",
        "\t\t\t\t\t// Get file src url from stack. Specifically works with the format of stack traces in IE.",
        "\t\t\t\t\t// A stack will look like this:",
        "\t\t\t\t\t//",
        "\t\t\t\t\t// Error",
        "\t\t\t\t\t//    at _.util.currentScript (http://localhost/components/prism-core.js:119:5)",
        "\t\t\t\t\t//    at Global code (http://localhost/components/prism-core.js:606:1)",
        "",
        "\t\t\t\t\tvar src = (/at [^(\\r\\n]*\\((.*):.+:.+\\)$/i.exec(err.stack) || [])[1];",
        "\t\t\t\t\tif (src) {",
        "\t\t\t\t\t\tvar scripts = document.getElementsByTagName('script');",
        "\t\t\t\t\t\tfor (var i in scripts) {",
        "\t\t\t\t\t\t\tif (scripts[i].src == src) {",
        "\t\t\t\t\t\t\t\treturn scripts[i];",
        "\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t}",
        "\t\t\t\t\treturn null;",
        "\t\t\t\t}",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Returns whether a given class is active for `element`.",
        "\t\t\t *",
        "\t\t\t * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated",
        "\t\t\t * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the",
        "\t\t\t * given class is just the given class with a `no-` prefix.",
        "\t\t\t *",
        "\t\t\t * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is",
        "\t\t\t * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its",
        "\t\t\t * ancestors have the given class or the negated version of it, then the default activation will be returned.",
        "\t\t\t *",
        "\t\t\t * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated",
        "\t\t\t * version of it, the class is considered active.",
        "\t\t\t *",
        "\t\t\t * @param {Element} element",
        "\t\t\t * @param {string} className",
        "\t\t\t * @param {boolean} [defaultActivation=false]",
        "\t\t\t * @returns {boolean}",
        "\t\t\t */",
        "\t\t\tisActive: function (element, className, defaultActivation) {",
        "\t\t\t\tvar no = 'no-' + className;",
        "",
        "\t\t\t\twhile (element) {",
        "\t\t\t\t\tvar classList = element.classList;",
        "\t\t\t\t\tif (classList.contains(className)) {",
        "\t\t\t\t\t\treturn true;",
        "\t\t\t\t\t}",
        "\t\t\t\t\tif (classList.contains(no)) {",
        "\t\t\t\t\t\treturn false;",
        "\t\t\t\t\t}",
        "\t\t\t\t\telement = element.parentElement;",
        "\t\t\t\t}",
        "\t\t\t\treturn !!defaultActivation;",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.",
        "\t\t *",
        "\t\t * @namespace",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\tlanguages: {",
        "\t\t\t/**",
        "\t\t\t * The grammar for plain, unformatted text.",
        "\t\t\t */",
        "\t\t\tplain: plainTextGrammar,",
        "\t\t\tplaintext: plainTextGrammar,",
        "\t\t\ttext: plainTextGrammar,",
        "\t\t\ttxt: plainTextGrammar,",
        "",
        "\t\t\t/**",
        "\t\t\t * Creates a deep copy of the language with the given id and appends the given tokens.",
        "\t\t\t *",
        "\t\t\t * If a token in `redef` also appears in the copied language, then the existing token in the copied language",
        "\t\t\t * will be overwritten at its original position.",
        "\t\t\t *",
        "\t\t\t * ## Best practices",
        "\t\t\t *",
        "\t\t\t * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)",
        "\t\t\t * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to",
        "\t\t\t * understand the language definition because, normally, the order of tokens matters in Prism grammars.",
        "\t\t\t *",
        "\t\t\t * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.",
        "\t\t\t * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.",
        "\t\t\t *",
        "\t\t\t * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.",
        "\t\t\t * @param {Grammar} redef The new tokens to append.",
        "\t\t\t * @returns {Grammar} The new language created.",
        "\t\t\t * @public",
        "\t\t\t * @example",
        "\t\t\t * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {",
        "\t\t\t *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token",
        "\t\t\t *     // at its original position",
        "\t\t\t *     'comment': { ... },",
        "\t\t\t *     // CSS doesn't have a 'color' token, so this token will be appended",
        "\t\t\t *     'color': /\\b(?:red|green|blue)\\b/",
        "\t\t\t * });",
        "\t\t\t */",
        "\t\t\textend: function (id, redef) {",
        "\t\t\t\tvar lang = _.util.clone(_.languages[id]);",
        "",
        "\t\t\t\tfor (var key in redef) {",
        "\t\t\t\t\tlang[key] = redef[key];",
        "\t\t\t\t}",
        "",
        "\t\t\t\treturn lang;",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Inserts tokens _before_ another token in a language definition or any other grammar.",
        "\t\t\t *",
        "\t\t\t * ## Usage",
        "\t\t\t *",
        "\t\t\t * This helper method makes it easy to modify existing languages. For example, the CSS language definition",
        "\t\t\t * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded",
        "\t\t\t * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the",
        "\t\t\t * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do",
        "\t\t\t * this:",
        "\t\t\t *",
        "\t\t\t * ```js",
        "\t\t\t * Prism.languages.markup.style = {",
        "\t\t\t *     // token",
        "\t\t\t * };",
        "\t\t\t * ```",
        "\t\t\t *",
        "\t\t\t * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens",
        "\t\t\t * before existing tokens. For the CSS example above, you would use it like this:",
        "\t\t\t *",
        "\t\t\t * ```js",
        "\t\t\t * Prism.languages.insertBefore('markup', 'cdata', {",
        "\t\t\t *     'style': {",
        "\t\t\t *         // token",
        "\t\t\t *     }",
        "\t\t\t * });",
        "\t\t\t * ```",
        "\t\t\t *",
        "\t\t\t * ## Special cases",
        "\t\t\t *",
        "\t\t\t * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar",
        "\t\t\t * will be ignored.",
        "\t\t\t *",
        "\t\t\t * This behavior can be used to insert tokens after `before`:",
        "\t\t\t *",
        "\t\t\t * ```js",
        "\t\t\t * Prism.languages.insertBefore('markup', 'comment', {",
        "\t\t\t *     'comment': Prism.languages.markup.comment,",
        "\t\t\t *     // tokens after 'comment'",
        "\t\t\t * });",
        "\t\t\t * ```",
        "\t\t\t *",
        "\t\t\t * ## Limitations",
        "\t\t\t *",
        "\t\t\t * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object",
        "\t\t\t * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave",
        "\t\t\t * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily",
        "\t\t\t * deleting properties which is necessary to insert at arbitrary positions.",
        "\t\t\t *",
        "\t\t\t * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.",
        "\t\t\t * Instead, it will create a new object and replace all references to the target object with the new one. This",
        "\t\t\t * can be done without temporarily deleting properties, so the iteration order is well-defined.",
        "\t\t\t *",
        "\t\t\t * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if",
        "\t\t\t * you hold the target object in a variable, then the value of the variable will not change.",
        "\t\t\t *",
        "\t\t\t * ```js",
        "\t\t\t * var oldMarkup = Prism.languages.markup;",
        "\t\t\t * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });",
        "\t\t\t *",
        "\t\t\t * assert(oldMarkup !== Prism.languages.markup);",
        "\t\t\t * assert(newMarkup === Prism.languages.markup);",
        "\t\t\t * ```",
        "\t\t\t *",
        "\t\t\t * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the",
        "\t\t\t * object to be modified.",
        "\t\t\t * @param {string} before The key to insert before.",
        "\t\t\t * @param {Grammar} insert An object containing the key-value pairs to be inserted.",
        "\t\t\t * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the",
        "\t\t\t * object to be modified.",
        "\t\t\t *",
        "\t\t\t * Defaults to `Prism.languages`.",
        "\t\t\t * @returns {Grammar} The new grammar object.",
        "\t\t\t * @public",
        "\t\t\t */",
        "\t\t\tinsertBefore: function (inside, before, insert, root) {",
        "\t\t\t\troot = root || /** @type {any} */ (_.languages);",
        "\t\t\t\tvar grammar = root[inside];",
        "\t\t\t\t/** @type {Grammar} */",
        "\t\t\t\tvar ret = {};",
        "",
        "\t\t\t\tfor (var token in grammar) {",
        "\t\t\t\t\tif (grammar.hasOwnProperty(token)) {",
        "",
        "\t\t\t\t\t\tif (token == before) {",
        "\t\t\t\t\t\t\tfor (var newToken in insert) {",
        "\t\t\t\t\t\t\t\tif (insert.hasOwnProperty(newToken)) {",
        "\t\t\t\t\t\t\t\t\tret[newToken] = insert[newToken];",
        "\t\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t\t}",
        "\t\t\t\t\t\t}",
        "",
        "\t\t\t\t\t\t// Do not insert token which also occur in insert. See #1525",
        "\t\t\t\t\t\tif (!insert.hasOwnProperty(token)) {",
        "\t\t\t\t\t\t\tret[token] = grammar[token];",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "",
        "\t\t\t\tvar old = root[inside];",
        "\t\t\t\troot[inside] = ret;",
        "",
        "\t\t\t\t// Update references in other language definitions",
        "\t\t\t\t_.languages.DFS(_.languages, function (key, value) {",
        "\t\t\t\t\tif (value === old && key != inside) {",
        "\t\t\t\t\t\tthis[key] = ret;",
        "\t\t\t\t\t}",
        "\t\t\t\t});",
        "",
        "\t\t\t\treturn ret;",
        "\t\t\t},",
        "",
        "\t\t\t// Traverse a language definition with Depth First Search",
        "\t\t\tDFS: function DFS(o, callback, type, visited) {",
        "\t\t\t\tvisited = visited || {};",
        "",
        "\t\t\t\tvar objId = _.util.objId;",
        "",
        "\t\t\t\tfor (var i in o) {",
        "\t\t\t\t\tif (o.hasOwnProperty(i)) {",
        "\t\t\t\t\t\tcallback.call(o, i, o[i], type || i);",
        "",
        "\t\t\t\t\t\tvar property = o[i];",
        "\t\t\t\t\t\tvar propertyType = _.util.type(property);",
        "",
        "\t\t\t\t\t\tif (propertyType === 'Object' && !visited[objId(property)]) {",
        "\t\t\t\t\t\t\tvisited[objId(property)] = true;",
        "\t\t\t\t\t\t\tDFS(property, callback, null, visited);",
        "\t\t\t\t\t\t} else if (propertyType === 'Array' && !visited[objId(property)]) {",
        "\t\t\t\t\t\t\tvisited[objId(property)] = true;",
        "\t\t\t\t\t\t\tDFS(property, callback, i, visited);",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\tplugins: {},",
        "",
        "\t\t/**",
        "\t\t * This is the most high-level function in Prism\u2019s API.",
        "\t\t * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on",
        "\t\t * each one of them.",
        "\t\t *",
        "\t\t * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.",
        "\t\t *",
        "\t\t * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.",
        "\t\t * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\thighlightAll: function (async, callback) {",
        "\t\t\t_.highlightAllUnder(document, async, callback);",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls",
        "\t\t * {@link Prism.highlightElement} on each one of them.",
        "\t\t *",
        "\t\t * The following hooks will be run:",
        "\t\t * 1. `before-highlightall`",
        "\t\t * 2. `before-all-elements-highlight`",
        "\t\t * 3. All hooks of {@link Prism.highlightElement} for each element.",
        "\t\t *",
        "\t\t * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.",
        "\t\t * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.",
        "\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\thighlightAllUnder: function (container, async, callback) {",
        "\t\t\tvar env = {",
        "\t\t\t\tcallback: callback,",
        "\t\t\t\tcontainer: container,",
        "\t\t\t\tselector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'",
        "\t\t\t};",
        "",
        "\t\t\t_.hooks.run('before-highlightall', env);",
        "",
        "\t\t\tenv.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));",
        "",
        "\t\t\t_.hooks.run('before-all-elements-highlight', env);",
        "",
        "\t\t\tfor (var i = 0, element; (element = env.elements[i++]);) {",
        "\t\t\t\t_.highlightElement(element, async === true, env.callback);",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * Highlights the code inside a single element.",
        "\t\t *",
        "\t\t * The following hooks will be run:",
        "\t\t * 1. `before-sanity-check`",
        "\t\t * 2. `before-highlight`",
        "\t\t * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.",
        "\t\t * 4. `before-insert`",
        "\t\t * 5. `after-highlight`",
        "\t\t * 6. `complete`",
        "\t\t *",
        "\t\t * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for",
        "\t\t * the element's language.",
        "\t\t *",
        "\t\t * @param {Element} element The element containing the code.",
        "\t\t * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.",
        "\t\t * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers",
        "\t\t * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is",
        "\t\t * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).",
        "\t\t *",
        "\t\t * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for",
        "\t\t * asynchronous highlighting to work. You can build your own bundle on the",
        "\t\t * [Download page](https://prismjs.com/download.html).",
        "\t\t * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.",
        "\t\t * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\thighlightElement: function (element, async, callback) {",
        "\t\t\t// Find language",
        "\t\t\tvar language = _.util.getLanguage(element);",
        "\t\t\tvar grammar = _.languages[language];",
        "",
        "\t\t\t// Set language on the element, if not present",
        "\t\t\telement.className = element.className.replace(lang, '').replace(/\\s+/g, ' ') + ' language-' + language;",
        "",
        "\t\t\t// Set language on the parent, for styling",
        "...",
        "\t\t * let tokens = Prism.tokenize(code, Prism.languages.javascript);",
        "\t\t * tokens.forEach(token => {",
        "\t\t *     if (token instanceof Prism.Token && token.type === 'number') {",
        "\t\t *         console.log(`Found numeric literal: ${token.content}`);",
        "\t\t *     }",
        "\t\t * });",
        "\t\t */",
        "\t\ttokenize: function (text, grammar) {",
        "\t\t\tvar rest = grammar.rest;",
        "\t\t\tif (rest) {",
        "\t\t\t\tfor (var token in rest) {",
        "\t\t\t\t\tgrammar[token] = rest[token];",
        "\t\t\t\t}",
        "",
        "\t\t\t\tdelete grammar.rest;",
        "\t\t\t}",
        "",
        "\t\t\tvar tokenList = new LinkedList();",
        "\t\t\taddAfter(tokenList, tokenList.head, text);",
        "",
        "\t\t\tmatchGrammar(text, tokenList, grammar, tokenList.head, 0);",
        "",
        "\t\t\treturn toArray(tokenList);",
        "\t\t},",
        "",
        "\t\t/**",
        "\t\t * @namespace",
        "\t\t * @memberof Prism",
        "\t\t * @public",
        "\t\t */",
        "\t\thooks: {",
        "\t\t\tall: {},",
        "",
        "\t\t\t/**",
        "\t\t\t * Adds the given callback to the list of callbacks for the given hook.",
        "\t\t\t *",
        "\t\t\t * The callback will be invoked when the hook it is registered for is run.",
        "\t\t\t * Hooks are usually directly run by a highlight function but you can also run hooks yourself.",
        "\t\t\t *",
        "\t\t\t * One callback function can be registered to multiple hooks and the same hook multiple times.",
        "\t\t\t *",
        "\t\t\t * @param {string} name The name of the hook.",
        "\t\t\t * @param {HookCallback} callback The callback function which is given environment variables.",
        "\t\t\t * @public",
        "\t\t\t */",
        "\t\t\tadd: function (name, callback) {",
        "\t\t\t\tvar hooks = _.hooks.all;",
        "",
        "\t\t\t\thooks[name] = hooks[name] || [];",
        "",
        "\t\t\t\thooks[name].push(callback);",
        "\t\t\t},",
        "",
        "\t\t\t/**",
        "\t\t\t * Runs a hook invoking all registered callbacks with the given environment variables.",
        "\t\t\t *",
        "\t\t\t * Callbacks will be invoked synchronously and in the order in which they were registered.",
        "\t\t\t *",
        "\t\t\t * @param {string} name The name of the hook.",
        "\t\t\t * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.",
        "\t\t\t * @public",
        "\t\t\t */",
        "\t\t\trun: function (name, env) {",
        "\t\t\t\tvar callbacks = _.hooks.all[name];",
        "",
        "\t\t\t\tif (!callbacks || !callbacks.length) {",
        "\t\t\t\t\treturn;",
        "\t\t\t\t}",
        "",
        "\t\t\t\tfor (var i = 0, callback; (callback = callbacks[i++]);) {",
        "\t\t\t\t\tcallback(env);",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t},",
        "",
        "\t\tToken: Token",
        "\t};",
        "\t_self.Prism = _;",
        "",
        "",
        "\t// Typescript note:",
        "\t// The following can be used to import the Token type in JSDoc:",
        "\t//",
        "\t//   @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token",
        "",
        "\t/**",
        "\t * Creates a new token.",
        "\t *",
        "\t * @param {string} type See {@link Token#type type}",
        "\t * @param {string | TokenStream} content See {@link Token#content content}",
        "\t * @param {string|string[]} [alias] The alias(es) of the token.",
        "\t * @param {string} [matchedStr=\"\"] A copy of the full string this token was created from.",
        "\t * @class",
        "\t * @global",
        "\t * @public",
        "\t */",
        "\tfunction Token(type, content, alias, matchedStr) {",
        "\t\t/**",
        "\t\t * The type of the token.",
        "\t\t *",
        "\t\t * This is usually the key of a pattern in a {@link Grammar}.",
        "\t\t *",
        "\t\t * @type {string}",
        "\t\t * @see GrammarToken",
        "\t\t * @public",
        "\t\t */",
        "\t\tthis.type = type;",
        "\t\t/**",
        "\t\t * The strings or tokens contained by this token.",
        "\t\t *",
        "\t\t * This will be a token stream if the pattern matched also defined an `inside` grammar.",
        "\t\t *",
        "\t\t * @type {string | TokenStream}",
        "\t\t * @public",
        "\t\t */",
        "\t\tthis.content = content;",
        "\t\t/**",
        "\t\t * The alias(es) of the token.",
        "\t\t *",
        "\t\t * @type {string|string[]}",
        "\t\t * @see GrammarToken",
        "\t\t * @public",
        "\t\t */",
        "\t\tthis.alias = alias;",
        "\t\t// Copy of the full string this token was created from",
        "\t\tthis.length = (matchedStr || '').length | 0;",
        "\t}",
        "",
        "\t/**",
        "\t * A token stream is an array of strings and {@link Token Token} objects.",
        "\t *",
        "\t * Token streams have to fulfill a few properties that are assumed by most functions (mostly internal ones) that process",
        "\t * them.",
        "\t *",
        "\t * 1. No adjacent strings.",
        "\t * 2. No empty strings.",
        "\t *",
        "\t *    The only exception here is the token stream that only contains the empty string and nothing else.",
        "\t *",
        "\t * @typedef {Array<string | Token>} TokenStream",
        "\t * @global",
        "\t * @public",
        "\t */",
        "",
        "\t/**",
        "\t * Converts the given token or token stream to an HTML representation.",
        "\t *",
        "\t * The following hooks will be run:",
        "\t * 1. `wrap`: On each {@link Token}.",
        "\t *",
        "\t * @param {string | Token | TokenStream} o The token or token stream to be converted.",
        "\t * @param {string} language The name of current language.",
        "\t * @returns {string} The HTML representation of the token or token stream.",
        "\t * @memberof Token",
        "\t * @static",
        "\t */",
        "\tToken.stringify = function stringify(o, language) {",
        "\t\tif (typeof o == 'string') {",
        "\t\t\treturn o;",
        "\t\t}",
        "\t\tif (Array.isArray(o)) {",
        "\t\t\tvar s = '';",
        "\t\t\to.forEach(function (e) {",
        "\t\t\t\ts += stringify(e, language);",
        "\t\t\t});",
        "\t\t\treturn s;",
        "\t\t}",
        "",
        "\t\tvar env = {",
        "\t\t\ttype: o.type,",
        "\t\t\tcontent: stringify(o.content, language),",
        "\t\t\ttag: 'span',",
        "\t\t\tclasses: ['token', o.type],",
        "\t\t\tattributes: {},",
        "\t\t\tlanguage: language",
        "\t\t};",
        "",
        "\t\tvar aliases = o.alias;",
        "\t\tif (aliases) {",
        "\t\t\tif (Array.isArray(aliases)) {",
        "\t\t\t\tArray.prototype.push.apply(env.classes, aliases);",
        "\t\t\t} else {",
        "\t\t\t\tenv.classes.push(aliases);",
        "\t\t\t}",
        "\t\t}",
        "",
        "\t\t_.hooks.run('wrap', env);",
        "",
        "\t\tvar attributes = '';",
        "\t\tfor (var name in env.attributes) {",
        "\t\t\tattributes += ' ' + name + '=\"' + (env.attributes[name] || '').replace(/\"/g, '&quot;') + '\"';",
        "\t\t}",
        "",
        "\t\treturn '<' + env.tag + ' class=\"' + env.classes.join(' ') + '\"' + attributes + '>' + env.content + '</' + env.tag + '>';",
        "\t};",
        "",
        "\t/**",
        "\t * @param {RegExp} pattern",
        "\t * @param {number} pos",
        "\t * @param {string} text",
        "\t * @param {boolean} lookbehind",
        "\t * @returns {RegExpExecArray | null}",
        "\t */",
        "\tfunction matchPattern(pattern, pos, text, lookbehind) {",
        "\t\tpattern.lastIndex = pos;",
        "\t\tvar match = pattern.exec(text);",
        "\t\tif (match && lookbehind && match[1]) {",
        "\t\t\t// change the match to remove the text matched by the Prism lookbehind group",
        "\t\t\tvar lookbehindLength = match[1].length;",
        "\t\t\tmatch.index += lookbehindLength;",
        "\t\t\tmatch[0] = match[0].slice(lookbehindLength);",
        "\t\t}",
        "\t\treturn match;",
        "\t}",
        "",
        "\t/**",
        "\t * @param {string} text",
        "\t * @param {LinkedList<string | Token>} tokenList",
        "\t * @param {any} grammar",
        "\t * @param {LinkedListNode<string | Token>} startNode",
        "\t * @param {number} startPos",
        "\t * @param {RematchOptions} [rematch]",
        "\t * @returns {void}",
        "\t * @private",
        "\t *",
        "\t * @typedef RematchOptions",
        "\t * @property {string} cause",
        "\t * @property {number} reach",
        "\t */",
        "\tfunction matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {",
        "\t\tfor (var token in grammar) {",
        "\t\t\tif (!grammar.hasOwnProperty(token) || !grammar[token]) {",
        "\t\t\t\tcontinue;",
        "\t\t\t}",
        "",
        "\t\t\tvar patterns = grammar[token];",
        "\t\t\tpatterns = Array.isArray(patterns) ? patterns : [patterns];",
        "",
        "\t\t\tfor (var j = 0; j < patterns.length; ++j) {",
        "\t\t\t\tif (rematch && rematch.cause == token + ',' + j) {",
        "\t\t\t\t\treturn;",
        "\t\t\t\t}",
        "",
        "\t\t\t\tvar patternObj = patterns[j];",
        "\t\t\t\tvar inside = patternObj.inside;",
        "\t\t\t\tvar lookbehind = !!patternObj.lookbehind;",
        "\t\t\t\tvar greedy = !!patternObj.greedy;",
        "\t\t\t\tvar alias = patternObj.alias;",
        "",
        "\t\t\t\tif (greedy && !patternObj.pattern.global) {",
        "\t\t\t\t\t// Without the global flag, lastIndex won't work",
        "\t\t\t\t\tvar flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];",
        "\t\t\t\t\tpatternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');",
        "\t\t\t\t}",
        "",
        "\t\t\t\t/** @type {RegExp} */",
        "\t\t\t\tvar pattern = patternObj.pattern || patternObj;",
        "",
        "\t\t\t\tfor ( // iterate the token list and keep track of the current token/string position",
        "\t\t\t\t\tvar currentNode = startNode.next, pos = startPos;",
        "\t\t\t\t\tcurrentNode !== tokenList.tail;",
        "\t\t\t\t\tpos += currentNode.value.length, currentNode = currentNode.next",
        "\t\t\t\t) {",
        "",
        "\t\t\t\t\tif (rematch && pos >= rematch.reach) {",
        "\t\t\t\t\t\tbreak;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tvar str = currentNode.value;",
        "",
        "\t\t\t\t\tif (tokenList.length > text.length) {",
        "\t\t\t\t\t\t// Something went terribly wrong, ABORT, ABORT!",
        "\t\t\t\t\t\treturn;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tif (str instanceof Token) {",
        "\t\t\t\t\t\tcontinue;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tvar removeCount = 1; // this is the to parameter of removeBetween",
        "\t\t\t\t\tvar match;",
        "",
        "\t\t\t\t\tif (greedy) {",
        "\t\t\t\t\t\tmatch = matchPattern(pattern, pos, text, lookbehind);",
        "\t\t\t\t\t\tif (!match) {",
        "\t\t\t\t\t\t\tbreak;",
        "\t\t\t\t\t\t}",
        "",
        "\t\t\t\t\t\tvar from = match.index;",
        "\t\t\t\t\t\tvar to = match.index + match[0].length;",
        "\t\t\t\t\t\tvar p = pos;",
        "",
        "\t\t\t\t\t\t// find the node that contains the match",
        "\t\t\t\t\t\tp += currentNode.value.length;",
        "\t\t\t\t\t\twhile (from >= p) {",
        "\t\t\t\t\t\t\tcurrentNode = currentNode.next;",
        "\t\t\t\t\t\t\tp += currentNode.value.length;",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t\t// adjust pos (and p)",
        "\t\t\t\t\t\tp -= currentNode.value.length;",
        "\t\t\t\t\t\tpos = p;",
        "",
        "\t\t\t\t\t\t// the current node is a Token, then the match starts inside another Token, which is invalid",
        "\t\t\t\t\t\tif (currentNode.value instanceof Token) {",
        "\t\t\t\t\t\t\tcontinue;",
        "\t\t\t\t\t\t}",
        "",
        "\t\t\t\t\t\t// find the last node which is affected by this match",
        "\t\t\t\t\t\tfor (",
        "\t\t\t\t\t\t\tvar k = currentNode;",
        "\t\t\t\t\t\t\tk !== tokenList.tail && (p < to || typeof k.value === 'string');",
        "\t\t\t\t\t\t\tk = k.next",
        "\t\t\t\t\t\t) {",
        "\t\t\t\t\t\t\tremoveCount++;",
        "\t\t\t\t\t\t\tp += k.value.length;",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t\tremoveCount--;",
        "",
        "\t\t\t\t\t\t// replace with the new match",
        "\t\t\t\t\t\tstr = text.slice(pos, p);",
        "\t\t\t\t\t\tmatch.index -= pos;",
        "\t\t\t\t\t} else {",
        "\t\t\t\t\t\tmatch = matchPattern(pattern, 0, str, lookbehind);",
        "\t\t\t\t\t\tif (!match) {",
        "\t\t\t\t\t\t\tcontinue;",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\t// eslint-disable-next-line no-redeclare",
        "\t\t\t\t\tvar from = match.index;",
        "\t\t\t\t\tvar matchStr = match[0];",
        "\t\t\t\t\tvar before = str.slice(0, from);",
        "\t\t\t\t\tvar after = str.slice(from + matchStr.length);",
        "",
        "\t\t\t\t\tvar reach = pos + str.length;",
        "\t\t\t\t\tif (rematch && reach > rematch.reach) {",
        "\t\t\t\t\t\trematch.reach = reach;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tvar removeFrom = currentNode.prev;",
        "",
        "\t\t\t\t\tif (before) {",
        "\t\t\t\t\t\tremoveFrom = addAfter(tokenList, removeFrom, before);",
        "\t\t\t\t\t\tpos += before.length;",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tremoveRange(tokenList, removeFrom, removeCount);",
        "",
        "\t\t\t\t\tvar wrapped = new Token(token, inside ? _.tokenize(matchStr, inside) : matchStr, alias, matchStr);",
        "\t\t\t\t\tcurrentNode = addAfter(tokenList, removeFrom, wrapped);",
        "",
        "\t\t\t\t\tif (after) {",
        "\t\t\t\t\t\taddAfter(tokenList, currentNode, after);",
        "\t\t\t\t\t}",
        "",
        "\t\t\t\t\tif (removeCount > 1) {",
        "\t\t\t\t\t\t// at least one Token object was removed, so we have to do some rematching",
        "\t\t\t\t\t\t// this can only happen if the current pattern is greedy",
        "",
        "\t\t\t\t\t\t/** @type {RematchOptions} */",
        "\t\t\t\t\t\tvar nestedRematch = {",
        "\t\t\t\t\t\t\tcause: token + ',' + j,",
        "\t\t\t\t\t\t\treach: reach",
        "\t\t\t\t\t\t};",
        "\t\t\t\t\t\tmatchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);",
        "",
        "\t\t\t\t\t\t// the reach might have been extended because of the rematching",
        "\t\t\t\t\t\tif (rematch && nestedRematch.reach > rematch.reach) {",
        "\t\t\t\t\t\t\trematch.reach = nestedRematch.reach;",
        "\t\t\t\t\t\t}",
        "\t\t\t\t\t}",
        "\t\t\t\t}",
        "\t\t\t}",
        "\t\t}",
        "\t}",
        "",
        "\t/**",
        "\t * @typedef LinkedListNode",
        "\t * @property {T} value",
        "\t * @property {LinkedListNode<T> | null} prev The previous node.",
        "\t * @property {LinkedListNode<T> | null} next The next node.",
        "\t * @template T",
        "\t * @private",
        "\t */",
        "",
        "\t/**",
        "\t * @template T",
        "\t * @private",
        "\t */",
        "\tfunction LinkedList() {",
        "\t\t/** @type {LinkedListNode<T>} */",
        "\t\tvar head = { value: null, prev: null, next: null };",
        "\t\t/** @type {LinkedListNode<T>} */",
        "\t\tvar tail = { value: null, prev: head, next: null };",
        "\t\thead.next = tail;",
        "",
        "\t\t/** @type {LinkedListNode<T>} */",
        "\t\tthis.head = head;",
        "\t\t/** @type {LinkedListNode<T>} */",
        "\t\tthis.tail = tail;",
        "\t\tthis.length = 0;",
        "\t}",
        "",
        "\t/**",
        "\t * Adds a new node with the given value to the list.",
        "\t *",
        "\t * @param {LinkedList<T>} list",
        "\t * @param {LinkedListNode<T>} node",
        "\t * @param {T} value",
        "\t * @returns {LinkedListNode<T>} The added node.",
        "\t * @template T",
        "\t */",
        "\tfunction addAfter(list, node, value) {",
        "\t\t// assumes that node != list.tail && values.length >= 0",
        "\t\tvar next = node.next;",
        "",
        "\t\tvar newNode = { value: value, prev: node, next: next };",
        "\t\tnode.next = newNode;",
        "\t\tnext.prev = newNode;",
        "\t\tlist.length++;",
        "",
        "\t\treturn newNode;",
        "\t}",
        "\t/**",
        "\t * Removes `count` nodes after the given node. The given node will not be removed.",
        "\t *",
        "\t * @param {LinkedList<T>} list",
        "\t * @param {LinkedListNode<T>} node",
        "\t * @param {number} count",
        "\t * @template T",
        "\t */",
        "\tfunction removeRange(list, node, count) {",
        "\t\tvar next = node.next;",
        "\t\tfor (var i = 0; i < count && next !== list.tail; i++) {",
        "\t\t\tnext = next.next;",
        "\t\t}",
        "\t\tnode.next = next;",
        "\t\tnext.prev = node;",
        "\t\tlist.length -= i;",
        "\t}",
        "\t/**",
        "\t * @param {LinkedList<T>} list",
        "\t * @returns {T[]}",
        "\t * @template T",
        "\t */",
        "\tfunction toArray(list) {",
        "\t\tvar array = [];",
        "\t\tvar node = list.head.next;",
        "\t\twhile (node !== list.tail) {",
        "\t\t\tarray.push(node.value);",
        "\t\t\tnode = node.next;",
        "\t\t}",
        "\t\treturn array;",
        "\t}",
        "",
        "",
        "\tif (!_self.document) {",
        "\t\tif (!_self.addEventListener) {",
        "\t\t\t// in Node.js",
        "\t\t\treturn _;",
        "\t\t}",
        "",
        "\t\tif (!_.disableWorkerMessageHandler) {",
        "\t\t\t// In worker",
        "\t\t\t_self.addEventListener('message', function (evt) {",
        "\t\t\t\tvar message = JSON.parse(evt.data);",
        "\t\t\t\tvar lang = message.language;",
        "\t\t\t\tvar code = message.code;",
        "\t\t\t\tvar immediateClose = message.immediateClose;",
        "",
        "\t\t\t\t_self.postMessage(_.highlight(code, _.languages[lang], lang));",
        "\t\t\t\tif (immediateClose) {",
        "\t\t\t\t\t_self.close();",
        "\t\t\t\t}",
        "\t\t\t}, false);",
        "\t\t}",
        "",
        "\t\treturn _;",
        "\t}",
        "",
        "\t// Get current script and highlight",
        "\tvar script = _.util.currentScript();",
        "",
        "\tif (script) {",
        "\t\t_.filename = script.src;",
        "",
        "\t\tif (script.hasAttribute('data-manual')) {",
        "\t\t\t_.manual = true;",
        "\t\t}",
        "\t}",
        "",
        "\tfunction highlightAutomaticallyCallback() {",
        "\t\tif (!_.manual) {",
        "\t\t\t_.highlightAll();",
        "\t\t}",
        "\t}",
        "",
        "\tif (!_.manual) {",
        "\t\t// If the document state is \"loading\", then we'll use DOMContentLoaded.",
        "\t\t// If the document state is \"interactive\" and the prism.js script is deferred, then we'll also use the",
        "\t\t// DOMContentLoaded event because there might be some plugins or languages which have also been deferred and they",
        "..."
    ]
}