{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) ",
            "file_path": "components/prism-javascript.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 101
                }
            ],
            "class_code": [
                "Prism.languages.javascript = Prism.languages.extend('clike', {",
                "\t'class-name': [",
                "\t\tPrism.languages.clike['class-name'],",
                "\t\t{",
                "\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:prototype|constructor))/,",
                "\t\t\tlookbehind: true",
                "\t\t}",
                "\t],",
                "\t'keyword': [",
                "\t\t{",
                "\t\t\tpattern: /((?:^|})\\s*)(?:catch|finally)\\b/,",
                "\t\t\tlookbehind: true",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\\s*[\\[$\\w\\xA0-\\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,",
                "\t\t\tlookbehind: true",
                "\t\t},",
                "\t],",
                "\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)",
                "\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,",
                "\t'number': /\\b(?:(?:0[xX](?:[\\dA-Fa-f](?:_[\\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\\d(?:_\\d)?)+n|NaN|Infinity)\\b|(?:\\b(?:\\d(?:_\\d)?)+\\.?(?:\\d(?:_\\d)?)*|\\B\\.(?:\\d(?:_\\d)?)+)(?:[Ee][+-]?(?:\\d(?:_\\d)?)+)?/,",
                "\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/",
                "});",
                "",
                "Prism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/;",
                "",
                "Prism.languages.insertBefore('javascript', 'keyword', {",
                "\t'regex': {",
                "\t\tpattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyus]{0,6}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,",
                "\t\tlookbehind: true,",
                "\t\tgreedy: true,",
                "\t\tinside: {",
                "\t\t\t'regex-source': {",
                "\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,",
                "\t\t\t\tlookbehind: true,",
                "\t\t\t\talias: 'language-regex',",
                "\t\t\t\tinside: Prism.languages.regex",
                "\t\t\t},",
                "\t\t\t'regex-flags': /[a-z]+$/,",
                "\t\t\t'regex-delimiter': /^\\/|\\/$/",
                "\t\t}",
                "\t},",
                "\t// This must be declared before keyword because we use \"function\" inside the look-forward",
                "\t'function-variable': {",
                "\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,",
                "\t\talias: 'function'",
                "\t},",
                "\t'parameter': [",
                "\t\t{",
                "\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: Prism.languages.javascript",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,",
                "\t\t\tinside: Prism.languages.javascript",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: Prism.languages.javascript",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: Prism.languages.javascript",
                "\t\t}",
                "\t],",
                "\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/",
                "});",
                "",
                "Prism.languages.insertBefore('javascript', 'string', {",
                "\t'template-string': {",
                "\t\tpattern: /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\\${)[^\\\\`])*`/,",
                "\t\tgreedy: true,",
                "\t\tinside: {",
                "\t\t\t'template-punctuation': {",
                "\t\t\t\tpattern: /^`|`$/,",
                "\t\t\t\talias: 'string'",
                "\t\t\t},",
                "\t\t\t'interpolation': {",
                "\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,",
                "\t\t\t\tlookbehind: true,",
                "\t\t\t\tinside: {",
                "\t\t\t\t\t'interpolation-punctuation': {",
                "\t\t\t\t\t\tpattern: /^\\${|}$/,",
                "\t\t\t\t\t\talias: 'punctuation'",
                "\t\t\t\t\t},",
                "\t\t\t\t\trest: Prism.languages.javascript",
                "\t\t\t\t}",
                "\t\t\t},",
                "\t\t\t'string': /[\\s\\S]+/",
                "\t\t}",
                "\t}",
                "});",
                "",
                "if (Prism.languages.markup) {",
                "\tPrism.languages.markup.tag.addInlined('script', 'javascript');",
                "}",
                "",
                "Prism.languages.js = Prism.languages.javascript;"
            ]
        },
        "2": {
            "class_name": "  (not found) ",
            "file_path": "components/prism-js-templates.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 346
                }
            ],
            "class_code": [
                "(function (Prism) {",
                "",
                "\tvar templateString = Prism.languages.javascript['template-string'];",
                "",
                "\t// see the pattern in prism-javascript.js",
                "\tvar templateLiteralPattern = templateString.pattern.source;",
                "\tvar interpolationObject = templateString.inside['interpolation'];",
                "\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];",
                "\tvar interpolationPattern = interpolationObject.pattern.source;",
                "",
                "",
                "\t/**",
                "\t * Creates a new pattern to match a template string with a special tag.",
                "\t *",
                "\t * This will return `undefined` if there is no grammar with the given language id.",
                "\t *",
                "\t * @param {string} language The language id of the embedded language. E.g. `markdown`.",
                "\t * @param {string} tag The regex pattern to match the tag.",
                "\t * @returns {object | undefined}",
                "\t * @example",
                "\t * createTemplate('css', /\\bcss/.source);",
                "\t */",
                "\tfunction createTemplate(language, tag) {",
                "\t\tif (!Prism.languages[language]) {",
                "\t\t\treturn undefined;",
                "\t\t}",
                "",
                "\t\treturn {",
                "\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),",
                "\t\t\tlookbehind: true,",
                "\t\t\tgreedy: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'template-punctuation': {",
                "\t\t\t\t\tpattern: /^`|`$/,",
                "\t\t\t\t\talias: 'string'",
                "\t\t\t\t},",
                "\t\t\t\t'embedded-code': {",
                "\t\t\t\t\tpattern: /[\\s\\S]+/,",
                "\t\t\t\t\talias: language",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t};",
                "\t}",
                "",
                "",
                "\tPrism.languages.javascript['template-string'] = [",
                "\t\t// styled-jsx:",
                "\t\t//   css`a { color: #25F; }`",
                "\t\t// styled-components:",
                "\t\t//   styled.h1`color: red;`",
                "\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),",
                "",
                "\t\t// html`<p></p>`",
                "\t\t// div.innerHTML = `<p></p>`",
                "\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),",
                "",
                "\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`",
                "\t\tcreateTemplate('svg', /\\bsvg/.source),",
                "",
                "\t\t// md`# h1`, markdown`## h2`",
                "\t\tcreateTemplate('markdown', /\\b(?:md|markdown)/.source),",
                "",
                "\t\t// gql`...`, graphql`...`, graphql.experimental`...`",
                "\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),",
                "",
                "\t\t// vanilla template string",
                "\t\ttemplateString",
                "\t].filter(Boolean);",
                "",
                "",
                "\t/**",
                "\t * Returns a specific placeholder literal for the given language.",
                "\t *",
                "\t * @param {number} counter",
                "\t * @param {string} language",
                "\t * @returns {string}",
                "\t */",
                "\tfunction getPlaceholder(counter, language) {",
                "\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';",
                "\t}",
                "",
                "\t/**",
                "\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.",
                "\t *",
                "\t * @param {string} code",
                "\t * @param {any} grammar",
                "\t * @param {string} language",
                "\t * @returns {(string|Token)[]}",
                "\t */",
                "\tfunction tokenizeWithHooks(code, grammar, language) {",
                "\t\tvar env = {",
                "\t\t\tcode: code,",
                "\t\t\tgrammar: grammar,",
                "\t\t\tlanguage: language",
                "\t\t};",
                "\t\tPrism.hooks.run('before-tokenize', env);",
                "\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);",
                "\t\tPrism.hooks.run('after-tokenize', env);",
                "\t\treturn env.tokens;",
                "\t}",
                "",
                "\t/**",
                "\t * Returns the token of the given JavaScript interpolation expression.",
                "\t *",
                "\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`",
                "\t * @returns {Token}",
                "\t */",
                "\tfunction tokenizeInterpolationExpression(expression) {",
                "\t\tvar tempGrammar = {};",
                "\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;",
                "",
                "\t\t/** @type {Array} */",
                "\t\tvar tokens = Prism.tokenize(expression, tempGrammar);",
                "\t\tif (tokens.length === 3) {",
                "\t\t\t/**",
                "\t\t\t * The token array will look like this",
                "\t\t\t * [",
                "\t\t\t *     [\"interpolation-punctuation\", \"${\"]",
                "\t\t\t *     \"...\" // JavaScript expression of the interpolation",
                "\t\t\t *     [\"interpolation-punctuation\", \"}\"]",
                "\t\t\t * ]",
                "\t\t\t */",
                "",
                "\t\t\tvar args = [1, 1];",
                "\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));",
                "",
                "\t\t\ttokens.splice.apply(tokens, args);",
                "\t\t}",
                "",
                "\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);",
                "\t}",
                "",
                "\t/**",
                "\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.",
                "\t *",
                "\t * This function has 3 phases:",
                "\t *",
                "\t * 1. Replace all JavaScript interpolation expression with a placeholder.",
                "\t *    The placeholder will have the syntax of a identify of the target language.",
                "\t * 2. Tokenize the code with placeholders.",
                "\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.",
                "\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been",
                "\t *    tokenized as two tokens by the grammar of the embedded language.",
                "\t *",
                "\t * @param {string} code",
                "\t * @param {object} grammar",
                "\t * @param {string} language",
                "\t * @returns {Token}",
                "\t */",
                "\tfunction tokenizeEmbedded(code, grammar, language) {",
                "\t\t// 1. First filter out all interpolations",
                "",
                "\t\t// because they might be escaped, we need a lookbehind, so we use Prism",
                "\t\t/** @type {(Token|string)[]} */",
                "\t\tvar _tokens = Prism.tokenize(code, {",
                "\t\t\t'interpolation': {",
                "\t\t\t\tpattern: RegExp(interpolationPattern),",
                "\t\t\t\tlookbehind: true",
                "\t\t\t}",
                "\t\t});",
                "",
                "\t\t// replace all interpolations with a placeholder which is not in the code already",
                "\t\tvar placeholderCounter = 0;",
                "\t\t/** @type {Object<string, string>} */",
                "\t\tvar placeholderMap = {};",
                "\t\tvar embeddedCode = _tokens.map(function (token) {",
                "\t\t\tif (typeof token === 'string') {",
                "\t\t\t\treturn token;",
                "\t\t\t} else {",
                "\t\t\t\tvar interpolationExpression = token.content;",
                "",
                "\t\t\t\tvar placeholder;",
                "\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { }",
                "\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;",
                "\t\t\t\treturn placeholder;",
                "\t\t\t}",
                "\t\t}).join('');",
                "",
                "",
                "\t\t// 2. Tokenize the embedded code",
                "",
                "\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);",
                "",
                "",
                "\t\t// 3. Re-insert the interpolation",
                "",
                "\t\tvar placeholders = Object.keys(placeholderMap);",
                "\t\tplaceholderCounter = 0;",
                "",
                "\t\t/**",
                "\t\t *",
                "\t\t * @param {(Token|string)[]} tokens",
                "\t\t * @returns {void}",
                "\t\t */",
                "\t\tfunction walkTokens(tokens) {",
                "\t\t\tfor (var i = 0; i < tokens.length; i++) {",
                "\t\t\t\tif (placeholderCounter >= placeholders.length) {",
                "\t\t\t\t\treturn;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tvar token = tokens[i];",
                "",
                "\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {",
                "\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];",
                "\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);",
                "",
                "\t\t\t\t\tvar index = s.indexOf(placeholder);",
                "\t\t\t\t\tif (index !== -1) {",
                "\t\t\t\t\t\t++placeholderCounter;",
                "",
                "\t\t\t\t\t\tvar before = s.substring(0, index);",
                "\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);",
                "\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);",
                "",
                "\t\t\t\t\t\tvar replacement = [];",
                "\t\t\t\t\t\tif (before) {",
                "\t\t\t\t\t\t\treplacement.push(before);",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t\treplacement.push(middle);",
                "\t\t\t\t\t\tif (after) {",
                "\t\t\t\t\t\t\tvar afterTokens = [after];",
                "\t\t\t\t\t\t\twalkTokens(afterTokens);",
                "\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\tif (typeof token === 'string') {",
                "\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));",
                "\t\t\t\t\t\t\ti += replacement.length - 1;",
                "\t\t\t\t\t\t} else {",
                "\t\t\t\t\t\t\ttoken.content = replacement;",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t}",
                "\t\t\t\t} else {",
                "\t\t\t\t\tvar content = token.content;",
                "\t\t\t\t\tif (Array.isArray(content)) {",
                "\t\t\t\t\t\twalkTokens(content);",
                "\t\t\t\t\t} else {",
                "\t\t\t\t\t\twalkTokens([content]);",
                "\t\t\t\t\t}",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "\t\twalkTokens(embeddedTokens);",
                "",
                "\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);",
                "\t}",
                "",
                "\t/**",
                "\t * The languages for which JS templating will handle tagged template literals.",
                "\t *",
                "\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.",
                "\t */",
                "\tvar supportedLanguages = {",
                "\t\t'javascript': true,",
                "\t\t'js': true,",
                "\t\t'typescript': true,",
                "\t\t'ts': true,",
                "\t\t'jsx': true,",
                "\t\t'tsx': true,",
                "\t};",
                "\tPrism.hooks.add('after-tokenize', function (env) {",
                "\t\tif (!(env.language in supportedLanguages)) {",
                "\t\t\treturn;",
                "\t\t}",
                "",
                "\t\t/**",
                "\t\t * Finds and tokenizes all template strings with an embedded languages.",
                "\t\t *",
                "\t\t * @param {(Token | string)[]} tokens",
                "\t\t * @returns {void}",
                "\t\t */",
                "\t\tfunction findTemplateStrings(tokens) {",
                "\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {",
                "\t\t\t\tvar token = tokens[i];",
                "",
                "\t\t\t\tif (typeof token === 'string') {",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tvar content = token.content;",
                "\t\t\t\tif (!Array.isArray(content)) {",
                "\t\t\t\t\tif (typeof content !== 'string') {",
                "\t\t\t\t\t\tfindTemplateStrings([content]);",
                "\t\t\t\t\t}",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tif (token.type === 'template-string') {",
                "\t\t\t\t\t/**",
                "\t\t\t\t\t * A JavaScript template-string token will look like this:",
                "\t\t\t\t\t *",
                "\t\t\t\t\t * [\"template-string\", [",
                "\t\t\t\t\t *     [\"template-punctuation\", \"`\"],",
                "\t\t\t\t\t *     (",
                "\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.",
                "\t\t\t\t\t *         or",
                "\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.",
                "\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.",
                "\t\t\t\t\t *     ),",
                "\t\t\t\t\t *     [\"template-punctuation\", \"`\"]",
                "\t\t\t\t\t * ]]",
                "\t\t\t\t\t */",
                "",
                "\t\t\t\t\tvar embedded = content[1];",
                "\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {",
                "\t\t\t\t\t\t// get string content",
                "\t\t\t\t\t\tvar code = stringContent(embedded);",
                "",
                "\t\t\t\t\t\tvar alias = embedded.alias;",
                "\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;",
                "",
                "\t\t\t\t\t\tvar grammar = Prism.languages[language];",
                "\t\t\t\t\t\tif (!grammar) {",
                "\t\t\t\t\t\t\t// the embedded language isn't registered.",
                "\t\t\t\t\t\t\tcontinue;",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);",
                "\t\t\t\t\t}",
                "\t\t\t\t} else {",
                "\t\t\t\t\tfindTemplateStrings(content);",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "",
                "\t\tfindTemplateStrings(env.tokens);",
                "\t});",
                "",
                "",
                "\t/**",
                "\t * Returns the string content of a token or token stream.",
                "\t *",
                "\t * @param {string | Token | (string | Token)[]} value",
                "\t * @returns {string}",
                "\t */",
                "\tfunction stringContent(value) {",
                "\t\tif (typeof value === 'string') {",
                "\t\t\treturn value;",
                "\t\t} else if (Array.isArray(value)) {",
                "\t\t\treturn value.map(stringContent).join('');",
                "\t\t} else {",
                "\t\t\treturn stringContent(value.content);",
                "\t\t}",
                "\t}",
                "",
                "}(Prism));"
            ]
        },
        "3": {
            "class_name": "Prism.languages.javascript (not found) ",
            "file_path": "components/prism-javascript.js",
            "class_details": [
                {
                    "name": "Prism.languages.javascript",
                    "start_line": 1,
                    "end_line": 101
                }
            ],
            "class_code": [
                "Prism.languages.javascript = Prism.languages.extend('clike', {",
                "\t'class-name': [",
                "\t\tPrism.languages.clike['class-name'],",
                "\t\t{",
                "\t\t\tpattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:prototype|constructor))/,",
                "\t\t\tlookbehind: true",
                "\t\t}",
                "\t],",
                "\t'keyword': [",
                "\t\t{",
                "\t\t\tpattern: /((?:^|})\\s*)(?:catch|finally)\\b/,",
                "\t\t\tlookbehind: true",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|(?:get|set)(?=\\s*[\\[$\\w\\xA0-\\uFFFF])|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,",
                "\t\t\tlookbehind: true",
                "\t\t},",
                "\t],",
                "\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)",
                "\t'function': /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,",
                "\t'number': /\\b(?:(?:0[xX](?:[\\dA-Fa-f](?:_[\\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\\d(?:_\\d)?)+n|NaN|Infinity)\\b|(?:\\b(?:\\d(?:_\\d)?)+\\.?(?:\\d(?:_\\d)?)*|\\B\\.(?:\\d(?:_\\d)?)+)(?:[Ee][+-]?(?:\\d(?:_\\d)?)+)?/,",
                "\t'operator': /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/",
                "});",
                "",
                "Prism.languages.javascript['class-name'][0].pattern = /(\\b(?:class|interface|extends|implements|instanceof|new)\\s+)[\\w.\\\\]+/;",
                "",
                "Prism.languages.insertBefore('javascript', 'keyword', {",
                "\t'regex': {",
                "\t\tpattern: /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)\\/(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[gimyus]{0,6}(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/,",
                "\t\tlookbehind: true,",
                "\t\tgreedy: true,",
                "\t\tinside: {",
                "\t\t\t'regex-source': {",
                "\t\t\t\tpattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,",
                "\t\t\t\tlookbehind: true,",
                "\t\t\t\talias: 'language-regex',",
                "\t\t\t\tinside: Prism.languages.regex",
                "\t\t\t},",
                "\t\t\t'regex-flags': /[a-z]+$/,",
                "\t\t\t'regex-delimiter': /^\\/|\\/$/",
                "\t\t}",
                "\t},",
                "\t// This must be declared before keyword because we use \"function\" inside the look-forward",
                "\t'function-variable': {",
                "\t\tpattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,",
                "\t\talias: 'function'",
                "\t},",
                "\t'parameter': [",
                "\t\t{",
                "\t\t\tpattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: Prism.languages.javascript",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,",
                "\t\t\tinside: Prism.languages.javascript",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: Prism.languages.javascript",
                "\t\t},",
                "\t\t{",
                "\t\t\tpattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,",
                "\t\t\tlookbehind: true,",
                "\t\t\tinside: Prism.languages.javascript",
                "\t\t}",
                "\t],",
                "\t'constant': /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/",
                "});",
                "",
                "Prism.languages.insertBefore('javascript', 'string', {",
                "\t'template-string': {",
                "\t\tpattern: /`(?:\\\\[\\s\\S]|\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\\${)[^\\\\`])*`/,",
                "\t\tgreedy: true,",
                "\t\tinside: {",
                "\t\t\t'template-punctuation': {",
                "\t\t\t\tpattern: /^`|`$/,",
                "\t\t\t\talias: 'string'",
                "\t\t\t},",
                "\t\t\t'interpolation': {",
                "\t\t\t\tpattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/,",
                "\t\t\t\tlookbehind: true,",
                "\t\t\t\tinside: {",
                "\t\t\t\t\t'interpolation-punctuation': {",
                "\t\t\t\t\t\tpattern: /^\\${|}$/,",
                "\t\t\t\t\t\talias: 'punctuation'",
                "\t\t\t\t\t},",
                "\t\t\t\t\trest: Prism.languages.javascript",
                "\t\t\t\t}",
                "\t\t\t},",
                "\t\t\t'string': /[\\s\\S]+/",
                "\t\t}",
                "\t}",
                "});",
                "",
                "if (Prism.languages.markup) {",
                "\tPrism.languages.markup.tag.addInlined('script', 'javascript');",
                "}",
                "",
                "Prism.languages.js = Prism.languages.javascript;"
            ]
        },
        "4": {
            "class_name": "Prism.languages.javascript['template-string'] (not found) ",
            "file_path": "components/prism-js-templates.js",
            "class_details": [
                {
                    "name": "Prism.languages.javascript['template-string']",
                    "start_line": 1,
                    "end_line": 346
                }
            ],
            "class_code": [
                "(function (Prism) {",
                "",
                "\tvar templateString = Prism.languages.javascript['template-string'];",
                "",
                "\t// see the pattern in prism-javascript.js",
                "\tvar templateLiteralPattern = templateString.pattern.source;",
                "\tvar interpolationObject = templateString.inside['interpolation'];",
                "\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];",
                "\tvar interpolationPattern = interpolationObject.pattern.source;",
                "",
                "",
                "\t/**",
                "\t * Creates a new pattern to match a template string with a special tag.",
                "\t *",
                "\t * This will return `undefined` if there is no grammar with the given language id.",
                "\t *",
                "\t * @param {string} language The language id of the embedded language. E.g. `markdown`.",
                "\t * @param {string} tag The regex pattern to match the tag.",
                "\t * @returns {object | undefined}",
                "\t * @example",
                "\t * createTemplate('css', /\\bcss/.source);",
                "\t */",
                "\tfunction createTemplate(language, tag) {",
                "\t\tif (!Prism.languages[language]) {",
                "\t\t\treturn undefined;",
                "\t\t}",
                "",
                "\t\treturn {",
                "\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),",
                "\t\t\tlookbehind: true,",
                "\t\t\tgreedy: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'template-punctuation': {",
                "\t\t\t\t\tpattern: /^`|`$/,",
                "\t\t\t\t\talias: 'string'",
                "\t\t\t\t},",
                "\t\t\t\t'embedded-code': {",
                "\t\t\t\t\tpattern: /[\\s\\S]+/,",
                "\t\t\t\t\talias: language",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t};",
                "\t}",
                "",
                "",
                "\tPrism.languages.javascript['template-string'] = [",
                "\t\t// styled-jsx:",
                "\t\t//   css`a { color: #25F; }`",
                "\t\t// styled-components:",
                "\t\t//   styled.h1`color: red;`",
                "\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),",
                "",
                "\t\t// html`<p></p>`",
                "\t\t// div.innerHTML = `<p></p>`",
                "\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),",
                "",
                "\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`",
                "\t\tcreateTemplate('svg', /\\bsvg/.source),",
                "",
                "\t\t// md`# h1`, markdown`## h2`",
                "\t\tcreateTemplate('markdown', /\\b(?:md|markdown)/.source),",
                "",
                "\t\t// gql`...`, graphql`...`, graphql.experimental`...`",
                "\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),",
                "",
                "\t\t// vanilla template string",
                "\t\ttemplateString",
                "\t].filter(Boolean);",
                "",
                "",
                "\t/**",
                "\t * Returns a specific placeholder literal for the given language.",
                "\t *",
                "\t * @param {number} counter",
                "\t * @param {string} language",
                "\t * @returns {string}",
                "\t */",
                "\tfunction getPlaceholder(counter, language) {",
                "\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';",
                "\t}",
                "",
                "\t/**",
                "\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.",
                "\t *",
                "\t * @param {string} code",
                "\t * @param {any} grammar",
                "\t * @param {string} language",
                "\t * @returns {(string|Token)[]}",
                "\t */",
                "\tfunction tokenizeWithHooks(code, grammar, language) {",
                "\t\tvar env = {",
                "\t\t\tcode: code,",
                "\t\t\tgrammar: grammar,",
                "\t\t\tlanguage: language",
                "\t\t};",
                "\t\tPrism.hooks.run('before-tokenize', env);",
                "\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);",
                "\t\tPrism.hooks.run('after-tokenize', env);",
                "\t\treturn env.tokens;",
                "\t}",
                "",
                "\t/**",
                "\t * Returns the token of the given JavaScript interpolation expression.",
                "\t *",
                "\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`",
                "\t * @returns {Token}",
                "\t */",
                "\tfunction tokenizeInterpolationExpression(expression) {",
                "\t\tvar tempGrammar = {};",
                "\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;",
                "",
                "\t\t/** @type {Array} */",
                "\t\tvar tokens = Prism.tokenize(expression, tempGrammar);",
                "\t\tif (tokens.length === 3) {",
                "\t\t\t/**",
                "\t\t\t * The token array will look like this",
                "\t\t\t * [",
                "\t\t\t *     [\"interpolation-punctuation\", \"${\"]",
                "\t\t\t *     \"...\" // JavaScript expression of the interpolation",
                "\t\t\t *     [\"interpolation-punctuation\", \"}\"]",
                "\t\t\t * ]",
                "\t\t\t */",
                "",
                "\t\t\tvar args = [1, 1];",
                "\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));",
                "",
                "\t\t\ttokens.splice.apply(tokens, args);",
                "\t\t}",
                "",
                "\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);",
                "\t}",
                "",
                "\t/**",
                "\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.",
                "\t *",
                "\t * This function has 3 phases:",
                "\t *",
                "\t * 1. Replace all JavaScript interpolation expression with a placeholder.",
                "\t *    The placeholder will have the syntax of a identify of the target language.",
                "\t * 2. Tokenize the code with placeholders.",
                "\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.",
                "\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been",
                "\t *    tokenized as two tokens by the grammar of the embedded language.",
                "\t *",
                "\t * @param {string} code",
                "\t * @param {object} grammar",
                "\t * @param {string} language",
                "\t * @returns {Token}",
                "\t */",
                "\tfunction tokenizeEmbedded(code, grammar, language) {",
                "\t\t// 1. First filter out all interpolations",
                "",
                "\t\t// because they might be escaped, we need a lookbehind, so we use Prism",
                "\t\t/** @type {(Token|string)[]} */",
                "\t\tvar _tokens = Prism.tokenize(code, {",
                "\t\t\t'interpolation': {",
                "\t\t\t\tpattern: RegExp(interpolationPattern),",
                "\t\t\t\tlookbehind: true",
                "\t\t\t}",
                "\t\t});",
                "",
                "\t\t// replace all interpolations with a placeholder which is not in the code already",
                "\t\tvar placeholderCounter = 0;",
                "\t\t/** @type {Object<string, string>} */",
                "\t\tvar placeholderMap = {};",
                "\t\tvar embeddedCode = _tokens.map(function (token) {",
                "\t\t\tif (typeof token === 'string') {",
                "\t\t\t\treturn token;",
                "\t\t\t} else {",
                "\t\t\t\tvar interpolationExpression = token.content;",
                "",
                "\t\t\t\tvar placeholder;",
                "\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { }",
                "\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;",
                "\t\t\t\treturn placeholder;",
                "\t\t\t}",
                "\t\t}).join('');",
                "",
                "",
                "\t\t// 2. Tokenize the embedded code",
                "",
                "\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);",
                "",
                "",
                "\t\t// 3. Re-insert the interpolation",
                "",
                "\t\tvar placeholders = Object.keys(placeholderMap);",
                "\t\tplaceholderCounter = 0;",
                "",
                "\t\t/**",
                "\t\t *",
                "\t\t * @param {(Token|string)[]} tokens",
                "\t\t * @returns {void}",
                "\t\t */",
                "\t\tfunction walkTokens(tokens) {",
                "\t\t\tfor (var i = 0; i < tokens.length; i++) {",
                "\t\t\t\tif (placeholderCounter >= placeholders.length) {",
                "\t\t\t\t\treturn;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tvar token = tokens[i];",
                "",
                "\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {",
                "\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];",
                "\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);",
                "",
                "\t\t\t\t\tvar index = s.indexOf(placeholder);",
                "\t\t\t\t\tif (index !== -1) {",
                "\t\t\t\t\t\t++placeholderCounter;",
                "",
                "\t\t\t\t\t\tvar before = s.substring(0, index);",
                "\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);",
                "\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);",
                "",
                "\t\t\t\t\t\tvar replacement = [];",
                "\t\t\t\t\t\tif (before) {",
                "\t\t\t\t\t\t\treplacement.push(before);",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t\treplacement.push(middle);",
                "\t\t\t\t\t\tif (after) {",
                "\t\t\t\t\t\t\tvar afterTokens = [after];",
                "\t\t\t\t\t\t\twalkTokens(afterTokens);",
                "\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\tif (typeof token === 'string') {",
                "\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));",
                "\t\t\t\t\t\t\ti += replacement.length - 1;",
                "\t\t\t\t\t\t} else {",
                "\t\t\t\t\t\t\ttoken.content = replacement;",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t}",
                "\t\t\t\t} else {",
                "\t\t\t\t\tvar content = token.content;",
                "\t\t\t\t\tif (Array.isArray(content)) {",
                "\t\t\t\t\t\twalkTokens(content);",
                "\t\t\t\t\t} else {",
                "\t\t\t\t\t\twalkTokens([content]);",
                "\t\t\t\t\t}",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "\t\twalkTokens(embeddedTokens);",
                "",
                "\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);",
                "\t}",
                "",
                "\t/**",
                "\t * The languages for which JS templating will handle tagged template literals.",
                "\t *",
                "\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.",
                "\t */",
                "\tvar supportedLanguages = {",
                "\t\t'javascript': true,",
                "\t\t'js': true,",
                "\t\t'typescript': true,",
                "\t\t'ts': true,",
                "\t\t'jsx': true,",
                "\t\t'tsx': true,",
                "\t};",
                "\tPrism.hooks.add('after-tokenize', function (env) {",
                "\t\tif (!(env.language in supportedLanguages)) {",
                "\t\t\treturn;",
                "\t\t}",
                "",
                "\t\t/**",
                "\t\t * Finds and tokenizes all template strings with an embedded languages.",
                "\t\t *",
                "\t\t * @param {(Token | string)[]} tokens",
                "\t\t * @returns {void}",
                "\t\t */",
                "\t\tfunction findTemplateStrings(tokens) {",
                "\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {",
                "\t\t\t\tvar token = tokens[i];",
                "",
                "\t\t\t\tif (typeof token === 'string') {",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tvar content = token.content;",
                "\t\t\t\tif (!Array.isArray(content)) {",
                "\t\t\t\t\tif (typeof content !== 'string') {",
                "\t\t\t\t\t\tfindTemplateStrings([content]);",
                "\t\t\t\t\t}",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tif (token.type === 'template-string') {",
                "\t\t\t\t\t/**",
                "\t\t\t\t\t * A JavaScript template-string token will look like this:",
                "\t\t\t\t\t *",
                "\t\t\t\t\t * [\"template-string\", [",
                "\t\t\t\t\t *     [\"template-punctuation\", \"`\"],",
                "\t\t\t\t\t *     (",
                "\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.",
                "\t\t\t\t\t *         or",
                "\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.",
                "\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.",
                "\t\t\t\t\t *     ),",
                "\t\t\t\t\t *     [\"template-punctuation\", \"`\"]",
                "\t\t\t\t\t * ]]",
                "\t\t\t\t\t */",
                "",
                "\t\t\t\t\tvar embedded = content[1];",
                "\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {",
                "\t\t\t\t\t\t// get string content",
                "\t\t\t\t\t\tvar code = stringContent(embedded);",
                "",
                "\t\t\t\t\t\tvar alias = embedded.alias;",
                "\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;",
                "",
                "\t\t\t\t\t\tvar grammar = Prism.languages[language];",
                "\t\t\t\t\t\tif (!grammar) {",
                "\t\t\t\t\t\t\t// the embedded language isn't registered.",
                "\t\t\t\t\t\t\tcontinue;",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);",
                "\t\t\t\t\t}",
                "\t\t\t\t} else {",
                "\t\t\t\t\tfindTemplateStrings(content);",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "",
                "\t\tfindTemplateStrings(env.tokens);",
                "\t});",
                "",
                "",
                "\t/**",
                "\t * Returns the string content of a token or token stream.",
                "\t *",
                "\t * @param {string | Token | (string | Token)[]} value",
                "\t * @returns {string}",
                "\t */",
                "\tfunction stringContent(value) {",
                "\t\tif (typeof value === 'string') {",
                "\t\t\treturn value;",
                "\t\t} else if (Array.isArray(value)) {",
                "\t\t\treturn value.map(stringContent).join('');",
                "\t\t} else {",
                "\t\t\treturn stringContent(value.content);",
                "\t\t}",
                "\t}",
                "",
                "}(Prism));"
            ]
        }
    },
    "bug_functions": {
        "5": {
            "function_name": "createTemplate (not found) ",
            "file_path": "components/prism-js-templates.js",
            "function_details": [
                {
                    "name": "createTemplate",
                    "start_line": 1,
                    "end_line": 346
                }
            ],
            "function_code": [
                "(function (Prism) {",
                "",
                "\tvar templateString = Prism.languages.javascript['template-string'];",
                "",
                "\t// see the pattern in prism-javascript.js",
                "\tvar templateLiteralPattern = templateString.pattern.source;",
                "\tvar interpolationObject = templateString.inside['interpolation'];",
                "\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];",
                "\tvar interpolationPattern = interpolationObject.pattern.source;",
                "",
                "",
                "\t/**",
                "\t * Creates a new pattern to match a template string with a special tag.",
                "\t *",
                "\t * This will return `undefined` if there is no grammar with the given language id.",
                "\t *",
                "\t * @param {string} language The language id of the embedded language. E.g. `markdown`.",
                "\t * @param {string} tag The regex pattern to match the tag.",
                "\t * @returns {object | undefined}",
                "\t * @example",
                "\t * createTemplate('css', /\\bcss/.source);",
                "\t */",
                "\tfunction createTemplate(language, tag) {",
                "\t\tif (!Prism.languages[language]) {",
                "\t\t\treturn undefined;",
                "\t\t}",
                "",
                "\t\treturn {",
                "\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),",
                "\t\t\tlookbehind: true,",
                "\t\t\tgreedy: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'template-punctuation': {",
                "\t\t\t\t\tpattern: /^`|`$/,",
                "\t\t\t\t\talias: 'string'",
                "\t\t\t\t},",
                "\t\t\t\t'embedded-code': {",
                "\t\t\t\t\tpattern: /[\\s\\S]+/,",
                "\t\t\t\t\talias: language",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t};",
                "\t}",
                "",
                "",
                "\tPrism.languages.javascript['template-string'] = [",
                "\t\t// styled-jsx:",
                "\t\t//   css`a { color: #25F; }`",
                "\t\t// styled-components:",
                "\t\t//   styled.h1`color: red;`",
                "\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),",
                "",
                "\t\t// html`<p></p>`",
                "\t\t// div.innerHTML = `<p></p>`",
                "\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),",
                "",
                "\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`",
                "\t\tcreateTemplate('svg', /\\bsvg/.source),",
                "",
                "\t\t// md`# h1`, markdown`## h2`",
                "\t\tcreateTemplate('markdown', /\\b(?:md|markdown)/.source),",
                "",
                "\t\t// gql`...`, graphql`...`, graphql.experimental`...`",
                "\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),",
                "",
                "\t\t// vanilla template string",
                "\t\ttemplateString",
                "\t].filter(Boolean);",
                "",
                "",
                "\t/**",
                "\t * Returns a specific placeholder literal for the given language.",
                "\t *",
                "\t * @param {number} counter",
                "\t * @param {string} language",
                "\t * @returns {string}",
                "\t */",
                "\tfunction getPlaceholder(counter, language) {",
                "\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';",
                "\t}",
                "",
                "\t/**",
                "\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.",
                "\t *",
                "\t * @param {string} code",
                "\t * @param {any} grammar",
                "\t * @param {string} language",
                "\t * @returns {(string|Token)[]}",
                "\t */",
                "\tfunction tokenizeWithHooks(code, grammar, language) {",
                "\t\tvar env = {",
                "\t\t\tcode: code,",
                "\t\t\tgrammar: grammar,",
                "\t\t\tlanguage: language",
                "\t\t};",
                "\t\tPrism.hooks.run('before-tokenize', env);",
                "\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);",
                "\t\tPrism.hooks.run('after-tokenize', env);",
                "\t\treturn env.tokens;",
                "\t}",
                "",
                "\t/**",
                "\t * Returns the token of the given JavaScript interpolation expression.",
                "\t *",
                "\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`",
                "\t * @returns {Token}",
                "\t */",
                "\tfunction tokenizeInterpolationExpression(expression) {",
                "\t\tvar tempGrammar = {};",
                "\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;",
                "",
                "\t\t/** @type {Array} */",
                "\t\tvar tokens = Prism.tokenize(expression, tempGrammar);",
                "\t\tif (tokens.length === 3) {",
                "\t\t\t/**",
                "\t\t\t * The token array will look like this",
                "\t\t\t * [",
                "\t\t\t *     [\"interpolation-punctuation\", \"${\"]",
                "\t\t\t *     \"...\" // JavaScript expression of the interpolation",
                "\t\t\t *     [\"interpolation-punctuation\", \"}\"]",
                "\t\t\t * ]",
                "\t\t\t */",
                "",
                "\t\t\tvar args = [1, 1];",
                "\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));",
                "",
                "\t\t\ttokens.splice.apply(tokens, args);",
                "\t\t}",
                "",
                "\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);",
                "\t}",
                "",
                "\t/**",
                "\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.",
                "\t *",
                "\t * This function has 3 phases:",
                "\t *",
                "\t * 1. Replace all JavaScript interpolation expression with a placeholder.",
                "\t *    The placeholder will have the syntax of a identify of the target language.",
                "\t * 2. Tokenize the code with placeholders.",
                "\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.",
                "\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been",
                "\t *    tokenized as two tokens by the grammar of the embedded language.",
                "\t *",
                "\t * @param {string} code",
                "\t * @param {object} grammar",
                "\t * @param {string} language",
                "\t * @returns {Token}",
                "\t */",
                "\tfunction tokenizeEmbedded(code, grammar, language) {",
                "\t\t// 1. First filter out all interpolations",
                "",
                "\t\t// because they might be escaped, we need a lookbehind, so we use Prism",
                "\t\t/** @type {(Token|string)[]} */",
                "\t\tvar _tokens = Prism.tokenize(code, {",
                "\t\t\t'interpolation': {",
                "\t\t\t\tpattern: RegExp(interpolationPattern),",
                "\t\t\t\tlookbehind: true",
                "\t\t\t}",
                "\t\t});",
                "",
                "\t\t// replace all interpolations with a placeholder which is not in the code already",
                "\t\tvar placeholderCounter = 0;",
                "\t\t/** @type {Object<string, string>} */",
                "\t\tvar placeholderMap = {};",
                "\t\tvar embeddedCode = _tokens.map(function (token) {",
                "\t\t\tif (typeof token === 'string') {",
                "\t\t\t\treturn token;",
                "\t\t\t} else {",
                "\t\t\t\tvar interpolationExpression = token.content;",
                "",
                "\t\t\t\tvar placeholder;",
                "\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { }",
                "\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;",
                "\t\t\t\treturn placeholder;",
                "\t\t\t}",
                "\t\t}).join('');",
                "",
                "",
                "\t\t// 2. Tokenize the embedded code",
                "",
                "\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);",
                "",
                "",
                "\t\t// 3. Re-insert the interpolation",
                "",
                "\t\tvar placeholders = Object.keys(placeholderMap);",
                "\t\tplaceholderCounter = 0;",
                "",
                "\t\t/**",
                "\t\t *",
                "\t\t * @param {(Token|string)[]} tokens",
                "\t\t * @returns {void}",
                "\t\t */",
                "\t\tfunction walkTokens(tokens) {",
                "\t\t\tfor (var i = 0; i < tokens.length; i++) {",
                "\t\t\t\tif (placeholderCounter >= placeholders.length) {",
                "\t\t\t\t\treturn;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tvar token = tokens[i];",
                "",
                "\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {",
                "\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];",
                "\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);",
                "",
                "\t\t\t\t\tvar index = s.indexOf(placeholder);",
                "\t\t\t\t\tif (index !== -1) {",
                "\t\t\t\t\t\t++placeholderCounter;",
                "",
                "\t\t\t\t\t\tvar before = s.substring(0, index);",
                "\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);",
                "\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);",
                "",
                "\t\t\t\t\t\tvar replacement = [];",
                "\t\t\t\t\t\tif (before) {",
                "\t\t\t\t\t\t\treplacement.push(before);",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t\treplacement.push(middle);",
                "\t\t\t\t\t\tif (after) {",
                "\t\t\t\t\t\t\tvar afterTokens = [after];",
                "\t\t\t\t\t\t\twalkTokens(afterTokens);",
                "\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\tif (typeof token === 'string') {",
                "\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));",
                "\t\t\t\t\t\t\ti += replacement.length - 1;",
                "\t\t\t\t\t\t} else {",
                "\t\t\t\t\t\t\ttoken.content = replacement;",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t}",
                "\t\t\t\t} else {",
                "\t\t\t\t\tvar content = token.content;",
                "\t\t\t\t\tif (Array.isArray(content)) {",
                "\t\t\t\t\t\twalkTokens(content);",
                "\t\t\t\t\t} else {",
                "\t\t\t\t\t\twalkTokens([content]);",
                "\t\t\t\t\t}",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "\t\twalkTokens(embeddedTokens);",
                "",
                "\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);",
                "\t}",
                "",
                "\t/**",
                "\t * The languages for which JS templating will handle tagged template literals.",
                "\t *",
                "\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.",
                "\t */",
                "\tvar supportedLanguages = {",
                "\t\t'javascript': true,",
                "\t\t'js': true,",
                "\t\t'typescript': true,",
                "\t\t'ts': true,",
                "\t\t'jsx': true,",
                "\t\t'tsx': true,",
                "\t};",
                "\tPrism.hooks.add('after-tokenize', function (env) {",
                "\t\tif (!(env.language in supportedLanguages)) {",
                "\t\t\treturn;",
                "\t\t}",
                "",
                "\t\t/**",
                "\t\t * Finds and tokenizes all template strings with an embedded languages.",
                "\t\t *",
                "\t\t * @param {(Token | string)[]} tokens",
                "\t\t * @returns {void}",
                "\t\t */",
                "\t\tfunction findTemplateStrings(tokens) {",
                "\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {",
                "\t\t\t\tvar token = tokens[i];",
                "",
                "\t\t\t\tif (typeof token === 'string') {",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tvar content = token.content;",
                "\t\t\t\tif (!Array.isArray(content)) {",
                "\t\t\t\t\tif (typeof content !== 'string') {",
                "\t\t\t\t\t\tfindTemplateStrings([content]);",
                "\t\t\t\t\t}",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tif (token.type === 'template-string') {",
                "\t\t\t\t\t/**",
                "\t\t\t\t\t * A JavaScript template-string token will look like this:",
                "\t\t\t\t\t *",
                "\t\t\t\t\t * [\"template-string\", [",
                "\t\t\t\t\t *     [\"template-punctuation\", \"`\"],",
                "\t\t\t\t\t *     (",
                "\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.",
                "\t\t\t\t\t *         or",
                "\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.",
                "\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.",
                "\t\t\t\t\t *     ),",
                "\t\t\t\t\t *     [\"template-punctuation\", \"`\"]",
                "\t\t\t\t\t * ]]",
                "\t\t\t\t\t */",
                "",
                "\t\t\t\t\tvar embedded = content[1];",
                "\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {",
                "\t\t\t\t\t\t// get string content",
                "\t\t\t\t\t\tvar code = stringContent(embedded);",
                "",
                "\t\t\t\t\t\tvar alias = embedded.alias;",
                "\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;",
                "",
                "\t\t\t\t\t\tvar grammar = Prism.languages[language];",
                "\t\t\t\t\t\tif (!grammar) {",
                "\t\t\t\t\t\t\t// the embedded language isn't registered.",
                "\t\t\t\t\t\t\tcontinue;",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);",
                "\t\t\t\t\t}",
                "\t\t\t\t} else {",
                "\t\t\t\t\tfindTemplateStrings(content);",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "",
                "\t\tfindTemplateStrings(env.tokens);",
                "\t});",
                "",
                "",
                "\t/**",
                "\t * Returns the string content of a token or token stream.",
                "\t *",
                "\t * @param {string | Token | (string | Token)[]} value",
                "\t * @returns {string}",
                "\t */",
                "\tfunction stringContent(value) {",
                "\t\tif (typeof value === 'string') {",
                "\t\t\treturn value;",
                "\t\t} else if (Array.isArray(value)) {",
                "\t\t\treturn value.map(stringContent).join('');",
                "\t\t} else {",
                "\t\t\treturn stringContent(value.content);",
                "\t\t}",
                "\t}",
                "",
                "}(Prism));"
            ]
        },
        "6": {
            "function_name": "tokenizeInterpolationExpression (not found) ",
            "file_path": "components/prism-js-templates.js",
            "function_details": [
                {
                    "name": "tokenizeInterpolationExpression",
                    "start_line": 1,
                    "end_line": 346
                }
            ],
            "function_code": [
                "(function (Prism) {",
                "",
                "\tvar templateString = Prism.languages.javascript['template-string'];",
                "",
                "\t// see the pattern in prism-javascript.js",
                "\tvar templateLiteralPattern = templateString.pattern.source;",
                "\tvar interpolationObject = templateString.inside['interpolation'];",
                "\tvar interpolationPunctuationObject = interpolationObject.inside['interpolation-punctuation'];",
                "\tvar interpolationPattern = interpolationObject.pattern.source;",
                "",
                "",
                "\t/**",
                "\t * Creates a new pattern to match a template string with a special tag.",
                "\t *",
                "\t * This will return `undefined` if there is no grammar with the given language id.",
                "\t *",
                "\t * @param {string} language The language id of the embedded language. E.g. `markdown`.",
                "\t * @param {string} tag The regex pattern to match the tag.",
                "\t * @returns {object | undefined}",
                "\t * @example",
                "\t * createTemplate('css', /\\bcss/.source);",
                "\t */",
                "\tfunction createTemplate(language, tag) {",
                "\t\tif (!Prism.languages[language]) {",
                "\t\t\treturn undefined;",
                "\t\t}",
                "",
                "\t\treturn {",
                "\t\t\tpattern: RegExp('((?:' + tag + ')\\\\s*)' + templateLiteralPattern),",
                "\t\t\tlookbehind: true,",
                "\t\t\tgreedy: true,",
                "\t\t\tinside: {",
                "\t\t\t\t'template-punctuation': {",
                "\t\t\t\t\tpattern: /^`|`$/,",
                "\t\t\t\t\talias: 'string'",
                "\t\t\t\t},",
                "\t\t\t\t'embedded-code': {",
                "\t\t\t\t\tpattern: /[\\s\\S]+/,",
                "\t\t\t\t\talias: language",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t};",
                "\t}",
                "",
                "",
                "\tPrism.languages.javascript['template-string'] = [",
                "\t\t// styled-jsx:",
                "\t\t//   css`a { color: #25F; }`",
                "\t\t// styled-components:",
                "\t\t//   styled.h1`color: red;`",
                "\t\tcreateTemplate('css', /\\b(?:styled(?:\\([^)]*\\))?(?:\\s*\\.\\s*\\w+(?:\\([^)]*\\))*)*|css(?:\\s*\\.\\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source),",
                "",
                "\t\t// html`<p></p>`",
                "\t\t// div.innerHTML = `<p></p>`",
                "\t\tcreateTemplate('html', /\\bhtml|\\.\\s*(?:inner|outer)HTML\\s*\\+?=/.source),",
                "",
                "\t\t// svg`<path fill=\"#fff\" d=\"M55.37 ...\"/>`",
                "\t\tcreateTemplate('svg', /\\bsvg/.source),",
                "",
                "\t\t// md`# h1`, markdown`## h2`",
                "\t\tcreateTemplate('markdown', /\\b(?:md|markdown)/.source),",
                "",
                "\t\t// gql`...`, graphql`...`, graphql.experimental`...`",
                "\t\tcreateTemplate('graphql', /\\b(?:gql|graphql(?:\\s*\\.\\s*experimental)?)/.source),",
                "",
                "\t\t// vanilla template string",
                "\t\ttemplateString",
                "\t].filter(Boolean);",
                "",
                "",
                "\t/**",
                "\t * Returns a specific placeholder literal for the given language.",
                "\t *",
                "\t * @param {number} counter",
                "\t * @param {string} language",
                "\t * @returns {string}",
                "\t */",
                "\tfunction getPlaceholder(counter, language) {",
                "\t\treturn '___' + language.toUpperCase() + '_' + counter + '___';",
                "\t}",
                "",
                "\t/**",
                "\t * Returns the tokens of `Prism.tokenize` but also runs the `before-tokenize` and `after-tokenize` hooks.",
                "\t *",
                "\t * @param {string} code",
                "\t * @param {any} grammar",
                "\t * @param {string} language",
                "\t * @returns {(string|Token)[]}",
                "\t */",
                "\tfunction tokenizeWithHooks(code, grammar, language) {",
                "\t\tvar env = {",
                "\t\t\tcode: code,",
                "\t\t\tgrammar: grammar,",
                "\t\t\tlanguage: language",
                "\t\t};",
                "\t\tPrism.hooks.run('before-tokenize', env);",
                "\t\tenv.tokens = Prism.tokenize(env.code, env.grammar);",
                "\t\tPrism.hooks.run('after-tokenize', env);",
                "\t\treturn env.tokens;",
                "\t}",
                "",
                "\t/**",
                "\t * Returns the token of the given JavaScript interpolation expression.",
                "\t *",
                "\t * @param {string} expression The code of the expression. E.g. `\"${42}\"`",
                "\t * @returns {Token}",
                "\t */",
                "\tfunction tokenizeInterpolationExpression(expression) {",
                "\t\tvar tempGrammar = {};",
                "\t\ttempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;",
                "",
                "\t\t/** @type {Array} */",
                "\t\tvar tokens = Prism.tokenize(expression, tempGrammar);",
                "\t\tif (tokens.length === 3) {",
                "\t\t\t/**",
                "\t\t\t * The token array will look like this",
                "\t\t\t * [",
                "\t\t\t *     [\"interpolation-punctuation\", \"${\"]",
                "\t\t\t *     \"...\" // JavaScript expression of the interpolation",
                "\t\t\t *     [\"interpolation-punctuation\", \"}\"]",
                "\t\t\t * ]",
                "\t\t\t */",
                "",
                "\t\t\tvar args = [1, 1];",
                "\t\t\targs.push.apply(args, tokenizeWithHooks(tokens[1], Prism.languages.javascript, 'javascript'));",
                "",
                "\t\t\ttokens.splice.apply(tokens, args);",
                "\t\t}",
                "",
                "\t\treturn new Prism.Token('interpolation', tokens, interpolationObject.alias, expression);",
                "\t}",
                "",
                "\t/**",
                "\t * Tokenizes the given code with support for JavaScript interpolation expressions mixed in.",
                "\t *",
                "\t * This function has 3 phases:",
                "\t *",
                "\t * 1. Replace all JavaScript interpolation expression with a placeholder.",
                "\t *    The placeholder will have the syntax of a identify of the target language.",
                "\t * 2. Tokenize the code with placeholders.",
                "\t * 3. Tokenize the interpolation expressions and re-insert them into the tokenize code.",
                "\t *    The insertion only works if a placeholder hasn't been \"ripped apart\" meaning that the placeholder has been",
                "\t *    tokenized as two tokens by the grammar of the embedded language.",
                "\t *",
                "\t * @param {string} code",
                "\t * @param {object} grammar",
                "\t * @param {string} language",
                "\t * @returns {Token}",
                "\t */",
                "\tfunction tokenizeEmbedded(code, grammar, language) {",
                "\t\t// 1. First filter out all interpolations",
                "",
                "\t\t// because they might be escaped, we need a lookbehind, so we use Prism",
                "\t\t/** @type {(Token|string)[]} */",
                "\t\tvar _tokens = Prism.tokenize(code, {",
                "\t\t\t'interpolation': {",
                "\t\t\t\tpattern: RegExp(interpolationPattern),",
                "\t\t\t\tlookbehind: true",
                "\t\t\t}",
                "\t\t});",
                "",
                "\t\t// replace all interpolations with a placeholder which is not in the code already",
                "\t\tvar placeholderCounter = 0;",
                "\t\t/** @type {Object<string, string>} */",
                "\t\tvar placeholderMap = {};",
                "\t\tvar embeddedCode = _tokens.map(function (token) {",
                "\t\t\tif (typeof token === 'string') {",
                "\t\t\t\treturn token;",
                "\t\t\t} else {",
                "\t\t\t\tvar interpolationExpression = token.content;",
                "",
                "\t\t\t\tvar placeholder;",
                "\t\t\t\twhile (code.indexOf(placeholder = getPlaceholder(placeholderCounter++, language)) !== -1) { }",
                "\t\t\t\tplaceholderMap[placeholder] = interpolationExpression;",
                "\t\t\t\treturn placeholder;",
                "\t\t\t}",
                "\t\t}).join('');",
                "",
                "",
                "\t\t// 2. Tokenize the embedded code",
                "",
                "\t\tvar embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);",
                "",
                "",
                "\t\t// 3. Re-insert the interpolation",
                "",
                "\t\tvar placeholders = Object.keys(placeholderMap);",
                "\t\tplaceholderCounter = 0;",
                "",
                "\t\t/**",
                "\t\t *",
                "\t\t * @param {(Token|string)[]} tokens",
                "\t\t * @returns {void}",
                "\t\t */",
                "\t\tfunction walkTokens(tokens) {",
                "\t\t\tfor (var i = 0; i < tokens.length; i++) {",
                "\t\t\t\tif (placeholderCounter >= placeholders.length) {",
                "\t\t\t\t\treturn;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tvar token = tokens[i];",
                "",
                "\t\t\t\tif (typeof token === 'string' || typeof token.content === 'string') {",
                "\t\t\t\t\tvar placeholder = placeholders[placeholderCounter];",
                "\t\t\t\t\tvar s = typeof token === 'string' ? token : /** @type {string} */ (token.content);",
                "",
                "\t\t\t\t\tvar index = s.indexOf(placeholder);",
                "\t\t\t\t\tif (index !== -1) {",
                "\t\t\t\t\t\t++placeholderCounter;",
                "",
                "\t\t\t\t\t\tvar before = s.substring(0, index);",
                "\t\t\t\t\t\tvar middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);",
                "\t\t\t\t\t\tvar after = s.substring(index + placeholder.length);",
                "",
                "\t\t\t\t\t\tvar replacement = [];",
                "\t\t\t\t\t\tif (before) {",
                "\t\t\t\t\t\t\treplacement.push(before);",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t\treplacement.push(middle);",
                "\t\t\t\t\t\tif (after) {",
                "\t\t\t\t\t\t\tvar afterTokens = [after];",
                "\t\t\t\t\t\t\twalkTokens(afterTokens);",
                "\t\t\t\t\t\t\treplacement.push.apply(replacement, afterTokens);",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\tif (typeof token === 'string') {",
                "\t\t\t\t\t\t\ttokens.splice.apply(tokens, [i, 1].concat(replacement));",
                "\t\t\t\t\t\t\ti += replacement.length - 1;",
                "\t\t\t\t\t\t} else {",
                "\t\t\t\t\t\t\ttoken.content = replacement;",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t}",
                "\t\t\t\t} else {",
                "\t\t\t\t\tvar content = token.content;",
                "\t\t\t\t\tif (Array.isArray(content)) {",
                "\t\t\t\t\t\twalkTokens(content);",
                "\t\t\t\t\t} else {",
                "\t\t\t\t\t\twalkTokens([content]);",
                "\t\t\t\t\t}",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "\t\twalkTokens(embeddedTokens);",
                "",
                "\t\treturn new Prism.Token(language, embeddedTokens, 'language-' + language, code);",
                "\t}",
                "",
                "\t/**",
                "\t * The languages for which JS templating will handle tagged template literals.",
                "\t *",
                "\t * JS templating isn't active for only JavaScript but also related languages like TypeScript, JSX, and TSX.",
                "\t */",
                "\tvar supportedLanguages = {",
                "\t\t'javascript': true,",
                "\t\t'js': true,",
                "\t\t'typescript': true,",
                "\t\t'ts': true,",
                "\t\t'jsx': true,",
                "\t\t'tsx': true,",
                "\t};",
                "\tPrism.hooks.add('after-tokenize', function (env) {",
                "\t\tif (!(env.language in supportedLanguages)) {",
                "\t\t\treturn;",
                "\t\t}",
                "",
                "\t\t/**",
                "\t\t * Finds and tokenizes all template strings with an embedded languages.",
                "\t\t *",
                "\t\t * @param {(Token | string)[]} tokens",
                "\t\t * @returns {void}",
                "\t\t */",
                "\t\tfunction findTemplateStrings(tokens) {",
                "\t\t\tfor (var i = 0, l = tokens.length; i < l; i++) {",
                "\t\t\t\tvar token = tokens[i];",
                "",
                "\t\t\t\tif (typeof token === 'string') {",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tvar content = token.content;",
                "\t\t\t\tif (!Array.isArray(content)) {",
                "\t\t\t\t\tif (typeof content !== 'string') {",
                "\t\t\t\t\t\tfindTemplateStrings([content]);",
                "\t\t\t\t\t}",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t}",
                "",
                "\t\t\t\tif (token.type === 'template-string') {",
                "\t\t\t\t\t/**",
                "\t\t\t\t\t * A JavaScript template-string token will look like this:",
                "\t\t\t\t\t *",
                "\t\t\t\t\t * [\"template-string\", [",
                "\t\t\t\t\t *     [\"template-punctuation\", \"`\"],",
                "\t\t\t\t\t *     (",
                "\t\t\t\t\t *         An array of \"string\" and \"interpolation\" tokens. This is the simple string case.",
                "\t\t\t\t\t *         or",
                "\t\t\t\t\t *         [\"embedded-code\", \"...\"] This is the token containing the embedded code.",
                "\t\t\t\t\t *                                  It also has an alias which is the language of the embedded code.",
                "\t\t\t\t\t *     ),",
                "\t\t\t\t\t *     [\"template-punctuation\", \"`\"]",
                "\t\t\t\t\t * ]]",
                "\t\t\t\t\t */",
                "",
                "\t\t\t\t\tvar embedded = content[1];",
                "\t\t\t\t\tif (content.length === 3 && typeof embedded !== 'string' && embedded.type === 'embedded-code') {",
                "\t\t\t\t\t\t// get string content",
                "\t\t\t\t\t\tvar code = stringContent(embedded);",
                "",
                "\t\t\t\t\t\tvar alias = embedded.alias;",
                "\t\t\t\t\t\tvar language = Array.isArray(alias) ? alias[0] : alias;",
                "",
                "\t\t\t\t\t\tvar grammar = Prism.languages[language];",
                "\t\t\t\t\t\tif (!grammar) {",
                "\t\t\t\t\t\t\t// the embedded language isn't registered.",
                "\t\t\t\t\t\t\tcontinue;",
                "\t\t\t\t\t\t}",
                "",
                "\t\t\t\t\t\tcontent[1] = tokenizeEmbedded(code, grammar, language);",
                "\t\t\t\t\t}",
                "\t\t\t\t} else {",
                "\t\t\t\t\tfindTemplateStrings(content);",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t}",
                "",
                "\t\tfindTemplateStrings(env.tokens);",
                "\t});",
                "",
                "",
                "\t/**",
                "\t * Returns the string content of a token or token stream.",
                "\t *",
                "\t * @param {string | Token | (string | Token)[]} value",
                "\t * @returns {string}",
                "\t */",
                "\tfunction stringContent(value) {",
                "\t\tif (typeof value === 'string') {",
                "\t\t\treturn value;",
                "\t\t} else if (Array.isArray(value)) {",
                "\t\t\treturn value.map(stringContent).join('');",
                "\t\t} else {",
                "\t\t\treturn stringContent(value.content);",
                "\t\t}",
                "\t}",
                "",
                "}(Prism));"
            ]
        }
    }
}