{
    "1": {
        "bug_file": "src/language-js/parser-babel.js",
        "compressed": "NO",
        "line_numbers": 286,
        "compressed_line_numbers": 286,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst {\n  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n  getShebang,\n} = require(\"../common/util\");\nconst { hasPragma } = require(\"./pragma\");\nconst { locStart, locEnd } = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nfunction babelOptions({ sourceType, extraPlugins = [] }) {\n  return {\n    sourceType,\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowUndeclaredExports: true,\n    errorRecovery: true,\n    createParenthesizedExpressions: true,\n    plugins: [\n      // When adding a plugin, please add a test in `tests/js/babel-plugins`,\n      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify\n\n      \"doExpressions\",\n      \"classProperties\",\n      \"exportDefaultFrom\",\n      \"functionBind\",\n      \"functionSent\",\n      \"classPrivateProperties\",\n      \"throwExpressions\",\n      \"classPrivateMethods\",\n      \"v8intrinsic\",\n      \"partialApplication\",\n      [\"decorators\", { decoratorsBeforeExport: false }],\n      \"privateIn\",\n      \"importAssertions\",\n      [\"recordAndTuple\", { syntaxType: \"hash\" }],\n      \"decimal\",\n      \"moduleStringNames\",\n      \"classStaticBlock\",\n      ...extraPlugins,\n    ],\n    tokens: true,\n    ranges: true,\n  };\n}\n\nfunction resolvePluginsConflict(\n  condition,\n  pluginCombinations,\n  conflictPlugins\n) {\n  if (!condition) {\n    return pluginCombinations;\n  }\n  const combinations = [];\n  for (const combination of pluginCombinations) {\n    for (const plugin of conflictPlugins) {\n      combinations.push([...combination, plugin]);\n    }\n  }\n  return combinations;\n}\n\n// Similar to babel\n// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67\nconst FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;\nfunction isFlowFile(text, options) {\n  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {\n    return true;\n  }\n\n  const shebang = getShebang(text);\n  if (shebang) {\n    text = text.slice(shebang.length);\n  }\n\n  const firstNonSpaceNonCommentCharacterIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(\n    text,\n    0\n  );\n\n  if (firstNonSpaceNonCommentCharacterIndex !== false) {\n    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);\n  }\n\n  return FLOW_PRAGMA_REGEX.test(text);\n}\n\nfunction createParse(parseMethod, ...pluginCombinations) {\n  return (text, parsers, opts = {}) => {\n    if (opts.parser === \"babel\" && isFlowFile(text, opts)) {\n      opts.parser = \"babel-flow\";\n      return parseFlow(text, parsers, opts);\n    }\n\n    // Inline the require to avoid loading all the JS if we don't use it\n    const babel = require(\"@babel/parser\");\n\n    const sourceType =\n      opts.__babelSourceType === \"script\" ? \"script\" : \"module\";\n\n    let ast;\n    try {\n      const combinations = resolvePluginsConflict(\n        text.includes(\"|>\"),\n        pluginCombinations,\n        [\n          [\"pipelineOperator\", { proposal: \"smart\" }],\n          [\"pipelineOperator\", { proposal: \"minimal\" }],\n          [\"pipelineOperator\", { proposal: \"fsharp\" }],\n        ]\n      );\n      ast = tryCombinations(\n        (options) => babel[parseMethod](text, options),\n        combinations.map((extraPlugins) =>\n          babelOptions({ sourceType, extraPlugins })\n        )\n      );\n    } catch (error) {\n      // babel error prints (l:c) with cols that are zero indexed\n      // so we need our custom error\n      const { message, loc } = error;\n\n      throw createError(message.replace(/ \\(.*\\)/, \"\"), {\n        start: {\n          line: loc ? loc.line : 0,\n          column: loc ? loc.column + 1 : 0,\n        },\n      });\n    }\n\n    return postprocess(ast, { ...opts, originalText: text });\n  };\n}\n\nconst parse = createParse(\"parse\", [\"jsx\", \"flow\"]);\nconst parseFlow = createParse(\"parse\", [\n  \"jsx\",\n  [\"flow\", { all: true, enums: true }],\n]);\nconst parseTypeScript = createParse(\n  \"parse\",\n  [\"jsx\", \"typescript\"],\n  [\"typescript\"]\n);\nconst parseExpression = createParse(\"parseExpression\", [\"jsx\"]);\n\nfunction tryCombinations(fn, combinations) {\n  let error;\n  for (let i = 0; i < combinations.length; i++) {\n    try {\n      return rethrowSomeRecoveredErrors(fn(combinations[i]));\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n  throw error;\n}\n\nconst messagesShouldThrow = new Set([\n  // TSErrors.UnexpectedTypeAnnotation\n  // https://github.com/babel/babel/blob/008fe25ae22e78288fbc637d41069bb4a1040987/packages/babel-parser/src/plugins/typescript/index.js#L95\n  \"Did not expect a type annotation here.\",\n  // ErrorMessages.ModuleAttributeDifferentFromType\n  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/parser/error-message.js#L92\n  \"The only accepted module attribute is `type`\",\n  // FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction\n  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/plugins/flow.js#L118\n  \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",\n]);\n\nfunction shouldRethrow(error) {\n  const [, message] = error.message.match(/(.*?)\\s*\\(\\d+:\\d+\\)/);\n  // Only works for literal message\n  return messagesShouldThrow.has(message);\n}\n\nfunction rethrowSomeRecoveredErrors(ast) {\n  const error = ast.errors.find((error) => shouldRethrow(error));\n  if (error) {\n    throw error;\n  }\n\n  return ast;\n}\n\nfunction parseJson(text, parsers, opts) {\n  const ast = parseExpression(text, parsers, opts);\n\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n    case \"ObjectProperty\":\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      }\n\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n      return [node.key, node.value].forEach(assertJsonChildNode);\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        default:\n          throw createJsonError(\"operator\");\n      }\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n      throw createJsonError();\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  }\n\n  function createJsonError(attribute) {\n    const name = !attribute\n      ? node.type\n      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;\n    return createError(`${name} is not allowed in JSON.`, {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1,\n      },\n    });\n  }\n}\n\nconst babel = { parse, astFormat: \"estree\", hasPragma, locStart, locEnd };\nconst babelFlow = { ...babel, parse: parseFlow };\nconst babelTypeScript = { ...babel, parse: parseTypeScript };\nconst babelExpression = { ...babel, parse: parseExpression };\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    babel,\n    \"babel-flow\": babelFlow,\n    \"babel-ts\": babelTypeScript,\n    json: {\n      ...babelExpression,\n      hasPragma() {\n        return true;\n      },\n    },\n    json5: babelExpression,\n    \"json-stringify\": {\n      parse: parseJson,\n      astFormat: \"estree-json\",\n      locStart,\n      locEnd,\n    },\n    /** @internal */\n    __js_expression: babelExpression,\n    /** for vue filter */\n    __vue_expression: babelExpression,\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel,\n  },\n};"
    },
    "2": {
        "bug_file": "src/language-js/parser-flow.js",
        "compressed": "NO",
        "line_numbers": 44,
        "compressed_line_numbers": 44,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst { hasPragma } = require(\"./pragma\");\nconst { locStart, locEnd } = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nfunction parse(text, parsers, opts) {\n  // Inline the require to avoid loading all the JS if we don't use it\n  const flowParser = require(\"flow-parser\");\n\n  const ast = flowParser.parse(text, {\n    enums: true,\n    esproposal_decorators: true,\n    esproposal_class_instance_fields: true,\n    esproposal_class_static_fields: true,\n    esproposal_export_star_as: true,\n    esproposal_optional_chaining: true,\n    esproposal_nullish_coalescing: true,\n    tokens: true,\n  });\n\n  const [error] = ast.errors;\n  if (error) {\n    const {\n      message,\n      loc: { start, end },\n    } = error;\n\n    throw createError(message, {\n      start: { line: start.line, column: start.column + 1 },\n      end: { line: end.line, column: end.column + 1 },\n    });\n  }\n\n  return postprocess(ast, { ...opts, originalText: text });\n}\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    flow: { parse, astFormat: \"estree\", hasPragma, locStart, locEnd },\n  },\n};"
    },
    "3": {
        "bug_file": "src/language-js/parser-espree.js",
        "compressed": "NO",
        "line_numbers": 59,
        "compressed_line_numbers": 59,
        "compressed_bug_file_content": "\"use strict\";\nconst { getShebang } = require(\"../common/util\");\nconst createError = require(\"../common/parser-create-error\");\nconst { hasPragma } = require(\"./pragma\");\nconst { locStart, locEnd } = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nconst espreeOptions = {\n  range: true,\n  loc: true,\n  comment: true,\n  tokens: true,\n  sourceType: \"module\",\n  ecmaFeatures: {\n    jsx: true,\n    globalReturn: true,\n    impliedStrict: false,\n  },\n};\n\nfunction parse(originalText, parsers, options) {\n  const { parse, latestEcmaVersion } = require(\"espree\");\n  espreeOptions.ecmaVersion = latestEcmaVersion;\n\n  // Replace shebang with space\n  const shebang = getShebang(originalText);\n  const text = shebang\n    ? \" \".repeat(shebang.length) + originalText.slice(shebang.length)\n    : originalText;\n\n  let ast;\n\n  try {\n    ast = parse(text, espreeOptions);\n  } catch (moduleError) {\n    try {\n      ast = parse(text, { ...espreeOptions, sourceType: \"script\" });\n    } catch (scriptError) {\n      // throw the error for `module` parsing\n\n      /* istanbul ignore next */\n      if (typeof moduleError.lineNumber !== \"number\") {\n        throw moduleError;\n      }\n\n      throw createError(moduleError.message, {\n        start: { line: moduleError.lineNumber, column: moduleError.column },\n      });\n    }\n  }\n\n  return postprocess(ast, { ...options, originalText });\n}\n\nmodule.exports = {\n  parsers: {\n    espree: { parse, astFormat: \"estree\", hasPragma, locStart, locEnd },\n  },\n};"
    },
    "4": {
        "bug_file": "src/language-js/index.js",
        "compressed": "NO",
        "line_numbers": 161,
        "compressed_line_numbers": 161,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createLanguage = require(\"../utils/create-language\");\nconst estreePrinter = require(\"./printer-estree\");\nconst estreeJsonPrinter = require(\"./printer-estree-json\");\nconst options = require(\"./options\");\n\nconst languages = [\n  createLanguage(\n    require(\"linguist-languages/data/JavaScript.json\"),\n    (data) => ({\n      since: \"0.0.0\",\n      parsers: [\n        \"babel\",\n        \"espree\",\n        \"babel-flow\",\n        \"babel-ts\",\n        \"flow\",\n        \"typescript\",\n      ],\n      vscodeLanguageIds: [\"javascript\", \"mongo\"],\n      extensions: [\n        ...data.extensions,\n        // WeiXin Script (Weixin Mini Programs)\n        // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/\n        \".wxs\",\n      ],\n    })\n  ),\n  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({\n    name: \"Flow\",\n    since: \"0.0.0\",\n    parsers: [\"flow\", \"babel-flow\"],\n    vscodeLanguageIds: [\"javascript\"],\n    aliases: [],\n    filenames: [],\n    extensions: [\".js.flow\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/JSX.json\"), () => ({\n    since: \"0.0.0\",\n    parsers: [\n      \"babel\",\n      \"babel-flow\",\n      \"babel-ts\",\n      \"flow\",\n      \"typescript\",\n      \"espree\",\n    ],\n    vscodeLanguageIds: [\"javascriptreact\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/TypeScript.json\"), () => ({\n    since: \"1.4.0\",\n    parsers: [\"typescript\", \"babel-ts\"],\n    vscodeLanguageIds: [\"typescript\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/TSX.json\"), () => ({\n    since: \"1.4.0\",\n    parsers: [\"typescript\", \"babel-ts\"],\n    vscodeLanguageIds: [\"typescriptreact\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/JSON.json\"), () => ({\n    name: \"JSON.stringify\",\n    since: \"1.13.0\",\n    parsers: [\"json-stringify\"],\n    vscodeLanguageIds: [\"json\"],\n    extensions: [], // .json file defaults to json instead of json-stringify\n    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/JSON.json\"), (data) => ({\n    since: \"1.5.0\",\n    parsers: [\"json\"],\n    vscodeLanguageIds: [\"json\"],\n    filenames: [...data.filenames, \".prettierrc\"],\n    extensions: data.extensions.filter((extension) => extension !== \".jsonl\"),\n  })),\n  createLanguage(\n    require(\"linguist-languages/data/JSON with Comments.json\"),\n    (data) => ({\n      since: \"1.5.0\",\n      parsers: [\"json\"],\n      vscodeLanguageIds: [\"jsonc\"],\n      filenames: [...data.filenames, \".eslintrc\"],\n    })\n  ),\n  createLanguage(require(\"linguist-languages/data/JSON5.json\"), () => ({\n    since: \"1.13.0\",\n    parsers: [\"json5\"],\n    vscodeLanguageIds: [\"json5\"],\n  })),\n];\n\nconst printers = {\n  estree: estreePrinter,\n  \"estree-json\": estreeJsonPrinter,\n};\n\nconst parsers = {\n  // JS - Babel\n  get babel() {\n    return require(\"./parser-babel\").parsers.babel;\n  },\n  get \"babel-flow\"() {\n    return require(\"./parser-babel\").parsers[\"babel-flow\"];\n  },\n  get \"babel-ts\"() {\n    return require(\"./parser-babel\").parsers[\"babel-ts\"];\n  },\n  get json() {\n    return require(\"./parser-babel\").parsers.json;\n  },\n  get json5() {\n    return require(\"./parser-babel\").parsers.json5;\n  },\n  get \"json-stringify\"() {\n    return require(\"./parser-babel\").parsers[\"json-stringify\"];\n  },\n  get __js_expression() {\n    return require(\"./parser-babel\").parsers.__js_expression;\n  },\n  get __vue_expression() {\n    return require(\"./parser-babel\").parsers.__vue_expression;\n  },\n  get __vue_event_binding() {\n    return require(\"./parser-babel\").parsers.__vue_event_binding;\n  },\n  // JS - Flow\n  get flow() {\n    return require(\"./parser-flow\").parsers.flow;\n  },\n  // JS - TypeScript\n  get typescript() {\n    return require(\"./parser-typescript\").parsers.typescript;\n  },\n  // JS - Angular Action\n  get __ng_action() {\n    return require(\"./parser-angular\").parsers.__ng_action;\n  },\n  // JS - Angular Binding\n  get __ng_binding() {\n    return require(\"./parser-angular\").parsers.__ng_binding;\n  },\n  // JS - Angular Interpolation\n  get __ng_interpolation() {\n    return require(\"./parser-angular\").parsers.__ng_interpolation;\n  },\n  // JS - Angular Directive\n  get __ng_directive() {\n    return require(\"./parser-angular\").parsers.__ng_directive;\n  },\n  // JS - espree\n  get espree() {\n    return require(\"./parser-espree\").parsers.espree;\n  },\n};\n\nmodule.exports = {\n  languages,\n  options,\n  printers,\n  parsers,\n};"
    },
    "5": {
        "bug_file": "src/language-js/options.js",
        "compressed": "NO",
        "line_numbers": 100,
        "compressed_line_numbers": 100,
        "compressed_bug_file_content": "\"use strict\";\n\nconst commonOptions = require(\"../common/common-options\");\n\nconst CATEGORY_JAVASCRIPT = \"JavaScript\";\n\n// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\nmodule.exports = {\n  arrowParens: {\n    since: \"1.9.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: [\n      { since: \"1.9.0\", value: \"avoid\" },\n      { since: \"2.0.0\", value: \"always\" },\n    ],\n    description: \"Include parentheses around a sole arrow function parameter.\",\n    choices: [\n      {\n        value: \"always\",\n        description: \"Always include parens. Example: `(x) => x`\",\n      },\n      {\n        value: \"avoid\",\n        description: \"Omit parens when possible. Example: `x => x`\",\n      },\n    ],\n  },\n  bracketSpacing: commonOptions.bracketSpacing,\n  jsxBracketSameLine: {\n    since: \"0.17.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Put > on the last line instead of at a new line.\",\n  },\n  semi: {\n    since: \"1.0.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: true,\n    description: \"Print semicolons.\",\n    oppositeDescription:\n      \"Do not print semicolons, except at the beginning of lines which may need them.\",\n  },\n  singleQuote: commonOptions.singleQuote,\n  jsxSingleQuote: {\n    since: \"1.15.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Use single quotes in JSX.\",\n  },\n  quoteProps: {\n    since: \"1.17.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"as-needed\",\n    description: \"Change when properties in objects are quoted.\",\n    choices: [\n      {\n        value: \"as-needed\",\n        description: \"Only add quotes around object properties where required.\",\n      },\n      {\n        value: \"consistent\",\n        description:\n          \"If at least one property in an object requires quotes, quote all properties.\",\n      },\n      {\n        value: \"preserve\",\n        description: \"Respect the input use of quotes in object properties.\",\n      },\n    ],\n  },\n  trailingComma: {\n    since: \"0.0.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: [\n      { since: \"0.0.0\", value: false },\n      { since: \"0.19.0\", value: \"none\" },\n      { since: \"2.0.0\", value: \"es5\" },\n    ],\n    description: \"Print trailing commas wherever possible when multi-line.\",\n    choices: [\n      {\n        value: \"es5\",\n        description:\n          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",\n      },\n      { value: \"none\", description: \"No trailing commas.\" },\n      {\n        value: \"all\",\n        description:\n          \"Trailing commas wherever possible (including function arguments).\",\n      },\n    ],\n  },\n};"
    },
    "6": {
        "bug_file": "src/main/multiparser.js",
        "compressed": "NO",
        "line_numbers": 80,
        "compressed_line_numbers": 80,
        "compressed_bug_file_content": "\"use strict\";\n\nconst {\n  utils: { stripTrailingHardline },\n} = require(\"../document\");\nconst { normalize } = require(\"./options\");\nconst comments = require(\"./comments\");\n\nfunction printSubtree(path, print, options, printAstToDoc) {\n  if (options.printer.embed && options.embeddedLanguageFormatting === \"auto\") {\n    return options.printer.embed(\n      path,\n      print,\n      (text, partialNextOptions, textToDocOptions) =>\n        textToDoc(\n          text,\n          partialNextOptions,\n          options,\n          printAstToDoc,\n          textToDocOptions\n        ),\n      options\n    );\n  }\n}\n\nfunction textToDoc(\n  text,\n  partialNextOptions,\n  parentOptions,\n  printAstToDoc,\n  // TODO: remove `stripTrailingHardline` in v3.0.0\n  { stripTrailingHardline: shouldStripTrailingHardline = false } = {}\n) {\n  const nextOptions = normalize(\n    {\n      ...parentOptions,\n      ...partialNextOptions,\n      parentParser: parentOptions.parser,\n      embeddedInHtml: !!(\n        parentOptions.embeddedInHtml ||\n        parentOptions.parser === \"html\" ||\n        parentOptions.parser === \"vue\" ||\n        parentOptions.parser === \"angular\" ||\n        parentOptions.parser === \"lwc\"\n      ),\n      originalText: text,\n    },\n    { passThrough: true }\n  );\n\n  const result = require(\"./parser\").parse(text, nextOptions);\n  const { ast } = result;\n  text = result.text;\n\n  const astComments = ast.comments;\n  delete ast.comments;\n  comments.attach(astComments, ast, text, nextOptions);\n  nextOptions[Symbol.for(\"comments\")] = astComments || [];\n  nextOptions[Symbol.for(\"tokens\")] = ast.tokens || [];\n\n  const doc = printAstToDoc(ast, nextOptions);\n  comments.ensureAllCommentsPrinted(astComments);\n\n  if (shouldStripTrailingHardline) {\n    // TODO: move this to `stripTrailingHardline` function in `/src/document/doc-utils.js`\n    if (typeof doc === \"string\") {\n      return doc.replace(/(?:\\r?\\n)*$/, \"\");\n    }\n\n    return stripTrailingHardline(doc, true);\n  }\n\n  /* istanbul ignore next */\n  return doc;\n}\n\nmodule.exports = {\n  printSubtree,\n};"
    },
    "7": {
        "bug_file": "src/main/parser.js",
        "compressed": "NO",
        "line_numbers": 111,
        "compressed_line_numbers": 111,
        "compressed_bug_file_content": "\"use strict\";\n\nconst path = require(\"path\");\nconst { ConfigError } = require(\"../common/errors\");\nconst jsLoc = require(\"../language-js/loc\");\n\nconst { locStart, locEnd } = jsLoc;\n\n// Use defineProperties()/getOwnPropertyDescriptor() to prevent\n// triggering the parsers getters.\nconst ownNames = Object.getOwnPropertyNames;\nconst ownDescriptor = Object.getOwnPropertyDescriptor;\nfunction getParsers(options) {\n  const parsers = {};\n  for (const plugin of options.plugins) {\n    // TODO: test this with plugins\n    /* istanbul ignore next */\n    if (!plugin.parsers) {\n      continue;\n    }\n\n    for (const name of ownNames(plugin.parsers)) {\n      Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));\n    }\n  }\n\n  return parsers;\n}\n\nfunction resolveParser(opts, parsers) {\n  parsers = parsers || getParsers(opts);\n\n  if (typeof opts.parser === \"function\") {\n    // Custom parser API always works with JavaScript.\n    return {\n      parse: opts.parser,\n      astFormat: \"estree\",\n      locStart,\n      locEnd,\n    };\n  }\n\n  if (typeof opts.parser === \"string\") {\n    if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {\n      return parsers[opts.parser];\n    }\n\n    /* istanbul ignore next */\n    if (process.env.PRETTIER_TARGET === \"universal\") {\n      throw new ConfigError(\n        `Couldn't resolve parser \"${opts.parser}\". Parsers must be explicitly added to the standalone bundle.`\n      );\n    }\n\n    try {\n      return {\n        parse: eval(\"require\")(path.resolve(process.cwd(), opts.parser)),\n        astFormat: \"estree\",\n        locStart,\n        locEnd,\n      };\n    } catch (err) {\n      /* istanbul ignore next */\n      throw new ConfigError(`Couldn't resolve parser \"${opts.parser}\"`);\n    }\n  }\n}\n\nfunction parse(text, opts) {\n  const parsers = getParsers(opts);\n\n  // Create a new object {parserName: parseFn}. Uses defineProperty() to only call\n  // the parsers getters when actually calling the parser `parse` function.\n  const parsersForCustomParserApi = Object.keys(parsers).reduce(\n    (object, parserName) =>\n      Object.defineProperty(object, parserName, {\n        enumerable: true,\n        get() {\n          return parsers[parserName].parse;\n        },\n      }),\n    {}\n  );\n\n  const parser = resolveParser(opts, parsers);\n\n  try {\n    if (parser.preprocess) {\n      text = parser.preprocess(text, opts);\n    }\n\n    return {\n      text,\n      ast: parser.parse(text, parsersForCustomParserApi, opts),\n    };\n  } catch (error) {\n    const { loc } = error;\n\n    if (loc) {\n      const { codeFrameColumns } = require(\"@babel/code-frame\");\n      error.codeFrame = codeFrameColumns(text, loc, { highlightCode: true });\n      error.message += \"\\n\" + error.codeFrame;\n      throw error;\n    }\n\n    /* istanbul ignore next */\n    throw error.stack;\n  }\n}\n\nmodule.exports = { parse, resolveParser };"
    }
}