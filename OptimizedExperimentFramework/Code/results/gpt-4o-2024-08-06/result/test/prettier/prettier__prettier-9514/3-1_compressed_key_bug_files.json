{
    "1": {
        "bug_file": "src/language-js/parser-babel.js",
        "compressed": "NO",
        "line_numbers": 286,
        "compressed_line_numbers": 286,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst {\n  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n  getShebang,\n} = require(\"../common/util\");\nconst { hasPragma } = require(\"./pragma\");\nconst { locStart, locEnd } = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nfunction babelOptions({ sourceType, extraPlugins = [] }) {\n  return {\n    sourceType,\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowUndeclaredExports: true,\n    errorRecovery: true,\n    createParenthesizedExpressions: true,\n    plugins: [\n      // When adding a plugin, please add a test in `tests/js/babel-plugins`,\n      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify\n\n      \"doExpressions\",\n      \"classProperties\",\n      \"exportDefaultFrom\",\n      \"functionBind\",\n      \"functionSent\",\n      \"classPrivateProperties\",\n      \"throwExpressions\",\n      \"classPrivateMethods\",\n      \"v8intrinsic\",\n      \"partialApplication\",\n      [\"decorators\", { decoratorsBeforeExport: false }],\n      \"privateIn\",\n      \"importAssertions\",\n      [\"recordAndTuple\", { syntaxType: \"hash\" }],\n      \"decimal\",\n      \"moduleStringNames\",\n      \"classStaticBlock\",\n      ...extraPlugins,\n    ],\n    tokens: true,\n    ranges: true,\n  };\n}\n\nfunction resolvePluginsConflict(\n  condition,\n  pluginCombinations,\n  conflictPlugins\n) {\n  if (!condition) {\n    return pluginCombinations;\n  }\n  const combinations = [];\n  for (const combination of pluginCombinations) {\n    for (const plugin of conflictPlugins) {\n      combinations.push([...combination, plugin]);\n    }\n  }\n  return combinations;\n}\n\n// Similar to babel\n// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67\nconst FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;\nfunction isFlowFile(text, options) {\n  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {\n    return true;\n  }\n\n  const shebang = getShebang(text);\n  if (shebang) {\n    text = text.slice(shebang.length);\n  }\n\n  const firstNonSpaceNonCommentCharacterIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(\n    text,\n    0\n  );\n\n  if (firstNonSpaceNonCommentCharacterIndex !== false) {\n    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);\n  }\n\n  return FLOW_PRAGMA_REGEX.test(text);\n}\n\nfunction createParse(parseMethod, ...pluginCombinations) {\n  return (text, parsers, opts = {}) => {\n    if (opts.parser === \"babel\" && isFlowFile(text, opts)) {\n      opts.parser = \"babel-flow\";\n      return parseFlow(text, parsers, opts);\n    }\n\n    // Inline the require to avoid loading all the JS if we don't use it\n    const babel = require(\"@babel/parser\");\n\n    const sourceType =\n      opts.__babelSourceType === \"script\" ? \"script\" : \"module\";\n\n    let ast;\n    try {\n      const combinations = resolvePluginsConflict(\n        text.includes(\"|>\"),\n        pluginCombinations,\n        [\n          [\"pipelineOperator\", { proposal: \"smart\" }],\n          [\"pipelineOperator\", { proposal: \"minimal\" }],\n          [\"pipelineOperator\", { proposal: \"fsharp\" }],\n        ]\n      );\n      ast = tryCombinations(\n        (options) => babel[parseMethod](text, options),\n        combinations.map((extraPlugins) =>\n          babelOptions({ sourceType, extraPlugins })\n        )\n      );\n    } catch (error) {\n      // babel error prints (l:c) with cols that are zero indexed\n      // so we need our custom error\n      const { message, loc } = error;\n\n      throw createError(message.replace(/ \\(.*\\)/, \"\"), {\n        start: {\n          line: loc ? loc.line : 0,\n          column: loc ? loc.column + 1 : 0,\n        },\n      });\n    }\n\n    return postprocess(ast, { ...opts, originalText: text });\n  };\n}\n\nconst parse = createParse(\"parse\", [\"jsx\", \"flow\"]);\nconst parseFlow = createParse(\"parse\", [\n  \"jsx\",\n  [\"flow\", { all: true, enums: true }],\n]);\nconst parseTypeScript = createParse(\n  \"parse\",\n  [\"jsx\", \"typescript\"],\n  [\"typescript\"]\n);\nconst parseExpression = createParse(\"parseExpression\", [\"jsx\"]);\n\nfunction tryCombinations(fn, combinations) {\n  let error;\n  for (let i = 0; i < combinations.length; i++) {\n    try {\n      return rethrowSomeRecoveredErrors(fn(combinations[i]));\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n  throw error;\n}\n\nconst messagesShouldThrow = new Set([\n  // TSErrors.UnexpectedTypeAnnotation\n  // https://github.com/babel/babel/blob/008fe25ae22e78288fbc637d41069bb4a1040987/packages/babel-parser/src/plugins/typescript/index.js#L95\n  \"Did not expect a type annotation here.\",\n  // ErrorMessages.ModuleAttributeDifferentFromType\n  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/parser/error-message.js#L92\n  \"The only accepted module attribute is `type`\",\n  // FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction\n  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/plugins/flow.js#L118\n  \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",\n]);\n\nfunction shouldRethrow(error) {\n  const [, message] = error.message.match(/(.*?)\\s*\\(\\d+:\\d+\\)/);\n  // Only works for literal message\n  return messagesShouldThrow.has(message);\n}\n\nfunction rethrowSomeRecoveredErrors(ast) {\n  const error = ast.errors.find((error) => shouldRethrow(error));\n  if (error) {\n    throw error;\n  }\n\n  return ast;\n}\n\nfunction parseJson(text, parsers, opts) {\n  const ast = parseExpression(text, parsers, opts);\n\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n    case \"ObjectProperty\":\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      }\n\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n      return [node.key, node.value].forEach(assertJsonChildNode);\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        default:\n          throw createJsonError(\"operator\");\n      }\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n      throw createJsonError();\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  }\n\n  function createJsonError(attribute) {\n    const name = !attribute\n      ? node.type\n      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;\n    return createError(`${name} is not allowed in JSON.`, {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1,\n      },\n    });\n  }\n}\n\nconst babel = { parse, astFormat: \"estree\", hasPragma, locStart, locEnd };\nconst babelFlow = { ...babel, parse: parseFlow };\nconst babelTypeScript = { ...babel, parse: parseTypeScript };\nconst babelExpression = { ...babel, parse: parseExpression };\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    babel,\n    \"babel-flow\": babelFlow,\n    \"babel-ts\": babelTypeScript,\n    json: {\n      ...babelExpression,\n      hasPragma() {\n        return true;\n      },\n    },\n    json5: babelExpression,\n    \"json-stringify\": {\n      parse: parseJson,\n      astFormat: \"estree-json\",\n      locStart,\n      locEnd,\n    },\n    /** @internal */\n    __js_expression: babelExpression,\n    /** for vue filter */\n    __vue_expression: babelExpression,\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel,\n  },\n};"
    },
    "2": {
        "bug_file": "src/language-js/index.js",
        "compressed": "NO",
        "line_numbers": 161,
        "compressed_line_numbers": 161,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createLanguage = require(\"../utils/create-language\");\nconst estreePrinter = require(\"./printer-estree\");\nconst estreeJsonPrinter = require(\"./printer-estree-json\");\nconst options = require(\"./options\");\n\nconst languages = [\n  createLanguage(\n    require(\"linguist-languages/data/JavaScript.json\"),\n    (data) => ({\n      since: \"0.0.0\",\n      parsers: [\n        \"babel\",\n        \"espree\",\n        \"babel-flow\",\n        \"babel-ts\",\n        \"flow\",\n        \"typescript\",\n      ],\n      vscodeLanguageIds: [\"javascript\", \"mongo\"],\n      extensions: [\n        ...data.extensions,\n        // WeiXin Script (Weixin Mini Programs)\n        // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/\n        \".wxs\",\n      ],\n    })\n  ),\n  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({\n    name: \"Flow\",\n    since: \"0.0.0\",\n    parsers: [\"flow\", \"babel-flow\"],\n    vscodeLanguageIds: [\"javascript\"],\n    aliases: [],\n    filenames: [],\n    extensions: [\".js.flow\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/JSX.json\"), () => ({\n    since: \"0.0.0\",\n    parsers: [\n      \"babel\",\n      \"babel-flow\",\n      \"babel-ts\",\n      \"flow\",\n      \"typescript\",\n      \"espree\",\n    ],\n    vscodeLanguageIds: [\"javascriptreact\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/TypeScript.json\"), () => ({\n    since: \"1.4.0\",\n    parsers: [\"typescript\", \"babel-ts\"],\n    vscodeLanguageIds: [\"typescript\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/TSX.json\"), () => ({\n    since: \"1.4.0\",\n    parsers: [\"typescript\", \"babel-ts\"],\n    vscodeLanguageIds: [\"typescriptreact\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/JSON.json\"), () => ({\n    name: \"JSON.stringify\",\n    since: \"1.13.0\",\n    parsers: [\"json-stringify\"],\n    vscodeLanguageIds: [\"json\"],\n    extensions: [], // .json file defaults to json instead of json-stringify\n    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],\n  })),\n  createLanguage(require(\"linguist-languages/data/JSON.json\"), (data) => ({\n    since: \"1.5.0\",\n    parsers: [\"json\"],\n    vscodeLanguageIds: [\"json\"],\n    filenames: [...data.filenames, \".prettierrc\"],\n    extensions: data.extensions.filter((extension) => extension !== \".jsonl\"),\n  })),\n  createLanguage(\n    require(\"linguist-languages/data/JSON with Comments.json\"),\n    (data) => ({\n      since: \"1.5.0\",\n      parsers: [\"json\"],\n      vscodeLanguageIds: [\"jsonc\"],\n      filenames: [...data.filenames, \".eslintrc\"],\n    })\n  ),\n  createLanguage(require(\"linguist-languages/data/JSON5.json\"), () => ({\n    since: \"1.13.0\",\n    parsers: [\"json5\"],\n    vscodeLanguageIds: [\"json5\"],\n  })),\n];\n\nconst printers = {\n  estree: estreePrinter,\n  \"estree-json\": estreeJsonPrinter,\n};\n\nconst parsers = {\n  // JS - Babel\n  get babel() {\n    return require(\"./parser-babel\").parsers.babel;\n  },\n  get \"babel-flow\"() {\n    return require(\"./parser-babel\").parsers[\"babel-flow\"];\n  },\n  get \"babel-ts\"() {\n    return require(\"./parser-babel\").parsers[\"babel-ts\"];\n  },\n  get json() {\n    return require(\"./parser-babel\").parsers.json;\n  },\n  get json5() {\n    return require(\"./parser-babel\").parsers.json5;\n  },\n  get \"json-stringify\"() {\n    return require(\"./parser-babel\").parsers[\"json-stringify\"];\n  },\n  get __js_expression() {\n    return require(\"./parser-babel\").parsers.__js_expression;\n  },\n  get __vue_expression() {\n    return require(\"./parser-babel\").parsers.__vue_expression;\n  },\n  get __vue_event_binding() {\n    return require(\"./parser-babel\").parsers.__vue_event_binding;\n  },\n  // JS - Flow\n  get flow() {\n    return require(\"./parser-flow\").parsers.flow;\n  },\n  // JS - TypeScript\n  get typescript() {\n    return require(\"./parser-typescript\").parsers.typescript;\n  },\n  // JS - Angular Action\n  get __ng_action() {\n    return require(\"./parser-angular\").parsers.__ng_action;\n  },\n  // JS - Angular Binding\n  get __ng_binding() {\n    return require(\"./parser-angular\").parsers.__ng_binding;\n  },\n  // JS - Angular Interpolation\n  get __ng_interpolation() {\n    return require(\"./parser-angular\").parsers.__ng_interpolation;\n  },\n  // JS - Angular Directive\n  get __ng_directive() {\n    return require(\"./parser-angular\").parsers.__ng_directive;\n  },\n  // JS - espree\n  get espree() {\n    return require(\"./parser-espree\").parsers.espree;\n  },\n};\n\nmodule.exports = {\n  languages,\n  options,\n  printers,\n  parsers,\n};"
    }
}