{
    "1": {
        "bug_file": "src/language-js/printer-estree.js",
        "compressed": "YES",
        "line_numbers": 1304,
        "compressed_line_numbers": 117,
        "compressed_bug_file_content": "\n\n/** @typedef {import(\"../document\").Doc} Doc */\n\n/** @type {import(\"assert\")} */\n\n\n// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\n    // their decorators are handled themselves\n\n\n    // If the parent node is an export declaration and the decorator\n    // was written before the export, the export will be responsible\n    // for printing the decorators.\n\n\n    // Only print decorators here if they were written before the export,\n    // otherwise they are printed by the node.declaration\n\n\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n\n\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing pathNeedsParens() except in this case.\n\n\n  /** @type{Doc[]} */\n\n\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n\n\n      // Babel 6\n\n\n      // Only force a trailing newline if there were any contents.\n\n\n    // Babel extension.\n\n\n      // Detect Flow and TypeScript directives\n\n\n      // Do not append semicolon after the only JSX element in a program\n\n\n    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\n\n\n    // Babel 6\n\n\n        // For ExpressionStatements and for-loop heads, which are among\n        // the few places a SequenceExpression appears unparenthesized, we want\n        // to indent expressions after the first.\n\n\n      // babel: n.extra.raw, flow: n.bigint\n\n\n      // typescript\n\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n\n\n        // Indent first var to comply with eslint one-var rule\n\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n\n\n        /* sameLine */ true\n\n\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n\n    // JSX extensions below.\n\n\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n\n      /* istanbul ignore next */\n\n\n                /* sameIndent */ true\n\n\n    // fall through\n\n\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n\n      // babel use `id`, meriyah use `name`\n\n\n      /* istanbul ignore next */\n\n\n    // TODO: Make this as default behavior\n\n\n"
    },
    "2": {
        "bug_file": "src/language-js/parser-babel.js",
        "compressed": "NO",
        "line_numbers": 286,
        "compressed_line_numbers": 286,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst {\n  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,\n  getShebang,\n} = require(\"../common/util\");\nconst { hasPragma } = require(\"./pragma\");\nconst { locStart, locEnd } = require(\"./loc\");\nconst postprocess = require(\"./parse-postprocess\");\n\nfunction babelOptions({ sourceType, extraPlugins = [] }) {\n  return {\n    sourceType,\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowUndeclaredExports: true,\n    errorRecovery: true,\n    createParenthesizedExpressions: true,\n    plugins: [\n      // When adding a plugin, please add a test in `tests/js/babel-plugins`,\n      // To remove plugins, remove it here and run `yarn test tests/js/babel-plugins` to verify\n\n      \"doExpressions\",\n      \"classProperties\",\n      \"exportDefaultFrom\",\n      \"functionBind\",\n      \"functionSent\",\n      \"classPrivateProperties\",\n      \"throwExpressions\",\n      \"classPrivateMethods\",\n      \"v8intrinsic\",\n      \"partialApplication\",\n      [\"decorators\", { decoratorsBeforeExport: false }],\n      \"privateIn\",\n      \"importAssertions\",\n      [\"recordAndTuple\", { syntaxType: \"hash\" }],\n      \"decimal\",\n      \"moduleStringNames\",\n      \"classStaticBlock\",\n      ...extraPlugins,\n    ],\n    tokens: true,\n    ranges: true,\n  };\n}\n\nfunction resolvePluginsConflict(\n  condition,\n  pluginCombinations,\n  conflictPlugins\n) {\n  if (!condition) {\n    return pluginCombinations;\n  }\n  const combinations = [];\n  for (const combination of pluginCombinations) {\n    for (const plugin of conflictPlugins) {\n      combinations.push([...combination, plugin]);\n    }\n  }\n  return combinations;\n}\n\n// Similar to babel\n// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67\nconst FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;\nfunction isFlowFile(text, options) {\n  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {\n    return true;\n  }\n\n  const shebang = getShebang(text);\n  if (shebang) {\n    text = text.slice(shebang.length);\n  }\n\n  const firstNonSpaceNonCommentCharacterIndex = getNextNonSpaceNonCommentCharacterIndexWithStartIndex(\n    text,\n    0\n  );\n\n  if (firstNonSpaceNonCommentCharacterIndex !== false) {\n    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);\n  }\n\n  return FLOW_PRAGMA_REGEX.test(text);\n}\n\nfunction createParse(parseMethod, ...pluginCombinations) {\n  return (text, parsers, opts = {}) => {\n    if (opts.parser === \"babel\" && isFlowFile(text, opts)) {\n      opts.parser = \"babel-flow\";\n      return parseFlow(text, parsers, opts);\n    }\n\n    // Inline the require to avoid loading all the JS if we don't use it\n    const babel = require(\"@babel/parser\");\n\n    const sourceType =\n      opts.__babelSourceType === \"script\" ? \"script\" : \"module\";\n\n    let ast;\n    try {\n      const combinations = resolvePluginsConflict(\n        text.includes(\"|>\"),\n        pluginCombinations,\n        [\n          [\"pipelineOperator\", { proposal: \"smart\" }],\n          [\"pipelineOperator\", { proposal: \"minimal\" }],\n          [\"pipelineOperator\", { proposal: \"fsharp\" }],\n        ]\n      );\n      ast = tryCombinations(\n        (options) => babel[parseMethod](text, options),\n        combinations.map((extraPlugins) =>\n          babelOptions({ sourceType, extraPlugins })\n        )\n      );\n    } catch (error) {\n      // babel error prints (l:c) with cols that are zero indexed\n      // so we need our custom error\n      const { message, loc } = error;\n\n      throw createError(message.replace(/ \\(.*\\)/, \"\"), {\n        start: {\n          line: loc ? loc.line : 0,\n          column: loc ? loc.column + 1 : 0,\n        },\n      });\n    }\n\n    return postprocess(ast, { ...opts, originalText: text });\n  };\n}\n\nconst parse = createParse(\"parse\", [\"jsx\", \"flow\"]);\nconst parseFlow = createParse(\"parse\", [\n  \"jsx\",\n  [\"flow\", { all: true, enums: true }],\n]);\nconst parseTypeScript = createParse(\n  \"parse\",\n  [\"jsx\", \"typescript\"],\n  [\"typescript\"]\n);\nconst parseExpression = createParse(\"parseExpression\", [\"jsx\"]);\n\nfunction tryCombinations(fn, combinations) {\n  let error;\n  for (let i = 0; i < combinations.length; i++) {\n    try {\n      return rethrowSomeRecoveredErrors(fn(combinations[i]));\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n  throw error;\n}\n\nconst messagesShouldThrow = new Set([\n  // TSErrors.UnexpectedTypeAnnotation\n  // https://github.com/babel/babel/blob/008fe25ae22e78288fbc637d41069bb4a1040987/packages/babel-parser/src/plugins/typescript/index.js#L95\n  \"Did not expect a type annotation here.\",\n  // ErrorMessages.ModuleAttributeDifferentFromType\n  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/parser/error-message.js#L92\n  \"The only accepted module attribute is `type`\",\n  // FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction\n  // https://github.com/babel/babel/blob/a023b6456cac4505096028f91c5b78829955bfc2/packages/babel-parser/src/plugins/flow.js#L118\n  \"Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`\",\n]);\n\nfunction shouldRethrow(error) {\n  const [, message] = error.message.match(/(.*?)\\s*\\(\\d+:\\d+\\)/);\n  // Only works for literal message\n  return messagesShouldThrow.has(message);\n}\n\nfunction rethrowSomeRecoveredErrors(ast) {\n  const error = ast.errors.find((error) => shouldRethrow(error));\n  if (error) {\n    throw error;\n  }\n\n  return ast;\n}\n\nfunction parseJson(text, parsers, opts) {\n  const ast = parseExpression(text, parsers, opts);\n\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n    case \"ObjectProperty\":\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      }\n\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n      return [node.key, node.value].forEach(assertJsonChildNode);\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        default:\n          throw createJsonError(\"operator\");\n      }\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n      throw createJsonError();\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  }\n\n  function createJsonError(attribute) {\n    const name = !attribute\n      ? node.type\n      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;\n    return createError(`${name} is not allowed in JSON.`, {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1,\n      },\n    });\n  }\n}\n\nconst babel = { parse, astFormat: \"estree\", hasPragma, locStart, locEnd };\nconst babelFlow = { ...babel, parse: parseFlow };\nconst babelTypeScript = { ...babel, parse: parseTypeScript };\nconst babelExpression = { ...babel, parse: parseExpression };\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    babel,\n    \"babel-flow\": babelFlow,\n    \"babel-ts\": babelTypeScript,\n    json: {\n      ...babelExpression,\n      hasPragma() {\n        return true;\n      },\n    },\n    json5: babelExpression,\n    \"json-stringify\": {\n      parse: parseJson,\n      astFormat: \"estree-json\",\n      locStart,\n      locEnd,\n    },\n    /** @internal */\n    __js_expression: babelExpression,\n    /** for vue filter */\n    __vue_expression: babelExpression,\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel,\n  },\n};"
    },
    "3": {
        "bug_file": "src/language-js/embed.js",
        "compressed": "NO",
        "line_numbers": 298,
        "compressed_line_numbers": 298,
        "compressed_bug_file_content": "\"use strict\";\n\nconst { hasComment, CommentCheckFlags } = require(\"./utils\");\nconst formatMarkdown = require(\"./embed/markdown\");\nconst formatCss = require(\"./embed/css\");\nconst formatGraphql = require(\"./embed/graphql\");\nconst formatHtml = require(\"./embed/html\");\n\nfunction getLanguage(path) {\n  if (\n    isStyledJsx(path) ||\n    isStyledComponents(path) ||\n    isCssProp(path) ||\n    isAngularComponentStyles(path)\n  ) {\n    return \"css\";\n  }\n\n  if (isGraphQL(path)) {\n    return \"graphql\";\n  }\n\n  if (isHtml(path)) {\n    return \"html\";\n  }\n\n  if (isAngularComponentTemplate(path)) {\n    return \"angular\";\n  }\n\n  if (isMarkdown(path)) {\n    return \"markdown\";\n  }\n}\n\nfunction embed(path, print, textToDoc, options) {\n  const node = path.getValue();\n\n  if (\n    node.type !== \"TemplateLiteral\" ||\n    // Bail out if any of the quasis have an invalid escape sequence\n    // (which would make the `cooked` value be `null`)\n    hasInvalidCookedValue(node)\n  ) {\n    return;\n  }\n\n  const language = getLanguage(path);\n  if (!language) {\n    return;\n  }\n\n  if (language === \"markdown\") {\n    return formatMarkdown(path, print, textToDoc);\n  }\n\n  if (language === \"css\") {\n    return formatCss(path, print, textToDoc);\n  }\n\n  if (language === \"graphql\") {\n    return formatGraphql(path, print, textToDoc);\n  }\n\n  if (language === \"html\" || language === \"angular\") {\n    return formatHtml(path, print, textToDoc, options, { parser: language });\n  }\n}\n\n/**\n * md`...`\n * markdown`...`\n */\nfunction isMarkdown(path) {\n  const node = path.getValue();\n  const parent = path.getParentNode();\n  return (\n    parent &&\n    parent.type === \"TaggedTemplateExpression\" &&\n    node.quasis.length === 1 &&\n    parent.tag.type === \"Identifier\" &&\n    (parent.tag.name === \"md\" || parent.tag.name === \"markdown\")\n  );\n}\n\n/**\n * Template literal in these contexts:\n * <style jsx>{`div{color:red}`}</style>\n * css``\n * css.global``\n * css.resolve``\n */\nfunction isStyledJsx(path) {\n  const node = path.getValue();\n  const parent = path.getParentNode();\n  const parentParent = path.getParentNode(1);\n  return (\n    (parentParent &&\n      node.quasis &&\n      parent.type === \"JSXExpressionContainer\" &&\n      parentParent.type === \"JSXElement\" &&\n      parentParent.openingElement.name.name === \"style\" &&\n      parentParent.openingElement.attributes.some(\n        (attribute) => attribute.name.name === \"jsx\"\n      )) ||\n    (parent &&\n      parent.type === \"TaggedTemplateExpression\" &&\n      parent.tag.type === \"Identifier\" &&\n      parent.tag.name === \"css\") ||\n    (parent &&\n      parent.type === \"TaggedTemplateExpression\" &&\n      parent.tag.type === \"MemberExpression\" &&\n      parent.tag.object.name === \"css\" &&\n      (parent.tag.property.name === \"global\" ||\n        parent.tag.property.name === \"resolve\"))\n  );\n}\n\n/**\n * Angular Components can have:\n * - Inline HTML template\n * - Inline CSS styles\n *\n * ...which are both within template literals somewhere\n * inside of the Component decorator factory.\n *\n * E.g.\n * @Component({\n *  template: `<div>...</div>`,\n *  styles: [`h1 { color: blue; }`]\n * })\n */\nfunction isAngularComponentStyles(path) {\n  return path.match(\n    (node) => node.type === \"TemplateLiteral\",\n    (node, name) => node.type === \"ArrayExpression\" && name === \"elements\",\n    (node, name) =>\n      (node.type === \"Property\" || node.type === \"ObjectProperty\") &&\n      node.key.type === \"Identifier\" &&\n      node.key.name === \"styles\" &&\n      name === \"value\",\n    ...angularComponentObjectExpressionPredicates\n  );\n}\nfunction isAngularComponentTemplate(path) {\n  return path.match(\n    (node) => node.type === \"TemplateLiteral\",\n    (node, name) =>\n      (node.type === \"Property\" || node.type === \"ObjectProperty\") &&\n      node.key.type === \"Identifier\" &&\n      node.key.name === \"template\" &&\n      name === \"value\",\n    ...angularComponentObjectExpressionPredicates\n  );\n}\nconst angularComponentObjectExpressionPredicates = [\n  (node, name) => node.type === \"ObjectExpression\" && name === \"properties\",\n  (node, name) =>\n    node.type === \"CallExpression\" &&\n    node.callee.type === \"Identifier\" &&\n    node.callee.name === \"Component\" &&\n    name === \"arguments\",\n  (node, name) => node.type === \"Decorator\" && name === \"expression\",\n];\n\n/**\n * styled-components template literals\n */\nfunction isStyledComponents(path) {\n  const parent = path.getParentNode();\n\n  if (!parent || parent.type !== \"TaggedTemplateExpression\") {\n    return false;\n  }\n\n  const { tag } = parent;\n\n  switch (tag.type) {\n    case \"MemberExpression\":\n      return (\n        // styled.foo``\n        isStyledIdentifier(tag.object) ||\n        // Component.extend``\n        isStyledExtend(tag)\n      );\n\n    case \"CallExpression\":\n      return (\n        // styled(Component)``\n        isStyledIdentifier(tag.callee) ||\n        (tag.callee.type === \"MemberExpression\" &&\n          ((tag.callee.object.type === \"MemberExpression\" &&\n            // styled.foo.attrs({})``\n            (isStyledIdentifier(tag.callee.object.object) ||\n              // Component.extend.attrs({})``\n              isStyledExtend(tag.callee.object))) ||\n            // styled(Component).attrs({})``\n            (tag.callee.object.type === \"CallExpression\" &&\n              isStyledIdentifier(tag.callee.object.callee))))\n      );\n\n    case \"Identifier\":\n      // css``\n      return tag.name === \"css\";\n\n    default:\n      return false;\n  }\n}\n\n/**\n * JSX element with CSS prop\n */\nfunction isCssProp(path) {\n  const parent = path.getParentNode();\n  const parentParent = path.getParentNode(1);\n  return (\n    parentParent &&\n    parent.type === \"JSXExpressionContainer\" &&\n    parentParent.type === \"JSXAttribute\" &&\n    parentParent.name.type === \"JSXIdentifier\" &&\n    parentParent.name.name === \"css\"\n  );\n}\n\nfunction isStyledIdentifier(node) {\n  return node.type === \"Identifier\" && node.name === \"styled\";\n}\n\nfunction isStyledExtend(node) {\n  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";\n}\n\n/*\n * react-relay and graphql-tag\n * graphql`...`\n * graphql.experimental`...`\n * gql`...`\n * GraphQL comment block\n *\n * This intentionally excludes Relay Classic tags, as Prettier does not\n * support Relay Classic formatting.\n */\nfunction isGraphQL(path) {\n  const node = path.getValue();\n  const parent = path.getParentNode();\n\n  return (\n    hasLanguageComment(node, \"GraphQL\") ||\n    (parent &&\n      ((parent.type === \"TaggedTemplateExpression\" &&\n        ((parent.tag.type === \"MemberExpression\" &&\n          parent.tag.object.name === \"graphql\" &&\n          parent.tag.property.name === \"experimental\") ||\n          (parent.tag.type === \"Identifier\" &&\n            (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")))) ||\n        (parent.type === \"CallExpression\" &&\n          parent.callee.type === \"Identifier\" &&\n          parent.callee.name === \"graphql\")))\n  );\n}\n\nfunction hasLanguageComment(node, languageName) {\n  // This checks for a leading comment that is exactly `/* GraphQL */`\n  // In order to be in line with other implementations of this comment tag\n  // we will not trim the comment value and we will expect exactly one space on\n  // either side of the GraphQL string\n  // Also see ./clean.js\n  return hasComment(\n    node,\n    CommentCheckFlags.Block | CommentCheckFlags.Leading,\n    ({ value }) => value === ` ${languageName} `\n  );\n}\n\n/**\n *     - html`...`\n *     - HTML comment block\n */\nfunction isHtml(path) {\n  return (\n    hasLanguageComment(path.getValue(), \"HTML\") ||\n    path.match(\n      (node) => node.type === \"TemplateLiteral\",\n      (node, name) =>\n        node.type === \"TaggedTemplateExpression\" &&\n        node.tag.type === \"Identifier\" &&\n        node.tag.name === \"html\" &&\n        name === \"quasi\"\n    )\n  );\n}\n\nfunction hasInvalidCookedValue({ quasis }) {\n  return quasis.some(({ value: { cooked } }) => cooked === null);\n}\n\nmodule.exports = embed;"
    },
    "4": {
        "bug_file": "src/language-js/print/jsx.js",
        "compressed": "YES",
        "line_numbers": 770,
        "compressed_line_numbers": 143,
        "compressed_bug_file_content": "\n\n// JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\n\n\n  // Convert `{\" \"}` to text nodes containing a space.\n  // This makes it easy to turn them into `jsxWhitespace` which\n  // can then print as either a space or `{\" \"}` when breaking.\n\n\n  // Record any breaks. Should never go from true to false, only false to true.\n\n\n  // We can end up we multiple whitespace elements with empty string\n  // content between them.\n  // We need to remove empty whitespace and softlines before JSX whitespace\n  // to get the correct output.\n\n\n  // Trim trailing lines (or empty strings)\n\n\n  // Trim leading lines (or empty strings)\n\n\n  // Tweak how we format children if outputting this element over multiple lines.\n  // Also detect whether we will force this element to output over multiple lines.\n\n\n    // There are a number of situations where we need to ensure we display\n    // whitespace as `{\" \"}` when outputting this element over multiple lines.\n\n\n          // Solitary whitespace\n\n\n        // Leading whitespace\n\n\n        // Trailing whitespace\n\n\n        // Whitespace after line break\n\n\n  // If there is text we use `fill` to fit as much onto each line as possible.\n  // When there is no text (just tags and expressions) we use `group`\n  // to output each on a separate line.\n\n\n// JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\n\n\n      // Contains a non-whitespace character\n\n\n        // Starts with whitespace\n\n\n        // Ends with whitespace\n\n\n        // This was whitespace only without a new line.\n\n\n        // Keep (up to one) blank line between tags/expressions/text.\n        // Note: We don't keep blank lines between text elements.\n\n\n  /* istanbul ignore next */\n\n\n      // Unescape all quotes so we get an accurate preferred quote\n\n\n  // Don't break self-closing elements with no attributes and no comments\n\n\n  // don't break up opening elements with a single long text attribute\n\n\n    // We should break for the following cases:\n    // <div\n    //   // comment\n    //   attr=\"value\"\n    // >\n    // <div\n    //   attr=\"value\"\n    //   // comment\n    // >\n\n\n    // Simple tags (no attributes and no comment in tag name) should be\n    // kept unbroken regardless of `jsxBracketSameLine`\n\n\n      // We should print the bracket in a new line for the following cases:\n      // <div\n      //   // comment\n      // >\n      // <div\n      //   attr // comment\n      // >\n\n\n  // We should print the opening element expanded if any prop value is a\n  // string literal with newlines\n\n\n// `JSXSpreadAttribute` and `JSXSpreadChild`\n\n\n      // Same as `printJsxSpreadAttribute`\n\n\n      /* istanbul ignore next */\n\n\n"
    }
}