{
    "src/language-js/printer-estree.js": [
        "\"use strict\";",
        "",
        "/** @typedef {import(\"../document\").Doc} Doc */",
        "",
        "/** @type {import(\"assert\")} */",
        "const assert = require(\"assert\");",
        "",
        "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
        "const comments = require(\"../main/comments\");",
        "const {",
        "  hasNewline,",
        "  printString,",
        "  printNumber,",
        "  isNextLineEmpty,",
        "} = require(\"../common/util\");",
        "const {",
        "  builders: {",
        "    concat,",
        "    join,",
        "    line,",
        "    hardline,",
        "    softline,",
        "    literalline,",
        "    group,",
        "    indent,",
        "  },",
        "  utils: { isEmpty },",
        "} = require(\"../document\");",
        "const embed = require(\"./embed\");",
        "const clean = require(\"./clean\");",
        "const { insertPragma } = require(\"./pragma\");",
        "const handleComments = require(\"./comments\");",
        "const pathNeedsParens = require(\"./needs-parens\");",
        "const preprocess = require(\"./print-preprocess\");",
        "const {",
        "  getCallArguments,",
        "  getParentExportDeclaration,",
        "  hasFlowShorthandAnnotationComment,",
        "  hasNewlineBetweenOrAfterDecorators,",
        "  hasPrettierIgnore,",
        "  hasComment,",
        "  CommentCheckFlags,",
        "  isExportDeclaration,",
        "  isFunctionNotation,",
        "  isGetterOrSetter,",
        "  isTheOnlyJSXElementInMarkdown,",
        "  isBlockComment,",
        "  needsHardlineAfterDanglingComment,",
        "  rawText,",
        "  shouldPrintComma,",
        "} = require(\"./utils\");",
        "const { locStart, locEnd } = require(\"./loc\");",
        "",
        "const {",
        "  printHtmlBinding,",
        "  isVueEventBindingExpression,",
        "} = require(\"./print/html-binding\");",
        "const { printAngular } = require(\"./print/angular\");",
        "const { printJsx } = require(\"./print/jsx\");",
        "const { printFlow } = require(\"./print/flow\");",
        "const { printTypescript } = require(\"./print/typescript\");",
        "const {",
        "  printOptionalToken,",
        "  printBindExpressionCallee,",
        "  printTypeAnnotation,",
        "  adjustClause,",
        "} = require(\"./print/misc\");",
        "const {",
        "  printImportDeclaration,",
        "  printExportDeclaration,",
        "  printExportAllDeclaration,",
        "  printModuleSpecifier,",
        "} = require(\"./print/module\");",
        "const { printTernary } = require(\"./print/ternary\");",
        "const { printTemplateLiteral } = require(\"./print/template-literal\");",
        "const { printArray, printArrayItems } = require(\"./print/array\");",
        "const { printObject } = require(\"./print/object\");",
        "const {",
        "  printClass,",
        "  printClassMethod,",
        "  printClassBody,",
        "  printClassProperty,",
        "} = require(\"./print/class\");",
        "const { printTypeParameters } = require(\"./print/type-parameters\");",
        "const { printPropertyKey, printProperty } = require(\"./print/property\");",
        "const {",
        "  printFunctionDeclaration,",
        "  printArrowFunctionExpression,",
        "  printMethod,",
        "  printReturnStatement,",
        "  printThrowStatement,",
        "} = require(\"./print/function\");",
        "const { printCallExpression } = require(\"./print/call-expression\");",
        "const { printInterface } = require(\"./print/interface\");",
        "const {",
        "  printVariableDeclarator,",
        "  printAssignmentExpression,",
        "} = require(\"./print/assignment\");",
        "const { printBinaryishExpression } = require(\"./print/binaryish\");",
        "const { printStatementSequence } = require(\"./print/statement\");",
        "const { printMemberExpression } = require(\"./print/member\");",
        "const { printBlock } = require(\"./print/block\");",
        "const { printComment } = require(\"./print/comment\");",
        "",
        "function genericPrint(path, options, printPath, args) {",
        "  const node = path.getValue();",
        "  let needsParens = false;",
        "  const linesWithoutParens = printPathNoParens(path, options, printPath, args);",
        "",
        "  if (!node || isEmpty(linesWithoutParens)) {",
        "    return linesWithoutParens;",
        "  }",
        "",
        "  const parentExportDecl = getParentExportDeclaration(path);",
        "  const decorators = [];",
        "  if (",
        "    node.type === \"ClassMethod\" ||",
        "    node.type === \"ClassPrivateMethod\" ||",
        "    node.type === \"ClassProperty\" ||",
        "    node.type === \"FieldDefinition\" ||",
        "    node.type === \"TSAbstractClassProperty\" ||",
        "    node.type === \"ClassPrivateProperty\" ||",
        "    node.type === \"MethodDefinition\" ||",
        "    node.type === \"TSAbstractMethodDefinition\" ||",
        "    node.type === \"TSDeclareMethod\"",
        "  ) {",
        "    // their decorators are handled themselves",
        "  } else if (",
        "    node.decorators &&",
        "    node.decorators.length > 0 &&",
        "    // If the parent node is an export declaration and the decorator",
        "    // was written before the export, the export will be responsible",
        "    // for printing the decorators.",
        "    !(",
        "      parentExportDecl &&",
        "      locStart(parentExportDecl, { ignoreDecorators: true }) >",
        "        locStart(node.decorators[0])",
        "    )",
        "  ) {",
        "    const shouldBreak =",
        "      node.type === \"ClassExpression\" ||",
        "      node.type === \"ClassDeclaration\" ||",
        "      hasNewlineBetweenOrAfterDecorators(node, options);",
        "",
        "    const separator = shouldBreak ? hardline : line;",
        "",
        "    path.each((decoratorPath) => {",
        "      let decorator = decoratorPath.getValue();",
        "      if (decorator.expression) {",
        "        decorator = decorator.expression;",
        "      } else {",
        "        decorator = decorator.callee;",
        "      }",
        "",
        "      decorators.push(printPath(decoratorPath), separator);",
        "    }, \"decorators\");",
        "",
        "    if (parentExportDecl) {",
        "      decorators.unshift(hardline);",
        "    }",
        "  } else if (",
        "    isExportDeclaration(node) &&",
        "    node.declaration &&",
        "    node.declaration.decorators &&",
        "    node.declaration.decorators.length > 0 &&",
        "    // Only print decorators here if they were written before the export,",
        "    // otherwise they are printed by the node.declaration",
        "    locStart(node, { ignoreDecorators: true }) >",
        "      locStart(node.declaration.decorators[0])",
        "  ) {",
        "    // Export declarations are responsible for printing any decorators",
        "    // that logically apply to node.declaration.",
        "    path.each(",
        "      (decoratorPath) => {",
        "        const decorator = decoratorPath.getValue();",
        "        const prefix = decorator.type === \"Decorator\" ? \"\" : \"@\";",
        "        decorators.push(prefix, printPath(decoratorPath), hardline);",
        "      },",
        "      \"declaration\",",
        "      \"decorators\"",
        "    );",
        "  } else {",
        "    // Nodes with decorators can't have parentheses, so we can avoid",
        "    // computing pathNeedsParens() except in this case.",
        "    needsParens = pathNeedsParens(path, options);",
        "  }",
        "",
        "  const parts = [];",
        "  if (needsParens) {",
        "    parts.unshift(\"(\");",
        "  }",
        "",
        "  parts.push(linesWithoutParens);",
        "",
        "  if (needsParens) {",
        "    const node = path.getValue();",
        "    if (hasFlowShorthandAnnotationComment(node)) {",
        "      parts.push(\" /*\");",
        "      parts.push(node.trailingComments[0].value.trimStart());",
        "      parts.push(\"*/\");",
        "      node.trailingComments[0].printed = true;",
        "    }",
        "",
        "    parts.push(\")\");",
        "  }",
        "",
        "  if (decorators.length > 0) {",
        "    return group(concat(decorators.concat(parts)));",
        "  }",
        "  return concat(parts);",
        "}",
        "",
        "function printPathNoParens(path, options, print, args) {",
        "  const n = path.getValue();",
        "  const semi = options.semi ? \";\" : \"\";",
        "",
        "  if (!n) {",
        "    return \"\";",
        "  }",
        "",
        "  if (typeof n === \"string\") {",
        "    return n;",
        "  }",
        "",
        "  for (const printer of [",
        "    printHtmlBinding,",
        "    printAngular,",
        "    printJsx,",
        "    printFlow,",
        "    printTypescript,",
        "  ]) {",
        "    const printed = printer(path, options, print);",
        "    if (typeof printed !== \"undefined\") {",
        "      return printed;",
        "    }",
        "  }",
        "",
        "  /** @type{Doc[]} */",
        "  let parts = [];",
        "",
        "  switch (n.type) {",
        "    case \"JsExpressionRoot\":",
        "      return path.call(print, \"node\");",
        "    case \"JsonRoot\":",
        "      return concat([path.call(print, \"node\"), hardline]);",
        "    case \"File\":",
        "      // Print @babel/parser's InterpreterDirective here so that",
        "      // leading comments on the `Program` node get printed after the hashbang.",
        "      if (n.program && n.program.interpreter) {",
        "        parts.push(",
        "          path.call(",
        "            (programPath) => programPath.call(print, \"interpreter\"),",
        "            \"program\"",
        "          )",
        "        );",
        "      }",
        "",
        "      parts.push(path.call(print, \"program\"));",
        "",
        "      return concat(parts);",
        "",
        "    case \"Program\": {",
        "      const hasContents =",
        "        !n.body.every(({ type }) => type === \"EmptyStatement\") || hasComment(n);",
        "",
        "      // Babel 6",
        "      if (n.directives) {",
        "        const directivesCount = n.directives.length;",
        "        path.each((childPath, index) => {",
        "          parts.push(print(childPath), semi, hardline);",
        "          if (",
        "            (index < directivesCount - 1 || hasContents) &&",
        "            isNextLineEmpty(options.originalText, childPath.getValue(), locEnd)",
        "          ) {",
        "            parts.push(hardline);",
        "          }",
        "        }, \"directives\");",
        "      }",
        "",
        "      parts.push(",
        "        path.call((bodyPath) => {",
        "          return printStatementSequence(bodyPath, options, print);",
        "        }, \"body\")",
        "      );",
        "",
        "      parts.push(",
        "        comments.printDanglingComments(path, options, /* sameIndent */ true)",
        "      );",
        "",
        "      // Only force a trailing newline if there were any contents.",
        "      if (hasContents) {",
        "        parts.push(hardline);",
        "      }",
        "",
        "      return concat(parts);",
        "    }",
        "    // Babel extension.",
        "    case \"EmptyStatement\":",
        "      return \"\";",
        "    case \"ExpressionStatement\":",
        "      // Detect Flow and TypeScript directives",
        "      if (n.directive) {",
        "        return concat([nodeStr(n.expression, options, true), semi]);",
        "      }",
        "",
        "      if (options.parser === \"__vue_event_binding\") {",
        "        const parent = path.getParentNode();",
        "        if (",
        "          parent.type === \"Program\" &&",
        "          parent.body.length === 1 &&",
        "          parent.body[0] === n",
        "        ) {",
        "          return concat([",
        "            path.call(print, \"expression\"),",
        "            isVueEventBindingExpression(n.expression) ? \";\" : \"\",",
        "          ]);",
        "        }",
        "      }",
        "",
        "      // Do not append semicolon after the only JSX element in a program",
        "      return concat([",
        "        path.call(print, \"expression\"),",
        "        isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi,",
        "      ]);",
        "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
        "    case \"ParenthesizedExpression\": {",
        "      const shouldHug = !hasComment(n.expression);",
        "      if (shouldHug) {",
        "        return concat([\"(\", path.call(print, \"expression\"), \")\"]);",
        "      }",
        "      return group(",
        "        concat([",
        "          \"(\",",
        "          indent(concat([softline, path.call(print, \"expression\")])),",
        "          softline,",
        "          \")\",",
        "        ])",
        "      );",
        "    }",
        "    case \"AssignmentExpression\":",
        "      return printAssignmentExpression(path, options, print);",
        "    case \"VariableDeclarator\":",
        "      return printVariableDeclarator(path, options, print);",
        "    case \"BinaryExpression\":",
        "    case \"LogicalExpression\":",
        "      return printBinaryishExpression(path, options, print);",
        "    case \"AssignmentPattern\":",
        "      return concat([",
        "        path.call(print, \"left\"),",
        "        \" = \",",
        "        path.call(print, \"right\"),",
        "      ]);",
        "    case \"OptionalMemberExpression\":",
        "    case \"MemberExpression\": {",
        "      return printMemberExpression(path, options, print);",
        "    }",
        "    case \"MetaProperty\":",
        "      return concat([",
        "        path.call(print, \"meta\"),",
        "        \".\",",
        "        path.call(print, \"property\"),",
        "      ]);",
        "    case \"BindExpression\":",
        "      if (n.object) {",
        "        parts.push(path.call(print, \"object\"));",
        "      }",
        "",
        "      parts.push(",
        "        group(",
        "          indent(",
        "            concat([softline, printBindExpressionCallee(path, options, print)])",
        "          )",
        "        )",
        "      );",
        "",
        "      return concat(parts);",
        "    case \"Identifier\": {",
        "      return concat([",
        "        n.name,",
        "        printOptionalToken(path),",
        "        printTypeAnnotation(path, options, print),",
        "      ]);",
        "    }",
        "    case \"V8IntrinsicIdentifier\":",
        "      return concat([\"%\", n.name]);",
        "    case \"SpreadElement\":",
        "    case \"SpreadElementPattern\":",
        "    case \"SpreadProperty\":",
        "    case \"SpreadPropertyPattern\":",
        "    case \"RestElement\":",
        "    case \"ObjectTypeSpreadProperty\":",
        "      return concat([",
        "        \"...\",",
        "        path.call(print, \"argument\"),",
        "        printTypeAnnotation(path, options, print),",
        "      ]);",
        "    case \"FunctionDeclaration\":",
        "    case \"FunctionExpression\":",
        "      return printFunctionDeclaration(",
        "        path,",
        "        print,",
        "        options,",
        "        args &&",
        "          args.expandLastArg &&",
        "          getCallArguments(path.getParentNode()).length > 1",
        "      );",
        "    case \"ArrowFunctionExpression\":",
        "      return printArrowFunctionExpression(path, options, print, args);",
        "    case \"YieldExpression\":",
        "      parts.push(\"yield\");",
        "",
        "      if (n.delegate) {",
        "        parts.push(\"*\");",
        "      }",
        "      if (n.argument) {",
        "        parts.push(\" \", path.call(print, \"argument\"));",
        "      }",
        "",
        "      return concat(parts);",
        "    case \"AwaitExpression\": {",
        "      parts.push(\"await\");",
        "      if (n.argument) {",
        "        parts.push(\" \", path.call(print, \"argument\"));",
        "      }",
        "      const parent = path.getParentNode();",
        "      if (",
        "        ((parent.type === \"CallExpression\" ||",
        "          parent.type === \"OptionalCallExpression\") &&",
        "          parent.callee === n) ||",
        "        ((parent.type === \"MemberExpression\" ||",
        "          parent.type === \"OptionalMemberExpression\") &&",
        "          parent.object === n)",
        "      ) {",
        "        return group(",
        "          concat([indent(concat([softline, concat(parts)])), softline])",
        "        );",
        "      }",
        "      return concat(parts);",
        "    }",
        "    case \"ExportDefaultDeclaration\":",
        "    case \"ExportNamedDeclaration\":",
        "      return printExportDeclaration(path, options, print);",
        "    case \"ExportAllDeclaration\":",
        "      return printExportAllDeclaration(path, options, print);",
        "    case \"ImportDeclaration\":",
        "      return printImportDeclaration(path, options, print);",
        "    case \"ImportSpecifier\":",
        "    case \"ExportSpecifier\":",
        "    case \"ImportNamespaceSpecifier\":",
        "    case \"ExportNamespaceSpecifier\":",
        "    case \"ImportDefaultSpecifier\":",
        "    case \"ExportDefaultSpecifier\":",
        "      return printModuleSpecifier(path, options, print);",
        "    case \"ImportAttribute\":",
        "      return concat([path.call(print, \"key\"), \": \", path.call(print, \"value\")]);",
        "    case \"Import\":",
        "      return \"import\";",
        "    case \"BlockStatement\":",
        "    case \"StaticBlock\":",
        "      return printBlock(path, options, print);",
        "    case \"ThrowStatement\":",
        "      return printThrowStatement(path, options, print);",
        "    case \"ReturnStatement\":",
        "      return printReturnStatement(path, options, print);",
        "    case \"NewExpression\":",
        "    case \"ImportExpression\":",
        "    case \"OptionalCallExpression\":",
        "    case \"CallExpression\":",
        "      return printCallExpression(path, options, print);",
        "    case \"ObjectTypeInternalSlot\":",
        "      return concat([",
        "        n.static ? \"static \" : \"\",",
        "        \"[[\",",
        "        path.call(print, \"id\"),",
        "        \"]]\",",
        "        printOptionalToken(path),",
        "        n.method ? \"\" : \": \",",
        "        path.call(print, \"value\"),",
        "      ]);",
        "",
        "    case \"ObjectExpression\":",
        "    case \"ObjectPattern\":",
        "    case \"ObjectTypeAnnotation\":",
        "    case \"RecordExpression\":",
        "      return printObject(path, options, print);",
        "    // Babel 6",
        "    case \"ObjectProperty\": // Non-standard AST node type.",
        "    case \"Property\":",
        "      if (n.method || n.kind === \"get\" || n.kind === \"set\") {",
        "        return printMethod(path, options, print);",
        "      }",
        "      return printProperty(path, options, print);",
        "    case \"ObjectMethod\":",
        "      return printMethod(path, options, print);",
        "    case \"Decorator\":",
        "      return concat([",
        "        \"@\",",
        "        path.call(print, \"expression\"),",
        "        path.call(print, \"callee\"),",
        "      ]);",
        "    case \"ArrayExpression\":",
        "..."
    ],
    "src/language-js/print/jsx.js": [
        "\"use strict\";",
        "",
        "const { printComments, printDanglingComments } = require(\"../../main/comments\");",
        "const {",
        "  builders: {",
        "    concat,",
        "    line,",
        "    hardline,",
        "    softline,",
        "    group,",
        "    indent,",
        "    conditionalGroup,",
        "    fill,",
        "    ifBreak,",
        "    lineSuffixBoundary,",
        "    join,",
        "  },",
        "  utils: { willBreak, isLineNext, isEmpty },",
        "} = require(\"../../document\");",
        "",
        "const { getLast, getPreferredQuote } = require(\"../../common/util\");",
        "const {",
        "  isEmptyJSXElement,",
        "  isJSXWhitespaceExpression,",
        "  isJSXNode,",
        "  isMeaningfulJSXText,",
        "  matchJsxWhitespaceRegex,",
        "  rawText,",
        "  isLiteral,",
        "  isCallOrOptionalCallExpression,",
        "  isStringLiteral,",
        "  isBinaryish,",
        "  hasComment,",
        "  CommentCheckFlags,",
        "} = require(\"../utils\");",
        "const pathNeedsParens = require(\"../needs-parens\");",
        "const { willPrintOwnComments } = require(\"../comments\");",
        "",
        "// JSX expands children from the inside-out, instead of the outside-in.",
        "// This is both to break children before attributes,",
        "// and to ensure that when children break, their parents do as well.",
        "//",
        "// Any element that is written without any newlines and fits on a single line",
        "// is left that way.",
        "// Not only that, any user-written-line containing multiple JSX siblings",
        "// should also be kept on one line if possible,",
        "// so each user-written-line is wrapped in its own group.",
        "//",
        "// Elements that contain newlines or don't fit on a single line (recursively)",
        "// are fully-split, using hardline and shouldBreak: true.",
        "//",
        "// To support that case properly, all leading and trailing spaces",
        "// are stripped from the list of children, and replaced with a single hardline.",
        "function printJsxElementInternal(path, options, print) {",
        "  const n = path.getValue();",
        "",
        "  if (n.type === \"JSXElement\" && isEmptyJSXElement(n)) {",
        "    return concat([",
        "      path.call(print, \"openingElement\"),",
        "      path.call(print, \"closingElement\"),",
        "    ]);",
        "  }",
        "",
        "  const openingLines =",
        "    n.type === \"JSXElement\"",
        "      ? path.call(print, \"openingElement\")",
        "      : path.call(print, \"openingFragment\");",
        "  const closingLines =",
        "    n.type === \"JSXElement\"",
        "      ? path.call(print, \"closingElement\")",
        "      : path.call(print, \"closingFragment\");",
        "",
        "  if (",
        "    n.children.length === 1 &&",
        "    n.children[0].type === \"JSXExpressionContainer\" &&",
        "    (n.children[0].expression.type === \"TemplateLiteral\" ||",
        "      n.children[0].expression.type === \"TaggedTemplateExpression\")",
        "  ) {",
        "    return concat([",
        "      openingLines,",
        "      concat(path.map(print, \"children\")),",
        "      closingLines,",
        "    ]);",
        "  }",
        "",
        "  // Convert `{\" \"}` to text nodes containing a space.",
        "  // This makes it easy to turn them into `jsxWhitespace` which",
        "  // can then print as either a space or `{\" \"}` when breaking.",
        "  n.children = n.children.map((child) => {",
        "    if (isJSXWhitespaceExpression(child)) {",
        "      return {",
        "        type: \"JSXText\",",
        "        value: \" \",",
        "        raw: \" \",",
        "      };",
        "    }",
        "    return child;",
        "  });",
        "",
        "  const containsTag = n.children.filter(isJSXNode).length > 0;",
        "  const containsMultipleExpressions =",
        "    n.children.filter((child) => child.type === \"JSXExpressionContainer\")",
        "      .length > 1;",
        "  const containsMultipleAttributes =",
        "    n.type === \"JSXElement\" && n.openingElement.attributes.length > 1;",
        "",
        "  // Record any breaks. Should never go from true to false, only false to true.",
        "  let forcedBreak =",
        "    willBreak(openingLines) ||",
        "    containsTag ||",
        "    containsMultipleAttributes ||",
        "    containsMultipleExpressions;",
        "",
        "  const isMdxBlock = path.getParentNode().rootMarker === \"mdx\";",
        "",
        "  const rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';",
        "  const jsxWhitespace = isMdxBlock",
        "    ? concat([\" \"])",
        "    : ifBreak(concat([rawJsxWhitespace, softline]), \" \");",
        "",
        "  const isFacebookTranslationTag =",
        "    n.openingElement &&",
        "    n.openingElement.name &&",
        "    n.openingElement.name.name === \"fbt\";",
        "",
        "  const children = printJSXChildren(",
        "    path,",
        "    options,",
        "    print,",
        "    jsxWhitespace,",
        "    isFacebookTranslationTag",
        "  );",
        "",
        "  const containsText = n.children.some((child) => isMeaningfulJSXText(child));",
        "",
        "  // We can end up we multiple whitespace elements with empty string",
        "  // content between them.",
        "  // We need to remove empty whitespace and softlines before JSX whitespace",
        "  // to get the correct output.",
        "  for (let i = children.length - 2; i >= 0; i--) {",
        "    const isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";",
        "    const isPairOfHardlines =",
        "      children[i] === hardline &&",
        "      children[i + 1] === \"\" &&",
        "      children[i + 2] === hardline;",
        "    const isLineFollowedByJSXWhitespace =",
        "      (children[i] === softline || children[i] === hardline) &&",
        "      children[i + 1] === \"\" &&",
        "      children[i + 2] === jsxWhitespace;",
        "    const isJSXWhitespaceFollowedByLine =",
        "      children[i] === jsxWhitespace &&",
        "      children[i + 1] === \"\" &&",
        "      (children[i + 2] === softline || children[i + 2] === hardline);",
        "    const isDoubleJSXWhitespace =",
        "      children[i] === jsxWhitespace &&",
        "      children[i + 1] === \"\" &&",
        "      children[i + 2] === jsxWhitespace;",
        "    const isPairOfHardOrSoftLines =",
        "      (children[i] === softline &&",
        "        children[i + 1] === \"\" &&",
        "        children[i + 2] === hardline) ||",
        "      (children[i] === hardline &&",
        "        children[i + 1] === \"\" &&",
        "        children[i + 2] === softline);",
        "",
        "    if (",
        "      (isPairOfHardlines && containsText) ||",
        "      isPairOfEmptyStrings ||",
        "      isLineFollowedByJSXWhitespace ||",
        "      isDoubleJSXWhitespace ||",
        "      isPairOfHardOrSoftLines",
        "    ) {",
        "      children.splice(i, 2);",
        "    } else if (isJSXWhitespaceFollowedByLine) {",
        "      children.splice(i + 1, 2);",
        "    }",
        "  }",
        "",
        "  // Trim trailing lines (or empty strings)",
        "  while (",
        "    children.length &&",
        "    (isLineNext(getLast(children)) || isEmpty(getLast(children)))",
        "  ) {",
        "    children.pop();",
        "  }",
        "",
        "  // Trim leading lines (or empty strings)",
        "  while (",
        "    children.length &&",
        "    (isLineNext(children[0]) || isEmpty(children[0])) &&",
        "    (isLineNext(children[1]) || isEmpty(children[1]))",
        "  ) {",
        "    children.shift();",
        "    children.shift();",
        "  }",
        "",
        "  // Tweak how we format children if outputting this element over multiple lines.",
        "  // Also detect whether we will force this element to output over multiple lines.",
        "  const multilineChildren = [];",
        "  children.forEach((child, i) => {",
        "    // There are a number of situations where we need to ensure we display",
        "    // whitespace as `{\" \"}` when outputting this element over multiple lines.",
        "    if (child === jsxWhitespace) {",
        "      if (i === 1 && children[i - 1] === \"\") {",
        "        if (children.length === 2) {",
        "          // Solitary whitespace",
        "          multilineChildren.push(rawJsxWhitespace);",
        "          return;",
        "        }",
        "        // Leading whitespace",
        "        multilineChildren.push(concat([rawJsxWhitespace, hardline]));",
        "        return;",
        "      } else if (i === children.length - 1) {",
        "        // Trailing whitespace",
        "        multilineChildren.push(rawJsxWhitespace);",
        "        return;",
        "      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {",
        "        // Whitespace after line break",
        "        multilineChildren.push(rawJsxWhitespace);",
        "        return;",
        "      }",
        "    }",
        "",
        "    multilineChildren.push(child);",
        "",
        "    if (willBreak(child)) {",
        "      forcedBreak = true;",
        "    }",
        "  });",
        "",
        "  // If there is text we use `fill` to fit as much onto each line as possible.",
        "  // When there is no text (just tags and expressions) we use `group`",
        "  // to output each on a separate line.",
        "  const content = containsText",
        "    ? fill(multilineChildren)",
        "    : group(concat(multilineChildren), { shouldBreak: true });",
        "",
        "  if (isMdxBlock) {",
        "    return content;",
        "  }",
        "",
        "  const multiLineElem = group(",
        "    concat([",
        "      openingLines,",
        "      indent(concat([hardline, content])),",
        "      hardline,",
        "      closingLines,",
        "    ])",
        "  );",
        "",
        "  if (forcedBreak) {",
        "    return multiLineElem;",
        "  }",
        "",
        "  return conditionalGroup([",
        "    group(concat([openingLines, concat(children), closingLines])),",
        "    multiLineElem,",
        "  ]);",
        "}",
        "",
        "// JSX Children are strange, mostly for two reasons:",
        "// 1. JSX reads newlines into string values, instead of skipping them like JS",
        "// 2. up to one whitespace between elements within a line is significant,",
        "//    but not between lines.",
        "//",
        "// Leading, trailing, and lone whitespace all need to",
        "// turn themselves into the rather ugly `{' '}` when breaking.",
        "//",
        "// We print JSX using the `fill` doc primitive.",
        "// This requires that we give it an array of alternating",
        "// content and whitespace elements.",
        "// To ensure this we add dummy `\"\"` content elements as needed.",
        "function printJSXChildren(",
        "  path,",
        "  options,",
        "  print,",
        "  jsxWhitespace,",
        "  isFacebookTranslationTag",
        ") {",
        "  const n = path.getValue();",
        "  const children = [];",
        "",
        "  path.each((childPath, i) => {",
        "    const child = childPath.getValue();",
        "    if (isLiteral(child)) {",
        "      const text = rawText(child);",
        "",
        "      // Contains a non-whitespace character",
        "      if (isMeaningfulJSXText(child)) {",
        "        const words = text.split(matchJsxWhitespaceRegex);",
        "",
        "        // Starts with whitespace",
        "        if (words[0] === \"\") {",
        "          children.push(\"\");",
        "          words.shift();",
        "          if (/\\n/.test(words[0])) {",
        "            const next = n.children[i + 1];",
        "            children.push(",
        "              separatorWithWhitespace(",
        "                isFacebookTranslationTag,",
        "                words[1],",
        "                child,",
        "                next",
        "              )",
        "            );",
        "          } else {",
        "            children.push(jsxWhitespace);",
        "          }",
        "          words.shift();",
        "        }",
        "",
        "        let endWhitespace;",
        "        // Ends with whitespace",
        "        if (getLast(words) === \"\") {",
        "          words.pop();",
        "          endWhitespace = words.pop();",
        "        }",
        "",
        "        // This was whitespace only without a new line.",
        "        if (words.length === 0) {",
        "          return;",
        "        }",
        "",
        "        words.forEach((word, i) => {",
        "          if (i % 2 === 1) {",
        "            children.push(line);",
        "          } else {",
        "            children.push(word);",
        "          }",
        "        });",
        "",
        "        if (endWhitespace !== undefined) {",
        "          if (/\\n/.test(endWhitespace)) {",
        "            const next = n.children[i + 1];",
        "            children.push(",
        "              separatorWithWhitespace(",
        "                isFacebookTranslationTag,",
        "                getLast(children),",
        "                child,",
        "                next",
        "              )",
        "            );",
        "          } else {",
        "            children.push(jsxWhitespace);",
        "          }",
        "        } else {",
        "          const next = n.children[i + 1];",
        "          children.push(",
        "            separatorNoWhitespace(",
        "              isFacebookTranslationTag,",
        "              getLast(children),",
        "              child,",
        "              next",
        "            )",
        "          );",
        "        }",
        "      } else if (/\\n/.test(text)) {",
        "        // Keep (up to one) blank line between tags/expressions/text.",
        "        // Note: We don't keep blank lines between text elements.",
        "        if (text.match(/\\n/g).length > 1) {",
        "          children.push(\"\");",
        "          children.push(hardline);",
        "        }",
        "      } else {",
        "        children.push(\"\");",
        "        children.push(jsxWhitespace);",
        "      }",
        "    } else {",
        "      const printedChild = print(childPath);",
        "      children.push(printedChild);",
        "",
        "      const next = n.children[i + 1];",
        "      const directlyFollowedByMeaningfulText =",
        "        next && isMeaningfulJSXText(next);",
        "      if (directlyFollowedByMeaningfulText) {",
        "        const firstWord = rawText(next)",
        "          .trim()",
        "          .split(matchJsxWhitespaceRegex)[0];",
        "        children.push(",
        "          separatorNoWhitespace(",
        "            isFacebookTranslationTag,",
        "            firstWord,",
        "            child,",
        "            next",
        "          )",
        "        );",
        "      } else {",
        "        children.push(hardline);",
        "      }",
        "    }",
        "  }, \"children\");",
        "",
        "  return children;",
        "}",
        "",
        "function separatorNoWhitespace(",
        "  isFacebookTranslationTag,",
        "  child,",
        "  childNode,",
        "  nextNode",
        ") {",
        "  if (isFacebookTranslationTag) {",
        "    return \"\";",
        "  }",
        "",
        "  if (",
        "    (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
        "    (nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement)",
        "  ) {",
        "    return child.length === 1 ? softline : hardline;",
        "  }",
        "",
        "  return softline;",
        "}",
        "",
        "function separatorWithWhitespace(",
        "  isFacebookTranslationTag,",
        "  child,",
        "  childNode,",
        "  nextNode",
        ") {",
        "  if (isFacebookTranslationTag) {",
        "    return hardline;",
        "  }",
        "",
        "  if (child.length === 1) {",
        "    return (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
        "      (nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement)",
        "      ? hardline",
        "      : softline;",
        "  }",
        "",
        "  return hardline;",
        "}",
        "",
        "function maybeWrapJSXElementInParens(path, elem, options) {",
        "  const parent = path.getParentNode();",
        "  /* istanbul ignore next */",
        "  if (!parent) {",
        "    return elem;",
        "  }",
        "",
        "  const NO_WRAP_PARENTS = {",
        "    ArrayExpression: true,",
        "    JSXAttribute: true,",
        "    JSXElement: true,",
        "    JSXExpressionContainer: true,",
        "    JSXFragment: true,",
        "    ExpressionStatement: true,",
        "    CallExpression: true,",
        "    OptionalCallExpression: true,",
        "    ConditionalExpression: true,",
        "    JsExpressionRoot: true,",
        "  };",
        "  if (NO_WRAP_PARENTS[parent.type]) {",
        "    return elem;",
        "  }",
        "",
        "  const shouldBreak = path.match(",
        "    undefined,",
        "    (node) => node.type === \"ArrowFunctionExpression\",",
        "    isCallOrOptionalCallExpression,",
        "    (node) => node.type === \"JSXExpressionContainer\"",
        "  );",
        "",
        "  const needsParens = pathNeedsParens(path, options);",
        "",
        "  return group(",
        "    concat([",
        "      needsParens ? \"\" : ifBreak(\"(\"),",
        "      indent(concat([softline, elem])),",
        "      softline,",
        "      needsParens ? \"\" : ifBreak(\")\"),",
        "    ]),",
        "    { shouldBreak }",
        "  );",
        "}",
        "",
        "function printJsxAttribute(path, options, print) {",
        "  const n = path.getValue();",
        "  const parts = [];",
        "  parts.push(path.call(print, \"name\"));",
        "",
        "  if (n.value) {",
        "    let res;",
        "    if (isStringLiteral(n.value)) {",
        "      const raw = rawText(n.value);",
        "      // Unescape all quotes so we get an accurate preferred quote",
        "      let final = raw.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');",
        "      const quote = getPreferredQuote(",
        "        final,",
        "        options.jsxSingleQuote ? \"'\" : '\"'",
        "      );",
        "      const escape = quote === \"'\" ? \"&apos;\" : \"&quot;\";",
        "      final = final.slice(1, -1).replace(new RegExp(quote, \"g\"), escape);",
        "      res = concat([quote, final, quote]);",
        "    } else {",
        "      res = path.call(print, \"value\");",
        "    }",
        "    parts.push(\"=\", res);",
        "  }",
        "..."
    ]
}