{
    "src/language-js/printer-estree.js": [
        "\"use strict\";",
        "",
        "/** @typedef {import(\"../document\").Doc} Doc */",
        "",
        "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
        "const { printDanglingComments } = require(\"../main/comments.js\");",
        "const { hasNewline } = require(\"../common/util.js\");",
        "const {",
        "  builders: { join, line, hardline, softline, group, indent },",
        "  utils: { replaceTextEndOfLine },",
        "} = require(\"../document/index.js\");",
        "const embed = require(\"./embed.js\");",
        "const clean = require(\"./clean.js\");",
        "const { insertPragma } = require(\"./pragma.js\");",
        "const handleComments = require(\"./comments.js\");",
        "const pathNeedsParens = require(\"./needs-parens.js\");",
        "const preprocess = require(\"./print-preprocess.js\");",
        "const {",
        "  hasFlowShorthandAnnotationComment,",
        "  hasComment,",
        "  CommentCheckFlags,",
        "  isTheOnlyJsxElementInMarkdown,",
        "  isLineComment,",
        "  isNextLineEmpty,",
        "  needsHardlineAfterDanglingComment,",
        "  hasIgnoreComment,",
        "  isCallExpression,",
        "  isMemberExpression,",
        "  markerForIfWithoutBlockAndSameLineComment,",
        "} = require(\"./utils/index.js\");",
        "const { locStart, locEnd } = require(\"./loc.js\");",
        "const isBlockComment = require(\"./utils/is-block-comment.js\");",
        "",
        "const {",
        "  printHtmlBinding,",
        "  isVueEventBindingExpression,",
        "} = require(\"./print/html-binding.js\");",
        "const { printAngular } = require(\"./print/angular.js\");",
        "const { printJsx, hasJsxIgnoreComment } = require(\"./print/jsx.js\");",
        "const { printFlow } = require(\"./print/flow.js\");",
        "const { printTypescript } = require(\"./print/typescript.js\");",
        "const {",
        "  printOptionalToken,",
        "  printBindExpressionCallee,",
        "  printTypeAnnotation,",
        "  adjustClause,",
        "  printRestSpread,",
        "  printDefiniteToken,",
        "  printDirective,",
        "} = require(\"./print/misc.js\");",
        "const {",
        "  printImportDeclaration,",
        "  printExportDeclaration,",
        "  printExportAllDeclaration,",
        "  printModuleSpecifier,",
        "} = require(\"./print/module.js\");",
        "const { printTernary } = require(\"./print/ternary.js\");",
        "const { printTemplateLiteral } = require(\"./print/template-literal.js\");",
        "const { printArray } = require(\"./print/array.js\");",
        "const { printObject } = require(\"./print/object.js\");",
        "const {",
        "  printClass,",
        "  printClassMethod,",
        "  printClassProperty,",
        "} = require(\"./print/class.js\");",
        "const { printProperty } = require(\"./print/property.js\");",
        "const {",
        "  printFunction,",
        "  printArrowFunction,",
        "  printMethod,",
        "  printReturnStatement,",
        "  printThrowStatement,",
        "} = require(\"./print/function.js\");",
        "const { printCallExpression } = require(\"./print/call-expression.js\");",
        "const {",
        "  printVariableDeclarator,",
        "  printAssignmentExpression,",
        "} = require(\"./print/assignment.js\");",
        "const { printBinaryishExpression } = require(\"./print/binaryish.js\");",
        "const { printSwitchCaseConsequent } = require(\"./print/statement.js\");",
        "const { printMemberExpression } = require(\"./print/member.js\");",
        "const { printBlock, printBlockBody } = require(\"./print/block.js\");",
        "const { printComment } = require(\"./print/comment.js\");",
        "const { printLiteral } = require(\"./print/literal.js\");",
        "const { printDecorators } = require(\"./print/decorators.js\");",
        "",
        "function genericPrint(path, options, print, args) {",
        "  const printed = printPathNoParens(path, options, print, args);",
        "  if (!printed) {",
        "    return \"\";",
        "  }",
        "",
        "  const node = path.getValue();",
        "  const { type } = node;",
        "  // Their decorators are handled themselves, and they can't have parentheses",
        "  if (",
        "    type === \"ClassMethod\" ||",
        "    type === \"ClassPrivateMethod\" ||",
        "    type === \"ClassProperty\" ||",
        "    type === \"ClassAccessorProperty\" ||",
        "    type === \"AccessorProperty\" ||",
        "    type === \"TSAbstractAccessorProperty\" ||",
        "    type === \"PropertyDefinition\" ||",
        "    type === \"TSAbstractPropertyDefinition\" ||",
        "    type === \"ClassPrivateProperty\" ||",
        "    type === \"MethodDefinition\" ||",
        "    type === \"TSAbstractMethodDefinition\" ||",
        "    type === \"TSDeclareMethod\"",
        "  ) {",
        "    return printed;",
        "  }",
        "",
        "  let parts = [printed];",
        "",
        "  const printedDecorators = printDecorators(path, options, print);",
        "  const isClassExpressionWithDecorators =",
        "    node.type === \"ClassExpression\" && printedDecorators;",
        "  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons",
        "  if (printedDecorators) {",
        "    parts = [...printedDecorators, printed];",
        "",
        "    if (!isClassExpressionWithDecorators) {",
        "      return group(parts);",
        "    }",
        "  }",
        "",
        "  const needsParens = pathNeedsParens(path, options);",
        "",
        "  if (!needsParens) {",
        "    if (args && args.needsSemi) {",
        "      parts.unshift(\";\");",
        "    }",
        "",
        "    // In member-chain print, it add `label` to the doc, if we return array here it will be broken",
        "    if (parts.length === 1 && parts[0] === printed) {",
        "      return printed;",
        "    }",
        "",
        "    return parts;",
        "  }",
        "",
        "  if (isClassExpressionWithDecorators) {",
        "    parts = [indent([line, ...parts])];",
        "  }",
        "",
        "  parts.unshift(\"(\");",
        "",
        "  if (args && args.needsSemi) {",
        "    parts.unshift(\";\");",
        "  }",
        "",
        "  if (hasFlowShorthandAnnotationComment(node)) {",
        "    const [comment] = node.trailingComments;",
        "    parts.push(\" /*\", comment.value.trimStart(), \"*/\");",
        "    comment.printed = true;",
        "  }",
        "",
        "  if (isClassExpressionWithDecorators) {",
        "    parts.push(line);",
        "  }",
        "",
        "  parts.push(\")\");",
        "",
        "  return parts;",
        "}",
        "",
        "function printPathNoParens(path, options, print, args) {",
        "  const node = path.getValue();",
        "  const semi = options.semi ? \";\" : \"\";",
        "",
        "  if (!node) {",
        "    return \"\";",
        "  }",
        "",
        "  if (typeof node === \"string\") {",
        "    return node;",
        "  }",
        "",
        "  for (const printer of [",
        "    printLiteral,",
        "    printHtmlBinding,",
        "    printAngular,",
        "    printJsx,",
        "    printFlow,",
        "    printTypescript,",
        "  ]) {",
        "    const printed = printer(path, options, print);",
        "    if (typeof printed !== \"undefined\") {",
        "      return printed;",
        "    }",
        "  }",
        "",
        "  /** @type{Doc[]} */",
        "  let parts = [];",
        "",
        "  switch (node.type) {",
        "    case \"JsExpressionRoot\":",
        "      return print(\"node\");",
        "    case \"JsonRoot\":",
        "      return [print(\"node\"), hardline];",
        "    case \"File\":",
        "      // Print @babel/parser's InterpreterDirective here so that",
        "      // leading comments on the `Program` node get printed after the hashbang.",
        "      if (node.program && node.program.interpreter) {",
        "        parts.push(print([\"program\", \"interpreter\"]));",
        "      }",
        "",
        "      parts.push(print(\"program\"));",
        "",
        "      return parts;",
        "",
        "    case \"Program\":",
        "      return printBlockBody(path, options, print);",
        "    // Babel extension.",
        "    case \"EmptyStatement\":",
        "      return \"\";",
        "    case \"ExpressionStatement\": {",
        "      if (",
        "        options.parser === \"__vue_event_binding\" ||",
        "        options.parser === \"__vue_ts_event_binding\"",
        "      ) {",
        "        const parent = path.getParentNode();",
        "        if (",
        "          parent.type === \"Program\" &&",
        "          parent.body.length === 1 &&",
        "          parent.body[0] === node",
        "        ) {",
        "          return [",
        "            print(\"expression\"),",
        "            isVueEventBindingExpression(node.expression) ? \";\" : \"\",",
        "          ];",
        "        }",
        "      }",
        "",
        "      const danglingComment = printDanglingComments(",
        "        path,",
        "        options,",
        "        /** sameIndent */ true,",
        "        ({ marker }) => marker === markerForIfWithoutBlockAndSameLineComment",
        "      );",
        "",
        "      // Do not append semicolon after the only JSX element in a program",
        "      return [",
        "        print(\"expression\"),",
        "        isTheOnlyJsxElementInMarkdown(options, path) ? \"\" : semi,",
        "        danglingComment ? [\" \", danglingComment] : \"\",",
        "      ];",
        "    }",
        "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
        "    case \"ParenthesizedExpression\": {",
        "      const shouldHug =",
        "        !hasComment(node.expression) &&",
        "        (node.expression.type === \"ObjectExpression\" ||",
        "          node.expression.type === \"ArrayExpression\");",
        "      if (shouldHug) {",
        "        return [\"(\", print(\"expression\"), \")\"];",
        "      }",
        "      return group([",
        "        \"(\",",
        "        indent([softline, print(\"expression\")]),",
        "        softline,",
        "        \")\",",
        "      ]);",
        "    }",
        "    case \"AssignmentExpression\":",
        "      return printAssignmentExpression(path, options, print);",
        "    case \"VariableDeclarator\":",
        "      return printVariableDeclarator(path, options, print);",
        "    case \"BinaryExpression\":",
        "    case \"LogicalExpression\":",
        "      return printBinaryishExpression(path, options, print);",
        "    case \"AssignmentPattern\":",
        "      return [print(\"left\"), \" = \", print(\"right\")];",
        "    case \"OptionalMemberExpression\":",
        "    case \"MemberExpression\": {",
        "      return printMemberExpression(path, options, print);",
        "    }",
        "    case \"MetaProperty\":",
        "      return [print(\"meta\"), \".\", print(\"property\")];",
        "    case \"BindExpression\":",
        "      if (node.object) {",
        "        parts.push(print(\"object\"));",
        "      }",
        "",
        "      parts.push(",
        "        group(",
        "          indent([softline, printBindExpressionCallee(path, options, print)])",
        "        )",
        "      );",
        "",
        "      return parts;",
        "    case \"Identifier\": {",
        "      return [",
        "        node.name,",
        "        printOptionalToken(path),",
        "        printDefiniteToken(path),",
        "        printTypeAnnotation(path, options, print),",
        "      ];",
        "    }",
        "    case \"V8IntrinsicIdentifier\":",
        "      return [\"%\", node.name];",
        "    case \"SpreadElement\":",
        "    case \"SpreadElementPattern\":",
        "    case \"SpreadProperty\":",
        "    case \"SpreadPropertyPattern\":",
        "    case \"RestElement\":",
        "      return printRestSpread(path, options, print);",
        "    case \"FunctionDeclaration\":",
        "    case \"FunctionExpression\":",
        "      return printFunction(path, print, options, args);",
        "    case \"ArrowFunctionExpression\":",
        "      return printArrowFunction(path, options, print, args);",
        "    case \"YieldExpression\":",
        "      parts.push(\"yield\");",
        "",
        "      if (node.delegate) {",
        "        parts.push(\"*\");",
        "      }",
        "      if (node.argument) {",
        "        parts.push(\" \", print(\"argument\"));",
        "      }",
        "",
        "      return parts;",
        "    case \"AwaitExpression\": {",
        "      parts.push(\"await\");",
        "      if (node.argument) {",
        "        parts.push(\" \", print(\"argument\"));",
        "        const parent = path.getParentNode();",
        "        if (",
        "          (isCallExpression(parent) && parent.callee === node) ||",
        "          (isMemberExpression(parent) && parent.object === node)",
        "        ) {",
        "          parts = [indent([softline, ...parts]), softline];",
        "          const parentAwaitOrBlock = path.findAncestor(",
        "            (node) =>",
        "              node.type === \"AwaitExpression\" || node.type === \"BlockStatement\"",
        "          );",
        "          if (",
        "            !parentAwaitOrBlock ||",
        "            parentAwaitOrBlock.type !== \"AwaitExpression\"",
        "          ) {",
        "            return group(parts);",
        "          }",
        "        }",
        "      }",
        "      return parts;",
        "    }",
        "    case \"ExportDefaultDeclaration\":",
        "    case \"ExportNamedDeclaration\":",
        "      return printExportDeclaration(path, options, print);",
        "    case \"ExportAllDeclaration\":",
        "      return printExportAllDeclaration(path, options, print);",
        "    case \"ImportDeclaration\":",
        "      return printImportDeclaration(path, options, print);",
        "    case \"ImportSpecifier\":",
        "    case \"ExportSpecifier\":",
        "    case \"ImportNamespaceSpecifier\":",
        "    case \"ExportNamespaceSpecifier\":",
        "    case \"ImportDefaultSpecifier\":",
        "    case \"ExportDefaultSpecifier\":",
        "      return printModuleSpecifier(path, options, print);",
        "    case \"ImportAttribute\":",
        "      return [print(\"key\"), \": \", print(\"value\")];",
        "    case \"Import\":",
        "      return \"import\";",
        "    case \"BlockStatement\":",
        "    case \"StaticBlock\":",
        "    case \"ClassBody\":",
        "      return printBlock(path, options, print);",
        "    case \"ThrowStatement\":",
        "      return printThrowStatement(path, options, print);",
        "    case \"ReturnStatement\":",
        "      return printReturnStatement(path, options, print);",
        "    case \"NewExpression\":",
        "    case \"ImportExpression\":",
        "    case \"OptionalCallExpression\":",
        "    case \"CallExpression\":",
        "      return printCallExpression(path, options, print);",
        "",
        "    case \"ObjectExpression\":",
        "    case \"ObjectPattern\":",
        "    case \"RecordExpression\":",
        "      return printObject(path, options, print);",
        "    // Babel 6",
        "    case \"ObjectProperty\": // Non-standard AST node type.",
        "    case \"Property\":",
        "      if (node.method || node.kind === \"get\" || node.kind === \"set\") {",
        "        return printMethod(path, options, print);",
        "      }",
        "      return printProperty(path, options, print);",
        "    case \"ObjectMethod\":",
        "      return printMethod(path, options, print);",
        "    case \"Decorator\":",
        "      return [\"@\", print(\"expression\")];",
        "    case \"ArrayExpression\":",
        "    case \"ArrayPattern\":",
        "    case \"TupleExpression\":",
        "      return printArray(path, options, print);",
        "    case \"SequenceExpression\": {",
        "      const parent = path.getParentNode(0);",
        "      if (",
        "        parent.type === \"ExpressionStatement\" ||",
        "        parent.type === \"ForStatement\"",
        "      ) {",
        "        // For ExpressionStatements and for-loop heads, which are among",
        "        // the few places a SequenceExpression appears unparenthesized, we want",
        "        // to indent expressions after the first.",
        "        const parts = [];",
        "        path.each((expressionPath, index) => {",
        "          if (index === 0) {",
        "            parts.push(print());",
        "          } else {",
        "            parts.push(\",\", indent([line, print()]));",
        "          }",
        "        }, \"expressions\");",
        "        return group(parts);",
        "      }",
        "      return group(join([\",\", line], path.map(print, \"expressions\")));",
        "    }",
        "    case \"ThisExpression\":",
        "      return \"this\";",
        "    case \"Super\":",
        "      return \"super\";",
        "    case \"Directive\":",
        "      return [print(\"value\"), semi]; // Babel 6",
        "    case \"DirectiveLiteral\":",
        "      return printDirective(node.extra.raw, options);",
        "    case \"UnaryExpression\":",
        "      parts.push(node.operator);",
        "",
        "      if (/[a-z]$/.test(node.operator)) {",
        "        parts.push(\" \");",
        "      }",
        "",
        "      if (hasComment(node.argument)) {",
        "        parts.push(",
        "          group([\"(\", indent([softline, print(\"argument\")]), softline, \")\"])",
        "        );",
        "      } else {",
        "        parts.push(print(\"argument\"));",
        "      }",
        "",
        "      return parts;",
        "    case \"UpdateExpression\":",
        "      parts.push(print(\"argument\"), node.operator);",
        "",
        "      if (node.prefix) {",
        "        parts.reverse();",
        "      }",
        "",
        "      return parts;",
        "    case \"ConditionalExpression\":",
        "      return printTernary(path, options, print);",
        "    case \"VariableDeclaration\": {",
        "      const printed = path.map(print, \"declarations\");",
        "",
        "      // We generally want to terminate all variable declarations with a",
        "      // semicolon, except when they in the () part of for loops.",
        "      const parentNode = path.getParentNode();",
        "",
        "      const isParentForLoop =",
        "        parentNode.type === \"ForStatement\" ||",
        "        parentNode.type === \"ForInStatement\" ||",
        "        parentNode.type === \"ForOfStatement\";",
        "",
        "      const hasValue = node.declarations.some((decl) => decl.init);",
        "",
        "      let firstVariable;",
        "      if (printed.length === 1 && !hasComment(node.declarations[0])) {",
        "        firstVariable = printed[0];",
        "      } else if (printed.length > 0) {",
        "        // Indent first var to comply with eslint one-var rule",
        "        firstVariable = indent(printed[0]);",
        "      }",
        "",
        "      parts = [",
        "        node.declare ? \"declare \" : \"\",",
        "        node.kind,",
        "        firstVariable ? [\" \", firstVariable] : \"\",",
        "        indent(",
        "          printed",
        "            .slice(1)",
        "            .map((p) => [",
        "              \",\",",
        "              hasValue && !isParentForLoop ? hardline : line,",
        "              p,",
        "            ])",
        "        ),",
        "      ];",
        "",
        "      if (!(isParentForLoop && parentNode.body !== node)) {",
        "        parts.push(semi);",
        "      }",
        "",
        "      return group(parts);",
        "    }",
        "    case \"WithStatement\":",
        "      return group([",
        "        \"with (\",",
        "        print(\"object\"),",
        "        \")\",",
        "..."
    ],
    "src/language-js/print/object.js": [
        "\"use strict\";",
        "",
        "const { printDanglingComments } = require(\"../../main/comments.js\");",
        "const {",
        "  builders: { line, softline, group, indent, ifBreak, hardline },",
        "} = require(\"../../document/index.js\");",
        "const {",
        "  getLast,",
        "  hasNewlineInRange,",
        "  hasNewline,",
        "  isNonEmptyArray,",
        "} = require(\"../../common/util.js\");",
        "const {",
        "  shouldPrintComma,",
        "  hasComment,",
        "  getComments,",
        "  CommentCheckFlags,",
        "  isNextLineEmpty,",
        "} = require(\"../utils/index.js\");",
        "const { locStart, locEnd } = require(\"../loc.js\");",
        "",
        "const { printOptionalToken, printTypeAnnotation } = require(\"./misc.js\");",
        "const { shouldHugFunctionParameters } = require(\"./function-parameters.js\");",
        "const { shouldHugType } = require(\"./type-annotation.js\");",
        "const { printHardlineAfterHeritage } = require(\"./class.js\");",
        "",
        "/** @typedef {import(\"../../document\").Doc} Doc */",
        "",
        "function printObject(path, options, print) {",
        "  const semi = options.semi ? \";\" : \"\";",
        "  const node = path.getValue();",
        "",
        "  let propertiesField;",
        "",
        "  if (node.type === \"TSTypeLiteral\") {",
        "    propertiesField = \"members\";",
        "  } else if (node.type === \"TSInterfaceBody\") {",
        "    propertiesField = \"body\";",
        "  } else {",
        "    propertiesField = \"properties\";",
        "  }",
        "",
        "  const isTypeAnnotation = node.type === \"ObjectTypeAnnotation\";",
        "  const fields = [propertiesField];",
        "  if (isTypeAnnotation) {",
        "    fields.push(\"indexers\", \"callProperties\", \"internalSlots\");",
        "  }",
        "",
        "  const firstProperty = fields",
        "    .map((field) => node[field][0])",
        "    .sort((a, b) => locStart(a) - locStart(b))[0];",
        "",
        "  const parent = path.getParentNode(0);",
        "  const isFlowInterfaceLikeBody =",
        "    isTypeAnnotation &&",
        "    parent &&",
        "    (parent.type === \"InterfaceDeclaration\" ||",
        "      parent.type === \"DeclareInterface\" ||",
        "      parent.type === \"DeclareClass\") &&",
        "    path.getName() === \"body\";",
        "  const shouldBreak =",
        "    node.type === \"TSInterfaceBody\" ||",
        "    isFlowInterfaceLikeBody ||",
        "    (node.type === \"ObjectPattern\" &&",
        "      parent.type !== \"FunctionDeclaration\" &&",
        "      parent.type !== \"FunctionExpression\" &&",
        "      parent.type !== \"ArrowFunctionExpression\" &&",
        "      parent.type !== \"ObjectMethod\" &&",
        "      parent.type !== \"ClassMethod\" &&",
        "      parent.type !== \"ClassPrivateMethod\" &&",
        "      parent.type !== \"AssignmentPattern\" &&",
        "      parent.type !== \"CatchClause\" &&",
        "      node.properties.some(",
        "        (property) =>",
        "          property.value &&",
        "          (property.value.type === \"ObjectPattern\" ||",
        "            property.value.type === \"ArrayPattern\")",
        "      )) ||",
        "    (node.type !== \"ObjectPattern\" &&",
        "      firstProperty &&",
        "      hasNewlineInRange(",
        "        options.originalText,",
        "        locStart(node),",
        "        locStart(firstProperty)",
        "      ));",
        "",
        "  const separator = isFlowInterfaceLikeBody",
        "    ? \";\"",
        "    : node.type === \"TSInterfaceBody\" || node.type === \"TSTypeLiteral\"",
        "    ? ifBreak(semi, \";\")",
        "    : \",\";",
        "  const leftBrace =",
        "    node.type === \"RecordExpression\" ? \"#{\" : node.exact ? \"{|\" : \"{\";",
        "  const rightBrace = node.exact ? \"|}\" : \"}\";",
        "",
        "  // Unfortunately, things are grouped together in the ast can be",
        "  // interleaved in the source code. So we need to reorder them before",
        "  // printing them.",
        "  const propsAndLoc = [];",
        "  for (const field of fields) {",
        "    path.each((childPath) => {",
        "      const node = childPath.getValue();",
        "      propsAndLoc.push({",
        "        node,",
        "        printed: print(),",
        "        loc: locStart(node),",
        "      });",
        "    }, field);",
        "  }",
        "",
        "  if (fields.length > 1) {",
        "    propsAndLoc.sort((a, b) => a.loc - b.loc);",
        "  }",
        "",
        "  /** @type {Doc[]} */",
        "  let separatorParts = [];",
        "  const props = propsAndLoc.map((prop) => {",
        "    const result = [...separatorParts, group(prop.printed)];",
        "    separatorParts = [separator, line];",
        "    if (",
        "      (prop.node.type === \"TSPropertySignature\" ||",
        "        prop.node.type === \"TSMethodSignature\" ||",
        "        prop.node.type === \"TSConstructSignatureDeclaration\") &&",
        "      hasComment(prop.node, CommentCheckFlags.PrettierIgnore)",
        "    ) {",
        "      separatorParts.shift();",
        "    }",
        "    if (isNextLineEmpty(prop.node, options)) {",
        "      separatorParts.push(hardline);",
        "    }",
        "    return result;",
        "  });",
        "",
        "  if (node.inexact) {",
        "    let printed;",
        "    if (hasComment(node, CommentCheckFlags.Dangling)) {",
        "      const hasLineComments = hasComment(node, CommentCheckFlags.Line);",
        "      const printedDanglingComments = printDanglingComments(",
        "        path,",
        "        options,",
        "        /* sameIndent */ true",
        "      );",
        "      printed = [",
        "        printedDanglingComments,",
        "        hasLineComments ||",
        "        hasNewline(options.originalText, locEnd(getLast(getComments(node))))",
        "          ? hardline",
        "          : line,",
        "        \"...\",",
        "      ];",
        "    } else {",
        "      printed = [\"...\"];",
        "    }",
        "    props.push([...separatorParts, ...printed]);",
        "  }",
        "",
        "  const lastElem = getLast(node[propertiesField]);",
        "",
        "  const canHaveTrailingSeparator = !(",
        "    node.inexact ||",
        "    (lastElem && lastElem.type === \"RestElement\") ||",
        "    (lastElem &&",
        "      (lastElem.type === \"TSPropertySignature\" ||",
        "        lastElem.type === \"TSCallSignatureDeclaration\" ||",
        "        lastElem.type === \"TSMethodSignature\" ||",
        "        lastElem.type === \"TSConstructSignatureDeclaration\") &&",
        "      hasComment(lastElem, CommentCheckFlags.PrettierIgnore))",
        "  );",
        "",
        "  let content;",
        "  if (props.length === 0) {",
        "    if (!hasComment(node, CommentCheckFlags.Dangling)) {",
        "      return [leftBrace, rightBrace, printTypeAnnotation(path, options, print)];",
        "    }",
        "",
        "    content = group([",
        "      leftBrace,",
        "      printDanglingComments(path, options),",
        "      softline,",
        "      rightBrace,",
        "      printOptionalToken(path),",
        "      printTypeAnnotation(path, options, print),",
        "    ]);",
        "  } else {",
        "    content = [",
        "      isFlowInterfaceLikeBody && isNonEmptyArray(node.properties)",
        "        ? printHardlineAfterHeritage(parent)",
        "        : \"\",",
        "      leftBrace,",
        "      indent([options.bracketSpacing ? line : softline, ...props]),",
        "      ifBreak(",
        "        canHaveTrailingSeparator &&",
        "          (separator !== \",\" || shouldPrintComma(options))",
        "          ? separator",
        "          : \"\"",
        "      ),",
        "      options.bracketSpacing ? line : softline,",
        "      rightBrace,",
        "      printOptionalToken(path),",
        "      printTypeAnnotation(path, options, print),",
        "    ];",
        "  }",
        "",
        "  // If we inline the object as first argument of the parent, we don't want",
        "  // to create another group so that the object breaks before the return",
        "  // type",
        "  if (",
        "    path.match(",
        "      (node) => node.type === \"ObjectPattern\" && !node.decorators,",
        "      (node, name, number) =>",
        "        shouldHugFunctionParameters(node) &&",
        "        (name === \"params\" ||",
        "          name === \"parameters\" ||",
        "          name === \"this\" ||",
        "          name === \"rest\") &&",
        "        number === 0",
        "    ) ||",
        "    path.match(",
        "      shouldHugType,",
        "      (node, name) => name === \"typeAnnotation\",",
        "      (node, name) => name === \"typeAnnotation\",",
        "      (node, name, number) =>",
        "        shouldHugFunctionParameters(node) &&",
        "        (name === \"params\" ||",
        "          name === \"parameters\" ||",
        "          name === \"this\" ||",
        "          name === \"rest\") &&",
        "        number === 0",
        "    ) ||",
        "    // Assignment printing logic (printAssignment) is responsible",
        "    // for adding a group if needed",
        "    (!shouldBreak &&",
        "      path.match(",
        "        (node) => node.type === \"ObjectPattern\",",
        "        (node) =>",
        "          node.type === \"AssignmentExpression\" ||",
        "          node.type === \"VariableDeclarator\"",
        "      ))",
        "  ) {",
        "    return content;",
        "  }",
        "",
        "  return group(content, { shouldBreak });",
        "}",
        "",
        "module.exports = { printObject };"
    ]
}