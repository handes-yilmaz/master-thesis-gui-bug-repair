{
    ".codecov.yml": {},
    ".editorconfig": {},
    ".eslintignore": {},
    ".eslintrc.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "const { isCI } = require(\"ci-info\");",
            "",
            "module.exports = {",
            "  root: true,",
            "  env: {",
            "    es2022: true,",
            "    node: true,",
            "  },",
            "  parserOptions: {",
            "    ecmaVersion: \"latest\",",
            "  },",
            "  reportUnusedDisableDirectives: true,",
            "  extends: [\"eslint:recommended\", \"prettier\"],",
            "  plugins: [",
            "    \"prettier-internal-rules\",",
            "    \"import\",",
            "    \"regexp\",",
            "    \"unicorn\",",
            "    \"@typescript-eslint\",",
            "  ],",
            "  settings: {",
            "    \"import/internal-regex\": \"^linguist-languages/\",",
            "  },",
            "  rules: {",
            "    \"@typescript-eslint/prefer-ts-expect-error\": \"error\",",
            "    \"arrow-body-style\": [\"error\", \"as-needed\"],",
            "    curly: \"error\",",
            "    \"dot-notation\": \"error\",",
            "    eqeqeq: \"error\",",
            "    \"no-console\": isCI ? \"error\" : \"warn\",",
            "    \"no-else-return\": [",
            "      \"error\",",
            "      {",
            "        allowElseIf: false,",
            "      },",
            "    ],",
            "    \"no-implicit-coercion\": \"error\",",
            "    \"no-inner-declarations\": \"error\",",
            "    \"no-restricted-syntax\": [",
            "      \"error\",",
            "      // `!foo === bar` and `!foo !== bar`",
            "      'BinaryExpression[operator=/^[!=]==$/] > UnaryExpression.left[operator=\"!\"]',",
            "    ],",
            "    \"no-return-await\": \"error\",",
            "    \"no-unneeded-ternary\": \"error\",",
            "    \"no-useless-return\": \"error\",",
            "    \"no-unused-vars\": [",
            "      \"error\",",
            "      {",
            "        ignoreRestSiblings: true,",
            "      },",
            "    ],",
            "    \"no-var\": \"error\",",
            "    \"object-shorthand\": \"error\",",
            "    \"one-var\": [\"error\", \"never\"],",
            "    \"prefer-arrow-callback\": \"error\",",
            "    \"prefer-const\": [",
            "      \"error\",",
            "      {",
            "        destructuring: \"all\",",
            "      },",
            "    ],",
            "    \"prefer-destructuring\": [",
            "      \"error\",",
            "      {",
            "        VariableDeclarator: {",
            "          array: false,",
            "          object: true,",
            "        },",
            "        AssignmentExpression: {",
            "          array: false,",
            "          object: false,",
            "        },",
            "      },",
            "      {",
            "        enforceForRenamedProperties: false,",
            "      },",
            "    ],",
            "    \"prefer-object-spread\": \"error\",",
            "    \"prefer-rest-params\": \"error\",",
            "    \"prefer-spread\": \"error\",",
            "    \"prettier-internal-rules/jsx-identifier-case\": \"error\",",
            "    \"prettier-internal-rules/no-identifier-n\": \"error\",",
            "    quotes: [",
            "      \"error\",",
            "      \"double\",",
            "      {",
            "        avoidEscape: true,",
            "      },",
            "    ],",
            "    \"require-await\": \"error\",",
            "    strict: \"error\",",
            "    \"symbol-description\": \"error\",",
            "    yoda: [",
            "      \"error\",",
            "      \"never\",",
            "      {",
            "        exceptRange: true,",
            "      },",
            "    ],",
            "",
            "    \"import/extensions\": [\"error\", \"ignorePackages\"],",
            "    \"import/no-extraneous-dependencies\": [",
            "      \"error\",",
            "      {",
            "        devDependencies: [\"tests*/**\", \"scripts/**\"],",
            "      },",
            "    ],",
            "    \"import/order\": \"error\",",
            "    \"import/no-anonymous-default-export\": \"error\",",
            "",
            "    \"regexp/match-any\": [",
            "      \"error\",",
            "      {",
            "        allows: [\"dotAll\"],",
            "      },",
            "    ],",
            "    \"regexp/no-unused-capturing-group\": \"error\",",
            "    \"regexp/no-useless-flag\": [",
            "      \"error\",",
            "      {",
            "        strictTypes: false,",
            "      },",
            "    ],",
            "    \"regexp/no-useless-lazy\": \"error\",",
            "",
            "    \"unicorn/better-regex\": \"error\",",
            "    \"unicorn/explicit-length-check\": \"error\",",
            "    \"unicorn/filename-case\": \"error\",",
            "    \"unicorn/new-for-builtins\": \"error\",",
            "    \"unicorn/no-array-for-each\": \"error\",",
            "    \"unicorn/no-array-push-push\": \"error\",",
            "    \"unicorn/no-new-array\": \"error\",",
            "    \"unicorn/no-unreadable-iife\": \"error\",",
            "    \"unicorn/no-useless-length-check\": \"error\",",
            "    \"unicorn/no-useless-promise-resolve-reject\": \"error\",",
            "    \"unicorn/no-useless-undefined\": \"error\",",
            "    \"unicorn/prefer-array-flat\": [",
            "      \"error\",",
            "      {",
            "        functions: [\"flat\", \"flatten\"],",
            "      },",
            "    ],",
            "    \"unicorn/prefer-array-flat-map\": \"error\",",
            "    \"unicorn/prefer-array-some\": \"error\",",
            "    \"unicorn/prefer-includes\": \"error\",",
            "    \"unicorn/prefer-json-parse-buffer\": \"error\",",
            "    \"unicorn/prefer-logical-operator-over-ternary\": \"error\",",
            "    \"unicorn/prefer-native-coercion-functions\": \"error\",",
            "    \"unicorn/prefer-number-properties\": \"error\",",
            "    \"unicorn/prefer-optional-catch-binding\": \"error\",",
            "    \"unicorn/prefer-regexp-test\": \"error\",",
            "    \"unicorn/prefer-spread\": \"error\",",
            "    \"unicorn/prefer-string-slice\": \"error\",",
            "    \"unicorn/prefer-string-starts-ends-with\": \"error\",",
            "    \"unicorn/prefer-switch\": \"error\",",
            "    \"unicorn/prefer-type-error\": \"error\",",
            "    \"unicorn/template-indent\": \"error\",",
            "    \"unicorn/text-encoding-identifier-case\": \"error\",",
            "  },",
            "  overrides: [",
            "    {",
            "      files: [",
            "        \"scripts/**/*.js\",",
            "        \"scripts/**/*.mjs\",",
            "        \"tests/config/install-prettier.js\",",
            "      ],",
            "      rules: {",
            "        \"no-console\": \"off\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"scripts/**/*.mjs\"],",
            "      rules: {",
            "        \"unicorn/prefer-top-level-await\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [",
            "        \"**/*.mjs\",",
            "        \"scripts/release/**/*.js\",",
            "        \"scripts/tools/bundle-test/**/*.js\",",
            "      ],",
            "      parserOptions: {",
            "        sourceType: \"module\",",
            "      },",
            "      rules: {",
            "        \"unicorn/prefer-module\": \"error\",",
            "        \"unicorn/prefer-node-protocol\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [",
            "        \"tests/format/**/jsfmt.spec.js\",",
            "        \"tests/config/**/*.js\",",
            "        \"tests/integration/**/*.js\",",
            "        \"scripts/release/__tests__/**/*.spec.js\",",
            "      ],",
            "      env: {",
            "        jest: true,",
            "      },",
            "      plugins: [\"jest\"],",
            "      rules: {",
            "        \"jest/valid-expect\": [",
            "          \"error\",",
            "          {",
            "            alwaysAwait: true,",
            "          },",
            "        ],",
            "        \"jest/prefer-to-be\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"tests/integration/**/*.js\"],",
            "      rules: {",
            "        \"prettier-internal-rules/await-cli-tests\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"tests/**/*.js\"],",
            "      rules: {",
            "        strict: \"off\",",
            "        \"unicorn/prefer-array-flat\": \"off\",",
            "        \"unicorn/prefer-array-flat-map\": \"off\",",
            "      },",
            "      globals: {",
            "        run_spec: false,",
            "      },",
            "    },",
            "    {",
            "      files: [\"src/cli/*.js\"],",
            "      rules: {",
            "        \"no-restricted-modules\": [",
            "          \"error\",",
            "          {",
            "            patterns: [\"../\"],",
            "          },",
            "        ],",
            "      },",
            "    },",
            "    {",
            "      files: [\"src/cli/*/*.js\"],",
            "      rules: {",
            "        \"no-restricted-modules\": [",
            "          \"error\",",
            "          {",
            "            patterns: [\"../../\"],",
            "          },",
            "        ],",
            "      },",
            "    },",
            "    {",
            "      files: \"src/language-js/needs-parens.js\",",
            "      rules: {",
            "        \"prettier-internal-rules/better-parent-property-check-in-needs-parens\":",
            "          \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: \"src/**/*.js\",",
            "      rules: {",
            "        \"prettier-internal-rules/consistent-negative-index-access\": \"error\",",
            "        \"prettier-internal-rules/flat-ast-path-call\": \"error\",",
            "        \"prettier-internal-rules/no-conflicting-comment-check-flags\": \"error\",",
            "        \"prettier-internal-rules/no-doc-builder-concat\": \"error\",",
            "        \"prettier-internal-rules/no-empty-flat-contents-for-if-break\": \"error\",",
            "        \"prettier-internal-rules/no-unnecessary-ast-path-call\": \"error\",",
            "        \"prettier-internal-rules/prefer-ast-path-each\": \"error\",",
            "        \"prettier-internal-rules/prefer-indent-if-break\": \"error\",",
            "        \"prettier-internal-rules/prefer-is-non-empty-array\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"src/language-*/**/*.js\"],",
            "      rules: {",
            "        \"prettier-internal-rules/directly-loc-start-end\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"src/language-js/**/*.js\"],",
            "      rules: {",
            "        \"prettier-internal-rules/no-node-comments\": [",
            "          \"error\",",
            "          {",
            "            file: \"src/language-js/utils/index.js\",",
            "            functions: [\"hasComment\", \"getComments\"],",
            "          },",
            "          \"src/language-js/pragma.js\",",
            "          \"src/language-js/parse/postprocess/*.js\",",
            "          \"src/language-js/parse/babel.js\",",
            "          \"src/language-js/parse/meriyah.js\",",
            "          \"src/language-js/parse/json.js\",",
            "          \"src/language-js/parse/acorn.js\",",
            "        ],",
            "      },",
            "    },",
            "    {",
            "      files: [\"website/**/*\"],",
            "      env: {",
            "        browser: true,",
            "        worker: true,",
            "      },",
            "      extends: [\"plugin:react/recommended\"],",
            "      settings: {",
            "        react: {",
            "          version: \"17\",",
            "        },",
            "      },",
            "      rules: {",
            "        \"import/no-extraneous-dependencies\": \"off\",",
            "        \"react/display-name\": \"off\",",
            "        \"react/no-deprecated\": \"off\",",
            "        \"react/prop-types\": \"off\",",
            "        \"unicorn/filename-case\": \"off\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"website/playground/**/*\"],",
            "      parserOptions: {",
            "        sourceType: \"module\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"bin/prettier.js\"],",
            "      parserOptions: {",
            "        ecmaVersion: 5,",
            "      },",
            "      rules: {",
            "        \"no-var\": \"off\",",
            "      },",
            "    },",
            "  ],",
            "};"
        ]
    },
    ".git-blame-ignore-revs": {},
    ".gitattributes": {},
    ".gitignore": {},
    ".gitpod.yml": {},
    ".ignore": {},
    ".prettierignore": {},
    ".prettierrc": {},
    ".yarnrc": {},
    "CHANGELOG.md": {},
    "CODE_OF_CONDUCT.md": {},
    "CONTRIBUTING.md": {},
    "LICENSE": {},
    "README.md": {},
    "commands.md": {},
    "cspell.json": {},
    "index.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "module.exports = require(\"./src/index.js\");"
        ]
    },
    "jest.config.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "const path = require(\"path\");",
            "const installPrettier = require(\"./tests/config/install-prettier.js\");",
            "",
            "const PROJECT_ROOT = __dirname;",
            "const isProduction = process.env.NODE_ENV === \"production\";",
            "const ENABLE_CODE_COVERAGE = Boolean(process.env.ENABLE_CODE_COVERAGE);",
            "const TEST_STANDALONE = Boolean(process.env.TEST_STANDALONE);",
            "const INSTALL_PACKAGE = Boolean(process.env.INSTALL_PACKAGE);",
            "const SKIP_TESTS_WITH_NEW_SYNTAX =",
            "  process.versions.node.startsWith(\"10.\") ||",
            "  process.versions.node.startsWith(\"12.\");",
            "",
            "let PRETTIER_DIR = isProduction",
            "  ? path.join(PROJECT_ROOT, \"dist\")",
            "  : PROJECT_ROOT;",
            "if (INSTALL_PACKAGE || (isProduction && !TEST_STANDALONE)) {",
            "  PRETTIER_DIR = installPrettier(PRETTIER_DIR);",
            "}",
            "process.env.PRETTIER_DIR = PRETTIER_DIR;",
            "",
            "const testPathIgnorePatterns = [];",
            "let transform = {};",
            "if (TEST_STANDALONE) {",
            "  testPathIgnorePatterns.push(\"<rootDir>/tests/integration/\");",
            "}",
            "if (isProduction) {",
            "  // `esm` bundles need transform",
            "  transform = {",
            "    \"(?:\\\\.mjs|codeSamples\\\\.js)$\": [",
            "      \"babel-jest\",",
            "      {",
            "        presets: [",
            "          [",
            "            \"@babel/env\",",
            "            {",
            "              targets: { node: \"current\" },",
            "              exclude: [",
            "                \"transform-async-to-generator\",",
            "                \"transform-classes\",",
            "                \"proposal-async-generator-functions\",",
            "                \"transform-regenerator\",",
            "              ],",
            "            },",
            "          ],",
            "        ],",
            "      },",
            "    ],",
            "  };",
            "} else {",
            "  // Only test bundles for production",
            "  testPathIgnorePatterns.push(",
            "    \"<rootDir>/tests/integration/__tests__/bundle.js\"",
            "  );",
            "}",
            "",
            "if (SKIP_TESTS_WITH_NEW_SYNTAX) {",
            "  testPathIgnorePatterns.push(",
            "    \"<rootDir>/tests/integration/__tests__/help-options.js\"",
            "  );",
            "}",
            "",
            "module.exports = {",
            "  setupFiles: [\"<rootDir>/tests/config/setup.js\"],",
            "  snapshotSerializers: [",
            "    \"jest-snapshot-serializer-raw\",",
            "    \"jest-snapshot-serializer-ansi\",",
            "  ],",
            "  snapshotFormat: {",
            "    escapeString: false,",
            "    printBasicPrototype: false,",
            "  },",
            "  testRegex: \"jsfmt\\\\.spec\\\\.js$|__tests__/.*\\\\.js$\",",
            "  testPathIgnorePatterns,",
            "  collectCoverage: ENABLE_CODE_COVERAGE,",
            "  collectCoverageFrom: [\"<rootDir>/src/**/*.js\", \"<rootDir>/bin/**/*.js\"],",
            "  coveragePathIgnorePatterns: [",
            "    \"<rootDir>/src/standalone.js\",",
            "    \"<rootDir>/src/document/doc-debug.js\",",
            "  ],",
            "  coverageReporters: [\"text\", \"lcov\"],",
            "  moduleNameMapper: {",
            "    \"prettier-local\": \"<rootDir>/tests/config/require-prettier.js\",",
            "    \"prettier-standalone\": \"<rootDir>/tests/config/require-standalone.js\",",
            "  },",
            "  modulePathIgnorePatterns: [",
            "    \"<rootDir>/dist\",",
            "    \"<rootDir>/website\",",
            "    \"<rootDir>/scripts/release\",",
            "  ],",
            "  transform,",
            "  watchPlugins: [",
            "    \"jest-watch-typeahead/filename\",",
            "    \"jest-watch-typeahead/testname\",",
            "  ],",
            "};"
        ]
    },
    "netlify.toml": {},
    "package.json": {},
    "standalone.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "module.exports = require(\"./src/standalone.js\");"
        ]
    },
    "tsconfig.json": {},
    "yarn.lock": {},
    "bin": {
        "prettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "#!/usr/bin/env node",
                "",
                "\"use strict\";",
                "",
                "var pleaseUpgradeNode = require(\"please-upgrade-node\");",
                "var packageJson = require(\"../package.json\");",
                "",
                "pleaseUpgradeNode(packageJson);",
                "",
                "var cli = require(\"../src/cli/index.js\");",
                "",
                "module.exports = cli.run(process.argv.slice(2));"
            ]
        }
    },
    "changelog_unreleased": {
        "BLOG_POST_INTRO_TEMPLATE.md": {},
        "TEMPLATE.md": {},
        "angular": {
            ".gitkeep": {}
        },
        "api": {
            ".gitkeep": {}
        },
        "cli": {
            ".gitkeep": {}
        },
        "css": {
            ".gitkeep": {}
        },
        "flow": {
            ".gitkeep": {}
        },
        "graphql": {
            ".gitkeep": {}
        },
        "handlebars": {
            ".gitkeep": {},
            "14067.md": {}
        },
        "html": {
            ".gitkeep": {}
        },
        "javascript": {
            ".gitkeep": {}
        },
        "json": {
            ".gitkeep": {}
        },
        "less": {
            ".gitkeep": {}
        },
        "lwc": {
            ".gitkeep": {}
        },
        "markdown": {
            ".gitkeep": {}
        },
        "mdx": {
            ".gitkeep": {}
        },
        "misc": {
            ".gitkeep": {}
        },
        "scss": {
            ".gitkeep": {}
        },
        "typescript": {
            ".gitkeep": {}
        },
        "vue": {
            ".gitkeep": {}
        },
        "yaml": {
            ".gitkeep": {}
        }
    },
    "src": {
        "index.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const { version } = require(\"../package.json\");",
                "",
                "const core = require(\"./main/core.js\");",
                "const { getSupportInfo } = require(\"./main/support.js\");",
                "const getFileInfo = require(\"./common/get-file-info.js\");",
                "const sharedUtil = require(\"./common/util-shared.js\");",
                "const plugins = require(\"./common/load-plugins.js\");",
                "const config = require(\"./config/resolve-config.js\");",
                "const doc = require(\"./document/index.js\");",
                "",
                "function _withPlugins(",
                "  fn,",
                "  optsArgIdx = 1 // Usually `opts` is the 2nd argument",
                ") {",
                "  return (...args) => {",
                "    const opts = args[optsArgIdx] || {};",
                "    args[optsArgIdx] = {",
                "      ...opts,",
                "      plugins: plugins.loadPlugins(opts.plugins, opts.pluginSearchDirs),",
                "    };",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "/**",
                " * @param {*} fn",
                " * @param {*} optsArgIdx",
                " * @returns {*}",
                " */",
                "function withPlugins(fn, optsArgIdx) {",
                "  const resultingFn = _withPlugins(fn, optsArgIdx);",
                "  if (fn.sync) {",
                "    // @ts-expect-error",
                "    resultingFn.sync = _withPlugins(fn.sync, optsArgIdx);",
                "  }",
                "  return resultingFn;",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "module.exports = {",
                "  formatWithCursor,",
                "",
                "  format(text, opts) {",
                "    return formatWithCursor(text, opts).formatted;",
                "  },",
                "",
                "  check(text, opts) {",
                "    const { formatted } = formatWithCursor(text, opts);",
                "    return formatted === text;",
                "  },",
                "",
                "  doc,",
                "",
                "  resolveConfig: config.resolveConfig,",
                "  resolveConfigFile: config.resolveConfigFile,",
                "  clearConfigCache() {",
                "    config.clearCache();",
                "    plugins.clearCache();",
                "  },",
                "",
                "  /** @type {typeof getFileInfo} */",
                "  getFileInfo: withPlugins(getFileInfo),",
                "  /** @type {typeof getSupportInfo} */",
                "  getSupportInfo: withPlugins(getSupportInfo, 0),",
                "",
                "  version,",
                "",
                "  util: sharedUtil,",
                "",
                "  // Internal shared",
                "  __internal: {",
                "    errors: require(\"./common/errors.js\"),",
                "    coreOptions: require(\"./main/core-options.js\"),",
                "    createIgnorer: require(\"./common/create-ignorer.js\"),",
                "    optionsModule: require(\"./main/options.js\"),",
                "    optionsNormalizer: require(\"./main/options-normalizer.js\"),",
                "    utils: {",
                "      arrayify: require(\"./utils/arrayify.js\"),",
                "      getLast: require(\"./utils/get-last.js\"),",
                "      partition: require(\"./utils/partition.js\"),",
                "      isNonEmptyArray: require(\"./common/util.js\").isNonEmptyArray,",
                "    },",
                "  },",
                "",
                "  /* istanbul ignore next */",
                "  __debug: {",
                "    parse: withPlugins(core.parse),",
                "    formatAST: withPlugins(core.formatAST),",
                "    formatDoc: withPlugins(core.formatDoc),",
                "    printToDoc: withPlugins(core.printToDoc),",
                "    printDocToString: withPlugins(core.printDocToString),",
                "  },",
                "};"
            ]
        },
        "languages.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "// We need to list the parsers and getters so we can load them only when necessary.",
                "module.exports = [",
                "  // JS",
                "  require(\"./language-js/index.js\"),",
                "  // CSS",
                "  require(\"./language-css/index.js\"),",
                "  // Handlebars",
                "  require(\"./language-handlebars/index.js\"),",
                "  // GraphQL",
                "  require(\"./language-graphql/index.js\"),",
                "  // Markdown",
                "  require(\"./language-markdown/index.js\"),",
                "  // HTML",
                "  require(\"./language-html/index.js\"),",
                "  // YAML",
                "  require(\"./language-yaml/index.js\"),",
                "];"
            ]
        },
        "standalone.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const { version } = require(\"../package.json\");",
                "",
                "const core = require(\"./main/core.js\");",
                "const { getSupportInfo } = require(\"./main/support.js\");",
                "const sharedUtil = require(\"./common/util-shared.js\");",
                "const languages = require(\"./languages.js\");",
                "const doc = require(\"./document/index.js\");",
                "",
                "function withPlugins(",
                "  fn,",
                "  optsArgIdx = 1 // Usually `opts` is the 2nd argument",
                ") {",
                "  return (...args) => {",
                "    const opts = args[optsArgIdx] || {};",
                "    const plugins = opts.plugins || [];",
                "",
                "    args[optsArgIdx] = {",
                "      ...opts,",
                "      plugins: [",
                "        ...languages,",
                "        ...(Array.isArray(plugins) ? plugins : Object.values(plugins)),",
                "      ],",
                "    };",
                "",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "module.exports = {",
                "  formatWithCursor,",
                "",
                "  format(text, opts) {",
                "    return formatWithCursor(text, opts).formatted;",
                "  },",
                "",
                "  check(text, opts) {",
                "    const { formatted } = formatWithCursor(text, opts);",
                "    return formatted === text;",
                "  },",
                "",
                "  doc,",
                "",
                "  getSupportInfo: withPlugins(getSupportInfo, 0),",
                "",
                "  version,",
                "",
                "  util: sharedUtil,",
                "",
                "  __debug: {",
                "    parse: withPlugins(core.parse),",
                "    formatAST: withPlugins(core.formatAST),",
                "    formatDoc: withPlugins(core.formatDoc),",
                "    printToDoc: withPlugins(core.printToDoc),",
                "    printDocToString: withPlugins(core.printDocToString),",
                "  },",
                "};"
            ]
        },
        "cli": {
            "constant.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { outdent } = require(\"outdent\");",
                    "const { coreOptions } = require(\"./prettier-internal.js\");",
                    "",
                    "const categoryOrder = [",
                    "  coreOptions.CATEGORY_OUTPUT,",
                    "  coreOptions.CATEGORY_FORMAT,",
                    "  coreOptions.CATEGORY_CONFIG,",
                    "  coreOptions.CATEGORY_EDITOR,",
                    "  coreOptions.CATEGORY_OTHER,",
                    "];",
                    "",
                    "/**",
                    " * {",
                    " *   [optionName]: {",
                    " *     // The type of the option. For 'choice', see also `choices` below.",
                    " *     // When passing a type other than the ones listed below, the option is",
                    " *     // treated as taking any string as argument, and `--option <${type}>` will",
                    " *     // be displayed in --help.",
                    " *     type: \"boolean\" | \"choice\" | \"int\" | string;",
                    " *",
                    " *     // Default value to be passed to the minimist option `default`.",
                    " *     default?: any;",
                    " *",
                    " *     // Alias name to be passed to the minimist option `alias`.",
                    " *     alias?: string;",
                    " *",
                    " *     // For grouping options by category in --help.",
                    " *     category?: string;",
                    " *",
                    " *     // Description to be displayed in --help. If omitted, the option won't be",
                    " *     // shown at all in --help (but see also `oppositeDescription` below).",
                    " *     description?: string;",
                    " *",
                    " *     // Description for `--no-${name}` to be displayed in --help. If omitted,",
                    " *     // `--no-${name}` won't be shown.",
                    " *     oppositeDescription?: string;",
                    " *",
                    " *     // Indicate if this option is simply passed to the API.",
                    " *     // true: use camelified name as the API option name.",
                    " *     // string: use this value as the API option name.",
                    " *     forwardToApi?: boolean | string;",
                    " *",
                    " *     // Indicate that a CLI flag should be an array when forwarded to the API.",
                    " *     array?: boolean;",
                    " *",
                    " *     // Specify available choices for validation. They will also be displayed",
                    " *     // in --help as <a|b|c>.",
                    " *     // Use an object instead of a string if a choice is deprecated and should",
                    " *     // be treated as `redirect` instead, or if you'd like to add description for",
                    " *     // the choice.",
                    " *     choices?: Array<",
                    " *       | string",
                    " *       | { value: string, description?: string, deprecated?: boolean, redirect?: string }",
                    " *     >;",
                    " *",
                    " *     // If the option has a value that is an exception to the regular value",
                    " *     // constraints, indicate that value here (or use a function for more",
                    " *     // flexibility).",
                    " *     exception?: ((value: any) => boolean);",
                    " *",
                    " *     // Indicate that the option is deprecated. Use a string to add an extra",
                    " *     // message to --help for the option, for example to suggest a replacement",
                    " *     // option.",
                    " *     deprecated?: true | string;",
                    " *   }",
                    " * }",
                    " *",
                    " * Note: The options below are sorted alphabetically.",
                    " */",
                    "/* eslint sort-keys: \"error\" */",
                    "const options = {",
                    "  cache: {",
                    "    default: false,",
                    "    description: \"Only format changed files. Cannot use with --stdin-filepath.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"cache-location\": {",
                    "    description: \"Path to the cache file.\",",
                    "    type: \"path\",",
                    "  },",
                    "  \"cache-strategy\": {",
                    "    choices: [",
                    "      {",
                    "        description: \"Use the file metadata such as timestamps as cache keys\",",
                    "        value: \"metadata\",",
                    "      },",
                    "      {",
                    "        description: \"Use the file content as cache keys\",",
                    "        value: \"content\",",
                    "      },",
                    "    ],",
                    "    description: \"Strategy for the cache to use for detecting changed files.\",",
                    "    type: \"choice\",",
                    "  },",
                    "  check: {",
                    "    alias: \"c\",",
                    "    category: coreOptions.CATEGORY_OUTPUT,",
                    "    description: outdent`",
                    "      Check if the given files are formatted, print a human-friendly summary",
                    "      message and paths to unformatted files (see also --list-different).",
                    "    `,",
                    "    type: \"boolean\",",
                    "  },",
                    "  color: {",
                    "    // The supports-color package (a sub sub dependency) looks directly at",
                    "    // `process.argv` for `--no-color` and such-like options. The reason it is",
                    "    // listed here is to avoid \"Ignored unknown option: --no-color\" warnings.",
                    "    // See https://github.com/chalk/supports-color/#info for more information.",
                    "    default: true,",
                    "    description: \"Colorize error messages.\",",
                    "    oppositeDescription: \"Do not colorize error messages.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  config: {",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).\",",
                    "    exception: (value) => value === false,",
                    "    oppositeDescription: \"Do not look for a configuration file.\",",
                    "    type: \"path\",",
                    "  },",
                    "  \"config-precedence\": {",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    choices: [",
                    "      {",
                    "        description: \"CLI options take precedence over config file\",",
                    "        value: \"cli-override\",",
                    "      },",
                    "      {",
                    "        description: \"Config file take precedence over CLI options\",",
                    "        value: \"file-override\",",
                    "      },",
                    "      {",
                    "        description: outdent`",
                    "          If a config file is found will evaluate it and ignore other CLI options.",
                    "          If no config file is found CLI options will evaluate as normal.",
                    "        `,",
                    "        value: \"prefer-file\",",
                    "      },",
                    "    ],",
                    "    default: \"cli-override\",",
                    "    description:",
                    "      \"Define in which order config files and CLI options should be evaluated.\",",
                    "    type: \"choice\",",
                    "  },",
                    "  \"debug-benchmark\": {",
                    "    // Run the formatting benchmarks. Requires 'benchmark' module to be installed.",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-check\": {",
                    "    // Run the formatting once again on the formatted output, throw if different.",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-print-ast\": {",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-print-comments\": {",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-print-doc\": {",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-repeat\": {",
                    "    // Repeat the formatting a few times and measure the average duration.",
                    "    default: 0,",
                    "    type: \"int\",",
                    "  },",
                    "  editorconfig: {",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    default: true,",
                    "    description: \"Take .editorconfig into account when parsing configuration.\",",
                    "    oppositeDescription:",
                    "      \"Don't take .editorconfig into account when parsing configuration.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"error-on-unmatched-pattern\": {",
                    "    oppositeDescription: \"Prevent errors when pattern is unmatched.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"file-info\": {",
                    "    description: outdent`",
                    "      Extract the following info (as JSON) for a given file path. Reported fields:",
                    "      * ignored (boolean) - true if file path is filtered by --ignore-path",
                    "      * inferredParser (string | null) - name of parser inferred from file path",
                    "    `,",
                    "    type: \"path\",",
                    "  },",
                    "  \"find-config-path\": {",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Find and print the path to a configuration file for the given input file.\",",
                    "    type: \"path\",",
                    "  },",
                    "  help: {",
                    "    alias: \"h\",",
                    "    description: outdent`",
                    "      Show CLI usage, or details about the given flag.",
                    "      Example: --help write",
                    "    `,",
                    "    exception: (value) => value === \"\",",
                    "    type: \"flag\",",
                    "  },",
                    "  \"ignore-path\": {",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    default: \".prettierignore\",",
                    "    description: \"Path to a file with patterns describing files to ignore.\",",
                    "    type: \"path\",",
                    "  },",
                    "  \"ignore-unknown\": {",
                    "    alias: \"u\",",
                    "    description: \"Ignore unknown files.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"list-different\": {",
                    "    alias: \"l\",",
                    "    category: coreOptions.CATEGORY_OUTPUT,",
                    "    description:",
                    "      \"Print the names of files that are different from Prettier's formatting (see also --check).\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  loglevel: {",
                    "    choices: [\"silent\", \"error\", \"warn\", \"log\", \"debug\"],",
                    "    default: \"log\",",
                    "    description: \"What level of logs to report.\",",
                    "    type: \"choice\",",
                    "  },",
                    "  \"plugin-search\": {",
                    "    oppositeDescription: \"Disable plugin autoloading.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"support-info\": {",
                    "    description: \"Print support information as JSON.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  version: {",
                    "    alias: \"v\",",
                    "    description: \"Print Prettier version.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"with-node-modules\": {",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description: \"Process files inside 'node_modules' directory.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  write: {",
                    "    alias: \"w\",",
                    "    category: coreOptions.CATEGORY_OUTPUT,",
                    "    description: \"Edit files in-place. (Beware!)\",",
                    "    type: \"boolean\",",
                    "  },",
                    "};",
                    "",
                    "const usageSummary = outdent`",
                    "  Usage: prettier [options] [file/dir/glob ...]",
                    "",
                    "  By default, output is written to stdout.",
                    "  Stdin is read if it is piped to Prettier and no files are given.",
                    "`;",
                    "",
                    "module.exports = {",
                    "  categoryOrder,",
                    "  options,",
                    "  usageSummary,",
                    "};"
                ]
            },
            "context.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const {",
                    "  utils: { getLast },",
                    "} = require(\"./prettier-internal.js\");",
                    "const getContextOptions = require(\"./options/get-context-options.js\");",
                    "const {",
                    "  parseArgv,",
                    "  parseArgvWithoutPlugins,",
                    "} = require(\"./options/parse-cli-arguments.js\");",
                    "",
                    "/**",
                    " * @typedef {Object} Context",
                    " * @property logger",
                    " * @property {string[]} rawArguments",
                    " * @property argv",
                    " * @property {string[]} filePatterns",
                    " * @property {any[]} supportOptions",
                    " * @property detailedOptions",
                    " * @property detailedOptionMap",
                    " * @property apiDefaultOptions",
                    " * @property languages",
                    " * @property {Partial<Context>[]} stack",
                    " * @property pushContextPlugins",
                    " * @property popContextPlugins",
                    " */",
                    "",
                    "class Context {",
                    "  constructor({ rawArguments, logger }) {",
                    "    this.rawArguments = rawArguments;",
                    "    this.logger = logger;",
                    "    this.stack = [];",
                    "",
                    "    const { plugins, pluginSearchDirs } = parseArgvWithoutPlugins(",
                    "      rawArguments,",
                    "      logger,",
                    "      [\"plugin\", \"plugin-search-dir\"]",
                    "    );",
                    "",
                    "    this.pushContextPlugins(plugins, pluginSearchDirs);",
                    "",
                    "    const argv = parseArgv(rawArguments, this.detailedOptions, logger);",
                    "    this.argv = argv;",
                    "    this.filePatterns = argv._.map(String);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string[]} plugins",
                    "   * @param {string[]=} pluginSearchDirs",
                    "   */",
                    "  pushContextPlugins(plugins, pluginSearchDirs) {",
                    "    const options = getContextOptions(plugins, pluginSearchDirs);",
                    "    this.stack.push(options);",
                    "    Object.assign(this, options);",
                    "  }",
                    "",
                    "  popContextPlugins() {",
                    "    this.stack.pop();",
                    "    Object.assign(this, getLast(this.stack));",
                    "  }",
                    "",
                    "  // eslint-disable-next-line getter-return",
                    "  get performanceTestFlag() {",
                    "    const { debugBenchmark, debugRepeat } = this.argv;",
                    "    /* istanbul ignore next */",
                    "    if (debugBenchmark) {",
                    "      return {",
                    "        name: \"--debug-benchmark\",",
                    "        debugBenchmark: true,",
                    "      };",
                    "    }",
                    "",
                    "    if (debugRepeat > 0) {",
                    "      return {",
                    "        name: \"--debug-repeat\",",
                    "        debugRepeat,",
                    "      };",
                    "    }",
                    "",
                    "    const { PRETTIER_PERF_REPEAT } = process.env;",
                    "    if (PRETTIER_PERF_REPEAT && /^\\d+$/.test(PRETTIER_PERF_REPEAT)) {",
                    "      return {",
                    "        name: \"PRETTIER_PERF_REPEAT (environment variable)\",",
                    "        debugRepeat: Number(PRETTIER_PERF_REPEAT),",
                    "      };",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = Context;"
                ]
            },
            "expand-patterns.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const fastGlob = require(\"fast-glob\");",
                    "",
                    "const { statSafe } = require(\"./utils.js\");",
                    "",
                    "/** @typedef {import('./context').Context} Context */",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "async function* expandPatterns(context) {",
                    "  const cwd = process.cwd();",
                    "  const seen = new Set();",
                    "  let noResults = true;",
                    "",
                    "  for await (const pathOrError of expandPatternsInternal(context)) {",
                    "    noResults = false;",
                    "    if (typeof pathOrError !== \"string\") {",
                    "      yield pathOrError;",
                    "      continue;",
                    "    }",
                    "",
                    "    const relativePath = path.relative(cwd, pathOrError);",
                    "",
                    "    // filter out duplicates",
                    "    if (seen.has(relativePath)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    seen.add(relativePath);",
                    "    yield relativePath;",
                    "  }",
                    "",
                    "  if (noResults && context.argv.errorOnUnmatchedPattern !== false) {",
                    "    // If there was no files and no other errors, let's yield a general error.",
                    "    yield {",
                    "      error: `No matching files. Patterns: ${context.filePatterns.join(\" \")}`,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "async function* expandPatternsInternal(context) {",
                    "  // Ignores files in version control systems directories and `node_modules`",
                    "  const silentlyIgnoredDirs = [\".git\", \".sl\", \".svn\", \".hg\"];",
                    "  if (context.argv.withNodeModules !== true) {",
                    "    silentlyIgnoredDirs.push(\"node_modules\");",
                    "  }",
                    "  const globOptions = {",
                    "    dot: true,",
                    "    ignore: silentlyIgnoredDirs.map((dir) => \"**/\" + dir),",
                    "  };",
                    "",
                    "  let supportedFilesGlob;",
                    "  const cwd = process.cwd();",
                    "",
                    "  /** @type {Array<{ type: 'file' | 'dir' | 'glob'; glob: string; input: string; }>} */",
                    "  const entries = [];",
                    "",
                    "  for (const pattern of context.filePatterns) {",
                    "    const absolutePath = path.resolve(cwd, pattern);",
                    "",
                    "    if (containsIgnoredPathSegment(absolutePath, cwd, silentlyIgnoredDirs)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const stat = await statSafe(absolutePath);",
                    "    if (stat) {",
                    "      if (stat.isFile()) {",
                    "        entries.push({",
                    "          type: \"file\",",
                    "          glob: escapePathForGlob(fixWindowsSlashes(pattern)),",
                    "          input: pattern,",
                    "        });",
                    "      } else if (stat.isDirectory()) {",
                    "        /*",
                    "        1. Remove trailing `/`, `fast-glob` can't find files for `src//*.js` pattern",
                    "        2. Cleanup dirname, when glob `src/../*.js` pattern with `fast-glob`,",
                    "          it returns files like 'src/../index.js'",
                    "        */",
                    "        const relativePath = path.relative(cwd, absolutePath) || \".\";",
                    "        entries.push({",
                    "          type: \"dir\",",
                    "          glob:",
                    "            escapePathForGlob(fixWindowsSlashes(relativePath)) +",
                    "            \"/\" +",
                    "            getSupportedFilesGlob(),",
                    "          input: pattern,",
                    "        });",
                    "      }",
                    "    } else if (pattern[0] === \"!\") {",
                    "      // convert negative patterns to `ignore` entries",
                    "      globOptions.ignore.push(fixWindowsSlashes(pattern.slice(1)));",
                    "    } else {",
                    "      entries.push({",
                    "        type: \"glob\",",
                    "        glob: fixWindowsSlashes(pattern),",
                    "        input: pattern,",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  for (const { type, glob, input } of entries) {",
                    "    let result;",
                    "",
                    "    try {",
                    "      result = await fastGlob(glob, globOptions);",
                    "    } catch ({ message }) {",
                    "      /* istanbul ignore next */",
                    "      yield { error: `${errorMessages.globError[type]}: ${input}\\n${message}` };",
                    "      /* istanbul ignore next */",
                    "      continue;",
                    "    }",
                    "",
                    "    if (result.length === 0) {",
                    "      if (context.argv.errorOnUnmatchedPattern !== false) {",
                    "        yield { error: `${errorMessages.emptyResults[type]}: \"${input}\".` };",
                    "      }",
                    "    } else {",
                    "      yield* sortPaths(result);",
                    "    }",
                    "  }",
                    "",
                    "  function getSupportedFilesGlob() {",
                    "    if (!supportedFilesGlob) {",
                    "      const extensions = context.languages.flatMap(",
                    "        (lang) => lang.extensions || []",
                    "      );",
                    "      const filenames = context.languages.flatMap(",
                    "        (lang) => lang.filenames || []",
                    "      );",
                    "      supportedFilesGlob = `**/{${[",
                    "        ...extensions.map((ext) => \"*\" + (ext[0] === \".\" ? ext : \".\" + ext)),",
                    "        ...filenames,",
                    "      ]}}`;",
                    "    }",
                    "    return supportedFilesGlob;",
                    "  }",
                    "}",
                    "",
                    "const errorMessages = {",
                    "  globError: {",
                    "    file: \"Unable to resolve file\",",
                    "    dir: \"Unable to expand directory\",",
                    "    glob: \"Unable to expand glob pattern\",",
                    "  },",
                    "  emptyResults: {",
                    "    file: \"Explicitly specified file was ignored due to negative glob patterns\",",
                    "    dir: \"No supported files were found in the directory\",",
                    "    glob: \"No files matching the pattern were found\",",
                    "  },",
                    "};",
                    "",
                    "/**",
                    " * @param {string} absolutePath",
                    " * @param {string} cwd",
                    " * @param {string[]} ignoredDirectories",
                    " */",
                    "function containsIgnoredPathSegment(absolutePath, cwd, ignoredDirectories) {",
                    "  return path",
                    "    .relative(cwd, absolutePath)",
                    "    .split(path.sep)",
                    "    .some((dir) => ignoredDirectories.includes(dir));",
                    "}",
                    "",
                    "/**",
                    " * @param {string[]} paths",
                    " */",
                    "function sortPaths(paths) {",
                    "  return paths.sort((a, b) => a.localeCompare(b));",
                    "}",
                    "",
                    "/**",
                    " * This function should be replaced with `fastGlob.escapePath` when these issues are fixed:",
                    " * - https://github.com/mrmlnc/fast-glob/issues/261",
                    " * - https://github.com/mrmlnc/fast-glob/issues/262",
                    " * @param {string} path",
                    " */",
                    "function escapePathForGlob(path) {",
                    "  return fastGlob",
                    "    .escapePath(",
                    "      path.replace(/\\\\/g, \"\\0\") // Workaround for fast-glob#262 (part 1)",
                    "    )",
                    "    .replace(/\\\\!/g, \"@(!)\") // Workaround for fast-glob#261",
                    "    .replace(/\\0/g, \"@(\\\\\\\\)\"); // Workaround for fast-glob#262 (part 2)",
                    "}",
                    "",
                    "const isWindows = path.sep === \"\\\\\";",
                    "",
                    "/**",
                    " * Using backslashes in globs is probably not okay, but not accepting",
                    " * backslashes as path separators on Windows is even more not okay.",
                    " * https://github.com/prettier/prettier/pull/6776#discussion_r380723717",
                    " * https://github.com/mrmlnc/fast-glob#how-to-write-patterns-on-windows",
                    " * @param {string} pattern",
                    " */",
                    "function fixWindowsSlashes(pattern) {",
                    "  return isWindows ? pattern.replace(/\\\\/g, \"/\") : pattern;",
                    "}",
                    "",
                    "module.exports = {",
                    "  expandPatterns,",
                    "  fixWindowsSlashes,",
                    "};"
                ]
            },
            "file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const stringify = require(\"fast-json-stable-stringify\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index.js\");",
                    "const { printToScreen } = require(\"./utils.js\");",
                    "",
                    "async function logFileInfoOrDie(context) {",
                    "  const {",
                    "    fileInfo: file,",
                    "    ignorePath,",
                    "    withNodeModules,",
                    "    plugins,",
                    "    pluginSearchDirs,",
                    "    config,",
                    "  } = context.argv;",
                    "",
                    "  const fileInfo = await prettier.getFileInfo(file, {",
                    "    ignorePath,",
                    "    withNodeModules,",
                    "    plugins,",
                    "    pluginSearchDirs,",
                    "    resolveConfig: config !== false,",
                    "  });",
                    "",
                    "  printToScreen(prettier.format(stringify(fileInfo), { parser: \"json\" }));",
                    "}",
                    "",
                    "module.exports = logFileInfoOrDie;"
                ]
            },
            "find-cache-file.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\").promises;",
                    "const os = require(\"os\");",
                    "const path = require(\"path\");",
                    "const findCacheDir = require(\"find-cache-dir\");",
                    "const { statSafe, isJson } = require(\"./utils.js\");",
                    "",
                    "/**",
                    " * Find default cache file (`./node_modules/.cache/prettier/.prettier-cache`) using https://github.com/avajs/find-cache-dir",
                    " */",
                    "function findDefaultCacheFile() {",
                    "  const cacheDir =",
                    "    findCacheDir({ name: \"prettier\", create: true }) || os.tmpdir();",
                    "  const cacheFilePath = path.join(cacheDir, \".prettier-cache\");",
                    "  return cacheFilePath;",
                    "}",
                    "",
                    "async function findCacheFileFromOption(cacheLocation) {",
                    "  const cacheFile = path.resolve(cacheLocation);",
                    "",
                    "  const stat = await statSafe(cacheFile);",
                    "  if (stat) {",
                    "    if (stat.isDirectory()) {",
                    "      throw new Error(",
                    "        `Resolved --cache-location '${cacheFile}' is a directory`",
                    "      );",
                    "    }",
                    "",
                    "    const data = await fs.readFile(cacheFile, \"utf8\");",
                    "    if (!isJson(data)) {",
                    "      throw new Error(`'${cacheFile}' isn't a valid JSON file`);",
                    "    }",
                    "  }",
                    "",
                    "  return cacheFile;",
                    "}",
                    "",
                    "/**",
                    " * @param {string | undefined} cacheLocation",
                    " * @returns {Promise<string>}",
                    " */",
                    "async function findCacheFile(cacheLocation) {",
                    "  if (!cacheLocation) {",
                    "    return findDefaultCacheFile();",
                    "  }",
                    "  const cacheFile = await findCacheFileFromOption(cacheLocation);",
                    "  return cacheFile;",
                    "}",
                    "",
                    "module.exports = findCacheFile;"
                ]
            },
            "find-config-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index.js\");",
                    "const { printToScreen } = require(\"./utils.js\");",
                    "",
                    "async function logResolvedConfigPathOrDie(context) {",
                    "  const file = context.argv.findConfigPath;",
                    "  const configFile = await prettier.resolveConfigFile(file);",
                    "  if (configFile) {",
                    "    printToScreen(path.relative(process.cwd(), configFile));",
                    "  } else {",
                    "    throw new Error(`Can not find configure file for \"${file}\"`);",
                    "  }",
                    "}",
                    "",
                    "module.exports = logResolvedConfigPathOrDie;"
                ]
            },
            "format-results-cache.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// Inspired by LintResultsCache from ESLint",
                    "// https://github.com/eslint/eslint/blob/c2d0a830754b6099a3325e6d3348c3ba983a677a/lib/cli-engine/lint-result-cache.js",
                    "",
                    "const fileEntryCache = require(\"file-entry-cache\");",
                    "const stringify = require(\"fast-json-stable-stringify\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { version: prettierVersion } = require(\"../index.js\");",
                    "const { createHash } = require(\"./utils.js\");",
                    "",
                    "const optionsHashCache = new WeakMap();",
                    "const nodeVersion = process && process.version;",
                    "",
                    "/**",
                    " * @param {*} options",
                    " * @returns {string}",
                    " */",
                    "function getHashOfOptions(options) {",
                    "  if (optionsHashCache.has(options)) {",
                    "    return optionsHashCache.get(options);",
                    "  }",
                    "  const hash = createHash(",
                    "    `${prettierVersion}_${nodeVersion}_${stringify(options)}`",
                    "  );",
                    "  optionsHashCache.set(options, hash);",
                    "  return hash;",
                    "}",
                    "",
                    "/**",
                    " * @typedef {{ hashOfOptions?: string }} OurMeta",
                    " * @typedef {import(\"file-entry-cache\").FileDescriptor} FileDescriptor",
                    " *",
                    " * @param {import(\"file-entry-cache\").FileDescriptor} fileDescriptor",
                    " * @returns {FileDescriptor[\"meta\"] & OurMeta}",
                    " */",
                    "function getMetadataFromFileDescriptor(fileDescriptor) {",
                    "  return fileDescriptor.meta;",
                    "}",
                    "",
                    "class FormatResultsCache {",
                    "  /**",
                    "   * @param {string} cacheFileLocation The path of cache file location. (default: `node_modules/.cache/prettier/.prettier-cache`)",
                    "   * @param {string} cacheStrategy",
                    "   */",
                    "  constructor(cacheFileLocation, cacheStrategy) {",
                    "    const useChecksum = cacheStrategy === \"content\";",
                    "",
                    "    this.cacheFileLocation = cacheFileLocation;",
                    "    this.fileEntryCache = fileEntryCache.create(",
                    "      /* cacheId */ cacheFileLocation,",
                    "      /* directory */ undefined,",
                    "      useChecksum",
                    "    );",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string} filePath",
                    "   * @param {any} options",
                    "   */",
                    "  existsAvailableFormatResultsCache(filePath, options) {",
                    "    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);",
                    "",
                    "    if (fileDescriptor.notFound) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const hashOfOptions = getHashOfOptions(options);",
                    "    const meta = getMetadataFromFileDescriptor(fileDescriptor);",
                    "    const changed =",
                    "      fileDescriptor.changed || meta.hashOfOptions !== hashOfOptions;",
                    "",
                    "    return !changed;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string} filePath",
                    "   * @param {any} options",
                    "   */",
                    "  setFormatResultsCache(filePath, options) {",
                    "    const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);",
                    "    const meta = getMetadataFromFileDescriptor(fileDescriptor);",
                    "    if (fileDescriptor && !fileDescriptor.notFound) {",
                    "      meta.hashOfOptions = getHashOfOptions(options);",
                    "    }",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string} filePath",
                    "   */",
                    "  removeFormatResultsCache(filePath) {",
                    "    this.fileEntryCache.removeEntry(filePath);",
                    "  }",
                    "",
                    "  reconcile() {",
                    "    this.fileEntryCache.reconcile();",
                    "  }",
                    "}",
                    "",
                    "module.exports = FormatResultsCache;"
                ]
            },
            "format.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { promises: fs } = require(\"fs\");",
                    "const path = require(\"path\");",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { default: chalk } = require(\"../../vendors/chalk.js\");",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index.js\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { getStdin } = require(\"../common/third-party.js\");",
                    "",
                    "const { createIgnorer, errors } = require(\"./prettier-internal.js\");",
                    "const { expandPatterns, fixWindowsSlashes } = require(\"./expand-patterns.js\");",
                    "const getOptionsForFile = require(\"./options/get-options-for-file.js\");",
                    "const isTTY = require(\"./is-tty.js\");",
                    "const findCacheFile = require(\"./find-cache-file.js\");",
                    "const FormatResultsCache = require(\"./format-results-cache.js\");",
                    "const { statSafe } = require(\"./utils.js\");",
                    "",
                    "function diff(a, b) {",
                    "  return require(\"diff\").createTwoFilesPatch(\"\", \"\", a, b, \"\", \"\", {",
                    "    context: 2,",
                    "  });",
                    "}",
                    "",
                    "function handleError(context, filename, error, printedFilename) {",
                    "  if (error instanceof errors.UndefinedParserError) {",
                    "    // Can't test on CI, `isTTY()` is always false, see ./is-tty.js",
                    "    /* istanbul ignore next */",
                    "    if ((context.argv.write || context.argv.ignoreUnknown) && printedFilename) {",
                    "      printedFilename.clear();",
                    "    }",
                    "    if (context.argv.ignoreUnknown) {",
                    "      return;",
                    "    }",
                    "    if (!context.argv.check && !context.argv.listDifferent) {",
                    "      process.exitCode = 2;",
                    "    }",
                    "    context.logger.error(error.message);",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.write) {",
                    "    // Add newline to split errors from filename line.",
                    "    process.stdout.write(\"\\n\");",
                    "  }",
                    "",
                    "  const isParseError = Boolean(error && error.loc);",
                    "  const isValidationError = /^Invalid \\S+ value\\./.test(error && error.message);",
                    "",
                    "  if (isParseError) {",
                    "    // `invalid.js: SyntaxError: Unexpected token (1:1)`.",
                    "    context.logger.error(`${filename}: ${String(error)}`);",
                    "  } else if (isValidationError || error instanceof errors.ConfigError) {",
                    "    // `Invalid printWidth value. Expected an integer, but received 0.5.`",
                    "    context.logger.error(error.message);",
                    "    // If validation fails for one file, it will fail for all of them.",
                    "    process.exit(1);",
                    "  } else if (error instanceof errors.DebugError) {",
                    "    // `invalid.js: Some debug error message`",
                    "    context.logger.error(`${filename}: ${error.message}`);",
                    "  } else {",
                    "    // `invalid.js: Error: Some unexpected error\\n[stack trace]`",
                    "    /* istanbul ignore next */",
                    "    context.logger.error(filename + \": \" + (error.stack || error));",
                    "  }",
                    "",
                    "  // Don't exit the process if one file failed",
                    "  process.exitCode = 2;",
                    "}",
                    "",
                    "function writeOutput(context, result, options) {",
                    "  // Don't use `console.log` here since it adds an extra newline at the end.",
                    "  process.stdout.write(",
                    "    context.argv.debugCheck ? result.filepath : result.formatted",
                    "  );",
                    "",
                    "  if (options && options.cursorOffset >= 0) {",
                    "    process.stderr.write(result.cursorOffset + \"\\n\");",
                    "  }",
                    "}",
                    "",
                    "function listDifferent(context, input, options, filename) {",
                    "  if (!context.argv.check && !context.argv.listDifferent) {",
                    "    return;",
                    "  }",
                    "",
                    "  try {",
                    "    if (!options.filepath && !options.parser) {",
                    "      throw new errors.UndefinedParserError(",
                    "        \"No parser and no file path given, couldn't infer a parser.\"",
                    "      );",
                    "    }",
                    "    if (!prettier.check(input, options)) {",
                    "      if (!context.argv.write) {",
                    "        context.logger.log(filename);",
                    "        process.exitCode = 1;",
                    "      }",
                    "    }",
                    "  } catch (error) {",
                    "    context.logger.error(error.message);",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function format(context, input, opt) {",
                    "  if (!opt.parser && !opt.filepath) {",
                    "    throw new errors.UndefinedParserError(",
                    "      \"No parser and no file path given, couldn't infer a parser.\"",
                    "    );",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintDoc) {",
                    "    const doc = prettier.__debug.printToDoc(input, opt);",
                    "    return { formatted: prettier.__debug.formatDoc(doc) + \"\\n\" };",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintComments) {",
                    "    return {",
                    "      formatted: prettier.format(",
                    "        JSON.stringify(prettier.formatWithCursor(input, opt).comments || []),",
                    "        { parser: \"json\" }",
                    "      ),",
                    "    };",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintAst) {",
                    "    const { ast } = prettier.__debug.parse(input, opt);",
                    "    return {",
                    "      formatted: JSON.stringify(ast),",
                    "    };",
                    "  }",
                    "",
                    "  if (context.argv.debugCheck) {",
                    "    const pp = prettier.format(input, opt);",
                    "    const pppp = prettier.format(pp, opt);",
                    "    if (pp !== pppp) {",
                    "      throw new errors.DebugError(",
                    "        \"prettier(input) !== prettier(prettier(input))\\n\" + diff(pp, pppp)",
                    "      );",
                    "    } else {",
                    "      const stringify = (obj) => JSON.stringify(obj, null, 2);",
                    "      const ast = stringify(",
                    "        prettier.__debug.parse(input, opt, /* massage */ true).ast",
                    "      );",
                    "      const past = stringify(",
                    "        prettier.__debug.parse(pp, opt, /* massage */ true).ast",
                    "      );",
                    "",
                    "      /* istanbul ignore next */",
                    "      if (ast !== past) {",
                    "        const MAX_AST_SIZE = 2097152; // 2MB",
                    "        const astDiff =",
                    "          ast.length > MAX_AST_SIZE || past.length > MAX_AST_SIZE",
                    "            ? \"AST diff too large to render\"",
                    "            : diff(ast, past);",
                    "        throw new errors.DebugError(",
                    "          \"ast(input) !== ast(prettier(input))\\n\" +",
                    "            astDiff +",
                    "            \"\\n\" +",
                    "            diff(input, pp)",
                    "        );",
                    "      }",
                    "    }",
                    "    return { formatted: pp, filepath: opt.filepath || \"(stdin)\\n\" };",
                    "  }",
                    "",
                    "  const { performanceTestFlag } = context;",
                    "  if (performanceTestFlag?.debugBenchmark) {",
                    "    let benchmark;",
                    "    try {",
                    "      // eslint-disable-next-line import/no-extraneous-dependencies",
                    "      benchmark = require(\"benchmark\");",
                    "    } catch {",
                    "      context.logger.debug(",
                    "        \"'--debug-benchmark' requires the 'benchmark' package to be installed.\"",
                    "      );",
                    "      process.exit(2);",
                    "    }",
                    "    context.logger.debug(",
                    "      \"'--debug-benchmark' option found, measuring formatWithCursor with 'benchmark' module.\"",
                    "    );",
                    "    const suite = new benchmark.Suite();",
                    "    suite",
                    "      .add(\"format\", () => {",
                    "        prettier.formatWithCursor(input, opt);",
                    "      })",
                    "      .on(\"cycle\", (event) => {",
                    "        const results = {",
                    "          benchmark: String(event.target),",
                    "          hz: event.target.hz,",
                    "          ms: event.target.times.cycle * 1000,",
                    "        };",
                    "        context.logger.debug(",
                    "          \"'--debug-benchmark' measurements for formatWithCursor: \" +",
                    "            JSON.stringify(results, null, 2)",
                    "        );",
                    "      })",
                    "      .run({ async: false });",
                    "  } else if (performanceTestFlag?.debugRepeat) {",
                    "    const repeat = context.argv.debugRepeat;",
                    "    context.logger.debug(",
                    "      \"'--debug-repeat' option found, running formatWithCursor \" +",
                    "        repeat +",
                    "        \" times.\"",
                    "    );",
                    "    let totalMs = 0;",
                    "    for (let i = 0; i < repeat; ++i) {",
                    "      // should be using `performance.now()`, but only `Date` is cross-platform enough",
                    "      const startMs = Date.now();",
                    "      prettier.formatWithCursor(input, opt);",
                    "      totalMs += Date.now() - startMs;",
                    "    }",
                    "    const averageMs = totalMs / repeat;",
                    "    const results = {",
                    "      repeat,",
                    "      hz: 1000 / averageMs,",
                    "      ms: averageMs,",
                    "    };",
                    "    context.logger.debug(",
                    "      \"'--debug-repeat' measurements for formatWithCursor: \" +",
                    "        JSON.stringify(results, null, 2)",
                    "    );",
                    "  }",
                    "",
                    "  return prettier.formatWithCursor(input, opt);",
                    "}",
                    "",
                    "async function createIgnorerFromContextOrDie(context) {",
                    "  try {",
                    "    return await createIgnorer(",
                    "      context.argv.ignorePath,",
                    "      context.argv.withNodeModules",
                    "    );",
                    "  } catch (e) {",
                    "    context.logger.error(e.message);",
                    "    process.exit(2);",
                    "  }",
                    "}",
                    "",
                    "async function formatStdin(context) {",
                    "  const filepath = context.argv.filepath",
                    "    ? path.resolve(process.cwd(), context.argv.filepath)",
                    "    : process.cwd();",
                    "",
                    "  const ignorer = await createIgnorerFromContextOrDie(context);",
                    "  // If there's an ignore-path set, the filename must be relative to the",
                    "  // ignore path, not the current working directory.",
                    "  const relativeFilepath = context.argv.ignorePath",
                    "    ? path.relative(path.dirname(context.argv.ignorePath), filepath)",
                    "    : path.relative(process.cwd(), filepath);",
                    "",
                    "  try {",
                    "    const input = await getStdin();",
                    "",
                    "    if (",
                    "      relativeFilepath &&",
                    "      ignorer.ignores(fixWindowsSlashes(relativeFilepath))",
                    "    ) {",
                    "      writeOutput(context, { formatted: input });",
                    "      return;",
                    "    }",
                    "",
                    "    const options = await getOptionsForFile(context, filepath);",
                    "",
                    "    if (listDifferent(context, input, options, \"(stdin)\")) {",
                    "      return;",
                    "    }",
                    "",
                    "    const formatted = format(context, input, options);",
                    "",
                    "    const { performanceTestFlag } = context;",
                    "    if (performanceTestFlag) {",
                    "      context.logger.log(",
                    "        `'${performanceTestFlag.name}' option found, skipped print code to screen.`",
                    "      );",
                    "      return;",
                    "    }",
                    "",
                    "    writeOutput(context, formatted, options);",
                    "  } catch (error) {",
                    "    handleError(context, relativeFilepath || \"stdin\", error);",
                    "  }",
                    "}",
                    "",
                    "async function formatFiles(context) {",
                    "  // The ignorer will be used to filter file paths after the glob is checked,",
                    "  // before any files are actually written",
                    "  const ignorer = await createIgnorerFromContextOrDie(context);",
                    "",
                    "  let numberOfUnformattedFilesFound = 0;",
                    "  const { performanceTestFlag } = context;",
                    "",
                    "  if (context.argv.check && !performanceTestFlag) {",
                    "    context.logger.log(\"Checking formatting...\");",
                    "  }",
                    "",
                    "  let formatResultsCache;",
                    "  const cacheFilePath = await findCacheFile(context.argv.cacheLocation);",
                    "  if (context.argv.cache) {",
                    "    formatResultsCache = new FormatResultsCache(",
                    "      cacheFilePath,",
                    "      context.argv.cacheStrategy || \"content\"",
                    "    );",
                    "  } else {",
                    "    if (context.argv.cacheStrategy) {",
                    "      context.logger.error(",
                    "        \"`--cache-strategy` cannot be used without `--cache`.\"",
                    "      );",
                    "      process.exit(2);",
                    "    }",
                    "    if (!context.argv.cacheLocation) {",
                    "      const stat = await statSafe(cacheFilePath);",
                    "      if (stat) {",
                    "        await fs.unlink(cacheFilePath);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  for await (const pathOrError of expandPatterns(context)) {",
                    "    if (typeof pathOrError === \"object\") {",
                    "      context.logger.error(pathOrError.error);",
                    "      // Don't exit, but set the exit code to 2",
                    "      process.exitCode = 2;",
                    "      continue;",
                    "    }",
                    "",
                    "    const filename = pathOrError;",
                    "    // If there's an ignore-path set, the filename must be relative to the",
                    "    // ignore path, not the current working directory.",
                    "    const ignoreFilename = context.argv.ignorePath",
                    "      ? path.relative(path.dirname(context.argv.ignorePath), filename)",
                    "      : filename;",
                    "",
                    "    const fileIgnored = ignorer.ignores(fixWindowsSlashes(ignoreFilename));",
                    "    if (",
                    "      fileIgnored &&",
                    "      (context.argv.debugCheck ||",
                    "        context.argv.write ||",
                    "        context.argv.check ||",
                    "        context.argv.listDifferent)",
                    "    ) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const options = {",
                    "      ...(await getOptionsForFile(context, filename)),",
                    "      filepath: filename,",
                    "    };",
                    "",
                    "    let printedFilename;",
                    "    if (isTTY()) {",
                    "      printedFilename = context.logger.log(filename, {",
                    "        newline: false,",
                    "        clearable: true,",
                    "      });",
                    "    }",
                    "",
                    "    let input;",
                    "    try {",
                    "      input = await fs.readFile(filename, \"utf8\");",
                    "    } catch (error) {",
                    "      // Add newline to split errors from filename line.",
                    "      /* istanbul ignore next */",
                    "      context.logger.log(\"\");",
                    "",
                    "      /* istanbul ignore next */",
                    "      context.logger.error(",
                    "        `Unable to read file: ${filename}\\n${error.message}`",
                    "      );",
                    "",
                    "      // Don't exit the process if one file failed",
                    "      /* istanbul ignore next */",
                    "      process.exitCode = 2;",
                    "",
                    "      /* istanbul ignore next */",
                    "      continue;",
                    "    }",
                    "",
                    "    if (fileIgnored) {",
                    "      writeOutput(context, { formatted: input }, options);",
                    "      continue;",
                    "    }",
                    "",
                    "    const start = Date.now();",
                    "",
                    "    const isCacheExists = formatResultsCache?.existsAvailableFormatResultsCache(",
                    "      filename,",
                    "      options",
                    "    );",
                    "",
                    "    let result;",
                    "    let output;",
                    "",
                    "    try {",
                    "      if (isCacheExists) {",
                    "        result = { formatted: input };",
                    "      } else {",
                    "        result = format(context, input, options);",
                    "      }",
                    "      output = result.formatted;",
                    "    } catch (error) {",
                    "      handleError(context, filename, error, printedFilename);",
                    "      continue;",
                    "    }",
                    "",
                    "    const isDifferent = output !== input;",
                    "    let shouldSetCache = !isDifferent;",
                    "",
                    "    if (printedFilename) {",
                    "      // Remove previously printed filename to log it with duration.",
                    "      printedFilename.clear();",
                    "    }",
                    "",
                    "    if (performanceTestFlag) {",
                    "      context.logger.log(",
                    "        `'${performanceTestFlag.name}' option found, skipped print code or write files.`",
                    "      );",
                    "      return;",
                    "    }",
                    "",
                    "    if (context.argv.write) {",
                    "      // Don't write the file if it won't change in order not to invalidate",
                    "      // mtime based caches.",
                    "      if (isDifferent) {",
                    "        if (!context.argv.check && !context.argv.listDifferent) {",
                    "          context.logger.log(`${filename} ${Date.now() - start}ms`);",
                    "        }",
                    "",
                    "        try {",
                    "          await fs.writeFile(filename, output, \"utf8\");",
                    "",
                    "          // Set cache if format succeeds",
                    "          shouldSetCache = true;",
                    "        } catch (error) {",
                    "          context.logger.error(",
                    "            `Unable to write file: ${filename}\\n${error.message}`",
                    "          );",
                    "",
                    "          // Don't exit the process if one file failed",
                    "          process.exitCode = 2;",
                    "        }",
                    "      } else if (!context.argv.check && !context.argv.listDifferent) {",
                    "        const message = `${chalk.grey(filename)} ${Date.now() - start}ms`;",
                    "        if (isCacheExists) {",
                    "          context.logger.log(`${message} (cached)`);",
                    "        } else {",
                    "          context.logger.log(message);",
                    "        }",
                    "      }",
                    "    } else if (context.argv.debugCheck) {",
                    "      /* istanbul ignore else */",
                    "      if (result.filepath) {",
                    "        context.logger.log(result.filepath);",
                    "      } else {",
                    "        process.exitCode = 2;",
                    "      }",
                    "    } else if (!context.argv.check && !context.argv.listDifferent) {",
                    "      writeOutput(context, result, options);",
                    "    }",
                    "",
                    "    if (shouldSetCache) {",
                    "      formatResultsCache?.setFormatResultsCache(filename, options);",
                    "    } else {",
                    "      formatResultsCache?.removeFormatResultsCache(filename);",
                    "    }",
                    "",
                    "    if (isDifferent) {",
                    "      if (context.argv.check) {",
                    "        context.logger.warn(filename);",
                    "      } else if (context.argv.listDifferent) {",
                    "        context.logger.log(filename);",
                    "      }",
                    "      numberOfUnformattedFilesFound += 1;",
                    "    }",
                    "  }",
                    "",
                    "  formatResultsCache?.reconcile();",
                    "",
                    "  // Print check summary based on expected exit code",
                    "  if (context.argv.check) {",
                    "    if (numberOfUnformattedFilesFound === 0) {",
                    "      context.logger.log(\"All matched files use Prettier code style!\");",
                    "    } else if (numberOfUnformattedFilesFound === 1) {",
                    "      context.logger.warn(",
                    "        context.argv.write",
                    "          ? \"Code style issues fixed in the above file.\"",
                    "          : \"Code style issues found in the above file. Forgot to run Prettier?\"",
                    "      );",
                    "    } else {",
                    "      context.logger.warn(",
                    "        context.argv.write",
                    "          ? \"Code style issues found in \" +",
                    "              numberOfUnformattedFilesFound +",
                    "              \" files.\"",
                    "          : \"Code style issues found in \" +",
                    "              numberOfUnformattedFilesFound +",
                    "              \" files. Forgot to run Prettier?\"",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  // Ensure non-zero exitCode when using --check/list-different is not combined with --write",
                    "  if (",
                    "    (context.argv.check || context.argv.listDifferent) &&",
                    "    numberOfUnformattedFilesFound > 0 &&",
                    "    !process.exitCode &&",
                    "    !context.argv.write",
                    "  ) {",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "module.exports = { formatStdin, formatFiles };"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const stringify = require(\"fast-json-stable-stringify\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index.js\");",
                    "const createLogger = require(\"./logger.js\");",
                    "const Context = require(\"./context.js\");",
                    "const { parseArgvWithoutPlugins } = require(\"./options/parse-cli-arguments.js\");",
                    "const { createDetailedUsage, createUsage } = require(\"./usage.js\");",
                    "const { formatStdin, formatFiles } = require(\"./format.js\");",
                    "const logFileInfoOrDie = require(\"./file-info.js\");",
                    "const logResolvedConfigPathOrDie = require(\"./find-config-path.js\");",
                    "const {",
                    "  utils: { isNonEmptyArray },",
                    "} = require(\"./prettier-internal.js\");",
                    "const { printToScreen } = require(\"./utils.js\");",
                    "",
                    "async function run(rawArguments) {",
                    "  // Create a default level logger, so we can log errors during `logLevel` parsing",
                    "  let logger = createLogger();",
                    "",
                    "  try {",
                    "    const logLevel = parseArgvWithoutPlugins(",
                    "      rawArguments,",
                    "      logger,",
                    "      \"loglevel\"",
                    "    ).loglevel;",
                    "    if (logLevel !== logger.logLevel) {",
                    "      logger = createLogger(logLevel);",
                    "    }",
                    "    const context = new Context({ rawArguments, logger });",
                    "    if (logger.logLevel !== \"debug\" && context.performanceTestFlag) {",
                    "      context.logger = createLogger(\"debug\");",
                    "    }",
                    "",
                    "    await main(context);",
                    "  } catch (error) {",
                    "    logger.error(error.message);",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "async function main(context) {",
                    "  context.logger.debug(`normalized argv: ${JSON.stringify(context.argv)}`);",
                    "",
                    "  if (context.argv.pluginSearch === false) {",
                    "    const rawPluginSearchDirs = context.argv.__raw[\"plugin-search-dir\"];",
                    "    if (",
                    "      typeof rawPluginSearchDirs === \"string\" ||",
                    "      isNonEmptyArray(rawPluginSearchDirs)",
                    "    ) {",
                    "      throw new Error(",
                    "        \"Cannot use --no-plugin-search and --plugin-search-dir together.\"",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (context.argv.check && context.argv.listDifferent) {",
                    "    throw new Error(\"Cannot use --check and --list-different together.\");",
                    "  }",
                    "",
                    "  if (context.argv.write && context.argv.debugCheck) {",
                    "    throw new Error(\"Cannot use --write and --debug-check together.\");",
                    "  }",
                    "",
                    "  if (context.argv.findConfigPath && context.filePatterns.length > 0) {",
                    "    throw new Error(\"Cannot use --find-config-path with multiple files\");",
                    "  }",
                    "",
                    "  if (context.argv.fileInfo && context.filePatterns.length > 0) {",
                    "    throw new Error(\"Cannot use --file-info with multiple files\");",
                    "  }",
                    "",
                    "  if (context.argv.version) {",
                    "    printToScreen(prettier.version);",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.help !== undefined) {",
                    "    printToScreen(",
                    "      typeof context.argv.help === \"string\" && context.argv.help !== \"\"",
                    "        ? createDetailedUsage(context, context.argv.help)",
                    "        : createUsage(context)",
                    "    );",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.supportInfo) {",
                    "    printToScreen(",
                    "      prettier.format(stringify(prettier.getSupportInfo()), {",
                    "        parser: \"json\",",
                    "      })",
                    "    );",
                    "    return;",
                    "  }",
                    "",
                    "  const hasFilePatterns = context.filePatterns.length > 0;",
                    "  const useStdin =",
                    "    !hasFilePatterns && (!process.stdin.isTTY || context.argv.filePath);",
                    "",
                    "  if (context.argv.findConfigPath) {",
                    "    await logResolvedConfigPathOrDie(context);",
                    "  } else if (context.argv.fileInfo) {",
                    "    await logFileInfoOrDie(context);",
                    "  } else if (useStdin) {",
                    "    if (context.argv.cache) {",
                    "      context.logger.error(\"`--cache` cannot be used with stdin.\");",
                    "      process.exit(2);",
                    "    }",
                    "    await formatStdin(context);",
                    "  } else if (hasFilePatterns) {",
                    "    await formatFiles(context);",
                    "  } else {",
                    "    process.exitCode = 1;",
                    "    printToScreen(createUsage(context));",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  run,",
                    "};"
                ]
            },
            "is-tty.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { isCI } = require(\"../common/third-party.js\");",
                    "",
                    "// Some CI pipelines incorrectly report process.stdout.isTTY status,",
                    "// which causes unwanted lines in the output. An additional check for isCI() helps.",
                    "// See https://github.com/prettier/prettier/issues/5801",
                    "module.exports = function isTTY() {",
                    "  return process.stdout.isTTY && !isCI();",
                    "};"
                ]
            },
            "logger.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const readline = require(\"readline\");",
                    "const wcwidth = require(\"wcwidth\");",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { default: stripAnsi } = require(\"../../vendors/strip-ansi.js\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { default: chalk, chalkStderr } = require(\"../../vendors/chalk.js\");",
                    "",
                    "const countLines = (stream, text) => {",
                    "  const columns = stream.columns || 80;",
                    "  let lineCount = 0;",
                    "  for (const line of stripAnsi(text).split(\"\\n\")) {",
                    "    lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));",
                    "  }",
                    "  return lineCount;",
                    "};",
                    "",
                    "const clear = (stream, text) => () => {",
                    "  const lineCount = countLines(stream, text);",
                    "",
                    "  for (let line = 0; line < lineCount; line++) {",
                    "    if (line > 0) {",
                    "      readline.moveCursor(stream, 0, -1);",
                    "    }",
                    "",
                    "    readline.clearLine(stream, 0);",
                    "    readline.cursorTo(stream, 0);",
                    "  }",
                    "};",
                    "",
                    "const emptyLogResult = { clear() {} };",
                    "function createLogger(logLevel = \"log\") {",
                    "  return {",
                    "    logLevel,",
                    "    warn: createLogFunc(\"warn\", \"yellow\"),",
                    "    error: createLogFunc(\"error\", \"red\"),",
                    "    debug: createLogFunc(\"debug\", \"blue\"),",
                    "    log: createLogFunc(\"log\"),",
                    "  };",
                    "",
                    "  function createLogFunc(loggerName, color) {",
                    "    if (!shouldLog(loggerName)) {",
                    "      return () => emptyLogResult;",
                    "    }",
                    "",
                    "    const stream = process[loggerName === \"log\" ? \"stdout\" : \"stderr\"];",
                    "    const chalkInstance = loggerName === \"log\" ? chalk : chalkStderr;",
                    "    const prefix = color ? `[${chalkInstance[color](loggerName)}] ` : \"\";",
                    "",
                    "    return (message, options) => {",
                    "      options = {",
                    "        newline: true,",
                    "        clearable: false,",
                    "        ...options,",
                    "      };",
                    "      message = message.replace(/^/gm, prefix) + (options.newline ? \"\\n\" : \"\");",
                    "      stream.write(message);",
                    "",
                    "      if (options.clearable) {",
                    "        return {",
                    "          clear: clear(stream, message),",
                    "        };",
                    "      }",
                    "    };",
                    "  }",
                    "",
                    "  function shouldLog(loggerName) {",
                    "    switch (logLevel) {",
                    "      case \"silent\":",
                    "        return false;",
                    "      case \"debug\":",
                    "        if (loggerName === \"debug\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"log\":",
                    "        if (loggerName === \"log\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"warn\":",
                    "        if (loggerName === \"warn\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"error\":",
                    "        return loggerName === \"error\";",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = createLogger;"
                ]
            },
            "prettier-internal.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "module.exports = require(\"../index.js\").__internal;"
                ]
            },
            "usage.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const camelCase = require(\"camelcase\");",
                    "const constant = require(\"./constant.js\");",
                    "const { groupBy } = require(\"./utils.js\");",
                    "",
                    "const OPTION_USAGE_THRESHOLD = 25;",
                    "const CHOICE_USAGE_MARGIN = 3;",
                    "const CHOICE_USAGE_INDENTATION = 2;",
                    "",
                    "function indent(str, spaces) {",
                    "  return str.replace(/^/gm, \" \".repeat(spaces));",
                    "}",
                    "",
                    "function createDefaultValueDisplay(value) {",
                    "  return Array.isArray(value)",
                    "    ? `[${value.map(createDefaultValueDisplay).join(\", \")}]`",
                    "    : value;",
                    "}",
                    "",
                    "function getOptionDefaultValue(context, optionName) {",
                    "  // --no-option",
                    "  if (!(optionName in context.detailedOptionMap)) {",
                    "    return;",
                    "  }",
                    "",
                    "  const option = context.detailedOptionMap[optionName];",
                    "",
                    "  if (option.default !== undefined) {",
                    "    return option.default;",
                    "  }",
                    "",
                    "  const optionCamelName = camelCase(optionName);",
                    "  if (optionCamelName in context.apiDefaultOptions) {",
                    "    return context.apiDefaultOptions[optionCamelName];",
                    "  }",
                    "}",
                    "",
                    "function createOptionUsageHeader(option) {",
                    "  const name = `--${option.name}`;",
                    "  const alias = option.alias ? `-${option.alias},` : null;",
                    "  const type = createOptionUsageType(option);",
                    "  return [alias, name, type].filter(Boolean).join(\" \");",
                    "}",
                    "",
                    "function createOptionUsageRow(header, content, threshold) {",
                    "  const separator =",
                    "    header.length >= threshold",
                    "      ? `\\n${\" \".repeat(threshold)}`",
                    "      : \" \".repeat(threshold - header.length);",
                    "",
                    "  const description = content.replace(/\\n/g, `\\n${\" \".repeat(threshold)}`);",
                    "",
                    "  return `${header}${separator}${description}`;",
                    "}",
                    "",
                    "function createOptionUsageType(option) {",
                    "  switch (option.type) {",
                    "    case \"boolean\":",
                    "      return null;",
                    "    case \"choice\":",
                    "      return `<${option.choices",
                    "        .filter((choice) => !choice.deprecated && choice.since !== null)",
                    "        .map((choice) => choice.value)",
                    "        .join(\"|\")}>`;",
                    "    default:",
                    "      return `<${option.type}>`;",
                    "  }",
                    "}",
                    "",
                    "function createChoiceUsages(choices, margin, indentation) {",
                    "  const activeChoices = choices.filter(",
                    "    (choice) => !choice.deprecated && choice.since !== null",
                    "  );",
                    "  const threshold =",
                    "    Math.max(0, ...activeChoices.map((choice) => choice.value.length)) + margin;",
                    "  return activeChoices.map((choice) =>",
                    "    indent(",
                    "      createOptionUsageRow(choice.value, choice.description, threshold),",
                    "      indentation",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function createOptionUsage(context, option, threshold) {",
                    "  const header = createOptionUsageHeader(option);",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  return createOptionUsageRow(",
                    "    header,",
                    "    `${option.description}${",
                    "      optionDefaultValue === undefined",
                    "        ? \"\"",
                    "        : `\\nDefaults to ${createDefaultValueDisplay(optionDefaultValue)}.`",
                    "    }`,",
                    "    threshold",
                    "  );",
                    "}",
                    "",
                    "function getOptionsWithOpposites(options) {",
                    "  // Add --no-foo after --foo.",
                    "  const optionsWithOpposites = options.map((option) => [",
                    "    option.description ? option : null,",
                    "    option.oppositeDescription",
                    "      ? {",
                    "          ...option,",
                    "          name: `no-${option.name}`,",
                    "          type: \"boolean\",",
                    "          description: option.oppositeDescription,",
                    "        }",
                    "      : null,",
                    "  ]);",
                    "  return optionsWithOpposites.flat().filter(Boolean);",
                    "}",
                    "",
                    "function createUsage(context) {",
                    "  const options = getOptionsWithOpposites(context.detailedOptions).filter(",
                    "    // remove unnecessary option (e.g. `semi`, `color`, etc.), which is only used for --help <flag>",
                    "    (option) =>",
                    "      !(",
                    "        option.type === \"boolean\" &&",
                    "        option.oppositeDescription &&",
                    "        !option.name.startsWith(\"no-\")",
                    "      )",
                    "  );",
                    "",
                    "  const groupedOptions = groupBy(options, (option) => option.category);",
                    "",
                    "  const firstCategories = constant.categoryOrder.slice(0, -1);",
                    "  const lastCategories = constant.categoryOrder.slice(-1);",
                    "  const restCategories = Object.keys(groupedOptions).filter(",
                    "    (category) => !constant.categoryOrder.includes(category)",
                    "  );",
                    "  const allCategories = [",
                    "    ...firstCategories,",
                    "    ...restCategories,",
                    "    ...lastCategories,",
                    "  ];",
                    "",
                    "  const optionsUsage = allCategories.map((category) => {",
                    "    const categoryOptions = groupedOptions[category]",
                    "      .map((option) =>",
                    "        createOptionUsage(context, option, OPTION_USAGE_THRESHOLD)",
                    "      )",
                    "      .join(\"\\n\");",
                    "    return `${category} options:\\n\\n${indent(categoryOptions, 2)}`;",
                    "  });",
                    "",
                    "  return [constant.usageSummary, ...optionsUsage, \"\"].join(\"\\n\\n\");",
                    "}",
                    "",
                    "function createDetailedUsage(context, flag) {",
                    "  const option = getOptionsWithOpposites(context.detailedOptions).find(",
                    "    (option) => option.name === flag || option.alias === flag",
                    "  );",
                    "",
                    "  const header = createOptionUsageHeader(option);",
                    "  const description = `\\n\\n${indent(option.description, 2)}`;",
                    "",
                    "  const choices =",
                    "    option.type !== \"choice\"",
                    "      ? \"\"",
                    "      : `\\n\\nValid options:\\n\\n${createChoiceUsages(",
                    "          option.choices,",
                    "          CHOICE_USAGE_MARGIN,",
                    "          CHOICE_USAGE_INDENTATION",
                    "        ).join(\"\\n\")}`;",
                    "",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  const defaults =",
                    "    optionDefaultValue !== undefined",
                    "      ? `\\n\\nDefault: ${createDefaultValueDisplay(optionDefaultValue)}`",
                    "      : \"\";",
                    "",
                    "  const pluginDefaults =",
                    "    option.pluginDefaults && Object.keys(option.pluginDefaults).length > 0",
                    "      ? `\\nPlugin defaults:${Object.entries(option.pluginDefaults).map(",
                    "          ([key, value]) => `\\n* ${key}: ${createDefaultValueDisplay(value)}`",
                    "        )}`",
                    "      : \"\";",
                    "  return `${header}${description}${choices}${defaults}${pluginDefaults}`;",
                    "}",
                    "",
                    "module.exports = {",
                    "  createUsage,",
                    "  createDetailedUsage,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { promises: fs } = require(\"fs\");",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { default: sdbm } = require(\"../../vendors/sdbm.js\");",
                    "",
                    "// eslint-disable-next-line no-console",
                    "const printToScreen = console.log.bind(console);",
                    "",
                    "/**",
                    " * @template Obj",
                    " * @template Key",
                    " * @param {Array<Obj>} array",
                    " * @param {(value: Obj) => Key} iteratee",
                    " * @returns {{[p in Key]: T}}",
                    " */",
                    "function groupBy(array, iteratee) {",
                    "  const result = Object.create(null);",
                    "",
                    "  for (const value of array) {",
                    "    const key = iteratee(value);",
                    "",
                    "    if (Array.isArray(result[key])) {",
                    "      result[key].push(value);",
                    "    } else {",
                    "      result[key] = [value];",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "/**",
                    " * @template Obj",
                    " * @template {keyof Obj} Keys",
                    " * @param {Obj} object",
                    " * @param {Array<Keys>} keys",
                    " * @returns {{[key in Keys]: Obj[key]}}",
                    " */",
                    "function pick(object, keys) {",
                    "  const entries = keys.map((key) => [key, object[key]]);",
                    "  return Object.fromEntries(entries);",
                    "}",
                    "",
                    "/**",
                    " * @param {string} source",
                    " * @returns {string}",
                    " */",
                    "function createHash(source) {",
                    "  return String(sdbm(source));",
                    "}",
                    "",
                    "/**",
                    " * Get stats of a given path.",
                    " * @param {string} filePath The path to target file.",
                    " * @returns {Promise<import('fs').Stats | undefined>} The stats.",
                    " */",
                    "async function statSafe(filePath) {",
                    "  try {",
                    "    return await fs.stat(filePath);",
                    "  } catch (error) {",
                    "    /* istanbul ignore next */",
                    "    if (error.code !== \"ENOENT\") {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @returns {boolean}",
                    " */",
                    "function isJson(value) {",
                    "  try {",
                    "    JSON.parse(value);",
                    "    return true;",
                    "  } catch {",
                    "    return false;",
                    "  }",
                    "}",
                    "",
                    "module.exports = { printToScreen, groupBy, pick, createHash, statSafe, isJson };"
                ]
            },
            "options": {
                "create-minimist-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  utils: { partition },",
                        "} = require(\"../prettier-internal.js\");",
                        "",
                        "module.exports = function createMinimistOptions(detailedOptions) {",
                        "  const [boolean, string] = partition(",
                        "    detailedOptions,",
                        "    ({ type }) => type === \"boolean\"",
                        "  ).map((detailedOptions) =>",
                        "    detailedOptions.flatMap(({ name, alias }) =>",
                        "      alias ? [name, alias] : [name]",
                        "    )",
                        "  );",
                        "",
                        "  const defaults = Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(",
                        "        (option) =>",
                        "          !option.deprecated &&",
                        "          (!option.forwardToApi ||",
                        "            option.name === \"plugin\" ||",
                        "            option.name === \"plugin-search-dir\") &&",
                        "          option.default !== undefined",
                        "      )",
                        "      .map((option) => [option.name, option.default])",
                        "  );",
                        "",
                        "  return {",
                        "    // we use vnopts' AliasSchema to handle aliases for better error messages",
                        "    alias: {},",
                        "    boolean,",
                        "    string,",
                        "    default: defaults,",
                        "  };",
                        "};"
                    ]
                },
                "get-context-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "// eslint-disable-next-line no-restricted-modules",
                        "const prettier = require(\"../../index.js\");",
                        "const {",
                        "  optionsModule,",
                        "  utils: { arrayify },",
                        "} = require(\"../prettier-internal.js\");",
                        "const constant = require(\"../constant.js\");",
                        "const {",
                        "  normalizeDetailedOptionMap,",
                        "  createDetailedOptionMap,",
                        "} = require(\"./option-map.js\");",
                        "",
                        "function getContextOptions(plugins, pluginSearchDirs) {",
                        "  const { options: supportOptions, languages } = prettier.getSupportInfo({",
                        "    showDeprecated: true,",
                        "    showUnreleased: true,",
                        "    showInternal: true,",
                        "    plugins,",
                        "    pluginSearchDirs,",
                        "  });",
                        "  const detailedOptionMap = normalizeDetailedOptionMap({",
                        "    ...createDetailedOptionMap(supportOptions),",
                        "    ...constant.options,",
                        "  });",
                        "",
                        "  const detailedOptions = arrayify(detailedOptionMap, \"name\");",
                        "",
                        "  const apiDefaultOptions = {",
                        "    ...optionsModule.hiddenDefaults,",
                        "    ...Object.fromEntries(",
                        "      supportOptions",
                        "        .filter(({ deprecated }) => !deprecated)",
                        "        .map((option) => [option.name, option.default])",
                        "    ),",
                        "  };",
                        "",
                        "  return {",
                        "    supportOptions,",
                        "    detailedOptions,",
                        "    detailedOptionMap,",
                        "    apiDefaultOptions,",
                        "    languages,",
                        "  };",
                        "}",
                        "",
                        "module.exports = getContextOptions;"
                    ]
                },
                "get-options-for-file.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const dashify = require(\"dashify\");",
                        "// eslint-disable-next-line no-restricted-modules",
                        "const prettier = require(\"../../index.js\");",
                        "const { optionsNormalizer } = require(\"../prettier-internal.js\");",
                        "const minimist = require(\"./minimist.js\");",
                        "const createMinimistOptions = require(\"./create-minimist-options.js\");",
                        "const normalizeCliOptions = require(\"./normalize-cli-options.js\");",
                        "",
                        "function getOptions(argv, detailedOptions) {",
                        "  return Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(({ forwardToApi }) => forwardToApi)",
                        "      .map(({ forwardToApi, name }) => [forwardToApi, argv[name]])",
                        "  );",
                        "}",
                        "",
                        "function cliifyOptions(object, apiDetailedOptionMap) {",
                        "  return Object.fromEntries(",
                        "    Object.entries(object || {}).map(([key, value]) => {",
                        "      const apiOption = apiDetailedOptionMap[key];",
                        "      const cliKey = apiOption ? apiOption.name : key;",
                        "",
                        "      return [dashify(cliKey), value];",
                        "    })",
                        "  );",
                        "}",
                        "",
                        "function createApiDetailedOptionMap(detailedOptions) {",
                        "  return Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(",
                        "        (option) => option.forwardToApi && option.forwardToApi !== option.name",
                        "      )",
                        "      .map((option) => [option.forwardToApi, option])",
                        "  );",
                        "}",
                        "",
                        "function parseArgsToOptions(context, overrideDefaults) {",
                        "  const minimistOptions = createMinimistOptions(context.detailedOptions);",
                        "  const apiDetailedOptionMap = createApiDetailedOptionMap(",
                        "    context.detailedOptions",
                        "  );",
                        "  return getOptions(",
                        "    normalizeCliOptions(",
                        "      minimist(context.rawArguments, {",
                        "        string: minimistOptions.string,",
                        "        boolean: minimistOptions.boolean,",
                        "        default: cliifyOptions(overrideDefaults, apiDetailedOptionMap),",
                        "      }),",
                        "      context.detailedOptions,",
                        "      { logger: false }",
                        "    ),",
                        "    context.detailedOptions",
                        "  );",
                        "}",
                        "",
                        "async function getOptionsOrDie(context, filePath) {",
                        "  try {",
                        "    if (context.argv.config === false) {",
                        "      context.logger.debug(",
                        "        \"'--no-config' option found, skip loading config file.\"",
                        "      );",
                        "      return null;",
                        "    }",
                        "",
                        "    context.logger.debug(",
                        "      context.argv.config",
                        "        ? `load config file from '${context.argv.config}'`",
                        "        : `resolve config from '${filePath}'`",
                        "    );",
                        "",
                        "    const options = await prettier.resolveConfig(filePath, {",
                        "      editorconfig: context.argv.editorconfig,",
                        "      config: context.argv.config,",
                        "    });",
                        "",
                        "    context.logger.debug(\"loaded options `\" + JSON.stringify(options) + \"`\");",
                        "    return options;",
                        "  } catch (error) {",
                        "    context.logger.error(",
                        "      `Invalid configuration file \\`${filePath}\\`: ` + error.message",
                        "    );",
                        "    process.exit(2);",
                        "  }",
                        "}",
                        "",
                        "function applyConfigPrecedence(context, options) {",
                        "  try {",
                        "    switch (context.argv.configPrecedence) {",
                        "      case \"cli-override\":",
                        "        return parseArgsToOptions(context, options);",
                        "      case \"file-override\":",
                        "        return { ...parseArgsToOptions(context), ...options };",
                        "      case \"prefer-file\":",
                        "        return options || parseArgsToOptions(context);",
                        "    }",
                        "  } catch (error) {",
                        "    /* istanbul ignore next */",
                        "    context.logger.error(error.toString());",
                        "",
                        "    /* istanbul ignore next */",
                        "    process.exit(2);",
                        "  }",
                        "}",
                        "",
                        "async function getOptionsForFile(context, filepath) {",
                        "  const options = await getOptionsOrDie(context, filepath);",
                        "",
                        "  const hasPlugins = options && options.plugins;",
                        "  if (hasPlugins) {",
                        "    context.pushContextPlugins(options.plugins);",
                        "  }",
                        "",
                        "  const appliedOptions = {",
                        "    filepath,",
                        "    ...applyConfigPrecedence(",
                        "      context,",
                        "      options &&",
                        "        optionsNormalizer.normalizeApiOptions(options, context.supportOptions, {",
                        "          logger: context.logger,",
                        "        })",
                        "    ),",
                        "  };",
                        "",
                        "  context.logger.debug(",
                        "    `applied config-precedence (${context.argv.configPrecedence}): ` +",
                        "      `${JSON.stringify(appliedOptions)}`",
                        "  );",
                        "",
                        "  if (hasPlugins) {",
                        "    context.popContextPlugins();",
                        "  }",
                        "",
                        "  return appliedOptions;",
                        "}",
                        "",
                        "module.exports = getOptionsForFile;"
                    ]
                },
                "minimist.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const minimist = require(\"minimist\");",
                        "",
                        "const PLACEHOLDER = null;",
                        "",
                        "/**",
                        " * unspecified boolean flag without default value is parsed as `undefined` instead of `false`",
                        " */",
                        "module.exports = function (args, options) {",
                        "  const boolean = options.boolean || [];",
                        "  const defaults = options.default || {};",
                        "",
                        "  const booleanWithoutDefault = boolean.filter((key) => !(key in defaults));",
                        "  const newDefaults = {",
                        "    ...defaults,",
                        "    ...Object.fromEntries(",
                        "      booleanWithoutDefault.map((key) => [key, PLACEHOLDER])",
                        "    ),",
                        "  };",
                        "",
                        "  const parsed = minimist(args, { ...options, default: newDefaults });",
                        "",
                        "  return Object.fromEntries(",
                        "    Object.entries(parsed).filter(([, value]) => value !== PLACEHOLDER)",
                        "  );",
                        "};"
                    ]
                },
                "normalize-cli-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "// eslint-disable-next-line no-restricted-modules",
                        "const { default: chalk } = require(\"../../../vendors/chalk.js\");",
                        "// eslint-disable-next-line no-restricted-modules",
                        "const { default: leven } = require(\"../../../vendors/leven.js\");",
                        "const { optionsNormalizer } = require(\"../prettier-internal.js\");",
                        "",
                        "function normalizeCliOptions(options, optionInfos, opts) {",
                        "  return optionsNormalizer.normalizeCliOptions(options, optionInfos, {",
                        "    colorsModule: chalk,",
                        "    levenshteinDistance: leven,",
                        "    ...opts,",
                        "  });",
                        "}",
                        "",
                        "module.exports = normalizeCliOptions;"
                    ]
                },
                "option-map.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const dashify = require(\"dashify\");",
                        "const { coreOptions } = require(\"../prettier-internal.js\");",
                        "",
                        "function normalizeDetailedOption(name, option) {",
                        "  return {",
                        "    category: coreOptions.CATEGORY_OTHER,",
                        "    ...option,",
                        "    choices:",
                        "      option.choices &&",
                        "      option.choices.map((choice) => {",
                        "        const newChoice = {",
                        "          description: \"\",",
                        "          deprecated: false,",
                        "          ...(typeof choice === \"object\" ? choice : { value: choice }),",
                        "        };",
                        "        /* istanbul ignore next */",
                        "        if (newChoice.value === true) {",
                        "          newChoice.value = \"\"; // backward compatibility for original boolean option",
                        "        }",
                        "        return newChoice;",
                        "      }),",
                        "  };",
                        "}",
                        "",
                        "function normalizeDetailedOptionMap(detailedOptionMap) {",
                        "  return Object.fromEntries(",
                        "    Object.entries(detailedOptionMap)",
                        "      .sort(([leftName], [rightName]) => leftName.localeCompare(rightName))",
                        "      .map(([name, option]) => [name, normalizeDetailedOption(name, option)])",
                        "  );",
                        "}",
                        "",
                        "function createDetailedOptionMap(supportOptions) {",
                        "  return Object.fromEntries(",
                        "    supportOptions.map((option) => {",
                        "      const newOption = {",
                        "        ...option,",
                        "        name: option.cliName || dashify(option.name),",
                        "        description: option.cliDescription || option.description,",
                        "        category: option.cliCategory || coreOptions.CATEGORY_FORMAT,",
                        "        forwardToApi: option.name,",
                        "      };",
                        "",
                        "      /* istanbul ignore next */",
                        "      if (option.deprecated) {",
                        "        delete newOption.forwardToApi;",
                        "        delete newOption.description;",
                        "        delete newOption.oppositeDescription;",
                        "        newOption.deprecated = true;",
                        "      }",
                        "",
                        "      return [newOption.name, newOption];",
                        "    })",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  normalizeDetailedOptionMap,",
                        "  createDetailedOptionMap,",
                        "};"
                    ]
                },
                "parse-cli-arguments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "const camelCase = require(\"camelcase\");",
                        "const { pick } = require(\"../utils.js\");",
                        "const getContextOptions = require(\"./get-context-options.js\");",
                        "const minimist = require(\"./minimist.js\");",
                        "const createMinimistOptions = require(\"./create-minimist-options.js\");",
                        "const normalizeCliOptions = require(\"./normalize-cli-options.js\");",
                        "",
                        "function parseArgv(rawArguments, detailedOptions, logger, keys) {",
                        "  const minimistOptions = createMinimistOptions(detailedOptions);",
                        "  let argv = minimist(rawArguments, minimistOptions);",
                        "",
                        "  if (keys) {",
                        "    if (keys.includes(\"plugin-search-dir\") && !keys.includes(\"plugin-search\")) {",
                        "      keys.push(\"plugin-search\");",
                        "    }",
                        "",
                        "    detailedOptions = detailedOptions.filter((option) =>",
                        "      keys.includes(option.name)",
                        "    );",
                        "    argv = pick(argv, keys);",
                        "  }",
                        "",
                        "  const normalized = normalizeCliOptions(argv, detailedOptions, { logger });",
                        "",
                        "  return {",
                        "    ...Object.fromEntries(",
                        "      Object.entries(normalized).map(([key, value]) => {",
                        "        const option = detailedOptions.find(({ name }) => name === key) || {};",
                        "        // If the flag is a prettier option, use the option name",
                        "        // `--plugin-search-dir` -> `pluginSearchDirs`",
                        "        // Otherwise use camel case for readability",
                        "        // `--ignore-unknown` -> `ignoreUnknown`",
                        "        return [option.forwardToApi || camelCase(key), value];",
                        "      })",
                        "    ),",
                        "    get __raw() {",
                        "      return argv;",
                        "    },",
                        "  };",
                        "}",
                        "",
                        "const detailedOptionsWithoutPlugins = getContextOptions(",
                        "  [],",
                        "  false",
                        ").detailedOptions;",
                        "function parseArgvWithoutPlugins(rawArguments, logger, keys) {",
                        "  return parseArgv(",
                        "    rawArguments,",
                        "    detailedOptionsWithoutPlugins,",
                        "    logger,",
                        "    typeof keys === \"string\" ? [keys] : keys",
                        "  );",
                        "}",
                        "",
                        "module.exports = { parseArgv, parseArgvWithoutPlugins };"
                    ]
                }
            }
        },
        "common": {
            "ast-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "",
                    "function getNodeHelper(path, count) {",
                    "  const stackIndex = getNodeStackIndexHelper(path.stack, count);",
                    "  return stackIndex === -1 ? null : path.stack[stackIndex];",
                    "}",
                    "",
                    "function getNodeStackIndexHelper(stack, count) {",
                    "  for (let i = stack.length - 1; i >= 0; i -= 2) {",
                    "    const value = stack[i];",
                    "    if (value && !Array.isArray(value) && --count < 0) {",
                    "      return i;",
                    "    }",
                    "  }",
                    "  return -1;",
                    "}",
                    "",
                    "class AstPath {",
                    "  constructor(value) {",
                    "    this.stack = [value];",
                    "  }",
                    "",
                    "  // The name of the current property is always the penultimate element of",
                    "  // this.stack, and always a String.",
                    "  getName() {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    if (length > 1) {",
                    "      return stack[length - 2];",
                    "    }",
                    "    // Since the name is always a string, null is a safe sentinel value to",
                    "    // return if we do not know the name of the (root) value.",
                    "    /* istanbul ignore next */",
                    "    return null;",
                    "  }",
                    "",
                    "  // The value of the current property is always the final element of",
                    "  // this.stack.",
                    "  getValue() {",
                    "    return getLast(this.stack);",
                    "  }",
                    "",
                    "  getNode(count = 0) {",
                    "    return getNodeHelper(this, count);",
                    "  }",
                    "",
                    "  getParentNode(count = 0) {",
                    "    return getNodeHelper(this, count + 1);",
                    "  }",
                    "",
                    "  // Temporarily push properties named by string arguments given after the",
                    "  // callback function onto this.stack, then call the callback with a",
                    "  // reference to this (modified) AstPath object. Note that the stack will",
                    "  // be restored to its original state after the callback is finished, so it",
                    "  // is probably a mistake to retain a reference to the path.",
                    "  call(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = getLast(stack);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "    const result = callback(this);",
                    "    stack.length = length;",
                    "    return result;",
                    "  }",
                    "",
                    "  callParent(callback, count = 0) {",
                    "    const stackIndex = getNodeStackIndexHelper(this.stack, count + 1);",
                    "    const parentValues = this.stack.splice(stackIndex + 1);",
                    "    const result = callback(this);",
                    "    this.stack.push(...parentValues);",
                    "    return result;",
                    "  }",
                    "",
                    "  // Similar to AstPath.prototype.call, except that the value obtained by",
                    "  // accessing this.getValue()[name1][name2]... should be array. The",
                    "  // callback will be called with a reference to this path object for each",
                    "  // element of the array.",
                    "  each(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = getLast(stack);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "",
                    "    for (let i = 0; i < value.length; ++i) {",
                    "      stack.push(i, value[i]);",
                    "      callback(this, i, value);",
                    "      stack.length -= 2;",
                    "    }",
                    "",
                    "    stack.length = length;",
                    "  }",
                    "",
                    "  // Similar to AstPath.prototype.each, except that the results of the",
                    "  // callback function invocations are stored in an array and returned at",
                    "  // the end of the iteration.",
                    "  map(callback, ...names) {",
                    "    const result = [];",
                    "    this.each((path, index, value) => {",
                    "      result[index] = callback(path, index, value);",
                    "    }, ...names);",
                    "    return result;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {() => void} callback",
                    "   * @internal Unstable API. Don't use in plugins for now.",
                    "   */",
                    "  try(callback) {",
                    "    const { stack } = this;",
                    "    const stackBackup = [...stack];",
                    "    try {",
                    "      return callback();",
                    "    } finally {",
                    "      stack.length = 0;",
                    "      stack.push(...stackBackup);",
                    "    }",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {...(",
                    "   *   | ((node: any, name: string | null, number: number | null) => boolean)",
                    "   *   | undefined",
                    "   * )} predicates",
                    "   */",
                    "  match(...predicates) {",
                    "    let stackPointer = this.stack.length - 1;",
                    "",
                    "    let name = null;",
                    "    let node = this.stack[stackPointer--];",
                    "",
                    "    for (const predicate of predicates) {",
                    "      /* istanbul ignore next */",
                    "      if (node === undefined) {",
                    "        return false;",
                    "      }",
                    "",
                    "      // skip index/array",
                    "      let number = null;",
                    "      if (typeof name === \"number\") {",
                    "        number = name;",
                    "        name = this.stack[stackPointer--];",
                    "        node = this.stack[stackPointer--];",
                    "      }",
                    "",
                    "      if (predicate && !predicate(node, name, number)) {",
                    "        return false;",
                    "      }",
                    "",
                    "      name = this.stack[stackPointer--];",
                    "      node = this.stack[stackPointer--];",
                    "    }",
                    "",
                    "    return true;",
                    "  }",
                    "",
                    "  /**",
                    "   * Traverses the ancestors of the current node heading toward the tree root",
                    "   * until it finds a node that matches the provided predicate function. Will",
                    "   * return the first matching ancestor. If no such node exists, returns undefined.",
                    "   * @param {(node: any, name: string, number: number | null) => boolean} predicate",
                    "   * @internal Unstable API. Don't use in plugins for now.",
                    "   */",
                    "  findAncestor(predicate) {",
                    "    let stackPointer = this.stack.length - 1;",
                    "",
                    "    let name = null;",
                    "    let node = this.stack[stackPointer--];",
                    "",
                    "    while (node) {",
                    "      // skip index/array",
                    "      let number = null;",
                    "      if (typeof name === \"number\") {",
                    "        number = name;",
                    "        name = this.stack[stackPointer--];",
                    "        node = this.stack[stackPointer--];",
                    "      }",
                    "",
                    "      if (name !== null && predicate(node, name, number)) {",
                    "        return node;",
                    "      }",
                    "",
                    "      name = this.stack[stackPointer--];",
                    "      node = this.stack[stackPointer--];",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = AstPath;"
                ]
            },
            "common-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const CATEGORY_COMMON = \"Common\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSpacing: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print spaces between brackets.\",",
                    "    oppositeDescription: \"Do not print spaces between brackets.\",",
                    "  },",
                    "  singleQuote: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes instead of double quotes.\",",
                    "  },",
                    "  proseWrap: {",
                    "    since: \"1.8.2\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.8.2\", value: true },",
                    "      { since: \"1.9.0\", value: \"preserve\" },",
                    "    ],",
                    "    description: \"How to wrap prose.\",",
                    "    choices: [",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"always\",",
                    "        description: \"Wrap prose if it exceeds the print width.\",",
                    "      },",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"never\",",
                    "        description: \"Do not wrap prose.\",",
                    "      },",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"preserve\",",
                    "        description: \"Wrap prose as-is.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  bracketSameLine: {",
                    "    since: \"2.4.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description:",
                    "      \"Put > of opening tags on the last line instead of on a new line.\",",
                    "  },",
                    "  singleAttributePerLine: {",
                    "    since: \"2.6.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Enforce single attribute per line in HTML, Vue and JSX.\",",
                    "  },",
                    "};"
                ]
            },
            "create-ignorer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const ignore = require(\"ignore\").default;",
                    "const getFileContentOrNull = require(\"../utils/get-file-content-or-null.js\");",
                    "",
                    "/**",
                    " * @param {string?} ignorePath",
                    " * @param {boolean?} withNodeModules",
                    " */",
                    "async function createIgnorer(ignorePath, withNodeModules) {",
                    "  const ignoreContent = ignorePath",
                    "    ? await getFileContentOrNull(path.resolve(ignorePath))",
                    "    : null;",
                    "",
                    "  return _createIgnorer(ignoreContent, withNodeModules);",
                    "}",
                    "",
                    "/**",
                    " * @param {string?} ignorePath",
                    " * @param {boolean?} withNodeModules",
                    " */",
                    "createIgnorer.sync = function (ignorePath, withNodeModules) {",
                    "  const ignoreContent = !ignorePath",
                    "    ? null",
                    "    : getFileContentOrNull.sync(path.resolve(ignorePath));",
                    "  return _createIgnorer(ignoreContent, withNodeModules);",
                    "};",
                    "",
                    "/**",
                    " * @param {null | string} ignoreContent",
                    " * @param {boolean?} withNodeModules",
                    " */",
                    "function _createIgnorer(ignoreContent, withNodeModules) {",
                    "  const ignorer = ignore({ allowRelativePaths: true }).add(ignoreContent || \"\");",
                    "  if (!withNodeModules) {",
                    "    ignorer.add(\"node_modules\");",
                    "  }",
                    "  return ignorer;",
                    "}",
                    "",
                    "module.exports = createIgnorer;"
                ]
            },
            "end-of-line.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function guessEndOfLine(text) {",
                    "  const index = text.indexOf(\"\\r\");",
                    "  if (index >= 0) {",
                    "    return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";",
                    "  }",
                    "  return \"lf\";",
                    "}",
                    "",
                    "function convertEndOfLineToChars(value) {",
                    "  switch (value) {",
                    "    case \"cr\":",
                    "      return \"\\r\";",
                    "    case \"crlf\":",
                    "      return \"\\r\\n\";",
                    "    default:",
                    "      return \"\\n\";",
                    "  }",
                    "}",
                    "",
                    "function countEndOfLineChars(text, eol) {",
                    "  let regex;",
                    "",
                    "  switch (eol) {",
                    "    case \"\\n\":",
                    "      regex = /\\n/g;",
                    "      break;",
                    "    case \"\\r\":",
                    "      regex = /\\r/g;",
                    "      break;",
                    "    case \"\\r\\n\":",
                    "      regex = /\\r\\n/g;",
                    "      break;",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);",
                    "  }",
                    "",
                    "  const endOfLines = text.match(regex);",
                    "  return endOfLines ? endOfLines.length : 0;",
                    "}",
                    "",
                    "function normalizeEndOfLine(text) {",
                    "  return text.replace(/\\r\\n?/g, \"\\n\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "  countEndOfLineChars,",
                    "  normalizeEndOfLine,",
                    "};"
                ]
            },
            "errors.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "class ConfigError extends Error {}",
                    "class DebugError extends Error {}",
                    "class UndefinedParserError extends Error {}",
                    "class ArgExpansionBailout extends Error {}",
                    "",
                    "module.exports = {",
                    "  ConfigError,",
                    "  DebugError,",
                    "  UndefinedParserError,",
                    "  ArgExpansionBailout,",
                    "};"
                ]
            },
            "get-file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const options = require(\"../main/options.js\");",
                    "const config = require(\"../config/resolve-config.js\");",
                    "const createIgnorer = require(\"./create-ignorer.js\");",
                    "",
                    "/**",
                    " * @typedef {{ ignorePath?: string, withNodeModules?: boolean, plugins: object, resolveConfig?: boolean }} FileInfoOptions",
                    " * @typedef {{ ignored: boolean, inferredParser: string | null }} FileInfoResult",
                    " */",
                    "",
                    "/**",
                    " * @param {string} filePath",
                    " * @param {FileInfoOptions} opts",
                    " * @returns {Promise<FileInfoResult>}",
                    " *",
                    " * Please note that prettier.getFileInfo() expects opts.plugins to be an array of paths,",
                    " * not an object. A transformation from this array to an object is automatically done",
                    " * internally by the method wrapper. See withPlugins() in index.js.",
                    " */",
                    "async function getFileInfo(filePath, opts) {",
                    "  if (typeof filePath !== \"string\") {",
                    "    throw new TypeError(",
                    "      `expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``",
                    "    );",
                    "  }",
                    "",
                    "  const ignorer = await createIgnorer(opts.ignorePath, opts.withNodeModules);",
                    "  return _getFileInfo({",
                    "    ignorer,",
                    "    filePath,",
                    "    plugins: opts.plugins,",
                    "    resolveConfig: opts.resolveConfig,",
                    "    ignorePath: opts.ignorePath,",
                    "    sync: false,",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * @param {string} filePath",
                    " * @param {FileInfoOptions} opts",
                    " * @returns {FileInfoResult}",
                    " */",
                    "getFileInfo.sync = function (filePath, opts) {",
                    "  if (typeof filePath !== \"string\") {",
                    "    throw new TypeError(",
                    "      `expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``",
                    "    );",
                    "  }",
                    "",
                    "  const ignorer = createIgnorer.sync(opts.ignorePath, opts.withNodeModules);",
                    "  return _getFileInfo({",
                    "    ignorer,",
                    "    filePath,",
                    "    plugins: opts.plugins,",
                    "    resolveConfig: opts.resolveConfig,",
                    "    ignorePath: opts.ignorePath,",
                    "    sync: true,",
                    "  });",
                    "};",
                    "",
                    "function getFileParser(resolvedConfig, filePath, plugins) {",
                    "  if (resolvedConfig && resolvedConfig.parser) {",
                    "    return resolvedConfig.parser;",
                    "  }",
                    "",
                    "  const inferredParser = options.inferParser(filePath, plugins);",
                    "",
                    "  if (inferredParser) {",
                    "    return inferredParser;",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function _getFileInfo({",
                    "  ignorer,",
                    "  filePath,",
                    "  plugins,",
                    "  resolveConfig = false,",
                    "  ignorePath,",
                    "  sync = false,",
                    "}) {",
                    "  const normalizedFilePath = normalizeFilePath(filePath, ignorePath);",
                    "",
                    "  const fileInfo = {",
                    "    ignored: ignorer.ignores(normalizedFilePath),",
                    "    inferredParser: null,",
                    "  };",
                    "",
                    "  if (fileInfo.ignored) {",
                    "    return fileInfo;",
                    "  }",
                    "",
                    "  let resolvedConfig;",
                    "",
                    "  if (resolveConfig) {",
                    "    if (sync) {",
                    "      resolvedConfig = config.resolveConfig.sync(filePath);",
                    "    } else {",
                    "      return config.resolveConfig(filePath).then((resolvedConfig) => {",
                    "        fileInfo.inferredParser = getFileParser(",
                    "          resolvedConfig,",
                    "          filePath,",
                    "          plugins",
                    "        );",
                    "        return fileInfo;",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  fileInfo.inferredParser = getFileParser(resolvedConfig, filePath, plugins);",
                    "  return fileInfo;",
                    "}",
                    "",
                    "function normalizeFilePath(filePath, ignorePath) {",
                    "  return ignorePath",
                    "    ? path.relative(path.dirname(ignorePath), filePath)",
                    "    : filePath;",
                    "}",
                    "",
                    "module.exports = getFileInfo;"
                ]
            },
            "load-plugins.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\");",
                    "const path = require(\"path\");",
                    "const fastGlob = require(\"fast-glob\");",
                    "const partition = require(\"../utils/partition.js\");",
                    "const uniqByKey = require(\"../utils/uniq-by-key.js\");",
                    "const internalPlugins = require(\"../languages.js\");",
                    "const { default: mem, memClear } = require(\"../../vendors/mem.js\");",
                    "const thirdParty = require(\"./third-party.js\");",
                    "const resolve = require(\"./resolve.js\");",
                    "",
                    "const memoizedLoad = mem(load, { cacheKey: JSON.stringify });",
                    "const memoizedSearch = mem(findPluginsInNodeModules);",
                    "const clearCache = () => {",
                    "  memClear(memoizedLoad);",
                    "  memClear(memoizedSearch);",
                    "};",
                    "",
                    "function load(plugins, pluginSearchDirs) {",
                    "  if (!plugins) {",
                    "    plugins = [];",
                    "  }",
                    "",
                    "  if (pluginSearchDirs === false) {",
                    "    pluginSearchDirs = [];",
                    "  } else {",
                    "    pluginSearchDirs = pluginSearchDirs || [];",
                    "",
                    "    // unless pluginSearchDirs are provided, auto-load plugins from node_modules that are parent to Prettier",
                    "    if (pluginSearchDirs.length === 0) {",
                    "      const autoLoadDir = thirdParty.findParentDir(__dirname, \"node_modules\");",
                    "      if (autoLoadDir) {",
                    "        pluginSearchDirs = [autoLoadDir];",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const [externalPluginNames, externalPluginInstances] = partition(",
                    "    plugins,",
                    "    (plugin) => typeof plugin === \"string\"",
                    "  );",
                    "",
                    "  const externalManualLoadPluginInfos = externalPluginNames.map(",
                    "    (pluginName) => {",
                    "      let requirePath;",
                    "      try {",
                    "        // try local files",
                    "        requirePath = resolve(path.resolve(process.cwd(), pluginName));",
                    "      } catch {",
                    "        // try node modules",
                    "        requirePath = resolve(pluginName, { paths: [process.cwd()] });",
                    "      }",
                    "",
                    "      return {",
                    "        name: pluginName,",
                    "        requirePath,",
                    "      };",
                    "    }",
                    "  );",
                    "",
                    "  const externalAutoLoadPluginInfos = pluginSearchDirs.flatMap(",
                    "    (pluginSearchDir) => {",
                    "      const resolvedPluginSearchDir = path.resolve(",
                    "        process.cwd(),",
                    "        pluginSearchDir",
                    "      );",
                    "",
                    "      const nodeModulesDir = path.resolve(",
                    "        resolvedPluginSearchDir,",
                    "        \"node_modules\"",
                    "      );",
                    "",
                    "      // In some fringe cases (ex: files \"mounted\" as virtual directories), the",
                    "      // isDirectory(resolvedPluginSearchDir) check might be false even though",
                    "      // the node_modules actually exists.",
                    "      if (",
                    "        !isDirectory(nodeModulesDir) &&",
                    "        !isDirectory(resolvedPluginSearchDir)",
                    "      ) {",
                    "        throw new Error(",
                    "          `${pluginSearchDir} does not exist or is not a directory`",
                    "        );",
                    "      }",
                    "",
                    "      return memoizedSearch(nodeModulesDir).map((pluginName) => ({",
                    "        name: pluginName,",
                    "        requirePath: resolve(pluginName, { paths: [resolvedPluginSearchDir] }),",
                    "      }));",
                    "    }",
                    "  );",
                    "",
                    "  const externalPlugins = [",
                    "    ...uniqByKey(",
                    "      [...externalManualLoadPluginInfos, ...externalAutoLoadPluginInfos],",
                    "      \"requirePath\"",
                    "    ).map((externalPluginInfo) => ({",
                    "      name: externalPluginInfo.name,",
                    "      ...require(externalPluginInfo.requirePath),",
                    "    })),",
                    "    ...externalPluginInstances,",
                    "  ];",
                    "",
                    "  return [...internalPlugins, ...externalPlugins];",
                    "}",
                    "",
                    "function findPluginsInNodeModules(nodeModulesDir) {",
                    "  const pluginPackageJsonPaths = fastGlob.sync(",
                    "    [",
                    "      \"prettier-plugin-*/package.json\",",
                    "      \"@*/prettier-plugin-*/package.json\",",
                    "      \"@prettier/plugin-*/package.json\",",
                    "    ],",
                    "    {",
                    "      cwd: nodeModulesDir,",
                    "    }",
                    "  );",
                    "  return pluginPackageJsonPaths.map(path.dirname);",
                    "}",
                    "",
                    "function isDirectory(dir) {",
                    "  try {",
                    "    return fs.statSync(dir).isDirectory();",
                    "  } catch {",
                    "    return false;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  loadPlugins: memoizedLoad,",
                    "  clearCache,",
                    "};"
                ]
            },
            "parser-create-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function createError(message, loc) {",
                    "  // Construct an error similar to the ones thrown by Babel.",
                    "  const error = new SyntaxError(",
                    "    message + \" (\" + loc.start.line + \":\" + loc.start.column + \")\"",
                    "  );",
                    "  // @ts-expect-error - TBD (...)",
                    "  error.loc = loc;",
                    "  return error;",
                    "}",
                    "",
                    "module.exports = createError;"
                ]
            },
            "resolve.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "let { resolve } = require;",
                    "",
                    "// In the VS Code and Atom extensions `require` is overridden and `require.resolve` doesn't support the 2nd argument.",
                    "if (resolve.length === 1 || process.env.PRETTIER_FALLBACK_RESOLVE) {",
                    "  // @ts-expect-error",
                    "  resolve = (id, options) => {",
                    "    let basedir;",
                    "    if (options && options.paths && options.paths.length === 1) {",
                    "      basedir = options.paths[0];",
                    "    }",
                    "",
                    "    return require(\"resolve\").sync(id, { basedir });",
                    "  };",
                    "}",
                    "",
                    "module.exports = resolve;"
                ]
            },
            "third-party.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  cosmiconfig: require(\"cosmiconfig\").cosmiconfig,",
                    "  cosmiconfigSync: require(\"cosmiconfig\").cosmiconfigSync,",
                    "  findParentDir: require(\"find-parent-dir\").sync,",
                    "  getStdin: require(\"get-stdin\"),",
                    "  isCI: () => require(\"ci-info\").isCI,",
                    "};"
                ]
            },
            "util-shared.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  getMaxContinuousCount,",
                    "  getStringWidth,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipNewline,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "  skipInlineComment,",
                    "  skipTrailingComment,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  isNextLineEmpty,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isPreviousLineEmpty,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "} = require(\"./util.js\");",
                    "",
                    "module.exports = {",
                    "  getMaxContinuousCount,",
                    "  getStringWidth,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipNewline,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "  skipInlineComment,",
                    "  skipTrailingComment,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  isNextLineEmpty,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isPreviousLineEmpty,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "};"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  default: escapeStringRegexp,",
                    "} = require(\"../../vendors/escape-string-regexp.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const { getSupportInfo } = require(\"../main/support.js\");",
                    "const isNonEmptyArray = require(\"../utils/is-non-empty-array.js\");",
                    "const getStringWidth = require(\"../utils/get-string-width.js\");",
                    "const {",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "} = require(\"../utils/text/skip.js\");",
                    "const skipInlineComment = require(\"../utils/text/skip-inline-comment.js\");",
                    "const skipTrailingComment = require(\"../utils/text/skip-trailing-comment.js\");",
                    "const skipNewline = require(\"../utils/text/skip-newline.js\");",
                    "const getNextNonSpaceNonCommentCharacterIndexWithStartIndex = require(\"../utils/text/get-next-non-space-non-comment-character-index-with-start-index.js\");",
                    "",
                    "const getPenultimate = (arr) => arr[arr.length - 2];",
                    "",
                    "/**",
                    " * @typedef {{backwards?: boolean}} SkipOptions",
                    " */",
                    "",
                    "/**",
                    " * @param {string | RegExp} chars",
                    " * @returns {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "function skip(chars) {",
                    "  return (text, index, opts) => {",
                    "    const backwards = opts && opts.backwards;",
                    "",
                    "    // Allow `skip` functions to be threaded together without having",
                    "    // to check for failures (did someone say monads?).",
                    "    /* istanbul ignore next */",
                    "    if (index === false) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const { length } = text;",
                    "    let cursor = index;",
                    "    while (cursor >= 0 && cursor < length) {",
                    "      const c = text.charAt(cursor);",
                    "      if (chars instanceof RegExp) {",
                    "        if (!chars.test(c)) {",
                    "          return cursor;",
                    "        }",
                    "      } else if (!chars.includes(c)) {",
                    "        return cursor;",
                    "      }",
                    "",
                    "      backwards ? cursor-- : cursor++;",
                    "    }",
                    "",
                    "    if (cursor === -1 || cursor === length) {",
                    "      // If we reached the beginning or end of the file, return the",
                    "      // out-of-bounds cursor. It's up to the caller to handle this",
                    "      // correctly. We don't want to indicate `false` though if it",
                    "      // actually skipped valid characters.",
                    "      return cursor;",
                    "    }",
                    "    return false;",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} index",
                    " * @param {SkipOptions=} opts",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewline(text, index, opts = {}) {",
                    "  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);",
                    "  const idx2 = skipNewline(text, idx, opts);",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} start",
                    " * @param {number} end",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewlineInRange(text, start, end) {",
                    "  for (let i = start; i < end; ++i) {",
                    "    if (text.charAt(i) === \"\\n\") {",
                    "      return true;",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "// Note: this function doesn't ignore leading comments unlike isNextLineEmpty",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locStart",
                    " */",
                    "function isPreviousLineEmpty(text, node, locStart) {",
                    "  /** @type {number | false} */",
                    "  let idx = locStart(node) - 1;",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  idx = skipNewline(text, idx, { backwards: true });",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  const idx2 = skipNewline(text, idx, { backwards: true });",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} index",
                    " * @returns {boolean}",
                    " */",
                    "function isNextLineEmptyAfterIndex(text, index) {",
                    "  /** @type {number | false} */",
                    "  let oldIdx = null;",
                    "  /** @type {number | false} */",
                    "  let idx = index;",
                    "  while (idx !== oldIdx) {",
                    "    // We need to skip all the potential trailing inline comments",
                    "    oldIdx = idx;",
                    "    idx = skipToLineEnd(text, idx);",
                    "    idx = skipInlineComment(text, idx);",
                    "    idx = skipSpaces(text, idx);",
                    "  }",
                    "  idx = skipTrailingComment(text, idx);",
                    "  idx = skipNewline(text, idx);",
                    "  return idx !== false && hasNewline(text, idx);",
                    "}",
                    "",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {boolean}",
                    " */",
                    "function isNextLineEmpty(text, node, locEnd) {",
                    "  return isNextLineEmptyAfterIndex(text, locEnd(node));",
                    "}",
                    "",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {number | false}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {",
                    "  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "    text,",
                    "    locEnd(node)",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {string}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacter(text, node, locEnd) {",
                    "  return text.charAt(",
                    "    // @ts-expect-error => TBD: can return false, should we define a fallback?",
                    "    getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd)",
                    "  );",
                    "}",
                    "",
                    "// Not using, but it's public utils",
                    "/* istanbul ignore next */",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} index",
                    " * @param {SkipOptions=} opts",
                    " * @returns {boolean}",
                    " */",
                    "function hasSpaces(text, index, opts = {}) {",
                    "  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);",
                    "  return idx !== index;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @param {number} tabWidth",
                    " * @param {number=} startIndex",
                    " * @returns {number}",
                    " */",
                    "function getAlignmentSize(value, tabWidth, startIndex = 0) {",
                    "  let size = 0;",
                    "  for (let i = startIndex; i < value.length; ++i) {",
                    "    if (value[i] === \"\\t\") {",
                    "      // Tabs behave in a way that they are aligned to the nearest",
                    "      // multiple of tabWidth:",
                    "      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4",
                    "      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...",
                    "      size = size + tabWidth - (size % tabWidth);",
                    "    } else {",
                    "      size++;",
                    "    }",
                    "  }",
                    "",
                    "  return size;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @param {number} tabWidth",
                    " * @returns {number}",
                    " */",
                    "function getIndentSize(value, tabWidth) {",
                    "  const lastNewlineIndex = value.lastIndexOf(\"\\n\");",
                    "  if (lastNewlineIndex === -1) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return getAlignmentSize(",
                    "    // All the leading whitespaces",
                    "    value.slice(lastNewlineIndex + 1).match(/^[\\t ]*/)[0],",
                    "    tabWidth",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @typedef {'\"' | \"'\"} Quote",
                    " */",
                    "",
                    "/**",
                    " *",
                    " * @param {string} rawContent",
                    " * @param {Quote} preferredQuote",
                    " * @returns {{ quote: Quote, regex: RegExp, escaped: string }}",
                    " */",
                    "",
                    "function getPreferredQuote(rawContent, preferredQuote) {",
                    "  /** @type {{ quote: '\"', regex: RegExp, escaped: \"&quot;\" }} */",
                    "  const double = { quote: '\"', regex: /\"/g, escaped: \"&quot;\" };",
                    "  /** @type {{ quote: \"'\", regex: RegExp, escaped: \"&apos;\" }} */",
                    "  const single = { quote: \"'\", regex: /'/g, escaped: \"&apos;\" };",
                    "",
                    "  const preferred = preferredQuote === \"'\" ? single : double;",
                    "  const alternate = preferred === single ? double : single;",
                    "",
                    "  let result = preferred;",
                    "",
                    "  // If `rawContent` contains at least one of the quote preferred for enclosing",
                    "  // the string, we might want to enclose with the alternate quote instead, to",
                    "  // minimize the number of escaped quotes.",
                    "  if (",
                    "    rawContent.includes(preferred.quote) ||",
                    "    rawContent.includes(alternate.quote)",
                    "  ) {",
                    "    const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;",
                    "    const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;",
                    "",
                    "    result = numPreferredQuotes > numAlternateQuotes ? alternate : preferred;",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function printString(raw, options) {",
                    "  // `rawContent` is the string exactly like it appeared in the input source",
                    "  // code, without its enclosing quotes.",
                    "  const rawContent = raw.slice(1, -1);",
                    "",
                    "  /** @type {Quote} */",
                    "  const enclosingQuote =",
                    "    options.parser === \"json\" ||",
                    "    (options.parser === \"json5\" &&",
                    "      options.quoteProps === \"preserve\" &&",
                    "      !options.singleQuote)",
                    "      ? '\"'",
                    "      : options.__isInHtmlAttribute",
                    "      ? \"'\"",
                    "      : getPreferredQuote(rawContent, options.singleQuote ? \"'\" : '\"').quote;",
                    "",
                    "  // It might sound unnecessary to use `makeString` even if the string already",
                    "  // is enclosed with `enclosingQuote`, but it isn't. The string could contain",
                    "  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes",
                    "  // sure that we consistently output the minimum amount of escaped quotes.",
                    "  return makeString(",
                    "    rawContent,",
                    "    enclosingQuote,",
                    "    !(",
                    "      options.parser === \"css\" ||",
                    "      options.parser === \"less\" ||",
                    "      options.parser === \"scss\" ||",
                    "      options.__embeddedInHtml",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} rawContent",
                    " * @param {Quote} enclosingQuote",
                    " * @param {boolean=} unescapeUnnecessaryEscapes",
                    " * @returns {string}",
                    " */",
                    "function makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {",
                    "  const otherQuote = enclosingQuote === '\"' ? \"'\" : '\"';",
                    "",
                    "  // Matches _any_ escape and unescaped quotes (both single and double).",
                    "  const regex = /\\\\(.)|([\"'])/gs;",
                    "",
                    "  // Escape and unescape single and double quotes as needed to be able to",
                    "  // enclose `rawContent` with `enclosingQuote`.",
                    "  const newContent = rawContent.replace(regex, (match, escaped, quote) => {",
                    "    // If we matched an escape, and the escaped character is a quote of the",
                    "    // other type than we intend to enclose the string with, there's no need for",
                    "    // it to be escaped, so return it _without_ the backslash.",
                    "    if (escaped === otherQuote) {",
                    "      return escaped;",
                    "    }",
                    "",
                    "    // If we matched an unescaped quote and it is of the _same_ type as we",
                    "    // intend to enclose the string with, it must be escaped, so return it with",
                    "    // a backslash.",
                    "    if (quote === enclosingQuote) {",
                    "      return \"\\\\\" + quote;",
                    "    }",
                    "",
                    "    if (quote) {",
                    "      return quote;",
                    "    }",
                    "",
                    "    // Unescape any unnecessarily escaped character.",
                    "    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27",
                    "    return unescapeUnnecessaryEscapes &&",
                    "      /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(escaped)",
                    "      ? escaped",
                    "      : \"\\\\\" + escaped;",
                    "  });",
                    "",
                    "  return enclosingQuote + newContent + enclosingQuote;",
                    "}",
                    "",
                    "function printNumber(rawNumber) {",
                    "  return (",
                    "    rawNumber",
                    "      .toLowerCase()",
                    "      // Remove unnecessary plus and zeroes from scientific notation.",
                    "      .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\")",
                    "      // Remove unnecessary scientific notation (1e0).",
                    "      .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\")",
                    "      // Make sure numbers always start with a digit.",
                    "      .replace(/^([+-])?\\./, \"$10.\")",
                    "      // Remove extraneous trailing decimal zeroes.",
                    "      .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\")",
                    "      // Remove trailing dot.",
                    "      .replace(/\\.(?=e|$)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} str",
                    " * @param {string} target",
                    " * @returns {number}",
                    " */",
                    "function getMaxContinuousCount(str, target) {",
                    "  const results = str.match(",
                    "    new RegExp(`(${escapeStringRegexp(target)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (results === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return results.reduce(",
                    "    (maxCount, result) => Math.max(maxCount, result.length / target.length),",
                    "    0",
                    "  );",
                    "}",
                    "",
                    "function getMinNotPresentContinuousCount(str, target) {",
                    "  const matches = str.match(",
                    "    new RegExp(`(${escapeStringRegexp(target)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (matches === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  const countPresent = new Map();",
                    "  let max = 0;",
                    "",
                    "  for (const match of matches) {",
                    "    const count = match.length / target.length;",
                    "    countPresent.set(count, true);",
                    "    if (count > max) {",
                    "      max = count;",
                    "    }",
                    "  }",
                    "",
                    "  for (let i = 1; i < max; i++) {",
                    "    if (!countPresent.get(i)) {",
                    "      return i;",
                    "    }",
                    "  }",
                    "",
                    "  return max + 1;",
                    "}",
                    "",
                    "function addCommentHelper(node, comment) {",
                    "  const comments = node.comments || (node.comments = []);",
                    "  comments.push(comment);",
                    "  comment.printed = false;",
                    "  comment.nodeDescription = describeNodeForDebugging(node);",
                    "}",
                    "",
                    "function addLeadingComment(node, comment) {",
                    "  comment.leading = true;",
                    "  comment.trailing = false;",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function addDanglingComment(node, comment, marker) {",
                    "  comment.leading = false;",
                    "  comment.trailing = false;",
                    "  if (marker) {",
                    "    comment.marker = marker;",
                    "  }",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function addTrailingComment(node, comment) {",
                    "  comment.leading = false;",
                    "  comment.trailing = true;",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function inferParserByLanguage(language, options) {",
                    "  const { languages } = getSupportInfo({ plugins: options.plugins });",
                    "  const matched =",
                    "    languages.find(({ name }) => name.toLowerCase() === language) ||",
                    "    languages.find(",
                    "      ({ aliases }) => Array.isArray(aliases) && aliases.includes(language)",
                    "    ) ||",
                    "    languages.find(",
                    "      ({ extensions }) =>",
                    "        Array.isArray(extensions) && extensions.includes(`.${language}`)",
                    "    );",
                    "  return matched && matched.parsers[0];",
                    "}",
                    "",
                    "function isFrontMatterNode(node) {",
                    "  return node && node.type === \"front-matter\";",
                    "}",
                    "",
                    "/**",
                    " * @param {string} description",
                    " * @returns {(node: any) => symbol}",
                    " */",
                    "function createGroupIdMapper(description) {",
                    "  const groupIds = new WeakMap();",
                    "  return function (node) {",
                    "    if (!groupIds.has(node)) {",
                    "      groupIds.set(node, Symbol(description));",
                    "    }",
                    "    return groupIds.get(node);",
                    "  };",
                    "}",
                    "",
                    "function describeNodeForDebugging(node) {",
                    "  const nodeType = node.type || node.kind || \"(unknown type)\";",
                    "  let nodeName = String(",
                    "    node.name ||",
                    "      (node.id && (typeof node.id === \"object\" ? node.id.name : node.id)) ||",
                    "      (node.key && (typeof node.key === \"object\" ? node.key.name : node.key)) ||",
                    "      (node.value &&",
                    "        (typeof node.value === \"object\" ? \"\" : String(node.value))) ||",
                    "      node.operator ||",
                    "      \"\"",
                    "  );",
                    "  if (nodeName.length > 20) {",
                    "    nodeName = nodeName.slice(0, 19) + \"\u2026\";",
                    "  }",
                    "  return nodeType + (nodeName ? \" \" + nodeName : \"\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  inferParserByLanguage,",
                    "  getStringWidth,",
                    "  getMaxContinuousCount,",
                    "  getMinNotPresentContinuousCount,",
                    "  getPenultimate,",
                    "  getLast,",
                    "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  getNextNonSpaceNonCommentCharacter,",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "  skipInlineComment,",
                    "  skipTrailingComment,",
                    "  skipNewline,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isNextLineEmpty,",
                    "  isPreviousLineEmpty,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  getPreferredQuote,",
                    "  printString,",
                    "  printNumber,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "  isFrontMatterNode,",
                    "  isNonEmptyArray,",
                    "  createGroupIdMapper,",
                    "};"
                ]
            }
        },
        "config": {
            "find-project-root.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// Simple version of `find-project-root`",
                    "// https://github.com/kirstein/find-project-root/blob/master/index.js",
                    "",
                    "const fs = require(\"fs\");",
                    "const path = require(\"path\");",
                    "",
                    "const MARKERS = [\".git\", \".hg\"];",
                    "",
                    "const markerExists = (directory) =>",
                    "  MARKERS.some((mark) => fs.existsSync(path.join(directory, mark)));",
                    "",
                    "function findProjectRoot(directory) {",
                    "  while (!markerExists(directory)) {",
                    "    const parentDirectory = path.resolve(directory, \"..\");",
                    "    if (parentDirectory === directory) {",
                    "      break;",
                    "    }",
                    "    directory = parentDirectory;",
                    "  }",
                    "",
                    "  return directory;",
                    "}",
                    "",
                    "module.exports = findProjectRoot;"
                ]
            },
            "resolve-config-editorconfig.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "",
                    "const editorconfig = require(\"editorconfig\");",
                    "const editorConfigToPrettier = require(\"editorconfig-to-prettier\");",
                    "const { default: mem, memClear } = require(\"../../vendors/mem.js\");",
                    "const findProjectRoot = require(\"./find-project-root.js\");",
                    "",
                    "const jsonStringifyMem = (fn) => mem(fn, { cacheKey: JSON.stringify });",
                    "",
                    "const maybeParse = (filePath, parse) =>",
                    "  filePath &&",
                    "  parse(filePath, {",
                    "    root: findProjectRoot(path.dirname(path.resolve(filePath))),",
                    "  });",
                    "",
                    "const editorconfigAsyncNoCache = async (filePath) =>",
                    "  editorConfigToPrettier(await maybeParse(filePath, editorconfig.parse));",
                    "const editorconfigAsyncWithCache = jsonStringifyMem(editorconfigAsyncNoCache);",
                    "",
                    "const editorconfigSyncNoCache = (filePath) =>",
                    "  editorConfigToPrettier(maybeParse(filePath, editorconfig.parseSync));",
                    "const editorconfigSyncWithCache = jsonStringifyMem(editorconfigSyncNoCache);",
                    "",
                    "function getLoadFunction(opts) {",
                    "  if (!opts.editorconfig) {",
                    "    return () => null;",
                    "  }",
                    "",
                    "  if (opts.sync) {",
                    "    return opts.cache ? editorconfigSyncWithCache : editorconfigSyncNoCache;",
                    "  }",
                    "",
                    "  return opts.cache ? editorconfigAsyncWithCache : editorconfigAsyncNoCache;",
                    "}",
                    "",
                    "function clearCache() {",
                    "  memClear(editorconfigSyncWithCache);",
                    "  memClear(editorconfigAsyncWithCache);",
                    "}",
                    "",
                    "module.exports = {",
                    "  getLoadFunction,",
                    "  clearCache,",
                    "};"
                ]
            },
            "resolve-config.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const micromatch = require(\"micromatch\");",
                    "const thirdParty = require(\"../common/third-party.js\");",
                    "",
                    "const loadToml = require(\"../utils/load-toml.js\");",
                    "const loadJson5 = require(\"../utils/load-json5.js\");",
                    "const partition = require(\"../utils/partition.js\");",
                    "const resolve = require(\"../common/resolve.js\");",
                    "const { default: mem, memClear } = require(\"../../vendors/mem.js\");",
                    "const resolveEditorConfig = require(\"./resolve-config-editorconfig.js\");",
                    "",
                    "/**",
                    " * @typedef {ReturnType<import(\"cosmiconfig\").cosmiconfig>} Explorer",
                    " * @typedef {ReturnType<import(\"cosmiconfig\").cosmiconfigSync>} SyncExplorer",
                    " * @typedef {{sync?: boolean; cache?: boolean }} Options",
                    " */",
                    "",
                    "/**",
                    " * @template {Options} Opts",
                    " * @param {Opts} opts",
                    " * @return {Opts[\"sync\"] extends true ? SyncExplorer : Explorer}",
                    " */",
                    "const getExplorerMemoized = mem(",
                    "  (opts) => {",
                    "    const cosmiconfig = thirdParty[\"cosmiconfig\" + (opts.sync ? \"Sync\" : \"\")];",
                    "    const explorer = cosmiconfig(\"prettier\", {",
                    "      cache: opts.cache,",
                    "      transform: (result) => {",
                    "        if (result && result.config) {",
                    "          if (typeof result.config === \"string\") {",
                    "            const dir = path.dirname(result.filepath);",
                    "            const modulePath = resolve(result.config, { paths: [dir] });",
                    "            result.config = require(modulePath);",
                    "          }",
                    "",
                    "          if (typeof result.config !== \"object\") {",
                    "            throw new TypeError(",
                    "              \"Config is only allowed to be an object, \" +",
                    "                `but received ${typeof result.config} in \"${result.filepath}\"`",
                    "            );",
                    "          }",
                    "",
                    "          delete result.config.$schema;",
                    "        }",
                    "        return result;",
                    "      },",
                    "      searchPlaces: [",
                    "        \"package.json\",",
                    "        \".prettierrc\",",
                    "        \".prettierrc.json\",",
                    "        \".prettierrc.yaml\",",
                    "        \".prettierrc.yml\",",
                    "        \".prettierrc.json5\",",
                    "        \".prettierrc.js\",",
                    "        \".prettierrc.cjs\",",
                    "        \"prettier.config.js\",",
                    "        \"prettier.config.cjs\",",
                    "        \".prettierrc.toml\",",
                    "      ],",
                    "      loaders: {",
                    "        \".toml\": loadToml,",
                    "        \".json5\": loadJson5,",
                    "      },",
                    "    });",
                    "",
                    "    return explorer;",
                    "  },",
                    "  { cacheKey: JSON.stringify }",
                    ");",
                    "",
                    "/**",
                    " * @template {Options} Opts",
                    " * @param {Opts} opts",
                    " * @return {Opts[\"sync\"] extends true ? SyncExplorer : Explorer}",
                    " */",
                    "function getExplorer(opts) {",
                    "  // Normalize opts before passing to a memoized function",
                    "  opts = { sync: false, cache: false, ...opts };",
                    "  return getExplorerMemoized(opts);",
                    "}",
                    "",
                    "function _resolveConfig(filePath, opts, sync) {",
                    "  opts = { useCache: true, ...opts };",
                    "  const loadOpts = {",
                    "    cache: Boolean(opts.useCache),",
                    "    sync: Boolean(sync),",
                    "    editorconfig: Boolean(opts.editorconfig),",
                    "  };",
                    "  const { load, search } = getExplorer(loadOpts);",
                    "  const loadEditorConfig = resolveEditorConfig.getLoadFunction(loadOpts);",
                    "  /** @type {[any, any]} */",
                    "  const arr = [",
                    "    opts.config ? load(opts.config) : search(filePath),",
                    "    loadEditorConfig(filePath),",
                    "  ];",
                    "",
                    "  const unwrapAndMerge = ([result, editorConfigured]) => {",
                    "    const merged = {",
                    "      ...editorConfigured,",
                    "      ...mergeOverrides(result, filePath),",
                    "    };",
                    "",
                    "    for (const optionName of [\"plugins\", \"pluginSearchDirs\"]) {",
                    "      if (Array.isArray(merged[optionName])) {",
                    "        merged[optionName] = merged[optionName].map((value) =>",
                    "          typeof value === \"string\" && value.startsWith(\".\") // relative path",
                    "            ? path.resolve(path.dirname(result.filepath), value)",
                    "            : value",
                    "        );",
                    "      }",
                    "    }",
                    "",
                    "    if (!result && !editorConfigured) {",
                    "      return null;",
                    "    }",
                    "",
                    "    // We are not using this option",
                    "    delete merged.insertFinalNewline;",
                    "    return merged;",
                    "  };",
                    "",
                    "  if (loadOpts.sync) {",
                    "    return unwrapAndMerge(arr);",
                    "  }",
                    "",
                    "  return Promise.all(arr).then(unwrapAndMerge);",
                    "}",
                    "",
                    "const resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);",
                    "",
                    "resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);",
                    "",
                    "function clearCache() {",
                    "  memClear(getExplorerMemoized);",
                    "  resolveEditorConfig.clearCache();",
                    "}",
                    "",
                    "async function resolveConfigFile(filePath) {",
                    "  const { search } = getExplorer({ sync: false });",
                    "  const result = await search(filePath);",
                    "  return result ? result.filepath : null;",
                    "}",
                    "",
                    "resolveConfigFile.sync = (filePath) => {",
                    "  const { search } = getExplorer({ sync: true });",
                    "  const result = search(filePath);",
                    "  return result ? result.filepath : null;",
                    "};",
                    "",
                    "function mergeOverrides(configResult, filePath) {",
                    "  const { config, filepath: configPath } = configResult || {};",
                    "  const { overrides, ...options } = config || {};",
                    "  if (filePath && overrides) {",
                    "    const relativeFilePath = path.relative(path.dirname(configPath), filePath);",
                    "    for (const override of overrides) {",
                    "      if (",
                    "        pathMatchesGlobs(",
                    "          relativeFilePath,",
                    "          override.files,",
                    "          override.excludeFiles",
                    "        )",
                    "      ) {",
                    "        Object.assign(options, override.options);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  return options;",
                    "}",
                    "",
                    "// Based on eslint: https://github.com/eslint/eslint/blob/master/lib/config/config-ops.js",
                    "function pathMatchesGlobs(filePath, patterns, excludedPatterns) {",
                    "  const patternList = Array.isArray(patterns) ? patterns : [patterns];",
                    "  // micromatch always matches against basename when the option is enabled",
                    "  // use only patterns without slashes with it to match minimatch behavior",
                    "  const [withSlashes, withoutSlashes] = partition(patternList, (pattern) =>",
                    "    pattern.includes(\"/\")",
                    "  );",
                    "",
                    "  return (",
                    "    micromatch.isMatch(filePath, withoutSlashes, {",
                    "      ignore: excludedPatterns,",
                    "      basename: true,",
                    "      dot: true,",
                    "    }) ||",
                    "    micromatch.isMatch(filePath, withSlashes, {",
                    "      ignore: excludedPatterns,",
                    "      basename: false,",
                    "      dot: true,",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  resolveConfig,",
                    "  resolveConfigFile,",
                    "  clearCache,",
                    "};"
                ]
            }
        },
        "document": {
            "doc-builders.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * TBD properly tagged union for Doc object type is needed here.",
                    " *",
                    " * @typedef {object} DocObject",
                    " * @property {string} type",
                    " * @property {boolean} [hard]",
                    " * @property {boolean} [literal]",
                    " *",
                    " * @typedef {Doc[]} DocArray",
                    " *",
                    " * @typedef {string | DocObject | DocArray} Doc",
                    " */",
                    "",
                    "/**",
                    " * @param {Doc} val",
                    " */",
                    "function assertDoc(val) {",
                    "  if (typeof val === \"string\") {",
                    "    return;",
                    "  }",
                    "",
                    "  if (Array.isArray(val)) {",
                    "    for (const doc of val) {",
                    "      assertDoc(doc);",
                    "    }",
                    "    return;",
                    "  }",
                    "",
                    "  if (val && typeof val.type === \"string\") {",
                    "    return;",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  throw new Error(\"Value \" + JSON.stringify(val) + \" is not a valid document\");",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} parts",
                    " * @returns Doc",
                    " */",
                    "function concat(parts) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    for (const part of parts) {",
                    "      assertDoc(part);",
                    "    }",
                    "  }",
                    "",
                    "  // We cannot do this until we change `printJSXElement` to not",
                    "  // access the internals of a document directly.",
                    "  // if(parts.length === 1) {",
                    "  //   // If it's a single document, no need to concat it.",
                    "  //   return parts[0];",
                    "  // }",
                    "  return { type: \"concat\", parts };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function indent(contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return { type: \"indent\", contents };",
                    "}",
                    "",
                    "/**",
                    " * @param {number | string} widthOrString",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function align(widthOrString, contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return { type: \"align\", contents, n: widthOrString };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function group(contents, opts = {}) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return {",
                    "    type: \"group\",",
                    "    id: opts.id,",
                    "    contents,",
                    "    break: Boolean(opts.shouldBreak),",
                    "    expandedStates: opts.expandedStates,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedentToRoot(contents) {",
                    "  return align(Number.NEGATIVE_INFINITY, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function markAsRoot(contents) {",
                    "  // @ts-expect-error - TBD ???:",
                    "  return align({ type: \"root\" }, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedent(contents) {",
                    "  return align(-1, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} states",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function conditionalGroup(states, opts) {",
                    "  return group(states[0], { ...opts, expandedStates: states });",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} parts",
                    " * @returns Doc",
                    " */",
                    "function fill(parts) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    for (const part of parts) {",
                    "      assertDoc(part);",
                    "    }",
                    "  }",
                    "",
                    "  return { type: \"fill\", parts };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} [breakContents]",
                    " * @param {Doc} [flatContents]",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function ifBreak(breakContents, flatContents, opts = {}) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    if (breakContents) {",
                    "      assertDoc(breakContents);",
                    "    }",
                    "    if (flatContents) {",
                    "      assertDoc(flatContents);",
                    "    }",
                    "  }",
                    "",
                    "  return {",
                    "    type: \"if-break\",",
                    "    breakContents,",
                    "    flatContents,",
                    "    groupId: opts.groupId,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * Optimized version of `ifBreak(indent(doc), doc, { groupId: ... })`",
                    " * @param {Doc} contents",
                    " * @param {{ groupId: symbol, negate?: boolean }} opts",
                    " * @returns Doc",
                    " */",
                    "function indentIfBreak(contents, opts) {",
                    "  return {",
                    "    type: \"indent-if-break\",",
                    "    contents,",
                    "    groupId: opts.groupId,",
                    "    negate: opts.negate,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function lineSuffix(contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "  return { type: \"line-suffix\", contents };",
                    "}",
                    "",
                    "const lineSuffixBoundary = { type: \"line-suffix-boundary\" };",
                    "const breakParent = { type: \"break-parent\" };",
                    "const trim = { type: \"trim\" };",
                    "",
                    "const hardlineWithoutBreakParent = { type: \"line\", hard: true };",
                    "const literallineWithoutBreakParent = {",
                    "  type: \"line\",",
                    "  hard: true,",
                    "  literal: true,",
                    "};",
                    "",
                    "const line = { type: \"line\" };",
                    "const softline = { type: \"line\", soft: true };",
                    "// eslint-disable-next-line prettier-internal-rules/no-doc-builder-concat",
                    "const hardline = concat([hardlineWithoutBreakParent, breakParent]);",
                    "// eslint-disable-next-line prettier-internal-rules/no-doc-builder-concat",
                    "const literalline = concat([literallineWithoutBreakParent, breakParent]);",
                    "",
                    "const cursor = { type: \"cursor\", placeholder: Symbol(\"cursor\") };",
                    "",
                    "/**",
                    " * @param {Doc} sep",
                    " * @param {Doc[]} arr",
                    " * @returns Doc",
                    " */",
                    "function join(sep, arr) {",
                    "  const res = [];",
                    "",
                    "  for (let i = 0; i < arr.length; i++) {",
                    "    if (i !== 0) {",
                    "      res.push(sep);",
                    "    }",
                    "",
                    "    res.push(arr[i]);",
                    "  }",
                    "",
                    "  // eslint-disable-next-line prettier-internal-rules/no-doc-builder-concat",
                    "  return concat(res);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} doc",
                    " * @param {number} size",
                    " * @param {number} tabWidth",
                    " */",
                    "function addAlignmentToDoc(doc, size, tabWidth) {",
                    "  let aligned = doc;",
                    "  if (size > 0) {",
                    "    // Use indent to add tabs for all the levels of tabs we need",
                    "    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {",
                    "      aligned = indent(aligned);",
                    "    }",
                    "    // Use align for all the spaces that are needed",
                    "    aligned = align(size % tabWidth, aligned);",
                    "    // size is absolute from 0 and not relative to the current",
                    "    // indentation, so we use -Infinity to reset the indentation to 0",
                    "    aligned = align(Number.NEGATIVE_INFINITY, aligned);",
                    "  }",
                    "  return aligned;",
                    "}",
                    "",
                    "function label(label, contents) {",
                    "  return { type: \"label\", label, contents };",
                    "}",
                    "",
                    "module.exports = {",
                    "  concat,",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  trim,",
                    "  indent,",
                    "  indentIfBreak,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent,",
                    "  hardlineWithoutBreakParent,",
                    "  literallineWithoutBreakParent,",
                    "  label,",
                    "};"
                ]
            },
            "doc-debug.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isConcat, getDocParts } = require(\"./doc-utils.js\");",
                    "",
                    "function flattenDoc(doc) {",
                    "  if (!doc) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (isConcat(doc)) {",
                    "    const res = [];",
                    "    for (const part of getDocParts(doc)) {",
                    "      if (isConcat(part)) {",
                    "        res.push(...flattenDoc(part).parts);",
                    "      } else {",
                    "        const flattened = flattenDoc(part);",
                    "        if (flattened !== \"\") {",
                    "          res.push(flattened);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return { type: \"concat\", parts: res };",
                    "  }",
                    "",
                    "  if (doc.type === \"if-break\") {",
                    "    return {",
                    "      ...doc,",
                    "      breakContents: flattenDoc(doc.breakContents),",
                    "      flatContents: flattenDoc(doc.flatContents),",
                    "    };",
                    "  }",
                    "",
                    "  if (doc.type === \"group\") {",
                    "    return {",
                    "      ...doc,",
                    "      contents: flattenDoc(doc.contents),",
                    "      expandedStates: doc.expandedStates && doc.expandedStates.map(flattenDoc),",
                    "    };",
                    "  }",
                    "",
                    "  if (doc.type === \"fill\") {",
                    "    return { type: \"fill\", parts: doc.parts.map(flattenDoc) };",
                    "  }",
                    "",
                    "  if (doc.contents) {",
                    "    return { ...doc, contents: flattenDoc(doc.contents) };",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function printDocToDebug(doc) {",
                    "  /** @type Record<symbol, string> */",
                    "  const printedSymbols = Object.create(null);",
                    "  /** @type Set<string> */",
                    "  const usedKeysForSymbols = new Set();",
                    "  return printDoc(flattenDoc(doc));",
                    "",
                    "  function printDoc(doc, index, parentParts) {",
                    "    if (typeof doc === \"string\") {",
                    "      return JSON.stringify(doc);",
                    "    }",
                    "",
                    "    if (isConcat(doc)) {",
                    "      const printed = getDocParts(doc).map(printDoc).filter(Boolean);",
                    "      return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;",
                    "    }",
                    "",
                    "    if (doc.type === \"line\") {",
                    "      const withBreakParent =",
                    "        Array.isArray(parentParts) &&",
                    "        parentParts[index + 1] &&",
                    "        parentParts[index + 1].type === \"break-parent\";",
                    "      if (doc.literal) {",
                    "        return withBreakParent",
                    "          ? \"literalline\"",
                    "          : \"literallineWithoutBreakParent\";",
                    "      }",
                    "      if (doc.hard) {",
                    "        return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";",
                    "      }",
                    "      if (doc.soft) {",
                    "        return \"softline\";",
                    "      }",
                    "      return \"line\";",
                    "    }",
                    "",
                    "    if (doc.type === \"break-parent\") {",
                    "      const afterHardline =",
                    "        Array.isArray(parentParts) &&",
                    "        parentParts[index - 1] &&",
                    "        parentParts[index - 1].type === \"line\" &&",
                    "        parentParts[index - 1].hard;",
                    "      return afterHardline ? undefined : \"breakParent\";",
                    "    }",
                    "",
                    "    if (doc.type === \"trim\") {",
                    "      return \"trim\";",
                    "    }",
                    "",
                    "    if (doc.type === \"indent\") {",
                    "      return \"indent(\" + printDoc(doc.contents) + \")\";",
                    "    }",
                    "",
                    "    if (doc.type === \"align\") {",
                    "      return doc.n === Number.NEGATIVE_INFINITY",
                    "        ? \"dedentToRoot(\" + printDoc(doc.contents) + \")\"",
                    "        : doc.n < 0",
                    "        ? \"dedent(\" + printDoc(doc.contents) + \")\"",
                    "        : doc.n.type === \"root\"",
                    "        ? \"markAsRoot(\" + printDoc(doc.contents) + \")\"",
                    "        : \"align(\" +",
                    "          JSON.stringify(doc.n) +",
                    "          \", \" +",
                    "          printDoc(doc.contents) +",
                    "          \")\";",
                    "    }",
                    "",
                    "    if (doc.type === \"if-break\") {",
                    "      return (",
                    "        \"ifBreak(\" +",
                    "        printDoc(doc.breakContents) +",
                    "        (doc.flatContents ? \", \" + printDoc(doc.flatContents) : \"\") +",
                    "        (doc.groupId",
                    "          ? (!doc.flatContents ? ', \"\"' : \"\") +",
                    "            `, { groupId: ${printGroupId(doc.groupId)} }`",
                    "          : \"\") +",
                    "        \")\"",
                    "      );",
                    "    }",
                    "",
                    "    if (doc.type === \"indent-if-break\") {",
                    "      const optionsParts = [];",
                    "",
                    "      if (doc.negate) {",
                    "        optionsParts.push(\"negate: true\");",
                    "      }",
                    "",
                    "      if (doc.groupId) {",
                    "        optionsParts.push(`groupId: ${printGroupId(doc.groupId)}`);",
                    "      }",
                    "",
                    "      const options =",
                    "        optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";",
                    "",
                    "      return `indentIfBreak(${printDoc(doc.contents)}${options})`;",
                    "    }",
                    "",
                    "    if (doc.type === \"group\") {",
                    "      const optionsParts = [];",
                    "",
                    "      if (doc.break && doc.break !== \"propagated\") {",
                    "        optionsParts.push(\"shouldBreak: true\");",
                    "      }",
                    "",
                    "      if (doc.id) {",
                    "        optionsParts.push(`id: ${printGroupId(doc.id)}`);",
                    "      }",
                    "",
                    "      const options =",
                    "        optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";",
                    "",
                    "      if (doc.expandedStates) {",
                    "        return `conditionalGroup([${doc.expandedStates",
                    "          .map((part) => printDoc(part))",
                    "          .join(\",\")}]${options})`;",
                    "      }",
                    "",
                    "      return `group(${printDoc(doc.contents)}${options})`;",
                    "    }",
                    "",
                    "    if (doc.type === \"fill\") {",
                    "      return `fill([${doc.parts.map((part) => printDoc(part)).join(\", \")}])`;",
                    "    }",
                    "",
                    "    if (doc.type === \"line-suffix\") {",
                    "      return \"lineSuffix(\" + printDoc(doc.contents) + \")\";",
                    "    }",
                    "",
                    "    if (doc.type === \"line-suffix-boundary\") {",
                    "      return \"lineSuffixBoundary\";",
                    "    }",
                    "",
                    "    if (doc.type === \"label\") {",
                    "      return `label(${JSON.stringify(doc.label)}, ${printDoc(doc.contents)})`;",
                    "    }",
                    "",
                    "    throw new Error(\"Unknown doc type \" + doc.type);",
                    "  }",
                    "",
                    "  function printGroupId(id) {",
                    "    if (typeof id !== \"symbol\") {",
                    "      return JSON.stringify(String(id));",
                    "    }",
                    "",
                    "    if (id in printedSymbols) {",
                    "      return printedSymbols[id];",
                    "    }",
                    "",
                    "    // TODO: use Symbol.prototype.description instead of slice once Node 10 is dropped",
                    "    const prefix = String(id).slice(7, -1) || \"symbol\";",
                    "    for (let counter = 0; ; counter++) {",
                    "      const key = prefix + (counter > 0 ? ` #${counter}` : \"\");",
                    "      if (!usedKeysForSymbols.has(key)) {",
                    "        usedKeysForSymbols.add(key);",
                    "        return (printedSymbols[id] = `Symbol.for(${JSON.stringify(key)})`);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = { printDocToDebug };"
                ]
            },
            "doc-printer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { convertEndOfLineToChars } = require(\"../common/end-of-line.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const getStringWidth = require(\"../utils/get-string-width.js\");",
                    "const { fill, cursor, indent } = require(\"./doc-builders.js\");",
                    "const { isConcat, getDocParts } = require(\"./doc-utils.js\");",
                    "",
                    "/** @typedef {typeof MODE_BREAK | typeof MODE_FLAT} Mode */",
                    "/** @typedef {{ ind: any, doc: any, mode: Mode }} Command */",
                    "",
                    "/** @type {Record<symbol, Mode>} */",
                    "let groupModeMap;",
                    "",
                    "// prettier-ignore",
                    "const MODE_BREAK = /** @type {const} */ (1);",
                    "// prettier-ignore",
                    "const MODE_FLAT = /** @type {const} */ (2);",
                    "",
                    "function rootIndent() {",
                    "  return { value: \"\", length: 0, queue: [] };",
                    "}",
                    "",
                    "function makeIndent(ind, options) {",
                    "  return generateInd(ind, { type: \"indent\" }, options);",
                    "}",
                    "",
                    "function makeAlign(indent, widthOrDoc, options) {",
                    "  if (widthOrDoc === Number.NEGATIVE_INFINITY) {",
                    "    return indent.root || rootIndent();",
                    "  }",
                    "",
                    "  if (widthOrDoc < 0) {",
                    "    return generateInd(indent, { type: \"dedent\" }, options);",
                    "  }",
                    "",
                    "  if (!widthOrDoc) {",
                    "    return indent;",
                    "  }",
                    "",
                    "  if (widthOrDoc.type === \"root\") {",
                    "    return { ...indent, root: indent };",
                    "  }",
                    "",
                    "  const alignType =",
                    "    typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";",
                    "",
                    "  return generateInd(indent, { type: alignType, n: widthOrDoc }, options);",
                    "}",
                    "",
                    "function generateInd(ind, newPart, options) {",
                    "  const queue =",
                    "    newPart.type === \"dedent\"",
                    "      ? ind.queue.slice(0, -1)",
                    "      : [...ind.queue, newPart];",
                    "",
                    "  let value = \"\";",
                    "  let length = 0;",
                    "  let lastTabs = 0;",
                    "  let lastSpaces = 0;",
                    "",
                    "  for (const part of queue) {",
                    "    switch (part.type) {",
                    "      case \"indent\":",
                    "        flush();",
                    "        if (options.useTabs) {",
                    "          addTabs(1);",
                    "        } else {",
                    "          addSpaces(options.tabWidth);",
                    "        }",
                    "        break;",
                    "      case \"stringAlign\":",
                    "        flush();",
                    "        value += part.n;",
                    "        length += part.n.length;",
                    "        break;",
                    "      case \"numberAlign\":",
                    "        lastTabs += 1;",
                    "        lastSpaces += part.n;",
                    "        break;",
                    "      /* istanbul ignore next */",
                    "      default:",
                    "        throw new Error(`Unexpected type '${part.type}'`);",
                    "    }",
                    "  }",
                    "",
                    "  flushSpaces();",
                    "",
                    "  return { ...ind, value, length, queue };",
                    "",
                    "  function addTabs(count) {",
                    "    value += \"\\t\".repeat(count);",
                    "    length += options.tabWidth * count;",
                    "  }",
                    "",
                    "  function addSpaces(count) {",
                    "    value += \" \".repeat(count);",
                    "    length += count;",
                    "  }",
                    "",
                    "  function flush() {",
                    "    if (options.useTabs) {",
                    "      flushTabs();",
                    "    } else {",
                    "      flushSpaces();",
                    "    }",
                    "  }",
                    "",
                    "  function flushTabs() {",
                    "    if (lastTabs > 0) {",
                    "      addTabs(lastTabs);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function flushSpaces() {",
                    "    if (lastSpaces > 0) {",
                    "      addSpaces(lastSpaces);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function resetLast() {",
                    "    lastTabs = 0;",
                    "    lastSpaces = 0;",
                    "  }",
                    "}",
                    "",
                    "function trim(out) {",
                    "  if (out.length === 0) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  let trimCount = 0;",
                    "",
                    "  // Trim whitespace at the end of line",
                    "  while (",
                    "    out.length > 0 &&",
                    "    typeof getLast(out) === \"string\" &&",
                    "    /^[\\t ]*$/.test(getLast(out))",
                    "  ) {",
                    "    trimCount += out.pop().length;",
                    "  }",
                    "",
                    "  if (out.length > 0 && typeof getLast(out) === \"string\") {",
                    "    const trimmed = getLast(out).replace(/[\\t ]*$/, \"\");",
                    "    trimCount += getLast(out).length - trimmed.length;",
                    "    out[out.length - 1] = trimmed;",
                    "  }",
                    "",
                    "  return trimCount;",
                    "}",
                    "",
                    "/**",
                    " * @param {Command} next",
                    " * @param {Command[]} restCommands",
                    " * @param {number} width",
                    " * @param {boolean} hasLineSuffix",
                    " * @param {boolean} [mustBeFlat]",
                    " * @returns {boolean}",
                    " */",
                    "function fits(next, restCommands, width, hasLineSuffix, mustBeFlat) {",
                    "  let restIdx = restCommands.length;",
                    "  /** @type {Array<Omit<Command, 'ind'>>} */",
                    "  const cmds = [next];",
                    "  // `out` is only used for width counting because `trim` requires to look",
                    "  // backwards for space characters.",
                    "  const out = [];",
                    "  while (width >= 0) {",
                    "    if (cmds.length === 0) {",
                    "      if (restIdx === 0) {",
                    "        return true;",
                    "      }",
                    "      cmds.push(restCommands[--restIdx]);",
                    "      continue;",
                    "    }",
                    "",
                    "    const { mode, doc } = cmds.pop();",
                    "",
                    "    if (typeof doc === \"string\") {",
                    "      out.push(doc);",
                    "      width -= getStringWidth(doc);",
                    "    } else if (isConcat(doc) || doc.type === \"fill\") {",
                    "      const parts = getDocParts(doc);",
                    "      for (let i = parts.length - 1; i >= 0; i--) {",
                    "        cmds.push({ mode, doc: parts[i] });",
                    "      }",
                    "    } else {",
                    "      switch (doc.type) {",
                    "        case \"indent\":",
                    "        case \"align\":",
                    "        case \"indent-if-break\":",
                    "        case \"label\":",
                    "          cmds.push({ mode, doc: doc.contents });",
                    "          break;",
                    "",
                    "        case \"trim\":",
                    "          width += trim(out);",
                    "          break;",
                    "",
                    "        case \"group\": {",
                    "          if (mustBeFlat && doc.break) {",
                    "            return false;",
                    "          }",
                    "          const groupMode = doc.break ? MODE_BREAK : mode;",
                    "          // The most expanded state takes up the least space on the current line.",
                    "          const contents =",
                    "            doc.expandedStates && groupMode === MODE_BREAK",
                    "              ? getLast(doc.expandedStates)",
                    "              : doc.contents;",
                    "          cmds.push({ mode: groupMode, doc: contents });",
                    "          break;",
                    "        }",
                    "",
                    "        case \"if-break\": {",
                    "          const groupMode = doc.groupId",
                    "            ? groupModeMap[doc.groupId] || MODE_FLAT",
                    "            : mode;",
                    "          const contents =",
                    "            groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;",
                    "          if (contents) {",
                    "            cmds.push({ mode, doc: contents });",
                    "          }",
                    "          break;",
                    "        }",
                    "",
                    "        case \"line\":",
                    "          if (mode === MODE_BREAK || doc.hard) {",
                    "            return true;",
                    "          }",
                    "          if (!doc.soft) {",
                    "            out.push(\" \");",
                    "            width--;",
                    "          }",
                    "          break;",
                    "",
                    "        case \"line-suffix\":",
                    "          hasLineSuffix = true;",
                    "          break;",
                    "",
                    "        case \"line-suffix-boundary\":",
                    "          if (hasLineSuffix) {",
                    "            return false;",
                    "          }",
                    "          break;",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function printDocToString(doc, options) {",
                    "  groupModeMap = {};",
                    "",
                    "  const width = options.printWidth;",
                    "  const newLine = convertEndOfLineToChars(options.endOfLine);",
                    "  let pos = 0;",
                    "  // cmds is basically a stack. We've turned a recursive call into a",
                    "  // while loop which is much faster. The while loop below adds new",
                    "  // cmds to the array instead of recursively calling `print`.",
                    "  /** @type Command[] */",
                    "  const cmds = [{ ind: rootIndent(), mode: MODE_BREAK, doc }];",
                    "  const out = [];",
                    "  let shouldRemeasure = false;",
                    "  /** @type Command[] */",
                    "  const lineSuffix = [];",
                    "",
                    "  while (cmds.length > 0) {",
                    "    const { ind, mode, doc } = cmds.pop();",
                    "",
                    "    if (typeof doc === \"string\") {",
                    "      const formatted = newLine !== \"\\n\" ? doc.replace(/\\n/g, newLine) : doc;",
                    "      out.push(formatted);",
                    "      pos += getStringWidth(formatted);",
                    "    } else if (isConcat(doc)) {",
                    "      const parts = getDocParts(doc);",
                    "      for (let i = parts.length - 1; i >= 0; i--) {",
                    "        cmds.push({ ind, mode, doc: parts[i] });",
                    "      }",
                    "    } else {",
                    "      switch (doc.type) {",
                    "        case \"cursor\":",
                    "          out.push(cursor.placeholder);",
                    "",
                    "          break;",
                    "        case \"indent\":",
                    "          cmds.push({ ind: makeIndent(ind, options), mode, doc: doc.contents });",
                    "",
                    "          break;",
                    "        case \"align\":",
                    "          cmds.push({",
                    "            ind: makeAlign(ind, doc.n, options),",
                    "            mode,",
                    "            doc: doc.contents,",
                    "          });",
                    "",
                    "          break;",
                    "        case \"trim\":",
                    "          pos -= trim(out);",
                    "",
                    "          break;",
                    "        case \"group\":",
                    "          switch (mode) {",
                    "            case MODE_FLAT:",
                    "              if (!shouldRemeasure) {",
                    "                cmds.push({",
                    "                  ind,",
                    "                  mode: doc.break ? MODE_BREAK : MODE_FLAT,",
                    "                  doc: doc.contents,",
                    "                });",
                    "",
                    "                break;",
                    "              }",
                    "            // fallthrough",
                    "",
                    "            case MODE_BREAK: {",
                    "              shouldRemeasure = false;",
                    "",
                    "              const next = { ind, mode: MODE_FLAT, doc: doc.contents };",
                    "              const rem = width - pos;",
                    "              const hasLineSuffix = lineSuffix.length > 0;",
                    "",
                    "              if (!doc.break && fits(next, cmds, rem, hasLineSuffix)) {",
                    "                cmds.push(next);",
                    "              } else {",
                    "                // Expanded states are a rare case where a document",
                    "                // can manually provide multiple representations of",
                    "                // itself. It provides an array of documents",
                    "                // going from the least expanded (most flattened)",
                    "                // representation first to the most expanded. If a",
                    "                // group has these, we need to manually go through",
                    "                // these states and find the first one that fits.",
                    "                if (doc.expandedStates) {",
                    "                  const mostExpanded = getLast(doc.expandedStates);",
                    "",
                    "                  if (doc.break) {",
                    "                    cmds.push({ ind, mode: MODE_BREAK, doc: mostExpanded });",
                    "",
                    "                    break;",
                    "                  } else {",
                    "                    for (let i = 1; i < doc.expandedStates.length + 1; i++) {",
                    "                      if (i >= doc.expandedStates.length) {",
                    "                        cmds.push({ ind, mode: MODE_BREAK, doc: mostExpanded });",
                    "",
                    "                        break;",
                    "                      } else {",
                    "                        const state = doc.expandedStates[i];",
                    "                        const cmd = { ind, mode: MODE_FLAT, doc: state };",
                    "",
                    "                        if (fits(cmd, cmds, rem, hasLineSuffix)) {",
                    "                          cmds.push(cmd);",
                    "",
                    "                          break;",
                    "                        }",
                    "                      }",
                    "                    }",
                    "                  }",
                    "                } else {",
                    "                  cmds.push({ ind, mode: MODE_BREAK, doc: doc.contents });",
                    "                }",
                    "              }",
                    "",
                    "              break;",
                    "            }",
                    "          }",
                    "",
                    "          if (doc.id) {",
                    "            groupModeMap[doc.id] = getLast(cmds).mode;",
                    "          }",
                    "          break;",
                    "        // Fills each line with as much code as possible before moving to a new",
                    "        // line with the same indentation.",
                    "        //",
                    "        // Expects doc.parts to be an array of alternating content and",
                    "        // whitespace. The whitespace contains the linebreaks.",
                    "        //",
                    "        // For example:",
                    "        //   [\"I\", line, \"love\", line, \"monkeys\"]",
                    "        // or",
                    "        //   [{ type: group, ... }, softline, { type: group, ... }]",
                    "        //",
                    "        // It uses this parts structure to handle three main layout cases:",
                    "        // * The first two content items fit on the same line without",
                    "        //   breaking",
                    "        //   -> output the first content item and the whitespace \"flat\".",
                    "        // * Only the first content item fits on the line without breaking",
                    "        //   -> output the first content item \"flat\" and the whitespace with",
                    "        //   \"break\".",
                    "        // * Neither content item fits on the line without breaking",
                    "        //   -> output the first content item and the whitespace with \"break\".",
                    "        case \"fill\": {",
                    "          const rem = width - pos;",
                    "",
                    "          const { parts } = doc;",
                    "          if (parts.length === 0) {",
                    "            break;",
                    "          }",
                    "",
                    "          const [content, whitespace] = parts;",
                    "          const contentFlatCmd = { ind, mode: MODE_FLAT, doc: content };",
                    "          const contentBreakCmd = { ind, mode: MODE_BREAK, doc: content };",
                    "          const contentFits = fits(",
                    "            contentFlatCmd,",
                    "            [],",
                    "            rem,",
                    "            lineSuffix.length > 0,",
                    "            true",
                    "          );",
                    "",
                    "          if (parts.length === 1) {",
                    "            if (contentFits) {",
                    "              cmds.push(contentFlatCmd);",
                    "            } else {",
                    "              cmds.push(contentBreakCmd);",
                    "            }",
                    "            break;",
                    "          }",
                    "",
                    "          const whitespaceFlatCmd = { ind, mode: MODE_FLAT, doc: whitespace };",
                    "          const whitespaceBreakCmd = { ind, mode: MODE_BREAK, doc: whitespace };",
                    "",
                    "          if (parts.length === 2) {",
                    "            if (contentFits) {",
                    "              cmds.push(whitespaceFlatCmd, contentFlatCmd);",
                    "            } else {",
                    "              cmds.push(whitespaceBreakCmd, contentBreakCmd);",
                    "            }",
                    "            break;",
                    "          }",
                    "",
                    "          // At this point we've handled the first pair (context, separator)",
                    "          // and will create a new fill doc for the rest of the content.",
                    "          // Ideally we wouldn't mutate the array here but copying all the",
                    "          // elements to a new array would make this algorithm quadratic,",
                    "          // which is unusable for large arrays (e.g. large texts in JSX).",
                    "          parts.splice(0, 2);",
                    "          const remainingCmd = { ind, mode, doc: fill(parts) };",
                    "",
                    "          const secondContent = parts[0];",
                    "",
                    "          const firstAndSecondContentFlatCmd = {",
                    "            ind,",
                    "            mode: MODE_FLAT,",
                    "            doc: [content, whitespace, secondContent],",
                    "          };",
                    "          const firstAndSecondContentFits = fits(",
                    "            firstAndSecondContentFlatCmd,",
                    "            [],",
                    "            rem,",
                    "            lineSuffix.length > 0,",
                    "            true",
                    "          );",
                    "",
                    "          if (firstAndSecondContentFits) {",
                    "            cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);",
                    "          } else if (contentFits) {",
                    "            cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);",
                    "          } else {",
                    "            cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);",
                    "          }",
                    "          break;",
                    "        }",
                    "        case \"if-break\":",
                    "        case \"indent-if-break\": {",
                    "          const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                    "          if (groupMode === MODE_BREAK) {",
                    "            const breakContents =",
                    "              doc.type === \"if-break\"",
                    "                ? doc.breakContents",
                    "                : doc.negate",
                    "                ? doc.contents",
                    "                : indent(doc.contents);",
                    "            if (breakContents) {",
                    "              cmds.push({ ind, mode, doc: breakContents });",
                    "            }",
                    "          }",
                    "          if (groupMode === MODE_FLAT) {",
                    "            const flatContents =",
                    "              doc.type === \"if-break\"",
                    "                ? doc.flatContents",
                    "                : doc.negate",
                    "                ? indent(doc.contents)",
                    "                : doc.contents;",
                    "            if (flatContents) {",
                    "              cmds.push({ ind, mode, doc: flatContents });",
                    "            }",
                    "          }",
                    "",
                    "          break;",
                    "        }",
                    "        case \"line-suffix\":",
                    "          lineSuffix.push({ ind, mode, doc: doc.contents });",
                    "          break;",
                    "        case \"line-suffix-boundary\":",
                    "          if (lineSuffix.length > 0) {",
                    "            cmds.push({ ind, mode, doc: { type: \"line\", hard: true } });",
                    "          }",
                    "          break;",
                    "        case \"line\":",
                    "          switch (mode) {",
                    "            case MODE_FLAT:",
                    "              if (!doc.hard) {",
                    "                if (!doc.soft) {",
                    "                  out.push(\" \");",
                    "",
                    "                  pos += 1;",
                    "                }",
                    "",
                    "                break;",
                    "              } else {",
                    "                // This line was forced into the output even if we",
                    "                // were in flattened mode, so we need to tell the next",
                    "                // group that no matter what, it needs to remeasure",
                    "                // because the previous measurement didn't accurately",
                    "                // capture the entire expression (this is necessary",
                    "                // for nested groups)",
                    "                shouldRemeasure = true;",
                    "              }",
                    "            // fallthrough",
                    "",
                    "            case MODE_BREAK:",
                    "              if (lineSuffix.length > 0) {",
                    "                cmds.push({ ind, mode, doc }, ...lineSuffix.reverse());",
                    "                lineSuffix.length = 0;",
                    "                break;",
                    "              }",
                    "",
                    "              if (doc.literal) {",
                    "                if (ind.root) {",
                    "                  out.push(newLine, ind.root.value);",
                    "                  pos = ind.root.length;",
                    "                } else {",
                    "                  out.push(newLine);",
                    "                  pos = 0;",
                    "                }",
                    "              } else {",
                    "                pos -= trim(out);",
                    "                out.push(newLine + ind.value);",
                    "                pos = ind.length;",
                    "              }",
                    "              break;",
                    "          }",
                    "          break;",
                    "        case \"label\":",
                    "          cmds.push({ ind, mode, doc: doc.contents });",
                    "          break;",
                    "        default:",
                    "      }",
                    "    }",
                    "",
                    "    // Flush remaining line-suffix contents at the end of the document, in case",
                    "    // there is no new line after the line-suffix.",
                    "    if (cmds.length === 0 && lineSuffix.length > 0) {",
                    "      cmds.push(...lineSuffix.reverse());",
                    "      lineSuffix.length = 0;",
                    "    }",
                    "  }",
                    "",
                    "  const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);",
                    "  if (cursorPlaceholderIndex !== -1) {",
                    "    const otherCursorPlaceholderIndex = out.indexOf(",
                    "      cursor.placeholder,",
                    "      cursorPlaceholderIndex + 1",
                    "    );",
                    "    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");",
                    "    const aroundCursor = out",
                    "      .slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex)",
                    "      .join(\"\");",
                    "    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");",
                    "",
                    "    return {",
                    "      formatted: beforeCursor + aroundCursor + afterCursor,",
                    "      cursorNodeStart: beforeCursor.length,",
                    "      cursorNodeText: aroundCursor,",
                    "    };",
                    "  }",
                    "",
                    "  return { formatted: out.join(\"\") };",
                    "}",
                    "",
                    "module.exports = { printDocToString };"
                ]
            },
            "doc-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const { literalline, join } = require(\"./doc-builders.js\");",
                    "",
                    "const isConcat = (doc) => Array.isArray(doc) || (doc && doc.type === \"concat\");",
                    "const getDocParts = (doc) => {",
                    "  if (Array.isArray(doc)) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (doc.type !== \"concat\" && doc.type !== \"fill\") {",
                    "    throw new Error(\"Expect doc type to be `concat` or `fill`.\");",
                    "  }",
                    "",
                    "  return doc.parts;",
                    "};",
                    "",
                    "// Using a unique object to compare by reference.",
                    "const traverseDocOnExitStackMarker = {};",
                    "",
                    "function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {",
                    "  const docsStack = [doc];",
                    "",
                    "  while (docsStack.length > 0) {",
                    "    const doc = docsStack.pop();",
                    "",
                    "    if (doc === traverseDocOnExitStackMarker) {",
                    "      onExit(docsStack.pop());",
                    "      continue;",
                    "    }",
                    "",
                    "    if (onExit) {",
                    "      docsStack.push(doc, traverseDocOnExitStackMarker);",
                    "    }",
                    "",
                    "    if (",
                    "      // Should Recurse",
                    "      !onEnter ||",
                    "      onEnter(doc) !== false",
                    "    ) {",
                    "      // When there are multiple parts to process,",
                    "      // the parts need to be pushed onto the stack in reverse order,",
                    "      // so that they are processed in the original order",
                    "      // when the stack is popped.",
                    "      if (isConcat(doc) || doc.type === \"fill\") {",
                    "        const parts = getDocParts(doc);",
                    "        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {",
                    "          docsStack.push(parts[i]);",
                    "        }",
                    "      } else if (doc.type === \"if-break\") {",
                    "        if (doc.flatContents) {",
                    "          docsStack.push(doc.flatContents);",
                    "        }",
                    "        if (doc.breakContents) {",
                    "          docsStack.push(doc.breakContents);",
                    "        }",
                    "      } else if (doc.type === \"group\" && doc.expandedStates) {",
                    "        if (shouldTraverseConditionalGroups) {",
                    "          for (let ic = doc.expandedStates.length, i = ic - 1; i >= 0; --i) {",
                    "            docsStack.push(doc.expandedStates[i]);",
                    "          }",
                    "        } else {",
                    "          docsStack.push(doc.contents);",
                    "        }",
                    "      } else if (doc.contents) {",
                    "        docsStack.push(doc.contents);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function mapDoc(doc, cb) {",
                    "  // Within a doc tree, the same subtrees can be found multiple times.",
                    "  // E.g., often this happens in conditional groups.",
                    "  // As an optimization (those subtrees can be huge) and to maintain the",
                    "  // reference structure of the tree, the mapping results are cached in",
                    "  // a map and reused.",
                    "  const mapped = new Map();",
                    "",
                    "  return rec(doc);",
                    "",
                    "  function rec(doc) {",
                    "    if (mapped.has(doc)) {",
                    "      return mapped.get(doc);",
                    "    }",
                    "    const result = process(doc);",
                    "    mapped.set(doc, result);",
                    "    return result;",
                    "  }",
                    "",
                    "  function process(doc) {",
                    "    if (Array.isArray(doc)) {",
                    "      return cb(doc.map(rec));",
                    "    }",
                    "",
                    "    if (doc.type === \"concat\" || doc.type === \"fill\") {",
                    "      const parts = doc.parts.map(rec);",
                    "      return cb({ ...doc, parts });",
                    "    }",
                    "",
                    "    if (doc.type === \"if-break\") {",
                    "      const breakContents = doc.breakContents && rec(doc.breakContents);",
                    "      const flatContents = doc.flatContents && rec(doc.flatContents);",
                    "      return cb({ ...doc, breakContents, flatContents });",
                    "    }",
                    "",
                    "    if (doc.type === \"group\" && doc.expandedStates) {",
                    "      const expandedStates = doc.expandedStates.map(rec);",
                    "      const contents = expandedStates[0];",
                    "      return cb({ ...doc, contents, expandedStates });",
                    "    }",
                    "",
                    "    if (doc.contents) {",
                    "      const contents = rec(doc.contents);",
                    "      return cb({ ...doc, contents });",
                    "    }",
                    "",
                    "    return cb(doc);",
                    "  }",
                    "}",
                    "",
                    "function findInDoc(doc, fn, defaultValue) {",
                    "  let result = defaultValue;",
                    "  let hasStopped = false;",
                    "  function findInDocOnEnterFn(doc) {",
                    "    const maybeResult = fn(doc);",
                    "    if (maybeResult !== undefined) {",
                    "      hasStopped = true;",
                    "      result = maybeResult;",
                    "    }",
                    "    if (hasStopped) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "  traverseDoc(doc, findInDocOnEnterFn);",
                    "  return result;",
                    "}",
                    "",
                    "function willBreakFn(doc) {",
                    "  if (doc.type === \"group\" && doc.break) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === \"line\" && doc.hard) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === \"break-parent\") {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function willBreak(doc) {",
                    "  return findInDoc(doc, willBreakFn, false);",
                    "}",
                    "",
                    "function breakParentGroup(groupStack) {",
                    "  if (groupStack.length > 0) {",
                    "    const parentGroup = getLast(groupStack);",
                    "    // Breaks are not propagated through conditional groups because",
                    "    // the user is expected to manually handle what breaks.",
                    "    if (!parentGroup.expandedStates && !parentGroup.break) {",
                    "      // An alternative truthy value allows to distinguish propagated group breaks",
                    "      // and not to print them as `group(..., { break: true })` in `--debug-print-doc`.",
                    "      parentGroup.break = \"propagated\";",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function propagateBreaks(doc) {",
                    "  const alreadyVisitedSet = new Set();",
                    "  const groupStack = [];",
                    "  function propagateBreaksOnEnterFn(doc) {",
                    "    if (doc.type === \"break-parent\") {",
                    "      breakParentGroup(groupStack);",
                    "    }",
                    "    if (doc.type === \"group\") {",
                    "      groupStack.push(doc);",
                    "      if (alreadyVisitedSet.has(doc)) {",
                    "        return false;",
                    "      }",
                    "      alreadyVisitedSet.add(doc);",
                    "    }",
                    "  }",
                    "  function propagateBreaksOnExitFn(doc) {",
                    "    if (doc.type === \"group\") {",
                    "      const group = groupStack.pop();",
                    "      if (group.break) {",
                    "        breakParentGroup(groupStack);",
                    "      }",
                    "    }",
                    "  }",
                    "  traverseDoc(",
                    "    doc,",
                    "    propagateBreaksOnEnterFn,",
                    "    propagateBreaksOnExitFn,",
                    "    /* shouldTraverseConditionalGroups */ true",
                    "  );",
                    "}",
                    "",
                    "function removeLinesFn(doc) {",
                    "  // Force this doc into flat mode by statically converting all",
                    "  // lines into spaces (or soft lines into nothing). Hard lines",
                    "  // should still output because there's too great of a chance",
                    "  // of breaking existing assumptions otherwise.",
                    "  if (doc.type === \"line\" && !doc.hard) {",
                    "    return doc.soft ? \"\" : \" \";",
                    "  }",
                    "",
                    "  if (doc.type === \"if-break\") {",
                    "    return doc.flatContents || \"\";",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function removeLines(doc) {",
                    "  return mapDoc(doc, removeLinesFn);",
                    "}",
                    "",
                    "const isHardline = (doc, nextDoc) =>",
                    "  doc &&",
                    "  doc.type === \"line\" &&",
                    "  doc.hard &&",
                    "  nextDoc &&",
                    "  nextDoc.type === \"break-parent\";",
                    "function stripDocTrailingHardlineFromDoc(doc) {",
                    "  if (!doc) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  if (isConcat(doc) || doc.type === \"fill\") {",
                    "    const parts = getDocParts(doc);",
                    "",
                    "    while (parts.length > 1 && isHardline(...parts.slice(-2))) {",
                    "      parts.length -= 2;",
                    "    }",
                    "",
                    "    if (parts.length > 0) {",
                    "      const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));",
                    "      parts[parts.length - 1] = lastPart;",
                    "    }",
                    "    return Array.isArray(doc) ? parts : { ...doc, parts };",
                    "  }",
                    "",
                    "  switch (doc.type) {",
                    "    case \"align\":",
                    "    case \"indent\":",
                    "    case \"indent-if-break\":",
                    "    case \"group\":",
                    "    case \"line-suffix\":",
                    "    case \"label\": {",
                    "      const contents = stripDocTrailingHardlineFromDoc(doc.contents);",
                    "      return { ...doc, contents };",
                    "    }",
                    "    case \"if-break\": {",
                    "      const breakContents = stripDocTrailingHardlineFromDoc(doc.breakContents);",
                    "      const flatContents = stripDocTrailingHardlineFromDoc(doc.flatContents);",
                    "      return { ...doc, breakContents, flatContents };",
                    "    }",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function stripTrailingHardline(doc) {",
                    "  // HACK remove ending hardline, original PR: #1984",
                    "  return stripDocTrailingHardlineFromDoc(cleanDoc(doc));",
                    "}",
                    "",
                    "function cleanDocFn(doc) {",
                    "  switch (doc.type) {",
                    "    case \"fill\":",
                    "      if (doc.parts.every((part) => part === \"\")) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case \"group\":",
                    "      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {",
                    "        return \"\";",
                    "      }",
                    "      // Remove nested only group",
                    "      if (",
                    "        doc.contents.type === \"group\" &&",
                    "        doc.contents.id === doc.id &&",
                    "        doc.contents.break === doc.break &&",
                    "        doc.contents.expandedStates === doc.expandedStates",
                    "      ) {",
                    "        return doc.contents;",
                    "      }",
                    "      break;",
                    "    case \"align\":",
                    "    case \"indent\":",
                    "    case \"indent-if-break\":",
                    "    case \"line-suffix\":",
                    "      if (!doc.contents) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case \"if-break\":",
                    "      if (!doc.flatContents && !doc.breakContents) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "  }",
                    "",
                    "  if (!isConcat(doc)) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  const parts = [];",
                    "  for (const part of getDocParts(doc)) {",
                    "    if (!part) {",
                    "      continue;",
                    "    }",
                    "    const [currentPart, ...restParts] = isConcat(part)",
                    "      ? getDocParts(part)",
                    "      : [part];",
                    "    if (typeof currentPart === \"string\" && typeof getLast(parts) === \"string\") {",
                    "      parts[parts.length - 1] += currentPart;",
                    "    } else {",
                    "      parts.push(currentPart);",
                    "    }",
                    "    parts.push(...restParts);",
                    "  }",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (parts.length === 1) {",
                    "    return parts[0];",
                    "  }",
                    "  return Array.isArray(doc) ? parts : { ...doc, parts };",
                    "}",
                    "// A safer version of `normalizeDoc`",
                    "// - `normalizeDoc` concat strings and flat \"concat\" in `fill`, while `cleanDoc` don't",
                    "// - On `concat` object, `normalizeDoc` always return object with `parts`, `cleanDoc` may return strings",
                    "// - `cleanDoc` also remove nested `group`s and empty `fill`/`align`/`indent`/`line-suffix`/`if-break` if possible",
                    "function cleanDoc(doc) {",
                    "  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));",
                    "}",
                    "",
                    "function normalizeParts(parts) {",
                    "  const newParts = [];",
                    "",
                    "  const restParts = parts.filter(Boolean);",
                    "  while (restParts.length > 0) {",
                    "    const part = restParts.shift();",
                    "",
                    "    if (!part) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (isConcat(part)) {",
                    "      restParts.unshift(...getDocParts(part));",
                    "      continue;",
                    "    }",
                    "",
                    "    if (",
                    "      newParts.length > 0 &&",
                    "      typeof getLast(newParts) === \"string\" &&",
                    "      typeof part === \"string\"",
                    "    ) {",
                    "      newParts[newParts.length - 1] += part;",
                    "      continue;",
                    "    }",
                    "",
                    "    newParts.push(part);",
                    "  }",
                    "",
                    "  return newParts;",
                    "}",
                    "",
                    "function normalizeDoc(doc) {",
                    "  return mapDoc(doc, (currentDoc) => {",
                    "    if (Array.isArray(currentDoc)) {",
                    "      return normalizeParts(currentDoc);",
                    "    }",
                    "    if (!currentDoc.parts) {",
                    "      return currentDoc;",
                    "    }",
                    "    return {",
                    "      ...currentDoc,",
                    "      parts: normalizeParts(currentDoc.parts),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "function replaceEndOfLine(doc) {",
                    "  return mapDoc(doc, (currentDoc) =>",
                    "    typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\")",
                    "      ? replaceTextEndOfLine(currentDoc)",
                    "      : currentDoc",
                    "  );",
                    "}",
                    "",
                    "// This function need return array",
                    "// TODO: remove `.parts` when we remove `docBuilders.concat()`",
                    "function replaceTextEndOfLine(text, replacement = literalline) {",
                    "  return join(replacement, text.split(\"\\n\")).parts;",
                    "}",
                    "",
                    "function canBreakFn(doc) {",
                    "  if (doc.type === \"line\") {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function canBreak(doc) {",
                    "  return findInDoc(doc, canBreakFn, false);",
                    "}",
                    "",
                    "module.exports = {",
                    "  isConcat,",
                    "  getDocParts,",
                    "  willBreak,",
                    "  traverseDoc,",
                    "  findInDoc,",
                    "  mapDoc,",
                    "  propagateBreaks,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  normalizeParts,",
                    "  normalizeDoc,",
                    "  cleanDoc,",
                    "  replaceTextEndOfLine,",
                    "  replaceEndOfLine,",
                    "  canBreak,",
                    "};"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./doc-builders\").Doc} Doc",
                    " */",
                    "",
                    "module.exports = {",
                    "  builders: require(\"./doc-builders.js\"),",
                    "  printer: require(\"./doc-printer.js\"),",
                    "  utils: require(\"./doc-utils.js\"),",
                    "  debug: require(\"./doc-debug.js\"),",
                    "};"
                ]
            }
        },
        "language-css": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isFrontMatterNode } = require(\"../common/util.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"raw\", // front-matter",
                    "  \"raws\",",
                    "  \"sourceIndex\",",
                    "  \"source\",",
                    "  \"before\",",
                    "  \"after\",",
                    "  \"trailingComma\",",
                    "]);",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  if (isFrontMatterNode(ast) && ast.lang === \"yaml\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"css-comment\" &&",
                    "    parent.type === \"css-root\" &&",
                    "    parent.nodes.length > 0",
                    "  ) {",
                    "    // --insert-pragma",
                    "    // first non-front-matter comment",
                    "    if (",
                    "      parent.nodes[0] === ast ||",
                    "      (isFrontMatterNode(parent.nodes[0]) && parent.nodes[1] === ast)",
                    "    ) {",
                    "      /**",
                    "       * something",
                    "       *",
                    "       * @format",
                    "       */",
                    "      delete newObj.text;",
                    "",
                    "      // standalone pragma",
                    "      if (/^\\*\\s*@(?:format|prettier)\\s*$/.test(ast.text)) {",
                    "        return null;",
                    "      }",
                    "    }",
                    "",
                    "    // Last comment is not parsed, when omitting semicolon, #8675",
                    "    if (parent.type === \"css-root\" && getLast(parent.nodes) === ast) {",
                    "      return null;",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"value-root\") {",
                    "    delete newObj.text;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"media-query\" ||",
                    "    ast.type === \"media-query-list\" ||",
                    "    ast.type === \"media-feature-expression\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"css-rule\") {",
                    "    delete newObj.params;",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-combinator\") {",
                    "    newObj.value = newObj.value.replace(/\\s+/g, \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"media-feature\") {",
                    "    newObj.value = newObj.value.replace(/ /g, \"\");",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"value-word\" &&",
                    "      ((ast.isColor && ast.isHex) ||",
                    "        [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(",
                    "          newObj.value.replace().toLowerCase()",
                    "        ))) ||",
                    "    ast.type === \"media-feature\" ||",
                    "    ast.type === \"selector-root-invalid\" ||",
                    "    ast.type === \"selector-pseudo\"",
                    "  ) {",
                    "    newObj.value = newObj.value.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-decl\") {",
                    "    newObj.prop = newObj.prop.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-atrule\" || ast.type === \"css-import\") {",
                    "    newObj.name = newObj.name.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"value-number\") {",
                    "    newObj.unit = newObj.unit.toLowerCase();",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-feature\" ||",
                    "      ast.type === \"media-keyword\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"media-unknown\" ||",
                    "      ast.type === \"media-url\" ||",
                    "      ast.type === \"media-value\" ||",
                    "      ast.type === \"selector-attribute\" ||",
                    "      ast.type === \"selector-string\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"value-string\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = cleanCSSStrings(newObj.value);",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-attribute\") {",
                    "    newObj.attribute = newObj.attribute.trim();",
                    "",
                    "    if (newObj.namespace) {",
                    "      if (typeof newObj.namespace === \"string\") {",
                    "        newObj.namespace = newObj.namespace.trim();",
                    "",
                    "        if (newObj.namespace.length === 0) {",
                    "          newObj.namespace = true;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (newObj.value) {",
                    "      newObj.value = newObj.value.trim().replace(/^[\"']|[\"']$/g, \"\");",
                    "      delete newObj.quoted;",
                    "    }",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-value\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"value-number\" ||",
                    "      ast.type === \"selector-root-invalid\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"selector-tag\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = newObj.value.replace(",
                    "      /([\\d+.Ee-]+)([A-Za-z]*)/g,",
                    "      (match, numStr, unit) => {",
                    "        const num = Number(numStr);",
                    "        return Number.isNaN(num) ? match : num + unit.toLowerCase();",
                    "      }",
                    "    );",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-tag\") {",
                    "    const lowercasedValue = ast.value.toLowerCase();",
                    "",
                    "    if ([\"from\", \"to\"].includes(lowercasedValue)) {",
                    "      newObj.value = lowercasedValue;",
                    "    }",
                    "  }",
                    "",
                    "  // Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`",
                    "  if (ast.type === \"css-atrule\" && ast.name.toLowerCase() === \"supports\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // Workaround for SCSS nested properties",
                    "  if (ast.type === \"selector-unknown\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // Workaround for SCSS arbitrary arguments",
                    "  if (ast.type === \"value-comma_group\") {",
                    "    const index = ast.groups.findIndex(",
                    "      (node) => node.type === \"value-number\" && node.unit === \"...\"",
                    "    );",
                    "",
                    "    if (index !== -1) {",
                    "      newObj.groups[index].unit = \"\";",
                    "      newObj.groups.splice(index + 1, 0, {",
                    "        type: \"value-word\",",
                    "        value: \"...\",",
                    "        isColor: false,",
                    "        isHex: false,",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  // We parse `@var[ foo ]` and `@var[foo]` differently",
                    "  if (",
                    "    ast.type === \"value-comma_group\" &&",
                    "    ast.groups.some(",
                    "      (node) =>",
                    "        (node.type === \"value-atword\" && node.value.endsWith(\"[\")) ||",
                    "        (node.type === \"value-word\" && node.value.startsWith(\"]\"))",
                    "    )",
                    "  ) {",
                    "    return {",
                    "      type: \"value-atword\",",
                    "      value: ast.groups.map((node) => node.value).join(\"\"),",
                    "      group: {",
                    "        open: null,",
                    "        close: null,",
                    "        groups: [],",
                    "        type: \"value-paren_group\",",
                    "      },",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "function cleanCSSStrings(value) {",
                    "  return value.replace(/'/g, '\"').replace(/\\\\([^\\dA-Fa-f])/g, \"$1\");",
                    "}",
                    "",
                    "module.exports = clean;"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const {",
                    "  builders: { hardline },",
                    "} = require(\"../document/index.js\");",
                    "const printFrontMatter = require(\"../utils/front-matter/print.js\");",
                    "",
                    "function embed(path, print, textToDoc /*, options */) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (node.type === \"front-matter\") {",
                    "    const doc = printFrontMatter(node, textToDoc);",
                    "    return doc ? [doc, hardline] : \"\";",
                    "  }",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-postcss.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/CSS.json\"), (data) => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"css\"],",
                    "    extensions: [",
                    "      ...data.extensions,",
                    "      // `WeiXin Style Sheets`(Weixin Mini Programs)",
                    "      // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                    "      \".wxss\",",
                    "    ],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/PostCSS.json\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"postcss\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/Less.json\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"less\"],",
                    "    vscodeLanguageIds: [\"less\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/SCSS.json\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"scss\"],",
                    "    vscodeLanguageIds: [\"scss\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  postcss: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { skipEverythingButNewLine } = require(\"../utils/text/skip.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const lineColumnToIndex = require(\"../utils/line-column-to-index.js\");",
                    "",
                    "function calculateLocStart(node, text) {",
                    "  // value-* nodes have this",
                    "  if (typeof node.sourceIndex === \"number\") {",
                    "    return node.sourceIndex;",
                    "  }",
                    "",
                    "  return node.source ? lineColumnToIndex(node.source.start, text) - 1 : null;",
                    "}",
                    "",
                    "function calculateLocEnd(node, text) {",
                    "  if (node.type === \"css-comment\" && node.inline) {",
                    "    return skipEverythingButNewLine(text, node.source.startOffset);",
                    "  }",
                    "  const endNode = node.nodes && getLast(node.nodes);",
                    "  if (endNode && node.source && !node.source.end) {",
                    "    node = endNode;",
                    "  }",
                    "  if (node.source && node.source.end) {",
                    "    return lineColumnToIndex(node.source.end, text);",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function calculateLoc(node, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text);",
                    "    node.source.endOffset = calculateLocEnd(node, text);",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (child.type === \"value-root\" || child.type === \"value-unknown\") {",
                    "      calculateValueNodeLoc(",
                    "        child,",
                    "        getValueRootOffset(node),",
                    "        child.text || child.value",
                    "      );",
                    "    } else {",
                    "      calculateLoc(child, text);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function calculateValueNodeLoc(node, rootOffset, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text) + rootOffset;",
                    "    node.source.endOffset = calculateLocEnd(node, text) + rootOffset;",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    calculateValueNodeLoc(child, rootOffset, text);",
                    "  }",
                    "}",
                    "",
                    "function getValueRootOffset(node) {",
                    "  let result = node.source.startOffset;",
                    "  if (typeof node.prop === \"string\") {",
                    "    result += node.prop.length;",
                    "  }",
                    "",
                    "  if (node.type === \"css-atrule\" && typeof node.name === \"string\") {",
                    "    result +=",
                    "      1 + node.name.length + node.raws.afterName.match(/^\\s*:?\\s*/)[0].length;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type !== \"css-atrule\" &&",
                    "    node.raws &&",
                    "    typeof node.raws.between === \"string\"",
                    "  ) {",
                    "    result += node.raws.between.length;",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "/**",
                    " * Workaround for a bug: quotes and asterisks in inline comments corrupt loc data of subsequent nodes.",
                    " * This function replaces the quotes and asterisks with spaces. Later, when the comments are printed,",
                    " * their content is extracted from the original text.",
                    " * - https://github.com/prettier/prettier/issues/7780",
                    " * - https://github.com/shellscape/postcss-less/issues/145",
                    " * - https://github.com/prettier/prettier/issues/8130",
                    " * @param text {string}",
                    " */",
                    "function replaceQuotesInInlineComments(text) {",
                    "  /** @typedef { 'initial' | 'single-quotes' | 'double-quotes' | 'url' | 'comment-block' | 'comment-inline' } State */",
                    "  /** @type {State} */",
                    "  let state = \"initial\";",
                    "  /** @type {State} */",
                    "  let stateToReturnFromQuotes = \"initial\";",
                    "  let inlineCommentStartIndex;",
                    "  let inlineCommentContainsQuotes = false;",
                    "  const inlineCommentsToReplace = [];",
                    "",
                    "  for (let i = 0; i < text.length; i++) {",
                    "    const c = text[i];",
                    "",
                    "    switch (state) {",
                    "      case \"initial\":",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          (c === \"u\" || c === \"U\") &&",
                    "          text.slice(i, i + 4).toLowerCase() === \"url(\"",
                    "        ) {",
                    "          state = \"url\";",
                    "          i += 3;",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"*\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-block\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"/\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-inline\";",
                    "          inlineCommentStartIndex = i - 1;",
                    "          continue;",
                    "        }",
                    "",
                    "        continue;",
                    "",
                    "      case \"single-quotes\":",
                    "        if (c === \"'\" && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"double-quotes\":",
                    "        if (c === '\"' && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"url\":",
                    "        if (c === \")\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-block\":",
                    "        if (c === \"/\" && text[i - 1] === \"*\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-inline\":",
                    "        if (c === '\"' || c === \"'\" || c === \"*\") {",
                    "          inlineCommentContainsQuotes = true;",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          if (inlineCommentContainsQuotes) {",
                    "            inlineCommentsToReplace.push([inlineCommentStartIndex, i]);",
                    "          }",
                    "          state = \"initial\";",
                    "          inlineCommentContainsQuotes = false;",
                    "        }",
                    "        continue;",
                    "    }",
                    "  }",
                    "",
                    "  for (const [start, end] of inlineCommentsToReplace) {",
                    "    text =",
                    "      text.slice(0, start) +",
                    "      text.slice(start, end).replace(/[\"'*]/g, \" \") +",
                    "      text.slice(end);",
                    "  }",
                    "",
                    "  return text;",
                    "}",
                    "",
                    "function locStart(node) {",
                    "  return node.source.startOffset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.source.endOffset;",
                    "}",
                    "",
                    "module.exports = {",
                    "  locStart,",
                    "  locEnd,",
                    "  calculateLoc,",
                    "  replaceQuotesInInlineComments,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};"
                ]
            },
            "parser-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const parseFrontMatter = require(\"../utils/front-matter/parse.js\");",
                    "const { hasPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const { calculateLoc, replaceQuotesInInlineComments } = require(\"./loc.js\");",
                    "const hasSCSSInterpolation = require(\"./utils/has-scss-interpolation.js\");",
                    "const hasStringOrFunction = require(\"./utils/has-string-or-function.js\");",
                    "const isLessParser = require(\"./utils/is-less-parser.js\");",
                    "const isSCSS = require(\"./utils/is-scss.js\");",
                    "const isSCSSNestedPropertyNode = require(\"./utils/is-scss-nested-property-node.js\");",
                    "const isSCSSVariable = require(\"./utils/is-scss-variable.js\");",
                    "const stringifyNode = require(\"./utils/stringify-node.js\");",
                    "const isModuleRuleName = require(\"./utils/is-module-rule-name.js\");",
                    "",
                    "const getHighestAncestor = (node) => {",
                    "  while (node.parent) {",
                    "    node = node.parent;",
                    "  }",
                    "  return node;",
                    "};",
                    "",
                    "function parseValueNode(valueNode, options) {",
                    "  const { nodes } = valueNode;",
                    "  let parenGroup = {",
                    "    open: null,",
                    "    close: null,",
                    "    groups: [],",
                    "    type: \"paren_group\",",
                    "  };",
                    "  const parenGroupStack = [parenGroup];",
                    "  const rootParenGroup = parenGroup;",
                    "  let commaGroup = {",
                    "    groups: [],",
                    "    type: \"comma_group\",",
                    "  };",
                    "  const commaGroupStack = [commaGroup];",
                    "",
                    "  for (let i = 0; i < nodes.length; ++i) {",
                    "    const node = nodes[i];",
                    "",
                    "    if (",
                    "      isSCSS(options.parser, node.value) &&",
                    "      node.type === \"number\" &&",
                    "      node.unit === \"..\" &&",
                    "      getLast(node.value) === \".\"",
                    "    ) {",
                    "      // Work around postcss bug parsing `50...` as `50.` with unit `..`",
                    "      // Set the unit to `...` to \"accidentally\" have arbitrary arguments work in the same way that cases where the node already had a unit work.",
                    "      // For example, 50px... is parsed as `50` with unit `px...` already by postcss-values-parser.",
                    "      node.value = node.value.slice(0, -1);",
                    "      node.unit = \"...\";",
                    "    }",
                    "",
                    "    if (node.type === \"func\" && node.value === \"selector\") {",
                    "      node.group.groups = [",
                    "        parseSelector(",
                    "          getHighestAncestor(valueNode).text.slice(",
                    "            node.group.open.sourceIndex + 1,",
                    "            node.group.close.sourceIndex",
                    "          )",
                    "        ),",
                    "      ];",
                    "    }",
                    "",
                    "    if (node.type === \"func\" && node.value === \"url\") {",
                    "      const groups = (node.group && node.group.groups) || [];",
                    "",
                    "      // Create a view with any top-level comma groups flattened.",
                    "      let groupList = [];",
                    "      for (let i = 0; i < groups.length; i++) {",
                    "        const group = groups[i];",
                    "        if (group.type === \"comma_group\") {",
                    "          groupList = [...groupList, ...group.groups];",
                    "        } else {",
                    "          groupList.push(group);",
                    "        }",
                    "      }",
                    "",
                    "      // Stringify if the value parser can't handle the content.",
                    "      if (",
                    "        hasSCSSInterpolation(groupList) ||",
                    "        (!hasStringOrFunction(groupList) && !isSCSSVariable(groupList[0]))",
                    "      ) {",
                    "        const stringifiedContent = stringifyNode({",
                    "          groups: node.group.groups,",
                    "        });",
                    "        node.group.groups = [stringifiedContent.trim()];",
                    "      }",
                    "    }",
                    "    if (node.type === \"paren\" && node.value === \"(\") {",
                    "      parenGroup = {",
                    "        open: node,",
                    "        close: null,",
                    "        groups: [],",
                    "        type: \"paren_group\",",
                    "      };",
                    "      parenGroupStack.push(parenGroup);",
                    "",
                    "      commaGroup = {",
                    "        groups: [],",
                    "        type: \"comma_group\",",
                    "      };",
                    "      commaGroupStack.push(commaGroup);",
                    "    } else if (node.type === \"paren\" && node.value === \")\") {",
                    "      if (commaGroup.groups.length > 0) {",
                    "        parenGroup.groups.push(commaGroup);",
                    "      }",
                    "      parenGroup.close = node;",
                    "",
                    "      /* istanbul ignore next */",
                    "      if (commaGroupStack.length === 1) {",
                    "        throw new Error(\"Unbalanced parenthesis\");",
                    "      }",
                    "",
                    "      commaGroupStack.pop();",
                    "      commaGroup = getLast(commaGroupStack);",
                    "      commaGroup.groups.push(parenGroup);",
                    "",
                    "      parenGroupStack.pop();",
                    "      parenGroup = getLast(parenGroupStack);",
                    "    } else if (node.type === \"comma\") {",
                    "      parenGroup.groups.push(commaGroup);",
                    "      commaGroup = {",
                    "        groups: [],",
                    "        type: \"comma_group\",",
                    "      };",
                    "      commaGroupStack[commaGroupStack.length - 1] = commaGroup;",
                    "    } else {",
                    "      commaGroup.groups.push(node);",
                    "    }",
                    "  }",
                    "  if (commaGroup.groups.length > 0) {",
                    "    parenGroup.groups.push(commaGroup);",
                    "  }",
                    "  return rootParenGroup;",
                    "}",
                    "",
                    "function flattenGroups(node) {",
                    "  if (",
                    "    node.type === \"paren_group\" &&",
                    "    !node.open &&",
                    "    !node.close &&",
                    "    node.groups.length === 1",
                    "  ) {",
                    "    return flattenGroups(node.groups[0]);",
                    "  }",
                    "",
                    "  if (node.type === \"comma_group\" && node.groups.length === 1) {",
                    "    return flattenGroups(node.groups[0]);",
                    "  }",
                    "",
                    "  if (node.type === \"paren_group\" || node.type === \"comma_group\") {",
                    "    return { ...node, groups: node.groups.map(flattenGroups) };",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function addTypePrefix(node, prefix, skipPrefix) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      addTypePrefix(node[key], prefix, skipPrefix);",
                    "      if (key === \"type\" && typeof node[key] === \"string\") {",
                    "        if (",
                    "          !node[key].startsWith(prefix) &&",
                    "          (!skipPrefix || !skipPrefix.test(node[key]))",
                    "        ) {",
                    "          node[key] = prefix + node[key];",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function addMissingType(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      addMissingType(node[key]);",
                    "    }",
                    "    if (!Array.isArray(node) && node.value && !node.type) {",
                    "      node.type = \"unknown\";",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function parseNestedValue(node, options) {",
                    "  if (node && typeof node === \"object\") {",
                    "    for (const key in node) {",
                    "      if (key !== \"parent\") {",
                    "        parseNestedValue(node[key], options);",
                    "        if (key === \"nodes\") {",
                    "          node.group = flattenGroups(parseValueNode(node, options));",
                    "          delete node[key];",
                    "        }",
                    "      }",
                    "    }",
                    "    delete node.parent;",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function parseValue(value, options) {",
                    "  const valueParser = require(\"postcss-values-parser\");",
                    "",
                    "  let result = null;",
                    "",
                    "  try {",
                    "    result = valueParser(value, { loose: true }).parse();",
                    "  } catch {",
                    "    return {",
                    "      type: \"value-unknown\",",
                    "      value,",
                    "    };",
                    "  }",
                    "",
                    "  result.text = value;",
                    "",
                    "  const parsedResult = parseNestedValue(result, options);",
                    "",
                    "  return addTypePrefix(parsedResult, \"value-\", /^selector-/);",
                    "}",
                    "",
                    "function parseSelector(selector) {",
                    "  // If there's a comment inside of a selector, the parser tries to parse",
                    "  // the content of the comment as selectors which turns it into complete",
                    "  // garbage. Better to print the whole selector as-is and not try to parse",
                    "  // and reformat it.",
                    "  if (/\\/\\/|\\/\\*/.test(selector)) {",
                    "    return {",
                    "      type: \"selector-unknown\",",
                    "      value: selector.trim(),",
                    "    };",
                    "  }",
                    "",
                    "  const selectorParser = require(\"postcss-selector-parser\");",
                    "",
                    "  let result = null;",
                    "",
                    "  try {",
                    "    selectorParser((result_) => {",
                    "      result = result_;",
                    "    }).process(selector);",
                    "  } catch {",
                    "    // Fail silently. It's better to print it as is than to try and parse it",
                    "    // Note: A common failure is for SCSS nested properties. `background:",
                    "    // none { color: red; }` is parsed as a NestedDeclaration by",
                    "    // postcss-scss, while `background: { color: red; }` is parsed as a Rule",
                    "    // with a selector ending with a colon. See:",
                    "    // https://github.com/postcss/postcss-scss/issues/39",
                    "    return {",
                    "      type: \"selector-unknown\",",
                    "      value: selector,",
                    "    };",
                    "  }",
                    "",
                    "  return addTypePrefix(result, \"selector-\");",
                    "}",
                    "",
                    "function parseMediaQuery(params) {",
                    "  const mediaParser = require(\"postcss-media-query-parser\").default;",
                    "",
                    "  let result = null;",
                    "",
                    "  try {",
                    "    result = mediaParser(params);",
                    "  } catch {",
                    "    // Ignore bad media queries",
                    "    /* istanbul ignore next */",
                    "    return {",
                    "      type: \"selector-unknown\",",
                    "      value: params,",
                    "    };",
                    "  }",
                    "",
                    "  return addTypePrefix(addMissingType(result), \"media-\");",
                    "}",
                    "",
                    "const DEFAULT_SCSS_DIRECTIVE = /(\\s*)(!default).*$/;",
                    "const GLOBAL_SCSS_DIRECTIVE = /(\\s*)(!global).*$/;",
                    "",
                    "function parseNestedCSS(node, options) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "",
                    "    for (const key in node) {",
                    "      parseNestedCSS(node[key], options);",
                    "    }",
                    "",
                    "    if (!node.type) {",
                    "      return node;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    if (!node.raws) {",
                    "      node.raws = {};",
                    "    }",
                    "",
                    "    let selector = \"\";",
                    "",
                    "    if (typeof node.selector === \"string\") {",
                    "      selector = node.raws.selector",
                    "        ? node.raws.selector.scss ?? node.raws.selector.raw",
                    "        : node.selector;",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        selector += node.raws.between;",
                    "      }",
                    "",
                    "      node.raws.selector = selector;",
                    "    }",
                    "",
                    "    let value = \"\";",
                    "",
                    "    if (typeof node.value === \"string\") {",
                    "      value = node.raws.value",
                    "        ? node.raws.value.scss ?? node.raws.value.raw",
                    "        : node.value;",
                    "",
                    "      value = value.trim();",
                    "",
                    "      node.raws.value = value;",
                    "    }",
                    "",
                    "    let params = \"\";",
                    "",
                    "    if (typeof node.params === \"string\") {",
                    "      params = node.raws.params",
                    "        ? node.raws.params.scss ?? node.raws.params.raw",
                    "        : node.params;",
                    "",
                    "      if (node.raws.afterName && node.raws.afterName.trim().length > 0) {",
                    "        params = node.raws.afterName + params;",
                    "      }",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        params = params + node.raws.between;",
                    "      }",
                    "",
                    "      params = params.trim();",
                    "",
                    "      node.raws.params = params;",
                    "    }",
                    "",
                    "    // Ignore LESS mixin declaration",
                    "    if (selector.trim().length > 0) {",
                    "      // TODO: confirm this code is dead",
                    "      /* istanbul ignore next */",
                    "      if (selector.startsWith(\"@\") && selector.endsWith(\":\")) {",
                    "        return node;",
                    "      }",
                    "",
                    "      // TODO: confirm this code is dead",
                    "      /* istanbul ignore next */",
                    "      // Ignore LESS mixins",
                    "      if (node.mixin) {",
                    "        node.selector = parseValue(selector, options);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      // Check on SCSS nested property",
                    "      if (isSCSSNestedPropertyNode(node)) {",
                    "        node.isSCSSNesterProperty = true;",
                    "      }",
                    "",
                    "      node.selector = parseSelector(selector);",
                    "",
                    "      return node;",
                    "    }",
                    "",
                    "    if (value.length > 0) {",
                    "      const defaultSCSSDirectiveIndex = value.match(DEFAULT_SCSS_DIRECTIVE);",
                    "",
                    "      if (defaultSCSSDirectiveIndex) {",
                    "        value = value.slice(0, defaultSCSSDirectiveIndex.index);",
                    "        node.scssDefault = true;",
                    "",
                    "        if (defaultSCSSDirectiveIndex[0].trim() !== \"!default\") {",
                    "          node.raws.scssDefault = defaultSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      const globalSCSSDirectiveIndex = value.match(GLOBAL_SCSS_DIRECTIVE);",
                    "",
                    "      if (globalSCSSDirectiveIndex) {",
                    "        value = value.slice(0, globalSCSSDirectiveIndex.index);",
                    "        node.scssGlobal = true;",
                    "",
                    "        if (globalSCSSDirectiveIndex[0].trim() !== \"!global\") {",
                    "          node.raws.scssGlobal = globalSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      if (value.startsWith(\"progid:\")) {",
                    "        return {",
                    "          type: \"value-unknown\",",
                    "          value,",
                    "        };",
                    "      }",
                    "",
                    "      node.value = parseValue(value, options);",
                    "    }",
                    "",
                    "    if (",
                    "      isLessParser(options) &&",
                    "      node.type === \"css-decl\" &&",
                    "      value.startsWith(\"extend(\")",
                    "    ) {",
                    "      // extend is missing",
                    "      if (!node.extend) {",
                    "        node.extend = node.raws.between === \":\";",
                    "      }",
                    "",
                    "      // `:extend()` is parsed as value",
                    "      if (node.extend && !node.selector) {",
                    "        delete node.value;",
                    "        node.selector = parseSelector(value.slice(\"extend(\".length, -1));",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\") {",
                    "      if (isLessParser(options)) {",
                    "        // mixin",
                    "        if (node.mixin) {",
                    "          const source =",
                    "            node.raws.identifier +",
                    "            node.name +",
                    "            node.raws.afterName +",
                    "            node.raws.params;",
                    "          node.selector = parseSelector(source);",
                    "          delete node.params;",
                    "          return node;",
                    "        }",
                    "",
                    "        // function",
                    "        if (node.function) {",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      // only css support custom-selector",
                    "      if (options.parser === \"css\" && node.name === \"custom-selector\") {",
                    "        const customSelector = node.params.match(/:--\\S+\\s+/)[0].trim();",
                    "        node.customSelector = customSelector;",
                    "        node.selector = parseSelector(",
                    "          node.params.slice(customSelector.length).trim()",
                    "        );",
                    "        delete node.params;",
                    "        return node;",
                    "      }",
                    "",
                    "      if (isLessParser(options)) {",
                    "        // postcss-less doesn't recognize variables in some cases.",
                    "        // `@color: blue;` is recognized fine, but the cases below aren't:",
                    "",
                    "        // `@color:blue;`",
                    "        if (node.name.includes(\":\") && !node.params) {",
                    "          node.variable = true;",
                    "          const parts = node.name.split(\":\");",
                    "          node.name = parts[0];",
                    "          node.value = parseValue(parts.slice(1).join(\":\"), options);",
                    "        }",
                    "",
                    "        // `@color :blue;`",
                    "        if (",
                    "          ![\"page\", \"nest\", \"keyframes\"].includes(node.name) &&",
                    "          node.params &&",
                    "          node.params[0] === \":\"",
                    "        ) {",
                    "          node.variable = true;",
                    "          const text = node.params.slice(1);",
                    "          if (text) {",
                    "            node.value = parseValue(text, options);",
                    "          }",
                    "          node.raws.afterName += \":\";",
                    "        }",
                    "",
                    "        // Less variable",
                    "        if (node.variable) {",
                    "          delete node.params;",
                    "",
                    "          if (!node.value) {",
                    "            delete node.value;",
                    "          }",
                    "",
                    "          return node;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\" && params.length > 0) {",
                    "      const { name } = node;",
                    "      const lowercasedName = node.name.toLowerCase();",
                    "",
                    "      if (name === \"warn\" || name === \"error\") {",
                    "        node.params = {",
                    "          type: \"media-unknown\",",
                    "          value: params,",
                    "        };",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"extend\" || name === \"nest\") {",
                    "        node.selector = parseSelector(params);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"at-root\") {",
                    "        if (/^\\(\\s*(?:without|with)\\s*:.+\\)$/s.test(params)) {",
                    "          node.params = parseValue(params, options);",
                    "        } else {",
                    "          node.selector = parseSelector(params);",
                    "          delete node.params;",
                    "        }",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (isModuleRuleName(lowercasedName)) {",
                    "        node.import = true;",
                    "        delete node.filename;",
                    "        node.params = parseValue(params, options);",
                    "        return node;",
                    "      }",
                    "",
                    "      if (",
                    "        [",
                    "          \"namespace\",",
                    "          \"supports\",",
                    "          \"if\",",
                    "          \"else\",",
                    "          \"for\",",
                    "          \"each\",",
                    "          \"while\",",
                    "          \"debug\",",
                    "          \"mixin\",",
                    "          \"include\",",
                    "          \"function\",",
                    "          \"return\",",
                    "          \"define-mixin\",",
                    "          \"add-mixin\",",
                    "        ].includes(name)",
                    "      ) {",
                    "        // Remove unnecessary spaces in SCSS variable arguments",
                    "        // Move spaces after the `...`, so we can keep the range correct",
                    "        params = params.replace(/(\\$\\S+?)(\\s+)?\\.{3}/, \"$1...$2\");",
                    "        // Remove unnecessary spaces before SCSS control, mixin and function directives",
                    "        // Move spaces after the `(`, so we can keep the range correct",
                    "        params = params.replace(/^(?!if)(\\S+)(\\s+)\\(/, \"$1($2\");",
                    "",
                    "        node.value = parseValue(params, options);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if ([\"media\", \"custom-media\"].includes(lowercasedName)) {",
                    "        if (params.includes(\"#{\")) {",
                    "          // Workaround for media at rule with scss interpolation",
                    "          return {",
                    "            type: \"media-unknown\",",
                    "            value: params,",
                    "          };",
                    "        }",
                    "",
                    "        node.params = parseMediaQuery(params);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      node.params = params;",
                    "",
                    "      return node;",
                    "    }",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function parseWithParser(parse, text, options) {",
                    "  const parsed = parseFrontMatter(text);",
                    "  const { frontMatter } = parsed;",
                    "  text = parsed.content;",
                    "",
                    "  let result;",
                    "",
                    "  try {",
                    "    result = parse(text);",
                    "  } catch (error) {",
                    "    const { name, reason, line, column } = error;",
                    "    /* istanbul ignore next */",
                    "    if (typeof line !== \"number\") {",
                    "      throw error;",
                    "    }",
                    "    throw createError(`${name}: ${reason}`, { start: { line, column } });",
                    "  }",
                    "",
                    "  result = parseNestedCSS(addTypePrefix(result, \"css-\"), options);",
                    "",
                    "  calculateLoc(result, text);",
                    "",
                    "  if (frontMatter) {",
                    "    frontMatter.source = {",
                    "      startOffset: 0,",
                    "      endOffset: frontMatter.raw.length,",
                    "    };",
                    "    result.nodes.unshift(frontMatter);",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "// TODO: make this only work on css",
                    "function parseCss(text, parsers, options = {}) {",
                    "  const isSCSSParser = isSCSS(options.parser, text);",
                    "  const parseFunctions = isSCSSParser",
                    "    ? [parseScss, parseLess]",
                    "    : [parseLess, parseScss];",
                    "",
                    "  let error;",
                    "  for (const parse of parseFunctions) {",
                    "    try {",
                    "      return parse(text, parsers, options);",
                    "    } catch (parseError) {",
                    "      error = error || parseError;",
                    "    }",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (error) {",
                    "    throw error;",
                    "  }",
                    "}",
                    "",
                    "function parseLess(text, parsers, options = {}) {",
                    "  const lessParser = require(\"postcss-less\");",
                    "  return parseWithParser(",
                    "    // Workaround for https://github.com/shellscape/postcss-less/issues/145",
                    "    // See comments for `replaceQuotesInInlineComments` in `loc.js`.",
                    "    (text) => lessParser.parse(replaceQuotesInInlineComments(text)),",
                    "    text,",
                    "    options",
                    "  );",
                    "}",
                    "",
                    "function parseScss(text, parsers, options = {}) {",
                    "  const { parse } = require(\"postcss-scss\");",
                    "  return parseWithParser(parse, text, options);",
                    "}",
                    "",
                    "const postCssParser = {",
                    "  astFormat: \"postcss\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "// Export as a plugin so we can reuse the same bundle for UMD loading",
                    "module.exports = {",
                    "  parsers: {",
                    "    css: {",
                    "      ...postCssParser,",
                    "      parse: parseCss,",
                    "    },",
                    "    less: {",
                    "      ...postCssParser,",
                    "      parse: parseLess,",
                    "    },",
                    "    scss: {",
                    "      ...postCssParser,",
                    "      parse: parseScss,",
                    "    },",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  // TODO: switch these to just `postcss` and use `language` instead.",
                    "  get css() {",
                    "    return require(\"./parser-postcss.js\").parsers.css;",
                    "  },",
                    "  get less() {",
                    "    return require(\"./parser-postcss.js\").parsers.less;",
                    "  },",
                    "  get scss() {",
                    "    return require(\"./parser-postcss.js\").parsers.scss;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const jsPragma = require(\"../language-js/pragma.js\");",
                    "const parseFrontMatter = require(\"../utils/front-matter/parse.js\");",
                    "",
                    "function hasPragma(text) {",
                    "  return jsPragma.hasPragma(parseFrontMatter(text).content);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  const { frontMatter, content } = parseFrontMatter(text);",
                    "  return (",
                    "    (frontMatter ? frontMatter.raw + \"\\n\\n\" : \"\") +",
                    "    jsPragma.insertPragma(content)",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "printer-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const {",
                    "  printNumber,",
                    "  printString,",
                    "  hasNewline,",
                    "  isFrontMatterNode,",
                    "  isNextLineEmpty,",
                    "  isNonEmptyArray,",
                    "} = require(\"../common/util.js\");",
                    "const {",
                    "  builders: {",
                    "    join,",
                    "    line,",
                    "    hardline,",
                    "    softline,",
                    "    group,",
                    "    fill,",
                    "    indent,",
                    "    dedent,",
                    "    ifBreak,",
                    "    breakParent,",
                    "  },",
                    "  utils: { removeLines, getDocParts },",
                    "} = require(\"../document/index.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "",
                    "const {",
                    "  getAncestorNode,",
                    "  getPropOfDeclNode,",
                    "  maybeToLowerCase,",
                    "  insideValueFunctionNode,",
                    "  insideICSSRuleNode,",
                    "  insideAtRuleNode,",
                    "  insideURLFunctionInImportAtRuleNode,",
                    "  isKeyframeAtRuleKeywords,",
                    "  isWideKeywords,",
                    "  isLastNode,",
                    "  isSCSSControlDirectiveNode,",
                    "  isDetachedRulesetDeclarationNode,",
                    "  isRelationalOperatorNode,",
                    "  isEqualityOperatorNode,",
                    "  isMultiplicationNode,",
                    "  isDivisionNode,",
                    "  isAdditionNode,",
                    "  isSubtractionNode,",
                    "  isMathOperatorNode,",
                    "  isEachKeywordNode,",
                    "  isForKeywordNode,",
                    "  isURLFunctionNode,",
                    "  isIfElseKeywordNode,",
                    "  hasComposesNode,",
                    "  hasParensAroundNode,",
                    "  hasEmptyRawBefore,",
                    "  isKeyValuePairNode,",
                    "  isKeyInValuePairNode,",
                    "  isDetachedRulesetCallNode,",
                    "  isTemplatePlaceholderNode,",
                    "  isTemplatePropNode,",
                    "  isPostcssSimpleVarNode,",
                    "  isSCSSMapItemNode,",
                    "  isInlineValueCommentNode,",
                    "  isHashNode,",
                    "  isLeftCurlyBraceNode,",
                    "  isRightCurlyBraceNode,",
                    "  isWordNode,",
                    "  isColonNode,",
                    "  isMediaAndSupportsKeywords,",
                    "  isColorAdjusterFuncNode,",
                    "  lastLineHasInlineComment,",
                    "  isAtWordPlaceholderNode,",
                    "  isConfigurationNode,",
                    "  isParenGroupNode,",
                    "} = require(\"./utils/index.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const isLessParser = require(\"./utils/is-less-parser.js\");",
                    "const isSCSS = require(\"./utils/is-scss.js\");",
                    "const printUnit = require(\"./utils/print-unit.js\");",
                    "",
                    "function shouldPrintComma(options) {",
                    "  return options.trailingComma === \"es5\" || options.trailingComma === \"all\";",
                    "}",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  /* istanbul ignore if */",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof node === \"string\") {",
                    "    return node;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return [node.raw, hardline];",
                    "    case \"css-root\": {",
                    "      const nodes = printNodeSequence(path, options, print);",
                    "      let after = node.raws.after.trim();",
                    "      if (after.startsWith(\";\")) {",
                    "        after = after.slice(1).trim();",
                    "      }",
                    "",
                    "      return [",
                    "        nodes,",
                    "        after ? ` ${after}` : \"\",",
                    "        getDocParts(nodes).length > 0 ? hardline : \"\",",
                    "      ];",
                    "    }",
                    "    case \"css-comment\": {",
                    "      const isInlineComment = node.inline || node.raws.inline;",
                    "",
                    "      const text = options.originalText.slice(locStart(node), locEnd(node));",
                    "",
                    "      return isInlineComment ? text.trimEnd() : text;",
                    "    }",
                    "    case \"css-rule\": {",
                    "      return [",
                    "        print(\"selector\"),",
                    "        node.important ? \" !important\" : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              node.selector &&",
                    "              node.selector.type === \"selector-unknown\" &&",
                    "              lastLineHasInlineComment(node.selector.value)",
                    "                ? line",
                    "                : \" \",",
                    "              \"{\",",
                    "              node.nodes.length > 0",
                    "                ? indent([hardline, printNodeSequence(path, options, print)])",
                    "                : \"\",",
                    "              hardline,",
                    "              \"}\",",
                    "              isDetachedRulesetDeclarationNode(node) ? \";\" : \"\",",
                    "            ]",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    case \"css-decl\": {",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      const { between: rawBetween } = node.raws;",
                    "      const trimmedBetween = rawBetween.trim();",
                    "      const isColon = trimmedBetween === \":\";",
                    "",
                    "      let value = hasComposesNode(node)",
                    "        ? removeLines(print(\"value\"))",
                    "        : print(\"value\");",
                    "",
                    "      if (!isColon && lastLineHasInlineComment(trimmedBetween)) {",
                    "        value = indent([hardline, dedent(value)]);",
                    "      }",
                    "",
                    "      return [",
                    "        node.raws.before.replace(/[\\s;]/g, \"\"),",
                    "        // Less variable",
                    "        (parentNode.type === \"css-atrule\" && parentNode.variable) ||",
                    "        insideICSSRuleNode(path)",
                    "          ? node.prop",
                    "          : maybeToLowerCase(node.prop),",
                    "        trimmedBetween.startsWith(\"//\") ? \" \" : \"\",",
                    "        trimmedBetween,",
                    "        node.extend ? \"\" : \" \",",
                    "        isLessParser(options) && node.extend && node.selector",
                    "          ? [\"extend(\", print(\"selector\"), \")\"]",
                    "          : \"\",",
                    "        value,",
                    "        node.raws.important",
                    "          ? node.raws.important.replace(/\\s*!\\s*important/i, \" !important\")",
                    "          : node.important",
                    "          ? \" !important\"",
                    "          : \"\",",
                    "        node.raws.scssDefault",
                    "          ? node.raws.scssDefault.replace(/\\s*!default/i, \" !default\")",
                    "          : node.scssDefault",
                    "          ? \" !default\"",
                    "          : \"\",",
                    "        node.raws.scssGlobal",
                    "          ? node.raws.scssGlobal.replace(/\\s*!global/i, \" !global\")",
                    "          : node.scssGlobal",
                    "          ? \" !global\"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              \" {\",",
                    "              indent([softline, printNodeSequence(path, options, print)]),",
                    "              softline,",
                    "              \"}\",",
                    "            ]",
                    "          : isTemplatePropNode(node) &&",
                    "            !parentNode.raws.semicolon &&",
                    "            options.originalText[locEnd(node) - 1] !== \";\"",
                    "          ? \"\"",
                    "          : options.__isHTMLStyleAttribute && isLastNode(path, node)",
                    "          ? ifBreak(\";\")",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    case \"css-atrule\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const isTemplatePlaceholderNodeWithoutSemiColon =",
                    "        isTemplatePlaceholderNode(node) &&",
                    "        !parentNode.raws.semicolon &&",
                    "        options.originalText[locEnd(node) - 1] !== \";\";",
                    "",
                    "      if (isLessParser(options)) {",
                    "        if (node.mixin) {",
                    "          return [",
                    "            print(\"selector\"),",
                    "            node.important ? \" !important\" : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "",
                    "        if (node.function) {",
                    "          return [",
                    "            node.name,",
                    "            print(\"params\"),",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "",
                    "        if (node.variable) {",
                    "          return [",
                    "            \"@\",",
                    "            node.name,",
                    "            \": \",",
                    "            node.value ? print(\"value\") : \"\",",
                    "            node.raws.between.trim() ? node.raws.between.trim() + \" \" : \"\",",
                    "            node.nodes",
                    "              ? [",
                    "                  \"{\",",
                    "                  indent([",
                    "                    node.nodes.length > 0 ? softline : \"\",",
                    "                    printNodeSequence(path, options, print),",
                    "                  ]),",
                    "                  softline,",
                    "                  \"}\",",
                    "                ]",
                    "              : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "      }",
                    "",
                    "      return [",
                    "        \"@\",",
                    "        // If a Less file ends up being parsed with the SCSS parser, Less",
                    "        // variable declarations will be parsed as at-rules with names ending",
                    "        // with a colon, so keep the original case then.",
                    "        isDetachedRulesetCallNode(node) || node.name.endsWith(\":\")",
                    "          ? node.name",
                    "          : maybeToLowerCase(node.name),",
                    "        node.params",
                    "          ? [",
                    "              isDetachedRulesetCallNode(node)",
                    "                ? \"\"",
                    "                : isTemplatePlaceholderNode(node)",
                    "                ? node.raws.afterName === \"\"",
                    "                  ? \"\"",
                    "                  : node.name.endsWith(\":\")",
                    "                  ? \" \"",
                    "                  : /^\\s*\\n\\s*\\n/.test(node.raws.afterName)",
                    "                  ? [hardline, hardline]",
                    "                  : /^\\s*\\n/.test(node.raws.afterName)",
                    "                  ? hardline",
                    "                  : \" \"",
                    "                : \" \",",
                    "              print(\"params\"),",
                    "            ]",
                    "          : \"\",",
                    "        node.selector ? indent([\" \", print(\"selector\")]) : \"\",",
                    "        node.value",
                    "          ? group([",
                    "              \" \",",
                    "              print(\"value\"),",
                    "              isSCSSControlDirectiveNode(node)",
                    "                ? hasParensAroundNode(node)",
                    "                  ? \" \"",
                    "                  : line",
                    "                : \"\",",
                    "            ])",
                    "          : node.name === \"else\"",
                    "          ? \" \"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              isSCSSControlDirectiveNode(node)",
                    "                ? \"\"",
                    "                : (node.selector &&",
                    "                    !node.selector.nodes &&",
                    "                    typeof node.selector.value === \"string\" &&",
                    "                    lastLineHasInlineComment(node.selector.value)) ||",
                    "                  (!node.selector &&",
                    "                    typeof node.params === \"string\" &&",
                    "                    lastLineHasInlineComment(node.params))",
                    "                ? line",
                    "                : \" \",",
                    "              \"{\",",
                    "              indent([",
                    "                node.nodes.length > 0 ? softline : \"\",",
                    "                printNodeSequence(path, options, print),",
                    "              ]),",
                    "              softline,",
                    "              \"}\",",
                    "            ]",
                    "          : isTemplatePlaceholderNodeWithoutSemiColon",
                    "          ? \"\"",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    // postcss-media-query-parser",
                    "    case \"media-query-list\": {",
                    "      const parts = [];",
                    "      path.each((childPath) => {",
                    "        const node = childPath.getValue();",
                    "        if (node.type === \"media-query\" && node.value === \"\") {",
                    "          return;",
                    "        }",
                    "        parts.push(print());",
                    "      }, \"nodes\");",
                    "",
                    "      return group(indent(join(line, parts)));",
                    "    }",
                    "    case \"media-query\": {",
                    "      return [",
                    "        join(\" \", path.map(print, \"nodes\")),",
                    "        isLastNode(path, node) ? \"\" : \",\",",
                    "      ];",
                    "    }",
                    "    case \"media-type\": {",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "    }",
                    "    case \"media-feature-expression\": {",
                    "      if (!node.nodes) {",
                    "        return node.value;",
                    "      }",
                    "      return [\"(\", ...path.map(print, \"nodes\"), \")\"];",
                    "    }",
                    "    case \"media-feature\": {",
                    "      return maybeToLowerCase(",
                    "        adjustStrings(node.value.replace(/ +/g, \" \"), options)",
                    "      );",
                    "    }",
                    "    case \"media-colon\": {",
                    "      return [node.value, \" \"];",
                    "    }",
                    "    case \"media-value\": {",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "    }",
                    "    case \"media-keyword\": {",
                    "      return adjustStrings(node.value, options);",
                    "    }",
                    "    case \"media-url\": {",
                    "      return adjustStrings(",
                    "        node.value.replace(/^url\\(\\s+/gi, \"url(\").replace(/\\s+\\)$/g, \")\"),",
                    "        options",
                    "      );",
                    "    }",
                    "    case \"media-unknown\": {",
                    "      return node.value;",
                    "    }",
                    "    // postcss-selector-parser",
                    "    case \"selector-root\": {",
                    "      return group([",
                    "        insideAtRuleNode(path, \"custom-selector\")",
                    "          ? [getAncestorNode(path, \"css-atrule\").customSelector, line]",
                    "          : \"\",",
                    "        join(",
                    "          [",
                    "            \",\",",
                    "            insideAtRuleNode(path, [\"extend\", \"custom-selector\", \"nest\"])",
                    "              ? line",
                    "              : hardline,",
                    "          ],",
                    "          path.map(print, \"nodes\")",
                    "        ),",
                    "      ]);",
                    "    }",
                    "    case \"selector-selector\": {",
                    "      return group(indent(path.map(print, \"nodes\")));",
                    "    }",
                    "    case \"selector-comment\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"selector-string\": {",
                    "      return adjustStrings(node.value, options);",
                    "    }",
                    "    case \"selector-tag\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode && parentNode.nodes.indexOf(node);",
                    "      const prevNode = index && parentNode.nodes[index - 1];",
                    "",
                    "      return [",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        prevNode.type === \"selector-nesting\"",
                    "          ? node.value",
                    "          : adjustNumbers(",
                    "              isKeyframeAtRuleKeywords(path, node.value)",
                    "                ? node.value.toLowerCase()",
                    "                : node.value",
                    "            ),",
                    "      ];",
                    "    }",
                    "    case \"selector-id\": {",
                    "      return [\"#\", node.value];",
                    "    }",
                    "    case \"selector-class\": {",
                    "      return [\".\", adjustNumbers(adjustStrings(node.value, options))];",
                    "    }",
                    "    case \"selector-attribute\": {",
                    "      return [",
                    "        \"[\",",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        node.attribute.trim(),",
                    "        node.operator ?? \"\",",
                    "        node.value",
                    "          ? quoteAttributeValue(",
                    "              adjustStrings(node.value.trim(), options),",
                    "              options",
                    "            )",
                    "          : \"\",",
                    "        node.insensitive ? \" i\" : \"\",",
                    "        \"]\",",
                    "      ];",
                    "    }",
                    "    case \"selector-combinator\": {",
                    "      if (",
                    "        node.value === \"+\" ||",
                    "        node.value === \">\" ||",
                    "        node.value === \"~\" ||",
                    "        node.value === \">>>\"",
                    "      ) {",
                    "        const parentNode = path.getParentNode();",
                    "        const leading =",
                    "          parentNode.type === \"selector-selector\" &&",
                    "          parentNode.nodes[0] === node",
                    "            ? \"\"",
                    "            : line;",
                    "",
                    "        return [leading, node.value, isLastNode(path, node) ? \"\" : \" \"];",
                    "      }",
                    "",
                    "      const leading = node.value.trim().startsWith(\"(\") ? line : \"\";",
                    "      const value =",
                    "        adjustNumbers(adjustStrings(node.value.trim(), options)) || line;",
                    "",
                    "      return [leading, value];",
                    "    }",
                    "    case \"selector-universal\": {",
                    "      return [",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        node.value,",
                    "      ];",
                    "    }",
                    "    case \"selector-pseudo\": {",
                    "      return [",
                    "        maybeToLowerCase(node.value),",
                    "        isNonEmptyArray(node.nodes)",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([softline, join([\",\", line], path.map(print, \"nodes\"))]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "    case \"selector-nesting\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"selector-unknown\": {",
                    "      const ruleAncestorNode = getAncestorNode(path, \"css-rule\");",
                    "",
                    "      // Nested SCSS property",
                    "      if (ruleAncestorNode && ruleAncestorNode.isSCSSNesterProperty) {",
                    "        return adjustNumbers(",
                    "          adjustStrings(maybeToLowerCase(node.value), options)",
                    "        );",
                    "      }",
                    "",
                    "      // originalText has to be used for Less, see replaceQuotesInInlineComments in loc.js",
                    "      const parentNode = path.getParentNode();",
                    "      if (parentNode.raws && parentNode.raws.selector) {",
                    "        const start = locStart(parentNode);",
                    "        const end = start + parentNode.raws.selector.length;",
                    "        return options.originalText.slice(start, end).trim();",
                    "      }",
                    "",
                    "      // Same reason above",
                    "      const grandParent = path.getParentNode(1);",
                    "      if (",
                    "        parentNode.type === \"value-paren_group\" &&",
                    "        grandParent &&",
                    "        grandParent.type === \"value-func\" &&",
                    "        grandParent.value === \"selector\"",
                    "      ) {",
                    "        const start = locEnd(parentNode.open) + 1;",
                    "        const end = locStart(parentNode.close);",
                    "        const selector = options.originalText.slice(start, end).trim();",
                    "",
                    "        return lastLineHasInlineComment(selector)",
                    "          ? [breakParent, selector]",
                    "          : selector;",
                    "      }",
                    "",
                    "      return node.value;",
                    "    }",
                    "    // postcss-values-parser",
                    "    case \"value-value\":",
                    "    case \"value-root\": {",
                    "      return print(\"group\");",
                    "    }",
                    "    case \"value-comment\": {",
                    "      return options.originalText.slice(locStart(node), locEnd(node));",
                    "    }",
                    "    case \"value-comma_group\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const parentParentNode = path.getParentNode(1);",
                    "      const declAncestorProp = getPropOfDeclNode(path);",
                    "      const isGridValue =",
                    "        declAncestorProp &&",
                    "        parentNode.type === \"value-value\" &&",
                    "        (declAncestorProp === \"grid\" ||",
                    "          declAncestorProp.startsWith(\"grid-template\"));",
                    "      const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "      const isControlDirective =",
                    "        atRuleAncestorNode && isSCSSControlDirectiveNode(atRuleAncestorNode);",
                    "      const hasInlineComment = node.groups.some((node) =>",
                    "        isInlineValueCommentNode(node)",
                    "      );",
                    "",
                    "      const printed = path.map(print, \"groups\");",
                    "      const parts = [];",
                    "      const insideURLFunction = insideValueFunctionNode(path, \"url\");",
                    "",
                    "      let insideSCSSInterpolationInString = false;",
                    "      let didBreak = false;",
                    "",
                    "      for (let i = 0; i < node.groups.length; ++i) {",
                    "        parts.push(printed[i]);",
                    "",
                    "        const iPrevNode = node.groups[i - 1];",
                    "        const iNode = node.groups[i];",
                    "        const iNextNode = node.groups[i + 1];",
                    "        const iNextNextNode = node.groups[i + 2];",
                    "",
                    "        if (insideURLFunction) {",
                    "          if (",
                    "            (iNextNode && isAdditionNode(iNextNode)) ||",
                    "            isAdditionNode(iNode)",
                    "          ) {",
                    "            parts.push(\" \");",
                    "          }",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore SCSS @forward wildcard suffix",
                    "        if (",
                    "          insideAtRuleNode(path, \"forward\") &&",
                    "          iNode.type === \"value-word\" &&",
                    "          iNode.value &&",
                    "          iPrevNode !== undefined &&",
                    "          iPrevNode.type === \"value-word\" &&",
                    "          iPrevNode.value === \"as\" &&",
                    "          iNextNode.type === \"value-operator\" &&",
                    "          iNextNode.value === \"*\"",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore after latest node (i.e. before semicolon)",
                    "        if (!iNextNode) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // styled.div` background: var(--${one}); `",
                    "        if (",
                    "          iNode.type === \"value-word\" &&",
                    "          iNode.value.endsWith(\"-\") &&",
                    "          isAtWordPlaceholderNode(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore spaces before/after string interpolation (i.e. `\"#{my-fn(\"_\")}\"`)",
                    "        if (iNode.type === \"value-string\" && iNode.quoted) {",
                    "          const positionOfOpeningInterpolation = iNode.value.lastIndexOf(\"#{\");",
                    "          const positionOfClosingInterpolation = iNode.value.lastIndexOf(\"}\");",
                    "          if (",
                    "            positionOfOpeningInterpolation !== -1 &&",
                    "            positionOfClosingInterpolation !== -1",
                    "          ) {",
                    "            insideSCSSInterpolationInString =",
                    "              positionOfOpeningInterpolation > positionOfClosingInterpolation;",
                    "          } else if (positionOfOpeningInterpolation !== -1) {",
                    "            insideSCSSInterpolationInString = true;",
                    "          } else if (positionOfClosingInterpolation !== -1) {",
                    "            insideSCSSInterpolationInString = false;",
                    "          }",
                    "        }",
                    "",
                    "        if (insideSCSSInterpolationInString) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore colon (i.e. `:`)",
                    "        if (isColonNode(iNode) || isColonNode(iNextNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `@` in Less (i.e. `@@var;`)",
                    "        if (",
                    "          iNode.type === \"value-atword\" &&",
                    "          (iNode.value === \"\" ||",
                    "            /*",
                    "            @var[ @notVarNested ][notVar]",
                    "            ^^^^^",
                    "            */",
                    "            iNode.value.endsWith(\"[\"))",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        /*",
                    "        @var[ @notVarNested ][notVar]",
                    "                            ^^^^^^^^^",
                    "        */",
                    "        if (",
                    "          iNextNode.type === \"value-word\" &&",
                    "          iNextNode.value.startsWith(\"]\")",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `~` in Less (i.e. `content: ~\"^//* some horrible but needed css hack\";`)",
                    "        if (iNode.value === \"~\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore escape `\\`",
                    "        if (",
                    "          iNode.value &&",
                    "          iNode.value.includes(\"\\\\\") &&",
                    "          iNextNode &&",
                    "          iNextNode.type !== \"value-comment\"",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore escaped `/`",
                    "        if (",
                    "          iPrevNode &&",
                    "          iPrevNode.value &&",
                    "          iPrevNode.value.indexOf(\"\\\\\") === iPrevNode.value.length - 1 &&",
                    "          iNode.type === \"value-operator\" &&",
                    "          iNode.value === \"/\"",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `\\` (i.e. `$variable: \\@small;`)",
                    "        if (iNode.value === \"\\\\\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `$$` (i.e. `background-color: $$(style)Color;`)",
                    "        if (isPostcssSimpleVarNode(iNode, iNextNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)",
                    "        if (",
                    "          isHashNode(iNode) ||",
                    "          isLeftCurlyBraceNode(iNode) ||",
                    "          isRightCurlyBraceNode(iNextNode) ||",
                    "          (isLeftCurlyBraceNode(iNextNode) && hasEmptyRawBefore(iNextNode)) ||",
                    "          (isRightCurlyBraceNode(iNode) && hasEmptyRawBefore(iNextNode))",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)",
                    "        if (iNode.value === \"--\" && isHashNode(iNextNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Formatting math operations",
                    "        const isMathOperator = isMathOperatorNode(iNode);",
                    "        const isNextMathOperator = isMathOperatorNode(iNextNode);",
                    "",
                    "        // Print spaces before and after math operators beside SCSS interpolation as is",
                    "        // (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)",
                    "        // (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)",
                    "        if (",
                    "          ((isMathOperator && isHashNode(iNextNode)) ||",
                    "            (isNextMathOperator && isRightCurlyBraceNode(iNode))) &&",
                    "          hasEmptyRawBefore(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // absolute paths are only parsed as one token if they are part of url(/abs/path) call",
                    "        // but if you have custom -fb-url(/abs/path/) then it is parsed as \"division /\" and rest",
                    "        // of the path. We don't want to put a space after that first division in this case.",
                    "        if (!iPrevNode && isDivisionNode(iNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Print spaces before and after addition and subtraction math operators as is in `calc` function",
                    "        // due to the fact that it is not valid syntax",
                    "        // (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)",
                    "        if (",
                    "          insideValueFunctionNode(path, \"calc\") &&",
                    "          (isAdditionNode(iNode) ||",
                    "            isAdditionNode(iNextNode) ||",
                    "            isSubtractionNode(iNode) ||",
                    "            isSubtractionNode(iNextNode)) &&",
                    "          hasEmptyRawBefore(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)",
                    "        // Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.",
                    "        const isColorAdjusterNode =",
                    "          (isAdditionNode(iNode) || isSubtractionNode(iNode)) &&",
                    "          i === 0 &&",
                    "          (iNextNode.type === \"value-number\" || iNextNode.isHex) &&",
                    "          parentParentNode &&",
                    "          isColorAdjusterFuncNode(parentParentNode) &&",
                    "          !hasEmptyRawBefore(iNextNode);",
                    "",
                    "        const requireSpaceBeforeOperator =",
                    "          (iNextNextNode && iNextNextNode.type === \"value-func\") ||",
                    "          (iNextNextNode && isWordNode(iNextNextNode)) ||",
                    "          iNode.type === \"value-func\" ||",
                    "          isWordNode(iNode);",
                    "        const requireSpaceAfterOperator =",
                    "          iNextNode.type === \"value-func\" ||",
                    "          isWordNode(iNextNode) ||",
                    "          (iPrevNode && iPrevNode.type === \"value-func\") ||",
                    "          (iPrevNode && isWordNode(iPrevNode));",
                    "",
                    "        // Formatting `/`, `+`, `-` sign",
                    "        if (",
                    "          !(isMultiplicationNode(iNextNode) || isMultiplicationNode(iNode)) &&",
                    "          !insideValueFunctionNode(path, \"calc\") &&",
                    "          !isColorAdjusterNode &&",
                    "          ((isDivisionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                    "            (isDivisionNode(iNode) && !requireSpaceAfterOperator) ||",
                    "            (isAdditionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                    "            (isAdditionNode(iNode) && !requireSpaceAfterOperator) ||",
                    "            isSubtractionNode(iNextNode) ||",
                    "            isSubtractionNode(iNode)) &&",
                    "          (hasEmptyRawBefore(iNextNode) ||",
                    "            (isMathOperator &&",
                    "              (!iPrevNode || (iPrevNode && isMathOperatorNode(iPrevNode)))))",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // No space before unary minus followed by an opening parenthesis `-(`",
                    "        if (",
                    "          (options.parser === \"scss\" || options.parser === \"less\") &&",
                    "          isMathOperator &&",
                    "          iNode.value === \"-\" &&",
                    "          isParenGroupNode(iNextNode) &&",
                    "          locEnd(iNode) === locStart(iNextNode.open) &&",
                    "          iNextNode.open.value === \"(\"",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Add `hardline` after inline comment (i.e. `// comment\\n foo: bar;`)",
                    "        if (isInlineValueCommentNode(iNode)) {",
                    "          if (parentNode.type === \"value-paren_group\") {",
                    "            parts.push(dedent(hardline));",
                    "            continue;",
                    "          }",
                    "          parts.push(hardline);",
                    "          continue;",
                    "        }",
                    "",
                    "        // Handle keywords in SCSS control directive",
                    "        if (",
                    "          isControlDirective &&",
                    "          (isEqualityOperatorNode(iNextNode) ||",
                    "            isRelationalOperatorNode(iNextNode) ||",
                    "            isIfElseKeywordNode(iNextNode) ||",
                    "            isEachKeywordNode(iNode) ||",
                    "            isForKeywordNode(iNode))",
                    "        ) {",
                    "          parts.push(\" \");",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // At-rule `namespace` should be in one line",
                    "        if (",
                    "          atRuleAncestorNode &&",
                    "          atRuleAncestorNode.name.toLowerCase() === \"namespace\"",
                    "        ) {",
                    "          parts.push(\" \");",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // Formatting `grid` property",
                    "        if (isGridValue) {",
                    "          if (",
                    "            iNode.source &&",
                    "            iNextNode.source &&",
                    "            iNode.source.start.line !== iNextNode.source.start.line",
                    "          ) {",
                    "            parts.push(hardline);",
                    "",
                    "            didBreak = true;",
                    "          } else {",
                    "            parts.push(\" \");",
                    "          }",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // Add `space` before next math operation",
                    "        // Note: `grip` property have `/` delimiter and it is not math operation, so",
                    "        // `grid` property handles above",
                    "        if (isNextMathOperator) {",
                    "          parts.push(\" \");",
                    "",
                    "          continue;",
                    "        }",
                    "        // allow function(returns-list($list)...)",
                    "        if (iNextNode && iNextNode.value === \"...\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          isAtWordPlaceholderNode(iNode) &&",
                    "          isAtWordPlaceholderNode(iNextNode) &&",
                    "          locEnd(iNode) === locStart(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          isAtWordPlaceholderNode(iNode) &&",
                    "          isParenGroupNode(iNextNode) &&",
                    "          locEnd(iNode) === locStart(iNextNode.open)",
                    "        ) {",
                    "          parts.push(softline);",
                    "          continue;",
                    "        }",
                    "",
                    "        if (iNode.value === \"with\" && isParenGroupNode(iNextNode)) {",
                    "          parts.push(\" \");",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          iNode.value?.endsWith(\"#\") &&",
                    "          iNextNode.value === \"{\" &&",
                    "          isParenGroupNode(iNextNode.group)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Be default all values go through `line`",
                    "        parts.push(line);",
                    "      }",
                    "",
                    "      if (hasInlineComment) {",
                    "        parts.push(breakParent);",
                    "      }",
                    "",
                    "      if (didBreak) {",
                    "        parts.unshift(hardline);",
                    "      }",
                    "",
                    "      if (isControlDirective) {",
                    "        return group(indent(parts));",
                    "      }",
                    "",
                    "      // Indent is not needed for import url when url is very long",
                    "      // and node has two groups",
                    "      // when type is value-comma_group",
                    "      // example @import url(\"verylongurl\") projection,tv",
                    "      if (insideURLFunctionInImportAtRuleNode(path)) {",
                    "        return group(fill(parts));",
                    "      }",
                    "",
                    "      return group(indent(fill(parts)));",
                    "    }",
                    "    case \"value-paren_group\": {",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      if (",
                    "        parentNode &&",
                    "        isURLFunctionNode(parentNode) &&",
                    "        (node.groups.length === 1 ||",
                    "          (node.groups.length > 0 &&",
                    "            node.groups[0].type === \"value-comma_group\" &&",
                    "            node.groups[0].groups.length > 0 &&",
                    "            node.groups[0].groups[0].type === \"value-word\" &&",
                    "            node.groups[0].groups[0].value.startsWith(\"data:\")))",
                    "      ) {",
                    "        return [",
                    "          node.open ? print(\"open\") : \"\",",
                    "          join(\",\", path.map(print, \"groups\")),",
                    "          node.close ? print(\"close\") : \"\",",
                    "        ];",
                    "      }",
                    "",
                    "      if (!node.open) {",
                    "        const printed = path.map(print, \"groups\");",
                    "        const res = [];",
                    "",
                    "        for (let i = 0; i < printed.length; i++) {",
                    "          if (i !== 0) {",
                    "            res.push([\",\", line]);",
                    "          }",
                    "          res.push(printed[i]);",
                    "        }",
                    "",
                    "        return group(indent(fill(res)));",
                    "      }",
                    "",
                    "      const isSCSSMapItem = isSCSSMapItemNode(path);",
                    "",
                    "      const lastItem = getLast(node.groups);",
                    "      const isLastItemComment = lastItem && lastItem.type === \"value-comment\";",
                    "      const isKey = isKeyInValuePairNode(node, parentNode);",
                    "      const isConfiguration = isConfigurationNode(node, parentNode);",
                    "",
                    "      const shouldBreak = isConfiguration || (isSCSSMapItem && !isKey);",
                    "      const shouldDedent = isConfiguration || isKey;",
                    "",
                    "      const printed = group(",
                    "        [",
                    "          node.open ? print(\"open\") : \"\",",
                    "          indent([",
                    "            softline,",
                    "            join(",
                    "              [line],",
                    "              path.map((childPath, index) => {",
                    "                const child = childPath.getValue();",
                    "                const isLast = index === node.groups.length - 1;",
                    "",
                    "                let printed = [print(), isLast ? \"\" : \",\"];",
                    "",
                    "                // Key/Value pair in open paren already indented",
                    "                if (",
                    "                  isKeyValuePairNode(child) &&",
                    "                  child.type === \"value-comma_group\" &&",
                    "                  child.groups &&",
                    "                  child.groups[0].type !== \"value-paren_group\" &&",
                    "                  child.groups[2] &&",
                    "                  child.groups[2].type === \"value-paren_group\"",
                    "                ) {",
                    "                  const parts = getDocParts(printed[0].contents.contents);",
                    "                  parts[1] = group(parts[1]);",
                    "                  printed = [group(dedent(printed))];",
                    "                }",
                    "",
                    "                if (",
                    "                  !isLast &&",
                    "                  child.type === \"value-comma_group\" &&",
                    "                  isNonEmptyArray(child.groups)",
                    "                ) {",
                    "                  let last = getLast(child.groups);",
                    "",
                    "                  // `value-paren_group` does not have location info, but its closing parenthesis does.",
                    "                  if (!last.source && last.close) {",
                    "                    last = last.close;",
                    "                  }",
                    "",
                    "                  if (",
                    "                    last.source &&",
                    "                    isNextLineEmpty(options.originalText, last, locEnd)",
                    "                  ) {",
                    "                    printed.push(hardline);",
                    "                  }",
                    "                }",
                    "",
                    "                return printed;",
                    "              }, \"groups\")",
                    "            ),",
                    "          ]),",
                    "          ifBreak(",
                    "            !isLastItemComment &&",
                    "              isSCSS(options.parser, options.originalText) &&",
                    "              isSCSSMapItem &&",
                    "              shouldPrintComma(options)",
                    "              ? \",\"",
                    "              : \"\"",
                    "          ),",
                    "          softline,",
                    "          node.close ? print(\"close\") : \"\",",
                    "        ],",
                    "        {",
                    "          shouldBreak,",
                    "        }",
                    "      );",
                    "",
                    "      return shouldDedent ? dedent(printed) : printed;",
                    "    }",
                    "    case \"value-func\": {",
                    "      return [",
                    "        node.value,",
                    "        insideAtRuleNode(path, \"supports\") && isMediaAndSupportsKeywords(node)",
                    "          ? \" \"",
                    "          : \"\",",
                    "        print(\"group\"),",
                    "      ];",
                    "    }",
                    "    case \"value-paren\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-number\": {",
                    "      return [printCssNumber(node.value), printUnit(node.unit)];",
                    "    }",
                    "    case \"value-operator\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-word\": {",
                    "      if ((node.isColor && node.isHex) || isWideKeywords(node.value)) {",
                    "        return node.value.toLowerCase();",
                    "      }",
                    "",
                    "      return node.value;",
                    "    }",
                    "    case \"value-colon\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode && parentNode.groups.indexOf(node);",
                    "      const prevNode = index && parentNode.groups[index - 1];",
                    "      return [",
                    "        node.value,",
                    "        // Don't add spaces on escaped colon `:`, e.g: grid-template-rows: [row-1-00\\:00] auto;",
                    "        (prevNode &&",
                    "          typeof prevNode.value === \"string\" &&",
                    "          getLast(prevNode.value) === \"\\\\\") ||",
                    "        // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)",
                    "        insideValueFunctionNode(path, \"url\")",
                    "          ? \"\"",
                    "          : line,",
                    "      ];",
                    "    }",
                    "    // TODO: confirm this code is dead",
                    "    /* istanbul ignore next */",
                    "    case \"value-comma\": {",
                    "      return [node.value, \" \"];",
                    "    }",
                    "    case \"value-string\": {",
                    "      return printString(",
                    "        node.raws.quote + node.value + node.raws.quote,",
                    "        options",
                    "      );",
                    "    }",
                    "    case \"value-atword\": {",
                    "      return [\"@\", node.value];",
                    "    }",
                    "    case \"value-unicode-range\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-unknown\": {",
                    "      return node.value;",
                    "    }",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unknown postcss type ${JSON.stringify(node.type)}`);",
                    "  }",
                    "}",
                    "",
                    "function printNodeSequence(path, options, print) {",
                    "  const parts = [];",
                    "  path.each((pathChild, i, nodes) => {",
                    "    const prevNode = nodes[i - 1];",
                    "    if (",
                    "      prevNode &&",
                    "      prevNode.type === \"css-comment\" &&",
                    "      prevNode.text.trim() === \"prettier-ignore\"",
                    "    ) {",
                    "      const childNode = pathChild.getValue();",
                    "      parts.push(",
                    "        options.originalText.slice(locStart(childNode), locEnd(childNode))",
                    "      );",
                    "    } else {",
                    "      parts.push(print());",
                    "    }",
                    "",
                    "    if (i !== nodes.length - 1) {",
                    "      if (",
                    "        (nodes[i + 1].type === \"css-comment\" &&",
                    "          !hasNewline(options.originalText, locStart(nodes[i + 1]), {",
                    "            backwards: true,",
                    "          }) &&",
                    "          !isFrontMatterNode(nodes[i])) ||",
                    "        (nodes[i + 1].type === \"css-atrule\" &&",
                    "          nodes[i + 1].name === \"else\" &&",
                    "          nodes[i].type !== \"css-comment\")",
                    "      ) {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(options.__isHTMLStyleAttribute ? line : hardline);",
                    "        if (",
                    "          isNextLineEmpty(options.originalText, pathChild.getValue(), locEnd) &&",
                    "          !isFrontMatterNode(nodes[i])",
                    "        ) {",
                    "          parts.push(hardline);",
                    "        }",
                    "      }",
                    "    }",
                    "  }, \"nodes\");",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "const STRING_REGEX = /([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*\\1/gs;",
                    "const NUMBER_REGEX = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[Ee][+-]?\\d+)?/g;",
                    "const STANDARD_UNIT_REGEX = /[A-Za-z]+/g;",
                    "const WORD_PART_REGEX = /[$@]?[A-Z_a-z\\u0080-\\uFFFF][\\w\\u0080-\\uFFFF-]*/g;",
                    "const ADJUST_NUMBERS_REGEX = new RegExp(",
                    "  STRING_REGEX.source +",
                    "    \"|\" +",
                    "    `(${WORD_PART_REGEX.source})?` +",
                    "    `(${NUMBER_REGEX.source})` +",
                    "    `(${STANDARD_UNIT_REGEX.source})?`,",
                    "  \"g\"",
                    ");",
                    "",
                    "function adjustStrings(value, options) {",
                    "  return value.replace(STRING_REGEX, (match) => printString(match, options));",
                    "}",
                    "",
                    "function quoteAttributeValue(value, options) {",
                    "  const quote = options.singleQuote ? \"'\" : '\"';",
                    "  return value.includes('\"') || value.includes(\"'\")",
                    "    ? value",
                    "    : quote + value + quote;",
                    "}",
                    "",
                    "function adjustNumbers(value) {",
                    "  return value.replace(",
                    "    ADJUST_NUMBERS_REGEX,",
                    "    (match, quote, wordPart, number, unit) =>",
                    "      !wordPart && number",
                    "        ? printCssNumber(number) + maybeToLowerCase(unit || \"\")",
                    "        : match",
                    "  );",
                    "}",
                    "",
                    "function printCssNumber(rawNumber) {",
                    "  return (",
                    "    printNumber(rawNumber)",
                    "      // Remove trailing `.0`.",
                    "      .replace(/\\.0(?=$|e)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  embed,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "};"
                ]
            },
            "utils": {
                "css-units.evaluate.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { default: cssUnits } = require(\"../../../vendors/css-units-list.json\");",
                        "",
                        "const CSS_UNITS = Object.fromEntries(",
                        "  cssUnits.map((unit) => [unit.toLowerCase(), unit])",
                        ");",
                        "",
                        "module.exports = CSS_UNITS;"
                    ]
                },
                "has-scss-interpolation.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const isNonEmptyArray = require(\"../../utils/is-non-empty-array.js\");",
                        "",
                        "function hasSCSSInterpolation(groupList) {",
                        "  if (isNonEmptyArray(groupList)) {",
                        "    for (let i = groupList.length - 1; i > 0; i--) {",
                        "      // If we find `#{`, return true.",
                        "      if (",
                        "        groupList[i].type === \"word\" &&",
                        "        groupList[i].value === \"{\" &&",
                        "        groupList[i - 1].type === \"word\" &&",
                        "        groupList[i - 1].value.endsWith(\"#\")",
                        "      ) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "module.exports = hasSCSSInterpolation;"
                    ]
                },
                "has-string-or-function.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function hasStringOrFunction(groupList) {",
                        "  return groupList.some(",
                        "    (group) => group.type === \"string\" || group.type === \"func\"",
                        "  );",
                        "}",
                        "",
                        "module.exports = hasStringOrFunction;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const colorAdjusterFunctions = new Set([",
                        "  \"red\",",
                        "  \"green\",",
                        "  \"blue\",",
                        "  \"alpha\",",
                        "  \"a\",",
                        "  \"rgb\",",
                        "  \"hue\",",
                        "  \"h\",",
                        "  \"saturation\",",
                        "  \"s\",",
                        "  \"lightness\",",
                        "  \"l\",",
                        "  \"whiteness\",",
                        "  \"w\",",
                        "  \"blackness\",",
                        "  \"b\",",
                        "  \"tint\",",
                        "  \"shade\",",
                        "  \"blend\",",
                        "  \"blenda\",",
                        "  \"contrast\",",
                        "  \"hsl\",",
                        "  \"hsla\",",
                        "  \"hwb\",",
                        "  \"hwba\",",
                        "]);",
                        "",
                        "function getAncestorCounter(path, typeOrTypes) {",
                        "  const types = Array.isArray(typeOrTypes) ? typeOrTypes : [typeOrTypes];",
                        "",
                        "  let counter = -1;",
                        "  let ancestorNode;",
                        "",
                        "  while ((ancestorNode = path.getParentNode(++counter))) {",
                        "    if (types.includes(ancestorNode.type)) {",
                        "      return counter;",
                        "    }",
                        "  }",
                        "",
                        "  return -1;",
                        "}",
                        "",
                        "function getAncestorNode(path, typeOrTypes) {",
                        "  const counter = getAncestorCounter(path, typeOrTypes);",
                        "  return counter === -1 ? null : path.getParentNode(counter);",
                        "}",
                        "",
                        "function getPropOfDeclNode(path) {",
                        "  const declAncestorNode = getAncestorNode(path, \"css-decl\");",
                        "",
                        "  return declAncestorNode?.prop?.toLowerCase();",
                        "}",
                        "",
                        "const wideKeywords = new Set([\"initial\", \"inherit\", \"unset\", \"revert\"]);",
                        "function isWideKeywords(value) {",
                        "  return wideKeywords.has(value.toLowerCase());",
                        "}",
                        "",
                        "function isKeyframeAtRuleKeywords(path, value) {",
                        "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                        "  return (",
                        "    atRuleAncestorNode?.name &&",
                        "    atRuleAncestorNode.name.toLowerCase().endsWith(\"keyframes\") &&",
                        "    [\"from\", \"to\"].includes(value.toLowerCase())",
                        "  );",
                        "}",
                        "",
                        "function maybeToLowerCase(value) {",
                        "  return value.includes(\"$\") ||",
                        "    value.includes(\"@\") ||",
                        "    value.includes(\"#\") ||",
                        "    value.startsWith(\"%\") ||",
                        "    value.startsWith(\"--\") ||",
                        "    value.startsWith(\":--\") ||",
                        "    (value.includes(\"(\") && value.includes(\")\"))",
                        "    ? value",
                        "    : value.toLowerCase();",
                        "}",
                        "",
                        "function insideValueFunctionNode(path, functionName) {",
                        "  const funcAncestorNode = getAncestorNode(path, \"value-func\");",
                        "  return funcAncestorNode?.value?.toLowerCase() === functionName;",
                        "}",
                        "",
                        "function insideICSSRuleNode(path) {",
                        "  const ruleAncestorNode = getAncestorNode(path, \"css-rule\");",
                        "  const selector = ruleAncestorNode?.raws?.selector;",
                        "",
                        "  return (",
                        "    selector &&",
                        "    (selector.startsWith(\":import\") || selector.startsWith(\":export\"))",
                        "  );",
                        "}",
                        "",
                        "function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {",
                        "  const atRuleNames = Array.isArray(atRuleNameOrAtRuleNames)",
                        "    ? atRuleNameOrAtRuleNames",
                        "    : [atRuleNameOrAtRuleNames];",
                        "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                        "",
                        "  return (",
                        "    atRuleAncestorNode &&",
                        "    atRuleNames.includes(atRuleAncestorNode.name.toLowerCase())",
                        "  );",
                        "}",
                        "",
                        "function insideURLFunctionInImportAtRuleNode(path) {",
                        "  const node = path.getValue();",
                        "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                        "",
                        "  return (",
                        "    atRuleAncestorNode?.name === \"import\" &&",
                        "    node.groups[0].value === \"url\" &&",
                        "    node.groups.length === 2",
                        "  );",
                        "}",
                        "",
                        "function isURLFunctionNode(node) {",
                        "  return node.type === \"value-func\" && node.value.toLowerCase() === \"url\";",
                        "}",
                        "",
                        "function isLastNode(path, node) {",
                        "  const nodes = path.getParentNode()?.nodes;",
                        "  return nodes && nodes.indexOf(node) === nodes.length - 1;",
                        "}",
                        "",
                        "function isDetachedRulesetDeclarationNode(node) {",
                        "  const { selector } = node;",
                        "  // If a Less file ends up being parsed with the SCSS parser, Less",
                        "  // variable declarations will be parsed as atrules with names ending",
                        "  // with a colon, so keep the original case then.",
                        "  /* istanbul ignore next */",
                        "  if (!selector) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return (",
                        "    (typeof selector === \"string\" && /^@.+:.*$/.test(selector)) ||",
                        "    (selector.value && /^@.+:.*$/.test(selector.value))",
                        "  );",
                        "}",
                        "",
                        "function isForKeywordNode(node) {",
                        "  return (",
                        "    node.type === \"value-word\" &&",
                        "    [\"from\", \"through\", \"end\"].includes(node.value)",
                        "  );",
                        "}",
                        "",
                        "function isIfElseKeywordNode(node) {",
                        "  return (",
                        "    node.type === \"value-word\" && [\"and\", \"or\", \"not\"].includes(node.value)",
                        "  );",
                        "}",
                        "",
                        "function isEachKeywordNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"in\";",
                        "}",
                        "",
                        "function isMultiplicationNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"*\";",
                        "}",
                        "",
                        "function isDivisionNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"/\";",
                        "}",
                        "",
                        "function isAdditionNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"+\";",
                        "}",
                        "",
                        "function isSubtractionNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"-\";",
                        "}",
                        "",
                        "function isModuloNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"%\";",
                        "}",
                        "",
                        "function isMathOperatorNode(node) {",
                        "  return (",
                        "    isMultiplicationNode(node) ||",
                        "    isDivisionNode(node) ||",
                        "    isAdditionNode(node) ||",
                        "    isSubtractionNode(node) ||",
                        "    isModuloNode(node)",
                        "  );",
                        "}",
                        "",
                        "function isEqualityOperatorNode(node) {",
                        "  return node.type === \"value-word\" && [\"==\", \"!=\"].includes(node.value);",
                        "}",
                        "",
                        "function isRelationalOperatorNode(node) {",
                        "  return (",
                        "    node.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].includes(node.value)",
                        "  );",
                        "}",
                        "",
                        "function isSCSSControlDirectiveNode(node) {",
                        "  return (",
                        "    node.type === \"css-atrule\" &&",
                        "    [\"if\", \"else\", \"for\", \"each\", \"while\"].includes(node.name)",
                        "  );",
                        "}",
                        "",
                        "function isDetachedRulesetCallNode(node) {",
                        "  return node.raws?.params && /^\\(\\s*\\)$/.test(node.raws.params);",
                        "}",
                        "",
                        "function isTemplatePlaceholderNode(node) {",
                        "  return node.name.startsWith(\"prettier-placeholder\");",
                        "}",
                        "",
                        "function isTemplatePropNode(node) {",
                        "  return node.prop.startsWith(\"@prettier-placeholder\");",
                        "}",
                        "",
                        "function isPostcssSimpleVarNode(currentNode, nextNode) {",
                        "  return (",
                        "    currentNode.value === \"$$\" &&",
                        "    currentNode.type === \"value-func\" &&",
                        "    nextNode?.type === \"value-word\" &&",
                        "    !nextNode.raws.before",
                        "  );",
                        "}",
                        "",
                        "function hasComposesNode(node) {",
                        "  return (",
                        "    node.value?.type === \"value-root\" &&",
                        "    node.value.group?.type === \"value-value\" &&",
                        "    node.prop.toLowerCase() === \"composes\"",
                        "  );",
                        "}",
                        "",
                        "function hasParensAroundNode(node) {",
                        "  return (",
                        "    node.value?.group?.group?.type === \"value-paren_group\" &&",
                        "    node.value.group.group.open !== null &&",
                        "    node.value.group.group.close !== null",
                        "  );",
                        "}",
                        "",
                        "function hasEmptyRawBefore(node) {",
                        "  return node.raws?.before === \"\";",
                        "}",
                        "",
                        "function isKeyValuePairNode(node) {",
                        "  return (",
                        "    node.type === \"value-comma_group\" &&",
                        "    node.groups?.[1]?.type === \"value-colon\"",
                        "  );",
                        "}",
                        "",
                        "function isKeyValuePairInParenGroupNode(node) {",
                        "  return (",
                        "    node.type === \"value-paren_group\" &&",
                        "    node.groups?.[0] &&",
                        "    isKeyValuePairNode(node.groups[0])",
                        "  );",
                        "}",
                        "",
                        "function isSCSSMapItemNode(path) {",
                        "  const node = path.getValue();",
                        "",
                        "  // Ignore empty item (i.e. `$key: ()`)",
                        "  if (node.groups.length === 0) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const parentParentNode = path.getParentNode(1);",
                        "",
                        "  // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)",
                        "  if (",
                        "    !isKeyValuePairInParenGroupNode(node) &&",
                        "    !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const declNode = getAncestorNode(path, \"css-decl\");",
                        "",
                        "  // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)",
                        "  if (declNode?.prop?.startsWith(\"$\")) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)",
                        "  if (isKeyValuePairInParenGroupNode(parentParentNode)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)",
                        "  if (parentParentNode.type === \"value-func\") {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function isInlineValueCommentNode(node) {",
                        "  return node.type === \"value-comment\" && node.inline;",
                        "}",
                        "",
                        "function isHashNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"#\";",
                        "}",
                        "",
                        "function isLeftCurlyBraceNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"{\";",
                        "}",
                        "",
                        "function isRightCurlyBraceNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"}\";",
                        "}",
                        "",
                        "function isWordNode(node) {",
                        "  return [\"value-word\", \"value-atword\"].includes(node.type);",
                        "}",
                        "",
                        "function isColonNode(node) {",
                        "  return node?.type === \"value-colon\";",
                        "}",
                        "",
                        "function isKeyInValuePairNode(node, parentNode) {",
                        "  if (!isKeyValuePairNode(parentNode)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const { groups } = parentNode;",
                        "  const index = groups.indexOf(node);",
                        "",
                        "  if (index === -1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return isColonNode(groups[index + 1]);",
                        "}",
                        "",
                        "function isMediaAndSupportsKeywords(node) {",
                        "  return node.value && [\"not\", \"and\", \"or\"].includes(node.value.toLowerCase());",
                        "}",
                        "",
                        "function isColorAdjusterFuncNode(node) {",
                        "  if (node.type !== \"value-func\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  return colorAdjusterFunctions.has(node.value.toLowerCase());",
                        "}",
                        "",
                        "function lastLineHasInlineComment(text) {",
                        "  return /\\/\\//.test(text.split(/[\\n\\r]/).pop());",
                        "}",
                        "",
                        "function isAtWordPlaceholderNode(node) {",
                        "  return (",
                        "    node?.type === \"value-atword\" &&",
                        "    node.value.startsWith(\"prettier-placeholder-\")",
                        "  );",
                        "}",
                        "",
                        "function isConfigurationNode(node, parentNode) {",
                        "  if (",
                        "    node.open?.value !== \"(\" ||",
                        "    node.close?.value !== \")\" ||",
                        "    node.groups.some((group) => group.type !== \"value-comma_group\")",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "  if (parentNode.type === \"value-comma_group\") {",
                        "    const prevIdx = parentNode.groups.indexOf(node) - 1;",
                        "    const maybeWithNode = parentNode.groups[prevIdx];",
                        "    if (",
                        "      maybeWithNode?.type === \"value-word\" &&",
                        "      maybeWithNode.value === \"with\"",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function isParenGroupNode(node) {",
                        "  return (",
                        "    node.type === \"value-paren_group\" &&",
                        "    node.open?.value === \"(\" &&",
                        "    node.close?.value === \")\"",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  getAncestorCounter,",
                        "  getAncestorNode,",
                        "  getPropOfDeclNode,",
                        "  maybeToLowerCase,",
                        "  insideValueFunctionNode,",
                        "  insideICSSRuleNode,",
                        "  insideAtRuleNode,",
                        "  insideURLFunctionInImportAtRuleNode,",
                        "  isKeyframeAtRuleKeywords,",
                        "  isWideKeywords,",
                        "  isLastNode,",
                        "  isSCSSControlDirectiveNode,",
                        "  isDetachedRulesetDeclarationNode,",
                        "  isRelationalOperatorNode,",
                        "  isEqualityOperatorNode,",
                        "  isMultiplicationNode,",
                        "  isDivisionNode,",
                        "  isAdditionNode,",
                        "  isSubtractionNode,",
                        "  isModuloNode,",
                        "  isMathOperatorNode,",
                        "  isEachKeywordNode,",
                        "  isForKeywordNode,",
                        "  isURLFunctionNode,",
                        "  isIfElseKeywordNode,",
                        "  hasComposesNode,",
                        "  hasParensAroundNode,",
                        "  hasEmptyRawBefore,",
                        "  isDetachedRulesetCallNode,",
                        "  isTemplatePlaceholderNode,",
                        "  isTemplatePropNode,",
                        "  isPostcssSimpleVarNode,",
                        "  isKeyValuePairNode,",
                        "  isKeyValuePairInParenGroupNode,",
                        "  isKeyInValuePairNode,",
                        "  isSCSSMapItemNode,",
                        "  isInlineValueCommentNode,",
                        "  isHashNode,",
                        "  isLeftCurlyBraceNode,",
                        "  isRightCurlyBraceNode,",
                        "  isWordNode,",
                        "  isColonNode,",
                        "  isMediaAndSupportsKeywords,",
                        "  isColorAdjusterFuncNode,",
                        "  lastLineHasInlineComment,",
                        "  isAtWordPlaceholderNode,",
                        "  isConfigurationNode,",
                        "  isParenGroupNode,",
                        "};"
                    ]
                },
                "is-less-parser.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "// TODO: only check `less` when we don't use `less` to parse `css`",
                        "function isLessParser(options) {",
                        "  return options.parser === \"css\" || options.parser === \"less\";",
                        "}",
                        "",
                        "module.exports = isLessParser;"
                    ]
                },
                "is-module-rule-name.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const moduleRuleNames = new Set([\"import\", \"use\", \"forward\"]);",
                        "",
                        "function isModuleRuleName(name) {",
                        "  return moduleRuleNames.has(name);",
                        "}",
                        "",
                        "module.exports = isModuleRuleName;"
                    ]
                },
                "is-scss-nested-property-node.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function isSCSSNestedPropertyNode(node) {",
                        "  /* istanbul ignore next */",
                        "  if (!node.selector) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return node.selector",
                        "    .replace(/\\/\\*.*?\\*\\//, \"\")",
                        "    .replace(/\\/\\/.*\\n/, \"\")",
                        "    .trim()",
                        "    .endsWith(\":\");",
                        "}",
                        "",
                        "module.exports = isSCSSNestedPropertyNode;"
                    ]
                },
                "is-scss-variable.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function isSCSSVariable(node) {",
                        "  return Boolean(node?.type === \"word\" && node.value.startsWith(\"$\"));",
                        "}",
                        "",
                        "module.exports = isSCSSVariable;"
                    ]
                },
                "is-scss.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function isSCSS(parser, text) {",
                        "  const hasExplicitParserChoice = parser === \"less\" || parser === \"scss\";",
                        "  const IS_POSSIBLY_SCSS = /(?:\\w\\s*:\\s*[^:}]+|#){|@import[^\\n]+(?:url|,)/;",
                        "  return hasExplicitParserChoice",
                        "    ? parser === \"scss\"",
                        "    : IS_POSSIBLY_SCSS.test(text);",
                        "}",
                        "",
                        "module.exports = isSCSS;"
                    ]
                },
                "print-unit.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const CSS_UNITS = require(\"./css-units.evaluate.js\");",
                        "",
                        "function printUnit(unit) {",
                        "  const lowercased = unit.toLowerCase();",
                        "",
                        "  return Object.prototype.hasOwnProperty.call(CSS_UNITS, lowercased)",
                        "    ? CSS_UNITS[lowercased]",
                        "    : unit;",
                        "}",
                        "",
                        "module.exports = printUnit;"
                    ]
                },
                "stringify-node.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function stringifyNode(node) {",
                        "  if (node.groups) {",
                        "    const open = node.open?.value || \"\";",
                        "    const groups = node.groups",
                        "      .map((currentValue) => stringifyNode(currentValue))",
                        "      .join(node.groups[0]?.type === \"comma_group\" ? \",\" : \"\");",
                        "    const close = node.close?.value || \"\";",
                        "",
                        "    return open + groups + close;",
                        "  }",
                        "",
                        "  const before = node.raws?.before || \"\";",
                        "  const quote = node.raws?.quote || \"\";",
                        "  const atword = node.type === \"atword\" ? \"@\" : \"\";",
                        "  const value = node.value || \"\";",
                        "  const unit = node.unit || \"\";",
                        "  const group = node.group ? stringifyNode(node.group) : \"\";",
                        "  const after = node.raws?.after || \"\";",
                        "",
                        "  return before + quote + atword + value + quote + unit + group + after;",
                        "}",
                        "",
                        "module.exports = stringifyNode;"
                    ]
                }
            }
        },
        "language-graphql": {
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-graphql.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/GraphQL.json\"), () => ({",
                    "    since: \"1.5.0\",",
                    "    parsers: [\"graphql\"],",
                    "    vscodeLanguageIds: [\"graphql\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  graphql: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  if (typeof node.start === \"number\") {",
                    "    return node.start;",
                    "  }",
                    "  return node.loc && node.loc.start;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  if (typeof node.end === \"number\") {",
                    "    return node.end;",
                    "  }",
                    "  return node.loc && node.loc.end;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "};"
                ]
            },
            "parser-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const tryCombinations = require(\"../utils/try-combinations.js\");",
                    "const { hasPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "function parseComments(ast) {",
                    "  const comments = [];",
                    "  const { startToken } = ast.loc;",
                    "  let { next } = startToken;",
                    "  while (next.kind !== \"<EOF>\") {",
                    "    if (next.kind === \"Comment\") {",
                    "      Object.assign(next, {",
                    "        // The Comment token's column starts _after_ the `#`,",
                    "        // but we need to make sure the node captures the `#`",
                    "        column: next.column - 1,",
                    "      });",
                    "      comments.push(next);",
                    "    }",
                    "    next = next.next;",
                    "  }",
                    "",
                    "  return comments;",
                    "}",
                    "",
                    "function removeTokens(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.startToken;",
                    "    delete node.endToken;",
                    "    delete node.prev;",
                    "    delete node.next;",
                    "    for (const key in node) {",
                    "      removeTokens(node[key]);",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "const parseOptions = {",
                    "  allowLegacySDLImplementsInterfaces: false,",
                    "  experimentalFragmentVariables: true,",
                    "};",
                    "",
                    "function createParseError(error) {",
                    "  const { GraphQLError } = require(\"graphql/error/GraphQLError\");",
                    "  if (error instanceof GraphQLError) {",
                    "    const {",
                    "      message,",
                    "      locations: [start],",
                    "    } = error;",
                    "    return createError(message, { start });",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  return error;",
                    "}",
                    "",
                    "function parse(text /*, parsers, opts*/) {",
                    "  // Inline the require to avoid loading all the JS if we don't use it",
                    "  const { parse } = require(\"graphql/language/parser\");",
                    "  const { result: ast, error } = tryCombinations(",
                    "    () => parse(text, { ...parseOptions }),",
                    "    () =>",
                    "      parse(text, { ...parseOptions, allowLegacySDLImplementsInterfaces: true })",
                    "  );",
                    "",
                    "  if (!ast) {",
                    "    throw createParseError(error);",
                    "  }",
                    "",
                    "  ast.comments = parseComments(ast);",
                    "  removeTokens(ast);",
                    "  return ast;",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    graphql: {",
                    "      parse,",
                    "      astFormat: \"graphql\",",
                    "      hasPragma,",
                    "      locStart,",
                    "      locEnd,",
                    "    },",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  get graphql() {",
                    "    return require(\"./parser-graphql.js\").parsers.graphql;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(?:format|prettier)\\s*(?:\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"# @format\\n\\n\" + text;",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "printer-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { join, hardline, line, softline, group, indent, ifBreak },",
                    "} = require(\"../document/index.js\");",
                    "const { isNextLineEmpty, isNonEmptyArray } = require(\"../common/util.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof node === \"string\") {",
                    "    return node;",
                    "  }",
                    "",
                    "  switch (node.kind) {",
                    "    case \"Document\": {",
                    "      const parts = [];",
                    "      path.each((pathChild, index, definitions) => {",
                    "        parts.push(print());",
                    "        if (index !== definitions.length - 1) {",
                    "          parts.push(hardline);",
                    "          if (",
                    "            isNextLineEmpty(options.originalText, pathChild.getValue(), locEnd)",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }",
                    "      }, \"definitions\");",
                    "      return [...parts, hardline];",
                    "    }",
                    "    case \"OperationDefinition\": {",
                    "      const hasOperation = options.originalText[locStart(node)] !== \"{\";",
                    "      const hasName = Boolean(node.name);",
                    "      return [",
                    "        hasOperation ? node.operation : \"\",",
                    "        hasOperation && hasName ? [\" \", print(\"name\")] : \"\",",
                    "        hasOperation && !hasName && isNonEmptyArray(node.variableDefinitions)",
                    "          ? \" \"",
                    "          : \"\",",
                    "        isNonEmptyArray(node.variableDefinitions)",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  path.map(print, \"variableDefinitions\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.selectionSet ? (!hasOperation && !hasName ? \"\" : \" \") : \"\",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "    }",
                    "    case \"FragmentDefinition\": {",
                    "      return [",
                    "        \"fragment \",",
                    "        print(\"name\"),",
                    "        isNonEmptyArray(node.variableDefinitions)",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  path.map(print, \"variableDefinitions\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        \" on \",",
                    "        print(\"typeCondition\"),",
                    "        printDirectives(path, print, node),",
                    "        \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "    }",
                    "    case \"SelectionSet\": {",
                    "      return [",
                    "        \"{\",",
                    "        indent([",
                    "          hardline,",
                    "          join(hardline, printSequence(path, options, print, \"selections\")),",
                    "        ]),",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "    }",
                    "    case \"Field\": {",
                    "      return group([",
                    "        node.alias ? [print(\"alias\"), \": \"] : \"\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.selectionSet ? \" \" : \"\",",
                    "        print(\"selectionSet\"),",
                    "      ]);",
                    "    }",
                    "    case \"Name\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"StringValue\": {",
                    "      if (node.block) {",
                    "        const lines = node.value.replace(/\"\"\"/g, \"\\\\$&\").split(\"\\n\");",
                    "        if (lines.length === 1) {",
                    "          lines[0] = lines[0].trim();",
                    "        }",
                    "",
                    "        if (lines.every((line) => line === \"\")) {",
                    "          lines.length = 0;",
                    "        }",
                    "",
                    "        return join(hardline, ['\"\"\"', ...lines, '\"\"\"']);",
                    "      }",
                    "      return [",
                    "        '\"',",
                    "        node.value.replace(/[\"\\\\]/g, \"\\\\$&\").replace(/\\n/g, \"\\\\n\"),",
                    "        '\"',",
                    "      ];",
                    "    }",
                    "    case \"IntValue\":",
                    "    case \"FloatValue\":",
                    "    case \"EnumValue\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"BooleanValue\": {",
                    "      return node.value ? \"true\" : \"false\";",
                    "    }",
                    "    case \"NullValue\": {",
                    "      return \"null\";",
                    "    }",
                    "    case \"Variable\": {",
                    "      return [\"$\", print(\"name\")];",
                    "    }",
                    "    case \"ListValue\": {",
                    "      return group([",
                    "        \"[\",",
                    "        indent([",
                    "          softline,",
                    "          join([ifBreak(\"\", \", \"), softline], path.map(print, \"values\")),",
                    "        ]),",
                    "        softline,",
                    "        \"]\",",
                    "      ]);",
                    "    }",
                    "    case \"ObjectValue\": {",
                    "      return group([",
                    "        \"{\",",
                    "        options.bracketSpacing && node.fields.length > 0 ? \" \" : \"\",",
                    "        indent([",
                    "          softline,",
                    "          join([ifBreak(\"\", \", \"), softline], path.map(print, \"fields\")),",
                    "        ]),",
                    "        softline,",
                    "        ifBreak(",
                    "          \"\",",
                    "          options.bracketSpacing && node.fields.length > 0 ? \" \" : \"\"",
                    "        ),",
                    "        \"}\",",
                    "      ]);",
                    "    }",
                    "    case \"ObjectField\":",
                    "    case \"Argument\": {",
                    "      return [print(\"name\"), \": \", print(\"value\")];",
                    "    }",
                    "",
                    "    case \"Directive\": {",
                    "      return [",
                    "        \"@\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"NamedType\": {",
                    "      return print(\"name\");",
                    "    }",
                    "",
                    "    case \"VariableDefinition\": {",
                    "      return [",
                    "        print(\"variable\"),",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        node.defaultValue ? [\" = \", print(\"defaultValue\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"ObjectTypeExtension\":",
                    "    case \"ObjectTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"ObjectTypeExtension\" ? \"extend \" : \"\",",
                    "        \"type \",",
                    "        print(\"name\"),",
                    "        node.interfaces.length > 0",
                    "          ? [\" implements \", ...printInterfaces(path, options, print)]",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.fields.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(hardline, printSequence(path, options, print, \"fields\")),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"FieldDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"DirectiveDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        \"directive \",",
                    "        \"@\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        node.repeatable ? \" repeatable\" : \"\",",
                    "        \" on \",",
                    "        join(\" | \", path.map(print, \"locations\")),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"EnumTypeExtension\":",
                    "    case \"EnumTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"EnumTypeExtension\" ? \"extend \" : \"\",",
                    "        \"enum \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "",
                    "        node.values.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(hardline, printSequence(path, options, print, \"values\")),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"EnumValueDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"InputValueDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? (node.description.block ? hardline : line) : \"\",",
                    "        print(\"name\"),",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        node.defaultValue ? [\" = \", print(\"defaultValue\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"InputObjectTypeExtension\":",
                    "    case \"InputObjectTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"InputObjectTypeExtension\" ? \"extend \" : \"\",",
                    "        \"input \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "        node.fields.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(hardline, printSequence(path, options, print, \"fields\")),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"SchemaExtension\": {",
                    "      return [",
                    "        \"extend schema\",",
                    "        printDirectives(path, print, node),",
                    "        ...(node.operationTypes.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  printSequence(path, options, print, \"operationTypes\")",
                    "                ),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : []),",
                    "      ];",
                    "    }",
                    "    case \"SchemaDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        \"schema\",",
                    "        printDirectives(path, print, node),",
                    "        \" {\",",
                    "        node.operationTypes.length > 0",
                    "          ? indent([",
                    "              hardline,",
                    "              join(",
                    "                hardline,",
                    "                printSequence(path, options, print, \"operationTypes\")",
                    "              ),",
                    "            ])",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"OperationTypeDefinition\": {",
                    "      return [print(\"operation\"), \": \", print(\"type\")];",
                    "    }",
                    "",
                    "    case \"InterfaceTypeExtension\":",
                    "    case \"InterfaceTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"InterfaceTypeExtension\" ? \"extend \" : \"\",",
                    "        \"interface \",",
                    "        print(\"name\"),",
                    "        node.interfaces.length > 0",
                    "          ? [\" implements \", ...printInterfaces(path, options, print)]",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.fields.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(hardline, printSequence(path, options, print, \"fields\")),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"FragmentSpread\": {",
                    "      return [\"...\", print(\"name\"), printDirectives(path, print, node)];",
                    "    }",
                    "",
                    "    case \"InlineFragment\": {",
                    "      return [",
                    "        \"...\",",
                    "        node.typeCondition ? [\" on \", print(\"typeCondition\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "        \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"UnionTypeExtension\":",
                    "    case \"UnionTypeDefinition\": {",
                    "      return group([",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        group([",
                    "          node.kind === \"UnionTypeExtension\" ? \"extend \" : \"\",",
                    "          \"union \",",
                    "          print(\"name\"),",
                    "          printDirectives(path, print, node),",
                    "          node.types.length > 0",
                    "            ? [",
                    "                \" =\",",
                    "                ifBreak(\"\", \" \"),",
                    "                indent([",
                    "                  ifBreak([line, \"  \"]),",
                    "                  join([line, \"| \"], path.map(print, \"types\")),",
                    "                ]),",
                    "              ]",
                    "            : \"\",",
                    "        ]),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"ScalarTypeExtension\":",
                    "    case \"ScalarTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\",",
                    "        \"scalar \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"NonNullType\": {",
                    "      return [print(\"type\"), \"!\"];",
                    "    }",
                    "",
                    "    case \"ListType\": {",
                    "      return [\"[\", print(\"type\"), \"]\"];",
                    "    }",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown graphql type: \" + JSON.stringify(node.kind));",
                    "  }",
                    "}",
                    "",
                    "function printDirectives(path, print, node) {",
                    "  if (node.directives.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const printed = join(line, path.map(print, \"directives\"));",
                    "",
                    "  if (",
                    "    node.kind === \"FragmentDefinition\" ||",
                    "    node.kind === \"OperationDefinition\"",
                    "  ) {",
                    "    return group([line, printed]);",
                    "  }",
                    "",
                    "  return [\" \", group(indent([softline, printed]))];",
                    "}",
                    "",
                    "function printSequence(path, options, print, property) {",
                    "  return path.map((path, index, sequence) => {",
                    "    const printed = print();",
                    "",
                    "    if (",
                    "      index < sequence.length - 1 &&",
                    "      isNextLineEmpty(options.originalText, path.getValue(), locEnd)",
                    "    ) {",
                    "      return [printed, hardline];",
                    "    }",
                    "",
                    "    return printed;",
                    "  }, property);",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return node.kind && node.kind !== \"Comment\";",
                    "}",
                    "",
                    "function printComment(commentPath) {",
                    "  const comment = commentPath.getValue();",
                    "  if (comment.kind === \"Comment\") {",
                    "    return \"#\" + comment.value.trimEnd();",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                    "}",
                    "",
                    "function printInterfaces(path, options, print) {",
                    "  const node = path.getNode();",
                    "  const parts = [];",
                    "  const { interfaces } = node;",
                    "  const printed = path.map((node) => print(node), \"interfaces\");",
                    "",
                    "  for (let index = 0; index < interfaces.length; index++) {",
                    "    const interfaceNode = interfaces[index];",
                    "    parts.push(printed[index]);",
                    "    const nextInterfaceNode = interfaces[index + 1];",
                    "    if (nextInterfaceNode) {",
                    "      const textBetween = options.originalText.slice(",
                    "        interfaceNode.loc.end,",
                    "        nextInterfaceNode.loc.start",
                    "      );",
                    "      const hasComment = textBetween.includes(\"#\");",
                    "      const separator = textBetween.replace(/#.*/g, \"\").trim();",
                    "",
                    "      parts.push(separator === \",\" ? \",\" : \" &\", hasComment ? line : \" \");",
                    "    }",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function clean(node, newNode /* , parent */) {",
                    "  // We print single line `\"\"\" string \"\"\"` as multiple line string,",
                    "  // and the parser ignores space in multiple line string",
                    "  if (node.kind === \"StringValue\" && node.block && !node.value.includes(\"\\n\")) {",
                    "    newNode.value = newNode.value.trim();",
                    "  }",
                    "}",
                    "clean.ignoredProperties = new Set([\"loc\", \"comments\"]);",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const node = path.getValue();",
                    "  return node?.comments?.some(",
                    "    (comment) => comment.value.trim() === \"prettier-ignore\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  insertPragma,",
                    "  printComment,",
                    "  canAttachComment,",
                    "};"
                ]
            }
        },
        "language-handlebars": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function clean(ast, newNode /*, parent*/) {",
                    "  // (Glimmer/HTML) ignore TextNode",
                    "  if (ast.type === \"TextNode\") {",
                    "    const trimmed = ast.chars.trim();",
                    "    if (!trimmed) {",
                    "      return null;",
                    "    }",
                    "    newNode.chars = trimmed.replace(/[\\t\\n\\f\\r ]+/g, \" \");",
                    "  }",
                    "",
                    "  // `class` is reformatted",
                    "  if (ast.type === \"AttrNode\" && ast.name.toLowerCase() === \"class\") {",
                    "    delete newNode.value;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = new Set([\"loc\", \"selfClosing\"]);",
                    "",
                    "module.exports = clean;"
                ]
            },
            "html-void-elements.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  voidMap,",
                    "} = require(\"@glimmer/syntax/dist/commonjs/es2017/lib/generation/printer.js\");",
                    "",
                    "module.exports = Object.keys(voidMap);"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-glimmer.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/Handlebars.json\"), () => ({",
                    "    since: \"2.3.0\",",
                    "    parsers: [\"glimmer\"],",
                    "    vscodeLanguageIds: [\"handlebars\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  glimmer: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  return node.loc.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.loc.end.offset;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "parser-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { LinesAndColumns } = require(\"lines-and-columns\");",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "/* from the following template: `non-escaped mustache \\\\{{helper}}`",
                    " * glimmer parser will produce an AST missing a backslash",
                    " * so here we add it back",
                    " * */",
                    "function addBackslash(/* options*/) {",
                    "  return {",
                    "    name: \"addBackslash\",",
                    "    visitor: {",
                    "      All(node) {",
                    "        const childrenOrBody = node.children ?? node.body;",
                    "        if (childrenOrBody) {",
                    "          for (let i = 0; i < childrenOrBody.length - 1; i++) {",
                    "            if (",
                    "              childrenOrBody[i].type === \"TextNode\" &&",
                    "              childrenOrBody[i + 1].type === \"MustacheStatement\"",
                    "            ) {",
                    "              childrenOrBody[i].chars = childrenOrBody[i].chars.replace(",
                    "                /\\\\$/,",
                    "                \"\\\\\\\\\"",
                    "              );",
                    "            }",
                    "          }",
                    "        }",
                    "      },",
                    "    },",
                    "  };",
                    "}",
                    "",
                    "// Add `loc.{start,end}.offset`",
                    "function addOffset(text) {",
                    "  const lines = new LinesAndColumns(text);",
                    "  const calculateOffset = ({ line, column }) =>",
                    "    lines.indexForLocation({ line: line - 1, column });",
                    "  return (/* options*/) => ({",
                    "    name: \"addOffset\",",
                    "    visitor: {",
                    "      All(node) {",
                    "        const { start, end } = node.loc;",
                    "        start.offset = calculateOffset(start);",
                    "        end.offset = calculateOffset(end);",
                    "      },",
                    "    },",
                    "  });",
                    "}",
                    "",
                    "function parse(text) {",
                    "  const { preprocess: glimmer } = require(\"@glimmer/syntax\");",
                    "  let ast;",
                    "  try {",
                    "    ast = glimmer(text, {",
                    "      mode: \"codemod\",",
                    "      plugins: { ast: [addBackslash, addOffset(text)] },",
                    "    });",
                    "  } catch (error) {",
                    "    const location = getErrorLocation(error);",
                    "",
                    "    if (location) {",
                    "      throw createError(error.message, location);",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw error;",
                    "  }",
                    "",
                    "  return ast;",
                    "}",
                    "",
                    "function getErrorLocation(error) {",
                    "  const { location, hash } = error;",
                    "  if (location) {",
                    "    const { start, end } = location;",
                    "    if (typeof end.line !== \"number\") {",
                    "      return { start };",
                    "    }",
                    "    return location;",
                    "  }",
                    "",
                    "  if (hash) {",
                    "    const {",
                    "      loc: { last_line, last_column },",
                    "    } = hash;",
                    "    return { start: { line: last_line, column: last_column + 1 } };",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    glimmer: {",
                    "      parse,",
                    "      astFormat: \"glimmer\",",
                    "      locStart,",
                    "      locEnd,",
                    "    },",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  get glimmer() {",
                    "    return require(\"./parser-glimmer.js\").parsers.glimmer;",
                    "  },",
                    "};"
                ]
            },
            "printer-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: {",
                    "    dedent,",
                    "    fill,",
                    "    group,",
                    "    hardline,",
                    "    ifBreak,",
                    "    indent,",
                    "    join,",
                    "    line,",
                    "    softline,",
                    "  },",
                    "  utils: { getDocParts, replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const { getPreferredQuote, isNonEmptyArray } = require(\"../common/util.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const {",
                    "  getNextNode,",
                    "  getPreviousNode,",
                    "  hasPrettierIgnore,",
                    "  isLastNodeOfSiblings,",
                    "  isNextNodeOfSomeType,",
                    "  isNodeOfSomeType,",
                    "  isParentOfSomeType,",
                    "  isPreviousNodeOfSomeType,",
                    "  isVoid,",
                    "  isWhitespaceNode,",
                    "} = require(\"./utils.js\");",
                    "",
                    "/**",
                    " * @typedef {import(\"../document\").Doc} Doc",
                    " */",
                    "",
                    "const NEWLINES_TO_PRESERVE_MAX = 2;",
                    "",
                    "// Formatter based on @glimmerjs/syntax's built-in test formatter:",
                    "// https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts",
                    "",
                    "function print(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  /* istanbul ignore if*/",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (hasPrettierIgnore(path)) {",
                    "    return options.originalText.slice(locStart(node), locEnd(node));",
                    "  }",
                    "",
                    "  const favoriteQuote = options.singleQuote ? \"'\" : '\"';",
                    "",
                    "  switch (node.type) {",
                    "    case \"Block\":",
                    "    case \"Program\":",
                    "    case \"Template\": {",
                    "      return group(path.map(print, \"body\"));",
                    "    }",
                    "",
                    "    case \"ElementNode\": {",
                    "      const startingTag = group(printStartingTag(path, print));",
                    "",
                    "      const escapeNextElementNode =",
                    "        options.htmlWhitespaceSensitivity === \"ignore\" &&",
                    "        isNextNodeOfSomeType(path, [\"ElementNode\"])",
                    "          ? softline",
                    "          : \"\";",
                    "",
                    "      if (isVoid(node)) {",
                    "        return [startingTag, escapeNextElementNode];",
                    "      }",
                    "",
                    "      const endingTag = [\"</\", node.tag, \">\"];",
                    "",
                    "      if (node.children.length === 0) {",
                    "        return [startingTag, indent(endingTag), escapeNextElementNode];",
                    "      }",
                    "",
                    "      if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "        return [",
                    "          startingTag,",
                    "          indent(printChildren(path, options, print)),",
                    "          hardline,",
                    "          indent(endingTag),",
                    "          escapeNextElementNode,",
                    "        ];",
                    "      }",
                    "",
                    "      return [",
                    "        startingTag,",
                    "        indent(group(printChildren(path, options, print))),",
                    "        indent(endingTag),",
                    "        escapeNextElementNode,",
                    "      ];",
                    "    }",
                    "",
                    "    case \"BlockStatement\": {",
                    "      const pp = path.getParentNode(1);",
                    "",
                    "      const isElseIfLike =",
                    "        pp &&",
                    "        pp.inverse &&",
                    "        pp.inverse.body.length === 1 &&",
                    "        pp.inverse.body[0] === node &&",
                    "        pp.inverse.body[0].path.parts[0] === pp.path.parts[0];",
                    "",
                    "      if (isElseIfLike) {",
                    "        return [",
                    "          printElseIfLikeBlock(path, print, pp.inverse.body[0].path.parts[0]),",
                    "          printProgram(path, print, options),",
                    "          printInverse(path, print, options),",
                    "        ];",
                    "      }",
                    "",
                    "      return [",
                    "        printOpenBlock(path, print),",
                    "        group([",
                    "          printProgram(path, print, options),",
                    "          printInverse(path, print, options),",
                    "          printCloseBlock(path, print, options),",
                    "        ]),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"ElementModifierStatement\": {",
                    "      return group([\"{{\", printPathAndParams(path, print), \"}}\"]);",
                    "    }",
                    "",
                    "    case \"MustacheStatement\": {",
                    "      return group([",
                    "        printOpeningMustache(node),",
                    "        printPathAndParams(path, print),",
                    "        printClosingMustache(node),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"SubExpression\": {",
                    "      return group([",
                    "        \"(\",",
                    "        printSubExpressionPathAndParams(path, print),",
                    "        softline,",
                    "        \")\",",
                    "      ]);",
                    "    }",
                    "    case \"AttrNode\": {",
                    "      const isText = node.value.type === \"TextNode\";",
                    "      const isEmptyText = isText && node.value.chars === \"\";",
                    "",
                    "      // If the text is empty and the value's loc start and end offsets are the",
                    "      // same, there is no value for this AttrNode and it should be printed",
                    "      // without the `=\"\"`. Example: `<img data-test>` -> `<img data-test>`",
                    "      if (isEmptyText && locStart(node.value) === locEnd(node.value)) {",
                    "        return node.name;",
                    "      }",
                    "",
                    "      // Let's assume quotes inside the content of text nodes are already",
                    "      // properly escaped with entities, otherwise the parse wouldn't have parsed them.",
                    "      const quote = isText",
                    "        ? getPreferredQuote(node.value.chars, favoriteQuote).quote",
                    "        : node.value.type === \"ConcatStatement\"",
                    "        ? getPreferredQuote(",
                    "            node.value.parts",
                    "              .filter((part) => part.type === \"TextNode\")",
                    "              .map((part) => part.chars)",
                    "              .join(\"\"),",
                    "            favoriteQuote",
                    "          ).quote",
                    "        : \"\";",
                    "",
                    "      const valueDoc = print(\"value\");",
                    "",
                    "      return [",
                    "        node.name,",
                    "        \"=\",",
                    "        quote,",
                    "        node.name === \"class\" && quote ? group(indent(valueDoc)) : valueDoc,",
                    "        quote,",
                    "      ];",
                    "    }",
                    "",
                    "    case \"ConcatStatement\": {",
                    "      return path.map(print, \"parts\");",
                    "    }",
                    "",
                    "    case \"Hash\": {",
                    "      return join(line, path.map(print, \"pairs\"));",
                    "    }",
                    "    case \"HashPair\": {",
                    "      return [node.key, \"=\", print(\"value\")];",
                    "    }",
                    "    case \"TextNode\": {",
                    "      /* if `{{my-component}}` (or any text containing \"{{\")",
                    "       * makes it to the TextNode, it means it was escaped,",
                    "       * so let's print it escaped, ie.; `\\{{my-component}}` */",
                    "      let text = node.chars.replace(/{{/g, \"\\\\{{\");",
                    "",
                    "      const attrName = getCurrentAttributeName(path);",
                    "",
                    "      if (attrName) {",
                    "        // TODO: format style and srcset attributes",
                    "        if (attrName === \"class\") {",
                    "          const formattedClasses = text.trim().split(/\\s+/).join(\" \");",
                    "",
                    "          let leadingSpace = false;",
                    "          let trailingSpace = false;",
                    "",
                    "          if (isParentOfSomeType(path, [\"ConcatStatement\"])) {",
                    "            if (",
                    "              isPreviousNodeOfSomeType(path, [\"MustacheStatement\"]) &&",
                    "              /^\\s/.test(text)",
                    "            ) {",
                    "              leadingSpace = true;",
                    "            }",
                    "            if (",
                    "              isNextNodeOfSomeType(path, [\"MustacheStatement\"]) &&",
                    "              /\\s$/.test(text) &&",
                    "              formattedClasses !== \"\"",
                    "            ) {",
                    "              trailingSpace = true;",
                    "            }",
                    "          }",
                    "",
                    "          return [",
                    "            leadingSpace ? line : \"\",",
                    "            formattedClasses,",
                    "            trailingSpace ? line : \"\",",
                    "          ];",
                    "        }",
                    "",
                    "        return replaceTextEndOfLine(text);",
                    "      }",
                    "",
                    "      const whitespacesOnlyRE = /^[\\t\\n\\f\\r ]*$/;",
                    "      const isWhitespaceOnly = whitespacesOnlyRE.test(text);",
                    "      const isFirstElement = !getPreviousNode(path);",
                    "      const isLastElement = !getNextNode(path);",
                    "",
                    "      if (options.htmlWhitespaceSensitivity !== \"ignore\") {",
                    "        // https://infra.spec.whatwg.org/#ascii-whitespace",
                    "        const leadingWhitespacesRE = /^[\\t\\n\\f\\r ]*/;",
                    "        const trailingWhitespacesRE = /[\\t\\n\\f\\r ]*$/;",
                    "",
                    "        // let's remove the file's final newline",
                    "        // https://github.com/ember-cli/ember-new-output/blob/1a04c67ddd02ccb35e0ff41bb5cbce34b31173ef/.editorconfig#L16",
                    "        const shouldTrimTrailingNewlines =",
                    "          isLastElement && isParentOfSomeType(path, [\"Template\"]);",
                    "        const shouldTrimLeadingNewlines =",
                    "          isFirstElement && isParentOfSomeType(path, [\"Template\"]);",
                    "",
                    "        if (isWhitespaceOnly) {",
                    "          if (shouldTrimLeadingNewlines || shouldTrimTrailingNewlines) {",
                    "            return \"\";",
                    "          }",
                    "",
                    "          let breaks = [line];",
                    "",
                    "          const newlines = countNewLines(text);",
                    "          if (newlines) {",
                    "            breaks = generateHardlines(newlines);",
                    "          }",
                    "",
                    "          if (isLastNodeOfSiblings(path)) {",
                    "            breaks = breaks.map((newline) => dedent(newline));",
                    "          }",
                    "",
                    "          return breaks;",
                    "        }",
                    "",
                    "        const [lead] = text.match(leadingWhitespacesRE);",
                    "        const [tail] = text.match(trailingWhitespacesRE);",
                    "",
                    "        let leadBreaks = [];",
                    "        if (lead) {",
                    "          leadBreaks = [line];",
                    "",
                    "          const leadingNewlines = countNewLines(lead);",
                    "          if (leadingNewlines) {",
                    "            leadBreaks = generateHardlines(leadingNewlines);",
                    "          }",
                    "",
                    "          text = text.replace(leadingWhitespacesRE, \"\");",
                    "        }",
                    "",
                    "        let trailBreaks = [];",
                    "        if (tail) {",
                    "          if (!shouldTrimTrailingNewlines) {",
                    "            trailBreaks = [line];",
                    "",
                    "            const trailingNewlines = countNewLines(tail);",
                    "            if (trailingNewlines) {",
                    "              trailBreaks = generateHardlines(trailingNewlines);",
                    "            }",
                    "",
                    "            if (isLastNodeOfSiblings(path)) {",
                    "              trailBreaks = trailBreaks.map((hardline) => dedent(hardline));",
                    "            }",
                    "          }",
                    "",
                    "          text = text.replace(trailingWhitespacesRE, \"\");",
                    "        }",
                    "",
                    "        return [...leadBreaks, fill(getTextValueParts(text)), ...trailBreaks];",
                    "      }",
                    "",
                    "      const lineBreaksCount = countNewLines(text);",
                    "",
                    "      let leadingLineBreaksCount = countLeadingNewLines(text);",
                    "      let trailingLineBreaksCount = countTrailingNewLines(text);",
                    "",
                    "      if (",
                    "        (isFirstElement || isLastElement) &&",
                    "        isWhitespaceOnly &&",
                    "        isParentOfSomeType(path, [\"Block\", \"ElementNode\", \"Template\"])",
                    "      ) {",
                    "        return \"\";",
                    "      }",
                    "",
                    "      if (isWhitespaceOnly && lineBreaksCount) {",
                    "        leadingLineBreaksCount = Math.min(",
                    "          lineBreaksCount,",
                    "          NEWLINES_TO_PRESERVE_MAX",
                    "        );",
                    "        trailingLineBreaksCount = 0;",
                    "      } else {",
                    "        if (isNextNodeOfSomeType(path, [\"BlockStatement\", \"ElementNode\"])) {",
                    "          trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);",
                    "        }",
                    "",
                    "        if (isPreviousNodeOfSomeType(path, [\"BlockStatement\", \"ElementNode\"])) {",
                    "          leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);",
                    "        }",
                    "      }",
                    "",
                    "      let leadingSpace = \"\";",
                    "      let trailingSpace = \"\";",
                    "",
                    "      if (",
                    "        trailingLineBreaksCount === 0 &&",
                    "        isNextNodeOfSomeType(path, [\"MustacheStatement\"])",
                    "      ) {",
                    "        trailingSpace = \" \";",
                    "      }",
                    "",
                    "      if (",
                    "        leadingLineBreaksCount === 0 &&",
                    "        isPreviousNodeOfSomeType(path, [\"MustacheStatement\"])",
                    "      ) {",
                    "        leadingSpace = \" \";",
                    "      }",
                    "",
                    "      if (isFirstElement) {",
                    "        leadingLineBreaksCount = 0;",
                    "        leadingSpace = \"\";",
                    "      }",
                    "",
                    "      if (isLastElement) {",
                    "        trailingLineBreaksCount = 0;",
                    "        trailingSpace = \"\";",
                    "      }",
                    "",
                    "      text = text",
                    "        .replace(/^[\\t\\n\\f\\r ]+/g, leadingSpace)",
                    "        .replace(/[\\t\\n\\f\\r ]+$/, trailingSpace);",
                    "",
                    "      return [",
                    "        ...generateHardlines(leadingLineBreaksCount),",
                    "        fill(getTextValueParts(text)),",
                    "        ...generateHardlines(trailingLineBreaksCount),",
                    "      ];",
                    "    }",
                    "    case \"MustacheCommentStatement\": {",
                    "      const start = locStart(node);",
                    "      const end = locEnd(node);",
                    "      // Starts with `{{~`",
                    "      const isLeftWhiteSpaceSensitive =",
                    "        options.originalText.charAt(start + 2) === \"~\";",
                    "      // Ends with `{{~`",
                    "      const isRightWhitespaceSensitive =",
                    "        options.originalText.charAt(end - 3) === \"~\";",
                    "",
                    "      const dashes = node.value.includes(\"}}\") ? \"--\" : \"\";",
                    "      return [",
                    "        \"{{\",",
                    "        isLeftWhiteSpaceSensitive ? \"~\" : \"\",",
                    "        \"!\",",
                    "        dashes,",
                    "        node.value,",
                    "        dashes,",
                    "        isRightWhitespaceSensitive ? \"~\" : \"\",",
                    "        \"}}\",",
                    "      ];",
                    "    }",
                    "    case \"PathExpression\": {",
                    "      return node.original;",
                    "    }",
                    "    case \"BooleanLiteral\": {",
                    "      return String(node.value);",
                    "    }",
                    "    case \"CommentStatement\": {",
                    "      return [\"<!--\", node.value, \"-->\"];",
                    "    }",
                    "    case \"StringLiteral\": {",
                    "      if (needsOppositeQuote(path)) {",
                    "        const printFavoriteQuote = !options.singleQuote ? \"'\" : '\"';",
                    "        return printStringLiteral(node.value, printFavoriteQuote);",
                    "      }",
                    "      return printStringLiteral(node.value, favoriteQuote);",
                    "    }",
                    "    case \"NumberLiteral\": {",
                    "      return String(node.value);",
                    "    }",
                    "    case \"UndefinedLiteral\": {",
                    "      return \"undefined\";",
                    "    }",
                    "    case \"NullLiteral\": {",
                    "      return \"null\";",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    default:",
                    "      throw new Error(\"unknown glimmer type: \" + JSON.stringify(node.type));",
                    "  }",
                    "}",
                    "",
                    "/* ElementNode print helpers */",
                    "",
                    "function sortByLoc(a, b) {",
                    "  return locStart(a) - locStart(b);",
                    "}",
                    "",
                    "function printStartingTag(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  const types = [\"attributes\", \"modifiers\", \"comments\"].filter((property) =>",
                    "    isNonEmptyArray(node[property])",
                    "  );",
                    "  const attributes = types.flatMap((type) => node[type]).sort(sortByLoc);",
                    "",
                    "  for (const attributeType of types) {",
                    "    path.each((attributePath) => {",
                    "      const index = attributes.indexOf(attributePath.getValue());",
                    "      attributes.splice(index, 1, [line, print()]);",
                    "    }, attributeType);",
                    "  }",
                    "",
                    "  if (isNonEmptyArray(node.blockParams)) {",
                    "    attributes.push(line, printBlockParams(node));",
                    "  }",
                    "",
                    "  return [\"<\", node.tag, indent(attributes), printStartingTagEndMarker(node)];",
                    "}",
                    "",
                    "function printChildren(path, options, print) {",
                    "  const node = path.getValue();",
                    "  const isEmpty = node.children.every((node) => isWhitespaceNode(node));",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\" && isEmpty) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return path.map((childPath, childIndex) => {",
                    "    const printedChild = print();",
                    "",
                    "    if (childIndex === 0 && options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "      return [softline, printedChild];",
                    "    }",
                    "",
                    "    return printedChild;",
                    "  }, \"children\");",
                    "}",
                    "",
                    "function printStartingTagEndMarker(node) {",
                    "  if (isVoid(node)) {",
                    "    return ifBreak([softline, \"/>\"], [\" />\", softline]);",
                    "  }",
                    "",
                    "  return ifBreak([softline, \">\"], \">\");",
                    "}",
                    "",
                    "/* MustacheStatement print helpers */",
                    "",
                    "function printOpeningMustache(node) {",
                    "  const mustache = node.escaped === false ? \"{{{\" : \"{{\";",
                    "  const strip = node.strip && node.strip.open ? \"~\" : \"\";",
                    "  return [mustache, strip];",
                    "}",
                    "",
                    "function printClosingMustache(node) {",
                    "  const mustache = node.escaped === false ? \"}}}\" : \"}}\";",
                    "  const strip = node.strip && node.strip.close ? \"~\" : \"\";",
                    "  return [strip, mustache];",
                    "}",
                    "",
                    "/* BlockStatement print helpers */",
                    "",
                    "function printOpeningBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.openStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip, \"#\"];",
                    "}",
                    "",
                    "function printOpeningBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.openStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printClosingBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.closeStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip, \"/\"];",
                    "}",
                    "",
                    "function printClosingBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.closeStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printInverseBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.inverseStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip];",
                    "}",
                    "",
                    "function printInverseBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.inverseStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printOpenBlock(path, print) {",
                    "  const node = path.getValue();",
                    "  /** @type {Doc[]} */",
                    "  const parts = [];",
                    "",
                    "  const paramsDoc = printParams(path, print);",
                    "  if (paramsDoc) {",
                    "    parts.push(group(paramsDoc));",
                    "  }",
                    "",
                    "  if (isNonEmptyArray(node.program.blockParams)) {",
                    "    parts.push(printBlockParams(node.program));",
                    "  }",
                    "",
                    "  return group([",
                    "    printOpeningBlockOpeningMustache(node),",
                    "    printPath(path, print),",
                    "    parts.length > 0 ? indent([line, join(line, parts)]) : \"\",",
                    "    softline,",
                    "    printOpeningBlockClosingMustache(node),",
                    "  ]);",
                    "}",
                    "",
                    "function printElseBlock(node, options) {",
                    "  return [",
                    "    options.htmlWhitespaceSensitivity === \"ignore\" ? hardline : \"\",",
                    "    printInverseBlockOpeningMustache(node),",
                    "    \"else\",",
                    "    printInverseBlockClosingMustache(node),",
                    "  ];",
                    "}",
                    "",
                    "function printElseIfLikeBlock(path, print, ifLikeKeyword) {",
                    "  const node = path.getValue();",
                    "  const parentNode = path.getParentNode(1);",
                    "",
                    "  return group([",
                    "    printInverseBlockOpeningMustache(parentNode),",
                    "    [\"else\", \" \", ifLikeKeyword],",
                    "    indent([",
                    "      line,",
                    "      group(printParams(path, print)),",
                    "      ...(isNonEmptyArray(node.program.blockParams)",
                    "        ? [line, printBlockParams(node.program)]",
                    "        : []),",
                    "    ]),",
                    "    softline,",
                    "    printInverseBlockClosingMustache(parentNode),",
                    "  ]);",
                    "}",
                    "",
                    "function printCloseBlock(path, print, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "    const escape = blockStatementHasOnlyWhitespaceInProgram(node)",
                    "      ? softline",
                    "      : hardline;",
                    "",
                    "    return [",
                    "      escape,",
                    "      printClosingBlockOpeningMustache(node),",
                    "      print(\"path\"),",
                    "      printClosingBlockClosingMustache(node),",
                    "    ];",
                    "  }",
                    "",
                    "  return [",
                    "    printClosingBlockOpeningMustache(node),",
                    "    print(\"path\"),",
                    "    printClosingBlockClosingMustache(node),",
                    "  ];",
                    "}",
                    "",
                    "function blockStatementHasOnlyWhitespaceInProgram(node) {",
                    "  return (",
                    "    isNodeOfSomeType(node, [\"BlockStatement\"]) &&",
                    "    node.program.body.every((node) => isWhitespaceNode(node))",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElseIfLike(node) {",
                    "  return (",
                    "    blockStatementHasElse(node) &&",
                    "    node.inverse.body.length === 1 &&",
                    "    isNodeOfSomeType(node.inverse.body[0], [\"BlockStatement\"]) &&",
                    "    node.inverse.body[0].path.parts[0] === node.path.parts[0]",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElse(node) {",
                    "  return isNodeOfSomeType(node, [\"BlockStatement\"]) && node.inverse;",
                    "}",
                    "",
                    "function printProgram(path, print, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (blockStatementHasOnlyWhitespaceInProgram(node)) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const program = print(\"program\");",
                    "",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "    return indent([hardline, program]);",
                    "  }",
                    "",
                    "  return indent(program);",
                    "}",
                    "",
                    "function printInverse(path, print, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  const inverse = print(\"inverse\");",
                    "  const printed =",
                    "    options.htmlWhitespaceSensitivity === \"ignore\"",
                    "      ? [hardline, inverse]",
                    "      : inverse;",
                    "",
                    "  if (blockStatementHasElseIfLike(node)) {",
                    "    return printed;",
                    "  }",
                    "",
                    "  if (blockStatementHasElse(node)) {",
                    "    return [printElseBlock(node, options), indent(printed)];",
                    "  }",
                    "",
                    "  return \"\";",
                    "}",
                    "",
                    "/* TextNode print helpers */",
                    "",
                    "function getTextValueParts(value) {",
                    "  return getDocParts(join(line, splitByHtmlWhitespace(value)));",
                    "}",
                    "",
                    "function splitByHtmlWhitespace(string) {",
                    "  return string.split(/[\\t\\n\\f\\r ]+/);",
                    "}",
                    "",
                    "function getCurrentAttributeName(path) {",
                    "  for (let depth = 0; depth < 2; depth++) {",
                    "    const parentNode = path.getParentNode(depth);",
                    "    if (parentNode && parentNode.type === \"AttrNode\") {",
                    "      return parentNode.name.toLowerCase();",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function countNewLines(string) {",
                    "  /* istanbul ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  return string.split(\"\\n\").length - 1;",
                    "}",
                    "",
                    "function countLeadingNewLines(string) {",
                    "  /* istanbul ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/^([^\\S\\n\\r]*[\\n\\r])+/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function countTrailingNewLines(string) {",
                    "  /* istanbul ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/([\\n\\r][^\\S\\n\\r]*)+$/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function generateHardlines(number = 0) {",
                    "  return Array.from({",
                    "    length: Math.min(number, NEWLINES_TO_PRESERVE_MAX),",
                    "  }).fill(hardline);",
                    "}",
                    "",
                    "/* StringLiteral print helpers */",
                    "",
                    "/** @typedef {import(\"../common/util\").Quote} Quote */",
                    "",
                    "/**",
                    " * Prints a string literal with the correct surrounding quotes based on",
                    " * `options.singleQuote` and the number of escaped quotes contained in",
                    " * the string literal. This function is the glimmer equivalent of `printString`",
                    " * in `common/util`, but has differences because of the way escaped characters",
                    " * are treated in hbs string literals.",
                    " * @param {string} stringLiteral - the string literal value",
                    " * @param {Quote} favoriteQuote - the user's preferred quote: `'` or `\"`",
                    " */",
                    "function printStringLiteral(stringLiteral, favoriteQuote) {",
                    "  const { quote, regex } = getPreferredQuote(stringLiteral, favoriteQuote);",
                    "  return [quote, stringLiteral.replace(regex, `\\\\${quote}`), quote];",
                    "}",
                    "",
                    "function needsOppositeQuote(path) {",
                    "  let index = 0;",
                    "  let parentNode = path.getParentNode(index);",
                    "  while (parentNode && isNodeOfSomeType(parentNode, [\"SubExpression\"])) {",
                    "    index++;",
                    "    parentNode = path.getParentNode(index);",
                    "  }",
                    "  if (",
                    "    parentNode &&",
                    "    isNodeOfSomeType(path.getParentNode(index + 1), [\"ConcatStatement\"]) &&",
                    "    isNodeOfSomeType(path.getParentNode(index + 2), [\"AttrNode\"])",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "/* SubExpression print helpers */",
                    "",
                    "function printSubExpressionPathAndParams(path, print) {",
                    "  const printed = printPath(path, print);",
                    "  const params = printParams(path, print);",
                    "",
                    "  if (!params) {",
                    "    return printed;",
                    "  }",
                    "",
                    "  return indent([printed, line, group(params)]);",
                    "}",
                    "",
                    "/* misc. print helpers */",
                    "",
                    "function printPathAndParams(path, print) {",
                    "  const p = printPath(path, print);",
                    "  const params = printParams(path, print);",
                    "",
                    "  if (!params) {",
                    "    return p;",
                    "  }",
                    "",
                    "  return [indent([p, line, params]), softline];",
                    "}",
                    "",
                    "function printPath(path, print) {",
                    "  return print(\"path\");",
                    "}",
                    "",
                    "function printParams(path, print) {",
                    "  const node = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  if (node.params.length > 0) {",
                    "    const params = path.map(print, \"params\");",
                    "    parts.push(...params);",
                    "  }",
                    "",
                    "  if (node.hash && node.hash.pairs.length > 0) {",
                    "    const hash = print(\"hash\");",
                    "    parts.push(hash);",
                    "  }",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return join(line, parts);",
                    "}",
                    "",
                    "function printBlockParams(node) {",
                    "  return [\"as |\", node.blockParams.join(\" \"), \"|\"];",
                    "}",
                    "",
                    "module.exports = {",
                    "  print,",
                    "  massageAstNode: clean,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const htmlVoidElements = require(\"./html-void-elements.evaluate.js\");",
                    "",
                    "function isLastNodeOfSiblings(path) {",
                    "  const node = path.getValue();",
                    "  const parentNode = path.getParentNode(0);",
                    "",
                    "  if (",
                    "    isParentOfSomeType(path, [\"ElementNode\"]) &&",
                    "    getLast(parentNode.children) === node",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    isParentOfSomeType(path, [\"Block\"]) &&",
                    "    getLast(parentNode.body) === node",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isUppercase(string) {",
                    "  return string.toUpperCase() === string;",
                    "}",
                    "",
                    "function isGlimmerComponent(node) {",
                    "  return (",
                    "    isNodeOfSomeType(node, [\"ElementNode\"]) &&",
                    "    typeof node.tag === \"string\" &&",
                    "    !node.tag.startsWith(\":\") &&",
                    "    (isUppercase(node.tag[0]) || node.tag.includes(\".\"))",
                    "  );",
                    "}",
                    "",
                    "const voidTags = new Set(htmlVoidElements);",
                    "// https://github.com/glimmerjs/glimmer-vm/blob/ec5648f3895b9ab8d085523be001553746221449/packages/%40glimmer/syntax/lib/generation/printer.ts#L44-L46",
                    "function isVoidTag(tag) {",
                    "  return voidTags.has(tag.toLowerCase()) && !isUppercase(tag[0]);",
                    "}",
                    "",
                    "function isVoid(node) {",
                    "  return (",
                    "    node.selfClosing === true ||",
                    "    isVoidTag(node.tag) ||",
                    "    (isGlimmerComponent(node) &&",
                    "      node.children.every((node) => isWhitespaceNode(node)))",
                    "  );",
                    "}",
                    "",
                    "function isWhitespaceNode(node) {",
                    "  return isNodeOfSomeType(node, [\"TextNode\"]) && !/\\S/.test(node.chars);",
                    "}",
                    "",
                    "function isNodeOfSomeType(node, types) {",
                    "  return node && types.includes(node.type);",
                    "}",
                    "",
                    "function isParentOfSomeType(path, types) {",
                    "  const parentNode = path.getParentNode(0);",
                    "  return isNodeOfSomeType(parentNode, types);",
                    "}",
                    "",
                    "function isPreviousNodeOfSomeType(path, types) {",
                    "  const previousNode = getPreviousNode(path);",
                    "  return isNodeOfSomeType(previousNode, types);",
                    "}",
                    "",
                    "function isNextNodeOfSomeType(path, types) {",
                    "  const nextNode = getNextNode(path);",
                    "  return isNodeOfSomeType(nextNode, types);",
                    "}",
                    "",
                    "function getSiblingNode(path, offset) {",
                    "  const node = path.getValue();",
                    "  const parentNode = path.getParentNode(0) ?? {};",
                    "  const children =",
                    "    parentNode.children ?? parentNode.body ?? parentNode.parts ?? [];",
                    "  const index = children.indexOf(node);",
                    "  return index !== -1 && children[index + offset];",
                    "}",
                    "",
                    "function getPreviousNode(path, lookBack = 1) {",
                    "  return getSiblingNode(path, -lookBack);",
                    "}",
                    "",
                    "function getNextNode(path) {",
                    "  return getSiblingNode(path, 1);",
                    "}",
                    "",
                    "function isPrettierIgnoreNode(node) {",
                    "  return (",
                    "    isNodeOfSomeType(node, [\"MustacheCommentStatement\"]) &&",
                    "    typeof node.value === \"string\" &&",
                    "    node.value.trim() === \"prettier-ignore\"",
                    "  );",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const node = path.getValue();",
                    "  const previousPreviousNode = getPreviousNode(path, 2);",
                    "  return (",
                    "    isPrettierIgnoreNode(node) || isPrettierIgnoreNode(previousPreviousNode)",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  getNextNode,",
                    "  getPreviousNode,",
                    "  hasPrettierIgnore,",
                    "  isLastNodeOfSiblings,",
                    "  isNextNodeOfSomeType,",
                    "  isNodeOfSomeType,",
                    "  isParentOfSomeType,",
                    "  isPreviousNodeOfSomeType,",
                    "  isVoid,",
                    "  isWhitespaceNode,",
                    "};"
                ]
            }
        },
        "language-html": {
            "ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const NODES_KEYS = {",
                    "  attrs: true,",
                    "  children: true,",
                    "};",
                    "",
                    "const NON_ENUMERABLE_PROPERTIES = new Set([\"parent\"]);",
                    "",
                    "// TODO: typechecking is problematic for this class because of this issue:",
                    "// https://github.com/microsoft/TypeScript/issues/26811",
                    "",
                    "class Node {",
                    "  constructor(nodeOrProperties = {}) {",
                    "    for (const property of new Set([",
                    "      ...NON_ENUMERABLE_PROPERTIES,",
                    "      ...Object.keys(nodeOrProperties),",
                    "    ])) {",
                    "      this.setProperty(property, nodeOrProperties[property]);",
                    "    }",
                    "  }",
                    "",
                    "  setProperty(property, value) {",
                    "    if (this[property] === value) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (property in NODES_KEYS) {",
                    "      value = value.map((node) => this.createChild(node));",
                    "    }",
                    "",
                    "    if (!NON_ENUMERABLE_PROPERTIES.has(property)) {",
                    "      this[property] = value;",
                    "      return;",
                    "    }",
                    "",
                    "    Object.defineProperty(this, property, {",
                    "      value,",
                    "      enumerable: false,",
                    "      configurable: true,",
                    "    });",
                    "  }",
                    "",
                    "  map(fn) {",
                    "    /** @type{any} */",
                    "    let newNode;",
                    "",
                    "    for (const NODES_KEY in NODES_KEYS) {",
                    "      const nodes = this[NODES_KEY];",
                    "      if (nodes) {",
                    "        const mappedNodes = mapNodesIfChanged(nodes, (node) => node.map(fn));",
                    "        if (newNode !== nodes) {",
                    "          if (!newNode) {",
                    "            // @ts-expect-error",
                    "            newNode = new Node({ parent: this.parent });",
                    "          }",
                    "          newNode.setProperty(NODES_KEY, mappedNodes);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (newNode) {",
                    "      for (const key in this) {",
                    "        if (!(key in NODES_KEYS)) {",
                    "          newNode[key] = this[key];",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return fn(newNode || this);",
                    "  }",
                    "",
                    "  walk(fn) {",
                    "    for (const NODES_KEY in NODES_KEYS) {",
                    "      const nodes = this[NODES_KEY];",
                    "      if (nodes) {",
                    "        for (let i = 0; i < nodes.length; i++) {",
                    "          nodes[i].walk(fn);",
                    "        }",
                    "      }",
                    "    }",
                    "    fn(this);",
                    "  }",
                    "",
                    "  createChild(nodeOrProperties) {",
                    "    const node =",
                    "      nodeOrProperties instanceof Node",
                    "        ? nodeOrProperties.clone()",
                    "        : new Node(nodeOrProperties);",
                    "    node.setProperty(\"parent\", this);",
                    "    return node;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [target]",
                    "   * @param {Object} [node]",
                    "   */",
                    "  insertChildBefore(target, node) {",
                    "    // @ts-expect-error",
                    "    this.children.splice(",
                    "      // @ts-expect-error",
                    "      this.children.indexOf(target),",
                    "      0,",
                    "      this.createChild(node)",
                    "    );",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [child]",
                    "   */",
                    "  removeChild(child) {",
                    "    // @ts-expect-error",
                    "    this.children.splice(this.children.indexOf(child), 1);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [target]",
                    "   * @param {Object} [node]",
                    "   */",
                    "  replaceChild(target, node) {",
                    "    // @ts-expect-error",
                    "    this.children[this.children.indexOf(target)] = this.createChild(node);",
                    "  }",
                    "",
                    "  clone() {",
                    "    return new Node(this);",
                    "  }",
                    "",
                    "  get firstChild() {",
                    "    // @ts-expect-error",
                    "    return this.children?.[0];",
                    "  }",
                    "",
                    "  get lastChild() {",
                    "    // @ts-expect-error",
                    "    return this.children?.[this.children.length - 1];",
                    "  }",
                    "",
                    "  get prev() {",
                    "    // @ts-expect-error",
                    "    return this.parent?.children[this.parent.children.indexOf(this) - 1];",
                    "  }",
                    "",
                    "  get next() {",
                    "    // @ts-expect-error",
                    "    return this.parent?.children[this.parent.children.indexOf(this) + 1];",
                    "  }",
                    "",
                    "  // for element and attribute",
                    "  get rawName() {",
                    "    // @ts-expect-error",
                    "    return this.hasExplicitNamespace ? this.fullName : this.name;",
                    "  }",
                    "",
                    "  get fullName() {",
                    "    // @ts-expect-error",
                    "    return this.namespace ? this.namespace + \":\" + this.name : this.name;",
                    "  }",
                    "",
                    "  get attrMap() {",
                    "    return Object.fromEntries(",
                    "      // @ts-expect-error",
                    "      this.attrs.map((attr) => [attr.fullName, attr.value])",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function mapNodesIfChanged(nodes, fn) {",
                    "  const newNodes = nodes.map(fn);",
                    "  return newNodes.some((newNode, index) => newNode !== nodes[index])",
                    "    ? newNodes",
                    "    : nodes;",
                    "}",
                    "",
                    "module.exports = {",
                    "  Node,",
                    "};"
                ]
            },
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isFrontMatterNode } = require(\"../common/util.js\");",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"sourceSpan\",",
                    "  \"startSourceSpan\",",
                    "  \"endSourceSpan\",",
                    "  \"nameSpan\",",
                    "  \"valueSpan\",",
                    "]);",
                    "",
                    "function clean(ast, newNode) {",
                    "  if (ast.type === \"text\" || ast.type === \"comment\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // may be formatted by multiparser",
                    "  if (isFrontMatterNode(ast) || ast.type === \"yaml\" || ast.type === \"toml\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"attribute\") {",
                    "    delete newNode.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"docType\") {",
                    "    delete newNode.value;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "module.exports = clean;"
                ]
            },
            "conditional-comment.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  ParseSourceSpan,",
                    "} = require(\"angular-html-parser/lib/compiler/src/parse_util\");",
                    "",
                    "// https://css-tricks.com/how-to-create-an-ie-only-stylesheet",
                    "",
                    "const parseFunctions = [",
                    "  {",
                    "    // <!--[if ... ]> ... <![endif]-->",
                    "    regex: /^(\\[if([^\\]]*)]>)(.*?)<!\\s*\\[endif]$/s,",
                    "    parse: parseIeConditionalStartEndComment,",
                    "  },",
                    "  {",
                    "    // <!--[if ... ]><!-->",
                    "    regex: /^\\[if([^\\]]*)]><!$/,",
                    "    parse: parseIeConditionalStartComment,",
                    "  },",
                    "  {",
                    "    // <!--<![endif]-->",
                    "    regex: /^<!\\s*\\[endif]$/,",
                    "    parse: parseIeConditionalEndComment,",
                    "  },",
                    "];",
                    "",
                    "function parseIeConditionalComment(node, parseHtml) {",
                    "  if (node.value) {",
                    "    for (const { regex, parse } of parseFunctions) {",
                    "      const match = node.value.match(regex);",
                    "      if (match) {",
                    "        return parse(node, parseHtml, match);",
                    "      }",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function parseIeConditionalStartEndComment(node, parseHtml, match) {",
                    "  const [, openingTagSuffix, condition, data] = match;",
                    "  const offset = \"<!--\".length + openingTagSuffix.length;",
                    "  const contentStartSpan = node.sourceSpan.start.moveBy(offset);",
                    "  const contentEndSpan = contentStartSpan.moveBy(data.length);",
                    "  const [complete, children] = (() => {",
                    "    try {",
                    "      return [true, parseHtml(data, contentStartSpan).children];",
                    "    } catch {",
                    "      const text = {",
                    "        type: \"text\",",
                    "        value: data,",
                    "        sourceSpan: new ParseSourceSpan(contentStartSpan, contentEndSpan),",
                    "      };",
                    "      return [false, [text]];",
                    "    }",
                    "  })();",
                    "  return {",
                    "    type: \"ieConditionalComment\",",
                    "    complete,",
                    "    children,",
                    "    condition: condition.trim().replace(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "    startSourceSpan: new ParseSourceSpan(",
                    "      node.sourceSpan.start,",
                    "      contentStartSpan",
                    "    ),",
                    "    endSourceSpan: new ParseSourceSpan(contentEndSpan, node.sourceSpan.end),",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalStartComment(node, parseHtml, match) {",
                    "  const [, condition] = match;",
                    "  return {",
                    "    type: \"ieConditionalStartComment\",",
                    "    condition: condition.trim().replace(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalEndComment(node /*, parseHtml, match */) {",
                    "  return {",
                    "    type: \"ieConditionalEndComment\",",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  parseIeConditionalComment,",
                    "};"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const htmlStyles = require(\"html-styles\");",
                    "",
                    "const getCssStyleTags = (property) =>",
                    "  Object.fromEntries(",
                    "    htmlStyles",
                    "      .filter((htmlStyle) => htmlStyle.style[property])",
                    "      .flatMap((htmlStyle) =>",
                    "        htmlStyle.selectorText",
                    "          .split(\",\")",
                    "          .map((selector) => selector.trim())",
                    "          .filter((selector) => /^[\\dA-Za-z]+$/.test(selector))",
                    "          .map((tagName) => [tagName, htmlStyle.style[property]])",
                    "      )",
                    "  );",
                    "",
                    "const CSS_DISPLAY_TAGS = {",
                    "  ...getCssStyleTags(\"display\"),",
                    "",
                    "  // TODO: send PR to upstream",
                    "  button: \"inline-block\",",
                    "",
                    "  // special cases for some css display=none elements",
                    "  template: \"inline\",",
                    "  source: \"block\",",
                    "  track: \"block\",",
                    "  script: \"block\",",
                    "  param: \"block\",",
                    "",
                    "  // `noscript` is inline",
                    "  // noscript: \"inline\",",
                    "",
                    "  // there's no css display for these elements but they behave these ways",
                    "  details: \"block\",",
                    "  summary: \"block\",",
                    "  dialog: \"block\",",
                    "  meter: \"inline-block\",",
                    "  progress: \"inline-block\",",
                    "  object: \"inline-block\",",
                    "  video: \"inline-block\",",
                    "  audio: \"inline-block\",",
                    "  select: \"inline-block\",",
                    "  option: \"block\",",
                    "  optgroup: \"block\",",
                    "};",
                    "const CSS_DISPLAY_DEFAULT = \"inline\";",
                    "const CSS_WHITE_SPACE_TAGS = getCssStyleTags(\"white-space\");",
                    "const CSS_WHITE_SPACE_DEFAULT = \"normal\";",
                    "",
                    "module.exports = {",
                    "  CSS_DISPLAY_TAGS,",
                    "  CSS_DISPLAY_DEFAULT,",
                    "  CSS_WHITE_SPACE_TAGS,",
                    "  CSS_WHITE_SPACE_DEFAULT,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { breakParent, group, hardline, indent, line, fill, softline },",
                    "  utils: { mapDoc, replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const printFrontMatter = require(\"../utils/front-matter/print.js\");",
                    "const {",
                    "  printClosingTag,",
                    "  printClosingTagSuffix,",
                    "  needsToBorrowPrevClosingTagEndMarker,",
                    "  printOpeningTagPrefix,",
                    "  printOpeningTag,",
                    "} = require(\"./print/tag.js\");",
                    "const { printImgSrcset, printClassNames } = require(\"./syntax-attribute.js\");",
                    "const {",
                    "  printVueFor,",
                    "  printVueBindings,",
                    "  isVueEventBindingExpression,",
                    "} = require(\"./syntax-vue.js\");",
                    "const {",
                    "  isScriptLikeTag,",
                    "  isVueNonHtmlBlock,",
                    "  inferScriptParser,",
                    "  htmlTrimPreserveIndentation,",
                    "  dedentString,",
                    "  unescapeQuoteEntities,",
                    "  isVueSlotAttribute,",
                    "  isVueSfcBindingsAttribute,",
                    "  getTextValueParts,",
                    "} = require(\"./utils/index.js\");",
                    "const getNodeContent = require(\"./get-node-content.js\");",
                    "",
                    "function printEmbeddedAttributeValue(node, htmlTextToDoc, options) {",
                    "  const isKeyMatched = (patterns) =>",
                    "    new RegExp(patterns.join(\"|\")).test(node.fullName);",
                    "  const getValue = () => unescapeQuoteEntities(node.value);",
                    "",
                    "  let shouldHug = false;",
                    "",
                    "  const __onHtmlBindingRoot = (root, options) => {",
                    "    const rootNode =",
                    "      root.type === \"NGRoot\"",
                    "        ? root.node.type === \"NGMicrosyntax\" &&",
                    "          root.node.body.length === 1 &&",
                    "          root.node.body[0].type === \"NGMicrosyntaxExpression\"",
                    "          ? root.node.body[0].expression",
                    "          : root.node",
                    "        : root.type === \"JsExpressionRoot\"",
                    "        ? root.node",
                    "        : root;",
                    "    if (",
                    "      rootNode &&",
                    "      (rootNode.type === \"ObjectExpression\" ||",
                    "        rootNode.type === \"ArrayExpression\" ||",
                    "        (options.parser === \"__vue_expression\" &&",
                    "          (rootNode.type === \"TemplateLiteral\" ||",
                    "            rootNode.type === \"StringLiteral\")))",
                    "    ) {",
                    "      shouldHug = true;",
                    "    }",
                    "  };",
                    "",
                    "  const printHug = (doc) => group(doc);",
                    "  const printExpand = (doc, canHaveTrailingWhitespace = true) =>",
                    "    group([indent([softline, doc]), canHaveTrailingWhitespace ? softline : \"\"]);",
                    "  const printMaybeHug = (doc) => (shouldHug ? printHug(doc) : printExpand(doc));",
                    "",
                    "  const attributeTextToDoc = (code, opts) =>",
                    "    htmlTextToDoc(code, {",
                    "      __onHtmlBindingRoot,",
                    "      __embeddedInHtml: true,",
                    "      ...opts,",
                    "    });",
                    "",
                    "  if (",
                    "    node.fullName === \"srcset\" &&",
                    "    (node.parent.fullName === \"img\" || node.parent.fullName === \"source\")",
                    "  ) {",
                    "    return printExpand(printImgSrcset(getValue()));",
                    "  }",
                    "",
                    "  if (node.fullName === \"class\" && !options.parentParser) {",
                    "    const value = getValue();",
                    "    if (!value.includes(\"{{\")) {",
                    "      return printClassNames(value);",
                    "    }",
                    "  }",
                    "",
                    "  if (node.fullName === \"style\" && !options.parentParser) {",
                    "    const value = getValue();",
                    "    if (!value.includes(\"{{\")) {",
                    "      return printExpand(",
                    "        attributeTextToDoc(value, {",
                    "          parser: \"css\",",
                    "          __isHTMLStyleAttribute: true,",
                    "        })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (options.parser === \"vue\") {",
                    "    if (node.fullName === \"v-for\") {",
                    "      return printVueFor(getValue(), attributeTextToDoc);",
                    "    }",
                    "",
                    "    if (isVueSlotAttribute(node) || isVueSfcBindingsAttribute(node, options)) {",
                    "      return printVueBindings(getValue(), attributeTextToDoc);",
                    "    }",
                    "",
                    "    /**",
                    "     *     @click=\"jsStatement\"",
                    "     *     @click=\"jsExpression\"",
                    "     *     v-on:click=\"jsStatement\"",
                    "     *     v-on:click=\"jsExpression\"",
                    "     */",
                    "    const vueEventBindingPatterns = [\"^@\", \"^v-on:\"];",
                    "    /**",
                    "     *     :class=\"vueExpression\"",
                    "     *     v-bind:id=\"vueExpression\"",
                    "     */",
                    "    const vueExpressionBindingPatterns = [\"^:\", \"^v-bind:\"];",
                    "    /**",
                    "     *     v-if=\"jsExpression\"",
                    "     */",
                    "    const jsExpressionBindingPatterns = [\"^v-\"];",
                    "",
                    "    if (isKeyMatched(vueEventBindingPatterns)) {",
                    "      const value = getValue();",
                    "      const parser = isVueEventBindingExpression(value)",
                    "        ? \"__js_expression\"",
                    "        : options.__should_parse_vue_template_with_ts",
                    "        ? \"__vue_ts_event_binding\"",
                    "        : \"__vue_event_binding\";",
                    "      return printMaybeHug(",
                    "        attributeTextToDoc(value, {",
                    "          parser,",
                    "        })",
                    "      );",
                    "    }",
                    "",
                    "    if (isKeyMatched(vueExpressionBindingPatterns)) {",
                    "      return printMaybeHug(",
                    "        attributeTextToDoc(getValue(), { parser: \"__vue_expression\" })",
                    "      );",
                    "    }",
                    "",
                    "    if (isKeyMatched(jsExpressionBindingPatterns)) {",
                    "      return printMaybeHug(",
                    "        attributeTextToDoc(getValue(), { parser: \"__js_expression\" })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (options.parser === \"angular\") {",
                    "    const ngTextToDoc = (code, opts) =>",
                    "      // angular does not allow trailing comma",
                    "      attributeTextToDoc(code, { ...opts, trailingComma: \"none\" });",
                    "",
                    "    /**",
                    "     *     *directive=\"angularDirective\"",
                    "     */",
                    "    const ngDirectiveBindingPatterns = [\"^\\\\*\"];",
                    "    /**",
                    "     *     (click)=\"angularStatement\"",
                    "     *     on-click=\"angularStatement\"",
                    "     */",
                    "    const ngStatementBindingPatterns = [\"^\\\\(.+\\\\)$\", \"^on-\"];",
                    "    /**",
                    "     *     [target]=\"angularExpression\"",
                    "     *     bind-target=\"angularExpression\"",
                    "     *     [(target)]=\"angularExpression\"",
                    "     *     bindon-target=\"angularExpression\"",
                    "     */",
                    "    const ngExpressionBindingPatterns = [",
                    "      \"^\\\\[.+\\\\]$\",",
                    "      \"^bind(on)?-\",",
                    "      // Unofficial rudimentary support for some of the most used directives of AngularJS 1.x",
                    "      \"^ng-(if|show|hide|class|style)$\",",
                    "    ];",
                    "    /**",
                    "     *     i18n=\"longDescription\"",
                    "     *     i18n-attr=\"longDescription\"",
                    "     */",
                    "    const ngI18nPatterns = [\"^i18n(-.+)?$\"];",
                    "",
                    "    if (isKeyMatched(ngStatementBindingPatterns)) {",
                    "      return printMaybeHug(ngTextToDoc(getValue(), { parser: \"__ng_action\" }));",
                    "    }",
                    "",
                    "    if (isKeyMatched(ngExpressionBindingPatterns)) {",
                    "      return printMaybeHug(ngTextToDoc(getValue(), { parser: \"__ng_binding\" }));",
                    "    }",
                    "",
                    "    if (isKeyMatched(ngI18nPatterns)) {",
                    "      const value = getValue().trim();",
                    "      return printExpand(",
                    "        fill(getTextValueParts(node, value)),",
                    "        !value.includes(\"@@\")",
                    "      );",
                    "    }",
                    "",
                    "    if (isKeyMatched(ngDirectiveBindingPatterns)) {",
                    "      return printMaybeHug(",
                    "        ngTextToDoc(getValue(), { parser: \"__ng_directive\" })",
                    "      );",
                    "    }",
                    "",
                    "    const interpolationRegex = /{{(.+?)}}/s;",
                    "    const value = getValue();",
                    "    if (interpolationRegex.test(value)) {",
                    "      const parts = [];",
                    "      for (const [index, part] of value.split(interpolationRegex).entries()) {",
                    "        if (index % 2 === 0) {",
                    "          parts.push(replaceTextEndOfLine(part));",
                    "        } else {",
                    "          try {",
                    "            parts.push(",
                    "              group([",
                    "                \"{{\",",
                    "                indent([",
                    "                  line,",
                    "                  ngTextToDoc(part, {",
                    "                    parser: \"__ng_interpolation\",",
                    "                    __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                    "                  }),",
                    "                ]),",
                    "                line,",
                    "                \"}}\",",
                    "              ])",
                    "            );",
                    "          } catch {",
                    "            parts.push(\"{{\", replaceTextEndOfLine(part), \"}}\");",
                    "          }",
                    "        }",
                    "      }",
                    "      return group(parts);",
                    "    }",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  switch (node.type) {",
                    "    case \"element\": {",
                    "      if (isScriptLikeTag(node) || node.type === \"interpolation\") {",
                    "        // Fall through to \"text\"",
                    "        return;",
                    "      }",
                    "",
                    "      if (!node.isSelfClosing && isVueNonHtmlBlock(node, options)) {",
                    "        const parser = inferScriptParser(node, options);",
                    "        if (!parser) {",
                    "          return;",
                    "        }",
                    "",
                    "        const content = getNodeContent(node, options);",
                    "        let isEmpty = /^\\s*$/.test(content);",
                    "        let doc = \"\";",
                    "        if (!isEmpty) {",
                    "          doc = textToDoc(",
                    "            htmlTrimPreserveIndentation(content),",
                    "            { parser, __embeddedInHtml: true },",
                    "            { stripTrailingHardline: true }",
                    "          );",
                    "          isEmpty = doc === \"\";",
                    "        }",
                    "",
                    "        return [",
                    "          printOpeningTagPrefix(node, options),",
                    "          group(printOpeningTag(path, options, print)),",
                    "          isEmpty ? \"\" : hardline,",
                    "          doc,",
                    "          isEmpty ? \"\" : hardline,",
                    "          printClosingTag(node, options),",
                    "          printClosingTagSuffix(node, options),",
                    "        ];",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"text\": {",
                    "      if (isScriptLikeTag(node.parent)) {",
                    "        const parser = inferScriptParser(node.parent, options);",
                    "        if (parser) {",
                    "          const value =",
                    "            parser === \"markdown\"",
                    "              ? dedentString(node.value.replace(/^[^\\S\\n]*\\n/, \"\"))",
                    "              : node.value;",
                    "          const textToDocOptions = { parser, __embeddedInHtml: true };",
                    "          if (options.parser === \"html\" && parser === \"babel\") {",
                    "            let sourceType = \"script\";",
                    "            const { attrMap } = node.parent;",
                    "            if (",
                    "              attrMap &&",
                    "              (attrMap.type === \"module\" ||",
                    "                (attrMap.type === \"text/babel\" &&",
                    "                  attrMap[\"data-type\"] === \"module\"))",
                    "            ) {",
                    "              sourceType = \"module\";",
                    "            }",
                    "            textToDocOptions.__babelSourceType = sourceType;",
                    "          }",
                    "          return [",
                    "            breakParent,",
                    "            printOpeningTagPrefix(node, options),",
                    "            textToDoc(value, textToDocOptions, {",
                    "              stripTrailingHardline: true,",
                    "            }),",
                    "            printClosingTagSuffix(node, options),",
                    "          ];",
                    "        }",
                    "      } else if (node.parent.type === \"interpolation\") {",
                    "        const textToDocOptions = {",
                    "          __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                    "          __embeddedInHtml: true,",
                    "        };",
                    "        if (options.parser === \"angular\") {",
                    "          textToDocOptions.parser = \"__ng_interpolation\";",
                    "          textToDocOptions.trailingComma = \"none\";",
                    "        } else if (options.parser === \"vue\") {",
                    "          textToDocOptions.parser = options.__should_parse_vue_template_with_ts",
                    "            ? \"__vue_ts_expression\"",
                    "            : \"__vue_expression\";",
                    "        } else {",
                    "          textToDocOptions.parser = \"__js_expression\";",
                    "        }",
                    "        return [",
                    "          indent([",
                    "            line,",
                    "            textToDoc(node.value, textToDocOptions, {",
                    "              stripTrailingHardline: true,",
                    "            }),",
                    "          ]),",
                    "          node.parent.next &&",
                    "          needsToBorrowPrevClosingTagEndMarker(node.parent.next)",
                    "            ? \" \"",
                    "            : line,",
                    "        ];",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"attribute\": {",
                    "      if (!node.value) {",
                    "        break;",
                    "      }",
                    "",
                    "      // lit-html: html`<my-element obj=${obj}></my-element>`",
                    "      if (",
                    "        /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(",
                    "          options.originalText.slice(",
                    "            node.valueSpan.start.offset,",
                    "            node.valueSpan.end.offset",
                    "          )",
                    "        )",
                    "      ) {",
                    "        return [node.rawName, \"=\", node.value];",
                    "      }",
                    "",
                    "      // lwc: html`<my-element data-for={value}></my-element>`",
                    "      if (options.parser === \"lwc\") {",
                    "        const interpolationRegex = /^{.*}$/s;",
                    "        if (",
                    "          interpolationRegex.test(",
                    "            options.originalText.slice(",
                    "              node.valueSpan.start.offset,",
                    "              node.valueSpan.end.offset",
                    "            )",
                    "          )",
                    "        ) {",
                    "          return [node.rawName, \"=\", node.value];",
                    "        }",
                    "      }",
                    "",
                    "      const embeddedAttributeValueDoc = printEmbeddedAttributeValue(",
                    "        node,",
                    "        (code, opts) =>",
                    "          // strictly prefer single quote to avoid unnecessary html entity escape",
                    "          textToDoc(",
                    "            code,",
                    "            { __isInHtmlAttribute: true, __embeddedInHtml: true, ...opts },",
                    "            { stripTrailingHardline: true }",
                    "          ),",
                    "        options",
                    "      );",
                    "      if (embeddedAttributeValueDoc) {",
                    "        return [",
                    "          node.rawName,",
                    "          '=\"',",
                    "          group(",
                    "            mapDoc(embeddedAttributeValueDoc, (doc) =>",
                    "              typeof doc === \"string\" ? doc.replace(/\"/g, \"&quot;\") : doc",
                    "            )",
                    "          ),",
                    "          '\"',",
                    "        ];",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"front-matter\":",
                    "      return printFrontMatter(node, textToDoc);",
                    "  }",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "get-node-content.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  needsToBorrowParentClosingTagStartMarker,",
                    "  printClosingTagStartMarker,",
                    "  needsToBorrowLastChildClosingTagEndMarker,",
                    "  printClosingTagEndMarker,",
                    "  needsToBorrowParentOpeningTagEndMarker,",
                    "  printOpeningTagEndMarker,",
                    "} = require(\"./print/tag.js\");",
                    "",
                    "function getNodeContent(node, options) {",
                    "  let start = node.startSourceSpan.end.offset;",
                    "  if (",
                    "    node.firstChild &&",
                    "    needsToBorrowParentOpeningTagEndMarker(node.firstChild)",
                    "  ) {",
                    "    start -= printOpeningTagEndMarker(node).length;",
                    "  }",
                    "",
                    "  let end = node.endSourceSpan.start.offset;",
                    "  if (",
                    "    node.lastChild &&",
                    "    needsToBorrowParentClosingTagStartMarker(node.lastChild)",
                    "  ) {",
                    "    end += printClosingTagStartMarker(node, options).length;",
                    "  } else if (needsToBorrowLastChildClosingTagEndMarker(node)) {",
                    "    end -= printClosingTagEndMarker(node.lastChild, options).length;",
                    "  }",
                    "",
                    "  return options.originalText.slice(start, end);",
                    "}",
                    "",
                    "module.exports = getNodeContent;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-html.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/HTML.json\"), () => ({",
                    "    name: \"Angular\",",
                    "    since: \"1.15.0\",",
                    "    parsers: [\"angular\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [\".component.html\"],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/HTML.json\"), (data) => ({",
                    "    since: \"1.15.0\",",
                    "    parsers: [\"html\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [",
                    "      ...data.extensions,",
                    "      \".mjml\", // MJML is considered XML in Linguist but it should be formatted as HTML",
                    "    ],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/HTML.json\"), () => ({",
                    "    name: \"Lightning Web Components\",",
                    "    since: \"1.17.0\",",
                    "    parsers: [\"lwc\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/Vue.json\"), () => ({",
                    "    since: \"1.10.0\",",
                    "    parsers: [\"vue\"],",
                    "    vscodeLanguageIds: [\"vue\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  html: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  printers,",
                    "  options,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  return node.sourceSpan.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.sourceSpan.end.offset;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "const CATEGORY_HTML = \"HTML\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSameLine: commonOptions.bracketSameLine,",
                    "  htmlWhitespaceSensitivity: {",
                    "    since: \"1.15.0\",",
                    "    category: CATEGORY_HTML,",
                    "    type: \"choice\",",
                    "    default: \"css\",",
                    "    description: \"How to handle whitespaces in HTML.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"css\",",
                    "        description: \"Respect the default value of CSS display property.\",",
                    "      },",
                    "      {",
                    "        value: \"strict\",",
                    "        description: \"Whitespaces are considered sensitive.\",",
                    "      },",
                    "      {",
                    "        value: \"ignore\",",
                    "        description: \"Whitespaces are considered insensitive.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  singleAttributePerLine: commonOptions.singleAttributePerLine,",
                    "  vueIndentScriptAndStyle: {",
                    "    since: \"1.19.0\",",
                    "    category: CATEGORY_HTML,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent script and style tags in Vue files.\",",
                    "  },",
                    "};"
                ]
            },
            "parser-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  ParseSourceSpan,",
                    "  ParseLocation,",
                    "  ParseSourceFile,",
                    "} = require(\"angular-html-parser/lib/compiler/src/parse_util\");",
                    "const parseFrontMatter = require(\"../utils/front-matter/parse.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const { inferParserByLanguage } = require(\"../common/util.js\");",
                    "const HTML_TAGS = require(\"./utils/html-tag-names.js\");",
                    "const HTML_ELEMENT_ATTRIBUTES = require(\"./utils/html-elements-attributes.js\");",
                    "const isUnknownNamespace = require(\"./utils/is-unknown-namespace.js\");",
                    "const { hasPragma } = require(\"./pragma.js\");",
                    "const { Node } = require(\"./ast.js\");",
                    "const { parseIeConditionalComment } = require(\"./conditional-comment.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "/**",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast').Node} AstNode",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast').Attribute} Attribute",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast').Element} Element",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/parser').ParseTreeResult} ParserTreeResult",
                    " * @typedef {Omit<import('angular-html-parser').ParseOptions, 'canSelfClose'> & {",
                    " *   name?: 'html' | 'angular' | 'vue' | 'lwc';",
                    " *   canSelfClose?: boolean;",
                    " *   normalizeTagName?: boolean;",
                    " *   normalizeAttributeName?: boolean;",
                    " * }} ParserOptions",
                    " * @typedef {{",
                    " *   parser: 'html' | 'angular' | 'vue' | 'lwc',",
                    " *   filepath?: string",
                    " * }} Options",
                    " */",
                    "",
                    "/**",
                    " * @param {string} input",
                    " * @param {ParserOptions} parserOptions",
                    " * @param {Options} options",
                    " */",
                    "function ngHtmlParser(",
                    "  input,",
                    "  {",
                    "    canSelfClose,",
                    "    normalizeTagName,",
                    "    normalizeAttributeName,",
                    "    allowHtmComponentClosingTags,",
                    "    isTagNameCaseSensitive,",
                    "    getTagContentType,",
                    "  },",
                    "  options",
                    ") {",
                    "  const parser = require(\"angular-html-parser\");",
                    "  const {",
                    "    RecursiveVisitor,",
                    "    visitAll,",
                    "  } = require(\"angular-html-parser/lib/compiler/src/ml_parser/ast\");",
                    "  const {",
                    "    ParseSourceSpan,",
                    "  } = require(\"angular-html-parser/lib/compiler/src/parse_util\");",
                    "  const {",
                    "    getHtmlTagDefinition,",
                    "  } = require(\"angular-html-parser/lib/compiler/src/ml_parser/html_tags\");",
                    "",
                    "  let { rootNodes, errors } = parser.parse(input, {",
                    "    canSelfClose,",
                    "    allowHtmComponentClosingTags,",
                    "    isTagNameCaseSensitive,",
                    "    getTagContentType,",
                    "  });",
                    "",
                    "  if (options.parser === \"vue\") {",
                    "    const isVueHtml = rootNodes.some(",
                    "      (node) =>",
                    "        (node.type === \"docType\" && node.value === \"html\") ||",
                    "        (node.type === \"element\" && node.name.toLowerCase() === \"html\")",
                    "    );",
                    "",
                    "    if (!isVueHtml) {",
                    "      const shouldParseAsHTML = (/** @type {AstNode} */ node) => {",
                    "        /* istanbul ignore next */",
                    "        if (!node) {",
                    "          return false;",
                    "        }",
                    "        if (node.type !== \"element\" || node.name !== \"template\") {",
                    "          return false;",
                    "        }",
                    "        const langAttr = node.attrs.find((attr) => attr.name === \"lang\");",
                    "        const langValue = langAttr && langAttr.value;",
                    "        return (",
                    "          !langValue || inferParserByLanguage(langValue, options) === \"html\"",
                    "        );",
                    "      };",
                    "      if (rootNodes.some(shouldParseAsHTML)) {",
                    "        /** @type {ParserTreeResult | undefined} */",
                    "        let secondParseResult;",
                    "        const doSecondParse = () =>",
                    "          parser.parse(input, {",
                    "            canSelfClose,",
                    "            allowHtmComponentClosingTags,",
                    "            isTagNameCaseSensitive,",
                    "          });",
                    "        const getSecondParse = () =>",
                    "          secondParseResult || (secondParseResult = doSecondParse());",
                    "        const getSameLocationNode = (node) =>",
                    "          getSecondParse().rootNodes.find(",
                    "            ({ startSourceSpan }) =>",
                    "              startSourceSpan &&",
                    "              startSourceSpan.start.offset === node.startSourceSpan.start.offset",
                    "          );",
                    "        for (let i = 0; i < rootNodes.length; i++) {",
                    "          const node = rootNodes[i];",
                    "          const { endSourceSpan, startSourceSpan } = node;",
                    "          const isUnclosedNode = endSourceSpan === null;",
                    "          if (isUnclosedNode) {",
                    "            const result = getSecondParse();",
                    "            errors = result.errors;",
                    "            rootNodes[i] = getSameLocationNode(node) || node;",
                    "          } else if (shouldParseAsHTML(node)) {",
                    "            const result = getSecondParse();",
                    "            const startOffset = startSourceSpan.end.offset;",
                    "            const endOffset = endSourceSpan.start.offset;",
                    "            for (const error of result.errors) {",
                    "              const { offset } = error.span.start;",
                    "              /* istanbul ignore next */",
                    "              if (startOffset < offset && offset < endOffset) {",
                    "                errors = [error];",
                    "                break;",
                    "              }",
                    "            }",
                    "            rootNodes[i] = getSameLocationNode(node) || node;",
                    "          }",
                    "        }",
                    "      }",
                    "    } else {",
                    "      // If not Vue SFC, treat as html",
                    "      canSelfClose = true;",
                    "      normalizeTagName = true;",
                    "      normalizeAttributeName = true;",
                    "      allowHtmComponentClosingTags = true;",
                    "      isTagNameCaseSensitive = false;",
                    "      const htmlParseResult = parser.parse(input, {",
                    "        canSelfClose,",
                    "        allowHtmComponentClosingTags,",
                    "        isTagNameCaseSensitive,",
                    "      });",
                    "",
                    "      rootNodes = htmlParseResult.rootNodes;",
                    "      errors = htmlParseResult.errors;",
                    "    }",
                    "  }",
                    "",
                    "  if (errors.length > 0) {",
                    "    const {",
                    "      msg,",
                    "      span: { start, end },",
                    "    } = errors[0];",
                    "    throw createError(msg, {",
                    "      start: { line: start.line + 1, column: start.col + 1 },",
                    "      end: { line: end.line + 1, column: end.col + 1 },",
                    "    });",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Attribute | Element} node",
                    "   */",
                    "  const restoreName = (node) => {",
                    "    const namespace = node.name.startsWith(\":\")",
                    "      ? node.name.slice(1).split(\":\")[0]",
                    "      : null;",
                    "    const rawName = node.nameSpan.toString();",
                    "    const hasExplicitNamespace =",
                    "      namespace !== null && rawName.startsWith(`${namespace}:`);",
                    "    const name = hasExplicitNamespace",
                    "      ? rawName.slice(namespace.length + 1)",
                    "      : rawName;",
                    "",
                    "    node.name = name;",
                    "    node.namespace = namespace;",
                    "    node.hasExplicitNamespace = hasExplicitNamespace;",
                    "  };",
                    "",
                    "  /**",
                    "   * @param {AstNode} node",
                    "   */",
                    "  const restoreNameAndValue = (node) => {",
                    "    switch (node.type) {",
                    "      case \"element\":",
                    "        restoreName(node);",
                    "        for (const attr of node.attrs) {",
                    "          restoreName(attr);",
                    "          if (!attr.valueSpan) {",
                    "            attr.value = null;",
                    "          } else {",
                    "            attr.value = attr.valueSpan.toString();",
                    "            if (/[\"']/.test(attr.value[0])) {",
                    "              attr.value = attr.value.slice(1, -1);",
                    "            }",
                    "          }",
                    "        }",
                    "        break;",
                    "      case \"comment\":",
                    "        node.value = node.sourceSpan",
                    "          .toString()",
                    "          .slice(\"<!--\".length, -\"-->\".length);",
                    "        break;",
                    "      case \"text\":",
                    "        node.value = node.sourceSpan.toString();",
                    "        break;",
                    "      // No default",
                    "    }",
                    "  };",
                    "",
                    "  const lowerCaseIfFn = (text, fn) => {",
                    "    const lowerCasedText = text.toLowerCase();",
                    "    return fn(lowerCasedText) ? lowerCasedText : text;",
                    "  };",
                    "  const normalizeName = (node) => {",
                    "    if (node.type === \"element\") {",
                    "      if (",
                    "        normalizeTagName &&",
                    "        (!node.namespace ||",
                    "          node.namespace === node.tagDefinition.implicitNamespacePrefix ||",
                    "          isUnknownNamespace(node))",
                    "      ) {",
                    "        node.name = lowerCaseIfFn(",
                    "          node.name,",
                    "          (lowerCasedName) => lowerCasedName in HTML_TAGS",
                    "        );",
                    "      }",
                    "",
                    "      if (normalizeAttributeName) {",
                    "        const CURRENT_HTML_ELEMENT_ATTRIBUTES =",
                    "          HTML_ELEMENT_ATTRIBUTES[node.name] || Object.create(null);",
                    "        for (const attr of node.attrs) {",
                    "          if (!attr.namespace) {",
                    "            attr.name = lowerCaseIfFn(",
                    "              attr.name,",
                    "              (lowerCasedAttrName) =>",
                    "                node.name in HTML_ELEMENT_ATTRIBUTES &&",
                    "                (lowerCasedAttrName in HTML_ELEMENT_ATTRIBUTES[\"*\"] ||",
                    "                  lowerCasedAttrName in CURRENT_HTML_ELEMENT_ATTRIBUTES)",
                    "            );",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  const fixSourceSpan = (node) => {",
                    "    if (node.sourceSpan && node.endSourceSpan) {",
                    "      node.sourceSpan = new ParseSourceSpan(",
                    "        node.sourceSpan.start,",
                    "        node.endSourceSpan.end",
                    "      );",
                    "    }",
                    "  };",
                    "",
                    "  /**",
                    "   * @param {AstNode} node",
                    "   */",
                    "  const addTagDefinition = (node) => {",
                    "    if (node.type === \"element\") {",
                    "      const tagDefinition = getHtmlTagDefinition(",
                    "        isTagNameCaseSensitive ? node.name : node.name.toLowerCase()",
                    "      );",
                    "      if (",
                    "        !node.namespace ||",
                    "        node.namespace === tagDefinition.implicitNamespacePrefix ||",
                    "        isUnknownNamespace(node)",
                    "      ) {",
                    "        node.tagDefinition = tagDefinition;",
                    "      } else {",
                    "        node.tagDefinition = getHtmlTagDefinition(\"\"); // the default one",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  visitAll(",
                    "    new (class extends RecursiveVisitor {",
                    "      visit(node) {",
                    "        restoreNameAndValue(node);",
                    "        addTagDefinition(node);",
                    "        normalizeName(node);",
                    "        fixSourceSpan(node);",
                    "      }",
                    "    })(),",
                    "    rootNodes",
                    "  );",
                    "",
                    "  return rootNodes;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {Options} options",
                    " * @param {ParserOptions} parserOptions",
                    " * @param {boolean} shouldParseFrontMatter",
                    " */",
                    "function _parse(text, options, parserOptions, shouldParseFrontMatter = true) {",
                    "  const { frontMatter, content } = shouldParseFrontMatter",
                    "    ? parseFrontMatter(text)",
                    "    : { frontMatter: null, content: text };",
                    "",
                    "  const file = new ParseSourceFile(text, options.filepath);",
                    "  const start = new ParseLocation(file, 0, 0, 0);",
                    "  const end = start.moveBy(text.length);",
                    "  const rawAst = {",
                    "    type: \"root\",",
                    "    sourceSpan: new ParseSourceSpan(start, end),",
                    "    children: ngHtmlParser(content, parserOptions, options),",
                    "  };",
                    "",
                    "  if (frontMatter) {",
                    "    const start = new ParseLocation(file, 0, 0, 0);",
                    "    const end = start.moveBy(frontMatter.raw.length);",
                    "    frontMatter.sourceSpan = new ParseSourceSpan(start, end);",
                    "    // @ts-expect-error",
                    "    rawAst.children.unshift(frontMatter);",
                    "  }",
                    "",
                    "  const ast = new Node(rawAst);",
                    "",
                    "  const parseSubHtml = (subContent, startSpan) => {",
                    "    const { offset } = startSpan;",
                    "    const fakeContent = text.slice(0, offset).replace(/[^\\n\\r]/g, \" \");",
                    "    const realContent = subContent;",
                    "    const subAst = _parse(",
                    "      fakeContent + realContent,",
                    "      options,",
                    "      parserOptions,",
                    "      false",
                    "    );",
                    "    // @ts-expect-error",
                    "    subAst.sourceSpan = new ParseSourceSpan(",
                    "      startSpan,",
                    "      // @ts-expect-error",
                    "      getLast(subAst.children).sourceSpan.end",
                    "    );",
                    "    // @ts-expect-error",
                    "    const firstText = subAst.children[0];",
                    "    if (firstText.length === offset) {",
                    "      /* istanbul ignore next */ // @ts-expect-error",
                    "      subAst.children.shift();",
                    "    } else {",
                    "      firstText.sourceSpan = new ParseSourceSpan(",
                    "        firstText.sourceSpan.start.moveBy(offset),",
                    "        firstText.sourceSpan.end",
                    "      );",
                    "      firstText.value = firstText.value.slice(offset);",
                    "    }",
                    "    return subAst;",
                    "  };",
                    "",
                    "  ast.walk((node) => {",
                    "    if (node.type === \"comment\") {",
                    "      const ieConditionalComment = parseIeConditionalComment(",
                    "        node,",
                    "        parseSubHtml",
                    "      );",
                    "      if (ieConditionalComment) {",
                    "        node.parent.replaceChild(node, ieConditionalComment);",
                    "      }",
                    "    }",
                    "  });",
                    "",
                    "  return ast;",
                    "}",
                    "",
                    "/**",
                    " * @param {ParserOptions} parserOptions",
                    " */",
                    "function createParser({",
                    "  name,",
                    "  canSelfClose = false,",
                    "  normalizeTagName = false,",
                    "  normalizeAttributeName = false,",
                    "  allowHtmComponentClosingTags = false,",
                    "  isTagNameCaseSensitive = false,",
                    "  getTagContentType,",
                    "} = {}) {",
                    "  return {",
                    "    parse: (text, parsers, options) =>",
                    "      _parse(",
                    "        text,",
                    "        { parser: name, ...options },",
                    "        {",
                    "          canSelfClose,",
                    "          normalizeTagName,",
                    "          normalizeAttributeName,",
                    "          allowHtmComponentClosingTags,",
                    "          isTagNameCaseSensitive,",
                    "          getTagContentType,",
                    "        }",
                    "      ),",
                    "    hasPragma,",
                    "    astFormat: \"html\",",
                    "    locStart,",
                    "    locEnd,",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    html: createParser({",
                    "      name: \"html\",",
                    "      canSelfClose: true,",
                    "      normalizeTagName: true,",
                    "      normalizeAttributeName: true,",
                    "      allowHtmComponentClosingTags: true,",
                    "    }),",
                    "    angular: createParser({ name: \"angular\", canSelfClose: true }),",
                    "    vue: createParser({",
                    "      name: \"vue\",",
                    "      canSelfClose: true,",
                    "      isTagNameCaseSensitive: true,",
                    "      getTagContentType: (tagName, prefix, hasParent, attrs) => {",
                    "        if (",
                    "          tagName.toLowerCase() !== \"html\" &&",
                    "          !hasParent &&",
                    "          (tagName !== \"template\" ||",
                    "            attrs.some(",
                    "              ({ name, value }) =>",
                    "                name === \"lang\" &&",
                    "                value !== \"html\" &&",
                    "                value !== \"\" &&",
                    "                value !== undefined",
                    "            ))",
                    "        ) {",
                    "          return require(\"angular-html-parser\").TagContentType.RAW_TEXT;",
                    "        }",
                    "      },",
                    "    }),",
                    "    lwc: createParser({ name: \"lwc\" }),",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  // HTML",
                    "  get html() {",
                    "    return require(\"./parser-html.js\").parsers.html;",
                    "  },",
                    "  // Vue",
                    "  get vue() {",
                    "    return require(\"./parser-html.js\").parsers.vue;",
                    "  },",
                    "  // Angular",
                    "  get angular() {",
                    "    return require(\"./parser-html.js\").parsers.angular;",
                    "  },",
                    "  // Lightning Web Components",
                    "  get lwc() {",
                    "    return require(\"./parser-html.js\").parsers.lwc;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*<!--\\s*@(?:format|prettier)\\s*-->/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"<!-- @format -->\\n\\n\" + text.replace(/^\\s*\\n/, \"\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  ParseSourceSpan,",
                    "} = require(\"angular-html-parser/lib/compiler/src/parse_util\");",
                    "const {",
                    "  htmlTrim,",
                    "  getLeadingAndTrailingHtmlWhitespace,",
                    "  hasHtmlWhitespace,",
                    "  canHaveInterpolation,",
                    "  getNodeCssStyleDisplay,",
                    "  isDanglingSpaceSensitiveNode,",
                    "  isIndentationSensitiveNode,",
                    "  isLeadingSpaceSensitiveNode,",
                    "  isTrailingSpaceSensitiveNode,",
                    "  isWhitespaceSensitiveNode,",
                    "  isVueScriptTag,",
                    "} = require(\"./utils/index.js\");",
                    "",
                    "const PREPROCESS_PIPELINE = [",
                    "  removeIgnorableFirstLf,",
                    "  mergeIfConditionalStartEndCommentIntoElementOpeningTag,",
                    "  mergeCdataIntoText,",
                    "  extractInterpolation,",
                    "  extractWhitespaces,",
                    "  addCssDisplay,",
                    "  addIsSelfClosing,",
                    "  addHasHtmComponentClosingTag,",
                    "  addIsSpaceSensitive,",
                    "  mergeSimpleElementIntoText,",
                    "  markTsScript,",
                    "];",
                    "",
                    "function preprocess(ast, options) {",
                    "  for (const fn of PREPROCESS_PIPELINE) {",
                    "    fn(ast, options);",
                    "  }",
                    "  return ast;",
                    "}",
                    "",
                    "function removeIgnorableFirstLf(ast /*, options */) {",
                    "  ast.walk((node) => {",
                    "    if (",
                    "      node.type === \"element\" &&",
                    "      node.tagDefinition.ignoreFirstLf &&",
                    "      node.children.length > 0 &&",
                    "      node.children[0].type === \"text\" &&",
                    "      node.children[0].value[0] === \"\\n\"",
                    "    ) {",
                    "      const text = node.children[0];",
                    "      if (text.value.length === 1) {",
                    "        node.removeChild(text);",
                    "      } else {",
                    "        text.value = text.value.slice(1);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeIfConditionalStartEndCommentIntoElementOpeningTag(",
                    "  ast /*, options */",
                    ") {",
                    "  /**",
                    "   *     <!--[if ...]><!--><target><!--<![endif]-->",
                    "   */",
                    "  const isTarget = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.prev &&",
                    "    node.prev.type === \"ieConditionalStartComment\" &&",
                    "    node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset &&",
                    "    node.firstChild &&",
                    "    node.firstChild.type === \"ieConditionalEndComment\" &&",
                    "    node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (!isTarget(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const ieConditionalStartComment = child.prev;",
                    "        const ieConditionalEndComment = child.firstChild;",
                    "",
                    "        // ieConditionalStartComment",
                    "        node.removeChild(ieConditionalStartComment);",
                    "        i--; // because a node was removed",
                    "",
                    "        const startSourceSpan = new ParseSourceSpan(",
                    "          ieConditionalStartComment.sourceSpan.start,",
                    "          ieConditionalEndComment.sourceSpan.end",
                    "        );",
                    "        const sourceSpan = new ParseSourceSpan(",
                    "          startSourceSpan.start,",
                    "          child.sourceSpan.end",
                    "        );",
                    "",
                    "        child.condition = ieConditionalStartComment.condition;",
                    "        child.sourceSpan = sourceSpan;",
                    "        child.startSourceSpan = startSourceSpan;",
                    "        child.removeChild(ieConditionalEndComment);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeNodeIntoText(ast, shouldMerge, getValue) {",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "",
                    "        if (child.type !== \"text\" && !shouldMerge(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        if (child.type !== \"text\") {",
                    "          child.type = \"text\";",
                    "          child.value = getValue(child);",
                    "        }",
                    "",
                    "        const prevChild = child.prev;",
                    "        if (!prevChild || prevChild.type !== \"text\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        prevChild.value += child.value;",
                    "        prevChild.sourceSpan = new ParseSourceSpan(",
                    "          prevChild.sourceSpan.start,",
                    "          child.sourceSpan.end",
                    "        );",
                    "",
                    "        node.removeChild(child);",
                    "        i--; // because a node was removed",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeCdataIntoText(ast /*, options */) {",
                    "  return mergeNodeIntoText(",
                    "    ast,",
                    "    (node) => node.type === \"cdata\",",
                    "    (node) => `<![CDATA[${node.value}]]>`",
                    "  );",
                    "}",
                    "",
                    "function mergeSimpleElementIntoText(ast /*, options */) {",
                    "  const isSimpleElement = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.attrs.length === 0 &&",
                    "    node.children.length === 1 &&",
                    "    node.firstChild.type === \"text\" &&",
                    "    !hasHtmlWhitespace(node.children[0].value) &&",
                    "    !node.firstChild.hasLeadingSpaces &&",
                    "    !node.firstChild.hasTrailingSpaces &&",
                    "    node.isLeadingSpaceSensitive &&",
                    "    !node.hasLeadingSpaces &&",
                    "    node.isTrailingSpaceSensitive &&",
                    "    !node.hasTrailingSpaces &&",
                    "    node.prev &&",
                    "    node.prev.type === \"text\" &&",
                    "    node.next &&",
                    "    node.next.type === \"text\";",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (!isSimpleElement(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const prevChild = child.prev;",
                    "        const nextChild = child.next;",
                    "        prevChild.value +=",
                    "          `<${child.rawName}>` +",
                    "          child.firstChild.value +",
                    "          `</${child.rawName}>` +",
                    "          nextChild.value;",
                    "        prevChild.sourceSpan = new ParseSourceSpan(",
                    "          prevChild.sourceSpan.start,",
                    "          nextChild.sourceSpan.end",
                    "        );",
                    "        prevChild.isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive;",
                    "        prevChild.hasTrailingSpaces = nextChild.hasTrailingSpaces;",
                    "",
                    "        node.removeChild(child);",
                    "        i--; // because a node was removed",
                    "        node.removeChild(nextChild);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function extractInterpolation(ast, options) {",
                    "  if (options.parser === \"html\") {",
                    "    return;",
                    "  }",
                    "",
                    "  const interpolationRegex = /{{(.+?)}}/s;",
                    "  ast.walk((node) => {",
                    "    if (!canHaveInterpolation(node)) {",
                    "      return;",
                    "    }",
                    "",
                    "    for (const child of node.children) {",
                    "      if (child.type !== \"text\") {",
                    "        continue;",
                    "      }",
                    "",
                    "      let startSourceSpan = child.sourceSpan.start;",
                    "      let endSourceSpan = null;",
                    "      const components = child.value.split(interpolationRegex);",
                    "      for (",
                    "        let i = 0;",
                    "        i < components.length;",
                    "        i++, startSourceSpan = endSourceSpan",
                    "      ) {",
                    "        const value = components[i];",
                    "",
                    "        if (i % 2 === 0) {",
                    "          endSourceSpan = startSourceSpan.moveBy(value.length);",
                    "          if (value.length > 0) {",
                    "            node.insertChildBefore(child, {",
                    "              type: \"text\",",
                    "              value,",
                    "              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "            });",
                    "          }",
                    "          continue;",
                    "        }",
                    "",
                    "        endSourceSpan = startSourceSpan.moveBy(value.length + 4); // `{{` + `}}`",
                    "        node.insertChildBefore(child, {",
                    "          type: \"interpolation\",",
                    "          sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "          children:",
                    "            value.length === 0",
                    "              ? []",
                    "              : [",
                    "                  {",
                    "                    type: \"text\",",
                    "                    value,",
                    "                    sourceSpan: new ParseSourceSpan(",
                    "                      startSourceSpan.moveBy(2),",
                    "                      endSourceSpan.moveBy(-2)",
                    "                    ),",
                    "                  },",
                    "                ],",
                    "        });",
                    "      }",
                    "",
                    "      node.removeChild(child);",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * - add `hasLeadingSpaces` field",
                    " * - add `hasTrailingSpaces` field",
                    " * - add `hasDanglingSpaces` field for parent nodes",
                    " * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes",
                    " * - remove insensitive whitespaces",
                    " */",
                    "function extractWhitespaces(ast /*, options*/) {",
                    "  ast.walk((node) => {",
                    "    if (!node.children) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (",
                    "      node.children.length === 0 ||",
                    "      (node.children.length === 1 &&",
                    "        node.children[0].type === \"text\" &&",
                    "        htmlTrim(node.children[0].value).length === 0)",
                    "    ) {",
                    "      node.hasDanglingSpaces = node.children.length > 0;",
                    "      node.children = [];",
                    "      return;",
                    "    }",
                    "",
                    "    const isWhitespaceSensitive = isWhitespaceSensitiveNode(node);",
                    "    const isIndentationSensitive = isIndentationSensitiveNode(node);",
                    "",
                    "    if (!isWhitespaceSensitive) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (child.type !== \"text\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        const { leadingWhitespace, text, trailingWhitespace } =",
                    "          getLeadingAndTrailingHtmlWhitespace(child.value);",
                    "",
                    "        const prevChild = child.prev;",
                    "        const nextChild = child.next;",
                    "",
                    "        if (!text) {",
                    "          node.removeChild(child);",
                    "          i--; // because a node was removed",
                    "",
                    "          if (leadingWhitespace || trailingWhitespace) {",
                    "            if (prevChild) {",
                    "              prevChild.hasTrailingSpaces = true;",
                    "            }",
                    "            if (nextChild) {",
                    "              nextChild.hasLeadingSpaces = true;",
                    "            }",
                    "          }",
                    "        } else {",
                    "          child.value = text;",
                    "          child.sourceSpan = new ParseSourceSpan(",
                    "            child.sourceSpan.start.moveBy(leadingWhitespace.length),",
                    "            child.sourceSpan.end.moveBy(-trailingWhitespace.length)",
                    "          );",
                    "",
                    "          if (leadingWhitespace) {",
                    "            if (prevChild) {",
                    "              prevChild.hasTrailingSpaces = true;",
                    "            }",
                    "            child.hasLeadingSpaces = true;",
                    "          }",
                    "          if (trailingWhitespace) {",
                    "            child.hasTrailingSpaces = true;",
                    "            if (nextChild) {",
                    "              nextChild.hasLeadingSpaces = true;",
                    "            }",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    node.isWhitespaceSensitive = isWhitespaceSensitive;",
                    "    node.isIndentationSensitive = isIndentationSensitive;",
                    "  });",
                    "}",
                    "",
                    "function addIsSelfClosing(ast /*, options */) {",
                    "  ast.walk((node) => {",
                    "    node.isSelfClosing =",
                    "      !node.children ||",
                    "      (node.type === \"element\" &&",
                    "        (node.tagDefinition.isVoid ||",
                    "          // self-closing",
                    "          node.startSourceSpan === node.endSourceSpan));",
                    "  });",
                    "}",
                    "",
                    "function addHasHtmComponentClosingTag(ast, options) {",
                    "  ast.walk((node) => {",
                    "    if (node.type !== \"element\") {",
                    "      return;",
                    "    }",
                    "",
                    "    node.hasHtmComponentClosingTag =",
                    "      node.endSourceSpan &&",
                    "      /^<\\s*\\/\\s*\\/\\s*>$/.test(",
                    "        options.originalText.slice(",
                    "          node.endSourceSpan.start.offset,",
                    "          node.endSourceSpan.end.offset",
                    "        )",
                    "      );",
                    "  });",
                    "}",
                    "",
                    "function addCssDisplay(ast, options) {",
                    "  ast.walk((node) => {",
                    "    node.cssDisplay = getNodeCssStyleDisplay(node, options);",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * - add `isLeadingSpaceSensitive` field",
                    " * - add `isTrailingSpaceSensitive` field",
                    " * - add `isDanglingSpaceSensitive` field for parent nodes",
                    " */",
                    "function addIsSpaceSensitive(ast, options) {",
                    "  ast.walk((node) => {",
                    "    const { children } = node;",
                    "    if (!children) {",
                    "      return;",
                    "    }",
                    "    if (children.length === 0) {",
                    "      node.isDanglingSpaceSensitive = isDanglingSpaceSensitiveNode(node);",
                    "      return;",
                    "    }",
                    "    for (const child of children) {",
                    "      child.isLeadingSpaceSensitive = isLeadingSpaceSensitiveNode(",
                    "        child,",
                    "        options",
                    "      );",
                    "      child.isTrailingSpaceSensitive = isTrailingSpaceSensitiveNode(",
                    "        child,",
                    "        options",
                    "      );",
                    "    }",
                    "    for (let index = 0; index < children.length; index++) {",
                    "      const child = children[index];",
                    "      child.isLeadingSpaceSensitive =",
                    "        index === 0",
                    "          ? child.isLeadingSpaceSensitive",
                    "          : child.prev.isTrailingSpaceSensitive &&",
                    "            child.isLeadingSpaceSensitive;",
                    "      child.isTrailingSpaceSensitive =",
                    "        index === children.length - 1",
                    "          ? child.isTrailingSpaceSensitive",
                    "          : child.next.isLeadingSpaceSensitive &&",
                    "            child.isTrailingSpaceSensitive;",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function markTsScript(ast, options) {",
                    "  if (options.parser === \"vue\") {",
                    "    const vueScriptTag = ast.children.find((child) =>",
                    "      isVueScriptTag(child, options)",
                    "    );",
                    "    if (!vueScriptTag) {",
                    "      return;",
                    "    }",
                    "    const { lang } = vueScriptTag.attrMap;",
                    "    if (lang === \"ts\" || lang === \"typescript\") {",
                    "      options.__should_parse_vue_template_with_ts = true;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * @typedef {import(\"../document\").Doc} Doc",
                    " */",
                    "",
                    "const {",
                    "  builders: { fill, group, hardline, literalline },",
                    "  utils: { cleanDoc, getDocParts, isConcat, replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const {",
                    "  countChars,",
                    "  unescapeQuoteEntities,",
                    "  getTextValueParts,",
                    "} = require(\"./utils/index.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const {",
                    "  printClosingTagSuffix,",
                    "  printClosingTagEnd,",
                    "  printOpeningTagPrefix,",
                    "  printOpeningTagStart,",
                    "} = require(\"./print/tag.js\");",
                    "const { printElement } = require(\"./print/element.js\");",
                    "const { printChildren } = require(\"./print/children.js\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return replaceTextEndOfLine(node.raw);",
                    "    case \"root\":",
                    "      if (options.__onHtmlRoot) {",
                    "        options.__onHtmlRoot(node);",
                    "      }",
                    "      // use original concat to not break stripTrailingHardline",
                    "      return [group(printChildren(path, options, print)), hardline];",
                    "    case \"element\":",
                    "    case \"ieConditionalComment\": {",
                    "      return printElement(path, options, print);",
                    "    }",
                    "    case \"ieConditionalStartComment\":",
                    "    case \"ieConditionalEndComment\":",
                    "      return [printOpeningTagStart(node), printClosingTagEnd(node)];",
                    "    case \"interpolation\":",
                    "      return [",
                    "        printOpeningTagStart(node, options),",
                    "        ...path.map(print, \"children\"),",
                    "        printClosingTagEnd(node, options),",
                    "      ];",
                    "    case \"text\": {",
                    "      if (node.parent.type === \"interpolation\") {",
                    "        // replace the trailing literalline with hardline for better readability",
                    "        const trailingNewlineRegex = /\\n[^\\S\\n]*$/;",
                    "        const hasTrailingNewline = trailingNewlineRegex.test(node.value);",
                    "        const value = hasTrailingNewline",
                    "          ? node.value.replace(trailingNewlineRegex, \"\")",
                    "          : node.value;",
                    "        return [",
                    "          ...replaceTextEndOfLine(value),",
                    "          hasTrailingNewline ? hardline : \"\",",
                    "        ];",
                    "      }",
                    "",
                    "      const printed = cleanDoc([",
                    "        printOpeningTagPrefix(node, options),",
                    "        ...getTextValueParts(node),",
                    "        printClosingTagSuffix(node, options),",
                    "      ]);",
                    "      if (isConcat(printed) || printed.type === \"fill\") {",
                    "        return fill(getDocParts(printed));",
                    "      }",
                    "      /* istanbul ignore next */",
                    "      return printed;",
                    "    }",
                    "    case \"docType\":",
                    "      return [",
                    "        group([",
                    "          printOpeningTagStart(node, options),",
                    "          \" \",",
                    "          node.value.replace(/^html\\b/i, \"html\").replace(/\\s+/g, \" \"),",
                    "        ]),",
                    "        printClosingTagEnd(node, options),",
                    "      ];",
                    "    case \"comment\": {",
                    "      return [",
                    "        printOpeningTagPrefix(node, options),",
                    "        ...replaceTextEndOfLine(",
                    "          options.originalText.slice(locStart(node), locEnd(node)),",
                    "          literalline",
                    "        ),",
                    "        printClosingTagSuffix(node, options),",
                    "      ];",
                    "    }",
                    "    case \"attribute\": {",
                    "      if (node.value === null) {",
                    "        return node.rawName;",
                    "      }",
                    "      const value = unescapeQuoteEntities(node.value);",
                    "      const singleQuoteCount = countChars(value, \"'\");",
                    "      const doubleQuoteCount = countChars(value, '\"');",
                    "      const quote = singleQuoteCount < doubleQuoteCount ? \"'\" : '\"';",
                    "      return [",
                    "        node.rawName,",
                    "",
                    "        \"=\",",
                    "        quote,",
                    "",
                    "        ...replaceTextEndOfLine(",
                    "          quote === '\"'",
                    "            ? value.replace(/\"/g, \"&quot;\")",
                    "            : value.replace(/'/g, \"&apos;\")",
                    "        ),",
                    "        quote,",
                    "      ];",
                    "    }",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unexpected node type ${node.type}`);",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  embed,",
                    "};"
                ]
            },
            "syntax-attribute.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const parseSrcset = require(\"parse-srcset\");",
                    "const {",
                    "  builders: { ifBreak, join, line },",
                    "} = require(\"../document/index.js\");",
                    "",
                    "function printImgSrcset(value) {",
                    "  const srcset = parseSrcset(value, {",
                    "    logger: {",
                    "      error(message) {",
                    "        throw new Error(message);",
                    "      },",
                    "    },",
                    "  });",
                    "",
                    "  const hasW = srcset.some(({ w }) => w);",
                    "  const hasH = srcset.some(({ h }) => h);",
                    "  const hasX = srcset.some(({ d }) => d);",
                    "",
                    "  if (hasW + hasH + hasX > 1) {",
                    "    throw new Error(\"Mixed descriptor in srcset is not supported\");",
                    "  }",
                    "",
                    "  const key = hasW ? \"w\" : hasH ? \"h\" : \"d\";",
                    "  const unit = hasW ? \"w\" : hasH ? \"h\" : \"x\";",
                    "",
                    "  const getMax = (values) => Math.max(...values);",
                    "",
                    "  const urls = srcset.map((src) => src.url);",
                    "  const maxUrlLength = getMax(urls.map((url) => url.length));",
                    "",
                    "  const descriptors = srcset",
                    "    .map((src) => src[key])",
                    "    .map((descriptor) => (descriptor ? descriptor.toString() : \"\"));",
                    "  const descriptorLeftLengths = descriptors.map((descriptor) => {",
                    "    const index = descriptor.indexOf(\".\");",
                    "    return index === -1 ? descriptor.length : index;",
                    "  });",
                    "  const maxDescriptorLeftLength = getMax(descriptorLeftLengths);",
                    "",
                    "  return join(",
                    "    [\",\", line],",
                    "    urls.map((url, index) => {",
                    "      const parts = [url];",
                    "",
                    "      const descriptor = descriptors[index];",
                    "      if (descriptor) {",
                    "        const urlPadding = maxUrlLength - url.length + 1;",
                    "        const descriptorPadding =",
                    "          maxDescriptorLeftLength - descriptorLeftLengths[index];",
                    "",
                    "        const alignment = \" \".repeat(urlPadding + descriptorPadding);",
                    "        parts.push(ifBreak(alignment, \" \"), descriptor + unit);",
                    "      }",
                    "",
                    "      return parts;",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function printClassNames(value) {",
                    "  return value.trim().split(/\\s+/).join(\" \");",
                    "}",
                    "",
                    "module.exports = {",
                    "  printImgSrcset,",
                    "  printClassNames,",
                    "};"
                ]
            },
            "syntax-vue.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { group },",
                    "} = require(\"../document/index.js\");",
                    "",
                    "/**",
                    " *     v-for=\"... in ...\"",
                    " *     v-for=\"... of ...\"",
                    " *     v-for=\"(..., ...) in ...\"",
                    " *     v-for=\"(..., ...) of ...\"",
                    " */",
                    "function printVueFor(value, textToDoc) {",
                    "  const { left, operator, right } = parseVueFor(value);",
                    "  return [",
                    "    group(",
                    "      textToDoc(`function _(${left}) {}`, {",
                    "        parser: \"babel\",",
                    "        __isVueForBindingLeft: true,",
                    "      })",
                    "    ),",
                    "    \" \",",
                    "    operator,",
                    "    \" \",",
                    "    textToDoc(",
                    "      right,",
                    "      { parser: \"__js_expression\" },",
                    "      { stripTrailingHardline: true }",
                    "    ),",
                    "  ];",
                    "}",
                    "",
                    "// modified from https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/parser/index.js#L370-L387",
                    "function parseVueFor(value) {",
                    "  const forAliasRE = /(.*?)\\s+(in|of)\\s+(.*)/s;",
                    "  const forIteratorRE = /,([^,\\]}]*)(?:,([^,\\]}]*))?$/;",
                    "  const stripParensRE = /^\\(|\\)$/g;",
                    "",
                    "  const inMatch = value.match(forAliasRE);",
                    "  if (!inMatch) {",
                    "    return;",
                    "  }",
                    "",
                    "  const res = {};",
                    "  res.for = inMatch[3].trim();",
                    "  if (!res.for) {",
                    "    return;",
                    "  }",
                    "",
                    "  const alias = inMatch[1].trim().replace(stripParensRE, \"\");",
                    "  const iteratorMatch = alias.match(forIteratorRE);",
                    "  if (iteratorMatch) {",
                    "    res.alias = alias.replace(forIteratorRE, \"\");",
                    "    res.iterator1 = iteratorMatch[1].trim();",
                    "    if (iteratorMatch[2]) {",
                    "      res.iterator2 = iteratorMatch[2].trim();",
                    "    }",
                    "  } else {",
                    "    res.alias = alias;",
                    "  }",
                    "",
                    "  const left = [res.alias, res.iterator1, res.iterator2];",
                    "  if (",
                    "    left.some(",
                    "      (part, index) =>",
                    "        !part && (index === 0 || left.slice(index + 1).some(Boolean))",
                    "    )",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  return {",
                    "    left: left.filter(Boolean).join(\",\"),",
                    "    operator: inMatch[2],",
                    "    right: res.for,",
                    "  };",
                    "}",
                    "",
                    "function printVueBindings(value, textToDoc) {",
                    "  return textToDoc(`function _(${value}) {}`, {",
                    "    parser: \"babel\",",
                    "    __isVueBindings: true,",
                    "  });",
                    "}",
                    "",
                    "function isVueEventBindingExpression(eventBindingValue) {",
                    "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/codegen/events.js#L3-L4",
                    "  // arrow function or anonymous function",
                    "  const fnExpRE = /^(?:[\\w$]+|\\([^)]*\\))\\s*=>|^function\\s*\\(/;",
                    "  // simple member expression chain (a, a.b, a['b'], a[\"b\"], a[0], a[b])",
                    "  const simplePathRE =",
                    "    /^[$A-Z_a-z][\\w$]*(?:\\.[$A-Z_a-z][\\w$]*|\\['[^']*']|\\[\"[^\"]*\"]|\\[\\d+]|\\[[$A-Z_a-z][\\w$]*])*$/;",
                    "",
                    "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/helpers.js#L104",
                    "  const value = eventBindingValue.trim();",
                    "",
                    "  return fnExpRE.test(value) || simplePathRE.test(value);",
                    "}",
                    "",
                    "module.exports = {",
                    "  isVueEventBindingExpression,",
                    "  printVueFor,",
                    "  printVueBindings,",
                    "};"
                ]
            },
            "print": {
                "children.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { breakParent, group, ifBreak, line, softline, hardline },",
                        "  utils: { replaceTextEndOfLine },",
                        "} = require(\"../../document/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const {",
                        "  forceBreakChildren,",
                        "  forceNextEmptyLine,",
                        "  isTextLikeNode,",
                        "  hasPrettierIgnore,",
                        "  preferHardlineAsLeadingSpaces,",
                        "} = require(\"../utils/index.js\");",
                        "const {",
                        "  printOpeningTagPrefix,",
                        "  needsToBorrowNextOpeningTagStartMarker,",
                        "  printOpeningTagStartMarker,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  printClosingTagEndMarker,",
                        "  printClosingTagSuffix,",
                        "  needsToBorrowParentClosingTagStartMarker,",
                        "} = require(\"./tag.js\");",
                        "",
                        "function printChild(childPath, options, print) {",
                        "  const child = childPath.getValue();",
                        "",
                        "  if (hasPrettierIgnore(child)) {",
                        "    return [",
                        "      printOpeningTagPrefix(child, options),",
                        "      ...replaceTextEndOfLine(",
                        "        options.originalText.slice(",
                        "          locStart(child) +",
                        "            (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev)",
                        "              ? printOpeningTagStartMarker(child).length",
                        "              : 0),",
                        "          locEnd(child) -",
                        "            (child.next && needsToBorrowPrevClosingTagEndMarker(child.next)",
                        "              ? printClosingTagEndMarker(child, options).length",
                        "              : 0)",
                        "        )",
                        "      ),",
                        "      printClosingTagSuffix(child, options),",
                        "    ];",
                        "  }",
                        "",
                        "  return print();",
                        "}",
                        "",
                        "function printBetweenLine(prevNode, nextNode) {",
                        "  return isTextLikeNode(prevNode) && isTextLikeNode(nextNode)",
                        "    ? prevNode.isTrailingSpaceSensitive",
                        "      ? prevNode.hasTrailingSpaces",
                        "        ? preferHardlineAsLeadingSpaces(nextNode)",
                        "          ? hardline",
                        "          : line",
                        "        : \"\"",
                        "      : preferHardlineAsLeadingSpaces(nextNode)",
                        "      ? hardline",
                        "      : softline",
                        "    : (needsToBorrowNextOpeningTagStartMarker(prevNode) &&",
                        "        (hasPrettierIgnore(nextNode) ||",
                        "          /**",
                        "           *     123<a",
                        "           *          ~",
                        "           *       ><b>",
                        "           */",
                        "          nextNode.firstChild ||",
                        "          /**",
                        "           *     123<!--",
                        "           *            ~",
                        "           *     -->",
                        "           */",
                        "          nextNode.isSelfClosing ||",
                        "          /**",
                        "           *     123<span",
                        "           *             ~",
                        "           *       attr",
                        "           */",
                        "          (nextNode.type === \"element\" && nextNode.attrs.length > 0))) ||",
                        "      /**",
                        "       *     <img",
                        "       *       src=\"long\"",
                        "       *                 ~",
                        "       *     />123",
                        "       */",
                        "      (prevNode.type === \"element\" &&",
                        "        prevNode.isSelfClosing &&",
                        "        needsToBorrowPrevClosingTagEndMarker(nextNode))",
                        "    ? \"\"",
                        "    : !nextNode.isLeadingSpaceSensitive ||",
                        "      preferHardlineAsLeadingSpaces(nextNode) ||",
                        "      /**",
                        "       *       Want to write us a letter? Use our<a",
                        "       *         ><b><a>mailing address</a></b></a",
                        "       *                                          ~",
                        "       *       >.",
                        "       */",
                        "      (needsToBorrowPrevClosingTagEndMarker(nextNode) &&",
                        "        prevNode.lastChild &&",
                        "        needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) &&",
                        "        prevNode.lastChild.lastChild &&",
                        "        needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild))",
                        "    ? hardline",
                        "    : nextNode.hasLeadingSpaces",
                        "    ? line",
                        "    : softline;",
                        "}",
                        "",
                        "function printChildren(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (forceBreakChildren(node)) {",
                        "    return [",
                        "      breakParent,",
                        "",
                        "      ...path.map((childPath) => {",
                        "        const childNode = childPath.getValue();",
                        "        const prevBetweenLine = !childNode.prev",
                        "          ? \"\"",
                        "          : printBetweenLine(childNode.prev, childNode);",
                        "        return [",
                        "          !prevBetweenLine",
                        "            ? \"\"",
                        "            : [",
                        "                prevBetweenLine,",
                        "                forceNextEmptyLine(childNode.prev) ? hardline : \"\",",
                        "              ],",
                        "          printChild(childPath, options, print),",
                        "        ];",
                        "      }, \"children\"),",
                        "    ];",
                        "  }",
                        "",
                        "  const groupIds = node.children.map(() => Symbol(\"\"));",
                        "  return path.map((childPath, childIndex) => {",
                        "    const childNode = childPath.getValue();",
                        "",
                        "    if (isTextLikeNode(childNode)) {",
                        "      if (childNode.prev && isTextLikeNode(childNode.prev)) {",
                        "        const prevBetweenLine = printBetweenLine(childNode.prev, childNode);",
                        "        if (prevBetweenLine) {",
                        "          if (forceNextEmptyLine(childNode.prev)) {",
                        "            return [hardline, hardline, printChild(childPath, options, print)];",
                        "          }",
                        "          return [prevBetweenLine, printChild(childPath, options, print)];",
                        "        }",
                        "      }",
                        "      return printChild(childPath, options, print);",
                        "    }",
                        "",
                        "    const prevParts = [];",
                        "    const leadingParts = [];",
                        "    const trailingParts = [];",
                        "    const nextParts = [];",
                        "",
                        "    const prevBetweenLine = childNode.prev",
                        "      ? printBetweenLine(childNode.prev, childNode)",
                        "      : \"\";",
                        "",
                        "    const nextBetweenLine = childNode.next",
                        "      ? printBetweenLine(childNode, childNode.next)",
                        "      : \"\";",
                        "",
                        "    if (prevBetweenLine) {",
                        "      if (forceNextEmptyLine(childNode.prev)) {",
                        "        prevParts.push(hardline, hardline);",
                        "      } else if (prevBetweenLine === hardline) {",
                        "        prevParts.push(hardline);",
                        "      } else {",
                        "        if (isTextLikeNode(childNode.prev)) {",
                        "          leadingParts.push(prevBetweenLine);",
                        "        } else {",
                        "          leadingParts.push(",
                        "            ifBreak(\"\", softline, {",
                        "              groupId: groupIds[childIndex - 1],",
                        "            })",
                        "          );",
                        "        }",
                        "      }",
                        "    }",
                        "",
                        "    if (nextBetweenLine) {",
                        "      if (forceNextEmptyLine(childNode)) {",
                        "        if (isTextLikeNode(childNode.next)) {",
                        "          nextParts.push(hardline, hardline);",
                        "        }",
                        "      } else if (nextBetweenLine === hardline) {",
                        "        if (isTextLikeNode(childNode.next)) {",
                        "          nextParts.push(hardline);",
                        "        }",
                        "      } else {",
                        "        trailingParts.push(nextBetweenLine);",
                        "      }",
                        "    }",
                        "",
                        "    return [",
                        "      ...prevParts,",
                        "      group([",
                        "        ...leadingParts,",
                        "        group([printChild(childPath, options, print), ...trailingParts], {",
                        "          id: groupIds[childIndex],",
                        "        }),",
                        "      ]),",
                        "      ...nextParts,",
                        "    ];",
                        "  }, \"children\");",
                        "}",
                        "",
                        "module.exports = { printChildren };"
                    ]
                },
                "element.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: {",
                        "    breakParent,",
                        "    dedentToRoot,",
                        "    group,",
                        "    ifBreak,",
                        "    indentIfBreak,",
                        "    indent,",
                        "    line,",
                        "    softline,",
                        "  },",
                        "  utils: { replaceTextEndOfLine },",
                        "} = require(\"../../document/index.js\");",
                        "const getNodeContent = require(\"../get-node-content.js\");",
                        "const {",
                        "  shouldPreserveContent,",
                        "  isScriptLikeTag,",
                        "  isVueCustomBlock,",
                        "  countParents,",
                        "  forceBreakContent,",
                        "} = require(\"../utils/index.js\");",
                        "const {",
                        "  printOpeningTagPrefix,",
                        "  printOpeningTag,",
                        "  printClosingTagSuffix,",
                        "  printClosingTag,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  needsToBorrowLastChildClosingTagEndMarker,",
                        "} = require(\"./tag.js\");",
                        "const { printChildren } = require(\"./children.js\");",
                        "",
                        "function printElement(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (shouldPreserveContent(node, options)) {",
                        "    return [",
                        "      printOpeningTagPrefix(node, options),",
                        "      group(printOpeningTag(path, options, print)),",
                        "      ...replaceTextEndOfLine(getNodeContent(node, options)),",
                        "      ...printClosingTag(node, options),",
                        "      printClosingTagSuffix(node, options),",
                        "    ];",
                        "  }",
                        "  /**",
                        "   * do not break:",
                        "   *",
                        "   *     <div>{{",
                        "   *         ~",
                        "   *       interpolation",
                        "   *     }}</div>",
                        "   *            ~",
                        "   *",
                        "   * exception: break if the opening tag breaks",
                        "   *",
                        "   *     <div",
                        "   *       long",
                        "   *           ~",
                        "   *       >{{",
                        "   *         interpolation",
                        "   *       }}</div",
                        "   *              ~",
                        "   *     >",
                        "   */",
                        "  const shouldHugContent =",
                        "    node.children.length === 1 &&",
                        "    node.firstChild.type === \"interpolation\" &&",
                        "    node.firstChild.isLeadingSpaceSensitive &&",
                        "    !node.firstChild.hasLeadingSpaces &&",
                        "    node.lastChild.isTrailingSpaceSensitive &&",
                        "    !node.lastChild.hasTrailingSpaces;",
                        "",
                        "  const attrGroupId = Symbol(\"element-attr-group-id\");",
                        "",
                        "  const printTag = (doc) =>",
                        "    group([",
                        "      group(printOpeningTag(path, options, print), { id: attrGroupId }),",
                        "      doc,",
                        "      printClosingTag(node, options),",
                        "    ]);",
                        "",
                        "  const printChildrenDoc = (childrenDoc) => {",
                        "    if (shouldHugContent) {",
                        "      return indentIfBreak(childrenDoc, { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      (isScriptLikeTag(node) || isVueCustomBlock(node, options)) &&",
                        "      node.parent.type === \"root\" &&",
                        "      options.parser === \"vue\" &&",
                        "      !options.vueIndentScriptAndStyle",
                        "    ) {",
                        "      return childrenDoc;",
                        "    }",
                        "    return indent(childrenDoc);",
                        "  };",
                        "",
                        "  const printLineBeforeChildren = () => {",
                        "    if (shouldHugContent) {",
                        "      return ifBreak(softline, \"\", { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      node.firstChild.hasLeadingSpaces &&",
                        "      node.firstChild.isLeadingSpaceSensitive",
                        "    ) {",
                        "      return line;",
                        "    }",
                        "    if (",
                        "      node.firstChild.type === \"text\" &&",
                        "      node.isWhitespaceSensitive &&",
                        "      node.isIndentationSensitive",
                        "    ) {",
                        "      return dedentToRoot(softline);",
                        "    }",
                        "    return softline;",
                        "  };",
                        "",
                        "  const printLineAfterChildren = () => {",
                        "    const needsToBorrow = node.next",
                        "      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                        "      : needsToBorrowLastChildClosingTagEndMarker(node.parent);",
                        "    if (needsToBorrow) {",
                        "      if (",
                        "        node.lastChild.hasTrailingSpaces &&",
                        "        node.lastChild.isTrailingSpaceSensitive",
                        "      ) {",
                        "        return \" \";",
                        "      }",
                        "      return \"\";",
                        "    }",
                        "    if (shouldHugContent) {",
                        "      return ifBreak(softline, \"\", { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      node.lastChild.hasTrailingSpaces &&",
                        "      node.lastChild.isTrailingSpaceSensitive",
                        "    ) {",
                        "      return line;",
                        "    }",
                        "    if (",
                        "      (node.lastChild.type === \"comment\" ||",
                        "        (node.lastChild.type === \"text\" &&",
                        "          node.isWhitespaceSensitive &&",
                        "          node.isIndentationSensitive)) &&",
                        "      new RegExp(",
                        "        `\\\\n[\\\\t ]{${",
                        "          options.tabWidth *",
                        "          countParents(",
                        "            path,",
                        "            (node) => node.parent && node.parent.type !== \"root\"",
                        "          )",
                        "        }}$`",
                        "      ).test(node.lastChild.value)",
                        "    ) {",
                        "      return \"\";",
                        "    }",
                        "    return softline;",
                        "  };",
                        "",
                        "  if (node.children.length === 0) {",
                        "    return printTag(",
                        "      node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line : \"\"",
                        "    );",
                        "  }",
                        "",
                        "  return printTag([",
                        "    forceBreakContent(node) ? breakParent : \"\",",
                        "    printChildrenDoc([",
                        "      printLineBeforeChildren(),",
                        "      printChildren(path, options, print),",
                        "    ]),",
                        "    printLineAfterChildren(),",
                        "  ]);",
                        "}",
                        "",
                        "module.exports = { printElement };"
                    ]
                },
                "tag.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document\").Doc} Doc",
                        " */",
                        "",
                        "const assert = require(\"assert\");",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { indent, join, line, softline, hardline },",
                        "  utils: { replaceTextEndOfLine },",
                        "} = require(\"../../document/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const {",
                        "  isTextLikeNode,",
                        "  getLastDescendant,",
                        "  isPreLikeNode,",
                        "  hasPrettierIgnore,",
                        "  shouldPreserveContent,",
                        "  isVueSfcBlock,",
                        "} = require(\"../utils/index.js\");",
                        "",
                        "function printClosingTag(node, options) {",
                        "  return [",
                        "    node.isSelfClosing ? \"\" : printClosingTagStart(node, options),",
                        "    printClosingTagEnd(node, options),",
                        "  ];",
                        "}",
                        "",
                        "function printClosingTagStart(node, options) {",
                        "  return node.lastChild &&",
                        "    needsToBorrowParentClosingTagStartMarker(node.lastChild)",
                        "    ? \"\"",
                        "    : [",
                        "        printClosingTagPrefix(node, options),",
                        "        printClosingTagStartMarker(node, options),",
                        "      ];",
                        "}",
                        "",
                        "function printClosingTagEnd(node, options) {",
                        "  return (",
                        "    node.next",
                        "      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                        "      : needsToBorrowLastChildClosingTagEndMarker(node.parent)",
                        "  )",
                        "    ? \"\"",
                        "    : [",
                        "        printClosingTagEndMarker(node, options),",
                        "        printClosingTagSuffix(node, options),",
                        "      ];",
                        "}",
                        "",
                        "function printClosingTagPrefix(node, options) {",
                        "  return needsToBorrowLastChildClosingTagEndMarker(node)",
                        "    ? printClosingTagEndMarker(node.lastChild, options)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printClosingTagSuffix(node, options) {",
                        "  return needsToBorrowParentClosingTagStartMarker(node)",
                        "    ? printClosingTagStartMarker(node.parent, options)",
                        "    : needsToBorrowNextOpeningTagStartMarker(node)",
                        "    ? printOpeningTagStartMarker(node.next)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printClosingTagStartMarker(node, options) {",
                        "  assert(!node.isSelfClosing);",
                        "  /* istanbul ignore next */",
                        "  if (shouldNotPrintClosingTag(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "      return \"<!\";",
                        "    case \"element\":",
                        "      if (node.hasHtmComponentClosingTag) {",
                        "        return \"<//\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return `</${node.rawName}`;",
                        "  }",
                        "}",
                        "",
                        "function printClosingTagEndMarker(node, options) {",
                        "  if (shouldNotPrintClosingTag(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"ieConditionalEndComment\":",
                        "      return \"[endif]-->\";",
                        "    case \"ieConditionalStartComment\":",
                        "      return \"]><!-->\";",
                        "    case \"interpolation\":",
                        "      return \"}}\";",
                        "    case \"element\":",
                        "      if (node.isSelfClosing) {",
                        "        return \"/>\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return \">\";",
                        "  }",
                        "}",
                        "",
                        "function shouldNotPrintClosingTag(node, options) {",
                        "  return (",
                        "    !node.isSelfClosing &&",
                        "    !node.endSourceSpan &&",
                        "    (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options))",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowPrevClosingTagEndMarker(node) {",
                        "  /**",
                        "   *     <p></p",
                        "   *     >123",
                        "   *     ^",
                        "   *",
                        "   *     <p></p",
                        "   *     ><a",
                        "   *     ^",
                        "   */",
                        "  return (",
                        "    node.prev &&",
                        "    node.prev.type !== \"docType\" &&",
                        "    !isTextLikeNode(node.prev) &&",
                        "    node.isLeadingSpaceSensitive &&",
                        "    !node.hasLeadingSpaces",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowLastChildClosingTagEndMarker(node) {",
                        "  /**",
                        "   *     <p",
                        "   *       ><a></a",
                        "   *       ></p",
                        "   *       ^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    node.lastChild &&",
                        "    node.lastChild.isTrailingSpaceSensitive &&",
                        "    !node.lastChild.hasTrailingSpaces &&",
                        "    !isTextLikeNode(getLastDescendant(node.lastChild)) &&",
                        "    !isPreLikeNode(node)",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowParentClosingTagStartMarker(node) {",
                        "  /**",
                        "   *     <p>",
                        "   *       123</p",
                        "   *          ^^^",
                        "   *     >",
                        "   *",
                        "   *         123</b",
                        "   *       ></a",
                        "   *        ^^^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    !node.next &&",
                        "    !node.hasTrailingSpaces &&",
                        "    node.isTrailingSpaceSensitive &&",
                        "    isTextLikeNode(getLastDescendant(node))",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowNextOpeningTagStartMarker(node) {",
                        "  /**",
                        "   *     123<p",
                        "   *        ^^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    node.next &&",
                        "    !isTextLikeNode(node.next) &&",
                        "    isTextLikeNode(node) &&",
                        "    node.isTrailingSpaceSensitive &&",
                        "    !node.hasTrailingSpaces",
                        "  );",
                        "}",
                        "",
                        "function getPrettierIgnoreAttributeCommentData(value) {",
                        "  const match = value.trim().match(/^prettier-ignore-attribute(?:\\s+(.+))?$/s);",
                        "",
                        "  if (!match) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!match[1]) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return match[1].split(/\\s+/);",
                        "}",
                        "",
                        "function needsToBorrowParentOpeningTagEndMarker(node) {",
                        "  /**",
                        "   *     <p",
                        "   *       >123",
                        "   *       ^",
                        "   *",
                        "   *     <p",
                        "   *       ><a",
                        "   *       ^",
                        "   */",
                        "  return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;",
                        "}",
                        "",
                        "function printAttributes(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (!isNonEmptyArray(node.attrs)) {",
                        "    return node.isSelfClosing",
                        "      ? /**",
                        "         *     <br />",
                        "         *        ^",
                        "         */",
                        "        \" \"",
                        "      : \"\";",
                        "  }",
                        "",
                        "  const ignoreAttributeData =",
                        "    node.prev &&",
                        "    node.prev.type === \"comment\" &&",
                        "    getPrettierIgnoreAttributeCommentData(node.prev.value);",
                        "",
                        "  const hasPrettierIgnoreAttribute =",
                        "    typeof ignoreAttributeData === \"boolean\"",
                        "      ? () => ignoreAttributeData",
                        "      : Array.isArray(ignoreAttributeData)",
                        "      ? (attribute) => ignoreAttributeData.includes(attribute.rawName)",
                        "      : () => false;",
                        "",
                        "  const printedAttributes = path.map((attributePath) => {",
                        "    const attribute = attributePath.getValue();",
                        "    return hasPrettierIgnoreAttribute(attribute)",
                        "      ? replaceTextEndOfLine(",
                        "          options.originalText.slice(locStart(attribute), locEnd(attribute))",
                        "        )",
                        "      : print();",
                        "  }, \"attrs\");",
                        "",
                        "  const forceNotToBreakAttrContent =",
                        "    node.type === \"element\" &&",
                        "    node.fullName === \"script\" &&",
                        "    node.attrs.length === 1 &&",
                        "    node.attrs[0].fullName === \"src\" &&",
                        "    node.children.length === 0;",
                        "",
                        "  const shouldPrintAttributePerLine =",
                        "    options.singleAttributePerLine &&",
                        "    node.attrs.length > 1 &&",
                        "    !isVueSfcBlock(node, options);",
                        "  const attributeLine = shouldPrintAttributePerLine ? hardline : line;",
                        "",
                        "  /** @type {Doc[]} */",
                        "  const parts = [",
                        "    indent([",
                        "      forceNotToBreakAttrContent ? \" \" : line,",
                        "      join(attributeLine, printedAttributes),",
                        "    ]),",
                        "  ];",
                        "",
                        "  if (",
                        "    /**",
                        "     *     123<a",
                        "     *       attr",
                        "     *           ~",
                        "     *       >456",
                        "     */",
                        "    (node.firstChild &&",
                        "      needsToBorrowParentOpeningTagEndMarker(node.firstChild)) ||",
                        "    /**",
                        "     *     <span",
                        "     *       >123<meta",
                        "     *                ~",
                        "     *     /></span>",
                        "     */",
                        "    (node.isSelfClosing &&",
                        "      needsToBorrowLastChildClosingTagEndMarker(node.parent)) ||",
                        "    forceNotToBreakAttrContent",
                        "  ) {",
                        "    parts.push(node.isSelfClosing ? \" \" : \"\");",
                        "  } else {",
                        "    parts.push(",
                        "      options.bracketSameLine",
                        "        ? node.isSelfClosing",
                        "          ? \" \"",
                        "          : \"\"",
                        "        : node.isSelfClosing",
                        "        ? line",
                        "        : softline",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printOpeningTagEnd(node) {",
                        "  return node.firstChild &&",
                        "    needsToBorrowParentOpeningTagEndMarker(node.firstChild)",
                        "    ? \"\"",
                        "    : printOpeningTagEndMarker(node);",
                        "}",
                        "",
                        "function printOpeningTag(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  return [",
                        "    printOpeningTagStart(node, options),",
                        "    printAttributes(path, options, print),",
                        "    node.isSelfClosing ? \"\" : printOpeningTagEnd(node),",
                        "  ];",
                        "}",
                        "",
                        "function printOpeningTagStart(node, options) {",
                        "  return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev)",
                        "    ? \"\"",
                        "    : [printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)];",
                        "}",
                        "",
                        "function printOpeningTagPrefix(node, options) {",
                        "  return needsToBorrowParentOpeningTagEndMarker(node)",
                        "    ? printOpeningTagEndMarker(node.parent)",
                        "    : needsToBorrowPrevClosingTagEndMarker(node)",
                        "    ? printClosingTagEndMarker(node.prev, options)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printOpeningTagStartMarker(node) {",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"ieConditionalStartComment\":",
                        "      return `<!--[if ${node.condition}`;",
                        "    case \"ieConditionalEndComment\":",
                        "      return \"<!--<!\";",
                        "    case \"interpolation\":",
                        "      return \"{{\";",
                        "    case \"docType\":",
                        "      return \"<!DOCTYPE\";",
                        "    case \"element\":",
                        "      if (node.condition) {",
                        "        return `<!--[if ${node.condition}]><!--><${node.rawName}`;",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return `<${node.rawName}`;",
                        "  }",
                        "}",
                        "",
                        "function printOpeningTagEndMarker(node) {",
                        "  assert(!node.isSelfClosing);",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "      return \"]>\";",
                        "    case \"element\":",
                        "      if (node.condition) {",
                        "        return \"><!--<![endif]-->\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return \">\";",
                        "  }",
                        "}",
                        "",
                        "module.exports = {",
                        "  printClosingTag,",
                        "  printClosingTagStart,",
                        "  printClosingTagStartMarker,",
                        "  printClosingTagEndMarker,",
                        "  printClosingTagSuffix,",
                        "  printClosingTagEnd,",
                        "  needsToBorrowLastChildClosingTagEndMarker,",
                        "  needsToBorrowParentClosingTagStartMarker,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  printOpeningTag,",
                        "  printOpeningTagStart,",
                        "  printOpeningTagPrefix,",
                        "  printOpeningTagStartMarker,",
                        "  printOpeningTagEndMarker,",
                        "  needsToBorrowNextOpeningTagStartMarker,",
                        "  needsToBorrowParentOpeningTagEndMarker,",
                        "};"
                    ]
                }
            },
            "utils": {
                "array-to-map.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function arrayToMap(array) {",
                        "  const map = Object.create(null);",
                        "  for (const value of array) {",
                        "    map[value] = true;",
                        "  }",
                        "  return map;",
                        "}",
                        "",
                        "module.exports = arrayToMap;"
                    ]
                },
                "html-elements-attributes.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  htmlElementAttributes,",
                        "} = require(\"../../../vendors/html-element-attributes.json\");",
                        "const mapObject = require(\"./map-object.js\");",
                        "const arrayToMap = require(\"./array-to-map.js\");",
                        "",
                        "const HTML_ELEMENT_ATTRIBUTES = mapObject(htmlElementAttributes, arrayToMap);",
                        "",
                        "module.exports = HTML_ELEMENT_ATTRIBUTES;"
                    ]
                },
                "html-tag-names.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { htmlTagNames } = require(\"../../../vendors/html-tag-names.json\");",
                        "const arrayToMap = require(\"./array-to-map.js\");",
                        "",
                        "const HTML_TAGS = arrayToMap(htmlTagNames);",
                        "",
                        "module.exports = HTML_TAGS;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path\")} AstPath",
                        " */",
                        "",
                        "const {",
                        "  inferParserByLanguage,",
                        "  isFrontMatterNode,",
                        "} = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { line, hardline, join },",
                        "  utils: { getDocParts, replaceTextEndOfLine },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  CSS_DISPLAY_TAGS,",
                        "  CSS_DISPLAY_DEFAULT,",
                        "  CSS_WHITE_SPACE_TAGS,",
                        "  CSS_WHITE_SPACE_DEFAULT,",
                        "} = require(\"../constants.evaluate.js\");",
                        "const isUnknownNamespace = require(\"./is-unknown-namespace.js\");",
                        "",
                        "// https://infra.spec.whatwg.org/#ascii-whitespace",
                        "const HTML_WHITESPACE = new Set([\"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"]);",
                        "const htmlTrimStart = (string) => string.replace(/^[\\t\\n\\f\\r ]+/, \"\");",
                        "const htmlTrimEnd = (string) => string.replace(/[\\t\\n\\f\\r ]+$/, \"\");",
                        "const htmlTrim = (string) => htmlTrimStart(htmlTrimEnd(string));",
                        "const htmlTrimLeadingBlankLines = (string) =>",
                        "  string.replace(/^[\\t\\f\\r ]*\\n/g, \"\");",
                        "const htmlTrimPreserveIndentation = (string) =>",
                        "  htmlTrimLeadingBlankLines(htmlTrimEnd(string));",
                        "const splitByHtmlWhitespace = (string) => string.split(/[\\t\\n\\f\\r ]+/);",
                        "const getLeadingHtmlWhitespace = (string) => string.match(/^[\\t\\n\\f\\r ]*/)[0];",
                        "const getLeadingAndTrailingHtmlWhitespace = (string) => {",
                        "  const [, leadingWhitespace, text, trailingWhitespace] = string.match(",
                        "    /^([\\t\\n\\f\\r ]*)(.*?)([\\t\\n\\f\\r ]*)$/s",
                        "  );",
                        "  return {",
                        "    leadingWhitespace,",
                        "    trailingWhitespace,",
                        "    text,",
                        "  };",
                        "};",
                        "const hasHtmlWhitespace = (string) => /[\\t\\n\\f\\r ]/.test(string);",
                        "",
                        "function shouldPreserveContent(node, options) {",
                        "  // unterminated node in ie conditional comment",
                        "  // e.g. <!--[if lt IE 9]><html><![endif]-->",
                        "  if (",
                        "    node.type === \"ieConditionalComment\" &&",
                        "    node.lastChild &&",
                        "    !node.lastChild.isSelfClosing &&",
                        "    !node.lastChild.endSourceSpan",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // incomplete html in ie conditional comment",
                        "  // e.g. <!--[if lt IE 9]></div><![endif]-->",
                        "  if (node.type === \"ieConditionalComment\" && !node.complete) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // TODO: handle non-text children in <pre>",
                        "  if (",
                        "    isPreLikeNode(node) &&",
                        "    node.children.some(",
                        "      (child) => child.type !== \"text\" && child.type !== \"interpolation\"",
                        "    )",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    isVueNonHtmlBlock(node, options) &&",
                        "    !isScriptLikeTag(node) &&",
                        "    node.type !== \"interpolation\"",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function hasPrettierIgnore(node) {",
                        "  /* istanbul ignore next */",
                        "  if (node.type === \"attribute\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  /* istanbul ignore next */",
                        "  if (!node.parent) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!node.prev) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return isPrettierIgnore(node.prev);",
                        "}",
                        "",
                        "function isPrettierIgnore(node) {",
                        "  return node.type === \"comment\" && node.value.trim() === \"prettier-ignore\";",
                        "}",
                        "",
                        "/** there's no opening/closing tag or it's considered not breakable */",
                        "function isTextLikeNode(node) {",
                        "  return node.type === \"text\" || node.type === \"comment\";",
                        "}",
                        "",
                        "function isScriptLikeTag(node) {",
                        "  return (",
                        "    node.type === \"element\" &&",
                        "    (node.fullName === \"script\" ||",
                        "      node.fullName === \"style\" ||",
                        "      node.fullName === \"svg:style\" ||",
                        "      (isUnknownNamespace(node) &&",
                        "        (node.name === \"script\" || node.name === \"style\")))",
                        "  );",
                        "}",
                        "",
                        "function canHaveInterpolation(node) {",
                        "  return node.children && !isScriptLikeTag(node);",
                        "}",
                        "",
                        "function isWhitespaceSensitiveNode(node) {",
                        "  return (",
                        "    isScriptLikeTag(node) ||",
                        "    node.type === \"interpolation\" ||",
                        "    isIndentationSensitiveNode(node)",
                        "  );",
                        "}",
                        "",
                        "function isIndentationSensitiveNode(node) {",
                        "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                        "}",
                        "",
                        "function isLeadingSpaceSensitiveNode(node, options) {",
                        "  const isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();",
                        "",
                        "  if (",
                        "    isLeadingSpaceSensitive &&",
                        "    !node.prev &&",
                        "    node.parent &&",
                        "    node.parent.tagDefinition &&",
                        "    node.parent.tagDefinition.ignoreFirstLf",
                        "  ) {",
                        "    return node.type === \"interpolation\";",
                        "  }",
                        "",
                        "  return isLeadingSpaceSensitive;",
                        "",
                        "  function _isLeadingSpaceSensitiveNode() {",
                        "    if (isFrontMatterNode(node)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (",
                        "      (node.type === \"text\" || node.type === \"interpolation\") &&",
                        "      node.prev &&",
                        "      (node.prev.type === \"text\" || node.prev.type === \"interpolation\")",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "",
                        "    if (!node.parent || node.parent.cssDisplay === \"none\") {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (isPreLikeNode(node.parent)) {",
                        "      return true;",
                        "    }",
                        "",
                        "    if (",
                        "      !node.prev &&",
                        "      (node.parent.type === \"root\" ||",
                        "        (isPreLikeNode(node) && node.parent) ||",
                        "        isScriptLikeTag(node.parent) ||",
                        "        isVueCustomBlock(node.parent, options) ||",
                        "        !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (",
                        "      node.prev &&",
                        "      !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return true;",
                        "  }",
                        "}",
                        "",
                        "function isTrailingSpaceSensitiveNode(node, options) {",
                        "  if (isFrontMatterNode(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    (node.type === \"text\" || node.type === \"interpolation\") &&",
                        "    node.next &&",
                        "    (node.next.type === \"text\" || node.next.type === \"interpolation\")",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!node.parent || node.parent.cssDisplay === \"none\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isPreLikeNode(node.parent)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    !node.next &&",
                        "    (node.parent.type === \"root\" ||",
                        "      (isPreLikeNode(node) && node.parent) ||",
                        "      isScriptLikeTag(node.parent) ||",
                        "      isVueCustomBlock(node.parent, options) ||",
                        "      !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    node.next &&",
                        "    !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "function isDanglingSpaceSensitiveNode(node) {",
                        "  return (",
                        "    isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) &&",
                        "    !isScriptLikeTag(node)",
                        "  );",
                        "}",
                        "",
                        "function forceNextEmptyLine(node) {",
                        "  return (",
                        "    isFrontMatterNode(node) ||",
                        "    (node.next &&",
                        "      node.sourceSpan.end &&",
                        "      node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line)",
                        "  );",
                        "}",
                        "",
                        "/** firstChild leadingSpaces and lastChild trailingSpaces */",
                        "function forceBreakContent(node) {",
                        "  return (",
                        "    forceBreakChildren(node) ||",
                        "    (node.type === \"element\" &&",
                        "      node.children.length > 0 &&",
                        "      ([\"body\", \"script\", \"style\"].includes(node.name) ||",
                        "        node.children.some((child) => hasNonTextChild(child)))) ||",
                        "    (node.firstChild &&",
                        "      node.firstChild === node.lastChild &&",
                        "      node.firstChild.type !== \"text\" &&",
                        "      hasLeadingLineBreak(node.firstChild) &&",
                        "      (!node.lastChild.isTrailingSpaceSensitive ||",
                        "        hasTrailingLineBreak(node.lastChild)))",
                        "  );",
                        "}",
                        "",
                        "/** spaces between children */",
                        "function forceBreakChildren(node) {",
                        "  return (",
                        "    node.type === \"element\" &&",
                        "    node.children.length > 0 &&",
                        "    ([\"html\", \"head\", \"ul\", \"ol\", \"select\"].includes(node.name) ||",
                        "      (node.cssDisplay.startsWith(\"table\") && node.cssDisplay !== \"table-cell\"))",
                        "  );",
                        "}",
                        "",
                        "function preferHardlineAsLeadingSpaces(node) {",
                        "  return (",
                        "    preferHardlineAsSurroundingSpaces(node) ||",
                        "    (node.prev && preferHardlineAsTrailingSpaces(node.prev)) ||",
                        "    hasSurroundingLineBreak(node)",
                        "  );",
                        "}",
                        "",
                        "function preferHardlineAsTrailingSpaces(node) {",
                        "  return (",
                        "    preferHardlineAsSurroundingSpaces(node) ||",
                        "    (node.type === \"element\" && node.fullName === \"br\") ||",
                        "    hasSurroundingLineBreak(node)",
                        "  );",
                        "}",
                        "",
                        "function hasSurroundingLineBreak(node) {",
                        "  return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);",
                        "}",
                        "",
                        "function hasLeadingLineBreak(node) {",
                        "  return (",
                        "    node.hasLeadingSpaces &&",
                        "    (node.prev",
                        "      ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line",
                        "      : node.parent.type === \"root\" ||",
                        "        node.parent.startSourceSpan.end.line < node.sourceSpan.start.line)",
                        "  );",
                        "}",
                        "",
                        "function hasTrailingLineBreak(node) {",
                        "  return (",
                        "    node.hasTrailingSpaces &&",
                        "    (node.next",
                        "      ? node.next.sourceSpan.start.line > node.sourceSpan.end.line",
                        "      : node.parent.type === \"root\" ||",
                        "        (node.parent.endSourceSpan &&",
                        "          node.parent.endSourceSpan.start.line > node.sourceSpan.end.line))",
                        "  );",
                        "}",
                        "",
                        "function preferHardlineAsSurroundingSpaces(node) {",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"comment\":",
                        "    case \"directive\":",
                        "      return true;",
                        "    case \"element\":",
                        "      return [\"script\", \"select\"].includes(node.name);",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function getLastDescendant(node) {",
                        "  return node.lastChild ? getLastDescendant(node.lastChild) : node;",
                        "}",
                        "",
                        "function hasNonTextChild(node) {",
                        "  return node.children && node.children.some((child) => child.type !== \"text\");",
                        "}",
                        "",
                        "function _inferScriptParser(node) {",
                        "  const { type, lang } = node.attrMap;",
                        "  if (",
                        "    type === \"module\" ||",
                        "    type === \"text/javascript\" ||",
                        "    type === \"text/babel\" ||",
                        "    type === \"application/javascript\" ||",
                        "    lang === \"jsx\"",
                        "  ) {",
                        "    return \"babel\";",
                        "  }",
                        "",
                        "  if (type === \"application/x-typescript\" || lang === \"ts\" || lang === \"tsx\") {",
                        "    return \"typescript\";",
                        "  }",
                        "",
                        "  if (type === \"text/markdown\") {",
                        "    return \"markdown\";",
                        "  }",
                        "",
                        "  if (type === \"text/html\") {",
                        "    return \"html\";",
                        "  }",
                        "",
                        "  if (",
                        "    (type && (type.endsWith(\"json\") || type.endsWith(\"importmap\"))) ||",
                        "    type === \"speculationrules\"",
                        "  ) {",
                        "    return \"json\";",
                        "  }",
                        "",
                        "  if (type === \"text/x-handlebars-template\") {",
                        "    return \"glimmer\";",
                        "  }",
                        "}",
                        "",
                        "function inferStyleParser(node, options) {",
                        "  const { lang } = node.attrMap;",
                        "  if (!lang || lang === \"postcss\" || lang === \"css\") {",
                        "    return \"css\";",
                        "  }",
                        "",
                        "  if (lang === \"scss\") {",
                        "    return \"scss\";",
                        "  }",
                        "",
                        "  if (lang === \"less\") {",
                        "    return \"less\";",
                        "  }",
                        "",
                        "  // Prettier does not officially support stylus.",
                        "  // But, we need to handle `\"stylus\"` here for printing a style block in Vue SFC as stylus code by external plugin.",
                        "  // https://github.com/prettier/prettier/pull/12707",
                        "  if (lang === \"stylus\") {",
                        "    return inferParserByLanguage(\"stylus\", options);",
                        "  }",
                        "}",
                        "",
                        "function inferScriptParser(node, options) {",
                        "  if (node.name === \"script\" && !node.attrMap.src) {",
                        "    if (!node.attrMap.lang && !node.attrMap.type) {",
                        "      return \"babel\";",
                        "    }",
                        "    return _inferScriptParser(node);",
                        "  }",
                        "",
                        "  if (node.name === \"style\") {",
                        "    return inferStyleParser(node, options);",
                        "  }",
                        "",
                        "  if (options && isVueNonHtmlBlock(node, options)) {",
                        "    return (",
                        "      _inferScriptParser(node) ||",
                        "      (!(\"src\" in node.attrMap) &&",
                        "        inferParserByLanguage(node.attrMap.lang, options))",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "function isBlockLikeCssDisplay(cssDisplay) {",
                        "  return (",
                        "    cssDisplay === \"block\" ||",
                        "    cssDisplay === \"list-item\" ||",
                        "    cssDisplay.startsWith(\"table\")",
                        "  );",
                        "}",
                        "",
                        "function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                        "}",
                        "",
                        "function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                        "}",
                        "",
                        "function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay);",
                        "}",
                        "",
                        "function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay);",
                        "}",
                        "",
                        "function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                        "}",
                        "",
                        "function isPreLikeNode(node) {",
                        "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @param {(any) => boolean} predicate",
                        " */",
                        "function countParents(path, predicate) {",
                        "  let counter = 0;",
                        "  for (let i = path.stack.length - 1; i >= 0; i--) {",
                        "    const value = path.stack[i];",
                        "    if (",
                        "      value &&",
                        "      typeof value === \"object\" &&",
                        "      !Array.isArray(value) &&",
                        "      predicate(value)",
                        "    ) {",
                        "      counter++;",
                        "    }",
                        "  }",
                        "  return counter;",
                        "}",
                        "",
                        "function hasParent(node, fn) {",
                        "  let current = node;",
                        "",
                        "  while (current) {",
                        "    if (fn(current)) {",
                        "      return true;",
                        "    }",
                        "",
                        "    current = current.parent;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function getNodeCssStyleDisplay(node, options) {",
                        "  if (node.prev && node.prev.type === \"comment\") {",
                        "    // <!-- display: block -->",
                        "    const match = node.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);",
                        "    if (match) {",
                        "      return match[1];",
                        "    }",
                        "  }",
                        "",
                        "  let isInSvgForeignObject = false;",
                        "  if (node.type === \"element\" && node.namespace === \"svg\") {",
                        "    if (hasParent(node, (parent) => parent.fullName === \"svg:foreignObject\")) {",
                        "      isInSvgForeignObject = true;",
                        "    } else {",
                        "      return node.name === \"svg\" ? \"inline-block\" : \"block\";",
                        "    }",
                        "  }",
                        "",
                        "  switch (options.htmlWhitespaceSensitivity) {",
                        "    case \"strict\":",
                        "      return \"inline\";",
                        "    case \"ignore\":",
                        "      return \"block\";",
                        "    default: {",
                        "      // See https://github.com/prettier/prettier/issues/8151",
                        "      if (",
                        "        options.parser === \"vue\" &&",
                        "        node.parent &&",
                        "        node.parent.type === \"root\"",
                        "      ) {",
                        "        return \"block\";",
                        "      }",
                        "      return (",
                        "        (node.type === \"element\" &&",
                        "          (!node.namespace ||",
                        "            isInSvgForeignObject ||",
                        "            isUnknownNamespace(node)) &&",
                        "          CSS_DISPLAY_TAGS[node.name]) ||",
                        "        CSS_DISPLAY_DEFAULT",
                        "      );",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "function getNodeCssStyleWhiteSpace(node) {",
                        "  return (",
                        "    (node.type === \"element\" &&",
                        "      (!node.namespace || isUnknownNamespace(node)) &&",
                        "      CSS_WHITE_SPACE_TAGS[node.name]) ||",
                        "    CSS_WHITE_SPACE_DEFAULT",
                        "  );",
                        "}",
                        "",
                        "function getMinIndentation(text) {",
                        "  let minIndentation = Number.POSITIVE_INFINITY;",
                        "",
                        "  for (const lineText of text.split(\"\\n\")) {",
                        "    if (lineText.length === 0) {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (!HTML_WHITESPACE.has(lineText[0])) {",
                        "      return 0;",
                        "    }",
                        "",
                        "    const indentation = getLeadingHtmlWhitespace(lineText).length;",
                        "",
                        "    if (lineText.length === indentation) {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (indentation < minIndentation) {",
                        "      minIndentation = indentation;",
                        "    }",
                        "  }",
                        "",
                        "  return minIndentation === Number.POSITIVE_INFINITY ? 0 : minIndentation;",
                        "}",
                        "",
                        "function dedentString(text, minIndent = getMinIndentation(text)) {",
                        "  return minIndent === 0",
                        "    ? text",
                        "    : text",
                        "        .split(\"\\n\")",
                        "        .map((lineText) => lineText.slice(minIndent))",
                        "        .join(\"\\n\");",
                        "}",
                        "",
                        "function countChars(text, char) {",
                        "  let counter = 0;",
                        "  for (let i = 0; i < text.length; i++) {",
                        "    if (text[i] === char) {",
                        "      counter++;",
                        "    }",
                        "  }",
                        "  return counter;",
                        "}",
                        "",
                        "function unescapeQuoteEntities(text) {",
                        "  return text.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');",
                        "}",
                        "",
                        "// top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block",
                        "// See https://vue-loader.vuejs.org/spec.html for detail",
                        "const vueRootElementsSet = new Set([\"template\", \"style\", \"script\"]);",
                        "function isVueCustomBlock(node, options) {",
                        "  return isVueSfcBlock(node, options) && !vueRootElementsSet.has(node.fullName);",
                        "}",
                        "",
                        "function isVueSfcBlock(node, options) {",
                        "  return (",
                        "    options.parser === \"vue\" &&",
                        "    node.type === \"element\" &&",
                        "    node.parent.type === \"root\" &&",
                        "    node.fullName.toLowerCase() !== \"html\"",
                        "  );",
                        "}",
                        "",
                        "function isVueNonHtmlBlock(node, options) {",
                        "  return (",
                        "    isVueSfcBlock(node, options) &&",
                        "    (isVueCustomBlock(node, options) ||",
                        "      (node.attrMap.lang && node.attrMap.lang !== \"html\"))",
                        "  );",
                        "}",
                        "",
                        "function isVueSlotAttribute(attribute) {",
                        "  const attributeName = attribute.fullName;",
                        "  return (",
                        "    attributeName.charAt(0) === \"#\" ||",
                        "    attributeName === \"slot-scope\" ||",
                        "    attributeName === \"v-slot\" ||",
                        "    attributeName.startsWith(\"v-slot:\")",
                        "  );",
                        "}",
                        "",
                        "function isVueSfcBindingsAttribute(attribute, options) {",
                        "  const element = attribute.parent;",
                        "  if (!isVueSfcBlock(element, options)) {",
                        "    return false;",
                        "  }",
                        "  const tagName = element.fullName;",
                        "  const attributeName = attribute.fullName;",
                        "",
                        "  return (",
                        "    // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-script-setup.md",
                        "    (tagName === \"script\" && attributeName === \"setup\") ||",
                        "    // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-style-variables.md",
                        "    (tagName === \"style\" && attributeName === \"vars\")",
                        "  );",
                        "}",
                        "",
                        "function getTextValueParts(node, value = node.value) {",
                        "  return node.parent.isWhitespaceSensitive",
                        "    ? node.parent.isIndentationSensitive",
                        "      ? replaceTextEndOfLine(value)",
                        "      : replaceTextEndOfLine(",
                        "          dedentString(htmlTrimPreserveIndentation(value)),",
                        "          hardline",
                        "        )",
                        "    : getDocParts(join(line, splitByHtmlWhitespace(value)));",
                        "}",
                        "",
                        "function isVueScriptTag(node, options) {",
                        "  return isVueSfcBlock(node, options) && node.name === \"script\";",
                        "}",
                        "",
                        "module.exports = {",
                        "  htmlTrim,",
                        "  htmlTrimPreserveIndentation,",
                        "  hasHtmlWhitespace,",
                        "  getLeadingAndTrailingHtmlWhitespace,",
                        "  canHaveInterpolation,",
                        "  countChars,",
                        "  countParents,",
                        "  dedentString,",
                        "  forceBreakChildren,",
                        "  forceBreakContent,",
                        "  forceNextEmptyLine,",
                        "  getLastDescendant,",
                        "  getNodeCssStyleDisplay,",
                        "  getNodeCssStyleWhiteSpace,",
                        "  hasPrettierIgnore,",
                        "  inferScriptParser,",
                        "  isVueCustomBlock,",
                        "  isVueNonHtmlBlock,",
                        "  isVueScriptTag,",
                        "  isVueSlotAttribute,",
                        "  isVueSfcBindingsAttribute,",
                        "  isVueSfcBlock,",
                        "  isDanglingSpaceSensitiveNode,",
                        "  isIndentationSensitiveNode,",
                        "  isLeadingSpaceSensitiveNode,",
                        "  isPreLikeNode,",
                        "  isScriptLikeTag,",
                        "  isTextLikeNode,",
                        "  isTrailingSpaceSensitiveNode,",
                        "  isWhitespaceSensitiveNode,",
                        "  isUnknownNamespace,",
                        "  preferHardlineAsLeadingSpaces,",
                        "  preferHardlineAsTrailingSpaces,",
                        "  shouldPreserveContent,",
                        "  unescapeQuoteEntities,",
                        "  getTextValueParts,",
                        "};"
                    ]
                },
                "is-unknown-namespace.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function isUnknownNamespace(node) {",
                        "  return (",
                        "    node.type === \"element\" &&",
                        "    !node.hasExplicitNamespace &&",
                        "    ![\"html\", \"svg\"].includes(node.namespace)",
                        "  );",
                        "}",
                        "",
                        "module.exports = isUnknownNamespace;"
                    ]
                },
                "map-object.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function mapObject(object, fn) {",
                        "  const newObject = Object.create(null);",
                        "  for (const [key, value] of Object.entries(object)) {",
                        "    newObject[key] = fn(value, key);",
                        "  }",
                        "  return newObject;",
                        "}",
                        "",
                        "module.exports = mapObject;"
                    ]
                }
            }
        },
        "language-js": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const isBlockComment = require(\"./utils/is-block-comment.js\");",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"range\",",
                    "  \"raw\",",
                    "  \"comments\",",
                    "  \"leadingComments\",",
                    "  \"trailingComments\",",
                    "  \"innerComments\",",
                    "  \"extra\",",
                    "  \"start\",",
                    "  \"end\",",
                    "  \"loc\",",
                    "  \"flags\",",
                    "  \"errors\",",
                    "  \"tokens\",",
                    "]);",
                    "",
                    "const removeTemplateElementsValue = (node) => {",
                    "  for (const templateElement of node.quasis) {",
                    "    delete templateElement.value;",
                    "  }",
                    "};",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  if (ast.type === \"Program\") {",
                    "    delete newObj.sourceType;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"BigIntLiteral\" ||",
                    "    ast.type === \"BigIntLiteralTypeAnnotation\"",
                    "  ) {",
                    "    if (newObj.value) {",
                    "      newObj.value = newObj.value.toLowerCase();",
                    "    }",
                    "  }",
                    "  if (ast.type === \"BigIntLiteral\" || ast.type === \"Literal\") {",
                    "    if (newObj.bigint) {",
                    "      newObj.bigint = newObj.bigint.toLowerCase();",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"DecimalLiteral\") {",
                    "    newObj.value = Number(newObj.value);",
                    "  }",
                    "  if (ast.type === \"Literal\" && newObj.decimal) {",
                    "    newObj.decimal = Number(newObj.decimal);",
                    "  }",
                    "",
                    "  // We remove extra `;` and add them when needed",
                    "  if (ast.type === \"EmptyStatement\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We move text around, including whitespaces and add {\" \"}",
                    "  if (ast.type === \"JSXText\") {",
                    "    return null;",
                    "  }",
                    "  if (",
                    "    ast.type === \"JSXExpressionContainer\" &&",
                    "    (ast.expression.type === \"Literal\" ||",
                    "      ast.expression.type === \"StringLiteral\") &&",
                    "    ast.expression.value === \" \"",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We change {'key': value} into {key: value}.",
                    "  // And {key: value} into {'key': value}.",
                    "  // Also for (some) number keys.",
                    "  if (",
                    "    (ast.type === \"Property\" ||",
                    "      ast.type === \"ObjectProperty\" ||",
                    "      ast.type === \"MethodDefinition\" ||",
                    "      ast.type === \"ClassProperty\" ||",
                    "      ast.type === \"ClassMethod\" ||",
                    "      ast.type === \"PropertyDefinition\" ||",
                    "      ast.type === \"TSDeclareMethod\" ||",
                    "      ast.type === \"TSPropertySignature\" ||",
                    "      ast.type === \"ObjectTypeProperty\") &&",
                    "    typeof ast.key === \"object\" &&",
                    "    ast.key &&",
                    "    (ast.key.type === \"Literal\" ||",
                    "      ast.key.type === \"NumericLiteral\" ||",
                    "      ast.key.type === \"StringLiteral\" ||",
                    "      ast.key.type === \"Identifier\")",
                    "  ) {",
                    "    delete newObj.key;",
                    "  }",
                    "",
                    "  // Remove raw and cooked values from TemplateElement when it's CSS",
                    "  // styled-jsx",
                    "  if (",
                    "    ast.type === \"JSXElement\" &&",
                    "    ast.openingElement.name.name === \"style\" &&",
                    "    ast.openingElement.attributes.some((attr) => attr.name.name === \"jsx\")",
                    "  ) {",
                    "    for (const { type, expression } of newObj.children) {",
                    "      if (",
                    "        type === \"JSXExpressionContainer\" &&",
                    "        expression.type === \"TemplateLiteral\"",
                    "      ) {",
                    "        removeTemplateElementsValue(expression);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  // CSS template literals in css prop",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.name.name === \"css\" &&",
                    "    ast.value.type === \"JSXExpressionContainer\" &&",
                    "    ast.value.expression.type === \"TemplateLiteral\"",
                    "  ) {",
                    "    removeTemplateElementsValue(newObj.value.expression);",
                    "  }",
                    "",
                    "  // We change quotes",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.value &&",
                    "    ast.value.type === \"Literal\" &&",
                    "    /[\"']|&quot;|&apos;/.test(ast.value.value)",
                    "  ) {",
                    "    newObj.value.value = newObj.value.value.replace(/[\"']|&quot;|&apos;/g, '\"');",
                    "  }",
                    "",
                    "  // Angular Components: Inline HTML template and Inline CSS styles",
                    "  const expression = ast.expression || ast.callee;",
                    "  if (",
                    "    ast.type === \"Decorator\" &&",
                    "    expression.type === \"CallExpression\" &&",
                    "    expression.callee.name === \"Component\" &&",
                    "    expression.arguments.length === 1",
                    "  ) {",
                    "    const astProps = ast.expression.arguments[0].properties;",
                    "    for (const [",
                    "      index,",
                    "      prop,",
                    "    ] of newObj.expression.arguments[0].properties.entries()) {",
                    "      switch (astProps[index].key.name) {",
                    "        case \"styles\":",
                    "          if (prop.value.type === \"ArrayExpression\") {",
                    "            removeTemplateElementsValue(prop.value.elements[0]);",
                    "          }",
                    "          break;",
                    "        case \"template\":",
                    "          if (prop.value.type === \"TemplateLiteral\") {",
                    "            removeTemplateElementsValue(prop.value);",
                    "          }",
                    "          break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  // styled-components, graphql, markdown",
                    "  if (",
                    "    ast.type === \"TaggedTemplateExpression\" &&",
                    "    (ast.tag.type === \"MemberExpression\" ||",
                    "      (ast.tag.type === \"Identifier\" &&",
                    "        (ast.tag.name === \"gql\" ||",
                    "          ast.tag.name === \"graphql\" ||",
                    "          ast.tag.name === \"css\" ||",
                    "          ast.tag.name === \"md\" ||",
                    "          ast.tag.name === \"markdown\" ||",
                    "          ast.tag.name === \"html\")) ||",
                    "      ast.tag.type === \"CallExpression\")",
                    "  ) {",
                    "    removeTemplateElementsValue(newObj.quasi);",
                    "  }",
                    "  if (ast.type === \"TemplateLiteral\") {",
                    "    // This checks for a leading comment that is exactly `/* GraphQL */`",
                    "    // In order to be in line with other implementations of this comment tag",
                    "    // we will not trim the comment value and we will expect exactly one space on",
                    "    // either side of the GraphQL string",
                    "    // Also see ./embed.js",
                    "    const hasLanguageComment = ast.leadingComments?.some(",
                    "      (comment) =>",
                    "        isBlockComment(comment) &&",
                    "        [\"GraphQL\", \"HTML\"].some(",
                    "          (languageName) => comment.value === ` ${languageName} `",
                    "        )",
                    "    );",
                    "    if (",
                    "      hasLanguageComment ||",
                    "      (parent.type === \"CallExpression\" && parent.callee.name === \"graphql\") ||",
                    "      // TODO: check parser",
                    "      // `flow` and `typescript` don't have `leadingComments`",
                    "      !ast.leadingComments",
                    "    ) {",
                    "      removeTemplateElementsValue(newObj);",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"InterpreterDirective\") {",
                    "    newObj.value = newObj.value.trimEnd();",
                    "  }",
                    "",
                    "  // Prettier removes degenerate union and intersection types with only one member.",
                    "  if (",
                    "    (ast.type === \"TSIntersectionType\" || ast.type === \"TSUnionType\") &&",
                    "    ast.types.length === 1",
                    "  ) {",
                    "    return newObj.types[0];",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "module.exports = clean;"
                ]
            },
            "comments.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  getLast,",
                    "  hasNewline,",
                    "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                    "  getNextNonSpaceNonCommentCharacter,",
                    "  hasNewlineInRange,",
                    "  addLeadingComment,",
                    "  addTrailingComment,",
                    "  addDanglingComment,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  isNonEmptyArray,",
                    "} = require(\"../common/util.js\");",
                    "const {",
                    "  getFunctionParameters,",
                    "  isPrettierIgnoreComment,",
                    "  isJsxNode,",
                    "  hasFlowShorthandAnnotationComment,",
                    "  hasFlowAnnotationComment,",
                    "  hasIgnoreComment,",
                    "  isCallLikeExpression,",
                    "  getCallArguments,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  isObjectProperty,",
                    "  isLineComment,",
                    "  getComments,",
                    "  CommentCheckFlags,",
                    "  markerForIfWithoutBlockAndSameLineComment,",
                    "} = require(\"./utils/index.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const isBlockComment = require(\"./utils/is-block-comment.js\");",
                    "",
                    "/**",
                    " * @typedef {import(\"./types/estree\").Node} Node",
                    " * @typedef {import(\"./types/estree\").Comment} Comment",
                    " * @typedef {import(\"../common/ast-path\")} AstPath",
                    " *",
                    " * @typedef {Object} CommentContext",
                    " * @property {Comment} comment",
                    " * @property {Node} precedingNode",
                    " * @property {Node} enclosingNode",
                    " * @property {Node} followingNode",
                    " * @property {string} text",
                    " * @property {any} options",
                    " * @property {Node} ast",
                    " * @property {boolean} isLastComment",
                    " */",
                    "",
                    "/**",
                    " * @param {CommentContext} context",
                    " * @returns {boolean}",
                    " */",
                    "function handleOwnLineComment(context) {",
                    "  return [",
                    "    handleIgnoreComments,",
                    "    handleLastFunctionArgComments,",
                    "    handleMemberExpressionComments,",
                    "    handleIfStatementComments,",
                    "    handleWhileComments,",
                    "    handleTryStatementComments,",
                    "    handleClassComments,",
                    "    handleForComments,",
                    "    handleUnionTypeComments,",
                    "    handleOnlyComments,",
                    "    handleModuleSpecifiersComments,",
                    "    handleAssignmentPatternComments,",
                    "    handleMethodNameComments,",
                    "    handleLabeledStatementComments,",
                    "    handleBreakAndContinueStatementComments,",
                    "  ].some((fn) => fn(context));",
                    "}",
                    "",
                    "/**",
                    " * @param {CommentContext} context",
                    " * @returns {boolean}",
                    " */",
                    "function handleEndOfLineComment(context) {",
                    "  return [",
                    "    handleClosureTypeCastComments,",
                    "    handleLastFunctionArgComments,",
                    "    handleConditionalExpressionComments,",
                    "    handleModuleSpecifiersComments,",
                    "    handleIfStatementComments,",
                    "    handleWhileComments,",
                    "    handleTryStatementComments,",
                    "    handleClassComments,",
                    "    handleLabeledStatementComments,",
                    "    handleCallExpressionComments,",
                    "    handlePropertyComments,",
                    "    handleOnlyComments,",
                    "    handleVariableDeclaratorComments,",
                    "    handleBreakAndContinueStatementComments,",
                    "    handleSwitchDefaultCaseComments,",
                    "  ].some((fn) => fn(context));",
                    "}",
                    "",
                    "/**",
                    " * @param {CommentContext} context",
                    " * @returns {boolean}",
                    " */",
                    "function handleRemainingComment(context) {",
                    "  return [",
                    "    handleIgnoreComments,",
                    "    handleIfStatementComments,",
                    "    handleWhileComments,",
                    "    handleObjectPropertyAssignment,",
                    "    handleCommentInEmptyParens,",
                    "    handleMethodNameComments,",
                    "    handleOnlyComments,",
                    "    handleCommentAfterArrowParams,",
                    "    handleFunctionNameComments,",
                    "    handleTSMappedTypeComments,",
                    "    handleBreakAndContinueStatementComments,",
                    "    handleTSFunctionTrailingComments,",
                    "  ].some((fn) => fn(context));",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @returns {void}",
                    " */",
                    "function addBlockStatementFirstComment(node, comment) {",
                    "  // @ts-expect-error",
                    "  const firstNonEmptyNode = (node.body || node.properties).find(",
                    "    ({ type }) => type !== \"EmptyStatement\"",
                    "  );",
                    "  if (firstNonEmptyNode) {",
                    "    addLeadingComment(firstNonEmptyNode, comment);",
                    "  } else {",
                    "    addDanglingComment(node, comment);",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @returns {void}",
                    " */",
                    "function addBlockOrNotComment(node, comment) {",
                    "  if (node.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(node, comment);",
                    "  } else {",
                    "    addLeadingComment(node, comment);",
                    "  }",
                    "}",
                    "",
                    "function handleClosureTypeCastComments({ comment, followingNode }) {",
                    "  if (followingNode && isTypeCastComment(comment)) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "// There are often comments before the else clause of if statements like",
                    "//",
                    "//   if (1) { ... }",
                    "//   // comment",
                    "//   else { ... }",
                    "//",
                    "// They are being attached as leading comments of the BlockExpression which",
                    "// is not well printed. What we want is to instead move the comment inside",
                    "// of the block and make it leadingComment of the first element of the block",
                    "// or dangling comment of the block if there is nothing inside",
                    "//",
                    "//   if (1) { ... }",
                    "//   else {",
                    "//     // comment",
                    "//     ...",
                    "//   }",
                    "function handleIfStatementComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  if (enclosingNode?.type !== \"IfStatement\" || !followingNode) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // We unfortunately have no way using the AST or location of nodes to know",
                    "  // if the comment is positioned before the condition parenthesis:",
                    "  //   if (a /* comment */) {}",
                    "  // The only workaround I found is to look at the next character to see if",
                    "  // it is a ).",
                    "  const nextCharacter = getNextNonSpaceNonCommentCharacter(",
                    "    text,",
                    "    comment,",
                    "    locEnd",
                    "  );",
                    "  if (nextCharacter === \")\") {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Comments before `else`:",
                    "  // - treat as trailing comments of the consequent, if it's a BlockStatement",
                    "  // - treat as a dangling comment otherwise",
                    "  if (",
                    "    precedingNode === enclosingNode.consequent &&",
                    "    followingNode === enclosingNode.alternate",
                    "  ) {",
                    "    if (precedingNode.type === \"BlockStatement\") {",
                    "      addTrailingComment(precedingNode, comment);",
                    "    } else {",
                    "      const isSingleLineComment =",
                    "        comment.type === \"SingleLine\" ||",
                    "        comment.loc.start.line === comment.loc.end.line;",
                    "      const isSameLineComment =",
                    "        comment.loc.start.line === precedingNode.loc.start.line;",
                    "      if (isSingleLineComment && isSameLineComment) {",
                    "        // example:",
                    "        //   if (cond1) expr1; // comment A",
                    "        //   else if (cond2) expr2; // comment A",
                    "        //   else expr3;",
                    "        addDanglingComment(",
                    "          precedingNode,",
                    "          comment,",
                    "          markerForIfWithoutBlockAndSameLineComment",
                    "        );",
                    "      } else {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      }",
                    "    }",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"IfStatement\") {",
                    "    addBlockOrNotComment(followingNode.consequent, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // For comments positioned after the condition parenthesis in an if statement",
                    "  // before the consequent without brackets on, such as",
                    "  // if (a) /* comment */ true,",
                    "  // we look at the next character to see if the following node",
                    "  // is the consequent for the if statement",
                    "  if (enclosingNode.consequent === followingNode) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleWhileComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  if (enclosingNode?.type !== \"WhileStatement\" || !followingNode) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // We unfortunately have no way using the AST or location of nodes to know",
                    "  // if the comment is positioned before the condition parenthesis:",
                    "  //   while (a /* comment */) {}",
                    "  // The only workaround I found is to look at the next character to see if",
                    "  // it is a ).",
                    "  const nextCharacter = getNextNonSpaceNonCommentCharacter(",
                    "    text,",
                    "    comment,",
                    "    locEnd",
                    "  );",
                    "  if (nextCharacter === \")\") {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (enclosingNode.body === followingNode) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "// Same as IfStatement but for TryStatement",
                    "function handleTryStatementComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    (enclosingNode?.type !== \"TryStatement\" &&",
                    "      enclosingNode?.type !== \"CatchClause\") ||",
                    "    !followingNode",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (enclosingNode.type === \"CatchClause\" && precedingNode) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"TryStatement\") {",
                    "    addBlockOrNotComment(followingNode.finalizer, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"CatchClause\") {",
                    "    addBlockOrNotComment(followingNode.body, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleMemberExpressionComments({",
                    "  comment,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    isMemberExpression(enclosingNode) &&",
                    "    followingNode?.type === \"Identifier\"",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleConditionalExpressionComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  const isSameLineAsPrecedingNode =",
                    "    precedingNode &&",
                    "    !hasNewlineInRange(text, locEnd(precedingNode), locStart(comment));",
                    "",
                    "  if (",
                    "    (!precedingNode || !isSameLineAsPrecedingNode) &&",
                    "    (enclosingNode?.type === \"ConditionalExpression\" ||",
                    "      enclosingNode?.type === \"TSConditionalType\") &&",
                    "    followingNode",
                    "  ) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleObjectPropertyAssignment({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "}) {",
                    "  if (",
                    "    isObjectProperty(enclosingNode) &&",
                    "    enclosingNode.shorthand &&",
                    "    enclosingNode.key === precedingNode &&",
                    "    enclosingNode.value.type === \"AssignmentPattern\"",
                    "  ) {",
                    "    addTrailingComment(enclosingNode.value.left, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "const classLikeNodeTypes = new Set([",
                    "  \"ClassDeclaration\",",
                    "  \"ClassExpression\",",
                    "  \"DeclareClass\",",
                    "  \"DeclareInterface\",",
                    "  \"InterfaceDeclaration\",",
                    "  \"TSInterfaceDeclaration\",",
                    "]);",
                    "function handleClassComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (classLikeNodeTypes.has(enclosingNode?.type)) {",
                    "    if (",
                    "      isNonEmptyArray(enclosingNode.decorators) &&",
                    "      !(followingNode && followingNode.type === \"Decorator\")",
                    "    ) {",
                    "      addTrailingComment(getLast(enclosingNode.decorators), comment);",
                    "      return true;",
                    "    }",
                    "",
                    "    if (enclosingNode.body && followingNode === enclosingNode.body) {",
                    "      addBlockStatementFirstComment(enclosingNode.body, comment);",
                    "      return true;",
                    "    }",
                    "",
                    "    // Don't add leading comments to `implements`, `extends`, `mixins` to",
                    "    // avoid printing the comment after the keyword.",
                    "    if (followingNode) {",
                    "      if (",
                    "        enclosingNode.superClass &&",
                    "        followingNode === enclosingNode.superClass &&",
                    "        precedingNode &&",
                    "        (precedingNode === enclosingNode.id ||",
                    "          precedingNode === enclosingNode.typeParameters)",
                    "      ) {",
                    "        addTrailingComment(precedingNode, comment);",
                    "        return true;",
                    "      }",
                    "",
                    "      for (const prop of [\"implements\", \"extends\", \"mixins\"]) {",
                    "        if (enclosingNode[prop] && followingNode === enclosingNode[prop][0]) {",
                    "          if (",
                    "            precedingNode &&",
                    "            (precedingNode === enclosingNode.id ||",
                    "              precedingNode === enclosingNode.typeParameters ||",
                    "              precedingNode === enclosingNode.superClass)",
                    "          ) {",
                    "            addTrailingComment(precedingNode, comment);",
                    "          } else {",
                    "            addDanglingComment(enclosingNode, comment, prop);",
                    "          }",
                    "          return true;",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "const propertyLikeNodeTypes = new Set([",
                    "  \"ClassMethod\",",
                    "  \"ClassProperty\",",
                    "  \"PropertyDefinition\",",
                    "  \"TSAbstractPropertyDefinition\",",
                    "  \"TSAbstractMethodDefinition\",",
                    "  \"TSDeclareMethod\",",
                    "  \"MethodDefinition\",",
                    "  \"ClassAccessorProperty\",",
                    "  \"AccessorProperty\",",
                    "  \"TSAbstractAccessorProperty\",",
                    "]);",
                    "function handleMethodNameComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  text,",
                    "}) {",
                    "  // This is only needed for estree parsers (flow, typescript) to attach",
                    "  // after a method name:",
                    "  // obj = { fn /*comment*/() {} };",
                    "  if (",
                    "    enclosingNode &&",
                    "    precedingNode &&",
                    "    getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === \"(\" &&",
                    "    // \"MethodDefinition\" is handled in getCommentChildNodes",
                    "    (enclosingNode.type === \"Property\" ||",
                    "      enclosingNode.type === \"TSDeclareMethod\" ||",
                    "      enclosingNode.type === \"TSAbstractMethodDefinition\") &&",
                    "    precedingNode.type === \"Identifier\" &&",
                    "    enclosingNode.key === precedingNode &&",
                    "    // special Property case: { key: /*comment*/(value) };",
                    "    // comment should be attached to value instead of key",
                    "    getNextNonSpaceNonCommentCharacter(text, precedingNode, locEnd) !== \":\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Print comments between decorators and class methods as a trailing comment",
                    "  // on the decorator node instead of the method node",
                    "  if (",
                    "    precedingNode?.type === \"Decorator\" &&",
                    "    propertyLikeNodeTypes.has(enclosingNode?.type)",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "const functionLikeNodeTypes = new Set([",
                    "  \"FunctionDeclaration\",",
                    "  \"FunctionExpression\",",
                    "  \"ClassMethod\",",
                    "  \"MethodDefinition\",",
                    "  \"ObjectMethod\",",
                    "]);",
                    "function handleFunctionNameComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  text,",
                    "}) {",
                    "  if (getNextNonSpaceNonCommentCharacter(text, comment, locEnd) !== \"(\") {",
                    "    return false;",
                    "  }",
                    "  if (precedingNode && functionLikeNodeTypes.has(enclosingNode?.type)) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleCommentAfterArrowParams({ comment, enclosingNode, text }) {",
                    "  if (!(enclosingNode?.type === \"ArrowFunctionExpression\")) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const index = getNextNonSpaceNonCommentCharacterIndex(text, comment, locEnd);",
                    "  if (index !== false && text.slice(index, index + 2) === \"=>\") {",
                    "    addDanglingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleCommentInEmptyParens({ comment, enclosingNode, text }) {",
                    "  if (getNextNonSpaceNonCommentCharacter(text, comment, locEnd) !== \")\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Only add dangling comments to fix the case when no params are present,",
                    "  // i.e. a function without any argument.",
                    "  if (",
                    "    enclosingNode &&",
                    "    ((isRealFunctionLikeNode(enclosingNode) &&",
                    "      getFunctionParameters(enclosingNode).length === 0) ||",
                    "      (isCallLikeExpression(enclosingNode) &&",
                    "        getCallArguments(enclosingNode).length === 0))",
                    "  ) {",
                    "    addDanglingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  if (",
                    "    (enclosingNode?.type === \"MethodDefinition\" ||",
                    "      enclosingNode?.type === \"TSAbstractMethodDefinition\") &&",
                    "    getFunctionParameters(enclosingNode.value).length === 0",
                    "  ) {",
                    "    addDanglingComment(enclosingNode.value, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleLastFunctionArgComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  // Flow function type definitions",
                    "  if (",
                    "    precedingNode?.type === \"FunctionTypeParam\" &&",
                    "    enclosingNode?.type === \"FunctionTypeAnnotation\" &&",
                    "    followingNode?.type !== \"FunctionTypeParam\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Real functions and TypeScript function type definitions",
                    "  if (",
                    "    (precedingNode?.type === \"Identifier\" ||",
                    "      precedingNode?.type === \"AssignmentPattern\") &&",
                    "    enclosingNode &&",
                    "    isRealFunctionLikeNode(enclosingNode) &&",
                    "    getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === \")\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    enclosingNode?.type === \"FunctionDeclaration\" &&",
                    "    followingNode?.type === \"BlockStatement\"",
                    "  ) {",
                    "    const functionParamRightParenIndex = (() => {",
                    "      const parameters = getFunctionParameters(enclosingNode);",
                    "      if (parameters.length > 0) {",
                    "        return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "          text,",
                    "          locEnd(getLast(parameters))",
                    "        );",
                    "      }",
                    "      const functionParamLeftParenIndex =",
                    "        getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "          text,",
                    "          locEnd(enclosingNode.id)",
                    "        );",
                    "      return (",
                    "        functionParamLeftParenIndex !== false &&",
                    "        getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "          text,",
                    "          functionParamLeftParenIndex + 1",
                    "        )",
                    "      );",
                    "    })();",
                    "    if (locStart(comment) > functionParamRightParenIndex) {",
                    "      addBlockStatementFirstComment(followingNode, comment);",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleLabeledStatementComments({ comment, enclosingNode }) {",
                    "  if (enclosingNode?.type === \"LabeledStatement\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleBreakAndContinueStatementComments({ comment, enclosingNode }) {",
                    "  if (",
                    "    (enclosingNode?.type === \"ContinueStatement\" ||",
                    "      enclosingNode?.type === \"BreakStatement\") &&",
                    "    !enclosingNode.label",
                    "  ) {",
                    "    addTrailingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleCallExpressionComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "}) {",
                    "  if (",
                    "    isCallExpression(enclosingNode) &&",
                    "    precedingNode &&",
                    "    enclosingNode.callee === precedingNode &&",
                    "    enclosingNode.arguments.length > 0",
                    "  ) {",
                    "    addLeadingComment(enclosingNode.arguments[0], comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleUnionTypeComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    enclosingNode?.type === \"UnionTypeAnnotation\" ||",
                    "    enclosingNode?.type === \"TSUnionType\"",
                    "  ) {",
                    "    if (isPrettierIgnoreComment(comment)) {",
                    "      followingNode.prettierIgnore = true;",
                    "      comment.unignore = true;",
                    "    }",
                    "    if (precedingNode) {",
                    "      addTrailingComment(precedingNode, comment);",
                    "      return true;",
                    "    }",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    (followingNode?.type === \"UnionTypeAnnotation\" ||",
                    "      followingNode?.type === \"TSUnionType\") &&",
                    "    isPrettierIgnoreComment(comment)",
                    "  ) {",
                    "    followingNode.types[0].prettierIgnore = true;",
                    "    comment.unignore = true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handlePropertyComments({ comment, enclosingNode }) {",
                    "  if (isObjectProperty(enclosingNode)) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleOnlyComments({",
                    "  comment,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  ast,",
                    "  isLastComment,",
                    "}) {",
                    "  // With Flow the enclosingNode is undefined so use the AST instead.",
                    "  if (ast && ast.body && ast.body.length === 0) {",
                    "    if (isLastComment) {",
                    "      addDanglingComment(ast, comment);",
                    "    } else {",
                    "      addLeadingComment(ast, comment);",
                    "    }",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    enclosingNode?.type === \"Program\" &&",
                    "    enclosingNode?.body.length === 0 &&",
                    "    !isNonEmptyArray(enclosingNode.directives)",
                    "  ) {",
                    "    if (isLastComment) {",
                    "      addDanglingComment(enclosingNode, comment);",
                    "    } else {",
                    "      addLeadingComment(enclosingNode, comment);",
                    "    }",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    followingNode?.type === \"Program\" &&",
                    "    followingNode?.body.length === 0 &&",
                    "    enclosingNode?.type === \"ModuleExpression\"",
                    "  ) {",
                    "    addDanglingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleForComments({ comment, enclosingNode }) {",
                    "  if (",
                    "    enclosingNode?.type === \"ForInStatement\" ||",
                    "    enclosingNode?.type === \"ForOfStatement\"",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleModuleSpecifiersComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  text,",
                    "}) {",
                    "  if (",
                    "    enclosingNode?.type === \"ImportSpecifier\" ||",
                    "    enclosingNode?.type === \"ExportSpecifier\"",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  const isImportDeclaration =",
                    "    precedingNode?.type === \"ImportSpecifier\" &&",
                    "    enclosingNode?.type === \"ImportDeclaration\";",
                    "  const isExportDeclaration =",
                    "    precedingNode?.type === \"ExportSpecifier\" &&",
                    "    enclosingNode?.type === \"ExportNamedDeclaration\";",
                    "  if (",
                    "    (isImportDeclaration || isExportDeclaration) &&",
                    "    hasNewline(text, locEnd(comment))",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleAssignmentPatternComments({ comment, enclosingNode }) {",
                    "  if (enclosingNode?.type === \"AssignmentPattern\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "const assignmentLikeNodeTypes = new Set([",
                    "  \"VariableDeclarator\",",
                    "  \"AssignmentExpression\",",
                    "  \"TypeAlias\",",
                    "  \"TSTypeAliasDeclaration\",",
                    "]);",
                    "const complexExprNodeTypes = new Set([",
                    "  \"ObjectExpression\",",
                    "  \"ArrayExpression\",",
                    "  \"TemplateLiteral\",",
                    "  \"TaggedTemplateExpression\",",
                    "  \"ObjectTypeAnnotation\",",
                    "  \"TSTypeLiteral\",",
                    "]);",
                    "function handleVariableDeclaratorComments({",
                    "  comment,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    assignmentLikeNodeTypes.has(enclosingNode?.type) &&",
                    "    followingNode &&",
                    "    (complexExprNodeTypes.has(followingNode.type) || isBlockComment(comment))",
                    "  ) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleTSFunctionTrailingComments({",
                    "  comment,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  if (",
                    "    !followingNode &&",
                    "    (enclosingNode?.type === \"TSMethodSignature\" ||",
                    "      enclosingNode?.type === \"TSDeclareFunction\" ||",
                    "      enclosingNode?.type === \"TSAbstractMethodDefinition\") &&",
                    "    getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === \";\"",
                    "  ) {",
                    "    addTrailingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleIgnoreComments({ comment, enclosingNode, followingNode }) {",
                    "  if (",
                    "    isPrettierIgnoreComment(comment) &&",
                    "    enclosingNode?.type === \"TSMappedType\" &&",
                    "    followingNode?.type === \"TSTypeParameter\" &&",
                    "    followingNode.constraint",
                    "  ) {",
                    "    enclosingNode.prettierIgnore = true;",
                    "    comment.unignore = true;",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function handleTSMappedTypeComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (enclosingNode?.type !== \"TSMappedType\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (followingNode?.type === \"TSTypeParameter\" && followingNode.name) {",
                    "    addLeadingComment(followingNode.name, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (precedingNode?.type === \"TSTypeParameter\" && precedingNode.constraint) {",
                    "    addTrailingComment(precedingNode.constraint, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleSwitchDefaultCaseComments({",
                    "  comment,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    !enclosingNode ||",
                    "    enclosingNode.type !== \"SwitchCase\" ||",
                    "    enclosingNode.test ||",
                    "    !followingNode ||",
                    "    followingNode !== enclosingNode.consequent[0]",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\" && isLineComment(comment)) {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "  } else {",
                    "    addDanglingComment(enclosingNode, comment);",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @returns {boolean}",
                    " */",
                    "function isRealFunctionLikeNode(node) {",
                    "  return (",
                    "    node.type === \"ArrowFunctionExpression\" ||",
                    "    node.type === \"FunctionExpression\" ||",
                    "    node.type === \"FunctionDeclaration\" ||",
                    "    node.type === \"ObjectMethod\" ||",
                    "    node.type === \"ClassMethod\" ||",
                    "    node.type === \"TSDeclareFunction\" ||",
                    "    node.type === \"TSCallSignatureDeclaration\" ||",
                    "    node.type === \"TSConstructSignatureDeclaration\" ||",
                    "    node.type === \"TSMethodSignature\" ||",
                    "    node.type === \"TSConstructorType\" ||",
                    "    node.type === \"TSFunctionType\" ||",
                    "    node.type === \"TSDeclareMethod\"",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {any} node",
                    " * @returns {Node[] | void}",
                    " */",
                    "function getCommentChildNodes(node, options) {",
                    "  // Prevent attaching comments to FunctionExpression in this case:",
                    "  //     class Foo {",
                    "  //       bar() // comment",
                    "  //       {",
                    "  //         baz();",
                    "  //       }",
                    "  //     }",
                    "  if (",
                    "    (options.parser === \"typescript\" ||",
                    "      options.parser === \"flow\" ||",
                    "      options.parser === \"acorn\" ||",
                    "      options.parser === \"espree\" ||",
                    "      options.parser === \"meriyah\" ||",
                    "      options.parser === \"__babel_estree\") &&",
                    "    node.type === \"MethodDefinition\" &&",
                    "    node.value &&",
                    "    node.value.type === \"FunctionExpression\" &&",
                    "    getFunctionParameters(node.value).length === 0 &&",
                    "    !node.value.returnType &&",
                    "    !isNonEmptyArray(node.value.typeParameters) &&",
                    "    node.value.body",
                    "  ) {",
                    "    return [...(node.decorators || []), node.key, node.value.body];",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Comment} comment",
                    " * @returns {boolean}",
                    " */",
                    "function isTypeCastComment(comment) {",
                    "  return (",
                    "    isBlockComment(comment) &&",
                    "    comment.value[0] === \"*\" &&",
                    "    // TypeScript expects the type to be enclosed in curly brackets, however",
                    "    // Closure Compiler accepts types in parens and even without any delimiters at all.",
                    "    // That's why we just search for \"@type\".",
                    "    /@type\\b/.test(comment.value)",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {AstPath} path",
                    " * @returns {boolean}",
                    " */",
                    "function willPrintOwnComments(path /*, options */) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  const hasFlowAnnotations = (node) =>",
                    "    hasFlowAnnotationComment(getComments(node, CommentCheckFlags.Leading)) ||",
                    "    hasFlowAnnotationComment(getComments(node, CommentCheckFlags.Trailing));",
                    "",
                    "  return (",
                    "    ((node &&",
                    "      (isJsxNode(node) ||",
                    "        hasFlowShorthandAnnotationComment(node) ||",
                    "        (isCallExpression(parent) && hasFlowAnnotations(node)))) ||",
                    "      (parent &&",
                    "        (parent.type === \"JSXSpreadAttribute\" ||",
                    "          parent.type === \"JSXSpreadChild\" ||",
                    "          parent.type === \"UnionTypeAnnotation\" ||",
                    "          parent.type === \"TSUnionType\" ||",
                    "          ((parent.type === \"ClassDeclaration\" ||",
                    "            parent.type === \"ClassExpression\") &&",
                    "            parent.superClass === node)))) &&",
                    "    (!hasIgnoreComment(path) ||",
                    "      parent.type === \"UnionTypeAnnotation\" ||",
                    "      parent.type === \"TSUnionType\")",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  handleOwnLineComment,",
                    "  handleEndOfLineComment,",
                    "  handleRemainingComment,",
                    "  isTypeCastComment,",
                    "  getCommentChildNodes,",
                    "  willPrintOwnComments,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  hasComment,",
                    "  CommentCheckFlags,",
                    "  isObjectProperty,",
                    "} = require(\"./utils/index.js\");",
                    "const formatMarkdown = require(\"./embed/markdown.js\");",
                    "const formatCss = require(\"./embed/css.js\");",
                    "const formatGraphql = require(\"./embed/graphql.js\");",
                    "const formatHtml = require(\"./embed/html.js\");",
                    "",
                    "function getLanguage(path) {",
                    "  if (",
                    "    isStyledJsx(path) ||",
                    "    isStyledComponents(path) ||",
                    "    isCssProp(path) ||",
                    "    isAngularComponentStyles(path)",
                    "  ) {",
                    "    return \"css\";",
                    "  }",
                    "",
                    "  if (isGraphQL(path)) {",
                    "    return \"graphql\";",
                    "  }",
                    "",
                    "  if (isHtml(path)) {",
                    "    return \"html\";",
                    "  }",
                    "",
                    "  if (isAngularComponentTemplate(path)) {",
                    "    return \"angular\";",
                    "  }",
                    "",
                    "  if (isMarkdown(path)) {",
                    "    return \"markdown\";",
                    "  }",
                    "}",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (",
                    "    node.type !== \"TemplateLiteral\" ||",
                    "    // Bail out if any of the quasis have an invalid escape sequence",
                    "    // (which would make the `cooked` value be `null`)",
                    "    hasInvalidCookedValue(node)",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  const language = getLanguage(path);",
                    "  if (!language) {",
                    "    return;",
                    "  }",
                    "",
                    "  if (language === \"markdown\") {",
                    "    return formatMarkdown(path, print, textToDoc);",
                    "  }",
                    "",
                    "  if (language === \"css\") {",
                    "    return formatCss(path, print, textToDoc);",
                    "  }",
                    "",
                    "  if (language === \"graphql\") {",
                    "    return formatGraphql(path, print, textToDoc);",
                    "  }",
                    "",
                    "  if (language === \"html\" || language === \"angular\") {",
                    "    return formatHtml(path, print, textToDoc, options, { parser: language });",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * md`...`",
                    " * markdown`...`",
                    " */",
                    "function isMarkdown(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  return (",
                    "    parent &&",
                    "    parent.type === \"TaggedTemplateExpression\" &&",
                    "    node.quasis.length === 1 &&",
                    "    parent.tag.type === \"Identifier\" &&",
                    "    (parent.tag.name === \"md\" || parent.tag.name === \"markdown\")",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * Template literal in these contexts:",
                    " * <style jsx>{`div{color:red}`}</style>",
                    " * css``",
                    " * css.global``",
                    " * css.resolve``",
                    " */",
                    "function isStyledJsx(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "  return (",
                    "    (parentParent &&",
                    "      node.quasis &&",
                    "      parent.type === \"JSXExpressionContainer\" &&",
                    "      parentParent.type === \"JSXElement\" &&",
                    "      parentParent.openingElement.name.name === \"style\" &&",
                    "      parentParent.openingElement.attributes.some(",
                    "        (attribute) => attribute.name.name === \"jsx\"",
                    "      )) ||",
                    "    (parent &&",
                    "      parent.type === \"TaggedTemplateExpression\" &&",
                    "      parent.tag.type === \"Identifier\" &&",
                    "      parent.tag.name === \"css\") ||",
                    "    (parent &&",
                    "      parent.type === \"TaggedTemplateExpression\" &&",
                    "      parent.tag.type === \"MemberExpression\" &&",
                    "      parent.tag.object.name === \"css\" &&",
                    "      (parent.tag.property.name === \"global\" ||",
                    "        parent.tag.property.name === \"resolve\"))",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * Angular Components can have:",
                    " * - Inline HTML template",
                    " * - Inline CSS styles",
                    " *",
                    " * ...which are both within template literals somewhere",
                    " * inside of the Component decorator factory.",
                    " *",
                    " * E.g.",
                    " * @Component({",
                    " *  template: `<div>...</div>`,",
                    " *  styles: [`h1 { color: blue; }`]",
                    " * })",
                    " */",
                    "function isAngularComponentStyles(path) {",
                    "  return path.match(",
                    "    (node) => node.type === \"TemplateLiteral\",",
                    "    (node, name) => node.type === \"ArrayExpression\" && name === \"elements\",",
                    "    (node, name) =>",
                    "      isObjectProperty(node) &&",
                    "      node.key.type === \"Identifier\" &&",
                    "      node.key.name === \"styles\" &&",
                    "      name === \"value\",",
                    "    ...angularComponentObjectExpressionPredicates",
                    "  );",
                    "}",
                    "function isAngularComponentTemplate(path) {",
                    "  return path.match(",
                    "    (node) => node.type === \"TemplateLiteral\",",
                    "    (node, name) =>",
                    "      isObjectProperty(node) &&",
                    "      node.key.type === \"Identifier\" &&",
                    "      node.key.name === \"template\" &&",
                    "      name === \"value\",",
                    "    ...angularComponentObjectExpressionPredicates",
                    "  );",
                    "}",
                    "const angularComponentObjectExpressionPredicates = [",
                    "  (node, name) => node.type === \"ObjectExpression\" && name === \"properties\",",
                    "  (node, name) =>",
                    "    node.type === \"CallExpression\" &&",
                    "    node.callee.type === \"Identifier\" &&",
                    "    node.callee.name === \"Component\" &&",
                    "    name === \"arguments\",",
                    "  (node, name) => node.type === \"Decorator\" && name === \"expression\",",
                    "];",
                    "",
                    "/**",
                    " * styled-components template literals",
                    " */",
                    "function isStyledComponents(path) {",
                    "  const parent = path.getParentNode();",
                    "",
                    "  if (!parent || parent.type !== \"TaggedTemplateExpression\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  const tag =",
                    "    parent.tag.type === \"ParenthesizedExpression\"",
                    "      ? parent.tag.expression",
                    "      : parent.tag;",
                    "",
                    "  switch (tag.type) {",
                    "    case \"MemberExpression\":",
                    "      return (",
                    "        // styled.foo``",
                    "        isStyledIdentifier(tag.object) ||",
                    "        // Component.extend``",
                    "        isStyledExtend(tag)",
                    "      );",
                    "",
                    "    case \"CallExpression\":",
                    "      return (",
                    "        // styled(Component)``",
                    "        isStyledIdentifier(tag.callee) ||",
                    "        (tag.callee.type === \"MemberExpression\" &&",
                    "          ((tag.callee.object.type === \"MemberExpression\" &&",
                    "            // styled.foo.attrs({})``",
                    "            (isStyledIdentifier(tag.callee.object.object) ||",
                    "              // Component.extend.attrs({})``",
                    "              isStyledExtend(tag.callee.object))) ||",
                    "            // styled(Component).attrs({})``",
                    "            (tag.callee.object.type === \"CallExpression\" &&",
                    "              isStyledIdentifier(tag.callee.object.callee))))",
                    "      );",
                    "",
                    "    case \"Identifier\":",
                    "      // css``",
                    "      return tag.name === \"css\";",
                    "",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * JSX element with CSS prop",
                    " */",
                    "function isCssProp(path) {",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "  return (",
                    "    parentParent &&",
                    "    parent.type === \"JSXExpressionContainer\" &&",
                    "    parentParent.type === \"JSXAttribute\" &&",
                    "    parentParent.name.type === \"JSXIdentifier\" &&",
                    "    parentParent.name.name === \"css\"",
                    "  );",
                    "}",
                    "",
                    "function isStyledIdentifier(node) {",
                    "  return node.type === \"Identifier\" && node.name === \"styled\";",
                    "}",
                    "",
                    "function isStyledExtend(node) {",
                    "  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";",
                    "}",
                    "",
                    "/*",
                    " * react-relay and graphql-tag",
                    " * graphql`...`",
                    " * graphql.experimental`...`",
                    " * gql`...`",
                    " * GraphQL comment block",
                    " *",
                    " * This intentionally excludes Relay Classic tags, as Prettier does not",
                    " * support Relay Classic formatting.",
                    " */",
                    "function isGraphQL(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  return (",
                    "    hasLanguageComment(node, \"GraphQL\") ||",
                    "    (parent &&",
                    "      ((parent.type === \"TaggedTemplateExpression\" &&",
                    "        ((parent.tag.type === \"MemberExpression\" &&",
                    "          parent.tag.object.name === \"graphql\" &&",
                    "          parent.tag.property.name === \"experimental\") ||",
                    "          (parent.tag.type === \"Identifier\" &&",
                    "            (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")))) ||",
                    "        (parent.type === \"CallExpression\" &&",
                    "          parent.callee.type === \"Identifier\" &&",
                    "          parent.callee.name === \"graphql\")))",
                    "  );",
                    "}",
                    "",
                    "function hasLanguageComment(node, languageName) {",
                    "  // This checks for a leading comment that is exactly `/* GraphQL */`",
                    "  // In order to be in line with other implementations of this comment tag",
                    "  // we will not trim the comment value and we will expect exactly one space on",
                    "  // either side of the GraphQL string",
                    "  // Also see ./clean.js",
                    "  return hasComment(",
                    "    node,",
                    "    CommentCheckFlags.Block | CommentCheckFlags.Leading,",
                    "    ({ value }) => value === ` ${languageName} `",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " *     - html`...`",
                    " *     - HTML comment block",
                    " */",
                    "function isHtml(path) {",
                    "  return (",
                    "    hasLanguageComment(path.getValue(), \"HTML\") ||",
                    "    path.match(",
                    "      (node) => node.type === \"TemplateLiteral\",",
                    "      (node, name) =>",
                    "        node.type === \"TaggedTemplateExpression\" &&",
                    "        node.tag.type === \"Identifier\" &&",
                    "        node.tag.name === \"html\" &&",
                    "        name === \"quasi\"",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function hasInvalidCookedValue({ quasis }) {",
                    "  return quasis.some(({ value: { cooked } }) => cooked === null);",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const estreePrinter = require(\"./printer-estree.js\");",
                    "const estreeJsonPrinter = require(\"./printer-estree-json.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parse/parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(",
                    "    require(\"linguist-languages/data/JavaScript.json\"),",
                    "    (data) => ({",
                    "      since: \"0.0.0\",",
                    "      parsers: [",
                    "        \"babel\",",
                    "        \"acorn\",",
                    "        \"espree\",",
                    "        \"meriyah\",",
                    "        \"babel-flow\",",
                    "        \"babel-ts\",",
                    "        \"flow\",",
                    "        \"typescript\",",
                    "      ],",
                    "      vscodeLanguageIds: [\"javascript\", \"mongo\"],",
                    "      interpreters: [",
                    "        ...data.interpreters,",
                    "        // https://github.com/google/zx",
                    "        \"zx\",",
                    "      ],",
                    "      extensions: [",
                    "        ...data.extensions.filter((extension) => extension !== \".jsx\"),",
                    "        // WeiXin Script (Weixin Mini Programs)",
                    "        // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                    "        \".wxs\",",
                    "      ],",
                    "    })",
                    "  ),",
                    "  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({",
                    "    name: \"Flow\",",
                    "    since: \"0.0.0\",",
                    "    parsers: [\"flow\", \"babel-flow\"],",
                    "    vscodeLanguageIds: [\"javascript\"],",
                    "    aliases: [],",
                    "    filenames: [],",
                    "    extensions: [\".js.flow\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({",
                    "    name: \"JSX\",",
                    "    since: \"0.0.0\",",
                    "    parsers: [",
                    "      \"babel\",",
                    "      \"babel-flow\",",
                    "      \"babel-ts\",",
                    "      \"flow\",",
                    "      \"typescript\",",
                    "      \"espree\",",
                    "      \"meriyah\",",
                    "    ],",
                    "    vscodeLanguageIds: [\"javascriptreact\"],",
                    "    aliases: undefined,",
                    "    filenames: undefined,",
                    "    extensions: [\".jsx\"],",
                    "    group: \"JavaScript\",",
                    "    interpreters: undefined,",
                    "    tmScope: \"source.js.jsx\",",
                    "    aceMode: \"javascript\",",
                    "    codemirrorMode: \"jsx\",",
                    "    codemirrorMimeType: \"text/jsx\",",
                    "    color: undefined,",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/TypeScript.json\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"typescript\", \"babel-ts\"],",
                    "    vscodeLanguageIds: [\"typescript\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/TSX.json\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"typescript\", \"babel-ts\"],",
                    "    vscodeLanguageIds: [\"typescriptreact\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JSON.json\"), () => ({",
                    "    name: \"JSON.stringify\",",
                    "    since: \"1.13.0\",",
                    "    parsers: [\"json-stringify\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    extensions: [\".importmap\"], // .json file defaults to json instead of json-stringify",
                    "    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JSON.json\"), (data) => ({",
                    "    since: \"1.5.0\",",
                    "    parsers: [\"json\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    extensions: data.extensions.filter((extension) => extension !== \".jsonl\"),",
                    "  })),",
                    "  createLanguage(",
                    "    require(\"linguist-languages/data/JSON with Comments.json\"),",
                    "    (data) => ({",
                    "      since: \"1.5.0\",",
                    "      parsers: [\"json\"],",
                    "      vscodeLanguageIds: [\"jsonc\"],",
                    "      filenames: [...data.filenames, \".eslintrc\", \".swcrc\"],",
                    "    })",
                    "  ),",
                    "  createLanguage(require(\"linguist-languages/data/JSON5.json\"), () => ({",
                    "    since: \"1.13.0\",",
                    "    parsers: [\"json5\"],",
                    "    vscodeLanguageIds: [\"json5\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  estree: estreePrinter,",
                    "  \"estree-json\": estreeJsonPrinter,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const isNonEmptyArray = require(\"../utils/is-non-empty-array.js\");",
                    "",
                    "/**",
                    " * @typedef {import(\"./types/estree\").Node} Node",
                    " */",
                    "",
                    "function locStart(node) {",
                    "  const start = node.range ? node.range[0] : node.start;",
                    "",
                    "  // Handle nodes with decorators. They should start at the first decorator",
                    "  const decorators = node.declaration?.decorators ?? node.decorators;",
                    "  if (isNonEmptyArray(decorators)) {",
                    "    return Math.min(locStart(decorators[0]), start);",
                    "  }",
                    "",
                    "  return start;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.range ? node.range[1] : node.end;",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLocStart(nodeA, nodeB) {",
                    "  const nodeAStart = locStart(nodeA);",
                    "  return Number.isInteger(nodeAStart) && nodeAStart === locStart(nodeB);",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLocEnd(nodeA, nodeB) {",
                    "  const nodeAEnd = locEnd(nodeA);",
                    "  return Number.isInteger(nodeAEnd) && nodeAEnd === locEnd(nodeB);",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLoc(nodeA, nodeB) {",
                    "  return hasSameLocStart(nodeA, nodeB) && hasSameLocEnd(nodeA, nodeB);",
                    "}",
                    "",
                    "module.exports = {",
                    "  locStart,",
                    "  locEnd,",
                    "  hasSameLocStart,",
                    "  hasSameLoc,",
                    "};"
                ]
            },
            "needs-parens.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const isNonEmptyArray = require(\"../utils/is-non-empty-array.js\");",
                    "const {",
                    "  getFunctionParameters,",
                    "  getLeftSidePathName,",
                    "  hasFlowShorthandAnnotationComment,",
                    "  hasNakedLeftSide,",
                    "  hasNode,",
                    "  isBitwiseOperator,",
                    "  startsWithNoLookaheadToken,",
                    "  shouldFlatten,",
                    "  getPrecedence,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  isObjectProperty,",
                    "  isTSTypeExpression,",
                    "} = require(\"./utils/index.js\");",
                    "",
                    "function needsParens(path, options) {",
                    "  const parent = path.getParentNode();",
                    "  if (!parent) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const name = path.getName();",
                    "  const node = path.getNode();",
                    "",
                    "  // to avoid unexpected `}}` in HTML interpolations",
                    "  if (",
                    "    options.__isInHtmlInterpolation &&",
                    "    !options.bracketSpacing &&",
                    "    endsWithRightBracket(node) &&",
                    "    isFollowedByRightBracket(path)",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Only statements don't need parentheses.",
                    "  if (isStatement(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    // Preserve parens if we have a Flow annotation comment, unless we're using the Flow",
                    "    // parser. The Flow parser turns Flow comments into type annotation nodes in its",
                    "    // AST, which we handle separately.",
                    "    options.parser !== \"flow\" &&",
                    "    hasFlowShorthandAnnotationComment(path.getValue())",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Identifiers never need parentheses.",
                    "  if (node.type === \"Identifier\") {",
                    "    // ...unless those identifiers are embed placeholders. They might be substituted by complex",
                    "    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):",
                    "    //     let tpl = html`<script> f((${expr}) / 2); </script>`;",
                    "    // If the inner JS formatter removes the parens, the expression might change its meaning:",
                    "    //     f((a + b) / 2)  vs  f(a + b / 2)",
                    "    if (",
                    "      node.extra &&",
                    "      node.extra.parenthesized &&",
                    "      /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    // `for ((async) of []);` and `for ((let) of []);`",
                    "    if (",
                    "      name === \"left\" &&",
                    "      ((node.name === \"async\" && !parent.await) || node.name === \"let\") &&",
                    "      parent.type === \"ForOfStatement\"",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    // `for ((let.a) of []);`",
                    "    if (node.name === \"let\") {",
                    "      const expression = path.findAncestor(",
                    "        (node) => node.type === \"ForOfStatement\"",
                    "      )?.left;",
                    "      if (",
                    "        expression &&",
                    "        startsWithNoLookaheadToken(",
                    "          expression,",
                    "          (leftmostNode) => leftmostNode === node",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "",
                    "    // `(let)[a] = 1`",
                    "    if (",
                    "      name === \"object\" &&",
                    "      node.name === \"let\" &&",
                    "      parent.type === \"MemberExpression\" &&",
                    "      parent.computed &&",
                    "      !parent.optional",
                    "    ) {",
                    "      const statement = path.findAncestor(",
                    "        (node) =>",
                    "          node.type === \"ExpressionStatement\" ||",
                    "          node.type === \"ForStatement\" ||",
                    "          node.type === \"ForInStatement\"",
                    "      );",
                    "      const expression = !statement",
                    "        ? undefined",
                    "        : statement.type === \"ExpressionStatement\"",
                    "        ? statement.expression",
                    "        : statement.type === \"ForStatement\"",
                    "        ? statement.init",
                    "        : statement.left;",
                    "      if (",
                    "        expression &&",
                    "        startsWithNoLookaheadToken(",
                    "          expression,",
                    "          (leftmostNode) => leftmostNode === node",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"ObjectExpression\" ||",
                    "    node.type === \"FunctionExpression\" ||",
                    "    node.type === \"ClassExpression\" ||",
                    "    node.type === \"DoExpression\"",
                    "  ) {",
                    "    const expression = path.findAncestor(",
                    "      (node) => node.type === \"ExpressionStatement\"",
                    "    )?.expression;",
                    "    if (",
                    "      expression &&",
                    "      startsWithNoLookaheadToken(",
                    "        expression,",
                    "        (leftmostNode) => leftmostNode === node",
                    "      )",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  switch (parent.type) {",
                    "    case \"ParenthesizedExpression\":",
                    "      return false;",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\": {",
                    "      // Add parens around the extends clause of a class. It is needed for almost",
                    "      // all expressions.",
                    "      if (",
                    "        name === \"superClass\" &&",
                    "        (node.type === \"ArrowFunctionExpression\" ||",
                    "          node.type === \"AssignmentExpression\" ||",
                    "          node.type === \"AwaitExpression\" ||",
                    "          node.type === \"BinaryExpression\" ||",
                    "          node.type === \"ConditionalExpression\" ||",
                    "          node.type === \"LogicalExpression\" ||",
                    "          node.type === \"NewExpression\" ||",
                    "          node.type === \"ObjectExpression\" ||",
                    "          node.type === \"SequenceExpression\" ||",
                    "          node.type === \"TaggedTemplateExpression\" ||",
                    "          node.type === \"UnaryExpression\" ||",
                    "          node.type === \"UpdateExpression\" ||",
                    "          node.type === \"YieldExpression\" ||",
                    "          node.type === \"TSNonNullExpression\")",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"ExportDefaultDeclaration\": {",
                    "      return (",
                    "        // `export default function` or `export default class` can't be followed by",
                    "        // anything after. So an expression like `export default (function(){}).toString()`",
                    "        // needs to be followed by a parentheses",
                    "        shouldWrapFunctionForExportDefault(path, options) ||",
                    "        // `export default (foo, bar)` also needs parentheses",
                    "        node.type === \"SequenceExpression\"",
                    "      );",
                    "    }",
                    "    case \"Decorator\": {",
                    "      if (name === \"expression\") {",
                    "        let hasCallExpression = false;",
                    "        let hasMemberExpression = false;",
                    "        let current = node;",
                    "        while (current) {",
                    "          switch (current.type) {",
                    "            case \"MemberExpression\":",
                    "              hasMemberExpression = true;",
                    "              current = current.object;",
                    "              break;",
                    "            case \"CallExpression\":",
                    "              if (",
                    "                /** @(x().y) */ hasMemberExpression ||",
                    "                /** @(x().y()) */ hasCallExpression",
                    "              ) {",
                    "                return options.parser !== \"typescript\";",
                    "              }",
                    "              hasCallExpression = true;",
                    "              current = current.callee;",
                    "              break;",
                    "            case \"Identifier\":",
                    "              return false;",
                    "            case \"TaggedTemplateExpression\":",
                    "              // babel-parser cannot parse",
                    "              //   @foo`bar`",
                    "              return options.parser !== \"typescript\";",
                    "            default:",
                    "              return true;",
                    "          }",
                    "        }",
                    "        return true;",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"ArrowFunctionExpression\": {",
                    "      if (",
                    "        name === \"body\" &&",
                    "        node.type !== \"SequenceExpression\" && // these have parens added anyway",
                    "        startsWithNoLookaheadToken(",
                    "          node,",
                    "          (node) => node.type === \"ObjectExpression\"",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"UpdateExpression\":",
                    "      if (parent.type === \"UnaryExpression\") {",
                    "        return (",
                    "          node.prefix &&",
                    "          ((node.operator === \"++\" && parent.operator === \"+\") ||",
                    "            (node.operator === \"--\" && parent.operator === \"-\"))",
                    "        );",
                    "      }",
                    "    // else fallthrough",
                    "    case \"UnaryExpression\":",
                    "      switch (parent.type) {",
                    "        case \"UnaryExpression\":",
                    "          return (",
                    "            node.operator === parent.operator &&",
                    "            (node.operator === \"+\" || node.operator === \"-\")",
                    "          );",
                    "",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"BinaryExpression\":",
                    "          return name === \"left\" && parent.operator === \"**\";",
                    "",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"BinaryExpression\": {",
                    "      if (parent.type === \"UpdateExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      // We add parentheses to any `a in b` inside `ForStatement` initializer",
                    "      // https://github.com/prettier/prettier/issues/907#issuecomment-284304321",
                    "      if (node.operator === \"in\" && isPathInForStatementInitializer(path)) {",
                    "        return true;",
                    "      }",
                    "      if (node.operator === \"|>\" && node.extra && node.extra.parenthesized) {",
                    "        const grandParent = path.getParentNode(1);",
                    "        if (",
                    "          grandParent.type === \"BinaryExpression\" &&",
                    "          grandParent.operator === \"|>\"",
                    "        ) {",
                    "          return true;",
                    "        }",
                    "      }",
                    "    }",
                    "    // fallthrough",
                    "    case \"TSTypeAssertion\":",
                    "    case \"TSAsExpression\":",
                    "    case \"TSSatisfiesExpression\":",
                    "    case \"LogicalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSAsExpression\":",
                    "          // example: foo as unknown as Bar",
                    "          return !isTSTypeExpression(node);",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return isTSTypeExpression(node);",
                    "",
                    "        case \"CallExpression\":",
                    "        case \"NewExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"ClassExpression\":",
                    "        case \"ClassDeclaration\":",
                    "          return name === \"superClass\";",
                    "",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"BindExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"UpdateExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"AssignmentExpression\":",
                    "        case \"AssignmentPattern\":",
                    "          return (",
                    "            name === \"left\" &&",
                    "            (node.type === \"TSTypeAssertion\" || isTSTypeExpression(node))",
                    "          );",
                    "",
                    "        case \"LogicalExpression\":",
                    "          if (node.type === \"LogicalExpression\") {",
                    "            return parent.operator !== node.operator;",
                    "          }",
                    "        // else fallthrough",
                    "",
                    "        case \"BinaryExpression\": {",
                    "          const { operator, type } = node;",
                    "          if (!operator && type !== \"TSTypeAssertion\") {",
                    "            return true;",
                    "          }",
                    "",
                    "          const precedence = getPrecedence(operator);",
                    "          const parentOperator = parent.operator;",
                    "          const parentPrecedence = getPrecedence(parentOperator);",
                    "",
                    "          if (parentPrecedence > precedence) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (name === \"right\" && parentPrecedence === precedence) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (",
                    "            parentPrecedence === precedence &&",
                    "            !shouldFlatten(parentOperator, operator)",
                    "          ) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (parentPrecedence < precedence && operator === \"%\") {",
                    "            return parentOperator === \"+\" || parentOperator === \"-\";",
                    "          }",
                    "",
                    "          // Add parenthesis when working with bitwise operators",
                    "          // It's not strictly needed but helps with code understanding",
                    "          if (isBitwiseOperator(parentOperator)) {",
                    "            return true;",
                    "          }",
                    "",
                    "          return false;",
                    "        }",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"SequenceExpression\":",
                    "      switch (parent.type) {",
                    "        case \"ReturnStatement\":",
                    "          return false;",
                    "",
                    "        case \"ForStatement\":",
                    "          // Although parentheses wouldn't hurt around sequence",
                    "          // expressions in the head of for loops, traditional style",
                    "          // dictates that e.g. i++, j++ should not be wrapped with",
                    "          // parentheses.",
                    "          return false;",
                    "",
                    "        case \"ExpressionStatement\":",
                    "          return name !== \"expression\";",
                    "",
                    "        case \"ArrowFunctionExpression\":",
                    "          // We do need parentheses, but SequenceExpressions are handled",
                    "          // specially when printing bodies of arrow functions.",
                    "          return name !== \"body\";",
                    "",
                    "        default:",
                    "          // Otherwise err on the side of overparenthesization, adding",
                    "          // explicit exceptions above if this proves overzealous.",
                    "          return true;",
                    "      }",
                    "",
                    "    case \"YieldExpression\":",
                    "      if (",
                    "        parent.type === \"UnaryExpression\" ||",
                    "        parent.type === \"AwaitExpression\" ||",
                    "        isTSTypeExpression(parent) ||",
                    "        parent.type === \"TSNonNullExpression\"",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // else fallthrough",
                    "    case \"AwaitExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\";",
                    "",
                    "        case \"BinaryExpression\": {",
                    "          if (!node.argument && parent.operator === \"|>\") {",
                    "            return false;",
                    "          }",
                    "",
                    "          return true;",
                    "        }",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"TSConditionalType\":",
                    "      if (name === \"extendsType\" && parent.type === \"TSConditionalType\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSFunctionType\":",
                    "    case \"TSConstructorType\":",
                    "      if (name === \"extendsType\" && parent.type === \"TSConditionalType\") {",
                    "        const returnTypeAnnotation = (node.returnType || node.typeAnnotation)",
                    "          .typeAnnotation;",
                    "        if (",
                    "          returnTypeAnnotation.type === \"TSInferType\" &&",
                    "          returnTypeAnnotation.typeParameter.constraint",
                    "        ) {",
                    "          return true;",
                    "        }",
                    "      }",
                    "      if (name === \"checkType\" && parent.type === \"TSConditionalType\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSUnionType\":",
                    "    case \"TSIntersectionType\":",
                    "      if (",
                    "        (parent.type === \"TSUnionType\" ||",
                    "          parent.type === \"TSIntersectionType\") &&",
                    "        parent.types.length > 1 &&",
                    "        (!node.types || node.types.length > 1)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSInferType\":",
                    "      if (node.type === \"TSInferType\" && parent.type === \"TSRestType\") {",
                    "        return false;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSTypeOperator\":",
                    "      return (",
                    "        parent.type === \"TSArrayType\" ||",
                    "        parent.type === \"TSOptionalType\" ||",
                    "        parent.type === \"TSRestType\" ||",
                    "        (name === \"objectType\" && parent.type === \"TSIndexedAccessType\") ||",
                    "        parent.type === \"TSTypeOperator\" ||",
                    "        (parent.type === \"TSTypeAnnotation\" &&",
                    "          path.getParentNode(1).type.startsWith(\"TSJSDoc\"))",
                    "      );",
                    "    case \"TSTypeQuery\":",
                    "      return (",
                    "        (name === \"objectType\" && parent.type === \"TSIndexedAccessType\") ||",
                    "        (name === \"elementType\" && parent.type === \"TSArrayType\")",
                    "      );",
                    "    case \"ArrayTypeAnnotation\":",
                    "      return parent.type === \"NullableTypeAnnotation\";",
                    "",
                    "    case \"IntersectionTypeAnnotation\":",
                    "    case \"UnionTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        parent.type === \"NullableTypeAnnotation\" ||",
                    "        parent.type === \"IntersectionTypeAnnotation\" ||",
                    "        parent.type === \"UnionTypeAnnotation\" ||",
                    "        (name === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\"))",
                    "      );",
                    "",
                    "    case \"NullableTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        (name === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\"))",
                    "      );",
                    "",
                    "    case \"FunctionTypeAnnotation\": {",
                    "      const ancestor =",
                    "        parent.type === \"NullableTypeAnnotation\"",
                    "          ? path.getParentNode(1)",
                    "          : parent;",
                    "",
                    "      return (",
                    "        ancestor.type === \"UnionTypeAnnotation\" ||",
                    "        ancestor.type === \"IntersectionTypeAnnotation\" ||",
                    "        ancestor.type === \"ArrayTypeAnnotation\" ||",
                    "        (name === \"objectType\" &&",
                    "          (ancestor.type === \"IndexedAccessType\" ||",
                    "            ancestor.type === \"OptionalIndexedAccessType\")) ||",
                    "        // We should check ancestor's parent to know whether the parentheses",
                    "        // are really needed, but since ??T doesn't make sense this check",
                    "        // will almost never be true.",
                    "        ancestor.type === \"NullableTypeAnnotation\" ||",
                    "        // See #5283",
                    "        (parent.type === \"FunctionTypeParam\" &&",
                    "          parent.name === null &&",
                    "          getFunctionParameters(node).some(",
                    "            (param) =>",
                    "              param.typeAnnotation &&",
                    "              param.typeAnnotation.type === \"NullableTypeAnnotation\"",
                    "          ))",
                    "      );",
                    "    }",
                    "",
                    "    case \"OptionalIndexedAccessType\":",
                    "      return name === \"objectType\" && parent.type === \"IndexedAccessType\";",
                    "",
                    "    case \"TypeofTypeAnnotation\":",
                    "      return (",
                    "        name === \"objectType\" &&",
                    "        (parent.type === \"IndexedAccessType\" ||",
                    "          parent.type === \"OptionalIndexedAccessType\")",
                    "      );",
                    "",
                    "    case \"StringLiteral\":",
                    "    case \"NumericLiteral\":",
                    "    case \"Literal\":",
                    "      if (",
                    "        typeof node.value === \"string\" &&",
                    "        parent.type === \"ExpressionStatement\" &&",
                    "        !parent.directive",
                    "      ) {",
                    "        // To avoid becoming a directive",
                    "        const grandParent = path.getParentNode(1);",
                    "",
                    "        return (",
                    "          grandParent.type === \"Program\" ||",
                    "          grandParent.type === \"BlockStatement\"",
                    "        );",
                    "      }",
                    "",
                    "      return (",
                    "        name === \"object\" &&",
                    "        parent.type === \"MemberExpression\" &&",
                    "        typeof node.value === \"number\"",
                    "      );",
                    "",
                    "    case \"AssignmentExpression\": {",
                    "      const grandParent = path.getParentNode(1);",
                    "",
                    "      if (name === \"body\" && parent.type === \"ArrowFunctionExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      if (",
                    "        name === \"key\" &&",
                    "        (parent.type === \"ClassProperty\" ||",
                    "          parent.type === \"PropertyDefinition\") &&",
                    "        parent.computed",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        (name === \"init\" || name === \"update\") &&",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"ExpressionStatement\") {",
                    "        return node.left.type === \"ObjectPattern\";",
                    "      }",
                    "",
                    "      if (name === \"key\" && parent.type === \"TSPropertySignature\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"AssignmentExpression\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        parent.type === \"SequenceExpression\" &&",
                    "        grandParent &&",
                    "        grandParent.type === \"ForStatement\" &&",
                    "        (grandParent.init === parent || grandParent.update === parent)",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        name === \"value\" &&",
                    "        parent.type === \"Property\" &&",
                    "        grandParent &&",
                    "        grandParent.type === \"ObjectPattern\" &&",
                    "        grandParent.properties.includes(parent)",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"NGChainedExpression\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      return true;",
                    "    }",
                    "    case \"ConditionalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"BinaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"NGPipeExpression\":",
                    "        case \"ExportDefaultDeclaration\":",
                    "        case \"AwaitExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TypeCastExpression\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\";",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"FunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.",
                    "          // Is necessary if it is `expression` of `ExpressionStatement`.",
                    "          return name === \"callee\";",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true; // This is basically a kind of IIFE.",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ArrowFunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"BinaryExpression\":",
                    "          return (",
                    "            parent.operator !== \"|>\" || (node.extra && node.extra.parenthesized)",
                    "          );",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"BindExpression\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSTypeAssertion\":",
                    "          return true;",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ClassExpression\":",
                    "      if (isNonEmptyArray(node.decorators)) {",
                    "        return true;",
                    "      }",
                    "",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "          return name === \"callee\";",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"OptionalCallExpression\": {",
                    "      const parentParent = path.getParentNode(1);",
                    "      if (",
                    "        (name === \"object\" && parent.type === \"MemberExpression\") ||",
                    "        (name === \"callee\" &&",
                    "          (parent.type === \"CallExpression\" ||",
                    "            parent.type === \"NewExpression\")) ||",
                    "        (parent.type === \"TSNonNullExpression\" &&",
                    "          parentParent.type === \"MemberExpression\" &&",
                    "          parentParent.object === parent)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "    // fallthrough",
                    "    case \"CallExpression\":",
                    "    case \"MemberExpression\":",
                    "    case \"TaggedTemplateExpression\":",
                    "    case \"TSNonNullExpression\":",
                    "      if (",
                    "        name === \"callee\" &&",
                    "        (parent.type === \"BindExpression\" || parent.type === \"NewExpression\")",
                    "      ) {",
                    "        let object = node;",
                    "        while (object) {",
                    "          switch (object.type) {",
                    "            case \"CallExpression\":",
                    "            case \"OptionalCallExpression\":",
                    "              return true;",
                    "            case \"MemberExpression\":",
                    "            case \"OptionalMemberExpression\":",
                    "            case \"BindExpression\":",
                    "              object = object.object;",
                    "              break;",
                    "            // tagged templates are basically member expressions from a grammar perspective",
                    "            // see https://tc39.github.io/ecma262/#prod-MemberExpression",
                    "            case \"TaggedTemplateExpression\":",
                    "              object = object.tag;",
                    "              break;",
                    "            case \"TSNonNullExpression\":",
                    "              object = object.expression;",
                    "              break;",
                    "            default:",
                    "              return false;",
                    "          }",
                    "        }",
                    "      }",
                    "      return false;",
                    "",
                    "    case \"BindExpression\":",
                    "      return (",
                    "        (name === \"callee\" &&",
                    "          (parent.type === \"BindExpression\" ||",
                    "            parent.type === \"NewExpression\")) ||",
                    "        (name === \"object\" && isMemberExpression(parent))",
                    "      );",
                    "    case \"NGPipeExpression\":",
                    "      if (",
                    "        parent.type === \"NGRoot\" ||",
                    "        parent.type === \"NGMicrosyntaxExpression\" ||",
                    "        (parent.type === \"ObjectProperty\" &&",
                    "          // Preserve parens for compatibility with AngularJS expressions",
                    "          !(node.extra && node.extra.parenthesized)) ||",
                    "        parent.type === \"ArrayExpression\" ||",
                    "        (isCallExpression(parent) && parent.arguments[name] === node) ||",
                    "        (name === \"right\" && parent.type === \"NGPipeExpression\") ||",
                    "        (name === \"property\" && parent.type === \"MemberExpression\") ||",
                    "        parent.type === \"AssignmentExpression\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "      return true;",
                    "    case \"JSXFragment\":",
                    "    case \"JSXElement\":",
                    "      return (",
                    "        name === \"callee\" ||",
                    "        (name === \"left\" &&",
                    "          parent.type === \"BinaryExpression\" &&",
                    "          parent.operator === \"<\") ||",
                    "        (parent.type !== \"ArrayExpression\" &&",
                    "          parent.type !== \"ArrowFunctionExpression\" &&",
                    "          parent.type !== \"AssignmentExpression\" &&",
                    "          parent.type !== \"AssignmentPattern\" &&",
                    "          parent.type !== \"BinaryExpression\" &&",
                    "          parent.type !== \"NewExpression\" &&",
                    "          parent.type !== \"ConditionalExpression\" &&",
                    "          parent.type !== \"ExpressionStatement\" &&",
                    "          parent.type !== \"JsExpressionRoot\" &&",
                    "          parent.type !== \"JSXAttribute\" &&",
                    "          parent.type !== \"JSXElement\" &&",
                    "          parent.type !== \"JSXExpressionContainer\" &&",
                    "          parent.type !== \"JSXFragment\" &&",
                    "          parent.type !== \"LogicalExpression\" &&",
                    "          !isCallExpression(parent) &&",
                    "          !isObjectProperty(parent) &&",
                    "          parent.type !== \"ReturnStatement\" &&",
                    "          parent.type !== \"ThrowStatement\" &&",
                    "          parent.type !== \"TypeCastExpression\" &&",
                    "          parent.type !== \"VariableDeclarator\" &&",
                    "          parent.type !== \"YieldExpression\")",
                    "      );",
                    "    case \"TypeAnnotation\":",
                    "      return (",
                    "        name === \"returnType\" &&",
                    "        parent.type === \"ArrowFunctionExpression\" &&",
                    "        includesFunctionTypeInObjectType(node)",
                    "      );",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isStatement(node) {",
                    "  return (",
                    "    node.type === \"BlockStatement\" ||",
                    "    node.type === \"BreakStatement\" ||",
                    "    node.type === \"ClassBody\" ||",
                    "    node.type === \"ClassDeclaration\" ||",
                    "    node.type === \"ClassMethod\" ||",
                    "    node.type === \"ClassProperty\" ||",
                    "    node.type === \"PropertyDefinition\" ||",
                    "    node.type === \"ClassPrivateProperty\" ||",
                    "    node.type === \"ContinueStatement\" ||",
                    "    node.type === \"DebuggerStatement\" ||",
                    "    node.type === \"DeclareClass\" ||",
                    "    node.type === \"DeclareExportAllDeclaration\" ||",
                    "    node.type === \"DeclareExportDeclaration\" ||",
                    "    node.type === \"DeclareFunction\" ||",
                    "    node.type === \"DeclareInterface\" ||",
                    "    node.type === \"DeclareModule\" ||",
                    "    node.type === \"DeclareModuleExports\" ||",
                    "    node.type === \"DeclareVariable\" ||",
                    "    node.type === \"DoWhileStatement\" ||",
                    "    node.type === \"EnumDeclaration\" ||",
                    "    node.type === \"ExportAllDeclaration\" ||",
                    "    node.type === \"ExportDefaultDeclaration\" ||",
                    "    node.type === \"ExportNamedDeclaration\" ||",
                    "    node.type === \"ExpressionStatement\" ||",
                    "    node.type === \"ForInStatement\" ||",
                    "    node.type === \"ForOfStatement\" ||",
                    "    node.type === \"ForStatement\" ||",
                    "    node.type === \"FunctionDeclaration\" ||",
                    "    node.type === \"IfStatement\" ||",
                    "    node.type === \"ImportDeclaration\" ||",
                    "    node.type === \"InterfaceDeclaration\" ||",
                    "    node.type === \"LabeledStatement\" ||",
                    "    node.type === \"MethodDefinition\" ||",
                    "    node.type === \"ReturnStatement\" ||",
                    "    node.type === \"SwitchStatement\" ||",
                    "    node.type === \"ThrowStatement\" ||",
                    "    node.type === \"TryStatement\" ||",
                    "    node.type === \"TSDeclareFunction\" ||",
                    "    node.type === \"TSEnumDeclaration\" ||",
                    "    node.type === \"TSImportEqualsDeclaration\" ||",
                    "    node.type === \"TSInterfaceDeclaration\" ||",
                    "    node.type === \"TSModuleDeclaration\" ||",
                    "    node.type === \"TSNamespaceExportDeclaration\" ||",
                    "    node.type === \"TypeAlias\" ||",
                    "    node.type === \"VariableDeclaration\" ||",
                    "    node.type === \"WhileStatement\" ||",
                    "    node.type === \"WithStatement\"",
                    "  );",
                    "}",
                    "",
                    "function isPathInForStatementInitializer(path) {",
                    "  let i = 0;",
                    "  let node = path.getValue();",
                    "  while (node) {",
                    "    const parent = path.getParentNode(i++);",
                    "    if (parent && parent.type === \"ForStatement\" && parent.init === node) {",
                    "      return true;",
                    "    }",
                    "    node = parent;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function includesFunctionTypeInObjectType(node) {",
                    "  return hasNode(",
                    "    node,",
                    "    (n1) =>",
                    "      (n1.type === \"ObjectTypeAnnotation\" &&",
                    "        hasNode(",
                    "          n1,",
                    "          (n2) => n2.type === \"FunctionTypeAnnotation\" || undefined",
                    "        )) ||",
                    "      undefined",
                    "  );",
                    "}",
                    "",
                    "function endsWithRightBracket(node) {",
                    "  switch (node.type) {",
                    "    case \"ObjectExpression\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function isFollowedByRightBracket(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const name = path.getName();",
                    "  switch (parent.type) {",
                    "    case \"NGPipeExpression\":",
                    "      if (",
                    "        typeof name === \"number\" &&",
                    "        parent.arguments[name] === node &&",
                    "        parent.arguments.length - 1 === name",
                    "      ) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ObjectProperty\":",
                    "      if (name === \"value\") {",
                    "        const parentParent = path.getParentNode(1);",
                    "        return getLast(parentParent.properties) === parent;",
                    "      }",
                    "      break;",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "      if (name === \"right\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ConditionalExpression\":",
                    "      if (name === \"alternate\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"UnaryExpression\":",
                    "      if (parent.prefix) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function shouldWrapFunctionForExportDefault(path, options) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {",
                    "    return (",
                    "      parent.type === \"ExportDefaultDeclaration\" ||",
                    "      // in some cases the function is already wrapped",
                    "      // (e.g. `export default (function() {})();`)",
                    "      // in this case we don't need to add extra parens",
                    "      !needsParens(path, options)",
                    "    );",
                    "  }",
                    "",
                    "  if (",
                    "    !hasNakedLeftSide(node) ||",
                    "    (parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return path.call(",
                    "    (childPath) => shouldWrapFunctionForExportDefault(childPath, options),",
                    "    ...getLeftSidePathName(path, node)",
                    "  );",
                    "}",
                    "",
                    "module.exports = needsParens;"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "const CATEGORY_JAVASCRIPT = \"JavaScript\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  arrowParens: {",
                    "    since: \"1.9.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.9.0\", value: \"avoid\" },",
                    "      { since: \"2.0.0\", value: \"always\" },",
                    "    ],",
                    "    description: \"Include parentheses around a sole arrow function parameter.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"always\",",
                    "        description: \"Always include parens. Example: `(x) => x`\",",
                    "      },",
                    "      {",
                    "        value: \"avoid\",",
                    "        description: \"Omit parens when possible. Example: `x => x`\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  bracketSameLine: commonOptions.bracketSameLine,",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  jsxBracketSameLine: {",
                    "    since: \"0.17.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    description: \"Put > on the last line instead of at a new line.\",",
                    "    deprecated: \"2.4.0\",",
                    "  },",
                    "  semi: {",
                    "    since: \"1.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print semicolons.\",",
                    "    oppositeDescription:",
                    "      \"Do not print semicolons, except at the beginning of lines which may need them.\",",
                    "  },",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  jsxSingleQuote: {",
                    "    since: \"1.15.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes in JSX.\",",
                    "  },",
                    "  quoteProps: {",
                    "    since: \"1.17.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"as-needed\",",
                    "    description: \"Change when properties in objects are quoted.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"as-needed\",",
                    "        description: \"Only add quotes around object properties where required.\",",
                    "      },",
                    "      {",
                    "        value: \"consistent\",",
                    "        description:",
                    "          \"If at least one property in an object requires quotes, quote all properties.\",",
                    "      },",
                    "      {",
                    "        value: \"preserve\",",
                    "        description: \"Respect the input use of quotes in object properties.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  trailingComma: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"0.0.0\", value: false },",
                    "      { since: \"0.19.0\", value: \"none\" },",
                    "      { since: \"2.0.0\", value: \"es5\" },",
                    "    ],",
                    "    description: \"Print trailing commas wherever possible when multi-line.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"es5\",",
                    "        description:",
                    "          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",",
                    "      },",
                    "      { value: \"none\", description: \"No trailing commas.\" },",
                    "      {",
                    "        value: \"all\",",
                    "        description:",
                    "          \"Trailing commas wherever possible (including function arguments).\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  singleAttributePerLine: commonOptions.singleAttributePerLine,",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { parseWithComments, strip, extract, print } = require(\"jest-docblock\");",
                    "const { normalizeEndOfLine } = require(\"../common/end-of-line.js\");",
                    "const getShebang = require(\"./utils/get-shebang.js\");",
                    "",
                    "function parseDocBlock(text) {",
                    "  const shebang = getShebang(text);",
                    "  if (shebang) {",
                    "    text = text.slice(shebang.length + 1);",
                    "  }",
                    "",
                    "  const docBlock = extract(text);",
                    "  const { pragmas, comments } = parseWithComments(docBlock);",
                    "",
                    "  return { shebang, text, pragmas, comments };",
                    "}",
                    "",
                    "function hasPragma(text) {",
                    "  const pragmas = Object.keys(parseDocBlock(text).pragmas);",
                    "  return pragmas.includes(\"prettier\") || pragmas.includes(\"format\");",
                    "}",
                    "",
                    "function insertPragma(originalText) {",
                    "  const { shebang, text, pragmas, comments } = parseDocBlock(originalText);",
                    "  const strippedText = strip(text);",
                    "",
                    "  const docBlock = print({",
                    "    pragmas: {",
                    "      format: \"\",",
                    "      ...pragmas,",
                    "    },",
                    "    comments: comments.trimStart(),",
                    "  });",
                    "",
                    "  return (",
                    "    (shebang ? `${shebang}\\n` : \"\") +",
                    "    // normalise newlines (mitigate use of os.EOL by jest-docblock)",
                    "    normalizeEndOfLine(docBlock) +",
                    "    (strippedText.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\") +",
                    "    strippedText",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function preprocess(ast, options) {",
                    "  switch (options.parser) {",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "    case \"__js_expression\":",
                    "    case \"__vue_expression\":",
                    "    case \"__vue_ts_expression\":",
                    "      return {",
                    "        ...ast,",
                    "        type: options.parser.startsWith(\"__\") ? \"JsExpressionRoot\" : \"JsonRoot\",",
                    "        node: ast,",
                    "        comments: [],",
                    "        rootMarker: options.rootMarker,",
                    "      };",
                    "    default:",
                    "      return ast;",
                    "  }",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-estree-json.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { hardline, indent, join },",
                    "} = require(\"../document/index.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "  switch (node.type) {",
                    "    case \"JsonRoot\":",
                    "      return [print(\"node\"), hardline];",
                    "    case \"ArrayExpression\": {",
                    "      if (node.elements.length === 0) {",
                    "        return \"[]\";",
                    "      }",
                    "",
                    "      const printed = path.map(",
                    "        () => (path.getValue() === null ? \"null\" : print()),",
                    "        \"elements\"",
                    "      );",
                    "",
                    "      return [",
                    "        \"[\",",
                    "        indent([hardline, join([\",\", hardline], printed)]),",
                    "        hardline,",
                    "        \"]\",",
                    "      ];",
                    "    }",
                    "    case \"ObjectExpression\":",
                    "      return node.properties.length === 0",
                    "        ? \"{}\"",
                    "        : [",
                    "            \"{\",",
                    "            indent([",
                    "              hardline,",
                    "              join([\",\", hardline], path.map(print, \"properties\")),",
                    "            ]),",
                    "            hardline,",
                    "            \"}\",",
                    "          ];",
                    "    case \"ObjectProperty\":",
                    "      return [print(\"key\"), \": \", print(\"value\")];",
                    "    case \"UnaryExpression\":",
                    "      return [node.operator === \"+\" ? \"\" : node.operator, print(\"argument\")];",
                    "    case \"NullLiteral\":",
                    "      return \"null\";",
                    "    case \"BooleanLiteral\":",
                    "      return node.value ? \"true\" : \"false\";",
                    "    case \"StringLiteral\":",
                    "      return JSON.stringify(node.value);",
                    "    case \"NumericLiteral\":",
                    "      return isObjectKey(path)",
                    "        ? JSON.stringify(String(node.value))",
                    "        : JSON.stringify(node.value);",
                    "    case \"Identifier\":",
                    "      return isObjectKey(path) ? JSON.stringify(node.name) : node.name;",
                    "    case \"TemplateLiteral\":",
                    "      // There is only one `TemplateElement`",
                    "      return print([\"quasis\", 0]);",
                    "    case \"TemplateElement\":",
                    "      return JSON.stringify(node.value.cooked);",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown type: \" + JSON.stringify(node.type));",
                    "  }",
                    "}",
                    "",
                    "function isObjectKey(path) {",
                    "  return (",
                    "    path.getName() === \"key\" && path.getParentNode().type === \"ObjectProperty\"",
                    "  );",
                    "}",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"start\",",
                    "  \"end\",",
                    "  \"extra\",",
                    "  \"loc\",",
                    "  \"comments\",",
                    "  \"leadingComments\",",
                    "  \"trailingComments\",",
                    "  \"innerComments\",",
                    "  \"errors\",",
                    "  \"range\",",
                    "  \"tokens\",",
                    "]);",
                    "",
                    "function clean(node, newNode /*, parent*/) {",
                    "  const { type } = node;",
                    "  // We print quoted key",
                    "  if (type === \"ObjectProperty\") {",
                    "    const { key } = node;",
                    "    if (key.type === \"Identifier\") {",
                    "      newNode.key = { type: \"StringLiteral\", value: key.name };",
                    "    } else if (key.type === \"NumericLiteral\") {",
                    "      newNode.key = { type: \"StringLiteral\", value: String(key.value) };",
                    "    }",
                    "    return;",
                    "  }",
                    "  if (type === \"UnaryExpression\" && node.operator === \"+\") {",
                    "    return newNode.argument;",
                    "  }",
                    "  // We print holes in array as `null`",
                    "  if (type === \"ArrayExpression\") {",
                    "    for (const [index, element] of node.elements.entries()) {",
                    "      if (element === null) {",
                    "        newNode.elements.splice(index, 0, { type: \"NullLiteral\" });",
                    "      }",
                    "    }",
                    "    return;",
                    "  }",
                    "  // We print `TemplateLiteral` as string",
                    "  if (type === \"TemplateLiteral\") {",
                    "    return { type: \"StringLiteral\", value: node.quasis[0].value.cooked };",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "};"
                ]
            },
            "printer-estree.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/** @typedef {import(\"../document\").Doc} Doc */",
                    "",
                    "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
                    "const { printDanglingComments } = require(\"../main/comments.js\");",
                    "const { hasNewline } = require(\"../common/util.js\");",
                    "const {",
                    "  builders: { join, line, hardline, softline, group, indent },",
                    "  utils: { replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "const handleComments = require(\"./comments.js\");",
                    "const pathNeedsParens = require(\"./needs-parens.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "const {",
                    "  hasFlowShorthandAnnotationComment,",
                    "  hasComment,",
                    "  CommentCheckFlags,",
                    "  isTheOnlyJsxElementInMarkdown,",
                    "  isLineComment,",
                    "  isNextLineEmpty,",
                    "  needsHardlineAfterDanglingComment,",
                    "  hasIgnoreComment,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  markerForIfWithoutBlockAndSameLineComment,",
                    "} = require(\"./utils/index.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const isBlockComment = require(\"./utils/is-block-comment.js\");",
                    "",
                    "const {",
                    "  printHtmlBinding,",
                    "  isVueEventBindingExpression,",
                    "} = require(\"./print/html-binding.js\");",
                    "const { printAngular } = require(\"./print/angular.js\");",
                    "const { printJsx, hasJsxIgnoreComment } = require(\"./print/jsx.js\");",
                    "const { printFlow } = require(\"./print/flow.js\");",
                    "const { printTypescript } = require(\"./print/typescript.js\");",
                    "const {",
                    "  printOptionalToken,",
                    "  printBindExpressionCallee,",
                    "  printTypeAnnotation,",
                    "  adjustClause,",
                    "  printRestSpread,",
                    "  printDefiniteToken,",
                    "  printDirective,",
                    "} = require(\"./print/misc.js\");",
                    "const {",
                    "  printImportDeclaration,",
                    "  printExportDeclaration,",
                    "  printExportAllDeclaration,",
                    "  printModuleSpecifier,",
                    "} = require(\"./print/module.js\");",
                    "const { printTernary } = require(\"./print/ternary.js\");",
                    "const { printTemplateLiteral } = require(\"./print/template-literal.js\");",
                    "const { printArray } = require(\"./print/array.js\");",
                    "const { printObject } = require(\"./print/object.js\");",
                    "const {",
                    "  printClass,",
                    "  printClassMethod,",
                    "  printClassProperty,",
                    "} = require(\"./print/class.js\");",
                    "const { printProperty } = require(\"./print/property.js\");",
                    "const {",
                    "  printFunction,",
                    "  printArrowFunction,",
                    "  printMethod,",
                    "  printReturnStatement,",
                    "  printThrowStatement,",
                    "} = require(\"./print/function.js\");",
                    "const { printCallExpression } = require(\"./print/call-expression.js\");",
                    "const {",
                    "  printVariableDeclarator,",
                    "  printAssignmentExpression,",
                    "} = require(\"./print/assignment.js\");",
                    "const { printBinaryishExpression } = require(\"./print/binaryish.js\");",
                    "const { printSwitchCaseConsequent } = require(\"./print/statement.js\");",
                    "const { printMemberExpression } = require(\"./print/member.js\");",
                    "const { printBlock, printBlockBody } = require(\"./print/block.js\");",
                    "const { printComment } = require(\"./print/comment.js\");",
                    "const { printLiteral } = require(\"./print/literal.js\");",
                    "const { printDecorators } = require(\"./print/decorators.js\");",
                    "",
                    "function genericPrint(path, options, print, args) {",
                    "  const printed = printPathNoParens(path, options, print, args);",
                    "  if (!printed) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const node = path.getValue();",
                    "  const { type } = node;",
                    "  // Their decorators are handled themselves, and they can't have parentheses",
                    "  if (",
                    "    type === \"ClassMethod\" ||",
                    "    type === \"ClassPrivateMethod\" ||",
                    "    type === \"ClassProperty\" ||",
                    "    type === \"ClassAccessorProperty\" ||",
                    "    type === \"AccessorProperty\" ||",
                    "    type === \"TSAbstractAccessorProperty\" ||",
                    "    type === \"PropertyDefinition\" ||",
                    "    type === \"TSAbstractPropertyDefinition\" ||",
                    "    type === \"ClassPrivateProperty\" ||",
                    "    type === \"MethodDefinition\" ||",
                    "    type === \"TSAbstractMethodDefinition\" ||",
                    "    type === \"TSDeclareMethod\"",
                    "  ) {",
                    "    return printed;",
                    "  }",
                    "",
                    "  let parts = [printed];",
                    "",
                    "  const printedDecorators = printDecorators(path, options, print);",
                    "  const isClassExpressionWithDecorators =",
                    "    node.type === \"ClassExpression\" && printedDecorators;",
                    "  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons",
                    "  if (printedDecorators) {",
                    "    parts = [...printedDecorators, printed];",
                    "",
                    "    if (!isClassExpressionWithDecorators) {",
                    "      return group(parts);",
                    "    }",
                    "  }",
                    "",
                    "  const needsParens = pathNeedsParens(path, options);",
                    "",
                    "  if (!needsParens) {",
                    "    if (args && args.needsSemi) {",
                    "      parts.unshift(\";\");",
                    "    }",
                    "",
                    "    // In member-chain print, it add `label` to the doc, if we return array here it will be broken",
                    "    if (parts.length === 1 && parts[0] === printed) {",
                    "      return printed;",
                    "    }",
                    "",
                    "    return parts;",
                    "  }",
                    "",
                    "  if (isClassExpressionWithDecorators) {",
                    "    parts = [indent([line, ...parts])];",
                    "  }",
                    "",
                    "  parts.unshift(\"(\");",
                    "",
                    "  if (args && args.needsSemi) {",
                    "    parts.unshift(\";\");",
                    "  }",
                    "",
                    "  if (hasFlowShorthandAnnotationComment(node)) {",
                    "    const [comment] = node.trailingComments;",
                    "    parts.push(\" /*\", comment.value.trimStart(), \"*/\");",
                    "    comment.printed = true;",
                    "  }",
                    "",
                    "  if (isClassExpressionWithDecorators) {",
                    "    parts.push(line);",
                    "  }",
                    "",
                    "  parts.push(\")\");",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printPathNoParens(path, options, print, args) {",
                    "  const node = path.getValue();",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof node === \"string\") {",
                    "    return node;",
                    "  }",
                    "",
                    "  for (const printer of [",
                    "    printLiteral,",
                    "    printHtmlBinding,",
                    "    printAngular,",
                    "    printJsx,",
                    "    printFlow,",
                    "    printTypescript,",
                    "  ]) {",
                    "    const printed = printer(path, options, print);",
                    "    if (typeof printed !== \"undefined\") {",
                    "      return printed;",
                    "    }",
                    "  }",
                    "",
                    "  /** @type{Doc[]} */",
                    "  let parts = [];",
                    "",
                    "  switch (node.type) {",
                    "    case \"JsExpressionRoot\":",
                    "      return print(\"node\");",
                    "    case \"JsonRoot\":",
                    "      return [print(\"node\"), hardline];",
                    "    case \"File\":",
                    "      // Print @babel/parser's InterpreterDirective here so that",
                    "      // leading comments on the `Program` node get printed after the hashbang.",
                    "      if (node.program && node.program.interpreter) {",
                    "        parts.push(print([\"program\", \"interpreter\"]));",
                    "      }",
                    "",
                    "      parts.push(print(\"program\"));",
                    "",
                    "      return parts;",
                    "",
                    "    case \"Program\":",
                    "      return printBlockBody(path, options, print);",
                    "    // Babel extension.",
                    "    case \"EmptyStatement\":",
                    "      return \"\";",
                    "    case \"ExpressionStatement\": {",
                    "      if (",
                    "        options.parser === \"__vue_event_binding\" ||",
                    "        options.parser === \"__vue_ts_event_binding\"",
                    "      ) {",
                    "        const parent = path.getParentNode();",
                    "        if (",
                    "          parent.type === \"Program\" &&",
                    "          parent.body.length === 1 &&",
                    "          parent.body[0] === node",
                    "        ) {",
                    "          return [",
                    "            print(\"expression\"),",
                    "            isVueEventBindingExpression(node.expression) ? \";\" : \"\",",
                    "          ];",
                    "        }",
                    "      }",
                    "",
                    "      const danglingComment = printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /** sameIndent */ true,",
                    "        ({ marker }) => marker === markerForIfWithoutBlockAndSameLineComment",
                    "      );",
                    "",
                    "      // Do not append semicolon after the only JSX element in a program",
                    "      return [",
                    "        print(\"expression\"),",
                    "        isTheOnlyJsxElementInMarkdown(options, path) ? \"\" : semi,",
                    "        danglingComment ? [\" \", danglingComment] : \"\",",
                    "      ];",
                    "    }",
                    "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
                    "    case \"ParenthesizedExpression\": {",
                    "      const shouldHug =",
                    "        !hasComment(node.expression) &&",
                    "        (node.expression.type === \"ObjectExpression\" ||",
                    "          node.expression.type === \"ArrayExpression\");",
                    "      if (shouldHug) {",
                    "        return [\"(\", print(\"expression\"), \")\"];",
                    "      }",
                    "      return group([",
                    "        \"(\",",
                    "        indent([softline, print(\"expression\")]),",
                    "        softline,",
                    "        \")\",",
                    "      ]);",
                    "    }",
                    "    case \"AssignmentExpression\":",
                    "      return printAssignmentExpression(path, options, print);",
                    "    case \"VariableDeclarator\":",
                    "      return printVariableDeclarator(path, options, print);",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "      return printBinaryishExpression(path, options, print);",
                    "    case \"AssignmentPattern\":",
                    "      return [print(\"left\"), \" = \", print(\"right\")];",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"MemberExpression\": {",
                    "      return printMemberExpression(path, options, print);",
                    "    }",
                    "    case \"MetaProperty\":",
                    "      return [print(\"meta\"), \".\", print(\"property\")];",
                    "    case \"BindExpression\":",
                    "      if (node.object) {",
                    "        parts.push(print(\"object\"));",
                    "      }",
                    "",
                    "      parts.push(",
                    "        group(",
                    "          indent([softline, printBindExpressionCallee(path, options, print)])",
                    "        )",
                    "      );",
                    "",
                    "      return parts;",
                    "    case \"Identifier\": {",
                    "      return [",
                    "        node.name,",
                    "        printOptionalToken(path),",
                    "        printDefiniteToken(path),",
                    "        printTypeAnnotation(path, options, print),",
                    "      ];",
                    "    }",
                    "    case \"V8IntrinsicIdentifier\":",
                    "      return [\"%\", node.name];",
                    "    case \"SpreadElement\":",
                    "    case \"SpreadElementPattern\":",
                    "    case \"SpreadProperty\":",
                    "    case \"SpreadPropertyPattern\":",
                    "    case \"RestElement\":",
                    "      return printRestSpread(path, options, print);",
                    "    case \"FunctionDeclaration\":",
                    "    case \"FunctionExpression\":",
                    "      return printFunction(path, print, options, args);",
                    "    case \"ArrowFunctionExpression\":",
                    "      return printArrowFunction(path, options, print, args);",
                    "    case \"YieldExpression\":",
                    "      parts.push(\"yield\");",
                    "",
                    "      if (node.delegate) {",
                    "        parts.push(\"*\");",
                    "      }",
                    "      if (node.argument) {",
                    "        parts.push(\" \", print(\"argument\"));",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"AwaitExpression\": {",
                    "      parts.push(\"await\");",
                    "      if (node.argument) {",
                    "        parts.push(\" \", print(\"argument\"));",
                    "        const parent = path.getParentNode();",
                    "        if (",
                    "          (isCallExpression(parent) && parent.callee === node) ||",
                    "          (isMemberExpression(parent) && parent.object === node)",
                    "        ) {",
                    "          parts = [indent([softline, ...parts]), softline];",
                    "          const parentAwaitOrBlock = path.findAncestor(",
                    "            (node) =>",
                    "              node.type === \"AwaitExpression\" || node.type === \"BlockStatement\"",
                    "          );",
                    "          if (",
                    "            !parentAwaitOrBlock ||",
                    "            parentAwaitOrBlock.type !== \"AwaitExpression\"",
                    "          ) {",
                    "            return group(parts);",
                    "          }",
                    "        }",
                    "      }",
                    "      return parts;",
                    "    }",
                    "    case \"ExportDefaultDeclaration\":",
                    "    case \"ExportNamedDeclaration\":",
                    "      return printExportDeclaration(path, options, print);",
                    "    case \"ExportAllDeclaration\":",
                    "      return printExportAllDeclaration(path, options, print);",
                    "    case \"ImportDeclaration\":",
                    "      return printImportDeclaration(path, options, print);",
                    "    case \"ImportSpecifier\":",
                    "    case \"ExportSpecifier\":",
                    "    case \"ImportNamespaceSpecifier\":",
                    "    case \"ExportNamespaceSpecifier\":",
                    "    case \"ImportDefaultSpecifier\":",
                    "    case \"ExportDefaultSpecifier\":",
                    "      return printModuleSpecifier(path, options, print);",
                    "    case \"ImportAttribute\":",
                    "      return [print(\"key\"), \": \", print(\"value\")];",
                    "    case \"Import\":",
                    "      return \"import\";",
                    "    case \"BlockStatement\":",
                    "    case \"StaticBlock\":",
                    "    case \"ClassBody\":",
                    "      return printBlock(path, options, print);",
                    "    case \"ThrowStatement\":",
                    "      return printThrowStatement(path, options, print);",
                    "    case \"ReturnStatement\":",
                    "      return printReturnStatement(path, options, print);",
                    "    case \"NewExpression\":",
                    "    case \"ImportExpression\":",
                    "    case \"OptionalCallExpression\":",
                    "    case \"CallExpression\":",
                    "      return printCallExpression(path, options, print);",
                    "",
                    "    case \"ObjectExpression\":",
                    "    case \"ObjectPattern\":",
                    "    case \"RecordExpression\":",
                    "      return printObject(path, options, print);",
                    "    // Babel 6",
                    "    case \"ObjectProperty\": // Non-standard AST node type.",
                    "    case \"Property\":",
                    "      if (node.method || node.kind === \"get\" || node.kind === \"set\") {",
                    "        return printMethod(path, options, print);",
                    "      }",
                    "      return printProperty(path, options, print);",
                    "    case \"ObjectMethod\":",
                    "      return printMethod(path, options, print);",
                    "    case \"Decorator\":",
                    "      return [\"@\", print(\"expression\")];",
                    "    case \"ArrayExpression\":",
                    "    case \"ArrayPattern\":",
                    "    case \"TupleExpression\":",
                    "      return printArray(path, options, print);",
                    "    case \"SequenceExpression\": {",
                    "      const parent = path.getParentNode(0);",
                    "      if (",
                    "        parent.type === \"ExpressionStatement\" ||",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        // For ExpressionStatements and for-loop heads, which are among",
                    "        // the few places a SequenceExpression appears unparenthesized, we want",
                    "        // to indent expressions after the first.",
                    "        const parts = [];",
                    "        path.each((expressionPath, index) => {",
                    "          if (index === 0) {",
                    "            parts.push(print());",
                    "          } else {",
                    "            parts.push(\",\", indent([line, print()]));",
                    "          }",
                    "        }, \"expressions\");",
                    "        return group(parts);",
                    "      }",
                    "      return group(join([\",\", line], path.map(print, \"expressions\")));",
                    "    }",
                    "    case \"ThisExpression\":",
                    "      return \"this\";",
                    "    case \"Super\":",
                    "      return \"super\";",
                    "    case \"Directive\":",
                    "      return [print(\"value\"), semi]; // Babel 6",
                    "    case \"DirectiveLiteral\":",
                    "      return printDirective(node.extra.raw, options);",
                    "    case \"UnaryExpression\":",
                    "      parts.push(node.operator);",
                    "",
                    "      if (/[a-z]$/.test(node.operator)) {",
                    "        parts.push(\" \");",
                    "      }",
                    "",
                    "      if (hasComment(node.argument)) {",
                    "        parts.push(",
                    "          group([\"(\", indent([softline, print(\"argument\")]), softline, \")\"])",
                    "        );",
                    "      } else {",
                    "        parts.push(print(\"argument\"));",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"UpdateExpression\":",
                    "      parts.push(print(\"argument\"), node.operator);",
                    "",
                    "      if (node.prefix) {",
                    "        parts.reverse();",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"ConditionalExpression\":",
                    "      return printTernary(path, options, print);",
                    "    case \"VariableDeclaration\": {",
                    "      const printed = path.map(print, \"declarations\");",
                    "",
                    "      // We generally want to terminate all variable declarations with a",
                    "      // semicolon, except when they in the () part of for loops.",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      const isParentForLoop =",
                    "        parentNode.type === \"ForStatement\" ||",
                    "        parentNode.type === \"ForInStatement\" ||",
                    "        parentNode.type === \"ForOfStatement\";",
                    "",
                    "      const hasValue = node.declarations.some((decl) => decl.init);",
                    "",
                    "      let firstVariable;",
                    "      if (printed.length === 1 && !hasComment(node.declarations[0])) {",
                    "        firstVariable = printed[0];",
                    "      } else if (printed.length > 0) {",
                    "        // Indent first var to comply with eslint one-var rule",
                    "        firstVariable = indent(printed[0]);",
                    "      }",
                    "",
                    "      parts = [",
                    "        node.declare ? \"declare \" : \"\",",
                    "        node.kind,",
                    "        firstVariable ? [\" \", firstVariable] : \"\",",
                    "        indent(",
                    "          printed",
                    "            .slice(1)",
                    "            .map((p) => [",
                    "              \",\",",
                    "              hasValue && !isParentForLoop ? hardline : line,",
                    "              p,",
                    "            ])",
                    "        ),",
                    "      ];",
                    "",
                    "      if (!(isParentForLoop && parentNode.body !== node)) {",
                    "        parts.push(semi);",
                    "      }",
                    "",
                    "      return group(parts);",
                    "    }",
                    "    case \"WithStatement\":",
                    "      return group([",
                    "        \"with (\",",
                    "        print(\"object\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "    case \"IfStatement\": {",
                    "      const con = adjustClause(node.consequent, print(\"consequent\"));",
                    "      const opening = group([",
                    "        \"if (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        con,",
                    "      ]);",
                    "",
                    "      parts.push(opening);",
                    "",
                    "      if (node.alternate) {",
                    "        const commentOnOwnLine =",
                    "          hasComment(",
                    "            node.consequent,",
                    "            CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                    "          ) || needsHardlineAfterDanglingComment(node);",
                    "        const elseOnSameLine =",
                    "          node.consequent.type === \"BlockStatement\" && !commentOnOwnLine;",
                    "        parts.push(elseOnSameLine ? \" \" : hardline);",
                    "",
                    "        if (hasComment(node, CommentCheckFlags.Dangling)) {",
                    "          parts.push(",
                    "            printDanglingComments(path, options, true),",
                    "            commentOnOwnLine ? hardline : \" \"",
                    "          );",
                    "        }",
                    "",
                    "        parts.push(",
                    "          \"else\",",
                    "          group(",
                    "            adjustClause(",
                    "              node.alternate,",
                    "              print(\"alternate\"),",
                    "              node.alternate.type === \"IfStatement\"",
                    "            )",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    case \"ForStatement\": {",
                    "      const body = adjustClause(node.body, print(\"body\"));",
                    "",
                    "      // We want to keep dangling comments above the loop to stay consistent.",
                    "      // Any comment positioned between the for statement and the parentheses",
                    "      // is going to be printed before the statement.",
                    "      const dangling = printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /* sameLine */ true",
                    "      );",
                    "      const printedComments = dangling ? [dangling, softline] : \"\";",
                    "",
                    "      if (!node.init && !node.test && !node.update) {",
                    "        return [printedComments, group([\"for (;;)\", body])];",
                    "      }",
                    "",
                    "      return [",
                    "        printedComments,",
                    "        group([",
                    "          \"for (\",",
                    "          group([",
                    "            indent([",
                    "              softline,",
                    "              print(\"init\"),",
                    "              \";\",",
                    "              line,",
                    "              print(\"test\"),",
                    "              \";\",",
                    "              line,",
                    "              print(\"update\"),",
                    "            ]),",
                    "            softline,",
                    "          ]),",
                    "          \")\",",
                    "          body,",
                    "        ]),",
                    "      ];",
                    "    }",
                    "    case \"WhileStatement\":",
                    "      return group([",
                    "        \"while (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "    case \"ForInStatement\":",
                    "      return group([",
                    "        \"for (\",",
                    "        print(\"left\"),",
                    "        \" in \",",
                    "        print(\"right\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "",
                    "    case \"ForOfStatement\":",
                    "      return group([",
                    "        \"for\",",
                    "        node.await ? \" await\" : \"\",",
                    "        \" (\",",
                    "        print(\"left\"),",
                    "        \" of \",",
                    "        print(\"right\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "",
                    "    case \"DoWhileStatement\": {",
                    "      const clause = adjustClause(node.body, print(\"body\"));",
                    "      const doBody = group([\"do\", clause]);",
                    "      parts = [doBody];",
                    "",
                    "      if (node.body.type === \"BlockStatement\") {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(hardline);",
                    "      }",
                    "      parts.push(",
                    "        \"while (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        semi",
                    "      );",
                    "",
                    "      return parts;",
                    "    }",
                    "    case \"DoExpression\":",
                    "      return [node.async ? \"async \" : \"\", \"do \", print(\"body\")];",
                    "    case \"BreakStatement\":",
                    "      parts.push(\"break\");",
                    "",
                    "      if (node.label) {",
                    "        parts.push(\" \", print(\"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return parts;",
                    "    case \"ContinueStatement\":",
                    "      parts.push(\"continue\");",
                    "",
                    "      if (node.label) {",
                    "        parts.push(\" \", print(\"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return parts;",
                    "    case \"LabeledStatement\":",
                    "      if (node.body.type === \"EmptyStatement\") {",
                    "        return [print(\"label\"), \":;\"];",
                    "      }",
                    "",
                    "      return [print(\"label\"), \": \", print(\"body\")];",
                    "    case \"TryStatement\":",
                    "      return [",
                    "        \"try \",",
                    "        print(\"block\"),",
                    "        node.handler ? [\" \", print(\"handler\")] : \"\",",
                    "        node.finalizer ? [\" finally \", print(\"finalizer\")] : \"\",",
                    "      ];",
                    "    case \"CatchClause\":",
                    "      if (node.param) {",
                    "        const parameterHasComments = hasComment(",
                    "          node.param,",
                    "          (comment) =>",
                    "            !isBlockComment(comment) ||",
                    "            (comment.leading &&",
                    "              hasNewline(options.originalText, locEnd(comment))) ||",
                    "            (comment.trailing &&",
                    "              hasNewline(options.originalText, locStart(comment), {",
                    "                backwards: true,",
                    "              }))",
                    "        );",
                    "        const param = print(\"param\");",
                    "",
                    "        return [",
                    "          \"catch \",",
                    "          parameterHasComments",
                    "            ? [\"(\", indent([softline, param]), softline, \") \"]",
                    "            : [\"(\", param, \") \"],",
                    "          print(\"body\"),",
                    "        ];",
                    "      }",
                    "",
                    "      return [\"catch \", print(\"body\")];",
                    "    // Note: ignoring n.lexical because it has no printing consequences.",
                    "    case \"SwitchStatement\":",
                    "      return [",
                    "        group([",
                    "          \"switch (\",",
                    "          indent([softline, print(\"discriminant\")]),",
                    "          softline,",
                    "          \")\",",
                    "        ]),",
                    "        \" {\",",
                    "        node.cases.length > 0",
                    "          ? indent([",
                    "              hardline,",
                    "              join(",
                    "                hardline,",
                    "                path.map((casePath, index, cases) => {",
                    "                  const caseNode = casePath.getValue();",
                    "                  return [",
                    "                    print(),",
                    "                    index !== cases.length - 1 &&",
                    "                    isNextLineEmpty(caseNode, options)",
                    "                      ? hardline",
                    "                      : \"\",",
                    "                  ];",
                    "                }, \"cases\")",
                    "              ),",
                    "            ])",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "    case \"SwitchCase\": {",
                    "      if (node.test) {",
                    "        parts.push(\"case \", print(\"test\"), \":\");",
                    "      } else {",
                    "        parts.push(\"default:\");",
                    "      }",
                    "",
                    "      if (hasComment(node, CommentCheckFlags.Dangling)) {",
                    "        parts.push(\" \", printDanglingComments(path, options, true));",
                    "      }",
                    "",
                    "      const consequent = node.consequent.filter(",
                    "        (node) => node.type !== \"EmptyStatement\"",
                    "      );",
                    "",
                    "      if (consequent.length > 0) {",
                    "        const cons = printSwitchCaseConsequent(path, options, print);",
                    "",
                    "        parts.push(",
                    "          consequent.length === 1 && consequent[0].type === \"BlockStatement\"",
                    "            ? [\" \", cons]",
                    "            : indent([hardline, cons])",
                    "        );",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    // JSX extensions below.",
                    "    case \"DebuggerStatement\":",
                    "      return [\"debugger\", semi];",
                    "",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\":",
                    "      return printClass(path, options, print);",
                    "    case \"ClassMethod\":",
                    "    case \"ClassPrivateMethod\":",
                    "    case \"MethodDefinition\":",
                    "      return printClassMethod(path, options, print);",
                    "    case \"ClassProperty\":",
                    "    case \"PropertyDefinition\":",
                    "    case \"ClassPrivateProperty\":",
                    "    case \"ClassAccessorProperty\":",
                    "    case \"AccessorProperty\":",
                    "      return printClassProperty(path, options, print);",
                    "    case \"TemplateElement\":",
                    "      return replaceTextEndOfLine(node.value.raw);",
                    "    case \"TemplateLiteral\":",
                    "      return printTemplateLiteral(path, print, options);",
                    "    case \"TaggedTemplateExpression\":",
                    "      return [print(\"tag\"), print(\"typeParameters\"), print(\"quasi\")];",
                    "    case \"PrivateIdentifier\":",
                    "      return [\"#\", print(\"name\")];",
                    "    case \"PrivateName\":",
                    "      return [\"#\", print(\"id\")];",
                    "",
                    "    case \"InterpreterDirective\":",
                    "      parts.push(\"#!\", node.value, hardline);",
                    "",
                    "      if (isNextLineEmpty(node, options)) {",
                    "        parts.push(hardline);",
                    "      }",
                    "",
                    "      return parts;",
                    "",
                    "    // For hack-style pipeline",
                    "    case \"TopicReference\":",
                    "      return \"%\";",
                    "",
                    "    case \"ArgumentPlaceholder\":",
                    "      return \"?\";",
                    "",
                    "    case \"ModuleExpression\": {",
                    "      parts.push(\"module {\");",
                    "      const printed = print(\"body\");",
                    "      if (printed) {",
                    "        parts.push(indent([hardline, printed]), hardline);",
                    "      }",
                    "      parts.push(\"}\");",
                    "      return parts;",
                    "    }",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown type: \" + JSON.stringify(node.type));",
                    "  }",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return (",
                    "    node.type &&",
                    "    !isBlockComment(node) &&",
                    "    !isLineComment(node) &&",
                    "    node.type !== \"EmptyStatement\" &&",
                    "    node.type !== \"TemplateElement\" &&",
                    "    node.type !== \"Import\" &&",
                    "    // `babel-ts` don't have similar node for `class Foo { bar() /* bat */; }`",
                    "    node.type !== \"TSEmptyBodyFunctionExpression\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  embed,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore(path) {",
                    "    return hasIgnoreComment(path) || hasJsxIgnoreComment(path);",
                    "  },",
                    "  willPrintOwnComments: handleComments.willPrintOwnComments,",
                    "  canAttachComment,",
                    "  printComment,",
                    "  isBlockComment,",
                    "  handleComments: {",
                    "    // TODO: Make this as default behavior",
                    "    avoidAstMutation: true,",
                    "    ownLine: handleComments.handleOwnLineComment,",
                    "    endOfLine: handleComments.handleEndOfLineComment,",
                    "    remaining: handleComments.handleRemainingComment,",
                    "  },",
                    "  getCommentChildNodes: handleComments.getCommentChildNodes,",
                    "};"
                ]
            },
            "embed": {
                "css.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { indent, hardline, softline },",
                        "  utils: { mapDoc, replaceEndOfLine, cleanDoc },",
                        "} = require(\"../../document/index.js\");",
                        "const { printTemplateExpressions } = require(\"../print/template-literal.js\");",
                        "",
                        "function format(path, print, textToDoc) {",
                        "  const node = path.getValue();",
                        "",
                        "  // Get full template literal with expressions replaced by placeholders",
                        "  const rawQuasis = node.quasis.map((q) => q.value.raw);",
                        "  let placeholderID = 0;",
                        "  const text = rawQuasis.reduce(",
                        "    (prevVal, currVal, idx) =>",
                        "      idx === 0",
                        "        ? currVal",
                        "        : prevVal +",
                        "          \"@prettier-placeholder-\" +",
                        "          placeholderID++ +",
                        "          \"-id\" +",
                        "          currVal,",
                        "    \"\"",
                        "  );",
                        "  const doc = textToDoc(",
                        "    text,",
                        "    { parser: \"scss\" },",
                        "    { stripTrailingHardline: true }",
                        "  );",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  return transformCssDoc(doc, node, expressionDocs);",
                        "}",
                        "",
                        "function transformCssDoc(quasisDoc, parentNode, expressionDocs) {",
                        "  const isEmpty =",
                        "    parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();",
                        "  if (isEmpty) {",
                        "    return \"``\";",
                        "  }",
                        "",
                        "  const newDoc = replacePlaceholders(quasisDoc, expressionDocs);",
                        "  /* istanbul ignore if */",
                        "  if (!newDoc) {",
                        "    throw new Error(\"Couldn't insert all the expressions\");",
                        "  }",
                        "  return [\"`\", indent([hardline, newDoc]), softline, \"`\"];",
                        "}",
                        "",
                        "// Search all the placeholders in the quasisDoc tree",
                        "// and replace them with the expression docs one by one",
                        "// returns a new doc with all the placeholders replaced,",
                        "// or null if it couldn't replace any expression",
                        "function replacePlaceholders(quasisDoc, expressionDocs) {",
                        "  if (!isNonEmptyArray(expressionDocs)) {",
                        "    return quasisDoc;",
                        "  }",
                        "  let replaceCounter = 0;",
                        "  const newDoc = mapDoc(cleanDoc(quasisDoc), (doc) => {",
                        "    if (typeof doc !== \"string\" || !doc.includes(\"@prettier-placeholder\")) {",
                        "      return doc;",
                        "    }",
                        "    // When we have multiple placeholders in one line, like:",
                        "    // ${Child}${Child2}:not(:first-child)",
                        "    return doc.split(/@prettier-placeholder-(\\d+)-id/).map((component, idx) => {",
                        "      // The placeholder is always at odd indices",
                        "      if (idx % 2 === 0) {",
                        "        return replaceEndOfLine(component);",
                        "      }",
                        "",
                        "      // The component will always be a number at odd index",
                        "      replaceCounter++;",
                        "      return expressionDocs[component];",
                        "    });",
                        "  });",
                        "  return expressionDocs.length === replaceCounter ? newDoc : null;",
                        "}",
                        "",
                        "module.exports = format;"
                    ]
                },
                "graphql.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { indent, join, hardline },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  escapeTemplateCharacters,",
                        "  printTemplateExpressions,",
                        "} = require(\"../print/template-literal.js\");",
                        "",
                        "function format(path, print, textToDoc) {",
                        "  const node = path.getValue();",
                        "",
                        "  const numQuasis = node.quasis.length;",
                        "  if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {",
                        "    return \"``\";",
                        "  }",
                        "",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  const parts = [];",
                        "",
                        "  for (let i = 0; i < numQuasis; i++) {",
                        "    const templateElement = node.quasis[i];",
                        "    const isFirst = i === 0;",
                        "    const isLast = i === numQuasis - 1;",
                        "    const text = templateElement.value.cooked;",
                        "",
                        "    const lines = text.split(\"\\n\");",
                        "    const numLines = lines.length;",
                        "    const expressionDoc = expressionDocs[i];",
                        "",
                        "    const startsWithBlankLine =",
                        "      numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";",
                        "    const endsWithBlankLine =",
                        "      numLines > 2 &&",
                        "      lines[numLines - 1].trim() === \"\" &&",
                        "      lines[numLines - 2].trim() === \"\";",
                        "",
                        "    const commentsAndWhitespaceOnly = lines.every((line) =>",
                        "      /^\\s*(?:#[^\\n\\r]*)?$/.test(line)",
                        "    );",
                        "",
                        "    // Bail out if an interpolation occurs within a comment.",
                        "    if (!isLast && /#[^\\n\\r]*$/.test(lines[numLines - 1])) {",
                        "      return null;",
                        "    }",
                        "",
                        "    let doc = null;",
                        "",
                        "    if (commentsAndWhitespaceOnly) {",
                        "      doc = printGraphqlComments(lines);",
                        "    } else {",
                        "      doc = textToDoc(",
                        "        text,",
                        "        { parser: \"graphql\" },",
                        "        { stripTrailingHardline: true }",
                        "      );",
                        "    }",
                        "",
                        "    if (doc) {",
                        "      doc = escapeTemplateCharacters(doc, false);",
                        "      if (!isFirst && startsWithBlankLine) {",
                        "        parts.push(\"\");",
                        "      }",
                        "      parts.push(doc);",
                        "      if (!isLast && endsWithBlankLine) {",
                        "        parts.push(\"\");",
                        "      }",
                        "    } else if (!isFirst && !isLast && startsWithBlankLine) {",
                        "      parts.push(\"\");",
                        "    }",
                        "",
                        "    if (expressionDoc) {",
                        "      parts.push(expressionDoc);",
                        "    }",
                        "  }",
                        "",
                        "  return [\"`\", indent([hardline, join(hardline, parts)]), hardline, \"`\"];",
                        "}",
                        "",
                        "function printGraphqlComments(lines) {",
                        "  const parts = [];",
                        "  let seenComment = false;",
                        "",
                        "  const array = lines.map((textLine) => textLine.trim());",
                        "  for (const [i, textLine] of array.entries()) {",
                        "    // Lines are either whitespace only, or a comment (with potential whitespace",
                        "    // around it). Drop whitespace-only lines.",
                        "    if (textLine === \"\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (array[i - 1] === \"\" && seenComment) {",
                        "      // If a non-first comment is preceded by a blank (whitespace only) line,",
                        "      // add in a blank line.",
                        "      parts.push([hardline, textLine]);",
                        "    } else {",
                        "      parts.push(textLine);",
                        "    }",
                        "",
                        "    seenComment = true;",
                        "  }",
                        "",
                        "  // If `lines` was whitespace only, return `null`.",
                        "  return parts.length === 0 ? null : join(hardline, parts);",
                        "}",
                        "",
                        "module.exports = format;"
                    ]
                },
                "html.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { indent, line, hardline, group },",
                        "  utils: { mapDoc },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  printTemplateExpressions,",
                        "  uncookTemplateElementValue,",
                        "} = require(\"../print/template-literal.js\");",
                        "",
                        "// The counter is needed to distinguish nested embeds.",
                        "let htmlTemplateLiteralCounter = 0;",
                        "function format(path, print, textToDoc, options, { parser }) {",
                        "  const node = path.getValue();",
                        "  const counter = htmlTemplateLiteralCounter;",
                        "  htmlTemplateLiteralCounter = (htmlTemplateLiteralCounter + 1) >>> 0;",
                        "",
                        "  const composePlaceholder = (index) =>",
                        "    `PRETTIER_HTML_PLACEHOLDER_${index}_${counter}_IN_JS`;",
                        "",
                        "  const text = node.quasis",
                        "    .map((quasi, index, quasis) =>",
                        "      index === quasis.length - 1",
                        "        ? quasi.value.cooked",
                        "        : quasi.value.cooked + composePlaceholder(index)",
                        "    )",
                        "    .join(\"\");",
                        "",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  if (expressionDocs.length === 0 && text.trim().length === 0) {",
                        "    return \"``\";",
                        "  }",
                        "",
                        "  const placeholderRegex = new RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");",
                        "  let topLevelCount = 0;",
                        "  const doc = textToDoc(",
                        "    text,",
                        "    {",
                        "      parser,",
                        "      __onHtmlRoot(root) {",
                        "        topLevelCount = root.children.length;",
                        "      },",
                        "    },",
                        "    { stripTrailingHardline: true }",
                        "  );",
                        "",
                        "  const contentDoc = mapDoc(doc, (doc) => {",
                        "    if (typeof doc !== \"string\") {",
                        "      return doc;",
                        "    }",
                        "",
                        "    const parts = [];",
                        "",
                        "    const components = doc.split(placeholderRegex);",
                        "    for (let i = 0; i < components.length; i++) {",
                        "      let component = components[i];",
                        "",
                        "      if (i % 2 === 0) {",
                        "        if (component) {",
                        "          component = uncookTemplateElementValue(component);",
                        "          if (options.__embeddedInHtml) {",
                        "            component = component.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\");",
                        "          }",
                        "          parts.push(component);",
                        "        }",
                        "        continue;",
                        "      }",
                        "",
                        "      const placeholderIndex = Number(component);",
                        "      parts.push(expressionDocs[placeholderIndex]);",
                        "    }",
                        "",
                        "    return parts;",
                        "  });",
                        "",
                        "  const leadingWhitespace = /^\\s/.test(text) ? \" \" : \"\";",
                        "  const trailingWhitespace = /\\s$/.test(text) ? \" \" : \"\";",
                        "",
                        "  const linebreak =",
                        "    options.htmlWhitespaceSensitivity === \"ignore\"",
                        "      ? hardline",
                        "      : leadingWhitespace && trailingWhitespace",
                        "      ? line",
                        "      : null;",
                        "",
                        "  if (linebreak) {",
                        "    return group([\"`\", indent([linebreak, group(contentDoc)]), linebreak, \"`\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    \"`\",",
                        "    leadingWhitespace,",
                        "    topLevelCount > 1 ? indent(group(contentDoc)) : group(contentDoc),",
                        "    trailingWhitespace,",
                        "    \"`\",",
                        "  ]);",
                        "}",
                        "",
                        "module.exports = format;"
                    ]
                },
                "markdown.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { indent, softline, literalline, dedentToRoot },",
                        "} = require(\"../../document/index.js\");",
                        "const { escapeTemplateCharacters } = require(\"../print/template-literal.js\");",
                        "",
                        "function format(path, print, textToDoc) {",
                        "  const node = path.getValue();",
                        "  let text = node.quasis[0].value.raw.replace(",
                        "    /((?:\\\\\\\\)*)\\\\`/g,",
                        "    (_, backslashes) => \"\\\\\".repeat(backslashes.length / 2) + \"`\"",
                        "  );",
                        "  const indentation = getIndentation(text);",
                        "  const hasIndent = indentation !== \"\";",
                        "  if (hasIndent) {",
                        "    text = text.replace(new RegExp(`^${indentation}`, \"gm\"), \"\");",
                        "  }",
                        "  const doc = escapeTemplateCharacters(",
                        "    textToDoc(",
                        "      text,",
                        "      { parser: \"markdown\", __inJsTemplate: true },",
                        "      { stripTrailingHardline: true }",
                        "    ),",
                        "    true",
                        "  );",
                        "  return [",
                        "    \"`\",",
                        "    hasIndent ? indent([softline, doc]) : [literalline, dedentToRoot(doc)],",
                        "    softline,",
                        "    \"`\",",
                        "  ];",
                        "}",
                        "",
                        "function getIndentation(str) {",
                        "  const firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);",
                        "  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];",
                        "}",
                        "",
                        "module.exports = format;"
                    ]
                }
            },
            "parse": {
                "acorn-and-espree.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const acorn = require(\"./acorn.js\");",
                        "const espree = require(\"./espree.js\");",
                        "",
                        "module.exports = {",
                        "  parsers: {",
                        "    acorn,",
                        "    espree,",
                        "  },",
                        "};"
                    ]
                },
                "acorn.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const tryCombinations = require(\"../../utils/try-combinations.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "",
                        "/** @type {import(\"acorn\").Options} */",
                        "const parseOptions = {",
                        "  ecmaVersion: \"latest\",",
                        "  sourceType: \"module\",",
                        "  allowReserved: true,",
                        "  allowReturnOutsideFunction: true,",
                        "  allowImportExportEverywhere: true,",
                        "  allowAwaitOutsideFunction: true,",
                        "  allowSuperOutsideMethod: true,",
                        "  allowHashBang: true,",
                        "  locations: true,",
                        "  ranges: true,",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, loc } = error;",
                        "",
                        "  /* istanbul ignore next */",
                        "  if (!loc) {",
                        "    return error;",
                        "  }",
                        "",
                        "  const { line, column } = loc;",
                        "",
                        "  return createError(message.replace(/ \\(\\d+:\\d+\\)$/, \"\"), {",
                        "    start: { line, column: column + 1 },",
                        "  });",
                        "}",
                        "",
                        "let parser;",
                        "const getParser = () => {",
                        "  if (!parser) {",
                        "    const { Parser: AcornParser } = require(\"acorn\");",
                        "    const acornJsx = require(\"acorn-jsx\");",
                        "    parser = AcornParser.extend(acornJsx());",
                        "  }",
                        "  return parser;",
                        "};",
                        "",
                        "function parseWithOptions(text, sourceType) {",
                        "  const parser = getParser();",
                        "",
                        "  const comments = [];",
                        "  const tokens = [];",
                        "",
                        "  /** @type {any} */",
                        "  const ast = parser.parse(text, {",
                        "    ...parseOptions,",
                        "    sourceType,",
                        "    onComment: comments,",
                        "    onToken: tokens,",
                        "  });",
                        "  ast.comments = comments;",
                        "  ast.tokens = tokens;",
                        "",
                        "  return ast;",
                        "}",
                        "",
                        "function parse(text, parsers, options = {}) {",
                        "  const { result: ast, error: moduleParseError } = tryCombinations(",
                        "    () => parseWithOptions(text, /* sourceType */ \"module\"),",
                        "    () => parseWithOptions(text, /* sourceType */ \"script\")",
                        "  );",
                        "",
                        "  if (!ast) {",
                        "    // throw the error for `module` parsing",
                        "    throw createParseError(moduleParseError);",
                        "  }",
                        "",
                        "  options.originalText = text;",
                        "  return postprocess(ast, options);",
                        "}",
                        "",
                        "module.exports = createParser(parse);"
                    ]
                },
                "angular.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "",
                        "function createParser(_parse) {",
                        "  const parse = (text, parsers, options) => {",
                        "    const ngEstreeParser = require(\"angular-estree-parser\");",
                        "    const node = _parse(text, ngEstreeParser);",
                        "    return {",
                        "      type: \"NGRoot\",",
                        "      node:",
                        "        options.parser === \"__ng_action\" && node.type !== \"NGChainedExpression\"",
                        "          ? { ...node, type: \"NGChainedExpression\", expressions: [node] }",
                        "          : node,",
                        "    };",
                        "  };",
                        "  return { astFormat: \"estree\", parse, locStart, locEnd };",
                        "}",
                        "",
                        "module.exports = {",
                        "  parsers: {",
                        "    __ng_action: createParser((text, ng) => ng.parseAction(text)),",
                        "    __ng_binding: createParser((text, ng) => ng.parseBinding(text)),",
                        "    __ng_interpolation: createParser((text, ng) => ng.parseInterpolation(text)),",
                        "    __ng_directive: createParser((text, ng) => ng.parseTemplateBindings(text)),",
                        "  },",
                        "};"
                    ]
                },
                "babel.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const tryCombinations = require(\"../../utils/try-combinations.js\");",
                        "const getShebang = require(\"../utils/get-shebang.js\");",
                        "const getNextNonSpaceNonCommentCharacterIndexWithStartIndex = require(\"../../utils/text/get-next-non-space-non-comment-character-index-with-start-index.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const createBabelParseError = require(\"./utils/create-babel-parse-error.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "const jsonParsers = require(\"./json.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"@babel/parser\").parse | import(\"@babel/parser\").parseExpression} Parse",
                        " * @typedef {import(\"@babel/parser\").ParserOptions} ParserOptions",
                        " * @typedef {import(\"@babel/parser\").ParserPlugin} ParserPlugin",
                        " */",
                        "",
                        "/** @type {ParserOptions} */",
                        "const parseOptions = {",
                        "  sourceType: \"module\",",
                        "  allowImportExportEverywhere: true,",
                        "  allowReturnOutsideFunction: true,",
                        "  allowSuperOutsideMethod: true,",
                        "  allowUndeclaredExports: true,",
                        "  errorRecovery: true,",
                        "  createParenthesizedExpressions: true,",
                        "  plugins: [",
                        "    // When adding a plugin, please add a test in `tests/format/js/babel-plugins`,",
                        "    // To remove plugins, remove it here and run `yarn test tests/format/js/babel-plugins` to verify",
                        "    \"doExpressions\",",
                        "    \"exportDefaultFrom\",",
                        "    \"functionBind\",",
                        "    \"functionSent\",",
                        "    \"throwExpressions\",",
                        "    \"partialApplication\",",
                        "    [\"decorators\", { decoratorsBeforeExport: false }],",
                        "    \"importAssertions\",",
                        "    \"decimal\",",
                        "    \"moduleBlocks\",",
                        "    \"asyncDoExpressions\",",
                        "    \"regexpUnicodeSets\",",
                        "    \"destructuringPrivate\",",
                        "    \"decoratorAutoAccessors\",",
                        "  ],",
                        "  tokens: true,",
                        "  ranges: true,",
                        "};",
                        "",
                        "/** @type {ParserPlugin} */",
                        "const recordAndTuplePlugin = [\"recordAndTuple\", { syntaxType: \"hash\" }];",
                        "",
                        "/** @type {ParserPlugin} */",
                        "const v8intrinsicPlugin = \"v8intrinsic\";",
                        "",
                        "/** @type {Array<ParserPlugin>} */",
                        "const pipelineOperatorPlugins = [",
                        "  [\"pipelineOperator\", { proposal: \"hack\", topicToken: \"%\" }],",
                        "  [\"pipelineOperator\", { proposal: \"minimal\" }],",
                        "  [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                        "];",
                        "const appendPlugins = (plugins, options = parseOptions) => ({",
                        "  ...options,",
                        "  plugins: [...options.plugins, ...plugins],",
                        "});",
                        "",
                        "// Similar to babel",
                        "// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67",
                        "const FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;",
                        "function isFlowFile(text, options) {",
                        "  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const shebang = getShebang(text);",
                        "  if (shebang) {",
                        "    text = text.slice(shebang.length);",
                        "  }",
                        "",
                        "  const firstNonSpaceNonCommentCharacterIndex =",
                        "    getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, 0);",
                        "",
                        "  if (firstNonSpaceNonCommentCharacterIndex !== false) {",
                        "    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);",
                        "  }",
                        "",
                        "  return FLOW_PRAGMA_REGEX.test(text);",
                        "}",
                        "",
                        "function parseWithOptions(parseMethod, text, options) {",
                        "  // Inline the require to avoid loading all the JS if we don't use it",
                        "  /** @type {Parse} */",
                        "  const parse = require(\"@babel/parser\")[parseMethod];",
                        "  const ast = parse(text, options);",
                        "  const error = ast.errors.find(",
                        "    (error) => !allowedMessageCodes.has(error.reasonCode)",
                        "  );",
                        "  if (error) {",
                        "    throw error;",
                        "  }",
                        "  return ast;",
                        "}",
                        "",
                        "function createParse(parseMethod, ...optionsCombinations) {",
                        "  return (text, parsers, opts = {}) => {",
                        "    if (",
                        "      (opts.parser === \"babel\" || opts.parser === \"__babel_estree\") &&",
                        "      isFlowFile(text, opts)",
                        "    ) {",
                        "      opts.parser = \"babel-flow\";",
                        "      return parseFlow(text, parsers, opts);",
                        "    }",
                        "",
                        "    let combinations = optionsCombinations;",
                        "    if (opts.__babelSourceType === \"script\") {",
                        "      combinations = combinations.map((options) => ({",
                        "        ...options,",
                        "        sourceType: \"script\",",
                        "      }));",
                        "    }",
                        "",
                        "    if (/#[[{]/.test(text)) {",
                        "      combinations = combinations.map((options) =>",
                        "        appendPlugins([recordAndTuplePlugin], options)",
                        "      );",
                        "    }",
                        "",
                        "    const shouldEnableV8intrinsicPlugin = /%[A-Z]/.test(text);",
                        "    if (text.includes(\"|>\")) {",
                        "      const conflictsPlugins = shouldEnableV8intrinsicPlugin",
                        "        ? [...pipelineOperatorPlugins, v8intrinsicPlugin]",
                        "        : pipelineOperatorPlugins;",
                        "      combinations = conflictsPlugins.flatMap((pipelineOperatorPlugin) =>",
                        "        combinations.map((options) =>",
                        "          appendPlugins([pipelineOperatorPlugin], options)",
                        "        )",
                        "      );",
                        "    } else if (shouldEnableV8intrinsicPlugin) {",
                        "      combinations = combinations.map((options) =>",
                        "        appendPlugins([v8intrinsicPlugin], options)",
                        "      );",
                        "    }",
                        "",
                        "    const { result: ast, error } = tryCombinations(",
                        "      ...combinations.map(",
                        "        (options) => () => parseWithOptions(parseMethod, text, options)",
                        "      )",
                        "    );",
                        "",
                        "    if (!ast) {",
                        "      throw createBabelParseError(error);",
                        "    }",
                        "",
                        "    opts.originalText = text;",
                        "    return postprocess(ast, opts);",
                        "  };",
                        "}",
                        "",
                        "const parse = createParse(\"parse\", appendPlugins([\"jsx\", \"flow\"]));",
                        "const parseFlow = createParse(",
                        "  \"parse\",",
                        "  appendPlugins([\"jsx\", [\"flow\", { all: true, enums: true }]])",
                        ");",
                        "const parseTypeScript = createParse(",
                        "  \"parse\",",
                        "  appendPlugins([\"jsx\", \"typescript\"]),",
                        "  appendPlugins([\"typescript\"])",
                        ");",
                        "const parseEstree = createParse(",
                        "  \"parse\",",
                        "  appendPlugins([\"jsx\", \"flow\", \"estree\"])",
                        ");",
                        "const parseExpression = createParse(\"parseExpression\", appendPlugins([\"jsx\"]));",
                        "",
                        "const parseTSExpression = createParse(",
                        "  \"parseExpression\",",
                        "  appendPlugins([\"typescript\"])",
                        ");",
                        "",
                        "// Error codes are defined in",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/parser/error-message.js",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/typescript/index.js#L69-L153",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/flow/index.js#L51-L140",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/jsx/index.js#L23-L39",
                        "const allowedMessageCodes = new Set([",
                        "  \"StrictNumericEscape\",",
                        "  \"StrictWith\",",
                        "  \"StrictOctalLiteral\",",
                        "  \"StrictDelete\",",
                        "  \"StrictEvalArguments\",",
                        "  \"StrictEvalArgumentsBinding\",",
                        "  \"StrictFunction\",",
                        "",
                        "  \"EmptyTypeArguments\",",
                        "  \"EmptyTypeParameters\",",
                        "  \"ConstructorHasTypeParameters\",",
                        "",
                        "  \"UnsupportedParameterPropertyKind\",",
                        "  \"UnexpectedParameterModifier\",",
                        "",
                        "  \"MixedLabeledAndUnlabeledElements\",",
                        "  \"InvalidTupleMemberLabel\",",
                        "",
                        "  \"NonClassMethodPropertyHasAbstractModifer\",",
                        "  \"ReadonlyForMethodSignature\",",
                        "  \"ClassMethodHasDeclare\",",
                        "  \"ClassMethodHasReadonly\",",
                        "  \"InvalidModifierOnTypeMember\",",
                        "  \"DuplicateAccessibilityModifier\",",
                        "  \"IndexSignatureHasDeclare\",",
                        "",
                        "  \"DecoratorExportClass\",",
                        "  \"ParamDupe\",",
                        "  \"InvalidDecimal\",",
                        "  \"RestTrailingComma\",",
                        "  \"UnsupportedParameterDecorator\",",
                        "  \"UnterminatedJsxContent\",",
                        "  \"UnexpectedReservedWord\",",
                        "  \"ModuleAttributesWithDuplicateKeys\",",
                        "  \"LineTerminatorBeforeArrow\",",
                        "  \"InvalidEscapeSequenceTemplate\",",
                        "  \"NonAbstractClassHasAbstractMethod\",",
                        "  \"UnsupportedPropertyDecorator\",",
                        "  \"OptionalTypeBeforeRequired\",",
                        "  \"PatternIsOptional\",",
                        "  \"OptionalBindingPattern\",",
                        "  \"DeclareClassFieldHasInitializer\",",
                        "  \"TypeImportCannotSpecifyDefaultAndNamed\",",
                        "  \"DeclareFunctionHasImplementation\",",
                        "  \"ConstructorClassField\",",
                        "",
                        "  \"VarRedeclaration\",",
                        "  \"InvalidPrivateFieldResolution\",",
                        "  \"DuplicateExport\",",
                        "]);",
                        "",
                        "const babel = createParser(parse);",
                        "const babelTs = createParser(parseTypeScript);",
                        "const babelExpression = createParser(parseExpression);",
                        "const babelTSExpression = createParser(parseTSExpression);",
                        "",
                        "// Export as a plugin so we can reuse the same bundle for UMD loading",
                        "module.exports = {",
                        "  parsers: {",
                        "    babel,",
                        "    \"babel-flow\": createParser(parseFlow),",
                        "    \"babel-ts\": babelTs,",
                        "    ...jsonParsers,",
                        "    /** @internal */",
                        "    __js_expression: babelExpression,",
                        "    /** for vue filter */",
                        "    __vue_expression: babelExpression,",
                        "    /** for vue filter written in TS */",
                        "    __vue_ts_expression: babelTSExpression,",
                        "    /** for vue event binding to handle semicolon */",
                        "    __vue_event_binding: babel,",
                        "    /** for vue event binding written in TS to handle semicolon */",
                        "    __vue_ts_event_binding: babelTs,",
                        "    /** verify that we can print this AST */",
                        "    __babel_estree: createParser(parseEstree),",
                        "  },",
                        "};"
                    ]
                },
                "espree.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const tryCombinations = require(\"../../utils/try-combinations.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const replaceHashbang = require(\"./utils/replace-hashbang.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "",
                        "/** @type {import(\"espree\").Options} */",
                        "const parseOptions = {",
                        "  ecmaVersion: \"latest\",",
                        "  range: true,",
                        "  loc: true,",
                        "  comment: true,",
                        "  tokens: true,",
                        "  sourceType: \"module\",",
                        "  ecmaFeatures: {",
                        "    jsx: true,",
                        "    globalReturn: true,",
                        "    impliedStrict: false,",
                        "  },",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, lineNumber, column } = error;",
                        "",
                        "  /* istanbul ignore next */",
                        "  if (typeof lineNumber !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, { start: { line: lineNumber, column } });",
                        "}",
                        "",
                        "function parse(originalText, parsers, options = {}) {",
                        "  const { parse } = require(\"espree\");",
                        "",
                        "  const textToParse = replaceHashbang(originalText);",
                        "  const { result: ast, error: moduleParseError } = tryCombinations(",
                        "    () => parse(textToParse, { ...parseOptions, sourceType: \"module\" }),",
                        "    () => parse(textToParse, { ...parseOptions, sourceType: \"script\" })",
                        "  );",
                        "",
                        "  if (!ast) {",
                        "    // throw the error for `module` parsing",
                        "    throw createParseError(moduleParseError);",
                        "  }",
                        "",
                        "  options.originalText = originalText;",
                        "  return postprocess(ast, options);",
                        "}",
                        "",
                        "module.exports = createParser(parse);"
                    ]
                },
                "flow.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const replaceHashbang = require(\"./utils/replace-hashbang.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "",
                        "// https://github.com/facebook/flow/tree/main/packages/flow-parser#options",
                        "// Keep this sync with `/scripts/sync-flow-test.js`",
                        "const parseOptions = {",
                        "  // `all_comments` (boolean, default `true`) - include a list of all comments from the whole program",
                        "  // all_comments: true,",
                        "  // `comments` (boolean, default `true`) - attach comments to AST nodes (`leadingComments` and `trailingComments`)",
                        "  comments: false,",
                        "  // `enums` (boolean, default `false`) - enable parsing of Flow enums",
                        "  enums: true,",
                        "  // `esproposal_decorators` (boolean, default `false`) - enable parsing of decorators",
                        "  esproposal_decorators: true,",
                        "  // `esproposal_export_star_as` (boolean, default `false`) - enable parsing of `export * as` syntax",
                        "  esproposal_export_star_as: true,",
                        "  // `types` (boolean, default `true`) - enable parsing of Flow types",
                        "  // types: true,",
                        "  // `use_strict` (boolean, default `false`) - treat the file as strict, without needing a \"use strict\" directive",
                        "  // use_strict: false,",
                        "  // `tokens` (boolean, default `false`) - include a list of all parsed tokens in a top-level `tokens` property",
                        "  tokens: true,",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const {",
                        "    message,",
                        "    loc: { start, end },",
                        "  } = error;",
                        "",
                        "  return createError(message, {",
                        "    start: { line: start.line, column: start.column + 1 },",
                        "    end: { line: end.line, column: end.column + 1 },",
                        "  });",
                        "}",
                        "",
                        "function parse(text, parsers, options = {}) {",
                        "  // Inline the require to avoid loading all the JS if we don't use it",
                        "  const { parse } = require(\"flow-parser\");",
                        "  const ast = parse(replaceHashbang(text), parseOptions);",
                        "  const [error] = ast.errors;",
                        "  if (error) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  options.originalText = text;",
                        "  return postprocess(ast, options);",
                        "}",
                        "",
                        "// Export as a plugin so we can reuse the same bundle for UMD loading",
                        "module.exports = {",
                        "  parsers: {",
                        "    flow: createParser(parse),",
                        "  },",
                        "};"
                    ]
                },
                "json.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const isNonEmptyArray = require(\"../../utils/is-non-empty-array.js\");",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const createBabelParseError = require(\"./utils/create-babel-parse-error.js\");",
                        "",
                        "function createJsonParse(options = {}) {",
                        "  const { allowComments = true } = options;",
                        "",
                        "  return function parse(text /*, parsers, options*/) {",
                        "    const { parseExpression } = require(\"@babel/parser\");",
                        "    let ast;",
                        "    try {",
                        "      ast = parseExpression(text, {",
                        "        tokens: true,",
                        "        ranges: true,",
                        "      });",
                        "    } catch (error) {",
                        "      throw createBabelParseError(error);",
                        "    }",
                        "",
                        "    // @ts-expect-error",
                        "    if (!allowComments && isNonEmptyArray(ast.comments)) {",
                        "      // @ts-expect-error",
                        "      throw createJsonError(ast.comments[0], \"Comment\");",
                        "    }",
                        "",
                        "    assertJsonNode(ast);",
                        "",
                        "    return ast;",
                        "  };",
                        "}",
                        "",
                        "function createJsonError(node, description) {",
                        "  const [start, end] = [node.loc.start, node.loc.end].map(",
                        "    ({ line, column }) => ({",
                        "      line,",
                        "      column: column + 1,",
                        "    })",
                        "  );",
                        "  return createError(`${description} is not allowed in JSON.`, { start, end });",
                        "}",
                        "",
                        "function assertJsonNode(node) {",
                        "  switch (node.type) {",
                        "    case \"ArrayExpression\":",
                        "      for (const element of node.elements) {",
                        "        if (element !== null) {",
                        "          assertJsonNode(element);",
                        "        }",
                        "      }",
                        "",
                        "      return;",
                        "    case \"ObjectExpression\":",
                        "      for (const property of node.properties) {",
                        "        assertJsonNode(property);",
                        "      }",
                        "",
                        "      return;",
                        "    case \"ObjectProperty\":",
                        "      if (node.computed) {",
                        "        throw createJsonError(node.key, \"Computed key\");",
                        "      }",
                        "",
                        "      if (node.shorthand) {",
                        "        throw createJsonError(node.key, \"Shorthand property\");",
                        "      }",
                        "",
                        "      if (node.key.type !== \"Identifier\") {",
                        "        assertJsonNode(node.key);",
                        "      }",
                        "",
                        "      assertJsonNode(node.value);",
                        "",
                        "      return;",
                        "    case \"UnaryExpression\": {",
                        "      const { operator, argument } = node;",
                        "      if (operator !== \"+\" && operator !== \"-\") {",
                        "        throw createJsonError(node, `Operator '${node.operator}'`);",
                        "      }",
                        "",
                        "      if (",
                        "        argument.type === \"NumericLiteral\" ||",
                        "        (argument.type === \"Identifier\" &&",
                        "          (argument.name === \"Infinity\" || argument.name === \"NaN\"))",
                        "      ) {",
                        "        return;",
                        "      }",
                        "",
                        "      throw createJsonError(",
                        "        argument,",
                        "        `Operator '${operator}' before '${argument.type}'`",
                        "      );",
                        "    }",
                        "    case \"Identifier\":",
                        "      if (",
                        "        // JSON5 https://spec.json5.org/#numbers",
                        "        node.name !== \"Infinity\" &&",
                        "        node.name !== \"NaN\" &&",
                        "        // JSON6 https://github.com/d3x0r/JSON6",
                        "        node.name !== \"undefined\"",
                        "      ) {",
                        "        throw createJsonError(node, `Identifier '${node.name}'`);",
                        "      }",
                        "",
                        "      return;",
                        "    case \"TemplateLiteral\":",
                        "      if (isNonEmptyArray(node.expressions)) {",
                        "        throw createJsonError(",
                        "          node.expressions[0],",
                        "          \"'TemplateLiteral' with expression\"",
                        "        );",
                        "      }",
                        "",
                        "      for (const element of node.quasis) {",
                        "        assertJsonNode(element);",
                        "      }",
                        "",
                        "      return;",
                        "    case \"NullLiteral\":",
                        "    case \"BooleanLiteral\":",
                        "    case \"NumericLiteral\":",
                        "    case \"StringLiteral\":",
                        "    case \"TemplateElement\":",
                        "      return;",
                        "    default:",
                        "      throw createJsonError(node, `'${node.type}'`);",
                        "  }",
                        "}",
                        "",
                        "const parseJson = createJsonParse();",
                        "",
                        "const jsonParsers = {",
                        "  json: createParser({",
                        "    parse: parseJson,",
                        "    hasPragma() {",
                        "      return true;",
                        "    },",
                        "  }),",
                        "  json5: createParser(parseJson),",
                        "  \"json-stringify\": createParser({",
                        "    parse: createJsonParse({ allowComments: false }),",
                        "    astFormat: \"estree-json\",",
                        "  }),",
                        "};",
                        "",
                        "module.exports = jsonParsers;"
                    ]
                },
                "meriyah.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const tryCombinations = require(\"../../utils/try-combinations.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "",
                        "// https://github.com/meriyah/meriyah/blob/4676f60b6c149d7082bde2c9147f9ae2359c8075/src/parser.ts#L185",
                        "const parseOptions = {",
                        "  // Allow module code",
                        "  module: true,",
                        "  // Enable stage 3 support (ESNext)",
                        "  next: true,",
                        "  // Enable start and end offsets to each node",
                        "  ranges: true,",
                        "  // Enable web compatibility",
                        "  webcompat: true,",
                        "  // Enable line/column location information to each node",
                        "  loc: true,",
                        "  // Attach raw property to each literal and identifier node",
                        "  raw: true,",
                        "  // Enabled directives",
                        "  directives: true,",
                        "  // Allow return in the global scope",
                        "  globalReturn: true,",
                        "  // Enable implied strict mode",
                        "  impliedStrict: false,",
                        "  // Enable non-standard parenthesized expression node",
                        "  preserveParens: false,",
                        "  // Enable lexical binding and scope tracking",
                        "  lexical: false,",
                        "  // Adds a source attribute in every node\u2019s loc object when the locations option is `true`",
                        "  // source: '',",
                        "  // Distinguish Identifier from IdentifierPattern",
                        "  identifierPattern: false,",
                        "  // Enable React JSX parsing",
                        "  jsx: true,",
                        "  // Allow edge cases that deviate from the spec",
                        "  specDeviation: true,",
                        "  // Creates unique key for in ObjectPattern when key value are same",
                        "  uniqueKeyInPattern: false,",
                        "};",
                        "",
                        "function parseWithOptions(text, module) {",
                        "  const { parse } = require(\"meriyah\");",
                        "  const comments = [];",
                        "  const tokens = [];",
                        "",
                        "  /** @type {any} */",
                        "  const ast = parse(text, {",
                        "    ...parseOptions,",
                        "    module,",
                        "    onComment: comments,",
                        "    onToken: tokens,",
                        "  });",
                        "  ast.comments = comments;",
                        "  ast.tokens = tokens;",
                        "",
                        "  return ast;",
                        "}",
                        "",
                        "function createParseError(error) {",
                        "  let { message, line, column } = error;",
                        "",
                        "  const matches = (",
                        "    message.match(/^\\[(?<line>\\d+):(?<column>\\d+)]: (?<message>.*)$/) || {}",
                        "  ).groups;",
                        "",
                        "  if (matches) {",
                        "    message = matches.message;",
                        "",
                        "    /* istanbul ignore next */",
                        "    if (typeof line !== \"number\") {",
                        "      line = Number(matches.line);",
                        "      column = Number(matches.column);",
                        "    }",
                        "  }",
                        "",
                        "  /* istanbul ignore next */",
                        "  if (typeof line !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, { start: { line, column } });",
                        "}",
                        "",
                        "function parse(text, parsers, options = {}) {",
                        "  const { result: ast, error: moduleParseError } = tryCombinations(",
                        "    () => parseWithOptions(text, /* module */ true),",
                        "    () => parseWithOptions(text, /* module */ false)",
                        "  );",
                        "",
                        "  if (!ast) {",
                        "    // Throw the error for `module` parsing",
                        "    throw createParseError(moduleParseError);",
                        "  }",
                        "",
                        "  options.originalText = text;",
                        "  return postprocess(ast, options);",
                        "}",
                        "",
                        "module.exports = {",
                        "  parsers: {",
                        "    meriyah: createParser(parse),",
                        "  },",
                        "};"
                    ]
                },
                "parsers.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  // JS - Babel",
                        "  get babel() {",
                        "    return require(\"./babel.js\").parsers.babel;",
                        "  },",
                        "  get \"babel-flow\"() {",
                        "    return require(\"./babel.js\").parsers[\"babel-flow\"];",
                        "  },",
                        "  get \"babel-ts\"() {",
                        "    return require(\"./babel.js\").parsers[\"babel-ts\"];",
                        "  },",
                        "  get json() {",
                        "    return require(\"./babel.js\").parsers.json;",
                        "  },",
                        "  get json5() {",
                        "    return require(\"./babel.js\").parsers.json5;",
                        "  },",
                        "  get \"json-stringify\"() {",
                        "    return require(\"./babel.js\").parsers[\"json-stringify\"];",
                        "  },",
                        "  get __js_expression() {",
                        "    return require(\"./babel.js\").parsers.__js_expression;",
                        "  },",
                        "  get __vue_expression() {",
                        "    return require(\"./babel.js\").parsers.__vue_expression;",
                        "  },",
                        "  get __vue_ts_expression() {",
                        "    return require(\"./babel.js\").parsers.__vue_ts_expression;",
                        "  },",
                        "  get __vue_event_binding() {",
                        "    return require(\"./babel.js\").parsers.__vue_event_binding;",
                        "  },",
                        "  get __vue_ts_event_binding() {",
                        "    return require(\"./babel.js\").parsers.__vue_ts_event_binding;",
                        "  },",
                        "  // JS - Flow",
                        "  get flow() {",
                        "    return require(\"./flow.js\").parsers.flow;",
                        "  },",
                        "  // JS - TypeScript",
                        "  get typescript() {",
                        "    return require(\"./typescript.js\").parsers.typescript;",
                        "  },",
                        "  // JS - Angular Action",
                        "  get __ng_action() {",
                        "    return require(\"./angular.js\").parsers.__ng_action;",
                        "  },",
                        "  // JS - Angular Binding",
                        "  get __ng_binding() {",
                        "    return require(\"./angular.js\").parsers.__ng_binding;",
                        "  },",
                        "  // JS - Angular Interpolation",
                        "  get __ng_interpolation() {",
                        "    return require(\"./angular.js\").parsers.__ng_interpolation;",
                        "  },",
                        "  // JS - Angular Directive",
                        "  get __ng_directive() {",
                        "    return require(\"./angular.js\").parsers.__ng_directive;",
                        "  },",
                        "  // JS - acorn",
                        "  get acorn() {",
                        "    return require(\"./acorn-and-espree.js\").parsers.acorn;",
                        "  },",
                        "  // JS - espree",
                        "  get espree() {",
                        "    return require(\"./acorn-and-espree.js\").parsers.espree;",
                        "  },",
                        "  // JS - meriyah",
                        "  get meriyah() {",
                        "    return require(\"./meriyah.js\").parsers.meriyah;",
                        "  },",
                        "  // JS - Babel Estree",
                        "  get __babel_estree() {",
                        "    return require(\"./babel.js\").parsers.__babel_estree;",
                        "  },",
                        "};"
                    ]
                },
                "typescript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const tryCombinations = require(\"../../utils/try-combinations.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const replaceHashbang = require(\"./utils/replace-hashbang.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "",
                        "/** @type {import(\"@typescript-eslint/typescript-estree\").TSESTreeOptions} */",
                        "const parseOptions = {",
                        "  // `jest@<=26.4.2` rely on `loc`",
                        "  // https://github.com/facebook/jest/issues/10444",
                        "  loc: true,",
                        "  range: true,",
                        "  comment: true,",
                        "  jsx: true,",
                        "  tokens: true,",
                        "  loggerFn: false,",
                        "  project: [],",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, lineNumber, column } = error;",
                        "",
                        "  /* istanbul ignore next */",
                        "  if (typeof lineNumber !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, {",
                        "    start: { line: lineNumber, column: column + 1 },",
                        "  });",
                        "}",
                        "",
                        "function parse(text, parsers, options = {}) {",
                        "  const textToParse = replaceHashbang(text);",
                        "  const jsx = isProbablyJsx(text);",
                        "",
                        "  const { parseWithNodeMaps } = require(\"@typescript-eslint/typescript-estree\");",
                        "  const { result, error: firstError } = tryCombinations(",
                        "    // Try passing with our best guess first.",
                        "    () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx }),",
                        "    // But if we get it wrong, try the opposite.",
                        "    () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx: !jsx })",
                        "  );",
                        "",
                        "  if (!result) {",
                        "    // Suppose our guess is correct, throw the first error",
                        "    throw createParseError(firstError);",
                        "  }",
                        "",
                        "  options.originalText = text;",
                        "  options.tsParseResult = result;",
                        "  return postprocess(result.ast, options);",
                        "}",
                        "",
                        "/**",
                        " * Use a naive regular expression to detect JSX",
                        " */",
                        "function isProbablyJsx(text) {",
                        "  return new RegExp(",
                        "    [",
                        "      \"(?:^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string",
                        "      \"|\",",
                        "      \"(?:^[^/]{2}.*/>)\", // Contains \"/>\" on line not starting with \"//\"",
                        "    ].join(\"\"),",
                        "    \"m\"",
                        "  ).test(text);",
                        "}",
                        "",
                        "// Export as a plugin so we can reuse the same bundle for UMD loading",
                        "module.exports = {",
                        "  parsers: {",
                        "    typescript: createParser(parse),",
                        "  },",
                        "};"
                    ]
                },
                "postprocess": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const { locStart, locEnd } = require(\"../../loc.js\");",
                            "const isTsKeywordType = require(\"../../utils/is-ts-keyword-type.js\");",
                            "const isTypeCastComment = require(\"../../utils/is-type-cast-comment.js\");",
                            "const getLast = require(\"../../../utils/get-last.js\");",
                            "const visitNode = require(\"./visit-node.js\");",
                            "const { throwErrorForInvalidNodes } = require(\"./typescript.js\");",
                            "const throwSyntaxError = require(\"./throw-syntax-error.js\");",
                            "",
                            "function postprocess(ast, options) {",
                            "  if (",
                            "    options.parser === \"typescript\" &&",
                            "    // decorators or abstract properties",
                            "    /@|abstract/.test(options.originalText)",
                            "  ) {",
                            "    throwErrorForInvalidNodes(ast, options);",
                            "  }",
                            "",
                            "  // Keep Babel's non-standard ParenthesizedExpression nodes only if they have Closure-style type cast comments.",
                            "  if (",
                            "    options.parser !== \"typescript\" &&",
                            "    options.parser !== \"flow\" &&",
                            "    options.parser !== \"acorn\" &&",
                            "    options.parser !== \"espree\" &&",
                            "    options.parser !== \"meriyah\"",
                            "  ) {",
                            "    const startOffsetsOfTypeCastedNodes = new Set();",
                            "",
                            "    // Comments might be attached not directly to ParenthesizedExpression but to its ancestor.",
                            "    // E.g.: /** @type {Foo} */ (foo).bar();",
                            "    // Let's use the fact that those ancestors and ParenthesizedExpression have the same start offset.",
                            "",
                            "    ast = visitNode(ast, (node) => {",
                            "      if (",
                            "        node.leadingComments &&",
                            "        node.leadingComments.some(isTypeCastComment)",
                            "      ) {",
                            "        startOffsetsOfTypeCastedNodes.add(locStart(node));",
                            "      }",
                            "    });",
                            "",
                            "    ast = visitNode(ast, (node) => {",
                            "      if (node.type === \"ParenthesizedExpression\") {",
                            "        const { expression } = node;",
                            "",
                            "        // Align range with `flow`",
                            "        if (expression.type === \"TypeCastExpression\") {",
                            "          expression.range = node.range;",
                            "          return expression;",
                            "        }",
                            "",
                            "        const start = locStart(node);",
                            "        if (!startOffsetsOfTypeCastedNodes.has(start)) {",
                            "          expression.extra = { ...expression.extra, parenthesized: true };",
                            "          return expression;",
                            "        }",
                            "      }",
                            "    });",
                            "  }",
                            "",
                            "  ast = visitNode(ast, (node) => {",
                            "    switch (node.type) {",
                            "      // Espree",
                            "      case \"ChainExpression\": {",
                            "        return transformChainExpression(node.expression);",
                            "      }",
                            "      case \"LogicalExpression\": {",
                            "        // We remove unneeded parens around same-operator LogicalExpressions",
                            "        if (isUnbalancedLogicalTree(node)) {",
                            "          return rebalanceLogicalTree(node);",
                            "        }",
                            "        break;",
                            "      }",
                            "      // fix unexpected locEnd caused by --no-semi style",
                            "      case \"VariableDeclaration\": {",
                            "        const lastDeclaration = getLast(node.declarations);",
                            "        if (lastDeclaration && lastDeclaration.init) {",
                            "          overrideLocEnd(node, lastDeclaration);",
                            "        }",
                            "        break;",
                            "      }",
                            "      // remove redundant TypeScript nodes",
                            "      case \"TSParenthesizedType\": {",
                            "        if (",
                            "          !(",
                            "            isTsKeywordType(node.typeAnnotation) ||",
                            "            node.typeAnnotation.type === \"TSThisType\"",
                            "          )",
                            "        ) {",
                            "          node.typeAnnotation.range = [locStart(node), locEnd(node)];",
                            "        }",
                            "        return node.typeAnnotation;",
                            "      }",
                            "      case \"TSTypeParameter\":",
                            "        // babel-ts",
                            "        if (typeof node.name === \"string\") {",
                            "          const start = locStart(node);",
                            "          node.name = {",
                            "            type: \"Identifier\",",
                            "            name: node.name,",
                            "            range: [start, start + node.name.length],",
                            "          };",
                            "        }",
                            "        break;",
                            "      case \"ObjectExpression\":",
                            "        // #12963",
                            "        if (options.parser === \"typescript\") {",
                            "          const invalidProperty = node.properties.find(",
                            "            (property) =>",
                            "              property.type === \"Property\" &&",
                            "              property.value.type === \"TSEmptyBodyFunctionExpression\"",
                            "          );",
                            "          if (invalidProperty) {",
                            "            throwSyntaxError(invalidProperty.value, \"Unexpected token.\");",
                            "          }",
                            "        }",
                            "        break;",
                            "",
                            "      case \"SequenceExpression\": {",
                            "        // Babel (unlike other parsers) includes spaces and comments in the range. Let's unify this.",
                            "        const lastExpression = getLast(node.expressions);",
                            "        node.range = [",
                            "          locStart(node),",
                            "          Math.min(locEnd(lastExpression), locEnd(node)),",
                            "        ];",
                            "        break;",
                            "      }",
                            "      // For hack-style pipeline",
                            "      case \"TopicReference\":",
                            "        options.__isUsingHackPipeline = true;",
                            "        break;",
                            "      // TODO: Remove this when https://github.com/meriyah/meriyah/issues/200 get fixed",
                            "      case \"ExportAllDeclaration\": {",
                            "        const { exported } = node;",
                            "        if (",
                            "          options.parser === \"meriyah\" &&",
                            "          exported &&",
                            "          exported.type === \"Identifier\"",
                            "        ) {",
                            "          const raw = options.originalText.slice(",
                            "            locStart(exported),",
                            "            locEnd(exported)",
                            "          );",
                            "          if (raw.startsWith('\"') || raw.startsWith(\"'\")) {",
                            "            node.exported = {",
                            "              ...node.exported,",
                            "              type: \"Literal\",",
                            "              value: node.exported.name,",
                            "              raw,",
                            "            };",
                            "          }",
                            "        }",
                            "        break;",
                            "      }",
                            "      // TODO: Remove this when https://github.com/meriyah/meriyah/issues/231 get fixed",
                            "      case \"PropertyDefinition\":",
                            "        if (",
                            "          options.parser === \"meriyah\" &&",
                            "          node.static &&",
                            "          !node.computed &&",
                            "          !node.key",
                            "        ) {",
                            "          const name = \"static\";",
                            "          const start = locStart(node);",
                            "          Object.assign(node, {",
                            "            static: false,",
                            "            key: {",
                            "              type: \"Identifier\",",
                            "              name,",
                            "              range: [start, start + name.length],",
                            "            },",
                            "          });",
                            "        }",
                            "        break;",
                            "    }",
                            "  });",
                            "",
                            "  return ast;",
                            "",
                            "  /**",
                            "   * - `toOverrideNode` must be the last thing in `toBeOverriddenNode`",
                            "   * - do nothing if there's a semicolon on `toOverrideNode.end` (no need to fix)",
                            "   */",
                            "  function overrideLocEnd(toBeOverriddenNode, toOverrideNode) {",
                            "    if (options.originalText[locEnd(toOverrideNode)] === \";\") {",
                            "      return;",
                            "    }",
                            "    toBeOverriddenNode.range = [",
                            "      locStart(toBeOverriddenNode),",
                            "      locEnd(toOverrideNode),",
                            "    ];",
                            "  }",
                            "}",
                            "",
                            "// This is a workaround to transform `ChainExpression` from `acorn`, `espree`,",
                            "// `meriyah`, and `typescript` into `babel` shape AST, we should do the opposite,",
                            "// since `ChainExpression` is the standard `estree` AST for `optional chaining`",
                            "// https://github.com/estree/estree/blob/master/es2020.md",
                            "function transformChainExpression(node) {",
                            "  switch (node.type) {",
                            "    case \"CallExpression\":",
                            "      node.type = \"OptionalCallExpression\";",
                            "      node.callee = transformChainExpression(node.callee);",
                            "      break;",
                            "    case \"MemberExpression\":",
                            "      node.type = \"OptionalMemberExpression\";",
                            "      node.object = transformChainExpression(node.object);",
                            "      break;",
                            "    // typescript",
                            "    case \"TSNonNullExpression\":",
                            "      node.expression = transformChainExpression(node.expression);",
                            "      break;",
                            "    // No default",
                            "  }",
                            "  return node;",
                            "}",
                            "",
                            "function isUnbalancedLogicalTree(node) {",
                            "  return (",
                            "    node.type === \"LogicalExpression\" &&",
                            "    node.right.type === \"LogicalExpression\" &&",
                            "    node.operator === node.right.operator",
                            "  );",
                            "}",
                            "",
                            "function rebalanceLogicalTree(node) {",
                            "  if (!isUnbalancedLogicalTree(node)) {",
                            "    return node;",
                            "  }",
                            "",
                            "  return rebalanceLogicalTree({",
                            "    type: \"LogicalExpression\",",
                            "    operator: node.operator,",
                            "    left: rebalanceLogicalTree({",
                            "      type: \"LogicalExpression\",",
                            "      operator: node.operator,",
                            "      left: node.left,",
                            "      right: node.right.left,",
                            "      range: [locStart(node.left), locEnd(node.right.left)],",
                            "    }),",
                            "    right: node.right.right,",
                            "    range: [locStart(node), locEnd(node)],",
                            "  });",
                            "}",
                            "",
                            "module.exports = postprocess;"
                        ]
                    },
                    "throw-syntax-error.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "const createError = require(\"../../../common/parser-create-error.js\");",
                            "",
                            "function throwSyntaxError(node, message) {",
                            "  const { start, end } = node.loc;",
                            "  throw createError(message, {",
                            "    start: { line: start.line, column: start.column + 1 },",
                            "    end: { line: end.line, column: end.column + 1 },",
                            "  });",
                            "}",
                            "",
                            "module.exports = throwSyntaxError;"
                        ]
                    },
                    "typescript.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const isNonEmptyArray = require(\"../../../utils/is-non-empty-array.js\");",
                            "const visitNode = require(\"./visit-node.js\");",
                            "const throwSyntaxError = require(\"./throw-syntax-error.js\");",
                            "",
                            "// Taken from `typescript` package",
                            "const SyntaxKind = {",
                            "  AbstractKeyword: 126,",
                            "  SourceFile: 308,",
                            "  PropertyDeclaration: 169,",
                            "};",
                            "",
                            "// Copied from https://unpkg.com/typescript@4.8.2/lib/typescript.js",
                            "function getSourceFileOfNode(node) {",
                            "  while (node && node.kind !== SyntaxKind.SourceFile) {",
                            "    node = node.parent;",
                            "  }",
                            "  return node;",
                            "}",
                            "",
                            "// Invalid decorators are removed since `@typescript-eslint/typescript-estree` v4",
                            "// https://github.com/typescript-eslint/typescript-eslint/pull/2375",
                            "// There is a `checkGrammarDecorators` in `typescript` package, consider use it directly in future",
                            "function throwErrorForInvalidDecorator(tsNode) {",
                            "  const { illegalDecorators } = tsNode;",
                            "  if (!isNonEmptyArray(illegalDecorators)) {",
                            "    return;",
                            "  }",
                            "",
                            "  const [{ expression }] = illegalDecorators;",
                            "",
                            "  const sourceFile = getSourceFileOfNode(expression);",
                            "  const [start, end] = [expression.pos, expression.end].map((position) => {",
                            "    const { line, character: column } =",
                            "      sourceFile.getLineAndCharacterOfPosition(position);",
                            "    return { line: line + 1, column };",
                            "  });",
                            "",
                            "  throwSyntaxError({ loc: { start, end } }, \"Decorators are not valid here.\");",
                            "}",
                            "",
                            "// Values of abstract property is removed since `@typescript-eslint/typescript-estree` v5",
                            "// https://github.com/typescript-eslint/typescript-eslint/releases/tag/v5.0.0",
                            "function throwErrorForInvalidAbstractProperty(tsNode, esTreeNode) {",
                            "  if (",
                            "    tsNode.kind !== SyntaxKind.PropertyDeclaration ||",
                            "    (tsNode.modifiers &&",
                            "      !tsNode.modifiers.some(",
                            "        (modifier) => modifier.kind === SyntaxKind.AbstractKeyword",
                            "      ))",
                            "  ) {",
                            "    return;",
                            "  }",
                            "  if (tsNode.initializer && esTreeNode.value === null) {",
                            "    throwSyntaxError(",
                            "      esTreeNode,",
                            "      \"Abstract property cannot have an initializer\"",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "function throwErrorForInvalidNodes(ast, options) {",
                            "  const { esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap } =",
                            "    options.tsParseResult;",
                            "",
                            "  visitNode(ast, (node) => {",
                            "    const tsNode = esTreeNodeToTSNodeMap.get(node);",
                            "    if (!tsNode) {",
                            "      return;",
                            "    }",
                            "    const esTreeNode = tsNodeToESTreeNodeMap.get(tsNode);",
                            "    if (esTreeNode !== node) {",
                            "      return;",
                            "    }",
                            "",
                            "    throwErrorForInvalidDecorator(tsNode);",
                            "    throwErrorForInvalidAbstractProperty(tsNode, esTreeNode);",
                            "  });",
                            "}",
                            "",
                            "module.exports = { throwErrorForInvalidNodes };"
                        ]
                    },
                    "visit-node.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "function visitNode(node, fn) {",
                            "  if (Array.isArray(node)) {",
                            "    // As of Node.js 16 using raw for loop over Array.entries provides a",
                            "    // measurable difference in performance. Array.entries returns an iterator",
                            "    // of arrays.",
                            "    for (let i = 0; i < node.length; i++) {",
                            "      node[i] = visitNode(node[i], fn);",
                            "    }",
                            "    return node;",
                            "  }",
                            "  if (node && typeof node === \"object\" && typeof node.type === \"string\") {",
                            "    // As of Node.js 16 this is benchmarked to be faster over Object.entries.",
                            "    // Object.entries returns an array of arrays. There are multiple ways to",
                            "    // iterate over objects but the Object.keys combined with a for loop",
                            "    // benchmarks well.",
                            "    const keys = Object.keys(node);",
                            "    for (let i = 0; i < keys.length; i++) {",
                            "      node[keys[i]] = visitNode(node[keys[i]], fn);",
                            "    }",
                            "    return fn(node) || node;",
                            "  }",
                            "  return node;",
                            "}",
                            "",
                            "module.exports = visitNode;"
                        ]
                    }
                },
                "utils": {
                    "create-babel-parse-error.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const createError = require(\"../../../common/parser-create-error.js\");",
                            "",
                            "function createBabelParseError(error) {",
                            "  // babel error prints (l:c) with cols that are zero indexed",
                            "  // so we need our custom error",
                            "  const { message, loc } = error;",
                            "",
                            "  return createError(message.replace(/ \\(.*\\)/, \"\"), {",
                            "    start: {",
                            "      line: loc ? loc.line : 0,",
                            "      column: loc ? loc.column + 1 : 0,",
                            "    },",
                            "  });",
                            "}",
                            "",
                            "module.exports = createBabelParseError;"
                        ]
                    },
                    "create-parser.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const { hasPragma } = require(\"../../pragma.js\");",
                            "const { locStart, locEnd } = require(\"../../loc.js\");",
                            "",
                            "function createParser(options) {",
                            "  options = typeof options === \"function\" ? { parse: options } : options;",
                            "",
                            "  return {",
                            "    astFormat: \"estree\",",
                            "    hasPragma,",
                            "    locStart,",
                            "    locEnd,",
                            "    ...options,",
                            "  };",
                            "}",
                            "",
                            "module.exports = createParser;"
                        ]
                    },
                    "replace-hashbang.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "// Replace `#!` with `//` so `typescript`, `flow`, and `espree` can parse it as line comment",
                            "// Inspired by ESLint parse function https://github.com/eslint/eslint/blob/9d6063add931f0803cae1676d5df307baf114360/lib/linter/linter.js#L635",
                            "function replaceHashbang(text) {",
                            "  if (text.charAt(0) === \"#\" && text.charAt(1) === \"!\") {",
                            "    return \"//\" + text.slice(2);",
                            "  }",
                            "",
                            "  return text;",
                            "}",
                            "",
                            "module.exports = replaceHashbang;"
                        ]
                    }
                }
            },
            "print": {
                "angular.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { join, line, group },",
                        "} = require(\"../../document/index.js\");",
                        "const { hasNode, hasComment, getComments } = require(\"../utils/index.js\");",
                        "const { printBinaryishExpression } = require(\"./binaryish.js\");",
                        "",
                        "/** @typedef {import(\"../../common/ast-path\")} AstPath */",
                        "",
                        "function printAngular(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  // Angular nodes always starts with `NG`",
                        "  if (!node.type.startsWith(\"NG\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"NGRoot\":",
                        "      return [",
                        "        print(\"node\"),",
                        "        !hasComment(node.node)",
                        "          ? \"\"",
                        "          : \" //\" + getComments(node.node)[0].value.trimEnd(),",
                        "      ];",
                        "    case \"NGPipeExpression\":",
                        "      return printBinaryishExpression(path, options, print);",
                        "    case \"NGChainedExpression\":",
                        "      return group(",
                        "        join(",
                        "          [\";\", line],",
                        "          path.map(",
                        "            (childPath) =>",
                        "              hasNgSideEffect(childPath) ? print() : [\"(\", print(), \")\"],",
                        "            \"expressions\"",
                        "          )",
                        "        )",
                        "      );",
                        "    case \"NGEmptyExpression\":",
                        "      return \"\";",
                        "    case \"NGQuotedExpression\":",
                        "      return [node.prefix, \": \", node.value.trim()];",
                        "    case \"NGMicrosyntax\":",
                        "      return path.map(",
                        "        (childPath, index) => [",
                        "          index === 0",
                        "            ? \"\"",
                        "            : isNgForOf(childPath.getValue(), index, node)",
                        "            ? \" \"",
                        "            : [\";\", line],",
                        "          print(),",
                        "        ],",
                        "        \"body\"",
                        "      );",
                        "    case \"NGMicrosyntaxKey\":",
                        "      return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(node.name)",
                        "        ? node.name",
                        "        : JSON.stringify(node.name);",
                        "    case \"NGMicrosyntaxExpression\":",
                        "      return [",
                        "        print(\"expression\"),",
                        "        node.alias === null ? \"\" : [\" as \", print(\"alias\")],",
                        "      ];",
                        "    case \"NGMicrosyntaxKeyedExpression\": {",
                        "      const index = path.getName();",
                        "      const parentNode = path.getParentNode();",
                        "      const shouldNotPrintColon =",
                        "        isNgForOf(node, index, parentNode) ||",
                        "        (((index === 1 &&",
                        "          (node.key.name === \"then\" || node.key.name === \"else\")) ||",
                        "          (index === 2 &&",
                        "            node.key.name === \"else\" &&",
                        "            parentNode.body[index - 1].type ===",
                        "              \"NGMicrosyntaxKeyedExpression\" &&",
                        "            parentNode.body[index - 1].key.name === \"then\")) &&",
                        "          parentNode.body[0].type === \"NGMicrosyntaxExpression\");",
                        "      return [",
                        "        print(\"key\"),",
                        "        shouldNotPrintColon ? \" \" : \": \",",
                        "        print(\"expression\"),",
                        "      ];",
                        "    }",
                        "    case \"NGMicrosyntaxLet\":",
                        "      return [",
                        "        \"let \",",
                        "        print(\"key\"),",
                        "        node.value === null ? \"\" : [\" = \", print(\"value\")],",
                        "      ];",
                        "    case \"NGMicrosyntaxAs\":",
                        "      return [print(\"key\"), \" as \", print(\"alias\")];",
                        "    default:",
                        "      /* istanbul ignore next */",
                        "      throw new Error(",
                        "        `Unknown Angular node type: ${JSON.stringify(node.type)}.`",
                        "      );",
                        "  }",
                        "}",
                        "",
                        "function isNgForOf(node, index, parentNode) {",
                        "  return (",
                        "    node.type === \"NGMicrosyntaxKeyedExpression\" &&",
                        "    node.key.name === \"of\" &&",
                        "    index === 1 &&",
                        "    parentNode.body[0].type === \"NGMicrosyntaxLet\" &&",
                        "    parentNode.body[0].value === null",
                        "  );",
                        "}",
                        "",
                        "/** identify if an angular expression seems to have side effects */",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function hasNgSideEffect(path) {",
                        "  return hasNode(path.getValue(), (node) => {",
                        "    switch (node.type) {",
                        "      case undefined:",
                        "        return false;",
                        "      case \"CallExpression\":",
                        "      case \"OptionalCallExpression\":",
                        "      case \"AssignmentExpression\":",
                        "        return true;",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "module.exports = { printAngular };"
                    ]
                },
                "array.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { line, softline, hardline, group, indent, ifBreak, fill },",
                        "} = require(\"../../document/index.js\");",
                        "const { getLast, hasNewline } = require(\"../../common/util.js\");",
                        "const {",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "  isNumericLiteral,",
                        "  isSignedNumericLiteral,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart } = require(\"../loc.js\");",
                        "",
                        "const { printOptionalToken, printTypeAnnotation } = require(\"./misc.js\");",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "function printArray(path, options, print) {",
                        "  const node = path.getValue();",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  const openBracket = node.type === \"TupleExpression\" ? \"#[\" : \"[\";",
                        "  const closeBracket = \"]\";",
                        "  if (node.elements.length === 0) {",
                        "    if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      parts.push(openBracket, closeBracket);",
                        "    } else {",
                        "      parts.push(",
                        "        group([",
                        "          openBracket,",
                        "          printDanglingComments(path, options),",
                        "          softline,",
                        "          closeBracket,",
                        "        ])",
                        "      );",
                        "    }",
                        "  } else {",
                        "    const lastElem = getLast(node.elements);",
                        "    const canHaveTrailingComma = !(lastElem && lastElem.type === \"RestElement\");",
                        "",
                        "    // JavaScript allows you to have empty elements in an array which",
                        "    // changes its length based on the number of commas. The algorithm",
                        "    // is that if the last argument is null, we need to force insert",
                        "    // a comma to ensure JavaScript recognizes it.",
                        "    //   [,].length === 1",
                        "    //   [1,].length === 1",
                        "    //   [1,,].length === 2",
                        "    //",
                        "    // Note that getLast returns null if the array is empty, but",
                        "    // we already check for an empty array just above so we are safe",
                        "    const needsForcedTrailingComma = lastElem === null;",
                        "",
                        "    const groupId = Symbol(\"array\");",
                        "",
                        "    const shouldBreak =",
                        "      !options.__inJestEach &&",
                        "      node.elements.length > 1 &&",
                        "      node.elements.every((element, i, elements) => {",
                        "        const elementType = element && element.type;",
                        "        if (",
                        "          elementType !== \"ArrayExpression\" &&",
                        "          elementType !== \"ObjectExpression\"",
                        "        ) {",
                        "          return false;",
                        "        }",
                        "",
                        "        const nextElement = elements[i + 1];",
                        "        if (nextElement && elementType !== nextElement.type) {",
                        "          return false;",
                        "        }",
                        "",
                        "        const itemsKey =",
                        "          elementType === \"ArrayExpression\" ? \"elements\" : \"properties\";",
                        "",
                        "        return element[itemsKey] && element[itemsKey].length > 1;",
                        "      });",
                        "",
                        "    const shouldUseConciseFormatting = isConciselyPrintedArray(node, options);",
                        "",
                        "    const trailingComma = !canHaveTrailingComma",
                        "      ? \"\"",
                        "      : needsForcedTrailingComma",
                        "      ? \",\"",
                        "      : !shouldPrintComma(options)",
                        "      ? \"\"",
                        "      : shouldUseConciseFormatting",
                        "      ? ifBreak(\",\", \"\", { groupId })",
                        "      : ifBreak(\",\");",
                        "",
                        "    parts.push(",
                        "      group(",
                        "        [",
                        "          openBracket,",
                        "          indent([",
                        "            softline,",
                        "            shouldUseConciseFormatting",
                        "              ? printArrayItemsConcisely(path, options, print, trailingComma)",
                        "              : [",
                        "                  printArrayItems(path, options, \"elements\", print),",
                        "                  trailingComma,",
                        "                ],",
                        "            printDanglingComments(path, options, /* sameIndent */ true),",
                        "          ]),",
                        "          softline,",
                        "          closeBracket,",
                        "        ],",
                        "        { shouldBreak, id: groupId }",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printOptionalToken(path),",
                        "    printTypeAnnotation(path, options, print)",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function isConciselyPrintedArray(node, options) {",
                        "  return (",
                        "    node.elements.length > 1 &&",
                        "    node.elements.every(",
                        "      (element) =>",
                        "        element &&",
                        "        (isNumericLiteral(element) ||",
                        "          (isSignedNumericLiteral(element) && !hasComment(element.argument))) &&",
                        "        !hasComment(",
                        "          element,",
                        "          CommentCheckFlags.Trailing | CommentCheckFlags.Line,",
                        "          (comment) =>",
                        "            !hasNewline(options.originalText, locStart(comment), {",
                        "              backwards: true,",
                        "            })",
                        "        )",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function printArrayItems(path, options, printPath, print) {",
                        "  const printedElements = [];",
                        "  let separatorParts = [];",
                        "",
                        "  path.each((childPath) => {",
                        "    printedElements.push(separatorParts, group(print()));",
                        "",
                        "    separatorParts = [\",\", line];",
                        "    if (",
                        "      childPath.getValue() &&",
                        "      isNextLineEmpty(childPath.getValue(), options)",
                        "    ) {",
                        "      separatorParts.push(softline);",
                        "    }",
                        "  }, printPath);",
                        "",
                        "  return printedElements;",
                        "}",
                        "",
                        "function printArrayItemsConcisely(path, options, print, trailingComma) {",
                        "  const parts = [];",
                        "",
                        "  path.each((childPath, i, elements) => {",
                        "    const isLast = i === elements.length - 1;",
                        "",
                        "    parts.push([print(), isLast ? trailingComma : \",\"]);",
                        "",
                        "    if (!isLast) {",
                        "      parts.push(",
                        "        isNextLineEmpty(childPath.getValue(), options)",
                        "          ? [hardline, hardline]",
                        "          : hasComment(",
                        "              elements[i + 1],",
                        "              CommentCheckFlags.Leading | CommentCheckFlags.Line",
                        "            )",
                        "          ? hardline",
                        "          : line",
                        "      );",
                        "    }",
                        "  }, \"elements\");",
                        "",
                        "  return fill(parts);",
                        "}",
                        "",
                        "module.exports = { printArray, printArrayItems, isConciselyPrintedArray };"
                    ]
                },
                "assignment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray, getStringWidth } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { line, group, indent, indentIfBreak, lineSuffixBoundary },",
                        "  utils: { cleanDoc, willBreak, canBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasLeadingOwnLineComment,",
                        "  isBinaryish,",
                        "  isStringLiteral,",
                        "  isLiteral,",
                        "  isNumericLiteral,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  getCallArguments,",
                        "  rawText,",
                        "  hasComment,",
                        "  isSignedNumericLiteral,",
                        "  isObjectProperty,",
                        "} = require(\"../utils/index.js\");",
                        "const { shouldInlineLogicalExpression } = require(\"./binaryish.js\");",
                        "const { printCallExpression } = require(\"./call-expression.js\");",
                        "",
                        "function printAssignment(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  leftDoc,",
                        "  operator,",
                        "  rightPropertyName",
                        ") {",
                        "  const layout = chooseLayout(path, options, print, leftDoc, rightPropertyName);",
                        "",
                        "  const rightDoc = print(rightPropertyName, { assignmentLayout: layout });",
                        "",
                        "  switch (layout) {",
                        "    // First break after operator, then the sides are broken independently on their own lines",
                        "    case \"break-after-operator\":",
                        "      return group([group(leftDoc), operator, group(indent([line, rightDoc]))]);",
                        "",
                        "    // First break right-hand side, then left-hand side",
                        "    case \"never-break-after-operator\":",
                        "      return group([group(leftDoc), operator, \" \", rightDoc]);",
                        "",
                        "    // First break right-hand side, then after operator",
                        "    case \"fluid\": {",
                        "      const groupId = Symbol(\"assignment\");",
                        "      return group([",
                        "        group(leftDoc),",
                        "        operator,",
                        "        group(indent(line), { id: groupId }),",
                        "        lineSuffixBoundary,",
                        "        indentIfBreak(rightDoc, { groupId }),",
                        "      ]);",
                        "    }",
                        "",
                        "    case \"break-lhs\":",
                        "      return group([leftDoc, operator, \" \", group(rightDoc)]);",
                        "",
                        "    // Parts of assignment chains aren't wrapped in groups.",
                        "    // Once one of them breaks, the chain breaks too.",
                        "    case \"chain\":",
                        "      return [group(leftDoc), operator, line, rightDoc];",
                        "",
                        "    case \"chain-tail\":",
                        "      return [group(leftDoc), operator, indent([line, rightDoc])];",
                        "",
                        "    case \"chain-tail-arrow-chain\":",
                        "      return [group(leftDoc), operator, rightDoc];",
                        "",
                        "    case \"only-left\":",
                        "      return leftDoc;",
                        "  }",
                        "}",
                        "",
                        "function printAssignmentExpression(path, options, print) {",
                        "  const node = path.getValue();",
                        "  return printAssignment(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    print(\"left\"),",
                        "    [\" \", node.operator],",
                        "    \"right\"",
                        "  );",
                        "}",
                        "",
                        "function printVariableDeclarator(path, options, print) {",
                        "  return printAssignment(path, options, print, print(\"id\"), \" =\", \"init\");",
                        "}",
                        "",
                        "function chooseLayout(path, options, print, leftDoc, rightPropertyName) {",
                        "  const node = path.getValue();",
                        "  const rightNode = node[rightPropertyName];",
                        "",
                        "  if (!rightNode) {",
                        "    return \"only-left\";",
                        "  }",
                        "",
                        "  // Short assignment chains (only 2 segments) are NOT formatted as chains.",
                        "  //   1) a = b = c; (expression statements)",
                        "  //   2) var/let/const a = b = c;",
                        "",
                        "  const isTail = !isAssignment(rightNode);",
                        "  const shouldUseChainFormatting = path.match(",
                        "    isAssignment,",
                        "    isAssignmentOrVariableDeclarator,",
                        "    (node) =>",
                        "      !isTail ||",
                        "      (node.type !== \"ExpressionStatement\" &&",
                        "        node.type !== \"VariableDeclaration\")",
                        "  );",
                        "  if (shouldUseChainFormatting) {",
                        "    return !isTail",
                        "      ? \"chain\"",
                        "      : rightNode.type === \"ArrowFunctionExpression\" &&",
                        "        rightNode.body.type === \"ArrowFunctionExpression\"",
                        "      ? \"chain-tail-arrow-chain\"",
                        "      : \"chain-tail\";",
                        "  }",
                        "  const isHeadOfLongChain = !isTail && isAssignment(rightNode.right);",
                        "",
                        "  if (",
                        "    isHeadOfLongChain ||",
                        "    hasLeadingOwnLineComment(options.originalText, rightNode)",
                        "  ) {",
                        "    return \"break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    (rightNode.type === \"CallExpression\" &&",
                        "      rightNode.callee.name === \"require\") ||",
                        "    // do not put values on a separate line from the key in json",
                        "    options.parser === \"json5\" ||",
                        "    options.parser === \"json\"",
                        "  ) {",
                        "    return \"never-break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    isComplexDestructuring(node) ||",
                        "    isComplexTypeAliasParams(node) ||",
                        "    hasComplexTypeAnnotation(node) ||",
                        "    (isArrowFunctionVariableDeclarator(node) && canBreak(leftDoc))",
                        "  ) {",
                        "    return \"break-lhs\";",
                        "  }",
                        "",
                        "  // wrapping object properties with very short keys usually doesn't add much value",
                        "  const hasShortKey = isObjectPropertyWithShortKey(node, leftDoc, options);",
                        "",
                        "  if (",
                        "    path.call(",
                        "      () => shouldBreakAfterOperator(path, options, print, hasShortKey),",
                        "      rightPropertyName",
                        "    )",
                        "  ) {",
                        "    return \"break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    hasShortKey ||",
                        "    rightNode.type === \"TemplateLiteral\" ||",
                        "    rightNode.type === \"TaggedTemplateExpression\" ||",
                        "    rightNode.type === \"BooleanLiteral\" ||",
                        "    isNumericLiteral(rightNode) ||",
                        "    rightNode.type === \"ClassExpression\"",
                        "  ) {",
                        "    return \"never-break-after-operator\";",
                        "  }",
                        "",
                        "  return \"fluid\";",
                        "}",
                        "",
                        "function shouldBreakAfterOperator(path, options, print, hasShortKey) {",
                        "  const rightNode = path.getValue();",
                        "",
                        "  if (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (rightNode.type) {",
                        "    case \"StringLiteralTypeAnnotation\":",
                        "    case \"SequenceExpression\":",
                        "      return true;",
                        "    case \"ConditionalExpression\": {",
                        "      const { test } = rightNode;",
                        "      return isBinaryish(test) && !shouldInlineLogicalExpression(test);",
                        "    }",
                        "    case \"ClassExpression\":",
                        "      return isNonEmptyArray(rightNode.decorators);",
                        "  }",
                        "",
                        "  if (hasShortKey) {",
                        "    return false;",
                        "  }",
                        "",
                        "  let node = rightNode;",
                        "  const propertiesForPath = [];",
                        "  for (;;) {",
                        "    if (node.type === \"UnaryExpression\") {",
                        "      node = node.argument;",
                        "      propertiesForPath.push(\"argument\");",
                        "    } else if (node.type === \"TSNonNullExpression\") {",
                        "      node = node.expression;",
                        "      propertiesForPath.push(\"expression\");",
                        "    } else {",
                        "      break;",
                        "    }",
                        "  }",
                        "  if (",
                        "    isStringLiteral(node) ||",
                        "    path.call(",
                        "      () => isPoorlyBreakableMemberOrCallChain(path, options, print),",
                        "      ...propertiesForPath",
                        "    )",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "// prefer to break destructuring assignment",
                        "// if it includes default values or non-shorthand properties",
                        "function isComplexDestructuring(node) {",
                        "  if (isAssignmentOrVariableDeclarator(node)) {",
                        "    const leftNode = node.left || node.id;",
                        "    return (",
                        "      leftNode.type === \"ObjectPattern\" &&",
                        "      leftNode.properties.length > 2 &&",
                        "      leftNode.properties.some(",
                        "        (property) =>",
                        "          isObjectProperty(property) &&",
                        "          (!property.shorthand ||",
                        "            (property.value && property.value.type === \"AssignmentPattern\"))",
                        "      )",
                        "    );",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function isAssignment(node) {",
                        "  return node.type === \"AssignmentExpression\";",
                        "}",
                        "",
                        "function isAssignmentOrVariableDeclarator(node) {",
                        "  return isAssignment(node) || node.type === \"VariableDeclarator\";",
                        "}",
                        "",
                        "function isComplexTypeAliasParams(node) {",
                        "  const typeParams = getTypeParametersFromTypeAlias(node);",
                        "  if (isNonEmptyArray(typeParams)) {",
                        "    const constraintPropertyName =",
                        "      node.type === \"TSTypeAliasDeclaration\" ? \"constraint\" : \"bound\";",
                        "    if (",
                        "      typeParams.length > 1 &&",
                        "      typeParams.some((param) => param[constraintPropertyName] || param.default)",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function getTypeParametersFromTypeAlias(node) {",
                        "  if (isTypeAlias(node) && node.typeParameters && node.typeParameters.params) {",
                        "    return node.typeParameters.params;",
                        "  }",
                        "  return null;",
                        "}",
                        "",
                        "function isTypeAlias(node) {",
                        "  return node.type === \"TSTypeAliasDeclaration\" || node.type === \"TypeAlias\";",
                        "}",
                        "",
                        "function hasComplexTypeAnnotation(node) {",
                        "  if (node.type !== \"VariableDeclarator\") {",
                        "    return false;",
                        "  }",
                        "  const { typeAnnotation } = node.id;",
                        "  if (!typeAnnotation || !typeAnnotation.typeAnnotation) {",
                        "    return false;",
                        "  }",
                        "  const typeParams = getTypeParametersFromTypeReference(",
                        "    typeAnnotation.typeAnnotation",
                        "  );",
                        "  return (",
                        "    isNonEmptyArray(typeParams) &&",
                        "    typeParams.length > 1 &&",
                        "    typeParams.some(",
                        "      (param) =>",
                        "        isNonEmptyArray(getTypeParametersFromTypeReference(param)) ||",
                        "        param.type === \"TSConditionalType\"",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function isArrowFunctionVariableDeclarator(node) {",
                        "  return (",
                        "    node.type === \"VariableDeclarator\" &&",
                        "    node.init &&",
                        "    node.init.type === \"ArrowFunctionExpression\"",
                        "  );",
                        "}",
                        "",
                        "function getTypeParametersFromTypeReference(node) {",
                        "  if (",
                        "    isTypeReference(node) &&",
                        "    node.typeParameters &&",
                        "    node.typeParameters.params",
                        "  ) {",
                        "    return node.typeParameters.params;",
                        "  }",
                        "  return null;",
                        "}",
                        "",
                        "function isTypeReference(node) {",
                        "  return (",
                        "    node.type === \"TSTypeReference\" || node.type === \"GenericTypeAnnotation\"",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * A chain with no calls at all or whose calls are all without arguments or with lone short arguments,",
                        " * excluding chains printed by `printMemberChain`",
                        " */",
                        "function isPoorlyBreakableMemberOrCallChain(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  deep = false",
                        ") {",
                        "  const node = path.getValue();",
                        "  const goDeeper = () =>",
                        "    isPoorlyBreakableMemberOrCallChain(path, options, print, true);",
                        "",
                        "  if (node.type === \"TSNonNullExpression\") {",
                        "    return path.call(goDeeper, \"expression\");",
                        "  }",
                        "",
                        "  if (isCallExpression(node)) {",
                        "    /** @type {any} TODO */",
                        "    const doc = printCallExpression(path, options, print);",
                        "    if (doc.label === \"member-chain\") {",
                        "      return false;",
                        "    }",
                        "",
                        "    const args = getCallArguments(node);",
                        "    const isPoorlyBreakableCall =",
                        "      args.length === 0 ||",
                        "      (args.length === 1 && isLoneShortArgument(args[0], options));",
                        "    if (!isPoorlyBreakableCall) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (isCallExpressionWithComplexTypeArguments(node, print)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return path.call(goDeeper, \"callee\");",
                        "  }",
                        "",
                        "  if (isMemberExpression(node)) {",
                        "    return path.call(goDeeper, \"object\");",
                        "  }",
                        "",
                        "  return deep && (node.type === \"Identifier\" || node.type === \"ThisExpression\");",
                        "}",
                        "",
                        "const LONE_SHORT_ARGUMENT_THRESHOLD_RATE = 0.25;",
                        "",
                        "function isLoneShortArgument(node, { printWidth }) {",
                        "  if (hasComment(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const threshold = printWidth * LONE_SHORT_ARGUMENT_THRESHOLD_RATE;",
                        "",
                        "  if (",
                        "    node.type === \"ThisExpression\" ||",
                        "    (node.type === \"Identifier\" && node.name.length <= threshold) ||",
                        "    (isSignedNumericLiteral(node) && !hasComment(node.argument))",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const regexpPattern =",
                        "    (node.type === \"Literal\" && \"regex\" in node && node.regex.pattern) ||",
                        "    (node.type === \"RegExpLiteral\" && node.pattern);",
                        "",
                        "  if (regexpPattern) {",
                        "    return regexpPattern.length <= threshold;",
                        "  }",
                        "",
                        "  if (isStringLiteral(node)) {",
                        "    return rawText(node).length <= threshold;",
                        "  }",
                        "",
                        "  if (node.type === \"TemplateLiteral\") {",
                        "    return (",
                        "      node.expressions.length === 0 &&",
                        "      node.quasis[0].value.raw.length <= threshold &&",
                        "      !node.quasis[0].value.raw.includes(\"\\n\")",
                        "    );",
                        "  }",
                        "",
                        "  return isLiteral(node);",
                        "}",
                        "",
                        "function isObjectPropertyWithShortKey(node, keyDoc, options) {",
                        "  if (!isObjectProperty(node)) {",
                        "    return false;",
                        "  }",
                        "  // TODO: for performance, it might make sense to use a more lightweight",
                        "  // version of cleanDoc, such that it would stop once it detects that",
                        "  // the doc can't be reduced to a string.",
                        "  keyDoc = cleanDoc(keyDoc);",
                        "  const MIN_OVERLAP_FOR_BREAK = 3;",
                        "  //   \u2193\u2193 - insufficient overlap for a line break",
                        "  // key1: longValue1,",
                        "  //   \u2193\u2193\u2193\u2193\u2193\u2193 - overlap is long enough to break",
                        "  // key2abcd:",
                        "  //   longValue2",
                        "  return (",
                        "    typeof keyDoc === \"string\" &&",
                        "    getStringWidth(keyDoc) < options.tabWidth + MIN_OVERLAP_FOR_BREAK",
                        "  );",
                        "}",
                        "",
                        "function isCallExpressionWithComplexTypeArguments(node, print) {",
                        "  const typeArgs = getTypeArgumentsFromCallExpression(node);",
                        "  if (isNonEmptyArray(typeArgs)) {",
                        "    if (typeArgs.length > 1) {",
                        "      return true;",
                        "    }",
                        "    if (typeArgs.length === 1) {",
                        "      const firstArg = typeArgs[0];",
                        "      if (",
                        "        firstArg.type === \"TSUnionType\" ||",
                        "        firstArg.type === \"UnionTypeAnnotation\" ||",
                        "        firstArg.type === \"TSIntersectionType\" ||",
                        "        firstArg.type === \"IntersectionTypeAnnotation\" ||",
                        "        firstArg.type === \"TSTypeLiteral\" ||",
                        "        firstArg.type === \"ObjectTypeAnnotation\"",
                        "      ) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "    const typeArgsKeyName = node.typeParameters",
                        "      ? \"typeParameters\"",
                        "      : \"typeArguments\";",
                        "    if (willBreak(print(typeArgsKeyName))) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function getTypeArgumentsFromCallExpression(node) {",
                        "  return (",
                        "    (node.typeParameters && node.typeParameters.params) ||",
                        "    (node.typeArguments && node.typeArguments.params)",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  printVariableDeclarator,",
                        "  printAssignmentExpression,",
                        "  printAssignment,",
                        "  isArrowFunctionVariableDeclarator,",
                        "};"
                    ]
                },
                "binaryish.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printComments } = require(\"../../main/comments.js\");",
                        "const { getLast } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { join, line, softline, group, indent, align, indentIfBreak },",
                        "  utils: { cleanDoc, getDocParts, isConcat },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasLeadingOwnLineComment,",
                        "  isBinaryish,",
                        "  isJsxNode,",
                        "  shouldFlatten,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isObjectProperty,",
                        "  isEnabledHackPipeline,",
                        "} = require(\"../utils/index.js\");",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "let uid = 0;",
                        "function printBinaryishExpression(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parent = path.getParentNode();",
                        "  const parentParent = path.getParentNode(1);",
                        "  const isInsideParenthesis =",
                        "    node !== parent.body &&",
                        "    (parent.type === \"IfStatement\" ||",
                        "      parent.type === \"WhileStatement\" ||",
                        "      parent.type === \"SwitchStatement\" ||",
                        "      parent.type === \"DoWhileStatement\");",
                        "  const isHackPipeline =",
                        "    isEnabledHackPipeline(options) && node.operator === \"|>\";",
                        "",
                        "  const parts = printBinaryishExpressions(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    /* isNested */ false,",
                        "    isInsideParenthesis",
                        "  );",
                        "",
                        "  //   if (",
                        "  //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft",
                        "  //   ) {",
                        "  //",
                        "  // looks super weird, we want to break the children if the parent breaks",
                        "  //",
                        "  //   if (",
                        "  //     this.hasPlugin(\"dynamicImports\") &&",
                        "  //     this.lookahead().type === tt.parenLeft",
                        "  //   ) {",
                        "  if (isInsideParenthesis) {",
                        "    return parts;",
                        "  }",
                        "",
                        "  if (isHackPipeline) {",
                        "    return group(parts);",
                        "  }",
                        "",
                        "  // Break between the parens in",
                        "  // unaries or in a member or specific call expression, i.e.",
                        "  //",
                        "  //   (",
                        "  //     a &&",
                        "  //     b &&",
                        "  //     c",
                        "  //   ).call()",
                        "  if (",
                        "    (isCallExpression(parent) && parent.callee === node) ||",
                        "    parent.type === \"UnaryExpression\" ||",
                        "    (isMemberExpression(parent) && !parent.computed)",
                        "  ) {",
                        "    return group([indent([softline, ...parts]), softline]);",
                        "  }",
                        "",
                        "  // Avoid indenting sub-expressions in some cases where the first sub-expression is already",
                        "  // indented accordingly. We should indent sub-expressions where the first case isn't indented.",
                        "  const shouldNotIndent =",
                        "    parent.type === \"ReturnStatement\" ||",
                        "    parent.type === \"ThrowStatement\" ||",
                        "    (parent.type === \"JSXExpressionContainer\" &&",
                        "      parentParent.type === \"JSXAttribute\") ||",
                        "    (node.operator !== \"|\" && parent.type === \"JsExpressionRoot\") ||",
                        "    (node.type !== \"NGPipeExpression\" &&",
                        "      ((parent.type === \"NGRoot\" && options.parser === \"__ng_binding\") ||",
                        "        (parent.type === \"NGMicrosyntaxExpression\" &&",
                        "          parentParent.type === \"NGMicrosyntax\" &&",
                        "          parentParent.body.length === 1))) ||",
                        "    (node === parent.body && parent.type === \"ArrowFunctionExpression\") ||",
                        "    (node !== parent.body && parent.type === \"ForStatement\") ||",
                        "    (parent.type === \"ConditionalExpression\" &&",
                        "      parentParent.type !== \"ReturnStatement\" &&",
                        "      parentParent.type !== \"ThrowStatement\" &&",
                        "      !isCallExpression(parentParent)) ||",
                        "    parent.type === \"TemplateLiteral\";",
                        "",
                        "  const shouldIndentIfInlining =",
                        "    parent.type === \"AssignmentExpression\" ||",
                        "    parent.type === \"VariableDeclarator\" ||",
                        "    parent.type === \"ClassProperty\" ||",
                        "    parent.type === \"PropertyDefinition\" ||",
                        "    parent.type === \"TSAbstractPropertyDefinition\" ||",
                        "    parent.type === \"ClassPrivateProperty\" ||",
                        "    isObjectProperty(parent);",
                        "",
                        "  const samePrecedenceSubExpression =",
                        "    isBinaryish(node.left) && shouldFlatten(node.operator, node.left.operator);",
                        "",
                        "  if (",
                        "    shouldNotIndent ||",
                        "    (shouldInlineLogicalExpression(node) && !samePrecedenceSubExpression) ||",
                        "    (!shouldInlineLogicalExpression(node) && shouldIndentIfInlining)",
                        "  ) {",
                        "    return group(parts);",
                        "  }",
                        "",
                        "  if (parts.length === 0) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // If the right part is a JSX node, we include it in a separate group to",
                        "  // prevent it breaking the whole chain, so we can print the expression like:",
                        "  //",
                        "  //   foo && bar && (",
                        "  //     <Foo>",
                        "  //       <Bar />",
                        "  //     </Foo>",
                        "  //   )",
                        "",
                        "  const hasJsx = isJsxNode(node.right);",
                        "",
                        "  const firstGroupIndex = parts.findIndex(",
                        "    (part) =>",
                        "      typeof part !== \"string\" && !Array.isArray(part) && part.type === \"group\"",
                        "  );",
                        "",
                        "  // Separate the leftmost expression, possibly with its leading comments.",
                        "  const headParts = parts.slice(",
                        "    0,",
                        "    firstGroupIndex === -1 ? 1 : firstGroupIndex + 1",
                        "  );",
                        "",
                        "  const rest = parts.slice(headParts.length, hasJsx ? -1 : undefined);",
                        "",
                        "  const groupId = Symbol(\"logicalChain-\" + ++uid);",
                        "",
                        "  const chain = group(",
                        "    [",
                        "      // Don't include the initial expression in the indentation",
                        "      // level. The first item is guaranteed to be the first",
                        "      // left-most expression.",
                        "      ...headParts,",
                        "      indent(rest),",
                        "    ],",
                        "    { id: groupId }",
                        "  );",
                        "",
                        "  if (!hasJsx) {",
                        "    return chain;",
                        "  }",
                        "",
                        "  const jsxPart = getLast(parts);",
                        "  return group([chain, indentIfBreak(jsxPart, { groupId })]);",
                        "}",
                        "",
                        "// For binary expressions to be consistent, we need to group",
                        "// subsequent operators with the same precedence level under a single",
                        "// group. Otherwise they will be nested such that some of them break",
                        "// onto new lines but not all. Operators with the same precedence",
                        "// level should either all break or not. Because we group them by",
                        "// precedence level and the AST is structured based on precedence",
                        "// level, things are naturally broken up correctly, i.e. `&&` is",
                        "// broken before `+`.",
                        "function printBinaryishExpressions(",
                        "  path,",
                        "  print,",
                        "  options,",
                        "  isNested,",
                        "  isInsideParenthesis",
                        ") {",
                        "  const node = path.getValue();",
                        "",
                        "  // Simply print the node normally.",
                        "  if (!isBinaryish(node)) {",
                        "    return [group(print())];",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  let parts = [];",
                        "",
                        "  // We treat BinaryExpression and LogicalExpression nodes the same.",
                        "",
                        "  // Put all operators with the same precedence level in the same",
                        "  // group. The reason we only need to do this with the `left`",
                        "  // expression is because given an expression like `1 + 2 - 3`, it",
                        "  // is always parsed like `((1 + 2) - 3)`, meaning the `left` side",
                        "  // is where the rest of the expression will exist. Binary",
                        "  // expressions on the right side mean they have a difference",
                        "  // precedence level and should be treated as a separate group, so",
                        "  // print them normally. (This doesn't hold for the `**` operator,",
                        "  // which is unique in that it is right-associative.)",
                        "  if (shouldFlatten(node.operator, node.left.operator)) {",
                        "    // Flatten them out by recursively calling this function.",
                        "    parts = path.call(",
                        "      (left) =>",
                        "        printBinaryishExpressions(",
                        "          left,",
                        "          print,",
                        "          options,",
                        "          /* isNested */ true,",
                        "          isInsideParenthesis",
                        "        ),",
                        "      \"left\"",
                        "    );",
                        "  } else {",
                        "    parts.push(group(print(\"left\")));",
                        "  }",
                        "",
                        "  const shouldInline = shouldInlineLogicalExpression(node);",
                        "  const lineBeforeOperator =",
                        "    (node.operator === \"|>\" ||",
                        "      node.type === \"NGPipeExpression\" ||",
                        "      (node.operator === \"|\" && options.parser === \"__vue_expression\")) &&",
                        "    !hasLeadingOwnLineComment(options.originalText, node.right);",
                        "",
                        "  const operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;",
                        "  const rightSuffix =",
                        "    node.type === \"NGPipeExpression\" && node.arguments.length > 0",
                        "      ? group(",
                        "          indent([",
                        "            line,",
                        "            \": \",",
                        "            join(",
                        "              [line, \": \"],",
                        "              path.map(print, \"arguments\").map((arg) => align(2, group(arg)))",
                        "            ),",
                        "          ])",
                        "        )",
                        "      : \"\";",
                        "",
                        "  /** @type {Doc} */",
                        "  let right;",
                        "  if (shouldInline) {",
                        "    right = [operator, \" \", print(\"right\"), rightSuffix];",
                        "  } else {",
                        "    const isHackPipeline = isEnabledHackPipeline(options) && operator === \"|>\";",
                        "    const rightContent = isHackPipeline",
                        "      ? path.call(",
                        "          (left) =>",
                        "            printBinaryishExpressions(",
                        "              left,",
                        "              print,",
                        "              options,",
                        "              /* isNested */ true,",
                        "              isInsideParenthesis",
                        "            ),",
                        "          \"right\"",
                        "        )",
                        "      : print(\"right\");",
                        "    right = [",
                        "      lineBeforeOperator ? line : \"\",",
                        "      operator,",
                        "      lineBeforeOperator ? \" \" : line,",
                        "      rightContent,",
                        "      rightSuffix,",
                        "    ];",
                        "  }",
                        "",
                        "  // If there's only a single binary expression, we want to create a group",
                        "  // in order to avoid having a small right part like -1 be on its own line.",
                        "  const parent = path.getParentNode();",
                        "  const shouldBreak = hasComment(",
                        "    node.left,",
                        "    CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "  );",
                        "  const shouldGroup =",
                        "    shouldBreak ||",
                        "    (!(isInsideParenthesis && node.type === \"LogicalExpression\") &&",
                        "      parent.type !== node.type &&",
                        "      node.left.type !== node.type &&",
                        "      node.right.type !== node.type);",
                        "",
                        "  parts.push(",
                        "    lineBeforeOperator ? \"\" : \" \",",
                        "    shouldGroup ? group(right, { shouldBreak }) : right",
                        "  );",
                        "",
                        "  // The root comments are already printed, but we need to manually print",
                        "  // the other ones since we don't call the normal print on BinaryExpression,",
                        "  // only for the left and right parts",
                        "  if (isNested && hasComment(node)) {",
                        "    const printed = cleanDoc(printComments(path, parts, options));",
                        "    /* istanbul ignore else */",
                        "    if (isConcat(printed) || printed.type === \"fill\") {",
                        "      return getDocParts(printed);",
                        "    }",
                        "",
                        "    return [printed];",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldInlineLogicalExpression(node) {",
                        "  if (node.type !== \"LogicalExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    node.right.type === \"ObjectExpression\" &&",
                        "    node.right.properties.length > 0",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.right.type === \"ArrayExpression\" && node.right.elements.length > 0) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (isJsxNode(node.right)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "module.exports = { printBinaryishExpression, shouldInlineLogicalExpression };"
                    ]
                },
                "block.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { hardline, indent },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { printHardlineAfterHeritage } = require(\"./class.js\");",
                        "",
                        "const { printBody } = require(\"./statement.js\");",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "function printBlock(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  if (node.type === \"StaticBlock\") {",
                        "    parts.push(\"static \");",
                        "  }",
                        "",
                        "  if (node.type === \"ClassBody\" && isNonEmptyArray(node.body)) {",
                        "    const parent = path.getParentNode();",
                        "    parts.push(printHardlineAfterHeritage(parent));",
                        "  }",
                        "",
                        "  parts.push(\"{\");",
                        "  const printed = printBlockBody(path, options, print);",
                        "  if (printed) {",
                        "    parts.push(indent([hardline, printed]), hardline);",
                        "  } else {",
                        "    const parent = path.getParentNode();",
                        "    const parentParent = path.getParentNode(1);",
                        "    if (",
                        "      !(",
                        "        parent.type === \"ArrowFunctionExpression\" ||",
                        "        parent.type === \"FunctionExpression\" ||",
                        "        parent.type === \"FunctionDeclaration\" ||",
                        "        parent.type === \"ObjectMethod\" ||",
                        "        parent.type === \"ClassMethod\" ||",
                        "        parent.type === \"ClassPrivateMethod\" ||",
                        "        parent.type === \"ForStatement\" ||",
                        "        parent.type === \"WhileStatement\" ||",
                        "        parent.type === \"DoWhileStatement\" ||",
                        "        parent.type === \"DoExpression\" ||",
                        "        (parent.type === \"CatchClause\" && !parentParent.finalizer) ||",
                        "        parent.type === \"TSModuleDeclaration\" ||",
                        "        parent.type === \"TSDeclareFunction\" ||",
                        "        node.type === \"StaticBlock\" ||",
                        "        node.type === \"ClassBody\"",
                        "      )",
                        "    ) {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  parts.push(\"}\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printBlockBody(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  const nodeHasDirectives = isNonEmptyArray(node.directives);",
                        "  const nodeHasBody = node.body.some((node) => node.type !== \"EmptyStatement\");",
                        "  const nodeHasComment = hasComment(node, CommentCheckFlags.Dangling);",
                        "",
                        "  if (!nodeHasDirectives && !nodeHasBody && !nodeHasComment) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const parts = [];",
                        "  // Babel 6",
                        "  if (nodeHasDirectives) {",
                        "    path.each((childPath, index, directives) => {",
                        "      parts.push(print());",
                        "      if (index < directives.length - 1 || nodeHasBody || nodeHasComment) {",
                        "        parts.push(hardline);",
                        "        if (isNextLineEmpty(childPath.getValue(), options)) {",
                        "          parts.push(hardline);",
                        "        }",
                        "      }",
                        "    }, \"directives\");",
                        "  }",
                        "",
                        "  if (nodeHasBody) {",
                        "    parts.push(printBody(path, options, print));",
                        "  }",
                        "",
                        "  if (nodeHasComment) {",
                        "    parts.push(printDanglingComments(path, options, /* sameIndent */ true));",
                        "  }",
                        "",
                        "  if (node.type === \"Program\") {",
                        "    const parent = path.getParentNode();",
                        "    if (!parent || parent.type !== \"ModuleExpression\") {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "module.exports = { printBlock, printBlockBody };"
                    ]
                },
                "call-arguments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const { getLast, getPenultimate } = require(\"../../common/util.js\");",
                        "const {",
                        "  getFunctionParameters,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isFunctionCompositionArgs,",
                        "  isJsxNode,",
                        "  isLongCurriedCallExpression,",
                        "  shouldPrintComma,",
                        "  getCallArguments,",
                        "  iterateCallArgumentsPath,",
                        "  isNextLineEmpty,",
                        "  isCallExpression,",
                        "  isStringLiteral,",
                        "  isObjectProperty,",
                        "  isTSTypeExpression,",
                        "} = require(\"../utils/index.js\");",
                        "",
                        "const {",
                        "  builders: {",
                        "    line,",
                        "    hardline,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    ifBreak,",
                        "    breakParent,",
                        "  },",
                        "  utils: { willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "const { ArgExpansionBailout } = require(\"../../common/errors.js\");",
                        "const { isConciselyPrintedArray } = require(\"./array.js\");",
                        "",
                        "function printCallArguments(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const isDynamicImport = node.type === \"ImportExpression\";",
                        "",
                        "  const args = getCallArguments(node);",
                        "  if (args.length === 0) {",
                        "    return [",
                        "      \"(\",",
                        "      printDanglingComments(path, options, /* sameIndent */ true),",
                        "      \")\",",
                        "    ];",
                        "  }",
                        "",
                        "  // useEffect(() => { ... }, [foo, bar, baz])",
                        "  if (isReactHookCallWithDepsArray(args)) {",
                        "    return [\"(\", print([\"arguments\", 0]), \", \", print([\"arguments\", 1]), \")\"];",
                        "  }",
                        "",
                        "  let anyArgEmptyLine = false;",
                        "  let hasEmptyLineFollowingFirstArg = false;",
                        "  const lastArgIndex = args.length - 1;",
                        "  const printedArguments = [];",
                        "  iterateCallArgumentsPath(path, (argPath, index) => {",
                        "    const arg = argPath.getNode();",
                        "    const parts = [print()];",
                        "",
                        "    if (index === lastArgIndex) {",
                        "      // do nothing",
                        "    } else if (isNextLineEmpty(arg, options)) {",
                        "      if (index === 0) {",
                        "        hasEmptyLineFollowingFirstArg = true;",
                        "      }",
                        "",
                        "      anyArgEmptyLine = true;",
                        "      parts.push(\",\", hardline, hardline);",
                        "    } else {",
                        "      parts.push(\",\", line);",
                        "    }",
                        "",
                        "    printedArguments.push(parts);",
                        "  });",
                        "",
                        "  const maybeTrailingComma =",
                        "    // Dynamic imports cannot have trailing commas",
                        "    !(isDynamicImport || (node.callee && node.callee.type === \"Import\")) &&",
                        "    shouldPrintComma(options, \"all\")",
                        "      ? \",\"",
                        "      : \"\";",
                        "",
                        "  function allArgsBrokenOut() {",
                        "    return group(",
                        "      [\"(\", indent([line, ...printedArguments]), maybeTrailingComma, line, \")\"],",
                        "      { shouldBreak: true }",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    anyArgEmptyLine ||",
                        "    (path.getParentNode().type !== \"Decorator\" &&",
                        "      isFunctionCompositionArgs(args))",
                        "  ) {",
                        "    return allArgsBrokenOut();",
                        "  }",
                        "",
                        "  const shouldGroupFirst = shouldGroupFirstArg(args);",
                        "  const shouldGroupLast = shouldGroupLastArg(args, options);",
                        "  if (shouldGroupFirst || shouldGroupLast) {",
                        "    if (",
                        "      shouldGroupFirst",
                        "        ? printedArguments.slice(1).some(willBreak)",
                        "        : printedArguments.slice(0, -1).some(willBreak)",
                        "    ) {",
                        "      return allArgsBrokenOut();",
                        "    }",
                        "",
                        "    // We want to print the last argument with a special flag",
                        "    let printedExpanded = [];",
                        "",
                        "    try {",
                        "      path.try(() => {",
                        "        iterateCallArgumentsPath(path, (argPath, i) => {",
                        "          if (shouldGroupFirst && i === 0) {",
                        "            printedExpanded = [",
                        "              [",
                        "                print([], { expandFirstArg: true }),",
                        "                printedArguments.length > 1 ? \",\" : \"\",",
                        "                hasEmptyLineFollowingFirstArg ? hardline : line,",
                        "                hasEmptyLineFollowingFirstArg ? hardline : \"\",",
                        "              ],",
                        "              ...printedArguments.slice(1),",
                        "            ];",
                        "          }",
                        "          if (shouldGroupLast && i === lastArgIndex) {",
                        "            printedExpanded = [",
                        "              ...printedArguments.slice(0, -1),",
                        "              print([], { expandLastArg: true }),",
                        "            ];",
                        "          }",
                        "        });",
                        "      });",
                        "    } catch (caught) {",
                        "      if (caught instanceof ArgExpansionBailout) {",
                        "        return allArgsBrokenOut();",
                        "      }",
                        "      /* istanbul ignore next */",
                        "      throw caught;",
                        "    }",
                        "",
                        "    return [",
                        "      printedArguments.some(willBreak) ? breakParent : \"\",",
                        "      conditionalGroup([",
                        "        [\"(\", ...printedExpanded, \")\"],",
                        "        shouldGroupFirst",
                        "          ? [",
                        "              \"(\",",
                        "              group(printedExpanded[0], { shouldBreak: true }),",
                        "              ...printedExpanded.slice(1),",
                        "              \")\",",
                        "            ]",
                        "          : [",
                        "              \"(\",",
                        "              ...printedArguments.slice(0, -1),",
                        "              group(getLast(printedExpanded), { shouldBreak: true }),",
                        "              \")\",",
                        "            ],",
                        "        allArgsBrokenOut(),",
                        "      ]),",
                        "    ];",
                        "  }",
                        "",
                        "  const contents = [",
                        "    \"(\",",
                        "    indent([softline, ...printedArguments]),",
                        "    ifBreak(maybeTrailingComma),",
                        "    softline,",
                        "    \")\",",
                        "  ];",
                        "  if (isLongCurriedCallExpression(path)) {",
                        "    // By not wrapping the arguments in a group, the printer prioritizes",
                        "    // breaking up these arguments rather than the args of the parent call.",
                        "    return contents;",
                        "  }",
                        "",
                        "  return group(contents, {",
                        "    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine,",
                        "  });",
                        "}",
                        "",
                        "function couldGroupArg(arg, arrowChainRecursion = false) {",
                        "  return (",
                        "    (arg.type === \"ObjectExpression\" &&",
                        "      (arg.properties.length > 0 || hasComment(arg))) ||",
                        "    (arg.type === \"ArrayExpression\" &&",
                        "      (arg.elements.length > 0 || hasComment(arg))) ||",
                        "    (arg.type === \"TSTypeAssertion\" && couldGroupArg(arg.expression)) ||",
                        "    (isTSTypeExpression(arg) && couldGroupArg(arg.expression)) ||",
                        "    arg.type === \"FunctionExpression\" ||",
                        "    (arg.type === \"ArrowFunctionExpression\" &&",
                        "      // we want to avoid breaking inside composite return types but not simple keywords",
                        "      // https://github.com/prettier/prettier/issues/4070",
                        "      // export class Thing implements OtherThing {",
                        "      //   do: (type: Type) => Provider<Prop> = memoize(",
                        "      //     (type: ObjectType): Provider<Opts> => {}",
                        "      //   );",
                        "      // }",
                        "      // https://github.com/prettier/prettier/issues/6099",
                        "      // app.get(\"/\", (req, res): void => {",
                        "      //   res.send(\"Hello World!\");",
                        "      // });",
                        "      (!arg.returnType ||",
                        "        !arg.returnType.typeAnnotation ||",
                        "        arg.returnType.typeAnnotation.type !== \"TSTypeReference\" ||",
                        "        // https://github.com/prettier/prettier/issues/7542",
                        "        isNonEmptyBlockStatement(arg.body)) &&",
                        "      (arg.body.type === \"BlockStatement\" ||",
                        "        (arg.body.type === \"ArrowFunctionExpression\" &&",
                        "          couldGroupArg(arg.body, true)) ||",
                        "        arg.body.type === \"ObjectExpression\" ||",
                        "        arg.body.type === \"ArrayExpression\" ||",
                        "        (!arrowChainRecursion &&",
                        "          (isCallExpression(arg.body) ||",
                        "            arg.body.type === \"ConditionalExpression\")) ||",
                        "        isJsxNode(arg.body))) ||",
                        "    arg.type === \"DoExpression\" ||",
                        "    arg.type === \"ModuleExpression\"",
                        "  );",
                        "}",
                        "",
                        "function shouldGroupLastArg(args, options) {",
                        "  const lastArg = getLast(args);",
                        "  const penultimateArg = getPenultimate(args);",
                        "  return (",
                        "    !hasComment(lastArg, CommentCheckFlags.Leading) &&",
                        "    !hasComment(lastArg, CommentCheckFlags.Trailing) &&",
                        "    couldGroupArg(lastArg) &&",
                        "    // If the last two arguments are of the same type,",
                        "    // disable last element expansion.",
                        "    (!penultimateArg || penultimateArg.type !== lastArg.type) &&",
                        "    // useMemo(() => func(), [foo, bar, baz])",
                        "    (args.length !== 2 ||",
                        "      penultimateArg.type !== \"ArrowFunctionExpression\" ||",
                        "      lastArg.type !== \"ArrayExpression\") &&",
                        "    !(",
                        "      args.length > 1 &&",
                        "      lastArg.type === \"ArrayExpression\" &&",
                        "      isConciselyPrintedArray(lastArg, options)",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function shouldGroupFirstArg(args) {",
                        "  if (args.length !== 2) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const [firstArg, secondArg] = args;",
                        "",
                        "  if (",
                        "    firstArg.type === \"ModuleExpression\" &&",
                        "    isTypeModuleObjectExpression(secondArg)",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return (",
                        "    !hasComment(firstArg) &&",
                        "    (firstArg.type === \"FunctionExpression\" ||",
                        "      (firstArg.type === \"ArrowFunctionExpression\" &&",
                        "        firstArg.body.type === \"BlockStatement\")) &&",
                        "    secondArg.type !== \"FunctionExpression\" &&",
                        "    secondArg.type !== \"ArrowFunctionExpression\" &&",
                        "    secondArg.type !== \"ConditionalExpression\" &&",
                        "    !couldGroupArg(secondArg)",
                        "  );",
                        "}",
                        "",
                        "function isReactHookCallWithDepsArray(args) {",
                        "  return (",
                        "    args.length === 2 &&",
                        "    args[0].type === \"ArrowFunctionExpression\" &&",
                        "    getFunctionParameters(args[0]).length === 0 &&",
                        "    args[0].body.type === \"BlockStatement\" &&",
                        "    args[1].type === \"ArrayExpression\" &&",
                        "    !args.some((arg) => hasComment(arg))",
                        "  );",
                        "}",
                        "",
                        "function isNonEmptyBlockStatement(node) {",
                        "  return (",
                        "    node.type === \"BlockStatement\" &&",
                        "    (node.body.some((node) => node.type !== \"EmptyStatement\") ||",
                        "      hasComment(node, CommentCheckFlags.Dangling))",
                        "  );",
                        "}",
                        "",
                        "// { type: \"module\" }",
                        "function isTypeModuleObjectExpression(node) {",
                        "  return (",
                        "    node.type === \"ObjectExpression\" &&",
                        "    node.properties.length === 1 &&",
                        "    isObjectProperty(node.properties[0]) &&",
                        "    node.properties[0].key.type === \"Identifier\" &&",
                        "    node.properties[0].key.name === \"type\" &&",
                        "    isStringLiteral(node.properties[0].value) &&",
                        "    node.properties[0].value.value === \"module\"",
                        "  );",
                        "}",
                        "",
                        "module.exports = printCallArguments;"
                    ]
                },
                "call-expression.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { join, group },",
                        "} = require(\"../../document/index.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const {",
                        "  getCallArguments,",
                        "  hasFlowAnnotationComment,",
                        "  isCallExpression,",
                        "  isMemberish,",
                        "  isStringLiteral,",
                        "  isTemplateOnItsOwnLine,",
                        "  isTestCall,",
                        "  iterateCallArgumentsPath,",
                        "} = require(\"../utils/index.js\");",
                        "const printMemberChain = require(\"./member-chain.js\");",
                        "const printCallArguments = require(\"./call-arguments.js\");",
                        "const {",
                        "  printOptionalToken,",
                        "  printFunctionTypeParameters,",
                        "} = require(\"./misc.js\");",
                        "",
                        "function printCallExpression(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parentNode = path.getParentNode();",
                        "  const isNew = node.type === \"NewExpression\";",
                        "  const isDynamicImport = node.type === \"ImportExpression\";",
                        "",
                        "  const optional = printOptionalToken(path);",
                        "  const args = getCallArguments(node);",
                        "  if (",
                        "    // Dangling comments are not handled, all these special cases should have arguments #9668",
                        "    args.length > 0 &&",
                        "    // We want to keep CommonJS- and AMD-style require calls, and AMD-style",
                        "    // define calls, as a unit.",
                        "    // e.g. `define([\"some/lib\"], (lib) => {`",
                        "    ((!isDynamicImport && !isNew && isCommonsJsOrAmdCall(node, parentNode)) ||",
                        "      // Template literals as single arguments",
                        "      (args.length === 1 &&",
                        "        isTemplateOnItsOwnLine(args[0], options.originalText)) ||",
                        "      // Keep test declarations on a single line",
                        "      // e.g. `it('long name', () => {`",
                        "      (!isNew && isTestCall(node, parentNode)))",
                        "  ) {",
                        "    const printed = [];",
                        "    iterateCallArgumentsPath(path, () => {",
                        "      printed.push(print());",
                        "    });",
                        "    return [",
                        "      isNew ? \"new \" : \"\",",
                        "      print(\"callee\"),",
                        "      optional,",
                        "      printFunctionTypeParameters(path, options, print),",
                        "      \"(\",",
                        "      join(\", \", printed),",
                        "      \")\",",
                        "    ];",
                        "  }",
                        "",
                        "  // Inline Flow annotation comments following Identifiers in Call nodes need to",
                        "  // stay with the Identifier. For example:",
                        "  //",
                        "  // foo /*:: <SomeGeneric> */(bar);",
                        "  //",
                        "  // Here, we ensure that such comments stay between the Identifier and the Callee.",
                        "  const isIdentifierWithFlowAnnotation =",
                        "    (options.parser === \"babel\" || options.parser === \"babel-flow\") &&",
                        "    node.callee &&",
                        "    node.callee.type === \"Identifier\" &&",
                        "    hasFlowAnnotationComment(node.callee.trailingComments);",
                        "  if (isIdentifierWithFlowAnnotation) {",
                        "    node.callee.trailingComments[0].printed = true;",
                        "  }",
                        "",
                        "  // We detect calls on member lookups and possibly print them in a",
                        "  // special chain format. See `printMemberChain` for more info.",
                        "  if (",
                        "    !isDynamicImport &&",
                        "    !isNew &&",
                        "    isMemberish(node.callee) &&",
                        "    !path.call((path) => pathNeedsParens(path, options), \"callee\")",
                        "  ) {",
                        "    return printMemberChain(path, options, print);",
                        "  }",
                        "",
                        "  const contents = [",
                        "    isNew ? \"new \" : \"\",",
                        "    isDynamicImport ? \"import\" : print(\"callee\"),",
                        "    optional,",
                        "    isIdentifierWithFlowAnnotation",
                        "      ? `/*:: ${node.callee.trailingComments[0].value.slice(2).trim()} */`",
                        "      : \"\",",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    printCallArguments(path, options, print),",
                        "  ];",
                        "",
                        "  // We group here when the callee is itself a call expression.",
                        "  // See `isLongCurriedCallExpression` for more info.",
                        "  if (isDynamicImport || isCallExpression(node.callee)) {",
                        "    return group(contents);",
                        "  }",
                        "",
                        "  return contents;",
                        "}",
                        "",
                        "function isCommonsJsOrAmdCall(node, parentNode) {",
                        "  if (node.callee.type !== \"Identifier\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (node.callee.name === \"require\") {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.callee.name === \"define\") {",
                        "    const args = getCallArguments(node);",
                        "    return (",
                        "      parentNode.type === \"ExpressionStatement\" &&",
                        "      (args.length === 1 ||",
                        "        (args.length === 2 && args[0].type === \"ArrayExpression\") ||",
                        "        (args.length === 3 &&",
                        "          isStringLiteral(args[0]) &&",
                        "          args[1].type === \"ArrayExpression\"))",
                        "    );",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "module.exports = { printCallExpression };"
                    ]
                },
                "class.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  isNonEmptyArray,",
                        "  createGroupIdMapper,",
                        "} = require(\"../../common/util.js\");",
                        "const {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "} = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { join, line, hardline, softline, group, indent, ifBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const { hasComment, CommentCheckFlags } = require(\"../utils/index.js\");",
                        "const { getTypeParametersGroupId } = require(\"./type-parameters.js\");",
                        "const { printMethod } = require(\"./function.js\");",
                        "const {",
                        "  printOptionalToken,",
                        "  printTypeAnnotation,",
                        "  printDefiniteToken,",
                        "} = require(\"./misc.js\");",
                        "const { printPropertyKey } = require(\"./property.js\");",
                        "const { printAssignment } = require(\"./assignment.js\");",
                        "const { printClassMemberDecorators } = require(\"./decorators.js\");",
                        "",
                        "function printClass(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "",
                        "  if (node.abstract) {",
                        "    parts.push(\"abstract \");",
                        "  }",
                        "",
                        "  parts.push(\"class\");",
                        "",
                        "  // Keep old behaviour of extends in same line",
                        "  // If there is only on extends and there are not comments",
                        "  const groupMode =",
                        "    (node.id && hasComment(node.id, CommentCheckFlags.Trailing)) ||",
                        "    (node.typeParameters &&",
                        "      hasComment(node.typeParameters, CommentCheckFlags.Trailing)) ||",
                        "    (node.superClass && hasComment(node.superClass)) ||",
                        "    isNonEmptyArray(node.extends) || // DeclareClass",
                        "    isNonEmptyArray(node.mixins) ||",
                        "    isNonEmptyArray(node.implements);",
                        "",
                        "  const partsGroup = [];",
                        "  const extendsParts = [];",
                        "",
                        "  if (node.id) {",
                        "    partsGroup.push(\" \", print(\"id\"));",
                        "  }",
                        "",
                        "  partsGroup.push(print(\"typeParameters\"));",
                        "",
                        "  if (node.superClass) {",
                        "    const printed = [",
                        "      printSuperClass(path, options, print),",
                        "      print(\"superTypeParameters\"),",
                        "    ];",
                        "    const printedWithComments = path.call(",
                        "      (superClass) => [\"extends \", printComments(superClass, printed, options)],",
                        "      \"superClass\"",
                        "    );",
                        "    if (groupMode) {",
                        "      extendsParts.push(line, group(printedWithComments));",
                        "    } else {",
                        "      extendsParts.push(\" \", printedWithComments);",
                        "    }",
                        "  } else {",
                        "    extendsParts.push(printList(path, options, print, \"extends\"));",
                        "  }",
                        "",
                        "  extendsParts.push(",
                        "    printList(path, options, print, \"mixins\"),",
                        "    printList(path, options, print, \"implements\")",
                        "  );",
                        "",
                        "  if (groupMode) {",
                        "    let printedPartsGroup;",
                        "    if (shouldIndentOnlyHeritageClauses(node)) {",
                        "      printedPartsGroup = [...partsGroup, indent(extendsParts)];",
                        "    } else {",
                        "      printedPartsGroup = indent([...partsGroup, extendsParts]);",
                        "    }",
                        "    parts.push(group(printedPartsGroup, { id: getHeritageGroupId(node) }));",
                        "  } else {",
                        "    parts.push(...partsGroup, ...extendsParts);",
                        "  }",
                        "",
                        "  parts.push(\" \", print(\"body\"));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "const getHeritageGroupId = createGroupIdMapper(\"heritageGroup\");",
                        "",
                        "function printHardlineAfterHeritage(node) {",
                        "  return ifBreak(hardline, \"\", { groupId: getHeritageGroupId(node) });",
                        "}",
                        "",
                        "function hasMultipleHeritage(node) {",
                        "  return (",
                        "    [\"superClass\", \"extends\", \"mixins\", \"implements\"].filter((key) =>",
                        "      Boolean(node[key])",
                        "    ).length > 1",
                        "  );",
                        "}",
                        "",
                        "function shouldIndentOnlyHeritageClauses(node) {",
                        "  return (",
                        "    node.typeParameters &&",
                        "    !hasComment(",
                        "      node.typeParameters,",
                        "      CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "    ) &&",
                        "    !hasMultipleHeritage(node)",
                        "  );",
                        "}",
                        "",
                        "function printList(path, options, print, listName) {",
                        "  const node = path.getValue();",
                        "  if (!isNonEmptyArray(node[listName])) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const printedLeadingComments = printDanglingComments(",
                        "    path,",
                        "    options,",
                        "    /* sameIndent */ true,",
                        "    ({ marker }) => marker === listName",
                        "  );",
                        "  return [",
                        "    shouldIndentOnlyHeritageClauses(node)",
                        "      ? ifBreak(\" \", line, {",
                        "          groupId: getTypeParametersGroupId(node.typeParameters),",
                        "        })",
                        "      : line,",
                        "    printedLeadingComments,",
                        "    printedLeadingComments && hardline,",
                        "    listName,",
                        "    group(indent([line, join([\",\", line], path.map(print, listName))])),",
                        "  ];",
                        "}",
                        "",
                        "function printSuperClass(path, options, print) {",
                        "  const printed = print(\"superClass\");",
                        "  const parent = path.getParentNode();",
                        "  if (parent.type === \"AssignmentExpression\") {",
                        "    return group(",
                        "      ifBreak([\"(\", indent([softline, printed]), softline, \")\"], printed)",
                        "    );",
                        "  }",
                        "  return printed;",
                        "}",
                        "",
                        "function printClassMethod(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  if (isNonEmptyArray(node.decorators)) {",
                        "    parts.push(printClassMemberDecorators(path, options, print));",
                        "  }",
                        "  if (node.accessibility) {",
                        "    parts.push(node.accessibility + \" \");",
                        "  }",
                        "  // \"readonly\" and \"declare\" are supported by only \"babel-ts\"",
                        "  // https://github.com/prettier/prettier/issues/9760",
                        "  if (node.readonly) {",
                        "    parts.push(\"readonly \");",
                        "  }",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "",
                        "  if (node.static) {",
                        "    parts.push(\"static \");",
                        "  }",
                        "  if (node.type === \"TSAbstractMethodDefinition\" || node.abstract) {",
                        "    parts.push(\"abstract \");",
                        "  }",
                        "  if (node.override) {",
                        "    parts.push(\"override \");",
                        "  }",
                        "",
                        "  parts.push(printMethod(path, options, print));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printClassProperty(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "",
                        "  if (isNonEmptyArray(node.decorators)) {",
                        "    parts.push(printClassMemberDecorators(path, options, print));",
                        "  }",
                        "  if (node.accessibility) {",
                        "    parts.push(node.accessibility + \" \");",
                        "  }",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "  if (node.static) {",
                        "    parts.push(\"static \");",
                        "  }",
                        "  if (",
                        "    node.type === \"TSAbstractPropertyDefinition\" ||",
                        "    node.type === \"TSAbstractAccessorProperty\" ||",
                        "    node.abstract",
                        "  ) {",
                        "    parts.push(\"abstract \");",
                        "  }",
                        "  if (node.override) {",
                        "    parts.push(\"override \");",
                        "  }",
                        "  if (node.readonly) {",
                        "    parts.push(\"readonly \");",
                        "  }",
                        "  if (node.variance) {",
                        "    parts.push(print(\"variance\"));",
                        "  }",
                        "  if (",
                        "    node.type === \"ClassAccessorProperty\" ||",
                        "    node.type === \"AccessorProperty\" ||",
                        "    node.type === \"TSAbstractAccessorProperty\"",
                        "  ) {",
                        "    parts.push(\"accessor \");",
                        "  }",
                        "  parts.push(",
                        "    printPropertyKey(path, options, print),",
                        "    printOptionalToken(path),",
                        "    printDefiniteToken(path),",
                        "    printTypeAnnotation(path, options, print)",
                        "  );",
                        "",
                        "  return [printAssignment(path, options, print, parts, \" =\", \"value\"), semi];",
                        "}",
                        "",
                        "module.exports = {",
                        "  printClass,",
                        "  printClassMethod,",
                        "  printClassProperty,",
                        "  printHardlineAfterHeritage,",
                        "};"
                    ]
                },
                "comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { hasNewline } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { join, hardline },",
                        "  utils: { replaceTextEndOfLine },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "const { isLineComment } = require(\"../utils/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const isBlockComment = require(\"../utils/is-block-comment.js\");",
                        "",
                        "function printComment(commentPath, options) {",
                        "  const comment = commentPath.getValue();",
                        "",
                        "  if (isLineComment(comment)) {",
                        "    // Supports `//`, `#!`, `<!--`, and `-->`",
                        "    return options.originalText",
                        "      .slice(locStart(comment), locEnd(comment))",
                        "      .trimEnd();",
                        "  }",
                        "",
                        "  if (isBlockComment(comment)) {",
                        "    if (isIndentableBlockComment(comment)) {",
                        "      const printed = printIndentableBlockComment(comment);",
                        "      // We need to prevent an edge case of a previous trailing comment",
                        "      // printed as a `lineSuffix` which causes the comments to be",
                        "      // interleaved. See https://github.com/prettier/prettier/issues/4412",
                        "      if (",
                        "        comment.trailing &&",
                        "        !hasNewline(options.originalText, locStart(comment), {",
                        "          backwards: true,",
                        "        })",
                        "      ) {",
                        "        return [hardline, printed];",
                        "      }",
                        "      return printed;",
                        "    }",
                        "",
                        "    const commentEnd = locEnd(comment);",
                        "    const isInsideFlowComment =",
                        "      options.originalText.slice(commentEnd - 3, commentEnd) === \"*-/\";",
                        "    return [",
                        "      \"/*\",",
                        "      replaceTextEndOfLine(comment.value),",
                        "      isInsideFlowComment ? \"*-/\" : \"*/\",",
                        "    ];",
                        "  }",
                        "",
                        "  /* istanbul ignore next */",
                        "  throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                        "}",
                        "",
                        "function isIndentableBlockComment(comment) {",
                        "  // If the comment has multiple lines and every line starts with a star",
                        "  // we can fix the indentation of each line. The stars in the `/*` and",
                        "  // `*/` delimiters are not included in the comment value, so add them",
                        "  // back first.",
                        "  const lines = `*${comment.value}*`.split(\"\\n\");",
                        "  return lines.length > 1 && lines.every((line) => line.trim()[0] === \"*\");",
                        "}",
                        "",
                        "function printIndentableBlockComment(comment) {",
                        "  const lines = comment.value.split(\"\\n\");",
                        "",
                        "  return [",
                        "    \"/*\",",
                        "    join(",
                        "      hardline,",
                        "      lines.map((line, index) =>",
                        "        index === 0",
                        "          ? line.trimEnd()",
                        "          : \" \" + (index < lines.length - 1 ? line.trim() : line.trimStart())",
                        "      )",
                        "    ),",
                        "    \"*/\",",
                        "  ];",
                        "}",
                        "",
                        "module.exports = { printComment };"
                    ]
                },
                "decorators.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray, hasNewline } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { line, hardline, join, breakParent, group },",
                        "} = require(\"../../document/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const { getParentExportDeclaration } = require(\"../utils/index.js\");",
                        "",
                        "function printClassMemberDecorators(path, options, print) {",
                        "  const node = path.getValue();",
                        "  return group([",
                        "    join(line, path.map(print, \"decorators\")),",
                        "    hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line,",
                        "  ]);",
                        "}",
                        "",
                        "function printDecoratorsBeforeExport(path, options, print) {",
                        "  // Export declarations are responsible for printing any decorators",
                        "  // that logically apply to node.declaration.",
                        "  return [",
                        "    join(hardline, path.map(print, \"declaration\", \"decorators\")),",
                        "    hardline,",
                        "  ];",
                        "}",
                        "",
                        "function printDecorators(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const { decorators } = node;",
                        "",
                        "  if (",
                        "    !isNonEmptyArray(decorators) ||",
                        "    // If the parent node is an export declaration and the decorator",
                        "    // was written before the export, the export will be responsible",
                        "    // for printing the decorators.",
                        "    hasDecoratorsBeforeExport(path.getParentNode())",
                        "  ) {",
                        "    return;",
                        "  }",
                        "",
                        "  const shouldBreak =",
                        "    node.type === \"ClassExpression\" ||",
                        "    node.type === \"ClassDeclaration\" ||",
                        "    hasNewlineBetweenOrAfterDecorators(node, options);",
                        "",
                        "  return [",
                        "    getParentExportDeclaration(path)",
                        "      ? hardline",
                        "      : shouldBreak",
                        "      ? breakParent",
                        "      : \"\",",
                        "    join(line, path.map(print, \"decorators\")),",
                        "    line,",
                        "  ];",
                        "}",
                        "",
                        "function hasNewlineBetweenOrAfterDecorators(node, options) {",
                        "  return node.decorators.some((decorator) =>",
                        "    hasNewline(options.originalText, locEnd(decorator))",
                        "  );",
                        "}",
                        "",
                        "function hasDecoratorsBeforeExport(node) {",
                        "  if (",
                        "    node.type !== \"ExportDefaultDeclaration\" &&",
                        "    node.type !== \"ExportNamedDeclaration\" &&",
                        "    node.type !== \"DeclareExportDeclaration\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const decorators = node.declaration && node.declaration.decorators;",
                        "",
                        "  return (",
                        "    isNonEmptyArray(decorators) && locStart(node) === locStart(decorators[0])",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  printDecorators,",
                        "  printClassMemberDecorators,",
                        "  printDecoratorsBeforeExport,",
                        "  hasDecoratorsBeforeExport,",
                        "};"
                    ]
                },
                "flow.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "const assert = require(\"assert\");",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const { printString, printNumber } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { hardline, softline, group, indent },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  getParentExportDeclaration,",
                        "  isFunctionNotation,",
                        "  isGetterOrSetter,",
                        "  rawText,",
                        "  shouldPrintComma,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const { replaceTextEndOfLine } = require(\"../../document/doc-utils.js\");",
                        "const { printClass } = require(\"./class.js\");",
                        "const {",
                        "  printOpaqueType,",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printTupleType,",
                        "  printIndexedAccessType,",
                        "} = require(\"./type-annotation.js\");",
                        "const { printInterface } = require(\"./interface.js\");",
                        "const {",
                        "  printTypeParameter,",
                        "  printTypeParameters,",
                        "} = require(\"./type-parameters.js\");",
                        "const {",
                        "  printExportDeclaration,",
                        "  printExportAllDeclaration,",
                        "} = require(\"./module.js\");",
                        "const { printArrayItems } = require(\"./array.js\");",
                        "const { printObject } = require(\"./object.js\");",
                        "const { printPropertyKey } = require(\"./property.js\");",
                        "const {",
                        "  printOptionalToken,",
                        "  printTypeAnnotation,",
                        "  printRestSpread,",
                        "} = require(\"./misc.js\");",
                        "",
                        "function printFlow(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "  switch (node.type) {",
                        "    case \"DeclareClass\":",
                        "      return printFlowDeclaration(path, printClass(path, options, print));",
                        "    case \"DeclareFunction\":",
                        "      return printFlowDeclaration(path, [",
                        "        \"function \",",
                        "        print(\"id\"),",
                        "        node.predicate ? \" \" : \"\",",
                        "        print(\"predicate\"),",
                        "        semi,",
                        "      ]);",
                        "    case \"DeclareModule\":",
                        "      return printFlowDeclaration(path, [",
                        "        \"module \",",
                        "        print(\"id\"),",
                        "        \" \",",
                        "        print(\"body\"),",
                        "      ]);",
                        "    case \"DeclareModuleExports\":",
                        "      return printFlowDeclaration(path, [",
                        "        \"module.exports\",",
                        "        \": \",",
                        "        print(\"typeAnnotation\"),",
                        "        semi,",
                        "      ]);",
                        "    case \"DeclareVariable\":",
                        "      return printFlowDeclaration(path, [\"var \", print(\"id\"), semi]);",
                        "    case \"DeclareOpaqueType\":",
                        "      return printFlowDeclaration(path, printOpaqueType(path, options, print));",
                        "    case \"DeclareInterface\":",
                        "      return printFlowDeclaration(path, printInterface(path, options, print));",
                        "    case \"DeclareTypeAlias\":",
                        "      return printFlowDeclaration(path, printTypeAlias(path, options, print));",
                        "    case \"DeclareExportDeclaration\":",
                        "      return printFlowDeclaration(",
                        "        path,",
                        "        printExportDeclaration(path, options, print)",
                        "      );",
                        "    case \"DeclareExportAllDeclaration\":",
                        "      return printFlowDeclaration(",
                        "        path,",
                        "        printExportAllDeclaration(path, options, print)",
                        "      );",
                        "    case \"OpaqueType\":",
                        "      return printOpaqueType(path, options, print);",
                        "    case \"TypeAlias\":",
                        "      return printTypeAlias(path, options, print);",
                        "    case \"IntersectionTypeAnnotation\":",
                        "      return printIntersectionType(path, options, print);",
                        "    case \"UnionTypeAnnotation\":",
                        "      return printUnionType(path, options, print);",
                        "    case \"FunctionTypeAnnotation\":",
                        "      return printFunctionType(path, options, print);",
                        "    case \"TupleTypeAnnotation\":",
                        "      return printTupleType(path, options, print);",
                        "    case \"GenericTypeAnnotation\":",
                        "      return [",
                        "        print(\"id\"),",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"IndexedAccessType\":",
                        "    case \"OptionalIndexedAccessType\":",
                        "      return printIndexedAccessType(path, options, print);",
                        "    // Type Annotations for Facebook Flow, typically stripped out or",
                        "    // transformed away before printing.",
                        "    case \"TypeAnnotation\":",
                        "      return print(\"typeAnnotation\");",
                        "    case \"TypeParameter\":",
                        "      return printTypeParameter(path, options, print);",
                        "    case \"TypeofTypeAnnotation\":",
                        "      return [\"typeof \", print(\"argument\")];",
                        "    case \"ExistsTypeAnnotation\":",
                        "      return \"*\";",
                        "    case \"EmptyTypeAnnotation\":",
                        "      return \"empty\";",
                        "    case \"MixedTypeAnnotation\":",
                        "      return \"mixed\";",
                        "    case \"ArrayTypeAnnotation\":",
                        "      return [print(\"elementType\"), \"[]\"];",
                        "    case \"BooleanLiteralTypeAnnotation\":",
                        "      return String(node.value);",
                        "    case \"EnumDeclaration\":",
                        "      return [\"enum \", print(\"id\"), \" \", print(\"body\")];",
                        "    case \"EnumBooleanBody\":",
                        "    case \"EnumNumberBody\":",
                        "    case \"EnumStringBody\":",
                        "    case \"EnumSymbolBody\": {",
                        "      if (node.type === \"EnumSymbolBody\" || node.explicitType) {",
                        "        let type = null;",
                        "        switch (node.type) {",
                        "          case \"EnumBooleanBody\":",
                        "            type = \"boolean\";",
                        "            break;",
                        "          case \"EnumNumberBody\":",
                        "            type = \"number\";",
                        "            break;",
                        "          case \"EnumStringBody\":",
                        "            type = \"string\";",
                        "            break;",
                        "          case \"EnumSymbolBody\":",
                        "            type = \"symbol\";",
                        "            break;",
                        "        }",
                        "        parts.push(\"of \", type, \" \");",
                        "      }",
                        "      if (node.members.length === 0 && !node.hasUnknownMembers) {",
                        "        parts.push(",
                        "          group([\"{\", printDanglingComments(path, options), softline, \"}\"])",
                        "        );",
                        "      } else {",
                        "        const members =",
                        "          node.members.length > 0",
                        "            ? [",
                        "                hardline,",
                        "                printArrayItems(path, options, \"members\", print),",
                        "                node.hasUnknownMembers || shouldPrintComma(options) ? \",\" : \"\",",
                        "              ]",
                        "            : [];",
                        "",
                        "        parts.push(",
                        "          group([",
                        "            \"{\",",
                        "            indent([",
                        "              ...members,",
                        "              ...(node.hasUnknownMembers ? [hardline, \"...\"] : []),",
                        "            ]),",
                        "            printDanglingComments(path, options, /* sameIndent */ true),",
                        "            hardline,",
                        "            \"}\",",
                        "          ])",
                        "        );",
                        "      }",
                        "      return parts;",
                        "    }",
                        "    case \"EnumBooleanMember\":",
                        "    case \"EnumNumberMember\":",
                        "    case \"EnumStringMember\":",
                        "      return [",
                        "        print(\"id\"),",
                        "        \" = \",",
                        "        typeof node.init === \"object\" ? print(\"init\") : String(node.init),",
                        "      ];",
                        "    case \"EnumDefaultedMember\":",
                        "      return print(\"id\");",
                        "    case \"FunctionTypeParam\": {",
                        "      const name = node.name",
                        "        ? print(\"name\")",
                        "        : path.getParentNode().this === node",
                        "        ? \"this\"",
                        "        : \"\";",
                        "      return [",
                        "        name,",
                        "        printOptionalToken(path),",
                        "        name ? \": \" : \"\",",
                        "        print(\"typeAnnotation\"),",
                        "      ];",
                        "    }",
                        "",
                        "    case \"InterfaceDeclaration\":",
                        "    case \"InterfaceTypeAnnotation\":",
                        "      return printInterface(path, options, print);",
                        "    case \"ClassImplements\":",
                        "    case \"InterfaceExtends\":",
                        "      return [print(\"id\"), print(\"typeParameters\")];",
                        "    case \"NullableTypeAnnotation\":",
                        "      return [\"?\", print(\"typeAnnotation\")];",
                        "    case \"Variance\": {",
                        "      const { kind } = node;",
                        "      assert.ok(kind === \"plus\" || kind === \"minus\");",
                        "      return kind === \"plus\" ? \"+\" : \"-\";",
                        "    }",
                        "    case \"ObjectTypeCallProperty\":",
                        "      if (node.static) {",
                        "        parts.push(\"static \");",
                        "      }",
                        "",
                        "      parts.push(print(\"value\"));",
                        "",
                        "      return parts;",
                        "    case \"ObjectTypeIndexer\": {",
                        "      return [",
                        "        node.static ? \"static \" : \"\",",
                        "        node.variance ? print(\"variance\") : \"\",",
                        "        \"[\",",
                        "        print(\"id\"),",
                        "        node.id ? \": \" : \"\",",
                        "        print(\"key\"),",
                        "        \"]: \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    }",
                        "    case \"ObjectTypeProperty\": {",
                        "      let modifier = \"\";",
                        "",
                        "      if (node.proto) {",
                        "        modifier = \"proto \";",
                        "      } else if (node.static) {",
                        "        modifier = \"static \";",
                        "      }",
                        "",
                        "      return [",
                        "        modifier,",
                        "        isGetterOrSetter(node) ? node.kind + \" \" : \"\",",
                        "        node.variance ? print(\"variance\") : \"\",",
                        "        printPropertyKey(path, options, print),",
                        "        printOptionalToken(path),",
                        "        isFunctionNotation(node) ? \"\" : \": \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    }",
                        "    case \"ObjectTypeAnnotation\":",
                        "      return printObject(path, options, print);",
                        "    case \"ObjectTypeInternalSlot\":",
                        "      return [",
                        "        node.static ? \"static \" : \"\",",
                        "        \"[[\",",
                        "        print(\"id\"),",
                        "        \"]]\",",
                        "        printOptionalToken(path),",
                        "        node.method ? \"\" : \": \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    // Same as `RestElement`",
                        "    case \"ObjectTypeSpreadProperty\":",
                        "      return printRestSpread(path, options, print);",
                        "    case \"QualifiedTypeofIdentifier\":",
                        "    case \"QualifiedTypeIdentifier\":",
                        "      return [print(\"qualification\"), \".\", print(\"id\")];",
                        "    case \"StringLiteralTypeAnnotation\":",
                        "      return replaceTextEndOfLine(printString(rawText(node), options));",
                        "    case \"NumberLiteralTypeAnnotation\":",
                        "      assert.strictEqual(typeof node.value, \"number\");",
                        "    // fall through",
                        "    case \"BigIntLiteralTypeAnnotation\":",
                        "      if (node.extra) {",
                        "        return printNumber(node.extra.raw);",
                        "      }",
                        "      return printNumber(node.raw);",
                        "    case \"TypeCastExpression\": {",
                        "      return [",
                        "        \"(\",",
                        "        print(\"expression\"),",
                        "        printTypeAnnotation(path, options, print),",
                        "        \")\",",
                        "      ];",
                        "    }",
                        "",
                        "    case \"TypeParameterDeclaration\":",
                        "    case \"TypeParameterInstantiation\": {",
                        "      const printed = printTypeParameters(path, options, print, \"params\");",
                        "",
                        "      if (options.parser === \"flow\") {",
                        "        const start = locStart(node);",
                        "        const end = locEnd(node);",
                        "        const commentStartIndex = options.originalText.lastIndexOf(\"/*\", start);",
                        "        const commentEndIndex = options.originalText.indexOf(\"*/\", end);",
                        "        if (commentStartIndex !== -1 && commentEndIndex !== -1) {",
                        "          const comment = options.originalText",
                        "            .slice(commentStartIndex + 2, commentEndIndex)",
                        "            .trim();",
                        "          if (",
                        "            comment.startsWith(\"::\") &&",
                        "            !comment.includes(\"/*\") &&",
                        "            !comment.includes(\"*/\")",
                        "          ) {",
                        "            return [\"/*:: \", printed, \" */\"];",
                        "          }",
                        "        }",
                        "      }",
                        "",
                        "      return printed;",
                        "    }",
                        "",
                        "    case \"InferredPredicate\":",
                        "      return \"%checks\";",
                        "    // Unhandled types below. If encountered, nodes of these types should",
                        "    // be either left alone or desugared into AST types that are fully",
                        "    // supported by the pretty-printer.",
                        "    case \"DeclaredPredicate\":",
                        "      return [\"%checks(\", print(\"value\"), \")\"];",
                        "    case \"AnyTypeAnnotation\":",
                        "      return \"any\";",
                        "    case \"BooleanTypeAnnotation\":",
                        "      return \"boolean\";",
                        "    case \"BigIntTypeAnnotation\":",
                        "      return \"bigint\";",
                        "    case \"NullLiteralTypeAnnotation\":",
                        "      return \"null\";",
                        "    case \"NumberTypeAnnotation\":",
                        "      return \"number\";",
                        "    case \"SymbolTypeAnnotation\":",
                        "      return \"symbol\";",
                        "    case \"StringTypeAnnotation\":",
                        "      return \"string\";",
                        "    case \"VoidTypeAnnotation\":",
                        "      return \"void\";",
                        "    case \"ThisTypeAnnotation\":",
                        "      return \"this\";",
                        "    // These types are unprintable because they serve as abstract",
                        "    // supertypes for other (printable) types.",
                        "    case \"Node\":",
                        "    case \"Printable\":",
                        "    case \"SourceLocation\":",
                        "    case \"Position\":",
                        "    case \"Statement\":",
                        "    case \"Function\":",
                        "    case \"Pattern\":",
                        "    case \"Expression\":",
                        "    case \"Declaration\":",
                        "    case \"Specifier\":",
                        "    case \"NamedSpecifier\":",
                        "    case \"Comment\":",
                        "    case \"MemberTypeAnnotation\": // Flow",
                        "    case \"Type\":",
                        "      /* istanbul ignore next */",
                        "      throw new Error(\"unprintable type: \" + JSON.stringify(node.type));",
                        "  }",
                        "}",
                        "",
                        "function printFlowDeclaration(path, printed) {",
                        "  const parentExportDecl = getParentExportDeclaration(path);",
                        "",
                        "  if (parentExportDecl) {",
                        "    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");",
                        "    return printed;",
                        "  }",
                        "",
                        "  // If the parent node has type DeclareExportDeclaration, then it",
                        "  // will be responsible for printing the \"declare\" token. Otherwise",
                        "  // it needs to be printed with this non-exported declaration node.",
                        "  return [\"declare \", printed];",
                        "}",
                        "",
                        "module.exports = { printFlow };"
                    ]
                },
                "function-parameters.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { getNextNonSpaceNonCommentCharacter } = require(\"../../common/util.js\");",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { line, hardline, softline, group, indent, ifBreak },",
                        "  utils: { removeLines, willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  getFunctionParameters,",
                        "  iterateFunctionParametersPath,",
                        "  isSimpleType,",
                        "  isTestCall,",
                        "  isTypeAnnotationAFunction,",
                        "  isObjectType,",
                        "  isObjectTypePropertyAFunction,",
                        "  hasRestParameter,",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { locEnd } = require(\"../loc.js\");",
                        "const { ArgExpansionBailout } = require(\"../../common/errors.js\");",
                        "const { printFunctionTypeParameters } = require(\"./misc.js\");",
                        "",
                        "function printFunctionParameters(",
                        "  path,",
                        "  print,",
                        "  options,",
                        "  expandArg,",
                        "  printTypeParams",
                        ") {",
                        "  const functionNode = path.getValue();",
                        "  const parameters = getFunctionParameters(functionNode);",
                        "  const typeParams = printTypeParams",
                        "    ? printFunctionTypeParameters(path, options, print)",
                        "    : \"\";",
                        "",
                        "  if (parameters.length === 0) {",
                        "    return [",
                        "      typeParams,",
                        "      \"(\",",
                        "      printDanglingComments(",
                        "        path,",
                        "        options,",
                        "        /* sameIndent */ true,",
                        "        (comment) =>",
                        "          getNextNonSpaceNonCommentCharacter(",
                        "            options.originalText,",
                        "            comment,",
                        "            locEnd",
                        "          ) === \")\"",
                        "      ),",
                        "      \")\",",
                        "    ];",
                        "  }",
                        "",
                        "  const parent = path.getParentNode();",
                        "  const isParametersInTestCall = isTestCall(parent);",
                        "  const shouldHugParameters = shouldHugFunctionParameters(functionNode);",
                        "  const printed = [];",
                        "  iterateFunctionParametersPath(path, (parameterPath, index) => {",
                        "    const isLastParameter = index === parameters.length - 1;",
                        "    if (isLastParameter && functionNode.rest) {",
                        "      printed.push(\"...\");",
                        "    }",
                        "    printed.push(print());",
                        "    if (isLastParameter) {",
                        "      return;",
                        "    }",
                        "    printed.push(\",\");",
                        "    if (isParametersInTestCall || shouldHugParameters) {",
                        "      printed.push(\" \");",
                        "    } else if (isNextLineEmpty(parameters[index], options)) {",
                        "      printed.push(hardline, hardline);",
                        "    } else {",
                        "      printed.push(line);",
                        "    }",
                        "  });",
                        "",
                        "  // If the parent is a call with the first/last argument expansion and this is the",
                        "  // params of the first/last argument, we don't want the arguments to break and instead",
                        "  // want the whole expression to be on a new line.",
                        "  //",
                        "  // Good:                 Bad:",
                        "  //   verylongcall(         verylongcall((",
                        "  //     (a, b) => {           a,",
                        "  //     }                     b,",
                        "  //   )                     ) => {",
                        "  //                         })",
                        "  if (expandArg) {",
                        "    if (willBreak(typeParams) || willBreak(printed)) {",
                        "      // Removing lines in this case leads to broken or ugly output",
                        "      throw new ArgExpansionBailout();",
                        "    }",
                        "    return group([removeLines(typeParams), \"(\", removeLines(printed), \")\"]);",
                        "  }",
                        "",
                        "  // Single object destructuring should hug",
                        "  //",
                        "  // function({",
                        "  //   a,",
                        "  //   b,",
                        "  //   c",
                        "  // }) {}",
                        "  const hasNotParameterDecorator = parameters.every((node) => !node.decorators);",
                        "  if (shouldHugParameters && hasNotParameterDecorator) {",
                        "    return [typeParams, \"(\", ...printed, \")\"];",
                        "  }",
                        "",
                        "  // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`",
                        "  if (isParametersInTestCall) {",
                        "    return [typeParams, \"(\", ...printed, \")\"];",
                        "  }",
                        "",
                        "  const isFlowShorthandWithOneArg =",
                        "    (isObjectTypePropertyAFunction(parent) ||",
                        "      isTypeAnnotationAFunction(parent) ||",
                        "      parent.type === \"TypeAlias\" ||",
                        "      parent.type === \"UnionTypeAnnotation\" ||",
                        "      parent.type === \"TSUnionType\" ||",
                        "      parent.type === \"IntersectionTypeAnnotation\" ||",
                        "      (parent.type === \"FunctionTypeAnnotation\" &&",
                        "        parent.returnType === functionNode)) &&",
                        "    parameters.length === 1 &&",
                        "    parameters[0].name === null &&",
                        "    // `type q = (this: string) => void;`",
                        "    functionNode.this !== parameters[0] &&",
                        "    parameters[0].typeAnnotation &&",
                        "    functionNode.typeParameters === null &&",
                        "    isSimpleType(parameters[0].typeAnnotation) &&",
                        "    !functionNode.rest;",
                        "",
                        "  if (isFlowShorthandWithOneArg) {",
                        "    if (options.arrowParens === \"always\") {",
                        "      return [\"(\", ...printed, \")\"];",
                        "    }",
                        "    return printed;",
                        "  }",
                        "",
                        "  return [",
                        "    typeParams,",
                        "    \"(\",",
                        "    indent([softline, ...printed]),",
                        "    ifBreak(",
                        "      !hasRestParameter(functionNode) && shouldPrintComma(options, \"all\")",
                        "        ? \",\"",
                        "        : \"\"",
                        "    ),",
                        "    softline,",
                        "    \")\",",
                        "  ];",
                        "}",
                        "",
                        "function shouldHugFunctionParameters(node) {",
                        "  if (!node) {",
                        "    return false;",
                        "  }",
                        "  const parameters = getFunctionParameters(node);",
                        "  if (parameters.length !== 1) {",
                        "    return false;",
                        "  }",
                        "  const [parameter] = parameters;",
                        "  return (",
                        "    !hasComment(parameter) &&",
                        "    (parameter.type === \"ObjectPattern\" ||",
                        "      parameter.type === \"ArrayPattern\" ||",
                        "      (parameter.type === \"Identifier\" &&",
                        "        parameter.typeAnnotation &&",
                        "        (parameter.typeAnnotation.type === \"TypeAnnotation\" ||",
                        "          parameter.typeAnnotation.type === \"TSTypeAnnotation\") &&",
                        "        isObjectType(parameter.typeAnnotation.typeAnnotation)) ||",
                        "      (parameter.type === \"FunctionTypeParam\" &&",
                        "        isObjectType(parameter.typeAnnotation)) ||",
                        "      (parameter.type === \"AssignmentPattern\" &&",
                        "        (parameter.left.type === \"ObjectPattern\" ||",
                        "          parameter.left.type === \"ArrayPattern\") &&",
                        "        (parameter.right.type === \"Identifier\" ||",
                        "          (parameter.right.type === \"ObjectExpression\" &&",
                        "            parameter.right.properties.length === 0) ||",
                        "          (parameter.right.type === \"ArrayExpression\" &&",
                        "            parameter.right.elements.length === 0))))",
                        "  );",
                        "}",
                        "",
                        "function getReturnTypeNode(functionNode) {",
                        "  let returnTypeNode;",
                        "  if (functionNode.returnType) {",
                        "    returnTypeNode = functionNode.returnType;",
                        "    if (returnTypeNode.typeAnnotation) {",
                        "      returnTypeNode = returnTypeNode.typeAnnotation;",
                        "    }",
                        "  } else if (functionNode.typeAnnotation) {",
                        "    returnTypeNode = functionNode.typeAnnotation;",
                        "  }",
                        "  return returnTypeNode;",
                        "}",
                        "",
                        "// When parameters are grouped, the return type annotation breaks first.",
                        "function shouldGroupFunctionParameters(functionNode, returnTypeDoc) {",
                        "  const returnTypeNode = getReturnTypeNode(functionNode);",
                        "  if (!returnTypeNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const typeParameters =",
                        "    functionNode.typeParameters && functionNode.typeParameters.params;",
                        "  if (typeParameters) {",
                        "    if (typeParameters.length > 1) {",
                        "      return false;",
                        "    }",
                        "    if (typeParameters.length === 1) {",
                        "      const typeParameter = typeParameters[0];",
                        "      if (typeParameter.constraint || typeParameter.default) {",
                        "        return false;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return (",
                        "    getFunctionParameters(functionNode).length === 1 &&",
                        "    (isObjectType(returnTypeNode) || willBreak(returnTypeDoc))",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  printFunctionParameters,",
                        "  shouldHugFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "};"
                    ]
                },
                "function.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/** @typedef {import(\"../../document/doc-builders\").Doc} Doc */",
                        "",
                        "const assert = require(\"assert\");",
                        "const {",
                        "  printDanglingComments,",
                        "  printCommentsSeparately,",
                        "} = require(\"../../main/comments.js\");",
                        "const getLast = require(\"../../utils/get-last.js\");",
                        "const {",
                        "  getNextNonSpaceNonCommentCharacterIndex,",
                        "} = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: {",
                        "    line,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    ifBreak,",
                        "    hardline,",
                        "    join,",
                        "    indentIfBreak,",
                        "  },",
                        "  utils: { removeLines, willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const { ArgExpansionBailout } = require(\"../../common/errors.js\");",
                        "const {",
                        "  getFunctionParameters,",
                        "  hasLeadingOwnLineComment,",
                        "  isFlowAnnotationComment,",
                        "  isJsxNode,",
                        "  isTemplateOnItsOwnLine,",
                        "  shouldPrintComma,",
                        "  startsWithNoLookaheadToken,",
                        "  isBinaryish,",
                        "  isLineComment,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  isCallLikeExpression,",
                        "  isCallExpression,",
                        "  getCallArguments,",
                        "  hasNakedLeftSide,",
                        "  getLeftSide,",
                        "} = require(\"../utils/index.js\");",
                        "const { locEnd } = require(\"../loc.js\");",
                        "const {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} = require(\"./function-parameters.js\");",
                        "const { printPropertyKey } = require(\"./property.js\");",
                        "const { printFunctionTypeParameters } = require(\"./misc.js\");",
                        "",
                        "function printFunction(path, print, options, args) {",
                        "  const node = path.getValue();",
                        "",
                        "  let expandArg = false;",
                        "  if (",
                        "    (node.type === \"FunctionDeclaration\" ||",
                        "      node.type === \"FunctionExpression\") &&",
                        "    args &&",
                        "    args.expandLastArg",
                        "  ) {",
                        "    const parent = path.getParentNode();",
                        "    if (isCallExpression(parent) && getCallArguments(parent).length > 1) {",
                        "      expandArg = true;",
                        "    }",
                        "  }",
                        "",
                        "  const parts = [];",
                        "",
                        "  // For TypeScript the TSDeclareFunction node shares the AST",
                        "  // structure with FunctionDeclaration",
                        "  if (node.type === \"TSDeclareFunction\" && node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "",
                        "  if (node.async) {",
                        "    parts.push(\"async \");",
                        "  }",
                        "",
                        "  if (node.generator) {",
                        "    parts.push(\"function* \");",
                        "  } else {",
                        "    parts.push(\"function \");",
                        "  }",
                        "",
                        "  if (node.id) {",
                        "    parts.push(print(\"id\"));",
                        "  }",
                        "",
                        "  const parametersDoc = printFunctionParameters(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    expandArg",
                        "  );",
                        "  const returnTypeDoc = printReturnType(path, print, options);",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "",
                        "  parts.push(",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    group([",
                        "      shouldGroupParameters ? group(parametersDoc) : parametersDoc,",
                        "      returnTypeDoc,",
                        "    ]),",
                        "    node.body ? \" \" : \"\",",
                        "    print(\"body\")",
                        "  );",
                        "",
                        "  if (options.semi && (node.declare || !node.body)) {",
                        "    parts.push(\";\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printMethod(path, options, print) {",
                        "  const node = path.getNode();",
                        "  const { kind } = node;",
                        "  const value = node.value || node;",
                        "  const parts = [];",
                        "",
                        "  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {",
                        "    if (value.async) {",
                        "      parts.push(\"async \");",
                        "    }",
                        "  } else {",
                        "    assert.ok(kind === \"get\" || kind === \"set\");",
                        "",
                        "    parts.push(kind, \" \");",
                        "  }",
                        "",
                        "  // A `getter`/`setter` can't be a generator, but it's recoverable",
                        "  if (value.generator) {",
                        "    parts.push(\"*\");",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printPropertyKey(path, options, print),",
                        "    node.optional || node.key.optional ? \"?\" : \"\"",
                        "  );",
                        "",
                        "  if (node === value) {",
                        "    parts.push(printMethodInternal(path, options, print));",
                        "  } else if (value.type === \"FunctionExpression\") {",
                        "    parts.push(",
                        "      path.call((path) => printMethodInternal(path, options, print), \"value\")",
                        "    );",
                        "  } else {",
                        "    parts.push(print(\"value\"));",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printMethodInternal(path, options, print) {",
                        "  const node = path.getNode();",
                        "  const parametersDoc = printFunctionParameters(path, print, options);",
                        "  const returnTypeDoc = printReturnType(path, print, options);",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "  const parts = [",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    group([",
                        "      shouldGroupParameters ? group(parametersDoc) : parametersDoc,",
                        "      returnTypeDoc,",
                        "    ]),",
                        "  ];",
                        "",
                        "  if (node.body) {",
                        "    parts.push(\" \", print(\"body\"));",
                        "  } else {",
                        "    parts.push(options.semi ? \";\" : \"\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrowFunctionSignature(path, options, print, args) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  if (node.async) {",
                        "    parts.push(\"async \");",
                        "  }",
                        "",
                        "  if (shouldPrintParamsWithoutParens(path, options)) {",
                        "    parts.push(print([\"params\", 0]));",
                        "  } else {",
                        "    const expandArg = args && (args.expandLastArg || args.expandFirstArg);",
                        "    let returnTypeDoc = printReturnType(path, print, options);",
                        "    if (expandArg) {",
                        "      if (willBreak(returnTypeDoc)) {",
                        "        throw new ArgExpansionBailout();",
                        "      }",
                        "      returnTypeDoc = group(removeLines(returnTypeDoc));",
                        "    }",
                        "    parts.push(",
                        "      group([",
                        "        printFunctionParameters(",
                        "          path,",
                        "          print,",
                        "          options,",
                        "          expandArg,",
                        "          /* printTypeParams */ true",
                        "        ),",
                        "        returnTypeDoc,",
                        "      ])",
                        "    );",
                        "  }",
                        "",
                        "  const dangling = printDanglingComments(",
                        "    path,",
                        "    options,",
                        "    /* sameIndent */ true,",
                        "    (comment) => {",
                        "      const nextCharacter = getNextNonSpaceNonCommentCharacterIndex(",
                        "        options.originalText,",
                        "        comment,",
                        "        locEnd",
                        "      );",
                        "      return (",
                        "        nextCharacter !== false &&",
                        "        options.originalText.slice(nextCharacter, nextCharacter + 2) === \"=>\"",
                        "      );",
                        "    }",
                        "  );",
                        "  if (dangling) {",
                        "    parts.push(\" \", dangling);",
                        "  }",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrowChain(",
                        "  path,",
                        "  args,",
                        "  signatures,",
                        "  shouldBreak,",
                        "  bodyDoc,",
                        "  tailNode",
                        ") {",
                        "  const name = path.getName();",
                        "  const parent = path.getParentNode();",
                        "  const isCallee = isCallLikeExpression(parent) && name === \"callee\";",
                        "  const isAssignmentRhs = Boolean(args && args.assignmentLayout);",
                        "  const shouldPutBodyOnSeparateLine =",
                        "    tailNode.body.type !== \"BlockStatement\" &&",
                        "    tailNode.body.type !== \"ObjectExpression\" &&",
                        "    tailNode.body.type !== \"SequenceExpression\";",
                        "  const shouldBreakBeforeChain =",
                        "    (isCallee && shouldPutBodyOnSeparateLine) ||",
                        "    (args && args.assignmentLayout === \"chain-tail-arrow-chain\");",
                        "",
                        "  const groupId = Symbol(\"arrow-chain\");",
                        "",
                        "  // We handle sequence expressions as the body of arrows specially,",
                        "  // so that the required parentheses end up on their own lines.",
                        "  if (tailNode.body.type === \"SequenceExpression\") {",
                        "    bodyDoc = group([\"(\", indent([softline, bodyDoc]), softline, \")\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    group(",
                        "      indent([",
                        "        isCallee || isAssignmentRhs ? softline : \"\",",
                        "        group(join([\" =>\", line], signatures), { shouldBreak }),",
                        "      ]),",
                        "      { id: groupId, shouldBreak: shouldBreakBeforeChain }",
                        "    ),",
                        "    \" =>\",",
                        "    indentIfBreak(",
                        "      shouldPutBodyOnSeparateLine ? indent([line, bodyDoc]) : [\" \", bodyDoc],",
                        "      { groupId }",
                        "    ),",
                        "    isCallee ? ifBreak(softline, \"\", { groupId }) : \"\",",
                        "  ]);",
                        "}",
                        "",
                        "function printArrowFunction(path, options, print, args) {",
                        "  let node = path.getValue();",
                        "  /** @type {Doc[]} */",
                        "  const signatures = [];",
                        "  const body = [];",
                        "  let chainShouldBreak = false;",
                        "",
                        "  (function rec() {",
                        "    const doc = printArrowFunctionSignature(path, options, print, args);",
                        "    if (signatures.length === 0) {",
                        "      signatures.push(doc);",
                        "    } else {",
                        "      const { leading, trailing } = printCommentsSeparately(path, options);",
                        "      signatures.push([leading, doc]);",
                        "      body.unshift(trailing);",
                        "    }",
                        "",
                        "    chainShouldBreak =",
                        "      chainShouldBreak ||",
                        "      // Always break the chain if:",
                        "      (node.returnType && getFunctionParameters(node).length > 0) ||",
                        "      node.typeParameters ||",
                        "      getFunctionParameters(node).some((param) => param.type !== \"Identifier\");",
                        "",
                        "    if (",
                        "      node.body.type !== \"ArrowFunctionExpression\" ||",
                        "      (args && args.expandLastArg)",
                        "    ) {",
                        "      body.unshift(print(\"body\", args));",
                        "    } else {",
                        "      node = node.body;",
                        "      path.call(rec, \"body\");",
                        "    }",
                        "  })();",
                        "",
                        "  if (signatures.length > 1) {",
                        "    return printArrowChain(",
                        "      path,",
                        "      args,",
                        "      signatures,",
                        "      chainShouldBreak,",
                        "      body,",
                        "      node",
                        "    );",
                        "  }",
                        "",
                        "  const parts = signatures;",
                        "  parts.push(\" =>\");",
                        "",
                        "  // We want to always keep these types of nodes on the same line",
                        "  // as the arrow.",
                        "  if (",
                        "    !hasLeadingOwnLineComment(options.originalText, node.body) &&",
                        "    (node.body.type === \"ArrayExpression\" ||",
                        "      node.body.type === \"ObjectExpression\" ||",
                        "      node.body.type === \"BlockStatement\" ||",
                        "      isJsxNode(node.body) ||",
                        "      isTemplateOnItsOwnLine(node.body, options.originalText) ||",
                        "      node.body.type === \"ArrowFunctionExpression\" ||",
                        "      node.body.type === \"DoExpression\")",
                        "  ) {",
                        "    return group([...parts, \" \", body]);",
                        "  }",
                        "",
                        "  // We handle sequence expressions as the body of arrows specially,",
                        "  // so that the required parentheses end up on their own lines.",
                        "  if (node.body.type === \"SequenceExpression\") {",
                        "    return group([",
                        "      ...parts,",
                        "      group([\" (\", indent([softline, body]), softline, \")\"]),",
                        "    ]);",
                        "  }",
                        "",
                        "  // if the arrow function is expanded as last argument, we are adding a",
                        "  // level of indentation and need to add a softline to align the closing )",
                        "  // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)",
                        "  // we should align the expression's closing } with the line with the opening {.",
                        "  const shouldAddSoftLine =",
                        "    ((args && args.expandLastArg) ||",
                        "      path.getParentNode().type === \"JSXExpressionContainer\") &&",
                        "    !hasComment(node);",
                        "",
                        "  const printTrailingComma =",
                        "    args && args.expandLastArg && shouldPrintComma(options, \"all\");",
                        "",
                        "  // In order to avoid confusion between",
                        "  // a => a ? a : a",
                        "  // a <= a ? a : a",
                        "  const shouldAddParens =",
                        "    node.body.type === \"ConditionalExpression\" &&",
                        "    !startsWithNoLookaheadToken(",
                        "      node.body,",
                        "      (node) => node.type === \"ObjectExpression\"",
                        "    );",
                        "",
                        "  return group([",
                        "    ...parts,",
                        "    group([",
                        "      indent([",
                        "        line,",
                        "        shouldAddParens ? ifBreak(\"\", \"(\") : \"\",",
                        "        body,",
                        "        shouldAddParens ? ifBreak(\"\", \")\") : \"\",",
                        "      ]),",
                        "      shouldAddSoftLine",
                        "        ? [ifBreak(printTrailingComma ? \",\" : \"\"), softline]",
                        "        : \"\",",
                        "    ]),",
                        "  ]);",
                        "}",
                        "",
                        "function canPrintParamsWithoutParens(node) {",
                        "  const parameters = getFunctionParameters(node);",
                        "  return (",
                        "    parameters.length === 1 &&",
                        "    !node.typeParameters &&",
                        "    !hasComment(node, CommentCheckFlags.Dangling) &&",
                        "    parameters[0].type === \"Identifier\" &&",
                        "    !parameters[0].typeAnnotation &&",
                        "    !hasComment(parameters[0]) &&",
                        "    !parameters[0].optional &&",
                        "    !node.predicate &&",
                        "    !node.returnType",
                        "  );",
                        "}",
                        "",
                        "function shouldPrintParamsWithoutParens(path, options) {",
                        "  if (options.arrowParens === \"always\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (options.arrowParens === \"avoid\") {",
                        "    const node = path.getValue();",
                        "    return canPrintParamsWithoutParens(node);",
                        "  }",
                        "",
                        "  // Fallback default; should be unreachable",
                        "  /* istanbul ignore next */",
                        "  return false;",
                        "}",
                        "",
                        "/** @returns {Doc} */",
                        "function printReturnType(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const returnType = print(\"returnType\");",
                        "",
                        "  if (",
                        "    node.returnType &&",
                        "    isFlowAnnotationComment(options.originalText, node.returnType)",
                        "  ) {",
                        "    return [\" /*: \", returnType, \" */\"];",
                        "  }",
                        "",
                        "  const parts = [returnType];",
                        "",
                        "  // prepend colon to TypeScript type annotation",
                        "  if (node.returnType && node.returnType.typeAnnotation) {",
                        "    parts.unshift(\": \");",
                        "  }",
                        "",
                        "  if (node.predicate) {",
                        "    // The return type will already add the colon, but otherwise we",
                        "    // need to do it ourselves",
                        "    parts.push(node.returnType ? \" \" : \": \", print(\"predicate\"));",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "// `ReturnStatement` and `ThrowStatement`",
                        "function printReturnOrThrowArgument(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const parts = [];",
                        "",
                        "  if (node.argument) {",
                        "    if (returnArgumentHasLeadingComment(options, node.argument)) {",
                        "      parts.push([\" (\", indent([hardline, print(\"argument\")]), hardline, \")\"]);",
                        "    } else if (",
                        "      isBinaryish(node.argument) ||",
                        "      node.argument.type === \"SequenceExpression\"",
                        "    ) {",
                        "      parts.push(",
                        "        group([",
                        "          ifBreak(\" (\", \" \"),",
                        "          indent([softline, print(\"argument\")]),",
                        "          softline,",
                        "          ifBreak(\")\"),",
                        "        ])",
                        "      );",
                        "    } else {",
                        "      parts.push(\" \", print(\"argument\"));",
                        "    }",
                        "  }",
                        "",
                        "  const comments = getComments(node);",
                        "  const lastComment = getLast(comments);",
                        "  const isLastCommentLine = lastComment && isLineComment(lastComment);",
                        "",
                        "  if (isLastCommentLine) {",
                        "    parts.push(semi);",
                        "  }",
                        "",
                        "  if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    parts.push(",
                        "      \" \",",
                        "      printDanglingComments(path, options, /* sameIndent */ true)",
                        "    );",
                        "  }",
                        "",
                        "  if (!isLastCommentLine) {",
                        "    parts.push(semi);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printReturnStatement(path, options, print) {",
                        "  return [\"return\", printReturnOrThrowArgument(path, options, print)];",
                        "}",
                        "",
                        "function printThrowStatement(path, options, print) {",
                        "  return [\"throw\", printReturnOrThrowArgument(path, options, print)];",
                        "}",
                        "",
                        "// This recurses the return argument, looking for the first token",
                        "// (the leftmost leaf node) and, if it (or its parents) has any",
                        "// leadingComments, returns true (so it can be wrapped in parens).",
                        "function returnArgumentHasLeadingComment(options, argument) {",
                        "  if (hasLeadingOwnLineComment(options.originalText, argument)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (hasNakedLeftSide(argument)) {",
                        "    let leftMost = argument;",
                        "    let newLeftMost;",
                        "    while ((newLeftMost = getLeftSide(leftMost))) {",
                        "      leftMost = newLeftMost;",
                        "",
                        "      if (hasLeadingOwnLineComment(options.originalText, leftMost)) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printFunction,",
                        "  printArrowFunction,",
                        "  printMethod,",
                        "  printReturnStatement,",
                        "  printThrowStatement,",
                        "  printMethodInternal,",
                        "  shouldPrintParamsWithoutParens,",
                        "};"
                    ]
                },
                "html-binding.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { join, line, group, softline, indent },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "function printHtmlBinding(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (options.__onHtmlBindingRoot && path.getName() === null) {",
                        "    options.__onHtmlBindingRoot(node, options);",
                        "  }",
                        "",
                        "  if (node.type !== \"File\") {",
                        "    return;",
                        "  }",
                        "",
                        "  if (options.__isVueForBindingLeft) {",
                        "    return path.call(",
                        "      (functionDeclarationPath) => {",
                        "        const printed = join(",
                        "          [\",\", line],",
                        "          functionDeclarationPath.map(print, \"params\")",
                        "        );",
                        "",
                        "        const { params } = functionDeclarationPath.getValue();",
                        "        if (params.length === 1) {",
                        "          return printed;",
                        "        }",
                        "",
                        "        return [\"(\", indent([softline, group(printed)]), softline, \")\"];",
                        "      },",
                        "      \"program\",",
                        "      \"body\",",
                        "      0",
                        "    );",
                        "  }",
                        "",
                        "  if (options.__isVueBindings) {",
                        "    return path.call(",
                        "      (functionDeclarationPath) =>",
                        "        join([\",\", line], functionDeclarationPath.map(print, \"params\")),",
                        "      \"program\",",
                        "      \"body\",",
                        "      0",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "// based on https://github.com/prettier/prettier/blob/main/src/language-html/syntax-vue.js isVueEventBindingExpression()",
                        "function isVueEventBindingExpression(node) {",
                        "  switch (node.type) {",
                        "    case \"MemberExpression\":",
                        "      switch (node.property.type) {",
                        "        case \"Identifier\":",
                        "        case \"NumericLiteral\":",
                        "        case \"StringLiteral\":",
                        "          return isVueEventBindingExpression(node.object);",
                        "      }",
                        "      return false;",
                        "    case \"Identifier\":",
                        "      return true;",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "module.exports = {",
                        "  isVueEventBindingExpression,",
                        "  printHtmlBinding,",
                        "};"
                    ]
                },
                "interface.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { join, line, group, indent, ifBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasComment,",
                        "  identity,",
                        "  CommentCheckFlags,",
                        "} = require(\"../utils/index.js\");",
                        "const { getTypeParametersGroupId } = require(\"./type-parameters.js\");",
                        "const { printTypeScriptModifiers } = require(\"./misc.js\");",
                        "",
                        "function printInterface(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "",
                        "  if (node.type === \"TSInterfaceDeclaration\") {",
                        "    parts.push(",
                        "      node.abstract ? \"abstract \" : \"\",",
                        "      printTypeScriptModifiers(path, options, print)",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(\"interface\");",
                        "",
                        "  const partsGroup = [];",
                        "  const extendsParts = [];",
                        "",
                        "  if (node.type !== \"InterfaceTypeAnnotation\") {",
                        "    partsGroup.push(\" \", print(\"id\"), print(\"typeParameters\"));",
                        "  }",
                        "",
                        "  const shouldIndentOnlyHeritageClauses =",
                        "    node.typeParameters &&",
                        "    !hasComment(",
                        "      node.typeParameters,",
                        "      CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "    );",
                        "",
                        "  if (isNonEmptyArray(node.extends)) {",
                        "    extendsParts.push(",
                        "      shouldIndentOnlyHeritageClauses",
                        "        ? ifBreak(\" \", line, {",
                        "            groupId: getTypeParametersGroupId(node.typeParameters),",
                        "          })",
                        "        : line,",
                        "      \"extends \",",
                        "      (node.extends.length === 1 ? identity : indent)(",
                        "        join([\",\", line], path.map(print, \"extends\"))",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    (node.id && hasComment(node.id, CommentCheckFlags.Trailing)) ||",
                        "    isNonEmptyArray(node.extends)",
                        "  ) {",
                        "    if (shouldIndentOnlyHeritageClauses) {",
                        "      parts.push(group([...partsGroup, indent(extendsParts)]));",
                        "    } else {",
                        "      parts.push(group(indent([...partsGroup, ...extendsParts])));",
                        "    }",
                        "  } else {",
                        "    parts.push(...partsGroup, ...extendsParts);",
                        "  }",
                        "",
                        "  parts.push(\" \", print(\"body\"));",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "module.exports = { printInterface };"
                    ]
                },
                "jsx.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "  printCommentsSeparately,",
                        "} = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: {",
                        "    line,",
                        "    hardline,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    fill,",
                        "    ifBreak,",
                        "    lineSuffixBoundary,",
                        "    join,",
                        "  },",
                        "  utils: { willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "const { getLast, getPreferredQuote } = require(\"../../common/util.js\");",
                        "const {",
                        "  isJsxNode,",
                        "  rawText,",
                        "  isCallExpression,",
                        "  isStringLiteral,",
                        "  isBinaryish,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  hasNodeIgnoreComment,",
                        "} = require(\"../utils/index.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const { willPrintOwnComments } = require(\"../comments.js\");",
                        "",
                        "const isEmptyStringOrAnyLine = (doc) =>",
                        "  doc === \"\" || doc === line || doc === hardline || doc === softline;",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path\")} AstPath",
                        " * @typedef {import(\"../types/estree\").Node} Node",
                        " * @typedef {import(\"../types/estree\").JSXElement} JSXElement",
                        " */",
                        "",
                        "// JSX expands children from the inside-out, instead of the outside-in.",
                        "// This is both to break children before attributes,",
                        "// and to ensure that when children break, their parents do as well.",
                        "//",
                        "// Any element that is written without any newlines and fits on a single line",
                        "// is left that way.",
                        "// Not only that, any user-written-line containing multiple JSX siblings",
                        "// should also be kept on one line if possible,",
                        "// so each user-written-line is wrapped in its own group.",
                        "//",
                        "// Elements that contain newlines or don't fit on a single line (recursively)",
                        "// are fully-split, using hardline and shouldBreak: true.",
                        "//",
                        "// To support that case properly, all leading and trailing spaces",
                        "// are stripped from the list of children, and replaced with a single hardline.",
                        "function printJsxElementInternal(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (node.type === \"JSXElement\" && isEmptyJsxElement(node)) {",
                        "    return [print(\"openingElement\"), print(\"closingElement\")];",
                        "  }",
                        "",
                        "  const openingLines =",
                        "    node.type === \"JSXElement\"",
                        "      ? print(\"openingElement\")",
                        "      : print(\"openingFragment\");",
                        "  const closingLines =",
                        "    node.type === \"JSXElement\"",
                        "      ? print(\"closingElement\")",
                        "      : print(\"closingFragment\");",
                        "",
                        "  if (",
                        "    node.children.length === 1 &&",
                        "    node.children[0].type === \"JSXExpressionContainer\" &&",
                        "    (node.children[0].expression.type === \"TemplateLiteral\" ||",
                        "      node.children[0].expression.type === \"TaggedTemplateExpression\")",
                        "  ) {",
                        "    return [openingLines, ...path.map(print, \"children\"), closingLines];",
                        "  }",
                        "",
                        "  // Convert `{\" \"}` to text nodes containing a space.",
                        "  // This makes it easy to turn them into `jsxWhitespace` which",
                        "  // can then print as either a space or `{\" \"}` when breaking.",
                        "  node.children = node.children.map((child) => {",
                        "    if (isJsxWhitespaceExpression(child)) {",
                        "      return {",
                        "        type: \"JSXText\",",
                        "        value: \" \",",
                        "        raw: \" \",",
                        "      };",
                        "    }",
                        "    return child;",
                        "  });",
                        "",
                        "  const containsTag = node.children.some(isJsxNode);",
                        "  const containsMultipleExpressions =",
                        "    node.children.filter((child) => child.type === \"JSXExpressionContainer\")",
                        "      .length > 1;",
                        "  const containsMultipleAttributes =",
                        "    node.type === \"JSXElement\" && node.openingElement.attributes.length > 1;",
                        "",
                        "  // Record any breaks. Should never go from true to false, only false to true.",
                        "  let forcedBreak =",
                        "    willBreak(openingLines) ||",
                        "    containsTag ||",
                        "    containsMultipleAttributes ||",
                        "    containsMultipleExpressions;",
                        "",
                        "  const isMdxBlock = path.getParentNode().rootMarker === \"mdx\";",
                        "",
                        "  const rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';",
                        "  const jsxWhitespace = isMdxBlock",
                        "    ? \" \"",
                        "    : ifBreak([rawJsxWhitespace, softline], \" \");",
                        "",
                        "  const isFacebookTranslationTag =",
                        "    node.openingElement &&",
                        "    node.openingElement.name &&",
                        "    node.openingElement.name.name === \"fbt\";",
                        "",
                        "  const children = printJsxChildren(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    jsxWhitespace,",
                        "    isFacebookTranslationTag",
                        "  );",
                        "",
                        "  const containsText = node.children.some((child) =>",
                        "    isMeaningfulJsxText(child)",
                        "  );",
                        "",
                        "  // We can end up we multiple whitespace elements with empty string",
                        "  // content between them.",
                        "  // We need to remove empty whitespace and softlines before JSX whitespace",
                        "  // to get the correct output.",
                        "  for (let i = children.length - 2; i >= 0; i--) {",
                        "    const isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";",
                        "    const isPairOfHardlines =",
                        "      children[i] === hardline &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === hardline;",
                        "    const isLineFollowedByJsxWhitespace =",
                        "      (children[i] === softline || children[i] === hardline) &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === jsxWhitespace;",
                        "    const isJsxWhitespaceFollowedByLine =",
                        "      children[i] === jsxWhitespace &&",
                        "      children[i + 1] === \"\" &&",
                        "      (children[i + 2] === softline || children[i + 2] === hardline);",
                        "    const isDoubleJsxWhitespace =",
                        "      children[i] === jsxWhitespace &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === jsxWhitespace;",
                        "    const isPairOfHardOrSoftLines =",
                        "      (children[i] === softline &&",
                        "        children[i + 1] === \"\" &&",
                        "        children[i + 2] === hardline) ||",
                        "      (children[i] === hardline &&",
                        "        children[i + 1] === \"\" &&",
                        "        children[i + 2] === softline);",
                        "",
                        "    if (",
                        "      (isPairOfHardlines && containsText) ||",
                        "      isPairOfEmptyStrings ||",
                        "      isLineFollowedByJsxWhitespace ||",
                        "      isDoubleJsxWhitespace ||",
                        "      isPairOfHardOrSoftLines",
                        "    ) {",
                        "      children.splice(i, 2);",
                        "    } else if (isJsxWhitespaceFollowedByLine) {",
                        "      children.splice(i + 1, 2);",
                        "    }",
                        "  }",
                        "",
                        "  // Trim trailing lines (or empty strings)",
                        "  while (children.length > 0 && isEmptyStringOrAnyLine(getLast(children))) {",
                        "    children.pop();",
                        "  }",
                        "",
                        "  // Trim leading lines (or empty strings)",
                        "  while (",
                        "    children.length > 1 &&",
                        "    isEmptyStringOrAnyLine(children[0]) &&",
                        "    isEmptyStringOrAnyLine(children[1])",
                        "  ) {",
                        "    children.shift();",
                        "    children.shift();",
                        "  }",
                        "",
                        "  // Tweak how we format children if outputting this element over multiple lines.",
                        "  // Also detect whether we will force this element to output over multiple lines.",
                        "  const multilineChildren = [];",
                        "  for (const [i, child] of children.entries()) {",
                        "    // There are a number of situations where we need to ensure we display",
                        "    // whitespace as `{\" \"}` when outputting this element over multiple lines.",
                        "    if (child === jsxWhitespace) {",
                        "      if (i === 1 && children[i - 1] === \"\") {",
                        "        if (children.length === 2) {",
                        "          // Solitary whitespace",
                        "          multilineChildren.push(rawJsxWhitespace);",
                        "          continue;",
                        "        }",
                        "        // Leading whitespace",
                        "        multilineChildren.push([rawJsxWhitespace, hardline]);",
                        "        continue;",
                        "      } else if (i === children.length - 1) {",
                        "        // Trailing whitespace",
                        "        multilineChildren.push(rawJsxWhitespace);",
                        "        continue;",
                        "      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {",
                        "        // Whitespace after line break",
                        "        multilineChildren.push(rawJsxWhitespace);",
                        "        continue;",
                        "      }",
                        "    }",
                        "",
                        "    multilineChildren.push(child);",
                        "",
                        "    if (willBreak(child)) {",
                        "      forcedBreak = true;",
                        "    }",
                        "  }",
                        "",
                        "  // If there is text we use `fill` to fit as much onto each line as possible.",
                        "  // When there is no text (just tags and expressions) we use `group`",
                        "  // to output each on a separate line.",
                        "  const content = containsText",
                        "    ? fill(multilineChildren)",
                        "    : group(multilineChildren, { shouldBreak: true });",
                        "",
                        "  if (isMdxBlock) {",
                        "    return content;",
                        "  }",
                        "",
                        "  const multiLineElem = group([",
                        "    openingLines,",
                        "    indent([hardline, content]),",
                        "    hardline,",
                        "    closingLines,",
                        "  ]);",
                        "",
                        "  if (forcedBreak) {",
                        "    return multiLineElem;",
                        "  }",
                        "",
                        "  return conditionalGroup([",
                        "    group([openingLines, ...children, closingLines]),",
                        "    multiLineElem,",
                        "  ]);",
                        "}",
                        "",
                        "// JSX Children are strange, mostly for two reasons:",
                        "// 1. JSX reads newlines into string values, instead of skipping them like JS",
                        "// 2. up to one whitespace between elements within a line is significant,",
                        "//    but not between lines.",
                        "//",
                        "// Leading, trailing, and lone whitespace all need to",
                        "// turn themselves into the rather ugly `{' '}` when breaking.",
                        "//",
                        "// We print JSX using the `fill` doc primitive.",
                        "// This requires that we give it an array of alternating",
                        "// content and whitespace elements.",
                        "// To ensure this we add dummy `\"\"` content elements as needed.",
                        "function printJsxChildren(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  jsxWhitespace,",
                        "  isFacebookTranslationTag",
                        ") {",
                        "  const parts = [];",
                        "  path.each((childPath, i, children) => {",
                        "    const child = childPath.getValue();",
                        "    if (child.type === \"JSXText\") {",
                        "      const text = rawText(child);",
                        "",
                        "      // Contains a non-whitespace character",
                        "      if (isMeaningfulJsxText(child)) {",
                        "        const words = text.split(matchJsxWhitespaceRegex);",
                        "",
                        "        // Starts with whitespace",
                        "        if (words[0] === \"\") {",
                        "          parts.push(\"\");",
                        "          words.shift();",
                        "          if (/\\n/.test(words[0])) {",
                        "            const next = children[i + 1];",
                        "            parts.push(",
                        "              separatorWithWhitespace(",
                        "                isFacebookTranslationTag,",
                        "                words[1],",
                        "                child,",
                        "                next",
                        "              )",
                        "            );",
                        "          } else {",
                        "            parts.push(jsxWhitespace);",
                        "          }",
                        "          words.shift();",
                        "        }",
                        "",
                        "        let endWhitespace;",
                        "        // Ends with whitespace",
                        "        if (getLast(words) === \"\") {",
                        "          words.pop();",
                        "          endWhitespace = words.pop();",
                        "        }",
                        "",
                        "        // This was whitespace only without a new line.",
                        "        if (words.length === 0) {",
                        "          return;",
                        "        }",
                        "",
                        "        for (const [i, word] of words.entries()) {",
                        "          if (i % 2 === 1) {",
                        "            parts.push(line);",
                        "          } else {",
                        "            parts.push(word);",
                        "          }",
                        "        }",
                        "",
                        "        if (endWhitespace !== undefined) {",
                        "          if (/\\n/.test(endWhitespace)) {",
                        "            const next = children[i + 1];",
                        "            parts.push(",
                        "              separatorWithWhitespace(",
                        "                isFacebookTranslationTag,",
                        "                getLast(parts),",
                        "                child,",
                        "                next",
                        "              )",
                        "            );",
                        "          } else {",
                        "            parts.push(jsxWhitespace);",
                        "          }",
                        "        } else {",
                        "          const next = children[i + 1];",
                        "          parts.push(",
                        "            separatorNoWhitespace(",
                        "              isFacebookTranslationTag,",
                        "              getLast(parts),",
                        "              child,",
                        "              next",
                        "            )",
                        "          );",
                        "        }",
                        "      } else if (/\\n/.test(text)) {",
                        "        // Keep (up to one) blank line between tags/expressions/text.",
                        "        // Note: We don't keep blank lines between text elements.",
                        "        if (text.match(/\\n/g).length > 1) {",
                        "          parts.push(\"\", hardline);",
                        "        }",
                        "      } else {",
                        "        parts.push(\"\", jsxWhitespace);",
                        "      }",
                        "    } else {",
                        "      const printedChild = print();",
                        "      parts.push(printedChild);",
                        "",
                        "      const next = children[i + 1];",
                        "      const directlyFollowedByMeaningfulText =",
                        "        next && isMeaningfulJsxText(next);",
                        "      if (directlyFollowedByMeaningfulText) {",
                        "        const firstWord = trimJsxWhitespace(rawText(next)).split(",
                        "          matchJsxWhitespaceRegex",
                        "        )[0];",
                        "        parts.push(",
                        "          separatorNoWhitespace(",
                        "            isFacebookTranslationTag,",
                        "            firstWord,",
                        "            child,",
                        "            next",
                        "          )",
                        "        );",
                        "      } else {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, \"children\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function separatorNoWhitespace(",
                        "  isFacebookTranslationTag,",
                        "  child,",
                        "  childNode,",
                        "  nextNode",
                        ") {",
                        "  if (isFacebookTranslationTag) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  if (",
                        "    (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                        "    (nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement)",
                        "  ) {",
                        "    return child.length === 1 ? softline : hardline;",
                        "  }",
                        "",
                        "  return softline;",
                        "}",
                        "",
                        "function separatorWithWhitespace(",
                        "  isFacebookTranslationTag,",
                        "  child,",
                        "  childNode,",
                        "  nextNode",
                        ") {",
                        "  if (isFacebookTranslationTag) {",
                        "    return hardline;",
                        "  }",
                        "",
                        "  if (child.length === 1) {",
                        "    return (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                        "      (nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement)",
                        "      ? hardline",
                        "      : softline;",
                        "  }",
                        "",
                        "  return hardline;",
                        "}",
                        "",
                        "function maybeWrapJsxElementInParens(path, elem, options) {",
                        "  const parent = path.getParentNode();",
                        "  /* istanbul ignore next */",
                        "  if (!parent) {",
                        "    return elem;",
                        "  }",
                        "",
                        "  const NO_WRAP_PARENTS = {",
                        "    ArrayExpression: true,",
                        "    JSXAttribute: true,",
                        "    JSXElement: true,",
                        "    JSXExpressionContainer: true,",
                        "    JSXFragment: true,",
                        "    ExpressionStatement: true,",
                        "    CallExpression: true,",
                        "    OptionalCallExpression: true,",
                        "    ConditionalExpression: true,",
                        "    JsExpressionRoot: true,",
                        "  };",
                        "  if (NO_WRAP_PARENTS[parent.type]) {",
                        "    return elem;",
                        "  }",
                        "",
                        "  const shouldBreak = path.match(",
                        "    undefined,",
                        "    (node) => node.type === \"ArrowFunctionExpression\",",
                        "    isCallExpression,",
                        "    (node) => node.type === \"JSXExpressionContainer\"",
                        "  );",
                        "",
                        "  const needsParens = pathNeedsParens(path, options);",
                        "",
                        "  return group(",
                        "    [",
                        "      needsParens ? \"\" : ifBreak(\"(\"),",
                        "      indent([softline, elem]),",
                        "      softline,",
                        "      needsParens ? \"\" : ifBreak(\")\"),",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "function printJsxAttribute(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  parts.push(print(\"name\"));",
                        "",
                        "  if (node.value) {",
                        "    let res;",
                        "    if (isStringLiteral(node.value)) {",
                        "      const raw = rawText(node.value);",
                        "      // Remove enclosing quotes and unescape",
                        "      // all quotes so we get an accurate preferred quote",
                        "      let final = raw",
                        "        .slice(1, -1)",
                        "        .replace(/&apos;/g, \"'\")",
                        "        .replace(/&quot;/g, '\"');",
                        "      const { escaped, quote, regex } = getPreferredQuote(",
                        "        final,",
                        "        options.jsxSingleQuote ? \"'\" : '\"'",
                        "      );",
                        "      final = final.replace(regex, escaped);",
                        "      const { leading, trailing } = path.call(",
                        "        () => printCommentsSeparately(path, options),",
                        "        \"value\"",
                        "      );",
                        "      res = [leading, quote, final, quote, trailing];",
                        "    } else {",
                        "      res = print(\"value\");",
                        "    }",
                        "    parts.push(\"=\", res);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJsxExpressionContainer(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  const shouldInline = (node, parent) =>",
                        "    node.type === \"JSXEmptyExpression\" ||",
                        "    (!hasComment(node) &&",
                        "      (node.type === \"ArrayExpression\" ||",
                        "        node.type === \"ObjectExpression\" ||",
                        "        node.type === \"ArrowFunctionExpression\" ||",
                        "        (node.type === \"AwaitExpression\" &&",
                        "          (shouldInline(node.argument, node) ||",
                        "            node.argument.type === \"JSXElement\")) ||",
                        "        isCallExpression(node) ||",
                        "        node.type === \"FunctionExpression\" ||",
                        "        node.type === \"TemplateLiteral\" ||",
                        "        node.type === \"TaggedTemplateExpression\" ||",
                        "        node.type === \"DoExpression\" ||",
                        "        (isJsxNode(parent) &&",
                        "          (node.type === \"ConditionalExpression\" || isBinaryish(node)))));",
                        "",
                        "  if (shouldInline(node.expression, path.getParentNode(0))) {",
                        "    return group([\"{\", print(\"expression\"), lineSuffixBoundary, \"}\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    \"{\",",
                        "    indent([softline, print(\"expression\")]),",
                        "    softline,",
                        "    lineSuffixBoundary,",
                        "    \"}\",",
                        "  ]);",
                        "}",
                        "",
                        "function printJsxOpeningElement(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  const nameHasComments =",
                        "    (node.name && hasComment(node.name)) ||",
                        "    (node.typeParameters && hasComment(node.typeParameters));",
                        "",
                        "  // Don't break self-closing elements with no attributes and no comments",
                        "  if (node.selfClosing && node.attributes.length === 0 && !nameHasComments) {",
                        "    return [\"<\", print(\"name\"), print(\"typeParameters\"), \" />\"];",
                        "  }",
                        "",
                        "  // don't break up opening elements with a single long text attribute",
                        "  if (",
                        "    node.attributes &&",
                        "    node.attributes.length === 1 &&",
                        "    node.attributes[0].value &&",
                        "    isStringLiteral(node.attributes[0].value) &&",
                        "    !node.attributes[0].value.value.includes(\"\\n\") &&",
                        "    // We should break for the following cases:",
                        "    // <div",
                        "    //   // comment",
                        "    //   attr=\"value\"",
                        "    // >",
                        "    // <div",
                        "    //   attr=\"value\"",
                        "    //   // comment",
                        "    // >",
                        "    !nameHasComments &&",
                        "    !hasComment(node.attributes[0])",
                        "  ) {",
                        "    return group([",
                        "      \"<\",",
                        "      print(\"name\"),",
                        "      print(\"typeParameters\"),",
                        "      \" \",",
                        "      ...path.map(print, \"attributes\"),",
                        "      node.selfClosing ? \" />\" : \">\",",
                        "    ]);",
                        "  }",
                        "",
                        "  // We should print the opening element expanded if any prop value is a",
                        "  // string literal with newlines",
                        "  const shouldBreak =",
                        "    node.attributes &&",
                        "    node.attributes.some(",
                        "      (attr) =>",
                        "        attr.value &&",
                        "        isStringLiteral(attr.value) &&",
                        "        attr.value.value.includes(\"\\n\")",
                        "    );",
                        "",
                        "  const attributeLine =",
                        "    options.singleAttributePerLine && node.attributes.length > 1",
                        "      ? hardline",
                        "      : line;",
                        "",
                        "  return group(",
                        "    [",
                        "      \"<\",",
                        "      print(\"name\"),",
                        "      print(\"typeParameters\"),",
                        "      indent(path.map(() => [attributeLine, print()], \"attributes\")),",
                        "      ...printEndOfOpeningTag(node, options, nameHasComments),",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "function printEndOfOpeningTag(node, options, nameHasComments) {",
                        "  if (node.selfClosing) {",
                        "    return [line, \"/>\"];",
                        "  }",
                        "  const bracketSameLine = shouldPrintBracketSameLine(",
                        "    node,",
                        "    options,",
                        "    nameHasComments",
                        "  );",
                        "  if (bracketSameLine) {",
                        "    return [\">\"];",
                        "  }",
                        "  return [softline, \">\"];",
                        "}",
                        "",
                        "function shouldPrintBracketSameLine(node, options, nameHasComments) {",
                        "  const lastAttrHasTrailingComments =",
                        "    node.attributes.length > 0 &&",
                        "    hasComment(getLast(node.attributes), CommentCheckFlags.Trailing);",
                        "  return (",
                        "    // Simple tags (no attributes and no comment in tag name) should be",
                        "    // kept unbroken regardless of `bracketSameLine`.",
                        "    // jsxBracketSameLine is deprecated in favour of bracketSameLine,",
                        "    // but is still needed for backwards compatibility.",
                        "    (node.attributes.length === 0 && !nameHasComments) ||",
                        "    ((options.bracketSameLine || options.jsxBracketSameLine) &&",
                        "      // We should print the bracket in a new line for the following cases:",
                        "      // <div",
                        "      //   // comment",
                        "      // >",
                        "      // <div",
                        "      //   attr // comment",
                        "      // >",
                        "      (!nameHasComments || node.attributes.length > 0) &&",
                        "      !lastAttrHasTrailingComments)",
                        "  );",
                        "}",
                        "",
                        "function printJsxClosingElement(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  parts.push(\"</\");",
                        "",
                        "  const printed = print(\"name\");",
                        "  if (",
                        "    hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Line)",
                        "  ) {",
                        "    parts.push(indent([hardline, printed]), hardline);",
                        "  } else if (",
                        "    hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Block)",
                        "  ) {",
                        "    parts.push(\" \", printed);",
                        "  } else {",
                        "    parts.push(printed);",
                        "  }",
                        "",
                        "  parts.push(\">\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJsxOpeningClosingFragment(path, options /*, print*/) {",
                        "  const node = path.getValue();",
                        "  const nodeHasComment = hasComment(node);",
                        "  const hasOwnLineComment = hasComment(node, CommentCheckFlags.Line);",
                        "  const isOpeningFragment = node.type === \"JSXOpeningFragment\";",
                        "  return [",
                        "    isOpeningFragment ? \"<\" : \"</\",",
                        "    indent([",
                        "      hasOwnLineComment",
                        "        ? hardline",
                        "        : nodeHasComment && !isOpeningFragment",
                        "        ? \" \"",
                        "        : \"\",",
                        "      printDanglingComments(path, options, true),",
                        "    ]),",
                        "    hasOwnLineComment ? hardline : \"\",",
                        "    \">\",",
                        "  ];",
                        "}",
                        "",
                        "function printJsxElement(path, options, print) {",
                        "  const elem = printComments(",
                        "    path,",
                        "    printJsxElementInternal(path, options, print),",
                        "    options",
                        "  );",
                        "  return maybeWrapJsxElementInParens(path, elem, options);",
                        "}",
                        "",
                        "function printJsxEmptyExpression(path, options /*, print*/) {",
                        "  const node = path.getValue();",
                        "  const requiresHardline = hasComment(node, CommentCheckFlags.Line);",
                        "",
                        "  return [",
                        "    printDanglingComments(path, options, /* sameIndent */ !requiresHardline),",
                        "    requiresHardline ? hardline : \"\",",
                        "  ];",
                        "}",
                        "",
                        "// `JSXSpreadAttribute` and `JSXSpreadChild`",
                        "function printJsxSpreadAttribute(path, options, print) {",
                        "  const node = path.getValue();",
                        "  return [",
                        "    \"{\",",
                        "    path.call(",
                        "      (p) => {",
                        "        const printed = [\"...\", print()];",
                        "        const node = p.getValue();",
                        "        if (!hasComment(node) || !willPrintOwnComments(p)) {",
                        "          return printed;",
                        "        }",
                        "        return [",
                        "          indent([softline, printComments(p, printed, options)]),",
                        "          softline,",
                        "        ];",
                        "      },",
                        "      node.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"",
                        "    ),",
                        "    \"}\",",
                        "  ];",
                        "}",
                        "",
                        "function printJsx(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  // JSX nodes always starts with `JSX`",
                        "  if (!node.type.startsWith(\"JSX\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"JSXAttribute\":",
                        "      return printJsxAttribute(path, options, print);",
                        "    case \"JSXIdentifier\":",
                        "      return String(node.name);",
                        "    case \"JSXNamespacedName\":",
                        "      return join(\":\", [print(\"namespace\"), print(\"name\")]);",
                        "    case \"JSXMemberExpression\":",
                        "      return join(\".\", [print(\"object\"), print(\"property\")]);",
                        "    case \"JSXSpreadAttribute\":",
                        "      return printJsxSpreadAttribute(path, options, print);",
                        "    case \"JSXSpreadChild\": {",
                        "      // Same as `printJsxSpreadAttribute`",
                        "      const printJsxSpreadChild = printJsxSpreadAttribute;",
                        "      return printJsxSpreadChild(path, options, print);",
                        "    }",
                        "    case \"JSXExpressionContainer\":",
                        "      return printJsxExpressionContainer(path, options, print);",
                        "    case \"JSXFragment\":",
                        "    case \"JSXElement\":",
                        "      return printJsxElement(path, options, print);",
                        "    case \"JSXOpeningElement\":",
                        "      return printJsxOpeningElement(path, options, print);",
                        "    case \"JSXClosingElement\":",
                        "      return printJsxClosingElement(path, options, print);",
                        "    case \"JSXOpeningFragment\":",
                        "    case \"JSXClosingFragment\":",
                        "      return printJsxOpeningClosingFragment(path, options /*, print*/);",
                        "    case \"JSXEmptyExpression\":",
                        "      return printJsxEmptyExpression(path, options /*, print*/);",
                        "    case \"JSXText\":",
                        "      /* istanbul ignore next */",
                        "      throw new Error(\"JSXText should be handled by JSXElement\");",
                        "    default:",
                        "      /* istanbul ignore next */",
                        "      throw new Error(`Unknown JSX node type: ${JSON.stringify(node.type)}.`);",
                        "  }",
                        "}",
                        "",
                        "// Only space, newline, carriage return, and tab are treated as whitespace",
                        "// inside JSX.",
                        "const jsxWhitespaceChars = \" \\n\\r\\t\";",
                        "const matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\");",
                        "const containsNonJsxWhitespaceRegex = new RegExp(",
                        "  \"[^\" + jsxWhitespaceChars + \"]\"",
                        ");",
                        "const trimJsxWhitespace = (text) =>",
                        "  text.replace(",
                        "    new RegExp(",
                        "      \"(?:^\" +",
                        "        matchJsxWhitespaceRegex.source +",
                        "        \"|\" +",
                        "        matchJsxWhitespaceRegex.source +",
                        "        \"$)\"",
                        "    ),",
                        "    \"\"",
                        "  );",
                        "",
                        "/**",
                        " * @param {JSXElement} node",
                        " * @returns {boolean}",
                        " */",
                        "function isEmptyJsxElement(node) {",
                        "  if (node.children.length === 0) {",
                        "    return true;",
                        "  }",
                        "  if (node.children.length > 1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // if there is one text child and does not contain any meaningful text",
                        "  // we can treat the element as empty.",
                        "  const child = node.children[0];",
                        "  return child.type === \"JSXText\" && !isMeaningfulJsxText(child);",
                        "}",
                        "",
                        "// Meaningful if it contains non-whitespace characters,",
                        "// or it contains whitespace without a new line.",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isMeaningfulJsxText(node) {",
                        "  return (",
                        "    node.type === \"JSXText\" &&",
                        "    (containsNonJsxWhitespaceRegex.test(rawText(node)) ||",
                        "      !/\\n/.test(rawText(node)))",
                        "  );",
                        "}",
                        "",
                        "// Detect an expression node representing `{\" \"}`",
                        "function isJsxWhitespaceExpression(node) {",
                        "  return (",
                        "    node.type === \"JSXExpressionContainer\" &&",
                        "    isStringLiteral(node.expression) &&",
                        "    node.expression.value === \" \" &&",
                        "    !hasComment(node.expression)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function hasJsxIgnoreComment(path) {",
                        "  const node = path.getValue();",
                        "  const parent = path.getParentNode();",
                        "  if (!parent || !node || !isJsxNode(node) || !isJsxNode(parent)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // Lookup the previous sibling, ignoring any empty JSXText elements",
                        "  const index = parent.children.indexOf(node);",
                        "  let prevSibling = null;",
                        "  for (let i = index; i > 0; i--) {",
                        "    const candidate = parent.children[i - 1];",
                        "    if (candidate.type === \"JSXText\" && !isMeaningfulJsxText(candidate)) {",
                        "      continue;",
                        "    }",
                        "    prevSibling = candidate;",
                        "    break;",
                        "  }",
                        "",
                        "  return (",
                        "    prevSibling &&",
                        "    prevSibling.type === \"JSXExpressionContainer\" &&",
                        "    prevSibling.expression.type === \"JSXEmptyExpression\" &&",
                        "    hasNodeIgnoreComment(prevSibling.expression)",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  hasJsxIgnoreComment,",
                        "  printJsx,",
                        "};"
                    ]
                },
                "literal.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "const { printString, printNumber } = require(\"../../common/util.js\");",
                        "const { replaceTextEndOfLine } = require(\"../../document/doc-utils.js\");",
                        "const { printDirective } = require(\"./misc.js\");",
                        "",
                        "function printLiteral(path, options /*, print*/) {",
                        "  const node = path.getNode();",
                        "",
                        "  switch (node.type) {",
                        "    case \"RegExpLiteral\": // Babel 6 Literal split",
                        "      return printRegex(node);",
                        "    case \"BigIntLiteral\":",
                        "      // babel: node.extra.raw, flow: node.bigint",
                        "      return printBigInt(node.bigint || node.extra.raw);",
                        "    case \"NumericLiteral\": // Babel 6 Literal split",
                        "      return printNumber(node.extra.raw);",
                        "    case \"StringLiteral\": // Babel 6 Literal split",
                        "      return replaceTextEndOfLine(printString(node.extra.raw, options));",
                        "    case \"NullLiteral\": // Babel 6 Literal split",
                        "      return \"null\";",
                        "    case \"BooleanLiteral\": // Babel 6 Literal split",
                        "      return String(node.value);",
                        "    case \"DecimalLiteral\":",
                        "      return printNumber(node.value) + \"m\";",
                        "    case \"Literal\": {",
                        "      if (node.regex) {",
                        "        return printRegex(node.regex);",
                        "      }",
                        "",
                        "      if (node.bigint) {",
                        "        return printBigInt(node.raw);",
                        "      }",
                        "",
                        "      if (node.decimal) {",
                        "        return printNumber(node.decimal) + \"m\";",
                        "      }",
                        "",
                        "      const { value } = node;",
                        "",
                        "      if (typeof value === \"number\") {",
                        "        return printNumber(node.raw);",
                        "      }",
                        "",
                        "      if (typeof value === \"string\") {",
                        "        return isDirective(path)",
                        "          ? printDirective(node.raw, options)",
                        "          : replaceTextEndOfLine(printString(node.raw, options));",
                        "      }",
                        "",
                        "      return String(value);",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "function isDirective(path) {",
                        "  if (path.getName() !== \"expression\") {",
                        "    return;",
                        "  }",
                        "",
                        "  const parent = path.getParentNode();",
                        "  return parent.type === \"ExpressionStatement\" && parent.directive;",
                        "}",
                        "",
                        "function printBigInt(raw) {",
                        "  return raw.toLowerCase();",
                        "}",
                        "",
                        "function printRegex({ pattern, flags }) {",
                        "  flags = [...flags].sort().join(\"\");",
                        "  return `/${pattern}/${flags}`;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printLiteral,",
                        "};"
                    ]
                },
                "member-chain.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  getLast,",
                        "  isNextLineEmptyAfterIndex,",
                        "  getNextNonSpaceNonCommentCharacterIndex,",
                        "} = require(\"../../common/util.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const {",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isFunctionOrArrowExpression,",
                        "  isLongCurriedCallExpression,",
                        "  isMemberish,",
                        "  isNumericLiteral,",
                        "  isSimpleCallArgument,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { locEnd } = require(\"../loc.js\");",
                        "",
                        "const {",
                        "  builders: {",
                        "    join,",
                        "    hardline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    breakParent,",
                        "    label,",
                        "  },",
                        "  utils: { willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const printCallArguments = require(\"./call-arguments.js\");",
                        "const { printMemberLookup } = require(\"./member.js\");",
                        "const {",
                        "  printOptionalToken,",
                        "  printFunctionTypeParameters,",
                        "  printBindExpressionCallee,",
                        "} = require(\"./misc.js\");",
                        "",
                        "// We detect calls on member expressions specially to format a",
                        "// common pattern better. The pattern we are looking for is this:",
                        "//",
                        "// arr",
                        "//   .map(x => x + 1)",
                        "//   .filter(x => x > 10)",
                        "//   .some(x => x % 2)",
                        "//",
                        "// The way it is structured in the AST is via a nested sequence of",
                        "// MemberExpression and CallExpression. We need to traverse the AST",
                        "// and make groups out of it to print it in the desired way.",
                        "function printMemberChain(path, options, print) {",
                        "  const parent = path.getParentNode();",
                        "  const isExpressionStatement =",
                        "    !parent || parent.type === \"ExpressionStatement\";",
                        "",
                        "  // The first phase is to linearize the AST by traversing it down.",
                        "  //",
                        "  //   a().b()",
                        "  // has the following AST structure:",
                        "  //   CallExpression(MemberExpression(CallExpression(Identifier)))",
                        "  // and we transform it into",
                        "  //   [Identifier, CallExpression, MemberExpression, CallExpression]",
                        "  const printedNodes = [];",
                        "",
                        "  // Here we try to retain one typed empty line after each call expression or",
                        "  // the first group whether it is in parentheses or not",
                        "  function shouldInsertEmptyLineAfter(node) {",
                        "    const { originalText } = options;",
                        "    const nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(",
                        "      originalText,",
                        "      node,",
                        "      locEnd",
                        "    );",
                        "    const nextChar = originalText.charAt(nextCharIndex);",
                        "",
                        "    // if it is cut off by a parenthesis, we only account for one typed empty",
                        "    // line after that parenthesis",
                        "    if (nextChar === \")\") {",
                        "      return (",
                        "        nextCharIndex !== false &&",
                        "        isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1)",
                        "      );",
                        "    }",
                        "",
                        "    return isNextLineEmpty(node, options);",
                        "  }",
                        "",
                        "  function rec(path) {",
                        "    const node = path.getValue();",
                        "    if (",
                        "      isCallExpression(node) &&",
                        "      (isMemberish(node.callee) || isCallExpression(node.callee))",
                        "    ) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: [",
                        "          printComments(",
                        "            path,",
                        "            [",
                        "              printOptionalToken(path),",
                        "              printFunctionTypeParameters(path, options, print),",
                        "              printCallArguments(path, options, print),",
                        "            ],",
                        "            options",
                        "          ),",
                        "          shouldInsertEmptyLineAfter(node) ? hardline : \"\",",
                        "        ],",
                        "      });",
                        "      path.call((callee) => rec(callee), \"callee\");",
                        "    } else if (isMemberish(node)) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        needsParens: pathNeedsParens(path, options),",
                        "        printed: printComments(",
                        "          path,",
                        "          isMemberExpression(node)",
                        "            ? printMemberLookup(path, options, print)",
                        "            : printBindExpressionCallee(path, options, print),",
                        "          options",
                        "        ),",
                        "      });",
                        "      path.call((object) => rec(object), \"object\");",
                        "    } else if (node.type === \"TSNonNullExpression\") {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: printComments(path, \"!\", options),",
                        "      });",
                        "      path.call((expression) => rec(expression), \"expression\");",
                        "    } else {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: print(),",
                        "      });",
                        "    }",
                        "  }",
                        "  // Note: the comments of the root node have already been printed, so we",
                        "  // need to extract this first call without printing them as they would",
                        "  // if handled inside of the recursive call.",
                        "  const node = path.getValue();",
                        "  printedNodes.unshift({",
                        "    node,",
                        "    printed: [",
                        "      printOptionalToken(path),",
                        "      printFunctionTypeParameters(path, options, print),",
                        "      printCallArguments(path, options, print),",
                        "    ],",
                        "  });",
                        "",
                        "  if (node.callee) {",
                        "    path.call((callee) => rec(callee), \"callee\");",
                        "  }",
                        "",
                        "  // Once we have a linear list of printed nodes, we want to create groups out",
                        "  // of it.",
                        "  //",
                        "  //   a().b.c().d().e",
                        "  // will be grouped as",
                        "  //   [",
                        "  //     [Identifier, CallExpression],",
                        "  //     [MemberExpression, MemberExpression, CallExpression],",
                        "  //     [MemberExpression, CallExpression],",
                        "  //     [MemberExpression],",
                        "  //   ]",
                        "  // so that we can print it as",
                        "  //   a()",
                        "  //     .b.c()",
                        "  //     .d()",
                        "  //     .e",
                        "",
                        "  // The first group is the first node followed by",
                        "  //   - as many CallExpression as possible",
                        "  //       < fn()()() >.something()",
                        "  //   - as many array accessors as possible",
                        "  //       < fn()[0][1][2] >.something()",
                        "  //   - then, as many MemberExpression as possible but the last one",
                        "  //       < this.items >.something()",
                        "  const groups = [];",
                        "  let currentGroup = [printedNodes[0]];",
                        "  let i = 1;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (",
                        "      printedNodes[i].node.type === \"TSNonNullExpression\" ||",
                        "      isCallExpression(printedNodes[i].node) ||",
                        "      (isMemberExpression(printedNodes[i].node) &&",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property))",
                        "    ) {",
                        "      currentGroup.push(printedNodes[i]);",
                        "    } else {",
                        "      break;",
                        "    }",
                        "  }",
                        "  if (!isCallExpression(printedNodes[0].node)) {",
                        "    for (; i + 1 < printedNodes.length; ++i) {",
                        "      if (",
                        "        isMemberish(printedNodes[i].node) &&",
                        "        isMemberish(printedNodes[i + 1].node)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "      } else {",
                        "        break;",
                        "      }",
                        "    }",
                        "  }",
                        "  groups.push(currentGroup);",
                        "  currentGroup = [];",
                        "",
                        "  // Then, each following group is a sequence of MemberExpression followed by",
                        "  // a sequence of CallExpression. To compute it, we keep adding things to the",
                        "  // group until we has seen a CallExpression in the past and reach a",
                        "  // MemberExpression",
                        "  let hasSeenCallExpression = false;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {",
                        "      // [0] should be appended at the end of the group instead of the",
                        "      // beginning of the next one",
                        "      if (",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "        continue;",
                        "      }",
                        "",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "",
                        "    if (",
                        "      isCallExpression(printedNodes[i].node) ||",
                        "      printedNodes[i].node.type === \"ImportExpression\"",
                        "    ) {",
                        "      hasSeenCallExpression = true;",
                        "    }",
                        "    currentGroup.push(printedNodes[i]);",
                        "",
                        "    if (hasComment(printedNodes[i].node, CommentCheckFlags.Trailing)) {",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "  }",
                        "  if (currentGroup.length > 0) {",
                        "    groups.push(currentGroup);",
                        "  }",
                        "",
                        "  // There are cases like Object.keys(), Observable.of(), _.values() where",
                        "  // they are the subject of all the chained calls and therefore should",
                        "  // be kept on the same line:",
                        "  //",
                        "  //   Object.keys(items)",
                        "  //     .filter(x => x)",
                        "  //     .map(x => x)",
                        "  //",
                        "  // In order to detect those cases, we use an heuristic: if the first",
                        "  // node is an identifier with the name starting with a capital",
                        "  // letter or just a sequence of _$. The rationale is that they are",
                        "  // likely to be factories.",
                        "  function isFactory(name) {",
                        "    return /^[A-Z]|^[$_]+$/.test(name);",
                        "  }",
                        "",
                        "  // In case the Identifier is shorter than tab width, we can keep the",
                        "  // first call in a single line, if it's an ExpressionStatement.",
                        "  //",
                        "  //   d3.scaleLinear()",
                        "  //     .domain([0, 100])",
                        "  //     .range([0, width]);",
                        "  //",
                        "  function isShort(name) {",
                        "    return name.length <= options.tabWidth;",
                        "  }",
                        "",
                        "  function shouldNotWrap(groups) {",
                        "    const hasComputed = groups[1].length > 0 && groups[1][0].node.computed;",
                        "",
                        "    if (groups[0].length === 1) {",
                        "      const firstNode = groups[0][0].node;",
                        "      return (",
                        "        firstNode.type === \"ThisExpression\" ||",
                        "        (firstNode.type === \"Identifier\" &&",
                        "          (isFactory(firstNode.name) ||",
                        "            (isExpressionStatement && isShort(firstNode.name)) ||",
                        "            hasComputed))",
                        "      );",
                        "    }",
                        "",
                        "    const lastNode = getLast(groups[0]).node;",
                        "    return (",
                        "      isMemberExpression(lastNode) &&",
                        "      lastNode.property.type === \"Identifier\" &&",
                        "      (isFactory(lastNode.property.name) || hasComputed)",
                        "    );",
                        "  }",
                        "",
                        "  const shouldMerge =",
                        "    groups.length >= 2 &&",
                        "    !hasComment(groups[1][0].node) &&",
                        "    shouldNotWrap(groups);",
                        "",
                        "  function printGroup(printedGroup) {",
                        "    const printed = printedGroup.map((tuple) => tuple.printed);",
                        "    // Checks if the last node (i.e. the parent node) needs parens and print",
                        "    // accordingly",
                        "    if (printedGroup.length > 0 && getLast(printedGroup).needsParens) {",
                        "      return [\"(\", ...printed, \")\"];",
                        "    }",
                        "    return printed;",
                        "  }",
                        "",
                        "  function printIndentedGroup(groups) {",
                        "    /* istanbul ignore next */",
                        "    if (groups.length === 0) {",
                        "      return \"\";",
                        "    }",
                        "    return indent(group([hardline, join(hardline, groups.map(printGroup))]));",
                        "  }",
                        "",
                        "  const printedGroups = groups.map(printGroup);",
                        "  const oneLine = printedGroups;",
                        "",
                        "  const cutoff = shouldMerge ? 3 : 2;",
                        "  const flatGroups = groups.flat();",
                        "",
                        "  const nodeHasComment =",
                        "    flatGroups",
                        "      .slice(1, -1)",
                        "      .some((node) => hasComment(node.node, CommentCheckFlags.Leading)) ||",
                        "    flatGroups",
                        "      .slice(0, -1)",
                        "      .some((node) => hasComment(node.node, CommentCheckFlags.Trailing)) ||",
                        "    (groups[cutoff] &&",
                        "      hasComment(groups[cutoff][0].node, CommentCheckFlags.Leading));",
                        "",
                        "  // If we only have a single `.`, we shouldn't do anything fancy and just",
                        "  // render everything concatenated together.",
                        "  if (groups.length <= cutoff && !nodeHasComment) {",
                        "    if (isLongCurriedCallExpression(path)) {",
                        "      return oneLine;",
                        "    }",
                        "    return group(oneLine);",
                        "  }",
                        "",
                        "  // Find out the last node in the first group and check if it has an",
                        "  // empty line after",
                        "  const lastNodeBeforeIndent = getLast(groups[shouldMerge ? 1 : 0]).node;",
                        "  const shouldHaveEmptyLineBeforeIndent =",
                        "    !isCallExpression(lastNodeBeforeIndent) &&",
                        "    shouldInsertEmptyLineAfter(lastNodeBeforeIndent);",
                        "",
                        "  const expanded = [",
                        "    printGroup(groups[0]),",
                        "    shouldMerge ? groups.slice(1, 2).map(printGroup) : \"\",",
                        "    shouldHaveEmptyLineBeforeIndent ? hardline : \"\",",
                        "    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1)),",
                        "  ];",
                        "",
                        "  const callExpressions = printedNodes",
                        "    .map(({ node }) => node)",
                        "    .filter(isCallExpression);",
                        "",
                        "  function lastGroupWillBreakAndOtherCallsHaveFunctionArguments() {",
                        "    const lastGroupNode = getLast(getLast(groups)).node;",
                        "    const lastGroupDoc = getLast(printedGroups);",
                        "    return (",
                        "      isCallExpression(lastGroupNode) &&",
                        "      willBreak(lastGroupDoc) &&",
                        "      callExpressions",
                        "        .slice(0, -1)",
                        "        .some((node) => node.arguments.some(isFunctionOrArrowExpression))",
                        "    );",
                        "  }",
                        "",
                        "  let result;",
                        "",
                        "  // We don't want to print in one line if at least one of these conditions occurs:",
                        "  //  * the chain has comments,",
                        "  //  * the chain is an expression statement and all the arguments are literal-like (\"fluent configuration\" pattern),",
                        "  //  * the chain is longer than 2 calls and has non-trivial arguments or more than 2 arguments in any call but the first one,",
                        "  //  * any group but the last one has a hard line,",
                        "  //  * the last call's arguments have a hard line and other calls have non-trivial arguments.",
                        "  if (",
                        "    nodeHasComment ||",
                        "    (callExpressions.length > 2 &&",
                        "      callExpressions.some(",
                        "        (expr) => !expr.arguments.every((arg) => isSimpleCallArgument(arg, 0))",
                        "      )) ||",
                        "    printedGroups.slice(0, -1).some(willBreak) ||",
                        "    lastGroupWillBreakAndOtherCallsHaveFunctionArguments()",
                        "  ) {",
                        "    result = group(expanded);",
                        "  } else {",
                        "    result = [",
                        "      // We only need to check `oneLine` because if `expanded` is chosen",
                        "      // that means that the parent group has already been broken",
                        "      // naturally",
                        "      willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\",",
                        "      conditionalGroup([oneLine, expanded]),",
                        "    ];",
                        "  }",
                        "",
                        "  return label(\"member-chain\", result);",
                        "}",
                        "",
                        "module.exports = printMemberChain;"
                    ]
                },
                "member.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { softline, group, indent, label },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  isNumericLiteral,",
                        "  isMemberExpression,",
                        "  isCallExpression,",
                        "} = require(\"../utils/index.js\");",
                        "const { printOptionalToken } = require(\"./misc.js\");",
                        "",
                        "function printMemberExpression(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  const parent = path.getParentNode();",
                        "  let firstNonMemberParent;",
                        "  let i = 0;",
                        "  do {",
                        "    firstNonMemberParent = path.getParentNode(i);",
                        "    i++;",
                        "  } while (",
                        "    firstNonMemberParent &&",
                        "    (isMemberExpression(firstNonMemberParent) ||",
                        "      firstNonMemberParent.type === \"TSNonNullExpression\")",
                        "  );",
                        "",
                        "  const objectDoc = print(\"object\");",
                        "  const lookupDoc = printMemberLookup(path, options, print);",
                        "",
                        "  const shouldInline =",
                        "    (firstNonMemberParent &&",
                        "      (firstNonMemberParent.type === \"NewExpression\" ||",
                        "        firstNonMemberParent.type === \"BindExpression\" ||",
                        "        (firstNonMemberParent.type === \"AssignmentExpression\" &&",
                        "          firstNonMemberParent.left.type !== \"Identifier\"))) ||",
                        "    node.computed ||",
                        "    (node.object.type === \"Identifier\" &&",
                        "      node.property.type === \"Identifier\" &&",
                        "      !isMemberExpression(parent)) ||",
                        "    ((parent.type === \"AssignmentExpression\" ||",
                        "      parent.type === \"VariableDeclarator\") &&",
                        "      ((isCallExpression(node.object) && node.object.arguments.length > 0) ||",
                        "        (node.object.type === \"TSNonNullExpression\" &&",
                        "          isCallExpression(node.object.expression) &&",
                        "          node.object.expression.arguments.length > 0) ||",
                        "        objectDoc.label === \"member-chain\"));",
                        "",
                        "  return label(objectDoc.label === \"member-chain\" ? \"member-chain\" : \"member\", [",
                        "    objectDoc,",
                        "    shouldInline ? lookupDoc : group(indent([softline, lookupDoc])),",
                        "  ]);",
                        "}",
                        "",
                        "function printMemberLookup(path, options, print) {",
                        "  const property = print(\"property\");",
                        "  const node = path.getValue();",
                        "  const optional = printOptionalToken(path);",
                        "",
                        "  if (!node.computed) {",
                        "    return [optional, \".\", property];",
                        "  }",
                        "",
                        "  if (!node.property || isNumericLiteral(node.property)) {",
                        "    return [optional, \"[\", property, \"]\"];",
                        "  }",
                        "",
                        "  return group([optional, \"[\", indent([softline, property]), softline, \"]\"]);",
                        "}",
                        "",
                        "module.exports = { printMemberExpression, printMemberLookup };"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { indent, join, line },",
                        "} = require(\"../../document/index.js\");",
                        "const { isFlowAnnotationComment } = require(\"../utils/index.js\");",
                        "",
                        "function printOptionalToken(path) {",
                        "  const node = path.getValue();",
                        "  if (",
                        "    !node.optional ||",
                        "    // It's an optional computed method parsed by typescript-estree.",
                        "    // \"?\" is printed in `printMethod`.",
                        "    (node.type === \"Identifier\" && node === path.getParentNode().key)",
                        "  ) {",
                        "    return \"\";",
                        "  }",
                        "  if (",
                        "    node.type === \"OptionalCallExpression\" ||",
                        "    (node.type === \"OptionalMemberExpression\" && node.computed)",
                        "  ) {",
                        "    return \"?.\";",
                        "  }",
                        "  return \"?\";",
                        "}",
                        "",
                        "function printDefiniteToken(path) {",
                        "  return path.getValue().definite ||",
                        "    path.match(",
                        "      undefined,",
                        "      (node, name) =>",
                        "        name === \"id\" && node.type === \"VariableDeclarator\" && node.definite",
                        "    )",
                        "    ? \"!\"",
                        "    : \"\";",
                        "}",
                        "",
                        "function printFunctionTypeParameters(path, options, print) {",
                        "  const fun = path.getValue();",
                        "  if (fun.typeArguments) {",
                        "    return print(\"typeArguments\");",
                        "  }",
                        "  if (fun.typeParameters) {",
                        "    return print(\"typeParameters\");",
                        "  }",
                        "  return \"\";",
                        "}",
                        "",
                        "function printTypeAnnotation(path, options, print) {",
                        "  const node = path.getValue();",
                        "  if (!node.typeAnnotation) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const parentNode = path.getParentNode();",
                        "",
                        "  const isFunctionDeclarationIdentifier =",
                        "    parentNode.type === \"DeclareFunction\" && parentNode.id === node;",
                        "",
                        "  if (isFlowAnnotationComment(options.originalText, node.typeAnnotation)) {",
                        "    return [\" /*: \", print(\"typeAnnotation\"), \" */\"];",
                        "  }",
                        "",
                        "  return [isFunctionDeclarationIdentifier ? \"\" : \": \", print(\"typeAnnotation\")];",
                        "}",
                        "",
                        "function printBindExpressionCallee(path, options, print) {",
                        "  return [\"::\", print(\"callee\")];",
                        "}",
                        "",
                        "function printTypeScriptModifiers(path, options, print) {",
                        "  const node = path.getValue();",
                        "  if (!isNonEmptyArray(node.modifiers)) {",
                        "    return \"\";",
                        "  }",
                        "  return [join(\" \", path.map(print, \"modifiers\")), \" \"];",
                        "}",
                        "",
                        "function adjustClause(node, clause, forceSpace) {",
                        "  if (node.type === \"EmptyStatement\") {",
                        "    return \";\";",
                        "  }",
                        "",
                        "  if (node.type === \"BlockStatement\" || forceSpace) {",
                        "    return [\" \", clause];",
                        "  }",
                        "",
                        "  return indent([line, clause]);",
                        "}",
                        "",
                        "function printRestSpread(path, options, print) {",
                        "  return [\"...\", print(\"argument\"), printTypeAnnotation(path, options, print)];",
                        "}",
                        "",
                        "function printDirective(rawText, options) {",
                        "  const rawContent = rawText.slice(1, -1);",
                        "",
                        "  // Check for the alternate quote, to determine if we're allowed to swap",
                        "  // the quotes on a DirectiveLiteral.",
                        "  if (rawContent.includes('\"') || rawContent.includes(\"'\")) {",
                        "    return rawText;",
                        "  }",
                        "",
                        "  const enclosingQuote = options.singleQuote ? \"'\" : '\"';",
                        "",
                        "  // Directives are exact code unit sequences, which means that you can't",
                        "  // change the escape sequences they use.",
                        "  // See https://github.com/prettier/prettier/issues/1555",
                        "  // and https://tc39.github.io/ecma262/#directive-prologue",
                        "  return enclosingQuote + rawContent + enclosingQuote;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printOptionalToken,",
                        "  printDefiniteToken,",
                        "  printFunctionTypeParameters,",
                        "  printBindExpressionCallee,",
                        "  printTypeScriptModifiers,",
                        "  printTypeAnnotation,",
                        "  printRestSpread,",
                        "  adjustClause,",
                        "  printDirective,",
                        "};"
                    ]
                },
                "module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { softline, group, indent, join, line, ifBreak, hardline },",
                        "} = require(\"../../document/index.js\");",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "",
                        "const {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  shouldPrintComma,",
                        "  needsHardlineAfterDanglingComment,",
                        "  isStringLiteral,",
                        "  rawText,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart, hasSameLoc } = require(\"../loc.js\");",
                        "const {",
                        "  hasDecoratorsBeforeExport,",
                        "  printDecoratorsBeforeExport,",
                        "} = require(\"./decorators.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document\").Doc} Doc",
                        " */",
                        "",
                        "function printImportDeclaration(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  const { importKind } = node;",
                        "",
                        "  parts.push(\"import\");",
                        "",
                        "  if (importKind && importKind !== \"value\") {",
                        "    parts.push(\" \", importKind);",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printModuleSpecifiers(path, options, print),",
                        "    printModuleSource(path, options, print),",
                        "    printImportAssertions(path, options, print),",
                        "    semi",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printExportDeclaration(path, options, print) {",
                        "  const node = path.getValue();",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  // Only print decorators here if they were written before the export,",
                        "  // otherwise they are printed by the node.declaration",
                        "  if (hasDecoratorsBeforeExport(node)) {",
                        "    parts.push(printDecoratorsBeforeExport(path, options, print));",
                        "  }",
                        "",
                        "  const { type, exportKind, declaration } = node;",
                        "",
                        "  parts.push(\"export\");",
                        "",
                        "  const isDefaultExport = node.default || type === \"ExportDefaultDeclaration\";",
                        "  if (isDefaultExport) {",
                        "    parts.push(\" default\");",
                        "  }",
                        "",
                        "  if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    parts.push(",
                        "      \" \",",
                        "      printDanglingComments(path, options, /* sameIndent */ true)",
                        "    );",
                        "",
                        "    if (needsHardlineAfterDanglingComment(node)) {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  if (declaration) {",
                        "    parts.push(\" \", print(\"declaration\"));",
                        "  } else {",
                        "    parts.push(",
                        "      exportKind === \"type\" ? \" type\" : \"\",",
                        "      printModuleSpecifiers(path, options, print),",
                        "      printModuleSource(path, options, print),",
                        "      printImportAssertions(path, options, print)",
                        "    );",
                        "  }",
                        "",
                        "  if (shouldExportDeclarationPrintSemi(node, options)) {",
                        "    parts.push(\";\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printExportAllDeclaration(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  const { exportKind, exported } = node;",
                        "",
                        "  parts.push(\"export\");",
                        "",
                        "  if (exportKind === \"type\") {",
                        "    parts.push(\" type\");",
                        "  }",
                        "",
                        "  parts.push(\" *\");",
                        "",
                        "  if (exported) {",
                        "    parts.push(\" as \", print(\"exported\"));",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printModuleSource(path, options, print),",
                        "    printImportAssertions(path, options, print),",
                        "    semi",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldExportDeclarationPrintSemi(node, options) {",
                        "  if (!options.semi) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const { type, declaration } = node;",
                        "  const isDefaultExport = node.default || type === \"ExportDefaultDeclaration\";",
                        "  if (!declaration) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const { type: declarationType } = declaration;",
                        "  if (",
                        "    isDefaultExport &&",
                        "    declarationType !== \"ClassDeclaration\" &&",
                        "    declarationType !== \"FunctionDeclaration\" &&",
                        "    declarationType !== \"TSInterfaceDeclaration\" &&",
                        "    declarationType !== \"DeclareClass\" &&",
                        "    declarationType !== \"DeclareFunction\" &&",
                        "    declarationType !== \"TSDeclareFunction\" &&",
                        "    declarationType !== \"EnumDeclaration\"",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function printModuleSource(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (!node.source) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "  if (!shouldNotPrintSpecifiers(node, options)) {",
                        "    parts.push(\" from\");",
                        "  }",
                        "  parts.push(\" \", print(\"source\"));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printModuleSpecifiers(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (shouldNotPrintSpecifiers(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [\" \"];",
                        "",
                        "  if (isNonEmptyArray(node.specifiers)) {",
                        "    const standaloneSpecifiers = [];",
                        "    const groupedSpecifiers = [];",
                        "",
                        "    path.each(() => {",
                        "      const specifierType = path.getValue().type;",
                        "      if (",
                        "        specifierType === \"ExportNamespaceSpecifier\" ||",
                        "        specifierType === \"ExportDefaultSpecifier\" ||",
                        "        specifierType === \"ImportNamespaceSpecifier\" ||",
                        "        specifierType === \"ImportDefaultSpecifier\"",
                        "      ) {",
                        "        standaloneSpecifiers.push(print());",
                        "      } else if (",
                        "        specifierType === \"ExportSpecifier\" ||",
                        "        specifierType === \"ImportSpecifier\"",
                        "      ) {",
                        "        groupedSpecifiers.push(print());",
                        "      } else {",
                        "        /* istanbul ignore next */",
                        "        throw new Error(",
                        "          `Unknown specifier type ${JSON.stringify(specifierType)}`",
                        "        );",
                        "      }",
                        "    }, \"specifiers\");",
                        "",
                        "    parts.push(join(\", \", standaloneSpecifiers));",
                        "",
                        "    if (groupedSpecifiers.length > 0) {",
                        "      if (standaloneSpecifiers.length > 0) {",
                        "        parts.push(\", \");",
                        "      }",
                        "",
                        "      const canBreak =",
                        "        groupedSpecifiers.length > 1 ||",
                        "        standaloneSpecifiers.length > 0 ||",
                        "        node.specifiers.some((node) => hasComment(node));",
                        "",
                        "      if (canBreak) {",
                        "        parts.push(",
                        "          group([",
                        "            \"{\",",
                        "            indent([",
                        "              options.bracketSpacing ? line : softline,",
                        "              join([\",\", line], groupedSpecifiers),",
                        "            ]),",
                        "            ifBreak(shouldPrintComma(options) ? \",\" : \"\"),",
                        "            options.bracketSpacing ? line : softline,",
                        "            \"}\",",
                        "          ])",
                        "        );",
                        "      } else {",
                        "        parts.push([",
                        "          \"{\",",
                        "          options.bracketSpacing ? \" \" : \"\",",
                        "          ...groupedSpecifiers,",
                        "          options.bracketSpacing ? \" \" : \"\",",
                        "          \"}\",",
                        "        ]);",
                        "      }",
                        "    }",
                        "  } else {",
                        "    parts.push(\"{}\");",
                        "  }",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldNotPrintSpecifiers(node, options) {",
                        "  const { type, importKind, source, specifiers } = node;",
                        "",
                        "  if (",
                        "    type !== \"ImportDeclaration\" ||",
                        "    isNonEmptyArray(specifiers) ||",
                        "    importKind === \"type\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // TODO: check tokens",
                        "  return !/{\\s*}/.test(",
                        "    options.originalText.slice(locStart(node), locStart(source))",
                        "  );",
                        "}",
                        "",
                        "function printImportAssertions(path, options, print) {",
                        "  const node = path.getNode();",
                        "  if (isNonEmptyArray(node.assertions)) {",
                        "    return [",
                        "      \" assert {\",",
                        "      options.bracketSpacing ? \" \" : \"\",",
                        "      join(\", \", path.map(print, \"assertions\")),",
                        "      options.bracketSpacing ? \" \" : \"\",",
                        "      \"}\",",
                        "    ];",
                        "  }",
                        "  return \"\";",
                        "}",
                        "",
                        "function printModuleSpecifier(path, options, print) {",
                        "  const node = path.getNode();",
                        "",
                        "  const { type } = node;",
                        "",
                        "  /** @type {Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  /** @type {\"type\" | \"typeof\" | \"value\"} */",
                        "  const kind = type === \"ImportSpecifier\" ? node.importKind : node.exportKind;",
                        "",
                        "  if (kind && kind !== \"value\") {",
                        "    parts.push(kind, \" \");",
                        "  }",
                        "",
                        "  const isImport = type.startsWith(\"Import\");",
                        "  const leftSideProperty = isImport ? \"imported\" : \"local\";",
                        "  const rightSideProperty = isImport ? \"local\" : \"exported\";",
                        "  const leftSideNode = node[leftSideProperty];",
                        "  const rightSideNode = node[rightSideProperty];",
                        "  let left = \"\";",
                        "  let right = \"\";",
                        "  if (",
                        "    type === \"ExportNamespaceSpecifier\" ||",
                        "    type === \"ImportNamespaceSpecifier\"",
                        "  ) {",
                        "    left = \"*\";",
                        "  } else if (leftSideNode) {",
                        "    left = print(leftSideProperty);",
                        "  }",
                        "",
                        "  if (rightSideNode && !isShorthandSpecifier(node)) {",
                        "    right = print(rightSideProperty);",
                        "  }",
                        "",
                        "  parts.push(left, left && right ? \" as \" : \"\", right);",
                        "  return parts;",
                        "}",
                        "",
                        "function isShorthandSpecifier(specifier) {",
                        "  if (",
                        "    specifier.type !== \"ImportSpecifier\" &&",
                        "    specifier.type !== \"ExportSpecifier\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const {",
                        "    local,",
                        "    [specifier.type === \"ImportSpecifier\" ? \"imported\" : \"exported\"]:",
                        "      importedOrExported,",
                        "  } = specifier;",
                        "",
                        "  if (",
                        "    local.type !== importedOrExported.type ||",
                        "    !hasSameLoc(local, importedOrExported)",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isStringLiteral(local)) {",
                        "    return (",
                        "      local.value === importedOrExported.value &&",
                        "      rawText(local) === rawText(importedOrExported)",
                        "    );",
                        "  }",
                        "",
                        "  switch (local.type) {",
                        "    case \"Identifier\":",
                        "      return local.name === importedOrExported.name;",
                        "    default:",
                        "      /* istanbul ignore next */",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "module.exports = {",
                        "  printImportDeclaration,",
                        "  printExportDeclaration,",
                        "  printExportAllDeclaration,",
                        "  printModuleSpecifier,",
                        "};"
                    ]
                },
                "object.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { line, softline, group, indent, ifBreak, hardline },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  getLast,",
                        "  hasNewlineInRange,",
                        "  hasNewline,",
                        "  isNonEmptyArray,",
                        "} = require(\"../../common/util.js\");",
                        "const {",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "",
                        "const { printOptionalToken, printTypeAnnotation } = require(\"./misc.js\");",
                        "const { shouldHugFunctionParameters } = require(\"./function-parameters.js\");",
                        "const { shouldHugType } = require(\"./type-annotation.js\");",
                        "const { printHardlineAfterHeritage } = require(\"./class.js\");",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "function printObject(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const node = path.getValue();",
                        "",
                        "  let propertiesField;",
                        "",
                        "  if (node.type === \"TSTypeLiteral\") {",
                        "    propertiesField = \"members\";",
                        "  } else if (node.type === \"TSInterfaceBody\") {",
                        "    propertiesField = \"body\";",
                        "  } else {",
                        "    propertiesField = \"properties\";",
                        "  }",
                        "",
                        "  const isTypeAnnotation = node.type === \"ObjectTypeAnnotation\";",
                        "  const fields = [propertiesField];",
                        "  if (isTypeAnnotation) {",
                        "    fields.push(\"indexers\", \"callProperties\", \"internalSlots\");",
                        "  }",
                        "",
                        "  const firstProperty = fields",
                        "    .map((field) => node[field][0])",
                        "    .sort((a, b) => locStart(a) - locStart(b))[0];",
                        "",
                        "  const parent = path.getParentNode(0);",
                        "  const isFlowInterfaceLikeBody =",
                        "    isTypeAnnotation &&",
                        "    parent &&",
                        "    (parent.type === \"InterfaceDeclaration\" ||",
                        "      parent.type === \"DeclareInterface\" ||",
                        "      parent.type === \"DeclareClass\") &&",
                        "    path.getName() === \"body\";",
                        "  const shouldBreak =",
                        "    node.type === \"TSInterfaceBody\" ||",
                        "    isFlowInterfaceLikeBody ||",
                        "    (node.type === \"ObjectPattern\" &&",
                        "      parent.type !== \"FunctionDeclaration\" &&",
                        "      parent.type !== \"FunctionExpression\" &&",
                        "      parent.type !== \"ArrowFunctionExpression\" &&",
                        "      parent.type !== \"ObjectMethod\" &&",
                        "      parent.type !== \"ClassMethod\" &&",
                        "      parent.type !== \"ClassPrivateMethod\" &&",
                        "      parent.type !== \"AssignmentPattern\" &&",
                        "      parent.type !== \"CatchClause\" &&",
                        "      node.properties.some(",
                        "        (property) =>",
                        "          property.value &&",
                        "          (property.value.type === \"ObjectPattern\" ||",
                        "            property.value.type === \"ArrayPattern\")",
                        "      )) ||",
                        "    (node.type !== \"ObjectPattern\" &&",
                        "      firstProperty &&",
                        "      hasNewlineInRange(",
                        "        options.originalText,",
                        "        locStart(node),",
                        "        locStart(firstProperty)",
                        "      ));",
                        "",
                        "  const separator = isFlowInterfaceLikeBody",
                        "    ? \";\"",
                        "    : node.type === \"TSInterfaceBody\" || node.type === \"TSTypeLiteral\"",
                        "    ? ifBreak(semi, \";\")",
                        "    : \",\";",
                        "  const leftBrace =",
                        "    node.type === \"RecordExpression\" ? \"#{\" : node.exact ? \"{|\" : \"{\";",
                        "  const rightBrace = node.exact ? \"|}\" : \"}\";",
                        "",
                        "  // Unfortunately, things are grouped together in the ast can be",
                        "  // interleaved in the source code. So we need to reorder them before",
                        "  // printing them.",
                        "  const propsAndLoc = [];",
                        "  for (const field of fields) {",
                        "    path.each((childPath) => {",
                        "      const node = childPath.getValue();",
                        "      propsAndLoc.push({",
                        "        node,",
                        "        printed: print(),",
                        "        loc: locStart(node),",
                        "      });",
                        "    }, field);",
                        "  }",
                        "",
                        "  if (fields.length > 1) {",
                        "    propsAndLoc.sort((a, b) => a.loc - b.loc);",
                        "  }",
                        "",
                        "  /** @type {Doc[]} */",
                        "  let separatorParts = [];",
                        "  const props = propsAndLoc.map((prop) => {",
                        "    const result = [...separatorParts, group(prop.printed)];",
                        "    separatorParts = [separator, line];",
                        "    if (",
                        "      (prop.node.type === \"TSPropertySignature\" ||",
                        "        prop.node.type === \"TSMethodSignature\" ||",
                        "        prop.node.type === \"TSConstructSignatureDeclaration\") &&",
                        "      hasComment(prop.node, CommentCheckFlags.PrettierIgnore)",
                        "    ) {",
                        "      separatorParts.shift();",
                        "    }",
                        "    if (isNextLineEmpty(prop.node, options)) {",
                        "      separatorParts.push(hardline);",
                        "    }",
                        "    return result;",
                        "  });",
                        "",
                        "  if (node.inexact) {",
                        "    let printed;",
                        "    if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      const hasLineComments = hasComment(node, CommentCheckFlags.Line);",
                        "      const printedDanglingComments = printDanglingComments(",
                        "        path,",
                        "        options,",
                        "        /* sameIndent */ true",
                        "      );",
                        "      printed = [",
                        "        printedDanglingComments,",
                        "        hasLineComments ||",
                        "        hasNewline(options.originalText, locEnd(getLast(getComments(node))))",
                        "          ? hardline",
                        "          : line,",
                        "        \"...\",",
                        "      ];",
                        "    } else {",
                        "      printed = [\"...\"];",
                        "    }",
                        "    props.push([...separatorParts, ...printed]);",
                        "  }",
                        "",
                        "  const lastElem = getLast(node[propertiesField]);",
                        "",
                        "  const canHaveTrailingSeparator = !(",
                        "    node.inexact ||",
                        "    (lastElem && lastElem.type === \"RestElement\") ||",
                        "    (lastElem &&",
                        "      (lastElem.type === \"TSPropertySignature\" ||",
                        "        lastElem.type === \"TSCallSignatureDeclaration\" ||",
                        "        lastElem.type === \"TSMethodSignature\" ||",
                        "        lastElem.type === \"TSConstructSignatureDeclaration\") &&",
                        "      hasComment(lastElem, CommentCheckFlags.PrettierIgnore))",
                        "  );",
                        "",
                        "  let content;",
                        "  if (props.length === 0) {",
                        "    if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      return [leftBrace, rightBrace, printTypeAnnotation(path, options, print)];",
                        "    }",
                        "",
                        "    content = group([",
                        "      leftBrace,",
                        "      printDanglingComments(path, options),",
                        "      softline,",
                        "      rightBrace,",
                        "      printOptionalToken(path),",
                        "      printTypeAnnotation(path, options, print),",
                        "    ]);",
                        "  } else {",
                        "    content = [",
                        "      isFlowInterfaceLikeBody && isNonEmptyArray(node.properties)",
                        "        ? printHardlineAfterHeritage(parent)",
                        "        : \"\",",
                        "      leftBrace,",
                        "      indent([options.bracketSpacing ? line : softline, ...props]),",
                        "      ifBreak(",
                        "        canHaveTrailingSeparator &&",
                        "          (separator !== \",\" || shouldPrintComma(options))",
                        "          ? separator",
                        "          : \"\"",
                        "      ),",
                        "      options.bracketSpacing ? line : softline,",
                        "      rightBrace,",
                        "      printOptionalToken(path),",
                        "      printTypeAnnotation(path, options, print),",
                        "    ];",
                        "  }",
                        "",
                        "  // If we inline the object as first argument of the parent, we don't want",
                        "  // to create another group so that the object breaks before the return",
                        "  // type",
                        "  if (",
                        "    path.match(",
                        "      (node) => node.type === \"ObjectPattern\" && !node.decorators,",
                        "      (node, name, number) =>",
                        "        shouldHugFunctionParameters(node) &&",
                        "        (name === \"params\" ||",
                        "          name === \"parameters\" ||",
                        "          name === \"this\" ||",
                        "          name === \"rest\") &&",
                        "        number === 0",
                        "    ) ||",
                        "    path.match(",
                        "      shouldHugType,",
                        "      (node, name) => name === \"typeAnnotation\",",
                        "      (node, name) => name === \"typeAnnotation\",",
                        "      (node, name, number) =>",
                        "        shouldHugFunctionParameters(node) &&",
                        "        (name === \"params\" ||",
                        "          name === \"parameters\" ||",
                        "          name === \"this\" ||",
                        "          name === \"rest\") &&",
                        "        number === 0",
                        "    ) ||",
                        "    // Assignment printing logic (printAssignment) is responsible",
                        "    // for adding a group if needed",
                        "    (!shouldBreak &&",
                        "      path.match(",
                        "        (node) => node.type === \"ObjectPattern\",",
                        "        (node) =>",
                        "          node.type === \"AssignmentExpression\" ||",
                        "          node.type === \"VariableDeclarator\"",
                        "      ))",
                        "  ) {",
                        "    return content;",
                        "  }",
                        "",
                        "  return group(content, { shouldBreak });",
                        "}",
                        "",
                        "module.exports = { printObject };"
                    ]
                },
                "property.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printComments } = require(\"../../main/comments.js\");",
                        "const { printString, printNumber } = require(\"../../common/util.js\");",
                        "const {",
                        "  isNumericLiteral,",
                        "  isSimpleNumber,",
                        "  isStringLiteral,",
                        "  isStringPropSafeToUnquote,",
                        "  rawText,",
                        "} = require(\"../utils/index.js\");",
                        "const { printAssignment } = require(\"./assignment.js\");",
                        "",
                        "const needsQuoteProps = new WeakMap();",
                        "",
                        "function printPropertyKey(path, options, print) {",
                        "  const node = path.getNode();",
                        "",
                        "  if (node.computed) {",
                        "    return [\"[\", print(\"key\"), \"]\"];",
                        "  }",
                        "",
                        "  const parent = path.getParentNode();",
                        "  const { key } = node;",
                        "",
                        "  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {",
                        "    const objectHasStringProp = (",
                        "      parent.properties ||",
                        "      parent.body ||",
                        "      parent.members",
                        "    ).some(",
                        "      (prop) =>",
                        "        !prop.computed &&",
                        "        prop.key &&",
                        "        isStringLiteral(prop.key) &&",
                        "        !isStringPropSafeToUnquote(prop, options)",
                        "    );",
                        "    needsQuoteProps.set(parent, objectHasStringProp);",
                        "  }",
                        "",
                        "  if (",
                        "    (key.type === \"Identifier\" ||",
                        "      (isNumericLiteral(key) &&",
                        "        isSimpleNumber(printNumber(rawText(key))) &&",
                        "        // Avoid converting 999999999999999999999 to 1e+21, 0.99999999999999999 to 1 and 1.0 to 1.",
                        "        String(key.value) === printNumber(rawText(key)) &&",
                        "        // Quoting number keys is safe in JS and Flow, but not in TypeScript (as",
                        "        // mentioned in `isStringPropSafeToUnquote`).",
                        "        !(options.parser === \"typescript\" || options.parser === \"babel-ts\"))) &&",
                        "    (options.parser === \"json\" ||",
                        "      (options.quoteProps === \"consistent\" && needsQuoteProps.get(parent)))",
                        "  ) {",
                        "    // a -> \"a\"",
                        "    // 1 -> \"1\"",
                        "    // 1.5 -> \"1.5\"",
                        "    const prop = printString(",
                        "      JSON.stringify(",
                        "        key.type === \"Identifier\" ? key.name : key.value.toString()",
                        "      ),",
                        "      options",
                        "    );",
                        "    return path.call((keyPath) => printComments(keyPath, prop, options), \"key\");",
                        "  }",
                        "",
                        "  if (",
                        "    isStringPropSafeToUnquote(node, options) &&",
                        "    (options.quoteProps === \"as-needed\" ||",
                        "      (options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent)))",
                        "  ) {",
                        "    // 'a' -> a",
                        "    // '1' -> 1",
                        "    // '1.5' -> 1.5",
                        "    return path.call(",
                        "      (keyPath) =>",
                        "        printComments(",
                        "          keyPath,",
                        "          /^\\d/.test(key.value) ? printNumber(key.value) : key.value,",
                        "          options",
                        "        ),",
                        "      \"key\"",
                        "    );",
                        "  }",
                        "",
                        "  return print(\"key\");",
                        "}",
                        "",
                        "function printProperty(path, options, print) {",
                        "  const node = path.getValue();",
                        "  if (node.shorthand) {",
                        "    return print(\"value\");",
                        "  }",
                        "",
                        "  return printAssignment(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    printPropertyKey(path, options, print),",
                        "    \":\",",
                        "    \"value\"",
                        "  );",
                        "}",
                        "",
                        "module.exports = { printProperty, printPropertyKey };"
                    ]
                },
                "statement.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { hardline },",
                        "} = require(\"../../document/index.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const {",
                        "  getLeftSidePathName,",
                        "  hasNakedLeftSide,",
                        "  isJsxNode,",
                        "  isTheOnlyJsxElementInMarkdown,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { shouldPrintParamsWithoutParens } = require(\"./function.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path\")} AstPath",
                        " */",
                        "",
                        "function printStatementSequence(path, options, print, property) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  const isClassBody = node.type === \"ClassBody\";",
                        "  const lastStatement = getLastStatement(node[property]);",
                        "",
                        "  path.each((path, index, statements) => {",
                        "    const node = path.getValue();",
                        "",
                        "    // Skip printing EmptyStatement nodes to avoid leaving stray",
                        "    // semicolons lying around.",
                        "    if (node.type === \"EmptyStatement\") {",
                        "      return;",
                        "    }",
                        "",
                        "    const printed = print();",
                        "",
                        "    // in no-semi mode, prepend statement with semicolon if it might break ASI",
                        "    // don't prepend the only JSX element in a program with semicolon",
                        "    if (",
                        "      !options.semi &&",
                        "      !isClassBody &&",
                        "      !isTheOnlyJsxElementInMarkdown(options, path) &&",
                        "      statementNeedsASIProtection(path, options)",
                        "    ) {",
                        "      if (hasComment(node, CommentCheckFlags.Leading)) {",
                        "        parts.push(print([], { needsSemi: true }));",
                        "      } else {",
                        "        parts.push(\";\", printed);",
                        "      }",
                        "    } else {",
                        "      parts.push(printed);",
                        "    }",
                        "",
                        "    if (",
                        "      !options.semi &&",
                        "      isClassBody &&",
                        "      isClassProperty(node) &&",
                        "      // `ClassBody` don't allow `EmptyStatement`,",
                        "      // so we can use `statements` to get next node",
                        "      shouldPrintSemicolonAfterClassProperty(node, statements[index + 1])",
                        "    ) {",
                        "      parts.push(\";\");",
                        "    }",
                        "",
                        "    if (node !== lastStatement) {",
                        "      parts.push(hardline);",
                        "",
                        "      if (isNextLineEmpty(node, options)) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, property);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function getLastStatement(statements) {",
                        "  for (let i = statements.length - 1; i >= 0; i--) {",
                        "    const statement = statements[i];",
                        "    if (statement.type !== \"EmptyStatement\") {",
                        "      return statement;",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "function statementNeedsASIProtection(path, options) {",
                        "  const node = path.getNode();",
                        "",
                        "  if (node.type !== \"ExpressionStatement\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  return path.call(",
                        "    (childPath) => expressionNeedsASIProtection(childPath, options),",
                        "    \"expression\"",
                        "  );",
                        "}",
                        "",
                        "function expressionNeedsASIProtection(path, options) {",
                        "  const node = path.getValue();",
                        "  switch (node.type) {",
                        "    case \"ParenthesizedExpression\":",
                        "    case \"TypeCastExpression\":",
                        "    case \"ArrayExpression\":",
                        "    case \"ArrayPattern\":",
                        "    case \"TemplateLiteral\":",
                        "    case \"TemplateElement\":",
                        "    case \"RegExpLiteral\":",
                        "      return true;",
                        "    case \"ArrowFunctionExpression\": {",
                        "      if (!shouldPrintParamsWithoutParens(path, options)) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    case \"UnaryExpression\": {",
                        "      const { prefix, operator } = node;",
                        "      if (prefix && (operator === \"+\" || operator === \"-\")) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    case \"BindExpression\": {",
                        "      if (!node.object) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    case \"Literal\": {",
                        "      if (node.regex) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    default: {",
                        "      if (isJsxNode(node)) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  if (pathNeedsParens(path, options)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!hasNakedLeftSide(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return path.call(",
                        "    (childPath) => expressionNeedsASIProtection(childPath, options),",
                        "    ...getLeftSidePathName(path, node)",
                        "  );",
                        "}",
                        "",
                        "function printBody(path, options, print) {",
                        "  return printStatementSequence(path, options, print, \"body\");",
                        "}",
                        "",
                        "function printSwitchCaseConsequent(path, options, print) {",
                        "  return printStatementSequence(path, options, print, \"consequent\");",
                        "}",
                        "",
                        "const isClassProperty = ({ type }) =>",
                        "  type === \"ClassProperty\" ||",
                        "  type === \"PropertyDefinition\" ||",
                        "  type === \"ClassPrivateProperty\" ||",
                        "  type === \"ClassAccessorProperty\" ||",
                        "  type === \"AccessorProperty\" ||",
                        "  type === \"TSAbstractPropertyDefinition\" ||",
                        "  type === \"TSAbstractAccessorProperty\";",
                        "/**",
                        " * @returns {boolean}",
                        " */",
                        "function shouldPrintSemicolonAfterClassProperty(node, nextNode) {",
                        "  const { type, name } = node.key;",
                        "  if (",
                        "    !node.computed &&",
                        "    type === \"Identifier\" &&",
                        "    (name === \"static\" ||",
                        "      name === \"get\" ||",
                        "      name === \"set\" ||",
                        "      // TODO: Remove this https://github.com/microsoft/TypeScript/issues/51707 is fixed",
                        "      name === \"accessor\") &&",
                        "    !node.value &&",
                        "    !node.typeAnnotation",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!nextNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    nextNode.static ||",
                        "    nextNode.accessibility // TypeScript",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!nextNode.computed) {",
                        "    const name = nextNode.key && nextNode.key.name;",
                        "    if (name === \"in\" || name === \"instanceof\") {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  // Flow variance sigil +/- requires semi if there's no",
                        "  // \"declare\" or \"static\" keyword before it.",
                        "  if (",
                        "    isClassProperty(nextNode) &&",
                        "    nextNode.variance &&",
                        "    !nextNode.static &&",
                        "    !nextNode.declare",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (nextNode.type) {",
                        "    case \"ClassProperty\":",
                        "    case \"PropertyDefinition\":",
                        "    case \"TSAbstractPropertyDefinition\":",
                        "      return nextNode.computed;",
                        "    case \"MethodDefinition\": // Flow",
                        "    case \"TSAbstractMethodDefinition\": // TypeScript",
                        "    case \"ClassMethod\":",
                        "    case \"ClassPrivateMethod\": {",
                        "      // Babel",
                        "      const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;",
                        "      if (isAsync || nextNode.kind === \"get\" || nextNode.kind === \"set\") {",
                        "        return false;",
                        "      }",
                        "",
                        "      const isGenerator = nextNode.value",
                        "        ? nextNode.value.generator",
                        "        : nextNode.generator;",
                        "      if (nextNode.computed || isGenerator) {",
                        "        return true;",
                        "      }",
                        "",
                        "      return false;",
                        "    }",
                        "",
                        "    case \"TSIndexSignature\":",
                        "      return true;",
                        "  }",
                        "",
                        "  /* istanbul ignore next */",
                        "  return false;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printBody,",
                        "  printSwitchCaseConsequent,",
                        "};"
                    ]
                },
                "template-literal.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const getLast = require(\"../../utils/get-last.js\");",
                        "const { getStringWidth, getIndentSize } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: {",
                        "    join,",
                        "    hardline,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    align,",
                        "    lineSuffixBoundary,",
                        "    addAlignmentToDoc,",
                        "  },",
                        "  printer: { printDocToString },",
                        "  utils: { mapDoc },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  isBinaryish,",
                        "  isJestEachTemplateLiteral,",
                        "  isSimpleTemplateLiteral,",
                        "  hasComment,",
                        "  isMemberExpression,",
                        "  isTSTypeExpression,",
                        "} = require(\"../utils/index.js\");",
                        "",
                        "function printTemplateLiteral(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const isTemplateLiteral = node.type === \"TemplateLiteral\";",
                        "",
                        "  if (",
                        "    isTemplateLiteral &&",
                        "    isJestEachTemplateLiteral(node, path.getParentNode())",
                        "  ) {",
                        "    const printed = printJestEachTemplateLiteral(path, options, print);",
                        "    if (printed) {",
                        "      return printed;",
                        "    }",
                        "  }",
                        "  let expressionsKey = \"expressions\";",
                        "  if (node.type === \"TSTemplateLiteralType\") {",
                        "    expressionsKey = \"types\";",
                        "  }",
                        "  const parts = [];",
                        "",
                        "  let expressions = path.map(print, expressionsKey);",
                        "  const isSimple = isSimpleTemplateLiteral(node);",
                        "",
                        "  if (isSimple) {",
                        "    expressions = expressions.map(",
                        "      (doc) =>",
                        "        printDocToString(doc, {",
                        "          ...options,",
                        "          printWidth: Number.POSITIVE_INFINITY,",
                        "        }).formatted",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(lineSuffixBoundary, \"`\");",
                        "",
                        "  path.each((childPath) => {",
                        "    const i = childPath.getName();",
                        "",
                        "    parts.push(print());",
                        "",
                        "    if (i < expressions.length) {",
                        "      // For a template literal of the following form:",
                        "      //   `someQuery {",
                        "      //     ${call({",
                        "      //       a,",
                        "      //       b,",
                        "      //     })}",
                        "      //   }`",
                        "      // the expression is on its own line (there is a \\n in the previous",
                        "      // quasi literal), therefore we want to indent the JavaScript",
                        "      // expression inside at the beginning of ${ instead of the beginning",
                        "      // of the `.",
                        "      const { tabWidth } = options;",
                        "      const quasi = childPath.getValue();",
                        "      const indentSize = getIndentSize(quasi.value.raw, tabWidth);",
                        "",
                        "      let printed = expressions[i];",
                        "",
                        "      if (!isSimple) {",
                        "        const expression = node[expressionsKey][i];",
                        "        // Breaks at the template element boundaries (${ and }) are preferred to breaking",
                        "        // in the middle of a MemberExpression",
                        "        if (",
                        "          hasComment(expression) ||",
                        "          isMemberExpression(expression) ||",
                        "          expression.type === \"ConditionalExpression\" ||",
                        "          expression.type === \"SequenceExpression\" ||",
                        "          isTSTypeExpression(expression) ||",
                        "          isBinaryish(expression)",
                        "        ) {",
                        "          printed = [indent([softline, printed]), softline];",
                        "        }",
                        "      }",
                        "",
                        "      const aligned =",
                        "        indentSize === 0 && quasi.value.raw.endsWith(\"\\n\")",
                        "          ? align(Number.NEGATIVE_INFINITY, printed)",
                        "          : addAlignmentToDoc(printed, indentSize, tabWidth);",
                        "",
                        "      parts.push(group([\"${\", aligned, lineSuffixBoundary, \"}\"]));",
                        "    }",
                        "  }, \"quasis\");",
                        "",
                        "  parts.push(\"`\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJestEachTemplateLiteral(path, options, print) {",
                        "  /**",
                        "   * a    | b    | expected",
                        "   * ${1} | ${1} | ${2}",
                        "   * ${1} | ${2} | ${3}",
                        "   * ${2} | ${1} | ${3}",
                        "   */",
                        "  const node = path.getNode();",
                        "  const headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);",
                        "  if (",
                        "    headerNames.length > 1 ||",
                        "    headerNames.some((headerName) => headerName.length > 0)",
                        "  ) {",
                        "    options.__inJestEach = true;",
                        "    const expressions = path.map(print, \"expressions\");",
                        "    options.__inJestEach = false;",
                        "    const parts = [];",
                        "    const stringifiedExpressions = expressions.map(",
                        "      (doc) =>",
                        "        \"${\" +",
                        "        printDocToString(doc, {",
                        "          ...options,",
                        "          printWidth: Number.POSITIVE_INFINITY,",
                        "          endOfLine: \"lf\",",
                        "        }).formatted +",
                        "        \"}\"",
                        "    );",
                        "",
                        "    const tableBody = [{ hasLineBreak: false, cells: [] }];",
                        "    for (let i = 1; i < node.quasis.length; i++) {",
                        "      const row = getLast(tableBody);",
                        "      const correspondingExpression = stringifiedExpressions[i - 1];",
                        "",
                        "      row.cells.push(correspondingExpression);",
                        "      if (correspondingExpression.includes(\"\\n\")) {",
                        "        row.hasLineBreak = true;",
                        "      }",
                        "",
                        "      if (node.quasis[i].value.raw.includes(\"\\n\")) {",
                        "        tableBody.push({ hasLineBreak: false, cells: [] });",
                        "      }",
                        "    }",
                        "",
                        "    const maxColumnCount = Math.max(",
                        "      headerNames.length,",
                        "      ...tableBody.map((row) => row.cells.length)",
                        "    );",
                        "",
                        "    const maxColumnWidths = Array.from({ length: maxColumnCount }).fill(0);",
                        "    const table = [",
                        "      { cells: headerNames },",
                        "      ...tableBody.filter((row) => row.cells.length > 0),",
                        "    ];",
                        "    for (const { cells } of table.filter((row) => !row.hasLineBreak)) {",
                        "      for (const [index, cell] of cells.entries()) {",
                        "        maxColumnWidths[index] = Math.max(",
                        "          maxColumnWidths[index],",
                        "          getStringWidth(cell)",
                        "        );",
                        "      }",
                        "    }",
                        "",
                        "    parts.push(",
                        "      lineSuffixBoundary,",
                        "      \"`\",",
                        "      indent([",
                        "        hardline,",
                        "        join(",
                        "          hardline,",
                        "          table.map((row) =>",
                        "            join(",
                        "              \" | \",",
                        "              row.cells.map((cell, index) =>",
                        "                row.hasLineBreak",
                        "                  ? cell",
                        "                  : cell +",
                        "                    \" \".repeat(maxColumnWidths[index] - getStringWidth(cell))",
                        "              )",
                        "            )",
                        "          )",
                        "        ),",
                        "      ]),",
                        "      hardline,",
                        "      \"`\"",
                        "    );",
                        "    return parts;",
                        "  }",
                        "}",
                        "",
                        "function printTemplateExpression(path, print) {",
                        "  const node = path.getValue();",
                        "  let printed = print();",
                        "  if (hasComment(node)) {",
                        "    printed = group([indent([softline, printed]), softline]);",
                        "  }",
                        "  return [\"${\", printed, lineSuffixBoundary, \"}\"];",
                        "}",
                        "",
                        "function printTemplateExpressions(path, print) {",
                        "  return path.map(",
                        "    (path) => printTemplateExpression(path, print),",
                        "    \"expressions\"",
                        "  );",
                        "}",
                        "",
                        "function escapeTemplateCharacters(doc, raw) {",
                        "  return mapDoc(doc, (currentDoc) => {",
                        "    if (typeof currentDoc === \"string\") {",
                        "      return raw",
                        "        ? currentDoc.replace(/(\\\\*)`/g, \"$1$1\\\\`\")",
                        "        : uncookTemplateElementValue(currentDoc);",
                        "    }",
                        "",
                        "    return currentDoc;",
                        "  });",
                        "}",
                        "",
                        "function uncookTemplateElementValue(cookedValue) {",
                        "  return cookedValue.replace(/([\\\\`]|\\${)/g, \"\\\\$1\");",
                        "}",
                        "",
                        "module.exports = {",
                        "  printTemplateLiteral,",
                        "  printTemplateExpressions,",
                        "  escapeTemplateCharacters,",
                        "  uncookTemplateElementValue,",
                        "};"
                    ]
                },
                "ternary.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { hasNewlineInRange } = require(\"../../common/util.js\");",
                        "const {",
                        "  isJsxNode,",
                        "  getComments,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isTSTypeExpression,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const isBlockComment = require(\"../utils/is-block-comment.js\");",
                        "const {",
                        "  builders: {",
                        "    line,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    align,",
                        "    ifBreak,",
                        "    dedent,",
                        "    breakParent,",
                        "  },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path\")} AstPath",
                        " *",
                        " * @typedef {any} Options - Prettier options (TBD ...)",
                        " */",
                        "",
                        "// If we have nested conditional expressions, we want to print them in JSX mode",
                        "// if there's at least one JSXElement somewhere in the tree.",
                        "//",
                        "// A conditional expression chain like this should be printed in normal mode,",
                        "// because there aren't JSXElements anywhere in it:",
                        "//",
                        "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";",
                        "//",
                        "// But a conditional expression chain like this should be printed in JSX mode,",
                        "// because there is a JSXElement in the last ConditionalExpression:",
                        "//",
                        "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;",
                        "//",
                        "// This type of ConditionalExpression chain is structured like this in the AST:",
                        "//",
                        "// ConditionalExpression {",
                        "//   test: ...,",
                        "//   consequent: ...,",
                        "//   alternate: ConditionalExpression {",
                        "//     test: ...,",
                        "//     consequent: ...,",
                        "//     alternate: ConditionalExpression {",
                        "//       test: ...,",
                        "//       consequent: ...,",
                        "//       alternate: ...,",
                        "//     }",
                        "//   }",
                        "// }",
                        "function conditionalExpressionChainContainsJsx(node) {",
                        "  // Given this code:",
                        "  //",
                        "  // // Using a ConditionalExpression as the consequent is uncommon, but should",
                        "  // // be handled.",
                        "  // A ? B : C ? D : E ? F ? G : H : I",
                        "  //",
                        "  // which has this AST:",
                        "  //",
                        "  // ConditionalExpression {",
                        "  //   test: Identifier(A),",
                        "  //   consequent: Identifier(B),",
                        "  //   alternate: ConditionalExpression {",
                        "  //     test: Identifier(C),",
                        "  //     consequent: Identifier(D),",
                        "  //     alternate: ConditionalExpression {",
                        "  //       test: Identifier(E),",
                        "  //       consequent: ConditionalExpression {",
                        "  //         test: Identifier(F),",
                        "  //         consequent: Identifier(G),",
                        "  //         alternate: Identifier(H),",
                        "  //       },",
                        "  //       alternate: Identifier(I),",
                        "  //     }",
                        "  //   }",
                        "  // }",
                        "  //",
                        "  // We don't care about whether each node was the test, consequent, or alternate",
                        "  // We are only checking if there's any JSXElements inside.",
                        "  const conditionalExpressions = [node];",
                        "  for (let index = 0; index < conditionalExpressions.length; index++) {",
                        "    const conditionalExpression = conditionalExpressions[index];",
                        "    for (const property of [\"test\", \"consequent\", \"alternate\"]) {",
                        "      const node = conditionalExpression[property];",
                        "",
                        "      if (isJsxNode(node)) {",
                        "        return true;",
                        "      }",
                        "",
                        "      if (node.type === \"ConditionalExpression\") {",
                        "        conditionalExpressions.push(node);",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function printTernaryTest(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const isConditionalExpression = node.type === \"ConditionalExpression\";",
                        "  const alternateNodePropertyName = isConditionalExpression",
                        "    ? \"alternate\"",
                        "    : \"falseType\";",
                        "",
                        "  const parent = path.getParentNode();",
                        "",
                        "  const printed = isConditionalExpression",
                        "    ? print(\"test\")",
                        "    : [print(\"checkType\"), \" \", \"extends\", \" \", print(\"extendsType\")];",
                        "  /**",
                        "   *     a",
                        "   *       ? b",
                        "   *       : multiline",
                        "   *         test",
                        "   *         node",
                        "   *       ^^ align(2)",
                        "   *       ? d",
                        "   *       : e",
                        "   */",
                        "  if (parent.type === node.type && parent[alternateNodePropertyName] === node) {",
                        "    return align(2, printed);",
                        "  }",
                        "  return printed;",
                        "}",
                        "",
                        "const ancestorNameMap = new Map([",
                        "  [\"AssignmentExpression\", \"right\"],",
                        "  [\"VariableDeclarator\", \"init\"],",
                        "  [\"ReturnStatement\", \"argument\"],",
                        "  [\"ThrowStatement\", \"argument\"],",
                        "  [\"UnaryExpression\", \"argument\"],",
                        "  [\"YieldExpression\", \"argument\"],",
                        "]);",
                        "function shouldExtraIndentForConditionalExpression(path) {",
                        "  const node = path.getValue();",
                        "  if (node.type !== \"ConditionalExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  let parent;",
                        "  let child = node;",
                        "  for (let ancestorCount = 0; !parent; ancestorCount++) {",
                        "    const node = path.getParentNode(ancestorCount);",
                        "",
                        "    if (",
                        "      (isCallExpression(node) && node.callee === child) ||",
                        "      (isMemberExpression(node) && node.object === child) ||",
                        "      (node.type === \"TSNonNullExpression\" && node.expression === child)",
                        "    ) {",
                        "      child = node;",
                        "      continue;",
                        "    }",
                        "",
                        "    // Reached chain root",
                        "",
                        "    if (",
                        "      (node.type === \"NewExpression\" && node.callee === child) ||",
                        "      (isTSTypeExpression(node) && node.expression === child)",
                        "    ) {",
                        "      parent = path.getParentNode(ancestorCount + 1);",
                        "      child = node;",
                        "    } else {",
                        "      parent = node;",
                        "    }",
                        "  }",
                        "",
                        "  // Do not add indent to direct `ConditionalExpression`",
                        "  if (child === node) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return parent[ancestorNameMap.get(parent.type)] === child;",
                        "}",
                        "",
                        "/**",
                        " * The following is the shared logic for",
                        " * ternary operators, namely ConditionalExpression",
                        " * and TSConditionalType",
                        " * @param {AstPath} path - The path to the ConditionalExpression/TSConditionalType node.",
                        " * @param {Options} options - Prettier options",
                        " * @param {Function} print - Print function to call recursively",
                        " * @returns {Doc}",
                        " */",
                        "function printTernary(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const isConditionalExpression = node.type === \"ConditionalExpression\";",
                        "  const consequentNodePropertyName = isConditionalExpression",
                        "    ? \"consequent\"",
                        "    : \"trueType\";",
                        "  const alternateNodePropertyName = isConditionalExpression",
                        "    ? \"alternate\"",
                        "    : \"falseType\";",
                        "  const testNodePropertyNames = isConditionalExpression",
                        "    ? [\"test\"]",
                        "    : [\"checkType\", \"extendsType\"];",
                        "  const consequentNode = node[consequentNodePropertyName];",
                        "  const alternateNode = node[alternateNodePropertyName];",
                        "  const parts = [];",
                        "",
                        "  // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".",
                        "  // See `tests/format/jsx/conditional-expression.js` for more info.",
                        "  let jsxMode = false;",
                        "  const parent = path.getParentNode();",
                        "  const isParentTest =",
                        "    parent.type === node.type &&",
                        "    testNodePropertyNames.some((prop) => parent[prop] === node);",
                        "  let forceNoIndent = parent.type === node.type && !isParentTest;",
                        "",
                        "  // Find the outermost non-ConditionalExpression parent, and the outermost",
                        "  // ConditionalExpression parent. We'll use these to determine if we should",
                        "  // print in JSX mode.",
                        "  let currentParent;",
                        "  let previousParent;",
                        "  let i = 0;",
                        "  do {",
                        "    previousParent = currentParent || node;",
                        "    currentParent = path.getParentNode(i);",
                        "    i++;",
                        "  } while (",
                        "    currentParent &&",
                        "    currentParent.type === node.type &&",
                        "    testNodePropertyNames.every(",
                        "      (prop) => currentParent[prop] !== previousParent",
                        "    )",
                        "  );",
                        "  const firstNonConditionalParent = currentParent || parent;",
                        "  const lastConditionalParent = previousParent;",
                        "",
                        "  if (",
                        "    isConditionalExpression &&",
                        "    (isJsxNode(node[testNodePropertyNames[0]]) ||",
                        "      isJsxNode(consequentNode) ||",
                        "      isJsxNode(alternateNode) ||",
                        "      conditionalExpressionChainContainsJsx(lastConditionalParent))",
                        "  ) {",
                        "    jsxMode = true;",
                        "    forceNoIndent = true;",
                        "",
                        "    // Even though they don't need parens, we wrap (almost) everything in",
                        "    // parens when using ?: within JSX, because the parens are analogous to",
                        "    // curly braces in an if statement.",
                        "    const wrap = (doc) => [",
                        "      ifBreak(\"(\"),",
                        "      indent([softline, doc]),",
                        "      softline,",
                        "      ifBreak(\")\"),",
                        "    ];",
                        "",
                        "    // The only things we don't wrap are:",
                        "    // * Nested conditional expressions in alternates",
                        "    // * null",
                        "    // * undefined",
                        "    const isNil = (node) =>",
                        "      node.type === \"NullLiteral\" ||",
                        "      (node.type === \"Literal\" && node.value === null) ||",
                        "      (node.type === \"Identifier\" && node.name === \"undefined\");",
                        "",
                        "    parts.push(",
                        "      \" ? \",",
                        "      isNil(consequentNode)",
                        "        ? print(consequentNodePropertyName)",
                        "        : wrap(print(consequentNodePropertyName)),",
                        "      \" : \",",
                        "      alternateNode.type === node.type || isNil(alternateNode)",
                        "        ? print(alternateNodePropertyName)",
                        "        : wrap(print(alternateNodePropertyName))",
                        "    );",
                        "  } else {",
                        "    // normal mode",
                        "    const part = [",
                        "      line,",
                        "      \"? \",",
                        "      consequentNode.type === node.type ? ifBreak(\"\", \"(\") : \"\",",
                        "      align(2, print(consequentNodePropertyName)),",
                        "      consequentNode.type === node.type ? ifBreak(\"\", \")\") : \"\",",
                        "      line,",
                        "      \": \",",
                        "      alternateNode.type === node.type",
                        "        ? print(alternateNodePropertyName)",
                        "        : align(2, print(alternateNodePropertyName)),",
                        "    ];",
                        "    parts.push(",
                        "      parent.type !== node.type ||",
                        "        parent[alternateNodePropertyName] === node ||",
                        "        isParentTest",
                        "        ? part",
                        "        : options.useTabs",
                        "        ? dedent(indent(part))",
                        "        : align(Math.max(0, options.tabWidth - 2), part)",
                        "    );",
                        "  }",
                        "",
                        "  // We want a whole chain of ConditionalExpressions to all",
                        "  // break if any of them break. That means we should only group around the",
                        "  // outer-most ConditionalExpression.",
                        "  const comments = [",
                        "    ...testNodePropertyNames.map((propertyName) =>",
                        "      getComments(node[propertyName])",
                        "    ),",
                        "    getComments(consequentNode),",
                        "    getComments(alternateNode),",
                        "  ].flat();",
                        "  const shouldBreak = comments.some(",
                        "    (comment) =>",
                        "      isBlockComment(comment) &&",
                        "      hasNewlineInRange(",
                        "        options.originalText,",
                        "        locStart(comment),",
                        "        locEnd(comment)",
                        "      )",
                        "  );",
                        "  const maybeGroup = (doc) =>",
                        "    parent === firstNonConditionalParent",
                        "      ? group(doc, { shouldBreak })",
                        "      : shouldBreak",
                        "      ? [doc, breakParent]",
                        "      : doc;",
                        "",
                        "  // Break the closing paren to keep the chain right after it:",
                        "  // (a",
                        "  //   ? b",
                        "  //   : c",
                        "  // ).call()",
                        "  const breakClosingParen =",
                        "    !jsxMode &&",
                        "    (isMemberExpression(parent) ||",
                        "      (parent.type === \"NGPipeExpression\" && parent.left === node)) &&",
                        "    !parent.computed;",
                        "",
                        "  const shouldExtraIndent = shouldExtraIndentForConditionalExpression(path);",
                        "",
                        "  const result = maybeGroup([",
                        "    printTernaryTest(path, options, print),",
                        "    forceNoIndent ? parts : indent(parts),",
                        "    isConditionalExpression && breakClosingParen && !shouldExtraIndent",
                        "      ? softline",
                        "      : \"\",",
                        "  ]);",
                        "",
                        "  return isParentTest || shouldExtraIndent",
                        "    ? group([indent([softline, result]), softline])",
                        "    : result;",
                        "}",
                        "",
                        "module.exports = { printTernary };"
                    ]
                },
                "type-annotation.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "} = require(\"../../main/comments.js\");",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { group, join, line, softline, indent, align, ifBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const { locStart } = require(\"../loc.js\");",
                        "const {",
                        "  isSimpleType,",
                        "  isObjectType,",
                        "  hasLeadingOwnLineComment,",
                        "  isObjectTypePropertyAFunction,",
                        "  shouldPrintComma,",
                        "} = require(\"../utils/index.js\");",
                        "const { printAssignment } = require(\"./assignment.js\");",
                        "const {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} = require(\"./function-parameters.js\");",
                        "const { printArrayItems } = require(\"./array.js\");",
                        "",
                        "function shouldHugType(node) {",
                        "  if (isSimpleType(node) || isObjectType(node)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {",
                        "    const voidCount = node.types.filter(",
                        "      (node) =>",
                        "        node.type === \"VoidTypeAnnotation\" ||",
                        "        node.type === \"TSVoidKeyword\" ||",
                        "        node.type === \"NullLiteralTypeAnnotation\" ||",
                        "        node.type === \"TSNullKeyword\"",
                        "    ).length;",
                        "",
                        "    const hasObject = node.types.some(",
                        "      (node) =>",
                        "        node.type === \"ObjectTypeAnnotation\" ||",
                        "        node.type === \"TSTypeLiteral\" ||",
                        "        // This is a bit aggressive but captures Array<{x}>",
                        "        node.type === \"GenericTypeAnnotation\" ||",
                        "        node.type === \"TSTypeReference\"",
                        "    );",
                        "",
                        "    if (node.types.length - 1 === voidCount && hasObject) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function printOpaqueType(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  parts.push(\"opaque type \", print(\"id\"), print(\"typeParameters\"));",
                        "",
                        "  if (node.supertype) {",
                        "    parts.push(\": \", print(\"supertype\"));",
                        "  }",
                        "",
                        "  if (node.impltype) {",
                        "    parts.push(\" = \", print(\"impltype\"));",
                        "  }",
                        "",
                        "  parts.push(semi);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printTypeAlias(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "  parts.push(\"type \", print(\"id\"), print(\"typeParameters\"));",
                        "  const rightPropertyName =",
                        "    node.type === \"TSTypeAliasDeclaration\" ? \"typeAnnotation\" : \"right\";",
                        "  return [",
                        "    printAssignment(path, options, print, parts, \" =\", rightPropertyName),",
                        "    semi,",
                        "  ];",
                        "}",
                        "",
                        "// `TSIntersectionType` and `IntersectionTypeAnnotation`",
                        "function printIntersectionType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const types = path.map(print, \"types\");",
                        "  const result = [];",
                        "  let wasIndented = false;",
                        "  for (let i = 0; i < types.length; ++i) {",
                        "    if (i === 0) {",
                        "      result.push(types[i]);",
                        "    } else if (isObjectType(node.types[i - 1]) && isObjectType(node.types[i])) {",
                        "      // If both are objects, don't indent",
                        "      result.push([\" & \", wasIndented ? indent(types[i]) : types[i]]);",
                        "    } else if (",
                        "      !isObjectType(node.types[i - 1]) &&",
                        "      !isObjectType(node.types[i])",
                        "    ) {",
                        "      // If no object is involved, go to the next line if it breaks",
                        "      result.push(indent([\" &\", line, types[i]]));",
                        "    } else {",
                        "      // If you go from object to non-object or vis-versa, then inline it",
                        "      if (i > 1) {",
                        "        wasIndented = true;",
                        "      }",
                        "      result.push(\" & \", i > 1 ? indent(types[i]) : types[i]);",
                        "    }",
                        "  }",
                        "  return group(result);",
                        "}",
                        "",
                        "// `TSUnionType` and `UnionTypeAnnotation`",
                        "function printUnionType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  // single-line variation",
                        "  // A | B | C",
                        "",
                        "  // multi-line variation",
                        "  // | A",
                        "  // | B",
                        "  // | C",
                        "",
                        "  const parent = path.getParentNode();",
                        "",
                        "  // If there's a leading comment, the parent is doing the indentation",
                        "  const shouldIndent =",
                        "    parent.type !== \"TypeParameterInstantiation\" &&",
                        "    parent.type !== \"TSTypeParameterInstantiation\" &&",
                        "    parent.type !== \"GenericTypeAnnotation\" &&",
                        "    parent.type !== \"TSTypeReference\" &&",
                        "    parent.type !== \"TSTypeAssertion\" &&",
                        "    parent.type !== \"TupleTypeAnnotation\" &&",
                        "    parent.type !== \"TSTupleType\" &&",
                        "    !(",
                        "      parent.type === \"FunctionTypeParam\" &&",
                        "      !parent.name &&",
                        "      path.getParentNode(1).this !== parent",
                        "    ) &&",
                        "    !(",
                        "      (parent.type === \"TypeAlias\" ||",
                        "        parent.type === \"VariableDeclarator\" ||",
                        "        parent.type === \"TSTypeAliasDeclaration\") &&",
                        "      hasLeadingOwnLineComment(options.originalText, node)",
                        "    );",
                        "",
                        "  // {",
                        "  //   a: string",
                        "  // } | null | void",
                        "  // should be inlined and not be printed in the multi-line variant",
                        "  const shouldHug = shouldHugType(node);",
                        "",
                        "  // We want to align the children but without its comment, so it looks like",
                        "  // | child1",
                        "  // // comment",
                        "  // | child2",
                        "  const printed = path.map((typePath) => {",
                        "    let printedType = print();",
                        "    if (!shouldHug) {",
                        "      printedType = align(2, printedType);",
                        "    }",
                        "    return printComments(typePath, printedType, options);",
                        "  }, \"types\");",
                        "",
                        "  if (shouldHug) {",
                        "    return join(\" | \", printed);",
                        "  }",
                        "",
                        "  const shouldAddStartLine =",
                        "    shouldIndent && !hasLeadingOwnLineComment(options.originalText, node);",
                        "",
                        "  const code = [",
                        "    ifBreak([shouldAddStartLine ? line : \"\", \"| \"]),",
                        "    join([line, \"| \"], printed),",
                        "  ];",
                        "",
                        "  if (pathNeedsParens(path, options)) {",
                        "    return group([indent(code), softline]);",
                        "  }",
                        "",
                        "  if (",
                        "    (parent.type === \"TupleTypeAnnotation\" && parent.types.length > 1) ||",
                        "    (parent.type === \"TSTupleType\" && parent.elementTypes.length > 1)",
                        "  ) {",
                        "    return group([",
                        "      indent([ifBreak([\"(\", softline]), code]),",
                        "      softline,",
                        "      ifBreak(\")\"),",
                        "    ]);",
                        "  }",
                        "",
                        "  return group(shouldIndent ? indent(code) : code);",
                        "}",
                        "",
                        "// `TSFunctionType` and `FunctionTypeAnnotation`",
                        "function printFunctionType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  // FunctionTypeAnnotation is ambiguous:",
                        "  // declare function foo(a: B): void; OR",
                        "  // var A: (a: B) => void;",
                        "  const parent = path.getParentNode(0);",
                        "  const parentParent = path.getParentNode(1);",
                        "  const parentParentParent = path.getParentNode(2);",
                        "  let isArrowFunctionTypeAnnotation =",
                        "    node.type === \"TSFunctionType\" ||",
                        "    !(",
                        "      ((parent.type === \"ObjectTypeProperty\" ||",
                        "        parent.type === \"ObjectTypeInternalSlot\") &&",
                        "        !parent.variance &&",
                        "        !parent.optional &&",
                        "        locStart(parent) === locStart(node)) ||",
                        "      parent.type === \"ObjectTypeCallProperty\" ||",
                        "      (parentParentParent && parentParentParent.type === \"DeclareFunction\")",
                        "    );",
                        "",
                        "  let needsColon =",
                        "    isArrowFunctionTypeAnnotation &&",
                        "    (parent.type === \"TypeAnnotation\" || parent.type === \"TSTypeAnnotation\");",
                        "",
                        "  // Sadly we can't put it inside of AstPath::needsColon because we are",
                        "  // printing \":\" as part of the expression and it would put parenthesis",
                        "  // around :(",
                        "  const needsParens =",
                        "    needsColon &&",
                        "    isArrowFunctionTypeAnnotation &&",
                        "    (parent.type === \"TypeAnnotation\" || parent.type === \"TSTypeAnnotation\") &&",
                        "    parentParent.type === \"ArrowFunctionExpression\";",
                        "",
                        "  if (isObjectTypePropertyAFunction(parent)) {",
                        "    isArrowFunctionTypeAnnotation = true;",
                        "    needsColon = true;",
                        "  }",
                        "",
                        "  if (needsParens) {",
                        "    parts.push(\"(\");",
                        "  }",
                        "",
                        "  const parametersDoc = printFunctionParameters(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    /* expandArg */ false,",
                        "    /* printTypeParams */ true",
                        "  );",
                        "",
                        "  // The returnType is not wrapped in a TypeAnnotation, so the colon",
                        "  // needs to be added separately.",
                        "  const returnTypeDoc =",
                        "    node.returnType || node.predicate || node.typeAnnotation",
                        "      ? [",
                        "          isArrowFunctionTypeAnnotation ? \" => \" : \": \",",
                        "          print(\"returnType\"),",
                        "          print(\"predicate\"),",
                        "          print(\"typeAnnotation\"),",
                        "        ]",
                        "      : \"\";",
                        "",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "",
                        "  parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);",
                        "",
                        "  if (returnTypeDoc) {",
                        "    parts.push(returnTypeDoc);",
                        "  }",
                        "",
                        "  if (needsParens) {",
                        "    parts.push(\")\");",
                        "  }",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "// `TSTupleType` and `TupleTypeAnnotation`",
                        "function printTupleType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const typesField = node.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";",
                        "  const types = node[typesField];",
                        "  const isNonEmptyTuple = isNonEmptyArray(types);",
                        "  const bracketsDelimiterLine = isNonEmptyTuple ? softline : \"\";",
                        "  return group([",
                        "    \"[\",",
                        "    indent([",
                        "      bracketsDelimiterLine,",
                        "      printArrayItems(path, options, typesField, print),",
                        "    ]),",
                        "    ifBreak(isNonEmptyTuple && shouldPrintComma(options, \"all\") ? \",\" : \"\"),",
                        "    printDanglingComments(path, options, /* sameIndent */ true),",
                        "    bracketsDelimiterLine,",
                        "    \"]\",",
                        "  ]);",
                        "}",
                        "",
                        "// `TSIndexedAccessType`, `IndexedAccessType`, and `OptionalIndexedAccessType`",
                        "function printIndexedAccessType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const leftDelimiter =",
                        "    node.type === \"OptionalIndexedAccessType\" && node.optional ? \"?.[\" : \"[\";",
                        "  return [print(\"objectType\"), leftDelimiter, print(\"indexType\"), \"]\"];",
                        "}",
                        "",
                        "// `TSJSDocNullableType`, `TSJSDocNonNullableType`",
                        "function printJSDocType(path, print, token) {",
                        "  const node = path.getValue();",
                        "  return [",
                        "    node.postfix ? \"\" : token,",
                        "    print(\"typeAnnotation\"),",
                        "    node.postfix ? token : \"\",",
                        "  ];",
                        "}",
                        "",
                        "module.exports = {",
                        "  printOpaqueType,",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printTupleType,",
                        "  printIndexedAccessType,",
                        "  shouldHugType,",
                        "  printJSDocType,",
                        "};"
                    ]
                },
                "type-parameters.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { join, line, hardline, softline, group, indent, ifBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  isTestCall,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isTSXFile,",
                        "  shouldPrintComma,",
                        "  getFunctionParameters,",
                        "  isObjectType,",
                        "} = require(\"../utils/index.js\");",
                        "const { createGroupIdMapper } = require(\"../../common/util.js\");",
                        "const { shouldHugType } = require(\"./type-annotation.js\");",
                        "const { isArrowFunctionVariableDeclarator } = require(\"./assignment.js\");",
                        "",
                        "const getTypeParametersGroupId = createGroupIdMapper(\"typeParameters\");",
                        "",
                        "function printTypeParameters(path, options, print, paramsKey) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (!node[paramsKey]) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // for TypeParameterDeclaration typeParameters is a single node",
                        "  if (!Array.isArray(node[paramsKey])) {",
                        "    return print(paramsKey);",
                        "  }",
                        "",
                        "  const grandparent = path.getNode(2);",
                        "  const isParameterInTestCall = grandparent && isTestCall(grandparent);",
                        "",
                        "  const isArrowFunctionVariable = path.match(",
                        "    (node) =>",
                        "      !(node[paramsKey].length === 1 && isObjectType(node[paramsKey][0])),",
                        "    undefined,",
                        "    (node, name) => name === \"typeAnnotation\",",
                        "    (node) => node.type === \"Identifier\",",
                        "    isArrowFunctionVariableDeclarator",
                        "  );",
                        "",
                        "  const shouldInline =",
                        "    node[paramsKey].length === 0 ||",
                        "    (!isArrowFunctionVariable &&",
                        "      (isParameterInTestCall ||",
                        "        (node[paramsKey].length === 1 &&",
                        "          (node[paramsKey][0].type === \"NullableTypeAnnotation\" ||",
                        "            shouldHugType(node[paramsKey][0])))));",
                        "",
                        "  if (shouldInline) {",
                        "    return [",
                        "      \"<\",",
                        "      join(\", \", path.map(print, paramsKey)),",
                        "      printDanglingCommentsForInline(path, options),",
                        "      \">\",",
                        "    ];",
                        "  }",
                        "",
                        "  // Keep comma if the file extension is .tsx and",
                        "  // has one type parameter that isn't extend with any types.",
                        "  // Because, otherwise formatted result will be invalid as tsx.",
                        "  const trailingComma =",
                        "    node.type === \"TSTypeParameterInstantiation\" // https://github.com/microsoft/TypeScript/issues/21984",
                        "      ? \"\"",
                        "      : getFunctionParameters(node).length === 1 &&",
                        "        isTSXFile(options) &&",
                        "        !node[paramsKey][0].constraint &&",
                        "        path.getParentNode().type === \"ArrowFunctionExpression\"",
                        "      ? \",\"",
                        "      : shouldPrintComma(options, \"all\")",
                        "      ? ifBreak(\",\")",
                        "      : \"\";",
                        "",
                        "  return group(",
                        "    [",
                        "      \"<\",",
                        "      indent([softline, join([\",\", line], path.map(print, paramsKey))]),",
                        "      trailingComma,",
                        "      softline,",
                        "      \">\",",
                        "    ],",
                        "    { id: getTypeParametersGroupId(node) }",
                        "  );",
                        "}",
                        "",
                        "function printDanglingCommentsForInline(path, options) {",
                        "  const node = path.getValue();",
                        "  if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    return \"\";",
                        "  }",
                        "  const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);",
                        "  const printed = printDanglingComments(",
                        "    path,",
                        "    options,",
                        "    /* sameIndent */ hasOnlyBlockComments",
                        "  );",
                        "  if (hasOnlyBlockComments) {",
                        "    return printed;",
                        "  }",
                        "  return [printed, hardline];",
                        "}",
                        "",
                        "function printTypeParameter(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  const parent = path.getParentNode();",
                        "  if (parent.type === \"TSMappedType\") {",
                        "    parts.push(\"[\", print(\"name\"));",
                        "    if (node.constraint) {",
                        "      parts.push(\" in \", print(\"constraint\"));",
                        "    }",
                        "    if (parent.nameType) {",
                        "      parts.push(",
                        "        \" as \",",
                        "        path.callParent(() => print(\"nameType\"))",
                        "      );",
                        "    }",
                        "    parts.push(\"]\");",
                        "    return parts;",
                        "  }",
                        "",
                        "  if (node.variance) {",
                        "    parts.push(print(\"variance\"));",
                        "  }",
                        "",
                        "  if (node.in) {",
                        "    parts.push(\"in \");",
                        "  }",
                        "",
                        "  if (node.out) {",
                        "    parts.push(\"out \");",
                        "  }",
                        "",
                        "  parts.push(print(\"name\"));",
                        "",
                        "  if (node.bound) {",
                        "    parts.push(\": \", print(\"bound\"));",
                        "  }",
                        "",
                        "  if (node.constraint) {",
                        "    parts.push(\" extends \", print(\"constraint\"));",
                        "  }",
                        "",
                        "  if (node.default) {",
                        "    parts.push(\" = \", print(\"default\"));",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printTypeParameter,",
                        "  printTypeParameters,",
                        "  getTypeParametersGroupId,",
                        "};"
                    ]
                },
                "typescript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const { hasNewlineInRange } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: {",
                        "    join,",
                        "    line,",
                        "    hardline,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    ifBreak,",
                        "  },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  isStringLiteral,",
                        "  getTypeScriptMappedTypeModifier,",
                        "  shouldPrintComma,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "} = require(\"../utils/index.js\");",
                        "const isTsKeywordType = require(\"../utils/is-ts-keyword-type.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "",
                        "const { printOptionalToken, printTypeScriptModifiers } = require(\"./misc.js\");",
                        "const { printTernary } = require(\"./ternary.js\");",
                        "const {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} = require(\"./function-parameters.js\");",
                        "const { printTemplateLiteral } = require(\"./template-literal.js\");",
                        "const { printArrayItems } = require(\"./array.js\");",
                        "const { printObject } = require(\"./object.js\");",
                        "const { printClassProperty, printClassMethod } = require(\"./class.js\");",
                        "const {",
                        "  printTypeParameter,",
                        "  printTypeParameters,",
                        "} = require(\"./type-parameters.js\");",
                        "const { printPropertyKey } = require(\"./property.js\");",
                        "const { printFunction, printMethodInternal } = require(\"./function.js\");",
                        "const { printInterface } = require(\"./interface.js\");",
                        "const { printBlock } = require(\"./block.js\");",
                        "const {",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printTupleType,",
                        "  printIndexedAccessType,",
                        "  printJSDocType,",
                        "} = require(\"./type-annotation.js\");",
                        "",
                        "function printTypescript(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  // TypeScript nodes always starts with `TS`",
                        "  if (!node.type.startsWith(\"TS\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (isTsKeywordType(node)) {",
                        "    return node.type.slice(2, -7).toLowerCase();",
                        "  }",
                        "",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const parts = [];",
                        "",
                        "  switch (node.type) {",
                        "    case \"TSThisType\":",
                        "      return \"this\";",
                        "    case \"TSTypeAssertion\": {",
                        "      const shouldBreakAfterCast = !(",
                        "        node.expression.type === \"ArrayExpression\" ||",
                        "        node.expression.type === \"ObjectExpression\"",
                        "      );",
                        "",
                        "      const castGroup = group([",
                        "        \"<\",",
                        "        indent([softline, print(\"typeAnnotation\")]),",
                        "        softline,",
                        "        \">\",",
                        "      ]);",
                        "",
                        "      const exprContents = [",
                        "        ifBreak(\"(\"),",
                        "        indent([softline, print(\"expression\")]),",
                        "        softline,",
                        "        ifBreak(\")\"),",
                        "      ];",
                        "",
                        "      if (shouldBreakAfterCast) {",
                        "        return conditionalGroup([",
                        "          [castGroup, print(\"expression\")],",
                        "          [castGroup, group(exprContents, { shouldBreak: true })],",
                        "          [castGroup, print(\"expression\")],",
                        "        ]);",
                        "      }",
                        "      return group([castGroup, print(\"expression\")]);",
                        "    }",
                        "    case \"TSDeclareFunction\":",
                        "      return printFunction(path, print, options);",
                        "    case \"TSExportAssignment\":",
                        "      return [\"export = \", print(\"expression\"), semi];",
                        "    case \"TSModuleBlock\":",
                        "      return printBlock(path, options, print);",
                        "    case \"TSInterfaceBody\":",
                        "    case \"TSTypeLiteral\":",
                        "      return printObject(path, options, print);",
                        "    case \"TSTypeAliasDeclaration\":",
                        "      return printTypeAlias(path, options, print);",
                        "    case \"TSQualifiedName\":",
                        "      return join(\".\", [print(\"left\"), print(\"right\")]);",
                        "    case \"TSAbstractMethodDefinition\":",
                        "    case \"TSDeclareMethod\":",
                        "      return printClassMethod(path, options, print);",
                        "    case \"TSAbstractAccessorProperty\":",
                        "    case \"TSAbstractPropertyDefinition\":",
                        "      return printClassProperty(path, options, print);",
                        "    case \"TSInterfaceHeritage\":",
                        "    case \"TSExpressionWithTypeArguments\": // Babel AST",
                        "      parts.push(print(\"expression\"));",
                        "",
                        "      if (node.typeParameters) {",
                        "        parts.push(print(\"typeParameters\"));",
                        "      }",
                        "",
                        "      return parts;",
                        "    case \"TSTemplateLiteralType\":",
                        "      return printTemplateLiteral(path, print, options);",
                        "    case \"TSNamedTupleMember\":",
                        "      return [",
                        "        print(\"label\"),",
                        "        node.optional ? \"?\" : \"\",",
                        "        \": \",",
                        "        print(\"elementType\"),",
                        "      ];",
                        "    case \"TSRestType\":",
                        "      return [\"...\", print(\"typeAnnotation\")];",
                        "    case \"TSOptionalType\":",
                        "      return [print(\"typeAnnotation\"), \"?\"];",
                        "    case \"TSInterfaceDeclaration\":",
                        "      return printInterface(path, options, print);",
                        "    case \"TSClassImplements\":",
                        "      return [print(\"expression\"), print(\"typeParameters\")];",
                        "    case \"TSTypeParameterDeclaration\":",
                        "    case \"TSTypeParameterInstantiation\":",
                        "      return printTypeParameters(path, options, print, \"params\");",
                        "    case \"TSTypeParameter\":",
                        "      return printTypeParameter(path, options, print);",
                        "    case \"TSSatisfiesExpression\":",
                        "    case \"TSAsExpression\": {",
                        "      const operator = node.type === \"TSAsExpression\" ? \"as\" : \"satisfies\";",
                        "      parts.push(print(\"expression\"), ` ${operator} `, print(\"typeAnnotation\"));",
                        "      const parent = path.getParentNode();",
                        "      if (",
                        "        (isCallExpression(parent) && parent.callee === node) ||",
                        "        (isMemberExpression(parent) && parent.object === node)",
                        "      ) {",
                        "        return group([indent([softline, ...parts]), softline]);",
                        "      }",
                        "      return parts;",
                        "    }",
                        "    case \"TSArrayType\":",
                        "      return [print(\"elementType\"), \"[]\"];",
                        "    case \"TSPropertySignature\": {",
                        "      if (node.readonly) {",
                        "        parts.push(\"readonly \");",
                        "      }",
                        "",
                        "      parts.push(",
                        "        printPropertyKey(path, options, print),",
                        "        printOptionalToken(path)",
                        "      );",
                        "",
                        "      if (node.typeAnnotation) {",
                        "        parts.push(\": \", print(\"typeAnnotation\"));",
                        "      }",
                        "",
                        "      // This isn't valid semantically, but it's in the AST so we can print it.",
                        "      if (node.initializer) {",
                        "        parts.push(\" = \", print(\"initializer\"));",
                        "      }",
                        "",
                        "      return parts;",
                        "    }",
                        "    case \"TSParameterProperty\":",
                        "      if (node.accessibility) {",
                        "        parts.push(node.accessibility + \" \");",
                        "      }",
                        "      if (node.export) {",
                        "        parts.push(\"export \");",
                        "      }",
                        "      if (node.static) {",
                        "        parts.push(\"static \");",
                        "      }",
                        "      if (node.override) {",
                        "        parts.push(\"override \");",
                        "      }",
                        "      if (node.readonly) {",
                        "        parts.push(\"readonly \");",
                        "      }",
                        "",
                        "      parts.push(print(\"parameter\"));",
                        "",
                        "      return parts;",
                        "    case \"TSTypeQuery\":",
                        "      return [\"typeof \", print(\"exprName\"), print(\"typeParameters\")];",
                        "    case \"TSIndexSignature\": {",
                        "      const parent = path.getParentNode();",
                        "",
                        "      // The typescript parser accepts multiple parameters here. If you're",
                        "      // using them, it makes sense to have a trailing comma. But if you",
                        "      // aren't, this is more like a computed property name than an array.",
                        "      // So we leave off the trailing comma when there's just one parameter.",
                        "      const trailingComma =",
                        "        node.parameters.length > 1",
                        "          ? ifBreak(shouldPrintComma(options) ? \",\" : \"\")",
                        "          : \"\";",
                        "",
                        "      const parametersGroup = group([",
                        "        indent([",
                        "          softline,",
                        "          join([\", \", softline], path.map(print, \"parameters\")),",
                        "        ]),",
                        "        trailingComma,",
                        "        softline,",
                        "      ]);",
                        "",
                        "      return [",
                        "        node.export ? \"export \" : \"\",",
                        "        node.accessibility ? [node.accessibility, \" \"] : \"\",",
                        "        node.static ? \"static \" : \"\",",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        node.declare ? \"declare \" : \"\",",
                        "        \"[\",",
                        "        node.parameters ? parametersGroup : \"\",",
                        "        node.typeAnnotation ? \"]: \" : \"]\",",
                        "        node.typeAnnotation ? print(\"typeAnnotation\") : \"\",",
                        "        parent.type === \"ClassBody\" ? semi : \"\",",
                        "      ];",
                        "    }",
                        "    case \"TSTypePredicate\":",
                        "      return [",
                        "        node.asserts ? \"asserts \" : \"\",",
                        "        print(\"parameterName\"),",
                        "        node.typeAnnotation ? [\" is \", print(\"typeAnnotation\")] : \"\",",
                        "      ];",
                        "    case \"TSNonNullExpression\":",
                        "      return [print(\"expression\"), \"!\"];",
                        "    case \"TSImportType\":",
                        "      return [",
                        "        !node.isTypeOf ? \"\" : \"typeof \",",
                        "        \"import(\",",
                        "        print(node.parameter ? \"parameter\" : \"argument\"),",
                        "        \")\",",
                        "        !node.qualifier ? \"\" : [\".\", print(\"qualifier\")],",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"TSLiteralType\":",
                        "      return print(\"literal\");",
                        "    case \"TSIndexedAccessType\":",
                        "      return printIndexedAccessType(path, options, print);",
                        "    case \"TSConstructSignatureDeclaration\":",
                        "    case \"TSCallSignatureDeclaration\":",
                        "    case \"TSConstructorType\": {",
                        "      if (node.type === \"TSConstructorType\" && node.abstract) {",
                        "        parts.push(\"abstract \");",
                        "      }",
                        "      if (node.type !== \"TSCallSignatureDeclaration\") {",
                        "        parts.push(\"new \");",
                        "      }",
                        "",
                        "      parts.push(",
                        "        group(",
                        "          printFunctionParameters(",
                        "            path,",
                        "            print,",
                        "            options,",
                        "            /* expandArg */ false,",
                        "            /* printTypeParams */ true",
                        "          )",
                        "        )",
                        "      );",
                        "",
                        "      if (node.returnType || node.typeAnnotation) {",
                        "        const isType = node.type === \"TSConstructorType\";",
                        "        parts.push(",
                        "          isType ? \" => \" : \": \",",
                        "          print(\"returnType\"),",
                        "          print(\"typeAnnotation\")",
                        "        );",
                        "      }",
                        "      return parts;",
                        "    }",
                        "    case \"TSTypeOperator\":",
                        "      return [node.operator, \" \", print(\"typeAnnotation\")];",
                        "    case \"TSMappedType\": {",
                        "      const shouldBreak = hasNewlineInRange(",
                        "        options.originalText,",
                        "        locStart(node),",
                        "        locEnd(node)",
                        "      );",
                        "      return group(",
                        "        [",
                        "          \"{\",",
                        "          indent([",
                        "            options.bracketSpacing ? line : softline,",
                        "            node.readonly",
                        "              ? [",
                        "                  getTypeScriptMappedTypeModifier(node.readonly, \"readonly\"),",
                        "                  \" \",",
                        "                ]",
                        "              : \"\",",
                        "            printTypeScriptModifiers(path, options, print),",
                        "            print(\"typeParameter\"),",
                        "            node.optional",
                        "              ? getTypeScriptMappedTypeModifier(node.optional, \"?\")",
                        "              : \"\",",
                        "            node.typeAnnotation ? \": \" : \"\",",
                        "            print(\"typeAnnotation\"),",
                        "            ifBreak(semi),",
                        "          ]),",
                        "          printDanglingComments(path, options, /* sameIndent */ true),",
                        "          options.bracketSpacing ? line : softline,",
                        "          \"}\",",
                        "        ],",
                        "        { shouldBreak }",
                        "      );",
                        "    }",
                        "    case \"TSMethodSignature\": {",
                        "      const kind = node.kind && node.kind !== \"method\" ? `${node.kind} ` : \"\";",
                        "      parts.push(",
                        "        node.accessibility ? [node.accessibility, \" \"] : \"\",",
                        "        kind,",
                        "        node.export ? \"export \" : \"\",",
                        "        node.static ? \"static \" : \"\",",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        // \"abstract\" and \"declare\" are supported by only \"babel-ts\"",
                        "        // https://github.com/prettier/prettier/issues/9760",
                        "        node.abstract ? \"abstract \" : \"\",",
                        "        node.declare ? \"declare \" : \"\",",
                        "        node.computed ? \"[\" : \"\",",
                        "        print(\"key\"),",
                        "        node.computed ? \"]\" : \"\",",
                        "        printOptionalToken(path)",
                        "      );",
                        "",
                        "      const parametersDoc = printFunctionParameters(",
                        "        path,",
                        "        print,",
                        "        options,",
                        "        /* expandArg */ false,",
                        "        /* printTypeParams */ true",
                        "      );",
                        "",
                        "      const returnTypePropertyName = node.returnType",
                        "        ? \"returnType\"",
                        "        : \"typeAnnotation\";",
                        "      const returnTypeNode = node[returnTypePropertyName];",
                        "      const returnTypeDoc = returnTypeNode ? print(returnTypePropertyName) : \"\";",
                        "      const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "        node,",
                        "        returnTypeDoc",
                        "      );",
                        "",
                        "      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);",
                        "",
                        "      if (returnTypeNode) {",
                        "        parts.push(\": \", group(returnTypeDoc));",
                        "      }",
                        "",
                        "      return group(parts);",
                        "    }",
                        "    case \"TSNamespaceExportDeclaration\":",
                        "      parts.push(\"export as namespace \", print(\"id\"));",
                        "",
                        "      if (options.semi) {",
                        "        parts.push(\";\");",
                        "      }",
                        "",
                        "      return group(parts);",
                        "    case \"TSEnumDeclaration\":",
                        "      if (node.declare) {",
                        "        parts.push(\"declare \");",
                        "      }",
                        "",
                        "      if (node.modifiers) {",
                        "        parts.push(printTypeScriptModifiers(path, options, print));",
                        "      }",
                        "      if (node.const) {",
                        "        parts.push(\"const \");",
                        "      }",
                        "",
                        "      parts.push(\"enum \", print(\"id\"), \" \");",
                        "",
                        "      if (node.members.length === 0) {",
                        "        parts.push(",
                        "          group([\"{\", printDanglingComments(path, options), softline, \"}\"])",
                        "        );",
                        "      } else {",
                        "        parts.push(",
                        "          group([",
                        "            \"{\",",
                        "            indent([",
                        "              hardline,",
                        "              printArrayItems(path, options, \"members\", print),",
                        "              shouldPrintComma(options, \"es5\") ? \",\" : \"\",",
                        "            ]),",
                        "            printDanglingComments(path, options, /* sameIndent */ true),",
                        "            hardline,",
                        "            \"}\",",
                        "          ])",
                        "        );",
                        "      }",
                        "",
                        "      return parts;",
                        "    case \"TSEnumMember\":",
                        "      if (node.computed) {",
                        "        parts.push(\"[\", print(\"id\"), \"]\");",
                        "      } else {",
                        "        parts.push(print(\"id\"));",
                        "      }",
                        "",
                        "      if (node.initializer) {",
                        "        parts.push(\" = \", print(\"initializer\"));",
                        "      }",
                        "      return parts;",
                        "    case \"TSImportEqualsDeclaration\":",
                        "      if (node.isExport) {",
                        "        parts.push(\"export \");",
                        "      }",
                        "",
                        "      parts.push(\"import \");",
                        "",
                        "      if (node.importKind && node.importKind !== \"value\") {",
                        "        parts.push(node.importKind, \" \");",
                        "      }",
                        "",
                        "      parts.push(print(\"id\"), \" = \", print(\"moduleReference\"));",
                        "",
                        "      if (options.semi) {",
                        "        parts.push(\";\");",
                        "      }",
                        "",
                        "      return group(parts);",
                        "    case \"TSExternalModuleReference\":",
                        "      return [\"require(\", print(\"expression\"), \")\"];",
                        "    case \"TSModuleDeclaration\": {",
                        "      const parent = path.getParentNode();",
                        "      const isExternalModule = isStringLiteral(node.id);",
                        "      const parentIsDeclaration = parent.type === \"TSModuleDeclaration\";",
                        "      const bodyIsDeclaration =",
                        "        node.body && node.body.type === \"TSModuleDeclaration\";",
                        "",
                        "      if (parentIsDeclaration) {",
                        "        parts.push(\".\");",
                        "      } else {",
                        "        if (node.declare) {",
                        "          parts.push(\"declare \");",
                        "        }",
                        "        parts.push(printTypeScriptModifiers(path, options, print));",
                        "",
                        "        const textBetweenNodeAndItsId = options.originalText.slice(",
                        "          locStart(node),",
                        "          locStart(node.id)",
                        "        );",
                        "",
                        "        // Global declaration looks like this:",
                        "        // (declare)? global { ... }",
                        "        const isGlobalDeclaration =",
                        "          node.id.type === \"Identifier\" &&",
                        "          node.id.name === \"global\" &&",
                        "          !/namespace|module/.test(textBetweenNodeAndItsId);",
                        "",
                        "        if (!isGlobalDeclaration) {",
                        "          parts.push(",
                        "            isExternalModule ||",
                        "              /(?:^|\\s)module(?:\\s|$)/.test(textBetweenNodeAndItsId)",
                        "              ? \"module \"",
                        "              : \"namespace \"",
                        "          );",
                        "        }",
                        "      }",
                        "",
                        "      parts.push(print(\"id\"));",
                        "",
                        "      if (bodyIsDeclaration) {",
                        "        parts.push(print(\"body\"));",
                        "      } else if (node.body) {",
                        "        parts.push(\" \", group(print(\"body\")));",
                        "      } else {",
                        "        parts.push(semi);",
                        "      }",
                        "",
                        "      return parts;",
                        "    }",
                        "",
                        "    case \"TSConditionalType\":",
                        "      return printTernary(path, options, print);",
                        "",
                        "    case \"TSInferType\":",
                        "      return [\"infer\", \" \", print(\"typeParameter\")];",
                        "    case \"TSIntersectionType\":",
                        "      return printIntersectionType(path, options, print);",
                        "    case \"TSUnionType\":",
                        "      return printUnionType(path, options, print);",
                        "    case \"TSFunctionType\":",
                        "      return printFunctionType(path, options, print);",
                        "    case \"TSTupleType\":",
                        "      return printTupleType(path, options, print);",
                        "    case \"TSTypeReference\":",
                        "      return [",
                        "        print(\"typeName\"),",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"TSTypeAnnotation\":",
                        "      return print(\"typeAnnotation\");",
                        "    case \"TSEmptyBodyFunctionExpression\":",
                        "      return printMethodInternal(path, options, print);",
                        "",
                        "    // These are not valid TypeScript. Printing them just for the sake of error recovery.",
                        "    case \"TSJSDocAllType\":",
                        "      return \"*\";",
                        "    case \"TSJSDocUnknownType\":",
                        "      return \"?\";",
                        "    case \"TSJSDocNullableType\":",
                        "      return printJSDocType(path, print, /* token */ \"?\");",
                        "    case \"TSJSDocNonNullableType\":",
                        "      return printJSDocType(path, print, /* token */ \"!\");",
                        "    case \"TSInstantiationExpression\":",
                        "      return [print(\"expression\"), print(\"typeParameters\")];",
                        "    default:",
                        "      /* istanbul ignore next */",
                        "      throw new Error(",
                        "        `Unknown TypeScript node type: ${JSON.stringify(node.type)}.`",
                        "      );",
                        "  }",
                        "}",
                        "",
                        "module.exports = { printTypescript };"
                    ]
                }
            },
            "types": {
                "estree.d.ts": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as ESTree from \"estree\";",
                        "import * as Babel from \"@babel/types\";",
                        "import { TSESTree } from \"@typescript-eslint/typescript-estree\";",
                        "import { ESTree as Meriyah } from \"meriyah\";",
                        "import * as NGTree from \"angular-estree-parser/lib/types\";",
                        "",
                        "type AdditionalFields = {",
                        "  extra?: {",
                        "    parenthesized?: boolean;",
                        "    raw?: string;",
                        "  };",
                        "  comments?: Comment[];",
                        "  trailingComments?: ReadonlyArray<Comment> | Comment[];",
                        "  leadingComments?: ReadonlyArray<Comment> | Comment[];",
                        "};",
                        "",
                        "export type Comment = (",
                        "  | ESTree.Comment",
                        "  | Babel.Comment",
                        "  | TSESTree.Comment",
                        "  | Meriyah.Comment",
                        ") & {",
                        "  printed?: boolean;",
                        "  trailing?: boolean;",
                        "  leading?: boolean;",
                        "};",
                        "",
                        "export type Node = (ESTree.Node | Babel.Node | TSESTree.Node | NGTree.NGNode) &",
                        "  AdditionalFields;",
                        "",
                        "export type TemplateLiteral = (",
                        "  | ESTree.TemplateLiteral",
                        "  | Babel.TemplateLiteral",
                        "  | TSESTree.TemplateLiteral",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type CallExpression = (",
                        "  | ESTree.CallExpression",
                        "  | Babel.CallExpression",
                        "  | TSESTree.CallExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type OptionalCallExpression = Babel.OptionalCallExpression &",
                        "  AdditionalFields;",
                        "",
                        "export type MemberExpression = (",
                        "  | ESTree.MemberExpression",
                        "  | Babel.MemberExpression",
                        "  | TSESTree.MemberExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type OptionalMemberExpression = Babel.OptionalMemberExpression &",
                        "  AdditionalFields;",
                        "",
                        "export type Expression = (",
                        "  | ESTree.Expression",
                        "  | Babel.Expression",
                        "  | TSESTree.Expression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type BindExpression = Babel.BindExpression & AdditionalFields;",
                        "",
                        "export type Property = (ESTree.Property | Babel.Property | TSESTree.Property) &",
                        "  AdditionalFields;",
                        "",
                        "export type ClassPrivateProperty = Babel.ClassPrivateProperty &",
                        "  AdditionalFields;",
                        "",
                        "export type ObjectTypeProperty = Babel.ObjectTypeProperty & AdditionalFields;",
                        "",
                        "export type JSXElement = (Babel.JSXElement | TSESTree.JSXElement) &",
                        "  AdditionalFields;",
                        "",
                        "export type TaggedTemplateExpression = (",
                        "  | ESTree.TaggedTemplateExpression",
                        "  | Babel.TaggedTemplateExpression",
                        "  | TSESTree.TaggedTemplateExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type Literal = (ESTree.Literal | Babel.Literal | TSESTree.Literal) &",
                        "  AdditionalFields;",
                        "",
                        "export { ESTree, Babel, TSESTree, NGTree };"
                    ]
                }
            },
            "utils": {
                "get-shebang.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function getShebang(text) {",
                        "  if (!text.startsWith(\"#!\")) {",
                        "    return \"\";",
                        "  }",
                        "  const index = text.indexOf(\"\\n\");",
                        "  if (index === -1) {",
                        "    return text;",
                        "  }",
                        "  return text.slice(0, index);",
                        "}",
                        "",
                        "module.exports = getShebang;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES5;",
                        "const {",
                        "  getLast,",
                        "  hasNewline,",
                        "  skipWhitespace,",
                        "  isNonEmptyArray,",
                        "  isNextLineEmptyAfterIndex,",
                        "  getStringWidth,",
                        "} = require(\"../../common/util.js\");",
                        "const { locStart, locEnd, hasSameLocStart } = require(\"../loc.js\");",
                        "const isBlockComment = require(\"./is-block-comment.js\");",
                        "const isNodeMatches = require(\"./is-node-matches.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree\").Node} Node",
                        " * @typedef {import(\"../types/estree\").TemplateLiteral} TemplateLiteral",
                        " * @typedef {import(\"../types/estree\").Comment} Comment",
                        " * @typedef {import(\"../types/estree\").MemberExpression} MemberExpression",
                        " * @typedef {import(\"../types/estree\").OptionalMemberExpression} OptionalMemberExpression",
                        " * @typedef {import(\"../types/estree\").CallExpression} CallExpression",
                        " * @typedef {import(\"../types/estree\").OptionalCallExpression} OptionalCallExpression",
                        " * @typedef {import(\"../types/estree\").Expression} Expression",
                        " * @typedef {import(\"../types/estree\").Property} Property",
                        " * @typedef {import(\"../types/estree\").ObjectTypeProperty} ObjectTypeProperty",
                        " * @typedef {import(\"../types/estree\").TaggedTemplateExpression} TaggedTemplateExpression",
                        " * @typedef {import(\"../types/estree\").Literal} Literal",
                        " *",
                        " * @typedef {import(\"../../common/ast-path\")} AstPath",
                        " */",
                        "",
                        "// We match any whitespace except line terminators because",
                        "// Flow annotation comments cannot be split across lines. For example:",
                        "//",
                        "// (this /*",
                        "// : any */).foo = 5;",
                        "//",
                        "// is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so",
                        "// removing the newline would create a type annotation that the user did not intend",
                        "// to create.",
                        "const NON_LINE_TERMINATING_WHITE_SPACE = \"(?:(?=.)\\\\s)\";",
                        "const FLOW_SHORTHAND_ANNOTATION = new RegExp(",
                        "  `^${NON_LINE_TERMINATING_WHITE_SPACE}*:`",
                        ");",
                        "const FLOW_ANNOTATION = new RegExp(`^${NON_LINE_TERMINATING_WHITE_SPACE}*::`);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasFlowShorthandAnnotationComment(node) {",
                        "  // https://flow.org/en/docs/types/comments/",
                        "  // Syntax example: const r = new (window.Request /*: Class<Request> */)(\"\");",
                        "",
                        "  return (",
                        "    node.extra?.parenthesized &&",
                        "    isBlockComment(node.trailingComments?.[0]) &&",
                        "    FLOW_SHORTHAND_ANNOTATION.test(node.trailingComments[0].value)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Comment[]} comments",
                        " * @returns {boolean}",
                        " */",
                        "function hasFlowAnnotationComment(comments) {",
                        "  const firstComment = comments?.[0];",
                        "  return (",
                        "    isBlockComment(firstComment) && FLOW_ANNOTATION.test(firstComment.value)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {(Node) => boolean} fn",
                        " * @returns {boolean}",
                        " */",
                        "function hasNode(node, fn) {",
                        "  if (!node || typeof node !== \"object\") {",
                        "    return false;",
                        "  }",
                        "  if (Array.isArray(node)) {",
                        "    return node.some((value) => hasNode(value, fn));",
                        "  }",
                        "  const result = fn(node);",
                        "  return typeof result === \"boolean\"",
                        "    ? result",
                        "    : Object.values(node).some((value) => hasNode(value, fn));",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasNakedLeftSide(node) {",
                        "  return (",
                        "    node.type === \"AssignmentExpression\" ||",
                        "    node.type === \"BinaryExpression\" ||",
                        "    node.type === \"LogicalExpression\" ||",
                        "    node.type === \"NGPipeExpression\" ||",
                        "    node.type === \"ConditionalExpression\" ||",
                        "    isCallExpression(node) ||",
                        "    isMemberExpression(node) ||",
                        "    node.type === \"SequenceExpression\" ||",
                        "    node.type === \"TaggedTemplateExpression\" ||",
                        "    node.type === \"BindExpression\" ||",
                        "    (node.type === \"UpdateExpression\" && !node.prefix) ||",
                        "    isTSTypeExpression(node) ||",
                        "    node.type === \"TSNonNullExpression\"",
                        "  );",
                        "}",
                        "",
                        "function getLeftSide(node) {",
                        "  if (node.expressions) {",
                        "    return node.expressions[0];",
                        "  }",
                        "  return (",
                        "    node.left ??",
                        "    node.test ??",
                        "    node.callee ??",
                        "    node.object ??",
                        "    node.tag ??",
                        "    node.argument ??",
                        "    node.expression",
                        "  );",
                        "}",
                        "",
                        "function getLeftSidePathName(path, node) {",
                        "  if (node.expressions) {",
                        "    return [\"expressions\", 0];",
                        "  }",
                        "  if (node.left) {",
                        "    return [\"left\"];",
                        "  }",
                        "  if (node.test) {",
                        "    return [\"test\"];",
                        "  }",
                        "  if (node.object) {",
                        "    return [\"object\"];",
                        "  }",
                        "  if (node.callee) {",
                        "    return [\"callee\"];",
                        "  }",
                        "  if (node.tag) {",
                        "    return [\"tag\"];",
                        "  }",
                        "  if (node.argument) {",
                        "    return [\"argument\"];",
                        "  }",
                        "  if (node.expression) {",
                        "    return [\"expression\"];",
                        "  }",
                        "  throw new Error(\"Unexpected node has no left side.\");",
                        "}",
                        "",
                        "function createTypeCheckFunction(types) {",
                        "  types = new Set(types);",
                        "  return (node) => types.has(node?.type);",
                        "}",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "const isLineComment = createTypeCheckFunction([",
                        "  \"Line\",",
                        "  \"CommentLine\",",
                        "  // `meriyah` has `SingleLine`, `HashbangComment`, `HTMLOpen`, and `HTMLClose`",
                        "  \"SingleLine\",",
                        "  \"HashbangComment\",",
                        "  \"HTMLOpen\",",
                        "  \"HTMLClose\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isExportDeclaration = createTypeCheckFunction([",
                        "  \"ExportDefaultDeclaration\",",
                        "  \"ExportDefaultSpecifier\",",
                        "  \"DeclareExportDeclaration\",",
                        "  \"ExportNamedDeclaration\",",
                        "  \"ExportAllDeclaration\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {Node | null}",
                        " */",
                        "function getParentExportDeclaration(path) {",
                        "  const parentNode = path.getParentNode();",
                        "  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {",
                        "    return parentNode;",
                        "  }",
                        "",
                        "  return null;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isLiteral = createTypeCheckFunction([",
                        "  \"BooleanLiteral\",",
                        "  \"DirectiveLiteral\",",
                        "  \"Literal\",",
                        "  \"NullLiteral\",",
                        "  \"NumericLiteral\",",
                        "  \"BigIntLiteral\",",
                        "  \"DecimalLiteral\",",
                        "  \"RegExpLiteral\",",
                        "  \"StringLiteral\",",
                        "  \"TemplateLiteral\",",
                        "  \"TSTypeLiteral\",",
                        "  \"JSXText\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isNumericLiteral(node) {",
                        "  return (",
                        "    node.type === \"NumericLiteral\" ||",
                        "    (node.type === \"Literal\" && typeof node.value === \"number\")",
                        "  );",
                        "}",
                        "",
                        "function isSignedNumericLiteral(node) {",
                        "  return (",
                        "    node.type === \"UnaryExpression\" &&",
                        "    (node.operator === \"+\" || node.operator === \"-\") &&",
                        "    isNumericLiteral(node.argument)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isStringLiteral(node) {",
                        "  return (",
                        "    node.type === \"StringLiteral\" ||",
                        "    (node.type === \"Literal\" && typeof node.value === \"string\")",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isObjectType = createTypeCheckFunction([",
                        "  \"ObjectTypeAnnotation\",",
                        "  \"TSTypeLiteral\",",
                        "  \"TSMappedType\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isFunctionOrArrowExpression = createTypeCheckFunction([",
                        "  \"FunctionExpression\",",
                        "  \"ArrowFunctionExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isFunctionOrArrowExpressionWithBody(node) {",
                        "  return (",
                        "    node.type === \"FunctionExpression\" ||",
                        "    (node.type === \"ArrowFunctionExpression\" &&",
                        "      node.body.type === \"BlockStatement\")",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * Note: `inject` is used in AngularJS 1.x, `async` and `fakeAsync` in",
                        " * Angular 2+, although `async` is deprecated and replaced by `waitForAsync`",
                        " * since Angular 12.",
                        " *",
                        " * example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-",
                        " *",
                        " * @param {CallExpression} node",
                        " * @returns {boolean}",
                        " */",
                        "function isAngularTestWrapper(node) {",
                        "  return (",
                        "    isCallExpression(node) &&",
                        "    node.callee.type === \"Identifier\" &&",
                        "    [\"async\", \"inject\", \"fakeAsync\", \"waitForAsync\"].includes(node.callee.name)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isJsxNode = createTypeCheckFunction([\"JSXElement\", \"JSXFragment\"]);",
                        "",
                        "function isTheOnlyJsxElementInMarkdown(options, path) {",
                        "  if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  const node = path.getNode();",
                        "",
                        "  if (!node.expression || !isJsxNode(node.expression)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const parent = path.getParentNode();",
                        "",
                        "  return parent.type === \"Program\" && parent.body.length === 1;",
                        "}",
                        "",
                        "function isGetterOrSetter(node) {",
                        "  return node.kind === \"get\" || node.kind === \"set\";",
                        "}",
                        "",
                        "// TODO: This is a bad hack and we need a better way to distinguish between",
                        "// arrow functions and otherwise",
                        "function isFunctionNotation(node) {",
                        "  return isGetterOrSetter(node) || hasSameLocStart(node, node.value);",
                        "}",
                        "",
                        "// Hack to differentiate between the following two which have the same ast",
                        "// type T = { method: () => void };",
                        "// type T = { method(): void };",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isObjectTypePropertyAFunction(node) {",
                        "  return (",
                        "    (node.type === \"ObjectTypeProperty\" ||",
                        "      node.type === \"ObjectTypeInternalSlot\") &&",
                        "    node.value.type === \"FunctionTypeAnnotation\" &&",
                        "    !node.static &&",
                        "    !isFunctionNotation(node)",
                        "  );",
                        "}",
                        "",
                        "// Hack to differentiate between the following two which have the same ast",
                        "// declare function f(a): void;",
                        "// var f: (a) => void;",
                        "function isTypeAnnotationAFunction(node) {",
                        "  return (",
                        "    (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") &&",
                        "    node.typeAnnotation.type === \"FunctionTypeAnnotation\" &&",
                        "    !node.static &&",
                        "    !hasSameLocStart(node, node.typeAnnotation)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isBinaryish = createTypeCheckFunction([",
                        "  \"BinaryExpression\",",
                        "  \"LogicalExpression\",",
                        "  \"NGPipeExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isMemberish(node) {",
                        "  return (",
                        "    isMemberExpression(node) ||",
                        "    (node.type === \"BindExpression\" && Boolean(node.object))",
                        "  );",
                        "}",
                        "",
                        "const simpleTypeAnnotations = new Set([",
                        "  // `any`",
                        "  \"AnyTypeAnnotation\",",
                        "  \"TSAnyKeyword\",",
                        "  // `null`",
                        "  \"NullLiteralTypeAnnotation\",",
                        "  \"TSNullKeyword\",",
                        "  // `this`",
                        "  \"ThisTypeAnnotation\",",
                        "  \"TSThisType\",",
                        "  // `number`",
                        "  \"NumberTypeAnnotation\",",
                        "  \"TSNumberKeyword\",",
                        "  // `void`",
                        "  \"VoidTypeAnnotation\",",
                        "  \"TSVoidKeyword\",",
                        "  // `boolean`",
                        "  \"BooleanTypeAnnotation\",",
                        "  \"TSBooleanKeyword\",",
                        "  // `bigint`",
                        "  \"BigIntTypeAnnotation\",",
                        "  \"TSBigIntKeyword\",",
                        "  // `symbol`",
                        "  \"SymbolTypeAnnotation\",",
                        "  \"TSSymbolKeyword\",",
                        "  // `string`",
                        "  \"StringTypeAnnotation\",",
                        "  \"TSStringKeyword\",",
                        "  // literals",
                        "  \"BooleanLiteralTypeAnnotation\",",
                        "  \"StringLiteralTypeAnnotation\",",
                        "  \"BigIntLiteralTypeAnnotation\",",
                        "  \"NumberLiteralTypeAnnotation\",",
                        "  \"TSLiteralType\",",
                        "  \"TSTemplateLiteralType\",",
                        "  // flow only, `empty`, `mixed`",
                        "  \"EmptyTypeAnnotation\",",
                        "  \"MixedTypeAnnotation\",",
                        "  // typescript only, `never`, `object`, `undefined`, `unknown`",
                        "  \"TSNeverKeyword\",",
                        "  \"TSObjectKeyword\",",
                        "  \"TSUndefinedKeyword\",",
                        "  \"TSUnknownKeyword\",",
                        "]);",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleType(node) {",
                        "  if (!node) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    (node.type === \"GenericTypeAnnotation\" ||",
                        "      node.type === \"TSTypeReference\") &&",
                        "    !node.typeParameters",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (simpleTypeAnnotations.has(node.type)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "/**",
                        " * @param {CallExpression} node",
                        " * @returns {boolean}",
                        " */",
                        "function isUnitTestSetUp(node) {",
                        "  const unitTestSetUpRe = /^(?:before|after)(?:Each|All)$/;",
                        "  return (",
                        "    node.callee.type === \"Identifier\" &&",
                        "    unitTestSetUpRe.test(node.callee.name) &&",
                        "    node.arguments.length === 1",
                        "  );",
                        "}",
                        "",
                        "const testCallCalleePatterns = [",
                        "  \"it\",",
                        "  \"it.only\",",
                        "  \"it.skip\",",
                        "  \"describe\",",
                        "  \"describe.only\",",
                        "  \"describe.skip\",",
                        "  \"test\",",
                        "  \"test.only\",",
                        "  \"test.skip\",",
                        "  \"test.step\",",
                        "  \"test.describe\",",
                        "  \"test.describe.only\",",
                        "  \"test.describe.parallel\",",
                        "  \"test.describe.parallel.only\",",
                        "  \"test.describe.serial\",",
                        "  \"test.describe.serial.only\",",
                        "  \"skip\",",
                        "  \"xit\",",
                        "  \"xdescribe\",",
                        "  \"xtest\",",
                        "  \"fit\",",
                        "  \"fdescribe\",",
                        "  \"ftest\",",
                        "];",
                        "",
                        "function isTestCallCallee(node) {",
                        "  return isNodeMatches(node, testCallCalleePatterns);",
                        "}",
                        "",
                        "// eg; `describe(\"some string\", (done) => {})`",
                        "function isTestCall(node, parent) {",
                        "  if (node.type !== \"CallExpression\") {",
                        "    return false;",
                        "  }",
                        "  if (node.arguments.length === 1) {",
                        "    if (isAngularTestWrapper(node) && parent && isTestCall(parent)) {",
                        "      return isFunctionOrArrowExpression(node.arguments[0]);",
                        "    }",
                        "",
                        "    if (isUnitTestSetUp(node)) {",
                        "      return isAngularTestWrapper(node.arguments[0]);",
                        "    }",
                        "  } else if (node.arguments.length === 2 || node.arguments.length === 3) {",
                        "    if (",
                        "      (node.arguments[0].type === \"TemplateLiteral\" ||",
                        "        isStringLiteral(node.arguments[0])) &&",
                        "      isTestCallCallee(node.callee)",
                        "    ) {",
                        "      // it(\"name\", () => { ... }, 2500)",
                        "      if (node.arguments[2] && !isNumericLiteral(node.arguments[2])) {",
                        "        return false;",
                        "      }",
                        "      return (",
                        "        (node.arguments.length === 2",
                        "          ? isFunctionOrArrowExpression(node.arguments[1])",
                        "          : isFunctionOrArrowExpressionWithBody(node.arguments[1]) &&",
                        "            getFunctionParameters(node.arguments[1]).length <= 1) ||",
                        "        isAngularTestWrapper(node.arguments[1])",
                        "      );",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isCallExpression = createTypeCheckFunction([",
                        "  \"CallExpression\",",
                        "  \"OptionalCallExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isMemberExpression = createTypeCheckFunction([",
                        "  \"MemberExpression\",",
                        "  \"OptionalMemberExpression\",",
                        "]);",
                        "",
                        "/**",
                        " *",
                        " * @param {any} node",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleTemplateLiteral(node) {",
                        "  let expressionsKey = \"expressions\";",
                        "  if (node.type === \"TSTemplateLiteralType\") {",
                        "    expressionsKey = \"types\";",
                        "  }",
                        "  const expressions = node[expressionsKey];",
                        "",
                        "  if (expressions.length === 0) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return expressions.every((expr) => {",
                        "    // Disallow comments since printDocToString can't print them here",
                        "    if (hasComment(expr)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    // Allow `x` and `this`",
                        "    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {",
                        "      return true;",
                        "    }",
                        "",
                        "    // Allow `a.b.c`, `a.b[c]`, and `this.x.y`",
                        "    if (isMemberExpression(expr)) {",
                        "      let head = expr;",
                        "      while (isMemberExpression(head)) {",
                        "        if (",
                        "          head.property.type !== \"Identifier\" &&",
                        "          head.property.type !== \"Literal\" &&",
                        "          head.property.type !== \"StringLiteral\" &&",
                        "          head.property.type !== \"NumericLiteral\"",
                        "        ) {",
                        "          return false;",
                        "        }",
                        "        head = head.object;",
                        "        if (hasComment(head)) {",
                        "          return false;",
                        "        }",
                        "      }",
                        "",
                        "      if (head.type === \"Identifier\" || head.type === \"ThisExpression\") {",
                        "        return true;",
                        "      }",
                        "",
                        "      return false;",
                        "    }",
                        "",
                        "    return false;",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {string} tokenNode",
                        " * @param {string} keyword",
                        " * @returns {string}",
                        " */",
                        "function getTypeScriptMappedTypeModifier(tokenNode, keyword) {",
                        "  if (tokenNode === \"+\" || tokenNode === \"-\") {",
                        "    return tokenNode + keyword;",
                        "  }",
                        "",
                        "  return keyword;",
                        "}",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {Node} typeAnnotation",
                        " * @returns {boolean}",
                        " */",
                        "function isFlowAnnotationComment(text, typeAnnotation) {",
                        "  const start = locStart(typeAnnotation);",
                        "  const end = skipWhitespace(text, locEnd(typeAnnotation));",
                        "  return (",
                        "    end !== false &&",
                        "    text.slice(start, start + 2) === \"/*\" &&",
                        "    text.slice(end, end + 2) === \"*/\"",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasLeadingOwnLineComment(text, node) {",
                        "  if (isJsxNode(node)) {",
                        "    return hasNodeIgnoreComment(node);",
                        "  }",
                        "",
                        "  return hasComment(node, CommentCheckFlags.Leading, (comment) =>",
                        "    hasNewline(text, locEnd(comment))",
                        "  );",
                        "}",
                        "",
                        "// Note: Quoting/unquoting numbers in TypeScript is not safe.",
                        "//",
                        "// let a = { 1: 1, 2: 2 }",
                        "// let b = { '1': 1, '2': 2 }",
                        "//",
                        "// declare let aa: keyof typeof a;",
                        "// declare let bb: keyof typeof b;",
                        "//",
                        "// aa = bb;",
                        "// ^^",
                        "// Type '\"1\" | \"2\"' is not assignable to type '1 | 2'.",
                        "//   Type '\"1\"' is not assignable to type '1 | 2'.(2322)",
                        "//",
                        "// And in Flow, you get:",
                        "//",
                        "// const x = {",
                        "//   0: 1",
                        "//   ^ Non-string literal property keys not supported. [unsupported-syntax]",
                        "// }",
                        "//",
                        "// Angular does not support unquoted numbers in expressions.",
                        "//",
                        "// So we play it safe and only unquote numbers for the JavaScript parsers.",
                        "// (Vue supports unquoted numbers in expressions, but let\u2019s keep it simple.)",
                        "//",
                        "// Identifiers can be unquoted in more circumstances, though.",
                        "function isStringPropSafeToUnquote(node, options) {",
                        "  return (",
                        "    options.parser !== \"json\" &&",
                        "    isStringLiteral(node.key) &&",
                        "    rawText(node.key).slice(1, -1) === node.key.value &&",
                        "    ((isIdentifierName(node.key.value) &&",
                        "      // With `--strictPropertyInitialization`, TS treats properties with quoted names differently than unquoted ones.",
                        "      // See https://github.com/microsoft/TypeScript/pull/20075",
                        "      !(",
                        "        (options.parser === \"babel-ts\" && node.type === \"ClassProperty\") ||",
                        "        (options.parser === \"typescript\" && node.type === \"PropertyDefinition\")",
                        "      )) ||",
                        "      (isSimpleNumber(node.key.value) &&",
                        "        String(Number(node.key.value)) === node.key.value &&",
                        "        (options.parser === \"babel\" ||",
                        "          options.parser === \"acorn\" ||",
                        "          options.parser === \"espree\" ||",
                        "          options.parser === \"meriyah\" ||",
                        "          options.parser === \"__babel_estree\")))",
                        "  );",
                        "}",
                        "",
                        "// Matches \u201csimple\u201d numbers like `123` and `2.5` but not `1_000`, `1e+100` or `0b10`.",
                        "function isSimpleNumber(numberString) {",
                        "  return /^(?:\\d+|\\d+\\.\\d+)$/.test(numberString);",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {Node} parentNode",
                        " * @returns {boolean}",
                        " */",
                        "function isJestEachTemplateLiteral(node, parentNode) {",
                        "  /**",
                        "   * describe.each`table`(name, fn)",
                        "   * describe.only.each`table`(name, fn)",
                        "   * describe.skip.each`table`(name, fn)",
                        "   * test.each`table`(name, fn)",
                        "   * test.only.each`table`(name, fn)",
                        "   * test.skip.each`table`(name, fn)",
                        "   *",
                        "   * Ref: https://github.com/facebook/jest/pull/6102",
                        "   */",
                        "  const jestEachTriggerRegex = /^[fx]?(?:describe|it|test)$/;",
                        "  return (",
                        "    parentNode.type === \"TaggedTemplateExpression\" &&",
                        "    parentNode.quasi === node &&",
                        "    parentNode.tag.type === \"MemberExpression\" &&",
                        "    parentNode.tag.property.type === \"Identifier\" &&",
                        "    parentNode.tag.property.name === \"each\" &&",
                        "    ((parentNode.tag.object.type === \"Identifier\" &&",
                        "      jestEachTriggerRegex.test(parentNode.tag.object.name)) ||",
                        "      (parentNode.tag.object.type === \"MemberExpression\" &&",
                        "        parentNode.tag.object.property.type === \"Identifier\" &&",
                        "        (parentNode.tag.object.property.name === \"only\" ||",
                        "          parentNode.tag.object.property.name === \"skip\") &&",
                        "        parentNode.tag.object.object.type === \"Identifier\" &&",
                        "        jestEachTriggerRegex.test(parentNode.tag.object.object.name)))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {TemplateLiteral} template",
                        " * @returns {boolean}",
                        " */",
                        "function templateLiteralHasNewLines(template) {",
                        "  return template.quasis.some((quasi) => quasi.value.raw.includes(\"\\n\"));",
                        "}",
                        "",
                        "/**",
                        " * @param {TemplateLiteral | TaggedTemplateExpression} node",
                        " * @param {string} text",
                        " * @returns {boolean}",
                        " */",
                        "function isTemplateOnItsOwnLine(node, text) {",
                        "  return (",
                        "    ((node.type === \"TemplateLiteral\" && templateLiteralHasNewLines(node)) ||",
                        "      (node.type === \"TaggedTemplateExpression\" &&",
                        "        templateLiteralHasNewLines(node.quasi))) &&",
                        "    !hasNewline(text, locStart(node), { backwards: true })",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function needsHardlineAfterDanglingComment(node) {",
                        "  if (!hasComment(node)) {",
                        "    return false;",
                        "  }",
                        "  const lastDanglingComment = getLast(",
                        "    getComments(node, CommentCheckFlags.Dangling)",
                        "  );",
                        "  return lastDanglingComment && !isBlockComment(lastDanglingComment);",
                        "}",
                        "",
                        "// Logic to check for args with multiple anonymous functions. For instance,",
                        "// the following call should be split on multiple lines for readability:",
                        "// source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))",
                        "function isFunctionCompositionArgs(args) {",
                        "  if (args.length <= 1) {",
                        "    return false;",
                        "  }",
                        "  let count = 0;",
                        "  for (const arg of args) {",
                        "    if (isFunctionOrArrowExpression(arg)) {",
                        "      count += 1;",
                        "      if (count > 1) {",
                        "        return true;",
                        "      }",
                        "    } else if (isCallExpression(arg)) {",
                        "      for (const childArg of arg.arguments) {",
                        "        if (isFunctionOrArrowExpression(childArg)) {",
                        "          return true;",
                        "        }",
                        "      }",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "// Logic to determine if a call is a \u201clong curried function call\u201d.",
                        "// See https://github.com/prettier/prettier/issues/1420.",
                        "//",
                        "// `connect(a, b, c)(d)`",
                        "// In the above call expression, the second call is the parent node and the",
                        "// first call is the current node.",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function isLongCurriedCallExpression(path) {",
                        "  const node = path.getValue();",
                        "  const parent = path.getParentNode();",
                        "  return (",
                        "    isCallExpression(node) &&",
                        "    isCallExpression(parent) &&",
                        "    parent.callee === node &&",
                        "    node.arguments.length > parent.arguments.length &&",
                        "    parent.arguments.length > 0",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {any} node",
                        " * @param {number} depth",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleCallArgument(node, depth) {",
                        "  if (depth >= 2) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const isChildSimple = (child) => isSimpleCallArgument(child, depth + 1);",
                        "",
                        "  const regexpPattern =",
                        "    (node.type === \"Literal\" && \"regex\" in node && node.regex.pattern) ||",
                        "    (node.type === \"RegExpLiteral\" && node.pattern);",
                        "",
                        "  if (regexpPattern && getStringWidth(regexpPattern) > 5) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    node.type === \"Literal\" ||",
                        "    node.type === \"BigIntLiteral\" ||",
                        "    node.type === \"DecimalLiteral\" ||",
                        "    node.type === \"BooleanLiteral\" ||",
                        "    node.type === \"NullLiteral\" ||",
                        "    node.type === \"NumericLiteral\" ||",
                        "    node.type === \"RegExpLiteral\" ||",
                        "    node.type === \"StringLiteral\" ||",
                        "    node.type === \"Identifier\" ||",
                        "    node.type === \"ThisExpression\" ||",
                        "    node.type === \"Super\" ||",
                        "    node.type === \"PrivateName\" ||",
                        "    node.type === \"PrivateIdentifier\" ||",
                        "    node.type === \"ArgumentPlaceholder\" ||",
                        "    node.type === \"Import\"",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.type === \"TemplateLiteral\") {",
                        "    return (",
                        "      node.quasis.every((element) => !element.value.raw.includes(\"\\n\")) &&",
                        "      node.expressions.every(isChildSimple)",
                        "    );",
                        "  }",
                        "",
                        "  if (node.type === \"ObjectExpression\") {",
                        "    return node.properties.every(",
                        "      (p) => !p.computed && (p.shorthand || (p.value && isChildSimple(p.value)))",
                        "    );",
                        "  }",
                        "",
                        "  if (node.type === \"ArrayExpression\") {",
                        "    return node.elements.every((x) => x === null || isChildSimple(x));",
                        "  }",
                        "",
                        "  if (isCallLikeExpression(node)) {",
                        "    return (",
                        "      (node.type === \"ImportExpression\" ||",
                        "        isSimpleCallArgument(node.callee, depth)) &&",
                        "      getCallArguments(node).every(isChildSimple)",
                        "    );",
                        "  }",
                        "",
                        "  if (isMemberExpression(node)) {",
                        "    return (",
                        "      isSimpleCallArgument(node.object, depth) &&",
                        "      isSimpleCallArgument(node.property, depth)",
                        "    );",
                        "  }",
                        "",
                        "  const targetUnaryExpressionOperators = {",
                        "    \"!\": true,",
                        "    \"-\": true,",
                        "    \"+\": true,",
                        "    \"~\": true,",
                        "  };",
                        "  if (",
                        "    node.type === \"UnaryExpression\" &&",
                        "    targetUnaryExpressionOperators[node.operator]",
                        "  ) {",
                        "    return isSimpleCallArgument(node.argument, depth);",
                        "  }",
                        "",
                        "  const targetUpdateExpressionOperators = {",
                        "    \"++\": true,",
                        "    \"--\": true,",
                        "  };",
                        "  if (",
                        "    node.type === \"UpdateExpression\" &&",
                        "    targetUpdateExpressionOperators[node.operator]",
                        "  ) {",
                        "    return isSimpleCallArgument(node.argument, depth);",
                        "  }",
                        "",
                        "  if (node.type === \"TSNonNullExpression\") {",
                        "    return isSimpleCallArgument(node.expression, depth);",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function rawText(node) {",
                        "  return node.extra?.raw ?? node.raw;",
                        "}",
                        "",
                        "function identity(x) {",
                        "  return x;",
                        "}",
                        "",
                        "function isTSXFile(options) {",
                        "  return options.filepath && /\\.tsx$/i.test(options.filepath);",
                        "}",
                        "",
                        "/**",
                        " * @param {any} options",
                        " * @param {(\"es5\" | \"all\")} [level]",
                        " * @returns {boolean}",
                        " */",
                        "function shouldPrintComma(options, level = \"es5\") {",
                        "  return (",
                        "    (options.trailingComma === \"es5\" && level === \"es5\") ||",
                        "    (options.trailingComma === \"all\" && (level === \"all\" || level === \"es5\"))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * Tests if the leftmost node of the expression matches the predicate. E.g.,",
                        " * used to check whether an expression statement needs to be wrapped in extra",
                        " * parentheses because it starts with:",
                        " *",
                        " * - `{`",
                        " * - `function`, `class`, or `do {}`",
                        " * - `let[`",
                        " *",
                        " * Will be overzealous if there already are necessary grouping parentheses.",
                        " *",
                        " * @param {Node} node",
                        " * @param {(leftmostNode: Node) => boolean} predicate",
                        " * @returns {boolean}",
                        " */",
                        "function startsWithNoLookaheadToken(node, predicate) {",
                        "  switch (node.type) {",
                        "    case \"BinaryExpression\":",
                        "    case \"LogicalExpression\":",
                        "    case \"AssignmentExpression\":",
                        "    case \"NGPipeExpression\":",
                        "      return startsWithNoLookaheadToken(node.left, predicate);",
                        "    case \"MemberExpression\":",
                        "    case \"OptionalMemberExpression\":",
                        "      return startsWithNoLookaheadToken(node.object, predicate);",
                        "    case \"TaggedTemplateExpression\":",
                        "      if (node.tag.type === \"FunctionExpression\") {",
                        "        // IIFEs are always already parenthesized",
                        "        return false;",
                        "      }",
                        "      return startsWithNoLookaheadToken(node.tag, predicate);",
                        "    case \"CallExpression\":",
                        "    case \"OptionalCallExpression\":",
                        "      if (node.callee.type === \"FunctionExpression\") {",
                        "        // IIFEs are always already parenthesized",
                        "        return false;",
                        "      }",
                        "      return startsWithNoLookaheadToken(node.callee, predicate);",
                        "    case \"ConditionalExpression\":",
                        "      return startsWithNoLookaheadToken(node.test, predicate);",
                        "    case \"UpdateExpression\":",
                        "      return (",
                        "        !node.prefix && startsWithNoLookaheadToken(node.argument, predicate)",
                        "      );",
                        "    case \"BindExpression\":",
                        "      return node.object && startsWithNoLookaheadToken(node.object, predicate);",
                        "    case \"SequenceExpression\":",
                        "      return startsWithNoLookaheadToken(node.expressions[0], predicate);",
                        "    case \"TSSatisfiesExpression\":",
                        "    case \"TSAsExpression\":",
                        "    case \"TSNonNullExpression\":",
                        "      return startsWithNoLookaheadToken(node.expression, predicate);",
                        "    default:",
                        "      return predicate(node);",
                        "  }",
                        "}",
                        "",
                        "const equalityOperators = {",
                        "  \"==\": true,",
                        "  \"!=\": true,",
                        "  \"===\": true,",
                        "  \"!==\": true,",
                        "};",
                        "const multiplicativeOperators = {",
                        "  \"*\": true,",
                        "  \"/\": true,",
                        "  \"%\": true,",
                        "};",
                        "const bitshiftOperators = {",
                        "  \">>\": true,",
                        "  \">>>\": true,",
                        "  \"<<\": true,",
                        "};",
                        "",
                        "function shouldFlatten(parentOp, nodeOp) {",
                        "  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // ** is right-associative",
                        "  // x ** y ** z --> x ** (y ** z)",
                        "  if (parentOp === \"**\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x == y == z --> (x == y) == z",
                        "  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x * y % z --> (x * y) % z",
                        "  if (",
                        "    (nodeOp === \"%\" && multiplicativeOperators[parentOp]) ||",
                        "    (parentOp === \"%\" && multiplicativeOperators[nodeOp])",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x * y / z --> (x * y) / z",
                        "  // x / y * z --> (x / y) * z",
                        "  if (",
                        "    nodeOp !== parentOp &&",
                        "    multiplicativeOperators[nodeOp] &&",
                        "    multiplicativeOperators[parentOp]",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x << y << z --> (x << y) << z",
                        "  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "const PRECEDENCE = new Map(",
                        "  [",
                        "    [\"|>\"],",
                        "    [\"??\"],",
                        "    [\"||\"],",
                        "    [\"&&\"],",
                        "    [\"|\"],",
                        "    [\"^\"],",
                        "    [\"&\"],",
                        "    [\"==\", \"===\", \"!=\", \"!==\"],",
                        "    [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],",
                        "    [\">>\", \"<<\", \">>>\"],",
                        "    [\"+\", \"-\"],",
                        "    [\"*\", \"/\", \"%\"],",
                        "    [\"**\"],",
                        "  ].flatMap((operators, index) =>",
                        "    operators.map((operator) => [operator, index])",
                        "  )",
                        ");",
                        "function getPrecedence(operator) {",
                        "  return PRECEDENCE.get(operator);",
                        "}",
                        "",
                        "function isBitwiseOperator(operator) {",
                        "  return (",
                        "    Boolean(bitshiftOperators[operator]) ||",
                        "    operator === \"|\" ||",
                        "    operator === \"^\" ||",
                        "    operator === \"&\"",
                        "  );",
                        "}",
                        "",
                        "function hasRestParameter(node) {",
                        "  if (node.rest) {",
                        "    return true;",
                        "  }",
                        "  const parameters = getFunctionParameters(node);",
                        "  return getLast(parameters)?.type === \"RestElement\";",
                        "}",
                        "",
                        "const functionParametersCache = new WeakMap();",
                        "function getFunctionParameters(node) {",
                        "  if (functionParametersCache.has(node)) {",
                        "    return functionParametersCache.get(node);",
                        "  }",
                        "  const parameters = [];",
                        "  if (node.this) {",
                        "    parameters.push(node.this);",
                        "  }",
                        "  // `params` vs `parameters` - see https://github.com/babel/babel/issues/9231",
                        "  if (Array.isArray(node.parameters)) {",
                        "    parameters.push(...node.parameters);",
                        "  } else if (Array.isArray(node.params)) {",
                        "    parameters.push(...node.params);",
                        "  }",
                        "  if (node.rest) {",
                        "    parameters.push(node.rest);",
                        "  }",
                        "  functionParametersCache.set(node, parameters);",
                        "  return parameters;",
                        "}",
                        "",
                        "function iterateFunctionParametersPath(path, iteratee) {",
                        "  const node = path.getValue();",
                        "  let index = 0;",
                        "  const callback = (childPath) => iteratee(childPath, index++);",
                        "  if (node.this) {",
                        "    path.call(callback, \"this\");",
                        "  }",
                        "  if (Array.isArray(node.parameters)) {",
                        "    path.each(callback, \"parameters\");",
                        "  } else if (Array.isArray(node.params)) {",
                        "    path.each(callback, \"params\");",
                        "  }",
                        "  if (node.rest) {",
                        "    path.call(callback, \"rest\");",
                        "  }",
                        "}",
                        "",
                        "const callArgumentsCache = new WeakMap();",
                        "function getCallArguments(node) {",
                        "  if (callArgumentsCache.has(node)) {",
                        "    return callArgumentsCache.get(node);",
                        "  }",
                        "",
                        "  let args = node.arguments;",
                        "  if (node.type === \"ImportExpression\") {",
                        "    args = [node.source];",
                        "",
                        "    if (node.attributes) {",
                        "      args.push(node.attributes);",
                        "    }",
                        "  }",
                        "",
                        "  callArgumentsCache.set(node, args);",
                        "  return args;",
                        "}",
                        "",
                        "function iterateCallArgumentsPath(path, iteratee) {",
                        "  const node = path.getValue();",
                        "  if (node.type === \"ImportExpression\") {",
                        "    path.call((sourcePath) => iteratee(sourcePath, 0), \"source\");",
                        "",
                        "    if (node.attributes) {",
                        "      path.call((sourcePath) => iteratee(sourcePath, 1), \"attributes\");",
                        "    }",
                        "  } else {",
                        "    path.each(iteratee, \"arguments\");",
                        "  }",
                        "}",
                        "",
                        "function isPrettierIgnoreComment(comment) {",
                        "  return comment.value.trim() === \"prettier-ignore\" && !comment.unignore;",
                        "}",
                        "",
                        "function hasNodeIgnoreComment(node) {",
                        "  return (",
                        "    node &&",
                        "    (node.prettierIgnore || hasComment(node, CommentCheckFlags.PrettierIgnore))",
                        "  );",
                        "}",
                        "",
                        "function hasIgnoreComment(path) {",
                        "  const node = path.getValue();",
                        "  return hasNodeIgnoreComment(node);",
                        "}",
                        "",
                        "const CommentCheckFlags = {",
                        "  /** Check comment is a leading comment */",
                        "  Leading: 1 << 1,",
                        "  /** Check comment is a trailing comment */",
                        "  Trailing: 1 << 2,",
                        "  /** Check comment is a dangling comment */",
                        "  Dangling: 1 << 3,",
                        "  /** Check comment is a block comment */",
                        "  Block: 1 << 4,",
                        "  /** Check comment is a line comment */",
                        "  Line: 1 << 5,",
                        "  /** Check comment is a `prettier-ignore` comment */",
                        "  PrettierIgnore: 1 << 6,",
                        "  /** Check comment is the first attached comment */",
                        "  First: 1 << 7,",
                        "  /** Check comment is the last attached comment */",
                        "  Last: 1 << 8,",
                        "};",
                        "",
                        "const getCommentTestFunction = (flags, fn) => {",
                        "  if (typeof flags === \"function\") {",
                        "    fn = flags;",
                        "    flags = 0;",
                        "  }",
                        "  if (flags || fn) {",
                        "    return (comment, index, comments) =>",
                        "      !(",
                        "        (flags & CommentCheckFlags.Leading && !comment.leading) ||",
                        "        (flags & CommentCheckFlags.Trailing && !comment.trailing) ||",
                        "        (flags & CommentCheckFlags.Dangling &&",
                        "          (comment.leading || comment.trailing)) ||",
                        "        (flags & CommentCheckFlags.Block && !isBlockComment(comment)) ||",
                        "        (flags & CommentCheckFlags.Line && !isLineComment(comment)) ||",
                        "        (flags & CommentCheckFlags.First && index !== 0) ||",
                        "        (flags & CommentCheckFlags.Last && index !== comments.length - 1) ||",
                        "        (flags & CommentCheckFlags.PrettierIgnore &&",
                        "          !isPrettierIgnoreComment(comment)) ||",
                        "        (fn && !fn(comment))",
                        "      );",
                        "  }",
                        "};",
                        "/**",
                        " * @param {Node} node",
                        " * @param {number | function} [flags]",
                        " * @param {function} [fn]",
                        " * @returns {boolean}",
                        " */",
                        "function hasComment(node, flags, fn) {",
                        "  if (!isNonEmptyArray(node?.comments)) {",
                        "    return false;",
                        "  }",
                        "  const test = getCommentTestFunction(flags, fn);",
                        "  return test ? node.comments.some(test) : true;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {number | function} [flags]",
                        " * @param {function} [fn]",
                        " * @returns {Comment[]}",
                        " */",
                        "function getComments(node, flags, fn) {",
                        "  if (!Array.isArray(node?.comments)) {",
                        "    return [];",
                        "  }",
                        "  const test = getCommentTestFunction(flags, fn);",
                        "  return test ? node.comments.filter(test) : node.comments;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isNextLineEmpty = (node, { originalText }) =>",
                        "  isNextLineEmptyAfterIndex(originalText, locEnd(node));",
                        "",
                        "function isCallLikeExpression(node) {",
                        "  return (",
                        "    isCallExpression(node) ||",
                        "    node.type === \"NewExpression\" ||",
                        "    node.type === \"ImportExpression\"",
                        "  );",
                        "}",
                        "",
                        "function isObjectProperty(node) {",
                        "  return (",
                        "    node &&",
                        "    (node.type === \"ObjectProperty\" ||",
                        "      (node.type === \"Property\" && !node.method && node.kind === \"init\"))",
                        "  );",
                        "}",
                        "",
                        "function isEnabledHackPipeline(options) {",
                        "  return Boolean(options.__isUsingHackPipeline);",
                        "}",
                        "",
                        "/**",
                        " * This is used as a marker for dangling comments.",
                        " */",
                        "const markerForIfWithoutBlockAndSameLineComment = Symbol(",
                        "  \"ifWithoutBlockAndSameLineComment\"",
                        ");",
                        "",
                        "function isTSTypeExpression(node) {",
                        "  return (",
                        "    node.type === \"TSAsExpression\" || node.type === \"TSSatisfiesExpression\"",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  getFunctionParameters,",
                        "  iterateFunctionParametersPath,",
                        "  getCallArguments,",
                        "  iterateCallArgumentsPath,",
                        "  hasRestParameter,",
                        "  getLeftSide,",
                        "  getLeftSidePathName,",
                        "  getParentExportDeclaration,",
                        "  getTypeScriptMappedTypeModifier,",
                        "  hasFlowAnnotationComment,",
                        "  hasFlowShorthandAnnotationComment,",
                        "  hasLeadingOwnLineComment,",
                        "  hasNakedLeftSide,",
                        "  hasNode,",
                        "  hasIgnoreComment,",
                        "  hasNodeIgnoreComment,",
                        "  identity,",
                        "  isBinaryish,",
                        "  isCallLikeExpression,",
                        "  isEnabledHackPipeline,",
                        "  isLineComment,",
                        "  isPrettierIgnoreComment,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isExportDeclaration,",
                        "  isFlowAnnotationComment,",
                        "  isFunctionCompositionArgs,",
                        "  isFunctionNotation,",
                        "  isFunctionOrArrowExpression,",
                        "  isGetterOrSetter,",
                        "  isJestEachTemplateLiteral,",
                        "  isJsxNode,",
                        "  isLiteral,",
                        "  isLongCurriedCallExpression,",
                        "  isSimpleCallArgument,",
                        "  isMemberish,",
                        "  isNumericLiteral,",
                        "  isSignedNumericLiteral,",
                        "  isObjectProperty,",
                        "  isObjectType,",
                        "  isObjectTypePropertyAFunction,",
                        "  isSimpleType,",
                        "  isSimpleNumber,",
                        "  isSimpleTemplateLiteral,",
                        "  isStringLiteral,",
                        "  isStringPropSafeToUnquote,",
                        "  isTemplateOnItsOwnLine,",
                        "  isTestCall,",
                        "  isTheOnlyJsxElementInMarkdown,",
                        "  isTSXFile,",
                        "  isTypeAnnotationAFunction,",
                        "  isNextLineEmpty,",
                        "  needsHardlineAfterDanglingComment,",
                        "  rawText,",
                        "  shouldPrintComma,",
                        "  isBitwiseOperator,",
                        "  shouldFlatten,",
                        "  startsWithNoLookaheadToken,",
                        "  getPrecedence,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  markerForIfWithoutBlockAndSameLineComment,",
                        "  isTSTypeExpression,",
                        "};"
                    ]
                },
                "is-block-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree\").Comment} Comment",
                        " */",
                        "",
                        "const BLOCK_COMMENT_TYPES = new Set([",
                        "  \"Block\",",
                        "  \"CommentBlock\",",
                        "  // `meriyah`",
                        "  \"MultiLine\",",
                        "]);",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "const isBlockComment = (comment) => BLOCK_COMMENT_TYPES.has(comment?.type);",
                        "",
                        "module.exports = isBlockComment;"
                    ]
                },
                "is-node-matches.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "// Copied from https://github.com/sindresorhus/eslint-plugin-unicorn/blob/d53d935951aa815c763fc9441aa452c763294715/rules/utils/is-node-matches.js",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree\").Node} Node",
                        " */",
                        "",
                        "/**",
                        "Check if node matches object name or key path.",
                        "",
                        "@param {Node} node - The AST node to check.",
                        "@param {string} nameOrPath - The object name or key path.",
                        "@returns {boolean}",
                        "*/",
                        "function isNodeMatchesNameOrPath(node, nameOrPath) {",
                        "  const names = nameOrPath.split(\".\");",
                        "  for (let index = names.length - 1; index >= 0; index--) {",
                        "    const name = names[index];",
                        "",
                        "    if (index === 0) {",
                        "      return node.type === \"Identifier\" && node.name === name;",
                        "    }",
                        "",
                        "    if (",
                        "      node.type !== \"MemberExpression\" ||",
                        "      node.optional ||",
                        "      node.computed ||",
                        "      node.property.type !== \"Identifier\" ||",
                        "      node.property.name !== name",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    node = node.object;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        "Check if node matches any object name or key path.",
                        "",
                        "@param {Node} node - The AST node to check.",
                        "@param {string[]} nameOrPaths - The object name or key paths.",
                        "@returns {boolean}",
                        "*/",
                        "function isNodeMatches(node, nameOrPaths) {",
                        "  return nameOrPaths.some((nameOrPath) =>",
                        "    isNodeMatchesNameOrPath(node, nameOrPath)",
                        "  );",
                        "}",
                        "",
                        "module.exports = isNodeMatches;"
                    ]
                },
                "is-ts-keyword-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "/**",
                        " * @returns {boolean}",
                        " */",
                        "function isTsKeywordType({ type }) {",
                        "  return type.startsWith(\"TS\") && type.endsWith(\"Keyword\");",
                        "}",
                        "",
                        "module.exports = isTsKeywordType;"
                    ]
                },
                "is-type-cast-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const isBlockComment = require(\"./is-block-comment.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree\").Comment} Comment",
                        " */",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "function isTypeCastComment(comment) {",
                        "  return (",
                        "    isBlockComment(comment) &&",
                        "    comment.value[0] === \"*\" &&",
                        "    // TypeScript expects the type to be enclosed in curly brackets, however",
                        "    // Closure Compiler accepts types in parens and even without any delimiters at all.",
                        "    // That's why we just search for \"@type\".",
                        "    /@type\\b/.test(comment.value)",
                        "  );",
                        "}",
                        "",
                        "module.exports = isTypeCastComment;"
                    ]
                }
            }
        },
        "language-markdown": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const collapseWhiteSpace = require(\"collapse-white-space\");",
                    "const { isFrontMatterNode } = require(\"../common/util.js\");",
                    "const { startWithPragma } = require(\"./pragma.js\");",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"position\",",
                    "  \"raw\", // front-matter",
                    "]);",
                    "function clean(ast, newObj, parent) {",
                    "  // for codeblock",
                    "  if (",
                    "    ast.type === \"front-matter\" ||",
                    "    ast.type === \"code\" ||",
                    "    ast.type === \"yaml\" ||",
                    "    ast.type === \"import\" ||",
                    "    ast.type === \"export\" ||",
                    "    ast.type === \"jsx\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"list\") {",
                    "    delete newObj.isAligned;",
                    "  }",
                    "",
                    "  if (ast.type === \"list\" || ast.type === \"listItem\") {",
                    "    delete newObj.spread;",
                    "    delete newObj.loose;",
                    "  }",
                    "",
                    "  // texts can be splitted or merged",
                    "  if (ast.type === \"text\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"inlineCode\") {",
                    "    newObj.value = ast.value.replace(/[\\t\\n ]+/g, \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"wikiLink\") {",
                    "    newObj.value = ast.value.trim().replace(/[\\t\\n]+/g, \" \");",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"definition\" ||",
                    "    ast.type === \"linkReference\" ||",
                    "    ast.type === \"imageReference\"",
                    "  ) {",
                    "    newObj.label = collapseWhiteSpace(ast.label);",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"definition\" ||",
                    "      ast.type === \"link\" ||",
                    "      ast.type === \"image\") &&",
                    "    ast.title",
                    "  ) {",
                    "    newObj.title = ast.title.replace(/\\\\([\"')])/g, \"$1\");",
                    "  }",
                    "",
                    "  // for insert pragma",
                    "  if (",
                    "    parent &&",
                    "    parent.type === \"root\" &&",
                    "    parent.children.length > 0 &&",
                    "    (parent.children[0] === ast ||",
                    "      (isFrontMatterNode(parent.children[0]) && parent.children[1] === ast)) &&",
                    "    ast.type === \"html\" &&",
                    "    startWithPragma(ast.value)",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "module.exports = clean;"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const cjkRegex = require(\"cjk-regex\");",
                    "const regexpUtil = require(\"regexp-util\");",
                    "const unicodeRegex = require(\"unicode-regex\");",
                    "",
                    "const cjkPattern = `(?:${cjkRegex()",
                    "  .union(",
                    "    unicodeRegex({",
                    "      Script_Extensions: [\"Han\", \"Katakana\", \"Hiragana\", \"Hangul\", \"Bopomofo\"],",
                    "      General_Category: [",
                    "        \"Other_Letter\",",
                    "        \"Letter_Number\",",
                    "        \"Other_Symbol\",",
                    "        \"Modifier_Letter\",",
                    "        \"Modifier_Symbol\",",
                    "        \"Nonspacing_Mark\",",
                    "      ],",
                    "    })",
                    "  )",
                    "  .toString()})(?:${unicodeRegex({",
                    "  Block: [\"Variation_Selectors\", \"Variation_Selectors_Supplement\"],",
                    "}).toString()})?`;",
                    "",
                    "const kPattern = unicodeRegex({ Script: [\"Hangul\"] })",
                    "  .union(unicodeRegex({ Script_Extensions: [\"Hangul\"] }))",
                    "  .toString();",
                    "",
                    "// http://spec.commonmark.org/0.25/#ascii-punctuation-character",
                    "const asciiPunctuationCharset =",
                    "  /* prettier-ignore */ regexpUtil.charset(",
                    "  \"!\", '\"', \"#\",  \"$\", \"%\", \"&\", \"'\", \"(\", \")\", \"*\",",
                    "  \"+\", \",\", \"-\",  \".\", \"/\", \":\", \";\", \"<\", \"=\", \">\",",
                    "  \"?\", \"@\", \"[\", \"\\\\\", \"]\", \"^\", \"_\", \"`\", \"{\", \"|\",",
                    "  \"}\", \"~\"",
                    ");",
                    "",
                    "// http://spec.commonmark.org/0.25/#punctuation-character",
                    "const punctuationCharset = unicodeRegex({",
                    "  // http://unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values",
                    "  General_Category: [",
                    "    /* Pc */ \"Connector_Punctuation\",",
                    "    /* Pd */ \"Dash_Punctuation\",",
                    "    /* Pe */ \"Close_Punctuation\",",
                    "    /* Pf */ \"Final_Punctuation\",",
                    "    /* Pi */ \"Initial_Punctuation\",",
                    "    /* Po */ \"Other_Punctuation\",",
                    "    /* Ps */ \"Open_Punctuation\",",
                    "  ],",
                    "}).union(asciiPunctuationCharset);",
                    "",
                    "const punctuationPattern = punctuationCharset.toString();",
                    "",
                    "module.exports = {",
                    "  cjkPattern,",
                    "  kPattern,",
                    "  punctuationPattern,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  inferParserByLanguage,",
                    "  getMaxContinuousCount,",
                    "} = require(\"../common/util.js\");",
                    "const {",
                    "  builders: { hardline, markAsRoot },",
                    "  utils: { replaceEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const printFrontMatter = require(\"../utils/front-matter/print.js\");",
                    "const { getFencedCodeBlockValue } = require(\"./utils.js\");",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (node.type === \"code\" && node.lang !== null) {",
                    "    const parser = inferParserByLanguage(node.lang, options);",
                    "    if (parser) {",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "      );",
                    "      const newOptions = { parser };",
                    "      if (node.lang === \"tsx\") {",
                    "        newOptions.filepath = \"dummy.tsx\";",
                    "      }",
                    "      const doc = textToDoc(",
                    "        getFencedCodeBlockValue(node, options.originalText),",
                    "        newOptions,",
                    "        { stripTrailingHardline: true }",
                    "      );",
                    "      return markAsRoot([",
                    "        style,",
                    "        node.lang,",
                    "        node.meta ? \" \" + node.meta : \"\",",
                    "        hardline,",
                    "        replaceEndOfLine(doc),",
                    "        hardline,",
                    "        style,",
                    "      ]);",
                    "    }",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return printFrontMatter(node, textToDoc);",
                    "",
                    "    // MDX",
                    "    case \"importExport\":",
                    "      return [",
                    "        textToDoc(",
                    "          node.value,",
                    "          { parser: \"babel\" },",
                    "          { stripTrailingHardline: true }",
                    "        ),",
                    "        hardline,",
                    "      ];",
                    "    case \"jsx\":",
                    "      return textToDoc(",
                    "        `<$>${node.value}</$>`,",
                    "        {",
                    "          parser: \"__js_expression\",",
                    "          rootMarker: \"mdx\",",
                    "        },",
                    "        { stripTrailingHardline: true }",
                    "      );",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-markdown.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/Markdown.json\"), (data) => ({",
                    "    since: \"1.8.0\",",
                    "    parsers: [\"markdown\"],",
                    "    vscodeLanguageIds: [\"markdown\"],",
                    "    filenames: [...data.filenames, \"README\"],",
                    "    extensions: data.extensions.filter((extension) => extension !== \".mdx\"),",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/Markdown.json\"), () => ({",
                    "    name: \"MDX\",",
                    "    since: \"1.15.0\",",
                    "    parsers: [\"mdx\"],",
                    "    vscodeLanguageIds: [\"mdx\"],",
                    "    filenames: [],",
                    "    extensions: [\".mdx\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  mdast: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  return node.position.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.position.end.offset;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "mdx.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * modified from https://github.com/mdx-js/mdx/blob/master/packages/mdx",
                    " *",
                    " * The MIT License (MIT)",
                    " *",
                    " * Copyright (c) 2017-2018 Compositor and Zeit, Inc.",
                    " *",
                    " * Permission is hereby granted, free of charge, to any person obtaining a copy",
                    " * of this software and associated documentation files (the \"Software\"), to deal",
                    " * in the Software without restriction, including without limitation the rights",
                    " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
                    " * copies of the Software, and to permit persons to whom the Software is",
                    " * furnished to do so, subject to the following conditions:",
                    " * The above copyright notice and this permission notice shall be included in",
                    " * all copies or substantial portions of the Software.",
                    " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
                    " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
                    " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
                    " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
                    " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
                    " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
                    " * THE SOFTWARE.",
                    " */",
                    "",
                    "const IMPORT_REGEX = /^import\\s/;",
                    "const EXPORT_REGEX = /^export\\s/;",
                    "const BLOCKS_REGEX = \"[a-z][a-z0-9]*(\\\\.[a-z][a-z0-9]*)*|\";",
                    "const COMMENT_REGEX = /<!---->|<!---?[^>-](?:-?[^-])*-->/;",
                    "const ES_COMMENT_REGEX = /^{\\s*\\/\\*(.*)\\*\\/\\s*}/;",
                    "const EMPTY_NEWLINE = \"\\n\\n\";",
                    "",
                    "const isImport = (text) => IMPORT_REGEX.test(text);",
                    "const isExport = (text) => EXPORT_REGEX.test(text);",
                    "",
                    "const tokenizeEsSyntax = (eat, value) => {",
                    "  const index = value.indexOf(EMPTY_NEWLINE);",
                    "  const subvalue = value.slice(0, index);",
                    "",
                    "  if (isExport(subvalue) || isImport(subvalue)) {",
                    "    return eat(subvalue)({",
                    "      type: isExport(subvalue) ? \"export\" : \"import\",",
                    "      value: subvalue,",
                    "    });",
                    "  }",
                    "};",
                    "",
                    "const tokenizeEsComment = (eat, value) => {",
                    "  const match = ES_COMMENT_REGEX.exec(value);",
                    "",
                    "  if (match) {",
                    "    return eat(match[0])({",
                    "      type: \"esComment\",",
                    "      value: match[1].trim(),",
                    "    });",
                    "  }",
                    "};",
                    "",
                    "/* istanbul ignore next */",
                    "tokenizeEsSyntax.locator = (value /*, fromIndex*/) =>",
                    "  isExport(value) || isImport(value) ? -1 : 1;",
                    "",
                    "tokenizeEsComment.locator = (value, fromIndex) => value.indexOf(\"{\", fromIndex);",
                    "",
                    "function esSyntax() {",
                    "  const { Parser } = this;",
                    "  const { blockTokenizers, blockMethods, inlineTokenizers, inlineMethods } =",
                    "    Parser.prototype;",
                    "",
                    "  blockTokenizers.esSyntax = tokenizeEsSyntax;",
                    "  inlineTokenizers.esComment = tokenizeEsComment;",
                    "",
                    "  blockMethods.splice(blockMethods.indexOf(\"paragraph\"), 0, \"esSyntax\");",
                    "  inlineMethods.splice(inlineMethods.indexOf(\"text\"), 0, \"esComment\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  esSyntax,",
                    "  BLOCKS_REGEX,",
                    "  COMMENT_REGEX,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  proseWrap: commonOptions.proseWrap,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};"
                ]
            },
            "parser-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const remarkParse = require(\"remark-parse\");",
                    "const unified = require(\"unified\");",
                    "const remarkMath = require(\"remark-math\");",
                    "const footnotes = require(\"remark-footnotes\");",
                    "const pragma = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const mdx = require(\"./mdx.js\");",
                    "const htmlToJsx = require(\"./unified-plugins/html-to-jsx.js\");",
                    "const frontMatter = require(\"./unified-plugins/front-matter.js\");",
                    "const liquid = require(\"./unified-plugins/liquid.js\");",
                    "const wikiLink = require(\"./unified-plugins/wiki-link.js\");",
                    "const looseItems = require(\"./unified-plugins/loose-items.js\");",
                    "",
                    "/**",
                    " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                    " *",
                    " * 1. restore unescaped character (Text)",
                    " * 2. merge continuous Texts",
                    " * 3. replace whitespaces in InlineCode#value with one whitespace",
                    " *    reference: http://spec.commonmark.org/0.25/#example-605",
                    " * 4. split Text into Sentence",
                    " *",
                    " * interface Word { value: string }",
                    " * interface Whitespace { value: string }",
                    " * interface Sentence { children: Array<Word | Whitespace> }",
                    " * interface InlineCode { children: Array<Sentence> }",
                    " */",
                    "function createParse({ isMDX }) {",
                    "  return (text) => {",
                    "    const processor = unified()",
                    "      .use(remarkParse, {",
                    "        commonmark: true,",
                    "        ...(isMDX && { blocks: [mdx.BLOCKS_REGEX] }),",
                    "      })",
                    "      .use(footnotes)",
                    "      .use(frontMatter)",
                    "      .use(remarkMath)",
                    "      .use(isMDX ? mdx.esSyntax : identity)",
                    "      .use(liquid)",
                    "      .use(isMDX ? htmlToJsx : identity)",
                    "      .use(wikiLink)",
                    "      .use(looseItems);",
                    "    return processor.runSync(processor.parse(text));",
                    "  };",
                    "}",
                    "",
                    "function identity(x) {",
                    "  return x;",
                    "}",
                    "",
                    "const baseParser = {",
                    "  astFormat: \"mdast\",",
                    "  hasPragma: pragma.hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "const markdownParser = { ...baseParser, parse: createParse({ isMDX: false }) };",
                    "",
                    "const mdxParser = { ...baseParser, parse: createParse({ isMDX: true }) };",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    remark: markdownParser,",
                    "    markdown: markdownParser,",
                    "    mdx: mdxParser,",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  /* istanbul ignore next */",
                    "  get remark() {",
                    "    return require(\"./parser-markdown.js\").parsers.remark;",
                    "  },",
                    "  get markdown() {",
                    "    return require(\"./parser-markdown.js\").parsers.remark;",
                    "  },",
                    "  get mdx() {",
                    "    return require(\"./parser-markdown.js\").parsers.mdx;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const parseFrontMatter = require(\"../utils/front-matter/parse.js\");",
                    "",
                    "const pragmas = [\"format\", \"prettier\"];",
                    "",
                    "function startWithPragma(text) {",
                    "  const pragma = `@(${pragmas.join(\"|\")})`;",
                    "  const regex = new RegExp(",
                    "    [",
                    "      `<!--\\\\s*${pragma}\\\\s*-->`,",
                    "      `{\\\\s*\\\\/\\\\*\\\\s*${pragma}\\\\s*\\\\*\\\\/\\\\s*}`,",
                    "      `<!--.*\\r?\\n[\\\\s\\\\S]*(^|\\n)[^\\\\S\\n]*${pragma}[^\\\\S\\n]*($|\\n)[\\\\s\\\\S]*\\n.*-->`,",
                    "    ].join(\"|\"),",
                    "    \"m\"",
                    "  );",
                    "  const matched = text.match(regex);",
                    "  return matched?.index === 0;",
                    "}",
                    "",
                    "module.exports = {",
                    "  startWithPragma,",
                    "  hasPragma: (text) =>",
                    "    startWithPragma(parseFrontMatter(text).content.trimStart()),",
                    "  insertPragma: (text) => {",
                    "    const extracted = parseFrontMatter(text);",
                    "    const pragma = `<!-- @${pragmas[0]} -->`;",
                    "    return extracted.frontMatter",
                    "      ? `${extracted.frontMatter.raw}\\n\\n${pragma}\\n\\n${extracted.content}`",
                    "      : `${pragma}\\n\\n${extracted.content}`;",
                    "  },",
                    "};"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const { getOrderedListItemInfo, mapAst, splitText } = require(\"./utils.js\");",
                    "",
                    "// 0x0 ~ 0x10ffff",
                    "const isSingleCharRegex = /^.$/su;",
                    "",
                    "function preprocess(ast, options) {",
                    "  ast = restoreUnescapedCharacter(ast, options);",
                    "  ast = mergeContinuousTexts(ast);",
                    "  ast = transformInlineCode(ast, options);",
                    "  ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);",
                    "  ast = markAlignedList(ast, options);",
                    "  ast = splitTextIntoSentences(ast, options);",
                    "  ast = transformImportExport(ast);",
                    "  ast = mergeContinuousImportExport(ast);",
                    "  return ast;",
                    "}",
                    "",
                    "function transformImportExport(ast) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (node.type !== \"import\" && node.type !== \"export\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    return { ...node, type: \"importExport\" };",
                    "  });",
                    "}",
                    "",
                    "function transformInlineCode(ast, options) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (node.type !== \"inlineCode\" || options.proseWrap === \"preserve\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    return { ...node, value: node.value.replace(/\\s+/g, \" \") };",
                    "  });",
                    "}",
                    "",
                    "function restoreUnescapedCharacter(ast, options) {",
                    "  return mapAst(ast, (node) =>",
                    "    node.type !== \"text\" ||",
                    "    node.value === \"*\" ||",
                    "    node.value === \"_\" || // handle these cases in printer",
                    "    !isSingleCharRegex.test(node.value) ||",
                    "    node.position.end.offset - node.position.start.offset === node.value.length",
                    "      ? node",
                    "      : {",
                    "          ...node,",
                    "          value: options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          ),",
                    "        }",
                    "  );",
                    "}",
                    "",
                    "function mergeContinuousImportExport(ast) {",
                    "  return mergeChildren(",
                    "    ast,",
                    "    (prevNode, node) =>",
                    "      prevNode.type === \"importExport\" && node.type === \"importExport\",",
                    "    (prevNode, node) => ({",
                    "      type: \"importExport\",",
                    "      value: prevNode.value + \"\\n\\n\" + node.value,",
                    "      position: {",
                    "        start: prevNode.position.start,",
                    "        end: node.position.end,",
                    "      },",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function mergeChildren(ast, shouldMerge, mergeNode) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (!node.children) {",
                    "      return node;",
                    "    }",
                    "    const children = node.children.reduce((current, child) => {",
                    "      const lastChild = getLast(current);",
                    "      if (lastChild && shouldMerge(lastChild, child)) {",
                    "        current.splice(-1, 1, mergeNode(lastChild, child));",
                    "      } else {",
                    "        current.push(child);",
                    "      }",
                    "      return current;",
                    "    }, []);",
                    "    return { ...node, children };",
                    "  });",
                    "}",
                    "",
                    "function mergeContinuousTexts(ast) {",
                    "  return mergeChildren(",
                    "    ast,",
                    "    (prevNode, node) => prevNode.type === \"text\" && node.type === \"text\",",
                    "    (prevNode, node) => ({",
                    "      type: \"text\",",
                    "      value: prevNode.value + node.value,",
                    "      position: {",
                    "        start: prevNode.position.start,",
                    "        end: node.position.end,",
                    "      },",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function splitTextIntoSentences(ast, options) {",
                    "  return mapAst(ast, (node, index, [parentNode]) => {",
                    "    if (node.type !== \"text\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    let { value } = node;",
                    "",
                    "    if (parentNode.type === \"paragraph\") {",
                    "      if (index === 0) {",
                    "        value = value.trimStart();",
                    "      }",
                    "      if (index === parentNode.children.length - 1) {",
                    "        value = value.trimEnd();",
                    "      }",
                    "    }",
                    "",
                    "    return {",
                    "      type: \"sentence\",",
                    "      position: node.position,",
                    "      children: splitText(value, options),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "function transformIndentedCodeblockAndMarkItsParentList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"code\") {",
                    "      // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it",
                    "      const isIndented = /^\\n?(?: {4,}|\\t)/.test(",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        )",
                    "      );",
                    "",
                    "      node.isIndented = isIndented;",
                    "",
                    "      if (isIndented) {",
                    "        for (let i = 0; i < parentStack.length; i++) {",
                    "          const parent = parentStack[i];",
                    "",
                    "          // no need to check checked items",
                    "          if (parent.hasIndentedCodeblock) {",
                    "            break;",
                    "          }",
                    "",
                    "          if (parent.type === \"list\") {",
                    "            parent.hasIndentedCodeblock = true;",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function markAlignedList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"list\" && node.children.length > 0) {",
                    "      // if one of its parents is not aligned, it's not possible to be aligned in sub-lists",
                    "      for (let i = 0; i < parentStack.length; i++) {",
                    "        const parent = parentStack[i];",
                    "        if (parent.type === \"list\" && !parent.isAligned) {",
                    "          node.isAligned = false;",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      node.isAligned = isAligned(node);",
                    "    }",
                    "",
                    "    return node;",
                    "  });",
                    "",
                    "  function getListItemStart(listItem) {",
                    "    return listItem.children.length === 0",
                    "      ? -1",
                    "      : listItem.children[0].position.start.column - 1;",
                    "  }",
                    "",
                    "  function isAligned(list) {",
                    "    if (!list.ordered) {",
                    "      /**",
                    "       * - 123",
                    "       * - 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const [firstItem, secondItem] = list.children;",
                    "",
                    "    const firstInfo = getOrderedListItemInfo(firstItem, options.originalText);",
                    "",
                    "    if (firstInfo.leadingSpaces.length > 1) {",
                    "      /**",
                    "       * 1.   123",
                    "       *",
                    "       * 1.   123",
                    "       * 1. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const firstStart = getListItemStart(firstItem);",
                    "",
                    "    if (firstStart === -1) {",
                    "      /**",
                    "       * 1.",
                    "       *",
                    "       * 1.",
                    "       * 1.",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (list.children.length === 1) {",
                    "      /**",
                    "       * aligned:",
                    "       *",
                    "       * 11. 123",
                    "       *",
                    "       * not aligned:",
                    "       *",
                    "       * 1. 123",
                    "       */",
                    "      return firstStart % options.tabWidth === 0;",
                    "    }",
                    "",
                    "    const secondStart = getListItemStart(secondItem);",
                    "",
                    "    if (firstStart !== secondStart) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 1. 123",
                    "       *",
                    "       * 1. 123",
                    "       * 11. 123",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (firstStart % options.tabWidth === 0) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 12. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    /**",
                    "     * aligned:",
                    "     *",
                    "     * 11. 123",
                    "     * 1.  123",
                    "     *",
                    "     * not aligned:",
                    "     *",
                    "     * 1. 123",
                    "     * 2. 123",
                    "     */",
                    "    const secondInfo = getOrderedListItemInfo(secondItem, options.originalText);",
                    "    return secondInfo.leadingSpaces.length > 1;",
                    "  }",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const collapseWhiteSpace = require(\"collapse-white-space\");",
                    "const {",
                    "  getLast,",
                    "  getMinNotPresentContinuousCount,",
                    "  getMaxContinuousCount,",
                    "  getStringWidth,",
                    "  isNonEmptyArray,",
                    "} = require(\"../common/util.js\");",
                    "const {",
                    "  builders: {",
                    "    breakParent,",
                    "    join,",
                    "    line,",
                    "    literalline,",
                    "    markAsRoot,",
                    "    hardline,",
                    "    softline,",
                    "    ifBreak,",
                    "    fill,",
                    "    align,",
                    "    indent,",
                    "    group,",
                    "    hardlineWithoutBreakParent,",
                    "  },",
                    "  utils: { normalizeDoc, replaceTextEndOfLine },",
                    "  printer: { printDocToString },",
                    "} = require(\"../document/index.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const {",
                    "  getFencedCodeBlockValue,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "  isAutolink,",
                    "} = require(\"./utils.js\");",
                    "",
                    "/**",
                    " * @typedef {import(\"../document\").Doc} Doc",
                    " */",
                    "",
                    "const TRAILING_HARDLINE_NODES = new Set([\"importExport\"]);",
                    "const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];",
                    "const SIBLING_NODE_TYPES = new Set([",
                    "  \"listItem\",",
                    "  \"definition\",",
                    "  \"footnoteDefinition\",",
                    "]);",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (shouldRemainTheSameContent(path)) {",
                    "    return splitText(",
                    "      options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      ),",
                    "      options",
                    "    ).map((node) =>",
                    "      node.type === \"word\"",
                    "        ? node.value",
                    "        : node.value === \"\"",
                    "        ? \"\"",
                    "        : printLine(path, node.value, options)",
                    "    );",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"root\":",
                    "      if (node.children.length === 0) {",
                    "        return \"\";",
                    "      }",
                    "      return [",
                    "        normalizeDoc(printRoot(path, options, print)),",
                    "        !TRAILING_HARDLINE_NODES.has(getLastDescendantNode(node).type)",
                    "          ? hardline",
                    "          : \"\",",
                    "      ];",
                    "    case \"paragraph\":",
                    "      return printChildren(path, options, print, {",
                    "        postprocessor: fill,",
                    "      });",
                    "    case \"sentence\":",
                    "      return printChildren(path, options, print);",
                    "    case \"word\": {",
                    "      let escapedValue = node.value",
                    "        .replace(/\\*/g, \"\\\\$&\") // escape all `*`",
                    "        .replace(",
                    "          new RegExp(",
                    "            [",
                    "              `(^|${punctuationPattern})(_+)`,",
                    "              `(_+)(${punctuationPattern}|$)`,",
                    "            ].join(\"|\"),",
                    "            \"g\"",
                    "          ),",
                    "          (_, text1, underscore1, underscore2, text2) =>",
                    "            (underscore1",
                    "              ? `${text1}${underscore1}`",
                    "              : `${underscore2}${text2}`",
                    "            ).replace(/_/g, \"\\\\_\")",
                    "        ); // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis",
                    "",
                    "      const isFirstSentence = (node, name, index) =>",
                    "        node.type === \"sentence\" && index === 0;",
                    "      const isLastChildAutolink = (node, name, index) =>",
                    "        isAutolink(node.children[index - 1]);",
                    "",
                    "      if (",
                    "        escapedValue !== node.value &&",
                    "        (path.match(undefined, isFirstSentence, isLastChildAutolink) ||",
                    "          path.match(",
                    "            undefined,",
                    "            isFirstSentence,",
                    "            (node, name, index) => node.type === \"emphasis\" && index === 0,",
                    "            isLastChildAutolink",
                    "          ))",
                    "      ) {",
                    "        // backslash is parsed as part of autolinks, so we need to remove it",
                    "        escapedValue = escapedValue.replace(/^(\\\\?[*_])+/, (prefix) =>",
                    "          prefix.replace(/\\\\/g, \"\")",
                    "        );",
                    "      }",
                    "",
                    "      return escapedValue;",
                    "    }",
                    "    case \"whitespace\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode.children.indexOf(node);",
                    "      const nextNode = parentNode.children[index + 1];",
                    "",
                    "      const proseWrap =",
                    "        // leading char that may cause different syntax",
                    "        nextNode && /^>|^(?:[*+-]|#{1,6}|\\d+[).])$/.test(nextNode.value)",
                    "          ? \"never\"",
                    "          : options.proseWrap;",
                    "",
                    "      return printLine(path, node.value, { proseWrap });",
                    "    }",
                    "    case \"emphasis\": {",
                    "      let style;",
                    "      if (isAutolink(node.children[0])) {",
                    "        style = options.originalText[node.position.start.offset];",
                    "      } else {",
                    "        const parentNode = path.getParentNode();",
                    "        const index = parentNode.children.indexOf(node);",
                    "        const prevNode = parentNode.children[index - 1];",
                    "        const nextNode = parentNode.children[index + 1];",
                    "        const hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not",
                    "          (prevNode &&",
                    "            prevNode.type === \"sentence\" &&",
                    "            prevNode.children.length > 0 &&",
                    "            getLast(prevNode.children).type === \"word\" &&",
                    "            !getLast(prevNode.children).hasTrailingPunctuation) ||",
                    "          (nextNode &&",
                    "            nextNode.type === \"sentence\" &&",
                    "            nextNode.children.length > 0 &&",
                    "            nextNode.children[0].type === \"word\" &&",
                    "            !nextNode.children[0].hasLeadingPunctuation);",
                    "        style =",
                    "          hasPrevOrNextWord || getAncestorNode(path, \"emphasis\") ? \"*\" : \"_\";",
                    "      }",
                    "      return [style, printChildren(path, options, print), style];",
                    "    }",
                    "    case \"strong\":",
                    "      return [\"**\", printChildren(path, options, print), \"**\"];",
                    "    case \"delete\":",
                    "      return [\"~~\", printChildren(path, options, print), \"~~\"];",
                    "    case \"inlineCode\": {",
                    "      const backtickCount = getMinNotPresentContinuousCount(node.value, \"`\");",
                    "      const style = \"`\".repeat(backtickCount || 1);",
                    "      const gap = backtickCount && !/^\\s/.test(node.value) ? \" \" : \"\";",
                    "      return [style, gap, node.value, gap, style];",
                    "    }",
                    "    case \"wikiLink\": {",
                    "      let contents = \"\";",
                    "      if (options.proseWrap === \"preserve\") {",
                    "        contents = node.value;",
                    "      } else {",
                    "        contents = node.value.replace(/[\\t\\n]+/g, \" \");",
                    "      }",
                    "",
                    "      return [\"[[\", contents, \"]]\"];",
                    "    }",
                    "    case \"link\":",
                    "      switch (options.originalText[node.position.start.offset]) {",
                    "        case \"<\": {",
                    "          const mailto = \"mailto:\";",
                    "          const url =",
                    "            // <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }",
                    "            node.url.startsWith(mailto) &&",
                    "            options.originalText.slice(",
                    "              node.position.start.offset + 1,",
                    "              node.position.start.offset + 1 + mailto.length",
                    "            ) !== mailto",
                    "              ? node.url.slice(mailto.length)",
                    "              : node.url;",
                    "          return [\"<\", url, \">\"];",
                    "        }",
                    "        case \"[\":",
                    "          return [",
                    "            \"[\",",
                    "            printChildren(path, options, print),",
                    "            \"](\",",
                    "            printUrl(node.url, \")\"),",
                    "            printTitle(node.title, options),",
                    "            \")\",",
                    "          ];",
                    "        default:",
                    "          return options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          );",
                    "      }",
                    "    case \"image\":",
                    "      return [",
                    "        \"![\",",
                    "        node.alt || \"\",",
                    "        \"](\",",
                    "        printUrl(node.url, \")\"),",
                    "        printTitle(node.title, options),",
                    "        \")\",",
                    "      ];",
                    "    case \"blockquote\":",
                    "      return [\"> \", align(\"> \", printChildren(path, options, print))];",
                    "    case \"heading\":",
                    "      return [",
                    "        \"#\".repeat(node.depth) + \" \",",
                    "        printChildren(path, options, print),",
                    "      ];",
                    "    case \"code\": {",
                    "      if (node.isIndented) {",
                    "        // indented code block",
                    "        const alignment = \" \".repeat(4);",
                    "        return align(alignment, [",
                    "          alignment,",
                    "          ...replaceTextEndOfLine(node.value, hardline),",
                    "        ]);",
                    "      }",
                    "",
                    "      // fenced code block",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "      );",
                    "      return [",
                    "        style,",
                    "        node.lang || \"\",",
                    "        node.meta ? \" \" + node.meta : \"\",",
                    "        hardline,",
                    "",
                    "        ...replaceTextEndOfLine(",
                    "          getFencedCodeBlockValue(node, options.originalText),",
                    "          hardline",
                    "        ),",
                    "        hardline,",
                    "        style,",
                    "      ];",
                    "    }",
                    "    case \"html\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const value =",
                    "        parentNode.type === \"root\" && getLast(parentNode.children) === node",
                    "          ? node.value.trimEnd()",
                    "          : node.value;",
                    "      const isHtmlComment = /^<!--.*-->$/s.test(value);",
                    "",
                    "      return replaceTextEndOfLine(",
                    "        value,",
                    "        // @ts-expect-error",
                    "        isHtmlComment ? hardline : markAsRoot(literalline)",
                    "      );",
                    "    }",
                    "    case \"list\": {",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        node,",
                    "        path.getParentNode()",
                    "      );",
                    "",
                    "      const isGitDiffFriendlyOrderedList = hasGitDiffFriendlyOrderedList(",
                    "        node,",
                    "        options",
                    "      );",
                    "",
                    "      return printChildren(path, options, print, {",
                    "        processor: (childPath, index) => {",
                    "          const prefix = getPrefix();",
                    "          const childNode = childPath.getValue();",
                    "",
                    "          if (",
                    "            childNode.children.length === 2 &&",
                    "            childNode.children[1].type === \"html\" &&",
                    "            childNode.children[0].position.start.column !==",
                    "              childNode.children[1].position.start.column",
                    "          ) {",
                    "            return [prefix, printListItem(childPath, options, print, prefix)];",
                    "          }",
                    "",
                    "          return [",
                    "            prefix,",
                    "            align(",
                    "              \" \".repeat(prefix.length),",
                    "              printListItem(childPath, options, print, prefix)",
                    "            ),",
                    "          ];",
                    "",
                    "          function getPrefix() {",
                    "            const rawPrefix = node.ordered",
                    "              ? (index === 0",
                    "                  ? node.start",
                    "                  : isGitDiffFriendlyOrderedList",
                    "                  ? 1",
                    "                  : node.start + index) +",
                    "                (nthSiblingIndex % 2 === 0 ? \". \" : \") \")",
                    "              : nthSiblingIndex % 2 === 0",
                    "              ? \"- \"",
                    "              : \"* \";",
                    "",
                    "            return node.isAligned ||",
                    "              /* workaround for https://github.com/remarkjs/remark/issues/315 */ node.hasIndentedCodeblock",
                    "              ? alignListPrefix(rawPrefix, options)",
                    "              : rawPrefix;",
                    "          }",
                    "        },",
                    "      });",
                    "    }",
                    "    case \"thematicBreak\": {",
                    "      const counter = getAncestorCounter(path, \"list\");",
                    "      if (counter === -1) {",
                    "        return \"---\";",
                    "      }",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        path.getParentNode(counter),",
                    "        path.getParentNode(counter + 1)",
                    "      );",
                    "      return nthSiblingIndex % 2 === 0 ? \"***\" : \"---\";",
                    "    }",
                    "    case \"linkReference\":",
                    "      return [",
                    "        \"[\",",
                    "        printChildren(path, options, print),",
                    "        \"]\",",
                    "        node.referenceType === \"full\"",
                    "          ? printLinkReference(node)",
                    "          : node.referenceType === \"collapsed\"",
                    "          ? \"[]\"",
                    "          : \"\",",
                    "      ];",
                    "    case \"imageReference\":",
                    "      switch (node.referenceType) {",
                    "        case \"full\":",
                    "          return [\"![\", node.alt || \"\", \"]\", printLinkReference(node)];",
                    "        default:",
                    "          return [",
                    "            \"![\",",
                    "            node.alt,",
                    "            \"]\",",
                    "            node.referenceType === \"collapsed\" ? \"[]\" : \"\",",
                    "          ];",
                    "      }",
                    "    case \"definition\": {",
                    "      const lineOrSpace = options.proseWrap === \"always\" ? line : \" \";",
                    "      return group([",
                    "        printLinkReference(node),",
                    "        \":\",",
                    "        indent([",
                    "          lineOrSpace,",
                    "          printUrl(node.url),",
                    "          node.title === null",
                    "            ? \"\"",
                    "            : [lineOrSpace, printTitle(node.title, options, false)],",
                    "        ]),",
                    "      ]);",
                    "    }",
                    "    // `footnote` requires `.use(footnotes, {inlineNotes: true})`, we are not using this option",
                    "    // https://github.com/remarkjs/remark-footnotes#optionsinlinenotes",
                    "    /* istanbul ignore next */",
                    "    case \"footnote\":",
                    "      return [\"[^\", printChildren(path, options, print), \"]\"];",
                    "    case \"footnoteReference\":",
                    "      return printFootnoteReference(node);",
                    "    case \"footnoteDefinition\": {",
                    "      const nextNode = path.getParentNode().children[path.getName() + 1];",
                    "      const shouldInlineFootnote =",
                    "        node.children.length === 1 &&",
                    "        node.children[0].type === \"paragraph\" &&",
                    "        (options.proseWrap === \"never\" ||",
                    "          (options.proseWrap === \"preserve\" &&",
                    "            node.children[0].position.start.line ===",
                    "              node.children[0].position.end.line));",
                    "      return [",
                    "        printFootnoteReference(node),",
                    "        \": \",",
                    "        shouldInlineFootnote",
                    "          ? printChildren(path, options, print)",
                    "          : group([",
                    "              align(",
                    "                \" \".repeat(4),",
                    "                printChildren(path, options, print, {",
                    "                  processor: (childPath, index) =>",
                    "                    index === 0 ? group([softline, print()]) : print(),",
                    "                })",
                    "              ),",
                    "              nextNode && nextNode.type === \"footnoteDefinition\"",
                    "                ? softline",
                    "                : \"\",",
                    "            ]),",
                    "      ];",
                    "    }",
                    "    case \"table\":",
                    "      return printTable(path, options, print);",
                    "    case \"tableCell\":",
                    "      return printChildren(path, options, print);",
                    "    case \"break\":",
                    "      return /\\s/.test(options.originalText[node.position.start.offset])",
                    "        ? [\"  \", markAsRoot(literalline)]",
                    "        : [\"\\\\\", hardline];",
                    "    case \"liquidNode\":",
                    "      return replaceTextEndOfLine(node.value, hardline);",
                    "    // MDX",
                    "    // fallback to the original text if multiparser failed",
                    "    // or `embeddedLanguageFormatting: \"off\"`",
                    "    case \"importExport\":",
                    "      return [node.value, hardline];",
                    "    case \"esComment\":",
                    "      return [\"{/* \", node.value, \" */}\"];",
                    "    case \"jsx\":",
                    "      return node.value;",
                    "    case \"math\":",
                    "      return [",
                    "        \"$$\",",
                    "        hardline,",
                    "        node.value",
                    "          ? [...replaceTextEndOfLine(node.value, hardline), hardline]",
                    "          : \"\",",
                    "        \"$$\",",
                    "      ];",
                    "    case \"inlineMath\": {",
                    "      // remark-math trims content but we don't want to remove whitespaces",
                    "      // since it's very possible that it's recognized as math accidentally",
                    "      return options.originalText.slice(locStart(node), locEnd(node));",
                    "    }",
                    "",
                    "    case \"tableRow\": // handled in \"table\"",
                    "    case \"listItem\": // handled in \"list\"",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unknown markdown type ${JSON.stringify(node.type)}`);",
                    "  }",
                    "}",
                    "",
                    "function printListItem(path, options, print, listPrefix) {",
                    "  const node = path.getValue();",
                    "  const prefix = node.checked === null ? \"\" : node.checked ? \"[x] \" : \"[ ] \";",
                    "  return [",
                    "    prefix,",
                    "    printChildren(path, options, print, {",
                    "      processor: (childPath, index) => {",
                    "        if (index === 0 && childPath.getValue().type !== \"list\") {",
                    "          return align(\" \".repeat(prefix.length), print());",
                    "        }",
                    "",
                    "        const alignment = \" \".repeat(",
                    "          clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block",
                    "        );",
                    "        return [alignment, align(alignment, print())];",
                    "      },",
                    "    }),",
                    "  ];",
                    "}",
                    "",
                    "function alignListPrefix(prefix, options) {",
                    "  const additionalSpaces = getAdditionalSpaces();",
                    "  return (",
                    "    prefix +",
                    "    \" \".repeat(",
                    "      additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block",
                    "    )",
                    "  );",
                    "",
                    "  function getAdditionalSpaces() {",
                    "    const restSpaces = prefix.length % options.tabWidth;",
                    "    return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;",
                    "  }",
                    "}",
                    "",
                    "function getNthListSiblingIndex(node, parentNode) {",
                    "  return getNthSiblingIndex(",
                    "    node,",
                    "    parentNode,",
                    "    (siblingNode) => siblingNode.ordered === node.ordered",
                    "  );",
                    "}",
                    "",
                    "function getNthSiblingIndex(node, parentNode, condition) {",
                    "  let index = -1;",
                    "",
                    "  for (const childNode of parentNode.children) {",
                    "    if (childNode.type === node.type && condition(childNode)) {",
                    "      index++;",
                    "    } else {",
                    "      index = -1;",
                    "    }",
                    "",
                    "    if (childNode === node) {",
                    "      return index;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getAncestorCounter(path, typeOrTypes) {",
                    "  const types = Array.isArray(typeOrTypes) ? typeOrTypes : [typeOrTypes];",
                    "",
                    "  let counter = -1;",
                    "  let ancestorNode;",
                    "",
                    "  while ((ancestorNode = path.getParentNode(++counter))) {",
                    "    if (types.includes(ancestorNode.type)) {",
                    "      return counter;",
                    "    }",
                    "  }",
                    "",
                    "  return -1;",
                    "}",
                    "",
                    "function getAncestorNode(path, typeOrTypes) {",
                    "  const counter = getAncestorCounter(path, typeOrTypes);",
                    "  return counter === -1 ? null : path.getParentNode(counter);",
                    "}",
                    "",
                    "function printLine(path, value, options) {",
                    "  if (options.proseWrap === \"preserve\" && value === \"\\n\") {",
                    "    return hardline;",
                    "  }",
                    "",
                    "  const isBreakable =",
                    "    options.proseWrap === \"always\" &&",
                    "    !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);",
                    "  return value !== \"\"",
                    "    ? isBreakable",
                    "      ? line",
                    "      : \" \"",
                    "    : isBreakable",
                    "    ? softline",
                    "    : \"\";",
                    "}",
                    "",
                    "function printTable(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  const columnMaxWidths = [];",
                    "  // { [rowIndex: number]: { [columnIndex: number]: {text: string, width: number} } }",
                    "  const contents = path.map(",
                    "    (rowPath) =>",
                    "      rowPath.map((cellPath, columnIndex) => {",
                    "        const text = printDocToString(print(), options).formatted;",
                    "        const width = getStringWidth(text);",
                    "        columnMaxWidths[columnIndex] = Math.max(",
                    "          columnMaxWidths[columnIndex] || 3, // minimum width = 3 (---, :--, :-:, --:)",
                    "          width",
                    "        );",
                    "        return { text, width };",
                    "      }, \"children\"),",
                    "    \"children\"",
                    "  );",
                    "",
                    "  const alignedTable = printTableContents(/* isCompact */ false);",
                    "  if (options.proseWrap !== \"never\") {",
                    "    return [breakParent, alignedTable];",
                    "  }",
                    "",
                    "  // Only if the --prose-wrap never is set and it exceeds the print width.",
                    "  const compactTable = printTableContents(/* isCompact */ true);",
                    "  return [breakParent, group(ifBreak(compactTable, alignedTable))];",
                    "",
                    "  function printTableContents(isCompact) {",
                    "    /** @type{Doc[]} */",
                    "    const parts = [printRow(contents[0], isCompact), printAlign(isCompact)];",
                    "    if (contents.length > 1) {",
                    "      parts.push(",
                    "        join(",
                    "          hardlineWithoutBreakParent,",
                    "          contents",
                    "            .slice(1)",
                    "            .map((rowContents) => printRow(rowContents, isCompact))",
                    "        )",
                    "      );",
                    "    }",
                    "    return join(hardlineWithoutBreakParent, parts);",
                    "  }",
                    "",
                    "  function printAlign(isCompact) {",
                    "    const align = columnMaxWidths.map((width, index) => {",
                    "      const align = node.align[index];",
                    "      const first = align === \"center\" || align === \"left\" ? \":\" : \"-\";",
                    "      const last = align === \"center\" || align === \"right\" ? \":\" : \"-\";",
                    "      const middle = isCompact ? \"-\" : \"-\".repeat(width - 2);",
                    "      return `${first}${middle}${last}`;",
                    "    });",
                    "",
                    "    return `| ${align.join(\" | \")} |`;",
                    "  }",
                    "",
                    "  function printRow(rowContents, isCompact) {",
                    "    const columns = rowContents.map(({ text, width }, columnIndex) => {",
                    "      if (isCompact) {",
                    "        return text;",
                    "      }",
                    "      const spaces = columnMaxWidths[columnIndex] - width;",
                    "      const align = node.align[columnIndex];",
                    "      let before = 0;",
                    "      if (align === \"right\") {",
                    "        before = spaces;",
                    "      } else if (align === \"center\") {",
                    "        before = Math.floor(spaces / 2);",
                    "      }",
                    "      const after = spaces - before;",
                    "      return `${\" \".repeat(before)}${text}${\" \".repeat(after)}`;",
                    "    });",
                    "",
                    "    return `| ${columns.join(\" | \")} |`;",
                    "  }",
                    "}",
                    "",
                    "function printRoot(path, options, print) {",
                    "  /** @typedef {{ index: number, offset: number }} IgnorePosition */",
                    "  /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */",
                    "  const ignoreRanges = [];",
                    "",
                    "  /** @type {IgnorePosition | null} */",
                    "  let ignoreStart = null;",
                    "",
                    "  const { children } = path.getValue();",
                    "  for (const [index, childNode] of children.entries()) {",
                    "    switch (isPrettierIgnore(childNode)) {",
                    "      case \"start\":",
                    "        if (ignoreStart === null) {",
                    "          ignoreStart = { index, offset: childNode.position.end.offset };",
                    "        }",
                    "        break;",
                    "      case \"end\":",
                    "        if (ignoreStart !== null) {",
                    "          ignoreRanges.push({",
                    "            start: ignoreStart,",
                    "            end: { index, offset: childNode.position.start.offset },",
                    "          });",
                    "          ignoreStart = null;",
                    "        }",
                    "        break;",
                    "      default:",
                    "        // do nothing",
                    "        break;",
                    "    }",
                    "  }",
                    "",
                    "  return printChildren(path, options, print, {",
                    "    processor: (childPath, index) => {",
                    "      if (ignoreRanges.length > 0) {",
                    "        const ignoreRange = ignoreRanges[0];",
                    "",
                    "        if (index === ignoreRange.start.index) {",
                    "          return [",
                    "            printIgnoreComment(children[ignoreRange.start.index]),",
                    "            options.originalText.slice(",
                    "              ignoreRange.start.offset,",
                    "              ignoreRange.end.offset",
                    "            ),",
                    "            printIgnoreComment(children[ignoreRange.end.index]),",
                    "          ];",
                    "        }",
                    "",
                    "        if (ignoreRange.start.index < index && index < ignoreRange.end.index) {",
                    "          return false;",
                    "        }",
                    "",
                    "        if (index === ignoreRange.end.index) {",
                    "          ignoreRanges.shift();",
                    "          return false;",
                    "        }",
                    "      }",
                    "",
                    "      return print();",
                    "    },",
                    "  });",
                    "}",
                    "",
                    "function printChildren(path, options, print, events = {}) {",
                    "  const { postprocessor } = events;",
                    "  const processor = events.processor || (() => print());",
                    "",
                    "  const node = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  let lastChildNode;",
                    "",
                    "  path.each((childPath, index) => {",
                    "    const childNode = childPath.getValue();",
                    "",
                    "    const result = processor(childPath, index);",
                    "    if (result !== false) {",
                    "      const data = {",
                    "        parts,",
                    "        prevNode: lastChildNode,",
                    "        parentNode: node,",
                    "        options,",
                    "      };",
                    "",
                    "      if (shouldPrePrintHardline(childNode, data)) {",
                    "        parts.push(hardline);",
                    "",
                    "        // Can't find a case to pass `shouldPrePrintTripleHardline`",
                    "        /* istanbul ignore next */",
                    "        if (lastChildNode && TRAILING_HARDLINE_NODES.has(lastChildNode.type)) {",
                    "          if (shouldPrePrintTripleHardline(childNode, data)) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        } else {",
                    "          if (",
                    "            shouldPrePrintDoubleHardline(childNode, data) ||",
                    "            shouldPrePrintTripleHardline(childNode, data)",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "",
                    "          if (shouldPrePrintTripleHardline(childNode, data)) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }",
                    "      }",
                    "",
                    "      parts.push(result);",
                    "",
                    "      lastChildNode = childNode;",
                    "    }",
                    "  }, \"children\");",
                    "",
                    "  return postprocessor ? postprocessor(parts) : parts;",
                    "}",
                    "",
                    "function printIgnoreComment(node) {",
                    "  if (node.type === \"html\") {",
                    "    return node.value;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"paragraph\" &&",
                    "    Array.isArray(node.children) &&",
                    "    node.children.length === 1 &&",
                    "    node.children[0].type === \"esComment\"",
                    "  ) {",
                    "    return [\"{/* \", node.children[0].value, \" */}\"];",
                    "  }",
                    "}",
                    "",
                    "function getLastDescendantNode(node) {",
                    "  let current = node;",
                    "  while (isNonEmptyArray(current.children)) {",
                    "    current = getLast(current.children);",
                    "  }",
                    "  return current;",
                    "}",
                    "",
                    "/** @return {false | 'next' | 'start' | 'end'} */",
                    "function isPrettierIgnore(node) {",
                    "  let match;",
                    "",
                    "  if (node.type === \"html\") {",
                    "    match = node.value.match(/^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/);",
                    "  } else {",
                    "    let comment;",
                    "",
                    "    if (node.type === \"esComment\") {",
                    "      comment = node;",
                    "    } else if (",
                    "      node.type === \"paragraph\" &&",
                    "      node.children.length === 1 &&",
                    "      node.children[0].type === \"esComment\"",
                    "    ) {",
                    "      comment = node.children[0];",
                    "    }",
                    "",
                    "    if (comment) {",
                    "      match = comment.value.match(/^prettier-ignore(?:-(start|end))?$/);",
                    "    }",
                    "  }",
                    "",
                    "  return match ? match[1] || \"next\" : false;",
                    "}",
                    "",
                    "function shouldPrePrintHardline(node, data) {",
                    "  const isFirstNode = data.parts.length === 0;",
                    "  const isInlineNode = INLINE_NODE_TYPES.includes(node.type);",
                    "",
                    "  const isInlineHTML =",
                    "    node.type === \"html\" &&",
                    "    INLINE_NODE_WRAPPER_TYPES.includes(data.parentNode.type);",
                    "",
                    "  return !isFirstNode && !isInlineNode && !isInlineHTML;",
                    "}",
                    "",
                    "function shouldPrePrintDoubleHardline(node, data) {",
                    "  const isSequence = (data.prevNode && data.prevNode.type) === node.type;",
                    "  const isSiblingNode = isSequence && SIBLING_NODE_TYPES.has(node.type);",
                    "",
                    "  const isInTightListItem =",
                    "    data.parentNode.type === \"listItem\" && !data.parentNode.loose;",
                    "",
                    "  const isPrevNodeLooseListItem =",
                    "    data.prevNode?.type === \"listItem\" && data.prevNode.loose;",
                    "",
                    "  const isPrevNodePrettierIgnore = isPrettierIgnore(data.prevNode) === \"next\";",
                    "",
                    "  const isBlockHtmlWithoutBlankLineBetweenPrevHtml =",
                    "    node.type === \"html\" &&",
                    "    data.prevNode?.type === \"html\" &&",
                    "    data.prevNode.position.end.line + 1 === node.position.start.line;",
                    "",
                    "  const isHtmlDirectAfterListItem =",
                    "    node.type === \"html\" &&",
                    "    data.parentNode.type === \"listItem\" &&",
                    "    data.prevNode?.type === \"paragraph\" &&",
                    "    data.prevNode.position.end.line + 1 === node.position.start.line;",
                    "",
                    "  return (",
                    "    isPrevNodeLooseListItem ||",
                    "    !(",
                    "      isSiblingNode ||",
                    "      isInTightListItem ||",
                    "      isPrevNodePrettierIgnore ||",
                    "      isBlockHtmlWithoutBlankLineBetweenPrevHtml ||",
                    "      isHtmlDirectAfterListItem",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function shouldPrePrintTripleHardline(node, data) {",
                    "  const isPrevNodeList = data.prevNode && data.prevNode.type === \"list\";",
                    "  const isIndentedCode = node.type === \"code\" && node.isIndented;",
                    "",
                    "  return isPrevNodeList && isIndentedCode;",
                    "}",
                    "",
                    "function shouldRemainTheSameContent(path) {",
                    "  const ancestorNode = getAncestorNode(path, [",
                    "    \"linkReference\",",
                    "    \"imageReference\",",
                    "  ]);",
                    "",
                    "  return (",
                    "    ancestorNode &&",
                    "    (ancestorNode.type !== \"linkReference\" ||",
                    "      ancestorNode.referenceType !== \"full\")",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} url",
                    " * @param {string[] | string} [dangerousCharOrChars]",
                    " * @returns {string}",
                    " */",
                    "function printUrl(url, dangerousCharOrChars = []) {",
                    "  const dangerousChars = [",
                    "    \" \",",
                    "    ...(Array.isArray(dangerousCharOrChars)",
                    "      ? dangerousCharOrChars",
                    "      : [dangerousCharOrChars]),",
                    "  ];",
                    "  return new RegExp(dangerousChars.map((x) => `\\\\${x}`).join(\"|\")).test(url)",
                    "    ? `<${url}>`",
                    "    : url;",
                    "}",
                    "",
                    "function printTitle(title, options, printSpace = true) {",
                    "  if (!title) {",
                    "    return \"\";",
                    "  }",
                    "  if (printSpace) {",
                    "    return \" \" + printTitle(title, options, false);",
                    "  }",
                    "",
                    "  // title is escaped after `remark-parse` v7",
                    "  title = title.replace(/\\\\([\"')])/g, \"$1\");",
                    "",
                    "  if (title.includes('\"') && title.includes(\"'\") && !title.includes(\")\")) {",
                    "    return `(${title})`; // avoid escaped quotes",
                    "  }",
                    "  // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split",
                    "  const singleCount = title.split(\"'\").length - 1;",
                    "  const doubleCount = title.split('\"').length - 1;",
                    "  const quote =",
                    "    singleCount > doubleCount",
                    "      ? '\"'",
                    "      : doubleCount > singleCount",
                    "      ? \"'\"",
                    "      : options.singleQuote",
                    "      ? \"'\"",
                    "      : '\"';",
                    "  title = title.replace(/\\\\/, \"\\\\\\\\\");",
                    "  title = title.replace(new RegExp(`(${quote})`, \"g\"), \"\\\\$1\");",
                    "  return `${quote}${title}${quote}`;",
                    "}",
                    "",
                    "function clamp(value, min, max) {",
                    "  return value < min ? min : value > max ? max : value;",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const index = Number(path.getName());",
                    "",
                    "  if (index === 0) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const prevNode = path.getParentNode().children[index - 1];",
                    "  return isPrettierIgnore(prevNode) === \"next\";",
                    "}",
                    "",
                    "// `remark-parse` lowercase the `label` as `identifier`, we don't want do that",
                    "// https://github.com/remarkjs/remark/blob/daddcb463af2d5b2115496c395d0571c0ff87d15/packages/remark-parse/lib/tokenize/reference.js",
                    "function printLinkReference(node) {",
                    "  return `[${collapseWhiteSpace(node.label)}]`;",
                    "}",
                    "",
                    "function printFootnoteReference(node) {",
                    "  return `[^${node.label}]`;",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  embed,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { getLast } = require(\"../common/util.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const {",
                    "  cjkPattern,",
                    "  kPattern,",
                    "  punctuationPattern,",
                    "} = require(\"./constants.evaluate.js\");",
                    "",
                    "const INLINE_NODE_TYPES = [",
                    "  \"liquidNode\",",
                    "  \"inlineCode\",",
                    "  \"emphasis\",",
                    "  \"esComment\",",
                    "  \"strong\",",
                    "  \"delete\",",
                    "  \"wikiLink\",",
                    "  \"link\",",
                    "  \"linkReference\",",
                    "  \"image\",",
                    "  \"imageReference\",",
                    "  \"footnote\",",
                    "  \"footnoteReference\",",
                    "  \"sentence\",",
                    "  \"whitespace\",",
                    "  \"word\",",
                    "  \"break\",",
                    "  \"inlineMath\",",
                    "];",
                    "",
                    "const INLINE_NODE_WRAPPER_TYPES = [",
                    "  ...INLINE_NODE_TYPES,",
                    "  \"tableCell\",",
                    "  \"paragraph\",",
                    "  \"heading\",",
                    "];",
                    "",
                    "const kRegex = new RegExp(kPattern);",
                    "const punctuationRegex = new RegExp(punctuationPattern);",
                    "",
                    "/**",
                    " * split text into whitespaces and words",
                    " * @param {string} text",
                    " */",
                    "function splitText(text, options) {",
                    "  const KIND_NON_CJK = \"non-cjk\";",
                    "  const KIND_CJ_LETTER = \"cj-letter\";",
                    "  const KIND_K_LETTER = \"k-letter\";",
                    "  const KIND_CJK_PUNCTUATION = \"cjk-punctuation\";",
                    "",
                    "  /** @type {Array<{ type: \"whitespace\", value: \" \" | \"\\n\" | \"\" } | { type: \"word\", value: string }>} */",
                    "  const nodes = [];",
                    "",
                    "  const tokens = (",
                    "    options.proseWrap === \"preserve\"",
                    "      ? text",
                    "      : text.replace(",
                    "          new RegExp(`(${cjkPattern})\\n(${cjkPattern})`, \"g\"),",
                    "          \"$1$2\"",
                    "        )",
                    "  ).split(/([\\t\\n ]+)/);",
                    "  for (const [index, token] of tokens.entries()) {",
                    "    // whitespace",
                    "    if (index % 2 === 1) {",
                    "      nodes.push({",
                    "        type: \"whitespace\",",
                    "        value: /\\n/.test(token) ? \"\\n\" : \" \",",
                    "      });",
                    "      continue;",
                    "    }",
                    "",
                    "    // word separated by whitespace",
                    "",
                    "    if ((index === 0 || index === tokens.length - 1) && token === \"\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    const innerTokens = token.split(new RegExp(`(${cjkPattern})`));",
                    "    for (const [innerIndex, innerToken] of innerTokens.entries()) {",
                    "      if (",
                    "        (innerIndex === 0 || innerIndex === innerTokens.length - 1) &&",
                    "        innerToken === \"\"",
                    "      ) {",
                    "        continue;",
                    "      }",
                    "",
                    "      // non-CJK word",
                    "      if (innerIndex % 2 === 0) {",
                    "        if (innerToken !== \"\") {",
                    "          appendNode({",
                    "            type: \"word\",",
                    "            value: innerToken,",
                    "            kind: KIND_NON_CJK,",
                    "            hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),",
                    "            hasTrailingPunctuation: punctuationRegex.test(getLast(innerToken)),",
                    "          });",
                    "        }",
                    "        continue;",
                    "      }",
                    "",
                    "      // CJK character",
                    "      appendNode(",
                    "        punctuationRegex.test(innerToken)",
                    "          ? {",
                    "              type: \"word\",",
                    "              value: innerToken,",
                    "              kind: KIND_CJK_PUNCTUATION,",
                    "              hasLeadingPunctuation: true,",
                    "              hasTrailingPunctuation: true,",
                    "            }",
                    "          : {",
                    "              type: \"word\",",
                    "              value: innerToken,",
                    "              kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,",
                    "              hasLeadingPunctuation: false,",
                    "              hasTrailingPunctuation: false,",
                    "            }",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return nodes;",
                    "",
                    "  function appendNode(node) {",
                    "    const lastNode = getLast(nodes);",
                    "    if (lastNode && lastNode.type === \"word\") {",
                    "      if (",
                    "        (lastNode.kind === KIND_NON_CJK &&",
                    "          node.kind === KIND_CJ_LETTER &&",
                    "          !lastNode.hasTrailingPunctuation) ||",
                    "        (lastNode.kind === KIND_CJ_LETTER &&",
                    "          node.kind === KIND_NON_CJK &&",
                    "          !node.hasLeadingPunctuation)",
                    "      ) {",
                    "        nodes.push({ type: \"whitespace\", value: \" \" });",
                    "      } else if (",
                    "        !isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) &&",
                    "        // disallow leading/trailing full-width whitespace",
                    "        ![lastNode.value, node.value].some((value) => /\\u3000/.test(value))",
                    "      ) {",
                    "        nodes.push({ type: \"whitespace\", value: \"\" });",
                    "      }",
                    "    }",
                    "    nodes.push(node);",
                    "",
                    "    function isBetween(kind1, kind2) {",
                    "      return (",
                    "        (lastNode.kind === kind1 && node.kind === kind2) ||",
                    "        (lastNode.kind === kind2 && node.kind === kind1)",
                    "      );",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getOrderedListItemInfo(orderListItem, originalText) {",
                    "  const [, numberText, marker, leadingSpaces] = originalText",
                    "    .slice(",
                    "      orderListItem.position.start.offset,",
                    "      orderListItem.position.end.offset",
                    "    )",
                    "    .match(/^\\s*(\\d+)(\\.|\\))(\\s*)/);",
                    "",
                    "  return { numberText, marker, leadingSpaces };",
                    "}",
                    "",
                    "function hasGitDiffFriendlyOrderedList(node, options) {",
                    "  if (!node.ordered) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (node.children.length < 2) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const firstNumber = Number(",
                    "    getOrderedListItemInfo(node.children[0], options.originalText).numberText",
                    "  );",
                    "",
                    "  const secondNumber = Number(",
                    "    getOrderedListItemInfo(node.children[1], options.originalText).numberText",
                    "  );",
                    "",
                    "  if (firstNumber === 0 && node.children.length > 2) {",
                    "    const thirdNumber = Number(",
                    "      getOrderedListItemInfo(node.children[2], options.originalText).numberText",
                    "    );",
                    "",
                    "    return secondNumber === 1 && thirdNumber === 1;",
                    "  }",
                    "",
                    "  return secondNumber === 1;",
                    "}",
                    "",
                    "// The final new line should not include in value",
                    "// https://github.com/remarkjs/remark/issues/512",
                    "function getFencedCodeBlockValue(node, originalText) {",
                    "  const { value } = node;",
                    "  if (",
                    "    node.position.end.offset === originalText.length &&",
                    "    value.endsWith(\"\\n\") &&",
                    "    // Code block has no end mark",
                    "    originalText.endsWith(\"\\n\")",
                    "  ) {",
                    "    return value.slice(0, -1);",
                    "  }",
                    "  return value;",
                    "}",
                    "",
                    "function mapAst(ast, handler) {",
                    "  return (function preorder(node, index, parentStack) {",
                    "    const newNode = { ...handler(node, index, parentStack) };",
                    "    if (newNode.children) {",
                    "      newNode.children = newNode.children.map((child, index) =>",
                    "        preorder(child, index, [newNode, ...parentStack])",
                    "      );",
                    "    }",
                    "",
                    "    return newNode;",
                    "  })(ast, null, []);",
                    "}",
                    "",
                    "function isAutolink(node) {",
                    "  if (node?.type !== \"link\" || node.children.length !== 1) {",
                    "    return false;",
                    "  }",
                    "  const [child] = node.children;",
                    "  return locStart(node) === locStart(child) && locEnd(node) === locEnd(child);",
                    "}",
                    "",
                    "module.exports = {",
                    "  mapAst,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  getFencedCodeBlockValue,",
                    "  getOrderedListItemInfo,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "  isAutolink,",
                    "};"
                ]
            },
            "unified-plugins": {
                "front-matter.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const parseFrontMatter = require(\"../../utils/front-matter/parse.js\");",
                        "",
                        "function frontMatter() {",
                        "  const proto = this.Parser.prototype;",
                        "  proto.blockMethods = [\"frontMatter\", ...proto.blockMethods];",
                        "  proto.blockTokenizers.frontMatter = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const parsed = parseFrontMatter(value);",
                        "",
                        "    if (parsed.frontMatter) {",
                        "      return eat(parsed.frontMatter.raw)(parsed.frontMatter);",
                        "    }",
                        "  }",
                        "  tokenizer.onlyAtStart = true;",
                        "}",
                        "",
                        "module.exports = frontMatter;"
                    ]
                },
                "html-to-jsx.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const mdx = require(\"../mdx.js\");",
                        "const { mapAst, INLINE_NODE_WRAPPER_TYPES } = require(\"../utils.js\");",
                        "",
                        "function htmlToJsx() {",
                        "  return (ast) =>",
                        "    mapAst(ast, (node, _index, [parent]) => {",
                        "      if (",
                        "        node.type !== \"html\" ||",
                        "        // Keep HTML-style comments (legacy MDX)",
                        "        mdx.COMMENT_REGEX.test(node.value) ||",
                        "        INLINE_NODE_WRAPPER_TYPES.includes(parent.type)",
                        "      ) {",
                        "        return node;",
                        "      }",
                        "      return { ...node, type: \"jsx\" };",
                        "    });",
                        "}",
                        "",
                        "module.exports = htmlToJsx;"
                    ]
                },
                "liquid.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function liquid() {",
                        "  const proto = this.Parser.prototype;",
                        "  const methods = proto.inlineMethods;",
                        "  methods.splice(methods.indexOf(\"text\"), 0, \"liquid\");",
                        "  proto.inlineTokenizers.liquid = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const match = value.match(/^({%.*?%}|{{.*?}})/s);",
                        "",
                        "    if (match) {",
                        "      return eat(match[0])({",
                        "        type: \"liquidNode\",",
                        "        value: match[0],",
                        "      });",
                        "    }",
                        "  }",
                        "  tokenizer.locator = function (value, fromIndex) {",
                        "    return value.indexOf(\"{\", fromIndex);",
                        "  };",
                        "}",
                        "",
                        "module.exports = liquid;"
                    ]
                },
                "loose-items.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function looseItems() {",
                        "  const proto = this.Parser.prototype;",
                        "  const originalList = proto.blockTokenizers.list;",
                        "",
                        "  function fixListNodes(value, node, parent) {",
                        "    if (node.type === \"listItem\") {",
                        "      node.loose = node.spread || value.charAt(value.length - 1) === \"\\n\";",
                        "      if (node.loose) {",
                        "        parent.loose = true;",
                        "      }",
                        "    }",
                        "    return node;",
                        "  }",
                        "",
                        "  proto.blockTokenizers.list = function list(realEat, value, silent) {",
                        "    function eat(subvalue) {",
                        "      const realAdd = realEat(subvalue);",
                        "",
                        "      function add(node, parent) {",
                        "        return realAdd(fixListNodes(subvalue, node, parent), parent);",
                        "      }",
                        "      add.reset = function (node, parent) {",
                        "        return realAdd.reset(fixListNodes(subvalue, node, parent), parent);",
                        "      };",
                        "",
                        "      return add;",
                        "    }",
                        "    eat.now = realEat.now;",
                        "    return originalList.call(this, eat, value, silent);",
                        "  };",
                        "}",
                        "",
                        "module.exports = looseItems;"
                    ]
                },
                "wiki-link.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function wikiLink() {",
                        "  const entityType = \"wikiLink\";",
                        "  const wikiLinkRegex = /^\\[\\[(?<linkContents>.+?)]]/s;",
                        "  const proto = this.Parser.prototype;",
                        "  const methods = proto.inlineMethods;",
                        "  methods.splice(methods.indexOf(\"link\"), 0, entityType);",
                        "  proto.inlineTokenizers.wikiLink = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const match = wikiLinkRegex.exec(value);",
                        "",
                        "    if (match) {",
                        "      const linkContents = match.groups.linkContents.trim();",
                        "",
                        "      return eat(match[0])({",
                        "        type: entityType,",
                        "        value: linkContents,",
                        "      });",
                        "    }",
                        "  }",
                        "",
                        "  tokenizer.locator = function (value, fromIndex) {",
                        "    return value.indexOf(\"[\", fromIndex);",
                        "  };",
                        "}",
                        "",
                        "module.exports = wikiLink;"
                    ]
                }
            }
        },
        "language-yaml": {
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  // Try to format `.prettierrc`, `.stylelintrc`, and `.lintstagedrc` as `json` first",
                    "  if (",
                    "    node.type === \"root\" &&",
                    "    options.filepath &&",
                    "    /(?:[/\\\\]|^)\\.(?:prettier|stylelint|lintstaged)rc$/.test(options.filepath)",
                    "  ) {",
                    "    return textToDoc(options.originalText, { ...options, parser: \"json\" });",
                    "  }",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-yaml.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/YAML.json\"), (data) => ({",
                    "    since: \"1.14.0\",",
                    "    parsers: [\"yaml\"],",
                    "    vscodeLanguageIds: [\"yaml\", \"ansible\", \"home-assistant\"],",
                    "    // yarn.lock is not YAML: https://github.com/yarnpkg/yarn/issues/5629",
                    "    filenames: [",
                    "      ...data.filenames.filter((filename) => filename !== \"yarn.lock\"),",
                    "      \".prettierrc\",",
                    "      \".stylelintrc\",",
                    "      \".lintstagedrc\",",
                    "    ],",
                    "  })),",
                    "];",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  printers: { yaml: printer },",
                    "  options,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  return node.position.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.position.end.offset;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  proseWrap: commonOptions.proseWrap,",
                    "};"
                ]
            },
            "parser-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const { hasPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "function parse(text) {",
                    "  const { parse } = require(\"yaml-unist-parser\");",
                    "",
                    "  try {",
                    "    const root = parse(text);",
                    "",
                    "    /**",
                    "     * suppress `comment not printed` error",
                    "     *",
                    "     * comments are handled in printer-yaml.js without using `printComment`",
                    "     * so that it'll always throw errors even if we printed it correctly",
                    "     */",
                    "    delete root.comments;",
                    "",
                    "    return root;",
                    "  } catch (error) {",
                    "    if (error?.position) {",
                    "      throw createError(error.message, error.position);",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw error;",
                    "  }",
                    "}",
                    "",
                    "const parser = {",
                    "  astFormat: \"yaml\",",
                    "  parse,",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    yaml: parser,",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  get yaml() {",
                    "    return require(\"./parser-yaml.js\").parsers.yaml;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function isPragma(text) {",
                    "  return /^\\s*@(?:prettier|format)\\s*$/.test(text);",
                    "}",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(?:prettier|format)\\s*?(?:\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return `# @format\\n\\n${text}`;",
                    "}",
                    "",
                    "module.exports = {",
                    "  isPragma,",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const { defineShortcut, mapNode } = require(\"./utils.js\");",
                    "",
                    "function preprocess(ast) {",
                    "  return mapNode(ast, defineShortcuts);",
                    "}",
                    "",
                    "function defineShortcuts(node) {",
                    "  switch (node.type) {",
                    "    case \"document\":",
                    "      defineShortcut(node, \"head\", () => node.children[0]);",
                    "      defineShortcut(node, \"body\", () => node.children[1]);",
                    "      break;",
                    "    case \"documentBody\":",
                    "    case \"sequenceItem\":",
                    "    case \"flowSequenceItem\":",
                    "    case \"mappingKey\":",
                    "    case \"mappingValue\":",
                    "      defineShortcut(node, \"content\", () => node.children[0]);",
                    "      break;",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\":",
                    "      defineShortcut(node, \"key\", () => node.children[0]);",
                    "      defineShortcut(node, \"value\", () => node.children[1]);",
                    "      break;",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/** @typedef {import(\"../document\").Doc} Doc */",
                    "",
                    "const {",
                    "  builders: {",
                    "    breakParent,",
                    "    fill,",
                    "    group,",
                    "    hardline,",
                    "    join,",
                    "    line,",
                    "    lineSuffix,",
                    "    literalline,",
                    "  },",
                    "  utils: { getDocParts, replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const { isPreviousLineEmpty } = require(\"../common/util.js\");",
                    "const { insertPragma, isPragma } = require(\"./pragma.js\");",
                    "const { locStart } = require(\"./loc.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const {",
                    "  getFlowScalarLineContents,",
                    "  getLastDescendantNode,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "  hasPrettierIgnore,",
                    "  isLastDescendantNode,",
                    "  isNode,",
                    "  isInlineNode,",
                    "} = require(\"./utils.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "const {",
                    "  alignWithSpaces,",
                    "  printNextEmptyLine,",
                    "  shouldPrintEndComments,",
                    "} = require(\"./print/misc.js\");",
                    "const {",
                    "  printFlowMapping,",
                    "  printFlowSequence,",
                    "} = require(\"./print/flow-mapping-sequence.js\");",
                    "const printMappingItem = require(\"./print/mapping-item.js\");",
                    "const printBlock = require(\"./print/block.js\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "  /** @type {Doc[]} */",
                    "  const parts = [];",
                    "",
                    "  if (node.type !== \"mappingValue\" && hasLeadingComments(node)) {",
                    "    parts.push([join(hardline, path.map(print, \"leadingComments\")), hardline]);",
                    "  }",
                    "",
                    "  const { tag, anchor } = node;",
                    "  if (tag) {",
                    "    parts.push(print(\"tag\"));",
                    "  }",
                    "  if (tag && anchor) {",
                    "    parts.push(\" \");",
                    "  }",
                    "  if (anchor) {",
                    "    parts.push(print(\"anchor\"));",
                    "  }",
                    "",
                    "  /** @type {Doc} */",
                    "  let nextEmptyLine = \"\";",
                    "",
                    "  if (",
                    "    isNode(node, [",
                    "      \"mapping\",",
                    "      \"sequence\",",
                    "      \"comment\",",
                    "      \"directive\",",
                    "      \"mappingItem\",",
                    "      \"sequenceItem\",",
                    "    ]) &&",
                    "    !isLastDescendantNode(path)",
                    "  ) {",
                    "    nextEmptyLine = printNextEmptyLine(path, options.originalText);",
                    "  }",
                    "",
                    "  if (tag || anchor) {",
                    "    if (isNode(node, [\"sequence\", \"mapping\"]) && !hasMiddleComments(node)) {",
                    "      parts.push(hardline);",
                    "    } else {",
                    "      parts.push(\" \");",
                    "    }",
                    "  }",
                    "",
                    "  if (hasMiddleComments(node)) {",
                    "    parts.push([",
                    "      node.middleComments.length === 1 ? \"\" : hardline,",
                    "      join(hardline, path.map(print, \"middleComments\")),",
                    "      hardline,",
                    "    ]);",
                    "  }",
                    "",
                    "  const parentNode = path.getParentNode();",
                    "  if (hasPrettierIgnore(path)) {",
                    "    parts.push(",
                    "      replaceTextEndOfLine(",
                    "        options.originalText",
                    "          .slice(node.position.start.offset, node.position.end.offset)",
                    "          .trimEnd(),",
                    "        literalline",
                    "      )",
                    "    );",
                    "  } else {",
                    "    parts.push(group(printNode(node, parentNode, path, options, print)));",
                    "  }",
                    "",
                    "  if (hasTrailingComment(node) && !isNode(node, [\"document\", \"documentHead\"])) {",
                    "    parts.push(",
                    "      lineSuffix([",
                    "        node.type === \"mappingValue\" && !node.content ? \"\" : \" \",",
                    "        parentNode.type === \"mappingKey\" &&",
                    "        path.getParentNode(2).type === \"mapping\" &&",
                    "        isInlineNode(node)",
                    "          ? \"\"",
                    "          : breakParent,",
                    "        print(\"trailingComment\"),",
                    "      ])",
                    "    );",
                    "  }",
                    "",
                    "  if (shouldPrintEndComments(node)) {",
                    "    parts.push(",
                    "      alignWithSpaces(node.type === \"sequenceItem\" ? 2 : 0, [",
                    "        hardline,",
                    "        join(",
                    "          hardline,",
                    "          path.map(",
                    "            (path) => [",
                    "              isPreviousLineEmpty(",
                    "                options.originalText,",
                    "                path.getValue(),",
                    "                locStart",
                    "              )",
                    "                ? hardline",
                    "                : \"\",",
                    "              print(),",
                    "            ],",
                    "            \"endComments\"",
                    "          )",
                    "        ),",
                    "      ])",
                    "    );",
                    "  }",
                    "  parts.push(nextEmptyLine);",
                    "  return parts;",
                    "}",
                    "",
                    "function printNode(node, parentNode, path, options, print) {",
                    "  switch (node.type) {",
                    "    case \"root\": {",
                    "      const { children } = node;",
                    "      const parts = [];",
                    "      path.each((childPath, index) => {",
                    "        const document = children[index];",
                    "        const nextDocument = children[index + 1];",
                    "        if (index !== 0) {",
                    "          parts.push(hardline);",
                    "        }",
                    "        parts.push(print());",
                    "        if (shouldPrintDocumentEndMarker(document, nextDocument)) {",
                    "          parts.push(hardline, \"...\");",
                    "          if (hasTrailingComment(document)) {",
                    "            parts.push(\" \", print(\"trailingComment\"));",
                    "          }",
                    "        } else if (nextDocument && !hasTrailingComment(nextDocument.head)) {",
                    "          parts.push(hardline, \"---\");",
                    "        }",
                    "      }, \"children\");",
                    "",
                    "      const lastDescendantNode = getLastDescendantNode(node);",
                    "      if (",
                    "        !isNode(lastDescendantNode, [\"blockLiteral\", \"blockFolded\"]) ||",
                    "        lastDescendantNode.chomping !== \"keep\"",
                    "      ) {",
                    "        parts.push(hardline);",
                    "      }",
                    "      return parts;",
                    "    }",
                    "    case \"document\": {",
                    "      const nextDocument = parentNode.children[path.getName() + 1];",
                    "      const parts = [];",
                    "      if (",
                    "        shouldPrintDocumentHeadEndMarker(",
                    "          node,",
                    "          nextDocument,",
                    "          parentNode,",
                    "          options",
                    "        ) === \"head\"",
                    "      ) {",
                    "        if (node.head.children.length > 0 || node.head.endComments.length > 0) {",
                    "          parts.push(print(\"head\"));",
                    "        }",
                    "",
                    "        if (hasTrailingComment(node.head)) {",
                    "          parts.push([\"---\", \" \", print([\"head\", \"trailingComment\"])]);",
                    "        } else {",
                    "          parts.push(\"---\");",
                    "        }",
                    "      }",
                    "",
                    "      if (shouldPrintDocumentBody(node)) {",
                    "        parts.push(print(\"body\"));",
                    "      }",
                    "",
                    "      return join(hardline, parts);",
                    "    }",
                    "    case \"documentHead\":",
                    "      return join(hardline, [",
                    "        ...path.map(print, \"children\"),",
                    "        ...path.map(print, \"endComments\"),",
                    "      ]);",
                    "    case \"documentBody\": {",
                    "      const { children, endComments } = node;",
                    "      /** @type {Doc} */",
                    "      let separator = \"\";",
                    "      if (children.length > 0 && endComments.length > 0) {",
                    "        const lastDescendantNode = getLastDescendantNode(node);",
                    "        // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)",
                    "        if (isNode(lastDescendantNode, [\"blockFolded\", \"blockLiteral\"])) {",
                    "          // an extra newline for better readability",
                    "          if (lastDescendantNode.chomping !== \"keep\") {",
                    "            separator = [hardline, hardline];",
                    "          }",
                    "        } else {",
                    "          separator = hardline;",
                    "        }",
                    "      }",
                    "",
                    "      return [",
                    "        join(hardline, path.map(print, \"children\")),",
                    "        separator,",
                    "        join(hardline, path.map(print, \"endComments\")),",
                    "      ];",
                    "    }",
                    "    case \"directive\":",
                    "      return [\"%\", join(\" \", [node.name, ...node.parameters])];",
                    "    case \"comment\":",
                    "      return [\"#\", node.value];",
                    "    case \"alias\":",
                    "      return [\"*\", node.value];",
                    "    case \"tag\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"anchor\":",
                    "      return [\"&\", node.value];",
                    "    case \"plain\":",
                    "      return printFlowScalarContent(",
                    "        node.type,",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        ),",
                    "        options",
                    "      );",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\": {",
                    "      const singleQuote = \"'\";",
                    "      const doubleQuote = '\"';",
                    "",
                    "      const raw = options.originalText.slice(",
                    "        node.position.start.offset + 1,",
                    "        node.position.end.offset - 1",
                    "      );",
                    "",
                    "      if (",
                    "        (node.type === \"quoteSingle\" && raw.includes(\"\\\\\")) ||",
                    "        (node.type === \"quoteDouble\" && /\\\\[^\"]/.test(raw))",
                    "      ) {",
                    "        // only quoteDouble can use escape chars",
                    "        // and quoteSingle do not need to escape backslashes",
                    "        const originalQuote =",
                    "          node.type === \"quoteDouble\" ? doubleQuote : singleQuote;",
                    "        return [",
                    "          originalQuote,",
                    "          printFlowScalarContent(node.type, raw, options),",
                    "          originalQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      if (raw.includes(doubleQuote)) {",
                    "        return [",
                    "          singleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteDouble\"",
                    "              ? raw",
                    "                  // double quote needs to be escaped by backslash in quoteDouble",
                    "                  .replace(/\\\\\"/g, doubleQuote)",
                    "                  .replace(/'/g, singleQuote.repeat(2))",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          singleQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      if (raw.includes(singleQuote)) {",
                    "        return [",
                    "          doubleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteSingle\"",
                    "              ? // single quote needs to be escaped by 2 single quotes in quoteSingle",
                    "                raw.replace(/''/g, singleQuote)",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          doubleQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      const quote = options.singleQuote ? singleQuote : doubleQuote;",
                    "      return [quote, printFlowScalarContent(node.type, raw, options), quote];",
                    "    }",
                    "    case \"blockFolded\":",
                    "    case \"blockLiteral\": {",
                    "      return printBlock(path, print, options);",
                    "    }",
                    "    case \"mapping\":",
                    "    case \"sequence\":",
                    "      return join(hardline, path.map(print, \"children\"));",
                    "    case \"sequenceItem\":",
                    "      return [\"- \", alignWithSpaces(2, node.content ? print(\"content\") : \"\")];",
                    "    case \"mappingKey\":",
                    "    case \"mappingValue\":",
                    "      return !node.content ? \"\" : print(\"content\");",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\": {",
                    "      return printMappingItem(node, parentNode, path, print, options);",
                    "    }",
                    "    case \"flowMapping\":",
                    "      return printFlowMapping(path, print, options);",
                    "    case \"flowSequence\":",
                    "      return printFlowSequence(path, print, options);",
                    "    case \"flowSequenceItem\":",
                    "      return print(\"content\");",
                    "    // istanbul ignore next",
                    "    default:",
                    "      throw new Error(`Unexpected node type ${node.type}`);",
                    "  }",
                    "}",
                    "",
                    "function shouldPrintDocumentBody(document) {",
                    "  return document.body.children.length > 0 || hasEndComments(document.body);",
                    "}",
                    "",
                    "function shouldPrintDocumentEndMarker(document, nextDocument) {",
                    "  return (",
                    "    /**",
                    "     *... # trailingComment",
                    "     */",
                    "    hasTrailingComment(document) ||",
                    "    (nextDocument &&",
                    "      /**",
                    "       * ...",
                    "       * %DIRECTIVE",
                    "       * ---",
                    "       */",
                    "      (nextDocument.head.children.length > 0 ||",
                    "        /**",
                    "         * ...",
                    "         * # endComment",
                    "         * ---",
                    "         */",
                    "        hasEndComments(nextDocument.head)))",
                    "  );",
                    "}",
                    "",
                    "function shouldPrintDocumentHeadEndMarker(",
                    "  document,",
                    "  nextDocument,",
                    "  root,",
                    "  options",
                    ") {",
                    "  if (",
                    "    /**",
                    "     * ---",
                    "     * preserve the first document head end marker",
                    "     */",
                    "    (root.children[0] === document &&",
                    "      /---(?:\\s|$)/.test(",
                    "        options.originalText.slice(locStart(document), locStart(document) + 4)",
                    "      )) ||",
                    "    /**",
                    "     * %DIRECTIVE",
                    "     * ---",
                    "     */",
                    "    document.head.children.length > 0 ||",
                    "    /**",
                    "     * # end comment",
                    "     * ---",
                    "     */",
                    "    hasEndComments(document.head) ||",
                    "    /**",
                    "     * --- # trailing comment",
                    "     */",
                    "    hasTrailingComment(document.head)",
                    "  ) {",
                    "    return \"head\";",
                    "  }",
                    "",
                    "  if (shouldPrintDocumentEndMarker(document, nextDocument)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return nextDocument ? \"root\" : false;",
                    "}",
                    "",
                    "function printFlowScalarContent(nodeType, content, options) {",
                    "  const lineContents = getFlowScalarLineContents(nodeType, content, options);",
                    "  return join(",
                    "    hardline,",
                    "    lineContents.map((lineContentWords) =>",
                    "      fill(getDocParts(join(line, lineContentWords)))",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function clean(node, newNode /*, parent */) {",
                    "  if (isNode(newNode)) {",
                    "    delete newNode.position;",
                    "    switch (newNode.type) {",
                    "      case \"comment\":",
                    "        // insert pragma",
                    "        if (isPragma(newNode.value)) {",
                    "          return null;",
                    "        }",
                    "        break;",
                    "      case \"quoteDouble\":",
                    "      case \"quoteSingle\":",
                    "        newNode.type = \"quote\";",
                    "        break;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  embed,",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { getLast, isNonEmptyArray } = require(\"../common/util.js\");",
                    "",
                    "function getAncestorCount(path, filter) {",
                    "  let counter = 0;",
                    "  const pathStackLength = path.stack.length - 1;",
                    "  for (let i = 0; i < pathStackLength; i++) {",
                    "    const value = path.stack[i];",
                    "    if (isNode(value) && filter(value)) {",
                    "      counter++;",
                    "    }",
                    "  }",
                    "  return counter;",
                    "}",
                    "",
                    "/**",
                    " * @param {any} value",
                    " * @param {string[]=} types",
                    " */",
                    "function isNode(value, types) {",
                    "  return (",
                    "    value &&",
                    "    typeof value.type === \"string\" &&",
                    "    (!types || types.includes(value.type))",
                    "  );",
                    "}",
                    "",
                    "function mapNode(node, callback, parent) {",
                    "  return callback(",
                    "    \"children\" in node",
                    "      ? {",
                    "          ...node,",
                    "          children: node.children.map((childNode) =>",
                    "            mapNode(childNode, callback, node)",
                    "          ),",
                    "        }",
                    "      : node,",
                    "    parent",
                    "  );",
                    "}",
                    "",
                    "function defineShortcut(x, key, getter) {",
                    "  Object.defineProperty(x, key, {",
                    "    get: getter,",
                    "    enumerable: false,",
                    "  });",
                    "}",
                    "",
                    "function isNextLineEmpty(node, text) {",
                    "  let newlineCount = 0;",
                    "  const textLength = text.length;",
                    "  for (let i = node.position.end.offset - 1; i < textLength; i++) {",
                    "    const char = text[i];",
                    "",
                    "    if (char === \"\\n\") {",
                    "      newlineCount++;",
                    "    }",
                    "",
                    "    if (newlineCount === 1 && /\\S/.test(char)) {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (newlineCount === 2) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isLastDescendantNode(path) {",
                    "  const node = path.getValue();",
                    "",
                    "  switch (node.type) {",
                    "    case \"tag\":",
                    "    case \"anchor\":",
                    "    case \"comment\":",
                    "      return false;",
                    "  }",
                    "",
                    "  const pathStackLength = path.stack.length;",
                    "",
                    "  for (let i = 1; i < pathStackLength; i++) {",
                    "    const item = path.stack[i];",
                    "    const parentItem = path.stack[i - 1];",
                    "",
                    "    if (",
                    "      Array.isArray(parentItem) &&",
                    "      typeof item === \"number\" &&",
                    "      item !== parentItem.length - 1",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function getLastDescendantNode(node) {",
                    "  return isNonEmptyArray(node.children)",
                    "    ? getLastDescendantNode(getLast(node.children))",
                    "    : node;",
                    "}",
                    "",
                    "function isPrettierIgnore(comment) {",
                    "  return comment.value.trim() === \"prettier-ignore\";",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (node.type === \"documentBody\") {",
                    "    const document = path.getParentNode();",
                    "    return (",
                    "      hasEndComments(document.head) &&",
                    "      isPrettierIgnore(getLast(document.head.endComments))",
                    "    );",
                    "  }",
                    "",
                    "  return (",
                    "    hasLeadingComments(node) && isPrettierIgnore(getLast(node.leadingComments))",
                    "  );",
                    "}",
                    "",
                    "function isEmptyNode(node) {",
                    "  return !isNonEmptyArray(node.children) && !hasComments(node);",
                    "}",
                    "",
                    "function hasComments(node) {",
                    "  return (",
                    "    hasLeadingComments(node) ||",
                    "    hasMiddleComments(node) ||",
                    "    hasIndicatorComment(node) ||",
                    "    hasTrailingComment(node) ||",
                    "    hasEndComments(node)",
                    "  );",
                    "}",
                    "",
                    "function hasLeadingComments(node) {",
                    "  return isNonEmptyArray(node?.leadingComments);",
                    "}",
                    "",
                    "function hasMiddleComments(node) {",
                    "  return isNonEmptyArray(node?.middleComments);",
                    "}",
                    "",
                    "function hasIndicatorComment(node) {",
                    "  return node?.indicatorComment;",
                    "}",
                    "",
                    "function hasTrailingComment(node) {",
                    "  return node?.trailingComment;",
                    "}",
                    "",
                    "function hasEndComments(node) {",
                    "  return isNonEmptyArray(node?.endComments);",
                    "}",
                    "",
                    "/**",
                    " * \" a   b c   d e   f \" -> [\" a   b\", \"c   d\", \"e   f \"]",
                    " */",
                    "function splitWithSingleSpace(text) {",
                    "  const parts = [];",
                    "",
                    "  let lastPart;",
                    "  for (const part of text.split(/( +)/)) {",
                    "    /* istanbul ignore else */",
                    "    if (part !== \" \") {",
                    "      if (lastPart === \" \") {",
                    "        parts.push(part);",
                    "      } else {",
                    "        parts.push((parts.pop() || \"\") + part);",
                    "      }",
                    "    } else if (lastPart === undefined) {",
                    "      parts.unshift(\"\");",
                    "    }",
                    "",
                    "    lastPart = part;",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (lastPart === \" \") {",
                    "    parts.push((parts.pop() || \"\") + \" \");",
                    "  }",
                    "",
                    "  if (parts[0] === \"\") {",
                    "    parts.shift();",
                    "    parts.unshift(\" \" + (parts.shift() || \"\"));",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function getFlowScalarLineContents(nodeType, content, options) {",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent, index, lineContents) =>",
                    "      index === 0 && index === lineContents.length - 1",
                    "        ? lineContent",
                    "        : index !== 0 && index !== lineContents.length - 1",
                    "        ? lineContent.trim()",
                    "        : index === 0",
                    "        ? lineContent.trimEnd()",
                    "        : lineContent.trimStart()",
                    "    );",
                    "",
                    "  if (options.proseWrap === \"preserve\") {",
                    "    return rawLineContents.map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : [lineContent]",
                    "    );",
                    "  }",
                    "",
                    "  return rawLineContents",
                    "    .map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "    )",
                    "    .reduce(",
                    "      (reduced, lineContentWords, index) =>",
                    "        index !== 0 &&",
                    "        rawLineContents[index - 1].length > 0 &&",
                    "        lineContentWords.length > 0 &&",
                    "        !(",
                    "          // trailing backslash in quoteDouble should be preserved",
                    "          (",
                    "            nodeType === \"quoteDouble\" &&",
                    "            getLast(getLast(reduced)).endsWith(\"\\\\\")",
                    "          )",
                    "        )",
                    "          ? [",
                    "              ...reduced.slice(0, -1),",
                    "              [...getLast(reduced), ...lineContentWords],",
                    "            ]",
                    "          : [...reduced, lineContentWords],",
                    "      []",
                    "    )",
                    "    .map((lineContentWords) =>",
                    "      options.proseWrap === \"never\"",
                    "        ? [lineContentWords.join(\" \")]",
                    "        : lineContentWords",
                    "    );",
                    "}",
                    "",
                    "function getBlockValueLineContents(",
                    "  node,",
                    "  { parentIndent, isLastDescendant, options }",
                    ") {",
                    "  const content =",
                    "    node.position.start.line === node.position.end.line",
                    "      ? \"\"",
                    "      : options.originalText",
                    "          .slice(node.position.start.offset, node.position.end.offset)",
                    "          // exclude open line `>` or `|`",
                    "          .match(/^[^\\n]*\\n(.*)$/s)[1];",
                    "",
                    "  let leadingSpaceCount;",
                    "  if (node.indent === null) {",
                    "    const matches = content.match(/^(?<leadingSpace> *)[^\\n\\r ]/m);",
                    "    leadingSpaceCount = matches",
                    "      ? matches.groups.leadingSpace.length",
                    "      : Number.POSITIVE_INFINITY;",
                    "  } else {",
                    "    leadingSpaceCount = node.indent - 1 + parentIndent;",
                    "  }",
                    "",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent) => lineContent.slice(leadingSpaceCount));",
                    "",
                    "  if (options.proseWrap === \"preserve\" || node.type === \"blockLiteral\") {",
                    "    return removeUnnecessaryTrailingNewlines(",
                    "      rawLineContents.map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : [lineContent]",
                    "      )",
                    "    );",
                    "  }",
                    "",
                    "  return removeUnnecessaryTrailingNewlines(",
                    "    rawLineContents",
                    "      .map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "      )",
                    "      .reduce(",
                    "        (reduced, lineContentWords, index) =>",
                    "          index !== 0 &&",
                    "          rawLineContents[index - 1].length > 0 &&",
                    "          lineContentWords.length > 0 &&",
                    "          !/^\\s/.test(lineContentWords[0]) &&",
                    "          !/^\\s|\\s$/.test(getLast(reduced))",
                    "            ? [",
                    "                ...reduced.slice(0, -1),",
                    "                [...getLast(reduced), ...lineContentWords],",
                    "              ]",
                    "            : [...reduced, lineContentWords],",
                    "        []",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        lineContentWords.reduce(",
                    "          (reduced, word) =>",
                    "            // disallow trailing spaces",
                    "            reduced.length > 0 && /\\s$/.test(getLast(reduced))",
                    "              ? [...reduced.slice(0, -1), getLast(reduced) + \" \" + word]",
                    "              : [...reduced, word],",
                    "          []",
                    "        )",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        options.proseWrap === \"never\"",
                    "          ? [lineContentWords.join(\" \")]",
                    "          : lineContentWords",
                    "      )",
                    "  );",
                    "",
                    "  function removeUnnecessaryTrailingNewlines(lineContents) {",
                    "    if (node.chomping === \"keep\") {",
                    "      return getLast(lineContents).length === 0",
                    "        ? lineContents.slice(0, -1)",
                    "        : lineContents;",
                    "    }",
                    "",
                    "    let trailingNewlineCount = 0;",
                    "    for (let i = lineContents.length - 1; i >= 0; i--) {",
                    "      if (lineContents[i].length === 0) {",
                    "        trailingNewlineCount++;",
                    "      } else {",
                    "        break;",
                    "      }",
                    "    }",
                    "",
                    "    return trailingNewlineCount === 0",
                    "      ? lineContents",
                    "      : trailingNewlineCount >= 2 && !isLastDescendant",
                    "      ? // next empty line",
                    "        lineContents.slice(0, -(trailingNewlineCount - 1))",
                    "      : lineContents.slice(0, -trailingNewlineCount);",
                    "  }",
                    "}",
                    "",
                    "function isInlineNode(node) {",
                    "  /* istanbul ignore next */",
                    "  if (!node) {",
                    "    return true;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"plain\":",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\":",
                    "    case \"alias\":",
                    "    case \"flowMapping\":",
                    "    case \"flowSequence\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  getLast,",
                    "  getAncestorCount,",
                    "  isNode,",
                    "  isEmptyNode,",
                    "  isInlineNode,",
                    "  mapNode,",
                    "  defineShortcut,",
                    "  isNextLineEmpty,",
                    "  isLastDescendantNode,",
                    "  getBlockValueLineContents,",
                    "  getFlowScalarLineContents,",
                    "  getLastDescendantNode,",
                    "  hasPrettierIgnore,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasIndicatorComment,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "};"
                ]
            },
            "print": {
                "block.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "const {",
                        "  builders: {",
                        "    dedent,",
                        "    dedentToRoot,",
                        "    fill,",
                        "    hardline,",
                        "    join,",
                        "    line,",
                        "    literalline,",
                        "    markAsRoot,",
                        "  },",
                        "  utils: { getDocParts },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  getAncestorCount,",
                        "  getBlockValueLineContents,",
                        "  hasIndicatorComment,",
                        "  isLastDescendantNode,",
                        "  isNode,",
                        "} = require(\"../utils.js\");",
                        "const { alignWithSpaces } = require(\"./misc.js\");",
                        "",
                        "function printBlock(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const parentIndent = getAncestorCount(path, (ancestorNode) =>",
                        "    isNode(ancestorNode, [\"sequence\", \"mapping\"])",
                        "  );",
                        "  const isLastDescendant = isLastDescendantNode(path);",
                        "  /** @type {Doc[]} */",
                        "  const parts = [node.type === \"blockFolded\" ? \">\" : \"|\"];",
                        "  if (node.indent !== null) {",
                        "    parts.push(node.indent.toString());",
                        "  }",
                        "",
                        "  if (node.chomping !== \"clip\") {",
                        "    parts.push(node.chomping === \"keep\" ? \"+\" : \"-\");",
                        "  }",
                        "",
                        "  if (hasIndicatorComment(node)) {",
                        "    parts.push(\" \", print(\"indicatorComment\"));",
                        "  }",
                        "",
                        "  const lineContents = getBlockValueLineContents(node, {",
                        "    parentIndent,",
                        "    isLastDescendant,",
                        "    options,",
                        "  });",
                        "  /** @type {Doc[]} */",
                        "  const contentsParts = [];",
                        "  for (const [index, lineWords] of lineContents.entries()) {",
                        "    if (index === 0) {",
                        "      contentsParts.push(hardline);",
                        "    }",
                        "    contentsParts.push(fill(getDocParts(join(line, lineWords))));",
                        "    if (index !== lineContents.length - 1) {",
                        "      contentsParts.push(",
                        "        lineWords.length === 0 ? hardline : markAsRoot(literalline)",
                        "      );",
                        "    } else if (node.chomping === \"keep\" && isLastDescendant) {",
                        "      contentsParts.push(",
                        "        dedentToRoot(lineWords.length === 0 ? hardline : literalline)",
                        "      );",
                        "    }",
                        "  }",
                        "  if (node.indent === null) {",
                        "    parts.push(dedent(alignWithSpaces(options.tabWidth, contentsParts)));",
                        "  } else {",
                        "    parts.push(",
                        "      dedentToRoot(",
                        "        alignWithSpaces(node.indent - 1 + parentIndent, contentsParts)",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "module.exports = printBlock;"
                    ]
                },
                "flow-mapping-sequence.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { ifBreak, line, softline, hardline, join },",
                        "} = require(\"../../document/index.js\");",
                        "const { isEmptyNode, getLast, hasEndComments } = require(\"../utils.js\");",
                        "const { printNextEmptyLine, alignWithSpaces } = require(\"./misc.js\");",
                        "",
                        "function printFlowMapping(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const isMapping = node.type === \"flowMapping\";",
                        "  const openMarker = isMapping ? \"{\" : \"[\";",
                        "  const closeMarker = isMapping ? \"}\" : \"]\";",
                        "",
                        "  /** @type {softline | line} */",
                        "  let bracketSpacing = softline;",
                        "  if (isMapping && node.children.length > 0 && options.bracketSpacing) {",
                        "    bracketSpacing = line;",
                        "  }",
                        "  const lastItem = getLast(node.children);",
                        "  const isLastItemEmptyMappingItem =",
                        "    lastItem &&",
                        "    lastItem.type === \"flowMappingItem\" &&",
                        "    isEmptyNode(lastItem.key) &&",
                        "    isEmptyNode(lastItem.value);",
                        "",
                        "  return [",
                        "    openMarker,",
                        "    alignWithSpaces(options.tabWidth, [",
                        "      bracketSpacing,",
                        "      printChildren(path, print, options),",
                        "      options.trailingComma === \"none\" ? \"\" : ifBreak(\",\"),",
                        "      hasEndComments(node)",
                        "        ? [hardline, join(hardline, path.map(print, \"endComments\"))]",
                        "        : \"\",",
                        "    ]),",
                        "    isLastItemEmptyMappingItem ? \"\" : bracketSpacing,",
                        "    closeMarker,",
                        "  ];",
                        "}",
                        "",
                        "function printChildren(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const parts = path.map(",
                        "    (childPath, index) => [",
                        "      print(),",
                        "      index === node.children.length - 1",
                        "        ? \"\"",
                        "        : [",
                        "            \",\",",
                        "            line,",
                        "            node.children[index].position.start.line !==",
                        "            node.children[index + 1].position.start.line",
                        "              ? printNextEmptyLine(childPath, options.originalText)",
                        "              : \"\",",
                        "          ],",
                        "    ],",
                        "    \"children\"",
                        "  );",
                        "  return parts;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printFlowMapping,",
                        "  // Alias",
                        "  printFlowSequence: printFlowMapping,",
                        "};"
                    ]
                },
                "mapping-item.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "const {",
                        "  builders: { conditionalGroup, group, hardline, ifBreak, join, line },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasLeadingComments,",
                        "  hasMiddleComments,",
                        "  hasTrailingComment,",
                        "  hasEndComments,",
                        "  isNode,",
                        "  isEmptyNode,",
                        "  isInlineNode,",
                        "} = require(\"../utils.js\");",
                        "const { alignWithSpaces } = require(\"./misc.js\");",
                        "",
                        "function printMappingItem(node, parentNode, path, print, options) {",
                        "  const { key, value } = node;",
                        "",
                        "  const isEmptyMappingKey = isEmptyNode(key);",
                        "  const isEmptyMappingValue = isEmptyNode(value);",
                        "",
                        "  if (isEmptyMappingKey && isEmptyMappingValue) {",
                        "    return \": \";",
                        "  }",
                        "",
                        "  const printedKey = print(\"key\");",
                        "  const spaceBeforeColon = needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\";",
                        "",
                        "  if (isEmptyMappingValue) {",
                        "    if (node.type === \"flowMappingItem\" && parentNode.type === \"flowMapping\") {",
                        "      return printedKey;",
                        "    }",
                        "",
                        "    if (",
                        "      node.type === \"mappingItem\" &&",
                        "      isAbsolutelyPrintedAsSingleLineNode(key.content, options) &&",
                        "      !hasTrailingComment(key.content) &&",
                        "      (!parentNode.tag || parentNode.tag.value !== \"tag:yaml.org,2002:set\")",
                        "    ) {",
                        "      return [printedKey, spaceBeforeColon, \":\"];",
                        "    }",
                        "",
                        "    return [\"? \", alignWithSpaces(2, printedKey)];",
                        "  }",
                        "",
                        "  const printedValue = print(\"value\");",
                        "  if (isEmptyMappingKey) {",
                        "    return [\": \", alignWithSpaces(2, printedValue)];",
                        "  }",
                        "",
                        "  // force explicit Key",
                        "  if (hasLeadingComments(value) || !isInlineNode(key.content)) {",
                        "    return [",
                        "      \"? \",",
                        "      alignWithSpaces(2, printedKey),",
                        "      hardline,",
                        "      join(",
                        "        \"\",",
                        "        path",
                        "          .map(print, \"value\", \"leadingComments\")",
                        "          .map((comment) => [comment, hardline])",
                        "      ),",
                        "      \": \",",
                        "      alignWithSpaces(2, printedValue),",
                        "    ];",
                        "  }",
                        "",
                        "  // force singleline",
                        "  if (",
                        "    isSingleLineNode(key.content) &&",
                        "    !hasLeadingComments(key.content) &&",
                        "    !hasMiddleComments(key.content) &&",
                        "    !hasTrailingComment(key.content) &&",
                        "    !hasEndComments(key) &&",
                        "    !hasLeadingComments(value.content) &&",
                        "    !hasMiddleComments(value.content) &&",
                        "    !hasEndComments(value) &&",
                        "    isAbsolutelyPrintedAsSingleLineNode(value.content, options)",
                        "  ) {",
                        "    return [printedKey, spaceBeforeColon, \": \", printedValue];",
                        "  }",
                        "",
                        "  const groupId = Symbol(\"mappingKey\");",
                        "  const groupedKey = group([",
                        "    ifBreak(\"? \"),",
                        "    group(alignWithSpaces(2, printedKey), { id: groupId }),",
                        "  ]);",
                        "",
                        "  // Construct both explicit and implicit mapping values.",
                        "  const explicitMappingValue = [",
                        "    hardline,",
                        "    \": \",",
                        "    alignWithSpaces(2, printedValue),",
                        "  ];",
                        "  /** @type {Doc[]} */",
                        "  // In the implicit case, it's convenient to treat everything from the key's colon",
                        "  // as part of the mapping value",
                        "  const implicitMappingValueParts = [spaceBeforeColon, \":\"];",
                        "  if (",
                        "    hasLeadingComments(value.content) ||",
                        "    (hasEndComments(value) &&",
                        "      value.content &&",
                        "      !isNode(value.content, [\"mapping\", \"sequence\"])) ||",
                        "    (parentNode.type === \"mapping\" &&",
                        "      hasTrailingComment(key.content) &&",
                        "      isInlineNode(value.content)) ||",
                        "    (isNode(value.content, [\"mapping\", \"sequence\"]) &&",
                        "      value.content.tag === null &&",
                        "      value.content.anchor === null)",
                        "  ) {",
                        "    implicitMappingValueParts.push(hardline);",
                        "  } else if (value.content) {",
                        "    implicitMappingValueParts.push(line);",
                        "  }",
                        "  implicitMappingValueParts.push(printedValue);",
                        "  const implicitMappingValue = alignWithSpaces(",
                        "    options.tabWidth,",
                        "    implicitMappingValueParts",
                        "  );",
                        "",
                        "  // If a key is definitely single-line, forcibly use implicit style to avoid edge cases (very long",
                        "  // keys) that would otherwise trigger explicit style as if it was multiline.",
                        "  // In those cases, explicit style makes the line even longer and causes confusion.",
                        "  if (",
                        "    isAbsolutelyPrintedAsSingleLineNode(key.content, options) &&",
                        "    !hasLeadingComments(key.content) &&",
                        "    !hasMiddleComments(key.content) &&",
                        "    !hasEndComments(key)",
                        "  ) {",
                        "    return conditionalGroup([[printedKey, implicitMappingValue]]);",
                        "  }",
                        "",
                        "  // Use explicit mapping syntax if the key breaks, implicit otherwise",
                        "  return conditionalGroup([",
                        "    [",
                        "      groupedKey,",
                        "      ifBreak(explicitMappingValue, implicitMappingValue, { groupId }),",
                        "    ],",
                        "  ]);",
                        "}",
                        "",
                        "function isAbsolutelyPrintedAsSingleLineNode(node, options) {",
                        "  if (!node) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"plain\":",
                        "    case \"quoteSingle\":",
                        "    case \"quoteDouble\":",
                        "      break;",
                        "    case \"alias\":",
                        "      return true;",
                        "",
                        "    default:",
                        "      return false;",
                        "  }",
                        "",
                        "  if (options.proseWrap === \"preserve\") {",
                        "    return node.position.start.line === node.position.end.line;",
                        "  }",
                        "",
                        "  if (",
                        "    // backslash-newline",
                        "    /\\\\$/m.test(",
                        "      options.originalText.slice(",
                        "        node.position.start.offset,",
                        "        node.position.end.offset",
                        "      )",
                        "    )",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  switch (options.proseWrap) {",
                        "    case \"never\":",
                        "      return !node.value.includes(\"\\n\");",
                        "    case \"always\":",
                        "      return !/[\\n ]/.test(node.value);",
                        "    // istanbul ignore next",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "function needsSpaceInFrontOfMappingValue(node) {",
                        "  return node.key.content && node.key.content.type === \"alias\";",
                        "}",
                        "",
                        "function isSingleLineNode(node) {",
                        "  /* istanbul ignore next */",
                        "  if (!node) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"plain\":",
                        "    case \"quoteDouble\":",
                        "    case \"quoteSingle\":",
                        "      return node.position.start.line === node.position.end.line;",
                        "    case \"alias\":",
                        "      return true;",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "module.exports = printMappingItem;"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { softline, align },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "const { hasEndComments, isNextLineEmpty, isNode } = require(\"../utils.js\");",
                        "",
                        "const printedEmptyLineCache = new WeakMap();",
                        "function printNextEmptyLine(path, originalText) {",
                        "  const node = path.getValue();",
                        "  const root = path.stack[0];",
                        "",
                        "  let isNextEmptyLinePrintedSet;",
                        "  if (printedEmptyLineCache.has(root)) {",
                        "    isNextEmptyLinePrintedSet = printedEmptyLineCache.get(root);",
                        "  } else {",
                        "    isNextEmptyLinePrintedSet = new Set();",
                        "    printedEmptyLineCache.set(root, isNextEmptyLinePrintedSet);",
                        "  }",
                        "",
                        "  if (!isNextEmptyLinePrintedSet.has(node.position.end.line)) {",
                        "    isNextEmptyLinePrintedSet.add(node.position.end.line);",
                        "    if (",
                        "      isNextLineEmpty(node, originalText) &&",
                        "      !shouldPrintEndComments(path.getParentNode())",
                        "    ) {",
                        "      return softline;",
                        "    }",
                        "  }",
                        "",
                        "  return \"\";",
                        "}",
                        "",
                        "function shouldPrintEndComments(node) {",
                        "  return (",
                        "    hasEndComments(node) &&",
                        "    !isNode(node, [",
                        "      \"documentHead\",",
                        "      \"documentBody\",",
                        "      \"flowMapping\",",
                        "      \"flowSequence\",",
                        "    ])",
                        "  );",
                        "}",
                        "",
                        "function alignWithSpaces(width, doc) {",
                        "  return align(\" \".repeat(width), doc);",
                        "}",
                        "",
                        "module.exports = {",
                        "  alignWithSpaces,",
                        "  shouldPrintEndComments,",
                        "  printNextEmptyLine,",
                        "};"
                    ]
                }
            }
        },
        "main": {
            "ast-to-doc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const AstPath = require(\"../common/ast-path.js\");",
                    "const {",
                    "  builders: { hardline, addAlignmentToDoc },",
                    "  utils: { propagateBreaks },",
                    "} = require(\"../document/index.js\");",
                    "const { printComments } = require(\"./comments.js\");",
                    "const multiparser = require(\"./multiparser.js\");",
                    "",
                    "/**",
                    " * Takes an abstract syntax tree (AST) and recursively converts it to a",
                    " * document (series of printing primitives).",
                    " *",
                    " * This is done by descending down the AST recursively. The recursion",
                    " * involves two functions that call each other:",
                    " *",
                    " * 1. mainPrint(), which is defined as an inner function here.",
                    " *    It basically takes care of node caching.",
                    " * 2. callPluginPrintFunction(), which checks for some options, and",
                    " *    ultimately calls the print() function provided by the plugin.",
                    " *",
                    " * The plugin function will call mainPrint() again for child nodes",
                    " * of the current node. mainPrint() will do its housekeeping, then call",
                    " * the plugin function again, and so on.",
                    " *",
                    " * All the while, these functions pass a \"path\" variable around, which",
                    " * is a stack-like data structure (AstPath) that maintains the current",
                    " * state of the recursion. It is called \"path\", because it represents",
                    " * the path to the current node through the Abstract Syntax Tree.",
                    " */",
                    "function printAstToDoc(ast, options, alignmentSize = 0) {",
                    "  const { printer } = options;",
                    "",
                    "  if (printer.preprocess) {",
                    "    ast = printer.preprocess(ast, options);",
                    "  }",
                    "",
                    "  const cache = new Map();",
                    "  const path = new AstPath(ast);",
                    "",
                    "  let doc = mainPrint();",
                    "",
                    "  if (alignmentSize > 0) {",
                    "    // Add a hardline to make the indents take effect",
                    "    // It should be removed in index.js format()",
                    "    doc = addAlignmentToDoc([hardline, doc], alignmentSize, options.tabWidth);",
                    "  }",
                    "",
                    "  propagateBreaks(doc);",
                    "",
                    "  return doc;",
                    "",
                    "  function mainPrint(selector, args) {",
                    "    if (selector === undefined || selector === path) {",
                    "      return mainPrintInternal(args);",
                    "    }",
                    "",
                    "    if (Array.isArray(selector)) {",
                    "      return path.call(() => mainPrintInternal(args), ...selector);",
                    "    }",
                    "",
                    "    return path.call(() => mainPrintInternal(args), selector);",
                    "  }",
                    "",
                    "  function mainPrintInternal(args) {",
                    "    const value = path.getValue();",
                    "",
                    "    const shouldCache =",
                    "      value && typeof value === \"object\" && args === undefined;",
                    "",
                    "    if (shouldCache && cache.has(value)) {",
                    "      return cache.get(value);",
                    "    }",
                    "",
                    "    const doc = callPluginPrintFunction(path, options, mainPrint, args);",
                    "",
                    "    if (shouldCache) {",
                    "      cache.set(value, doc);",
                    "    }",
                    "",
                    "    return doc;",
                    "  }",
                    "}",
                    "",
                    "function printPrettierIgnoredNode(node, options) {",
                    "  const {",
                    "    originalText,",
                    "    [Symbol.for(\"comments\")]: comments,",
                    "    locStart,",
                    "    locEnd,",
                    "  } = options;",
                    "",
                    "  const start = locStart(node);",
                    "  const end = locEnd(node);",
                    "  const printedComments = new Set();",
                    "",
                    "  for (const comment of comments) {",
                    "    if (locStart(comment) >= start && locEnd(comment) <= end) {",
                    "      comment.printed = true;",
                    "      printedComments.add(comment);",
                    "    }",
                    "  }",
                    "",
                    "  return { doc: originalText.slice(start, end), printedComments };",
                    "}",
                    "",
                    "function callPluginPrintFunction(path, options, printPath, args) {",
                    "  const node = path.getValue();",
                    "  const { printer } = options;",
                    "",
                    "  let doc;",
                    "  let printedComments;",
                    "",
                    "  // Escape hatch",
                    "  if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {",
                    "    ({ doc, printedComments } = printPrettierIgnoredNode(node, options));",
                    "  } else {",
                    "    if (node) {",
                    "      try {",
                    "        // Potentially switch to a different parser",
                    "        doc = multiparser.printSubtree(path, printPath, options, printAstToDoc);",
                    "      } catch (error) {",
                    "        /* istanbul ignore if */",
                    "        if (process.env.PRETTIER_DEBUG) {",
                    "          throw error;",
                    "        }",
                    "        // Continue with current parser",
                    "      }",
                    "    }",
                    "",
                    "    if (!doc) {",
                    "      doc = printer.print(path, options, printPath, args);",
                    "    }",
                    "  }",
                    "",
                    "  // We let JSXElement print its comments itself because it adds () around",
                    "  // UnionTypeAnnotation has to align the child without the comments",
                    "  if (",
                    "    !printer.willPrintOwnComments ||",
                    "    !printer.willPrintOwnComments(path, options)",
                    "  ) {",
                    "    // printComments will call the plugin print function and check for",
                    "    // comments to print",
                    "    doc = printComments(path, doc, options, printedComments);",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "module.exports = printAstToDoc;"
                ]
            },
            "comments.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "",
                    "const {",
                    "  builders: { line, hardline, breakParent, indent, lineSuffix, join, cursor },",
                    "} = require(\"../document/index.js\");",
                    "",
                    "const {",
                    "  hasNewline,",
                    "  skipNewline,",
                    "  skipSpaces,",
                    "  isPreviousLineEmpty,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "} = require(\"../common/util.js\");",
                    "",
                    "const childNodesCache = new WeakMap();",
                    "function getSortedChildNodes(node, options, resultArray) {",
                    "  if (!node) {",
                    "    return;",
                    "  }",
                    "  const { printer, locStart, locEnd } = options;",
                    "",
                    "  if (resultArray) {",
                    "    if (printer.canAttachComment && printer.canAttachComment(node)) {",
                    "      // This reverse insertion sort almost always takes constant",
                    "      // time because we almost always (maybe always?) append the",
                    "      // nodes in order anyway.",
                    "      let i;",
                    "      for (i = resultArray.length - 1; i >= 0; --i) {",
                    "        if (",
                    "          locStart(resultArray[i]) <= locStart(node) &&",
                    "          locEnd(resultArray[i]) <= locEnd(node)",
                    "        ) {",
                    "          break;",
                    "        }",
                    "      }",
                    "      resultArray.splice(i + 1, 0, node);",
                    "      return;",
                    "    }",
                    "  } else if (childNodesCache.has(node)) {",
                    "    return childNodesCache.get(node);",
                    "  }",
                    "",
                    "  const childNodes =",
                    "    (printer.getCommentChildNodes &&",
                    "      printer.getCommentChildNodes(node, options)) ||",
                    "    (typeof node === \"object\" &&",
                    "      Object.entries(node)",
                    "        .filter(",
                    "          ([key]) =>",
                    "            key !== \"enclosingNode\" &&",
                    "            key !== \"precedingNode\" &&",
                    "            key !== \"followingNode\" &&",
                    "            key !== \"tokens\" &&",
                    "            key !== \"comments\" &&",
                    "            key !== \"parent\"",
                    "        )",
                    "        .map(([, value]) => value));",
                    "",
                    "  if (!childNodes) {",
                    "    return;",
                    "  }",
                    "",
                    "  if (!resultArray) {",
                    "    resultArray = [];",
                    "    childNodesCache.set(node, resultArray);",
                    "  }",
                    "",
                    "  for (const childNode of childNodes) {",
                    "    getSortedChildNodes(childNode, options, resultArray);",
                    "  }",
                    "",
                    "  return resultArray;",
                    "}",
                    "",
                    "// As efficiently as possible, decorate the comment object with",
                    "// .precedingNode, .enclosingNode, and/or .followingNode properties, at",
                    "// least one of which is guaranteed to be defined.",
                    "function decorateComment(node, comment, options, enclosingNode) {",
                    "  const { locStart, locEnd } = options;",
                    "  const commentStart = locStart(comment);",
                    "  const commentEnd = locEnd(comment);",
                    "",
                    "  const childNodes = getSortedChildNodes(node, options);",
                    "  let precedingNode;",
                    "  let followingNode;",
                    "  // Time to dust off the old binary search robes and wizard hat.",
                    "  let left = 0;",
                    "  let right = childNodes.length;",
                    "  while (left < right) {",
                    "    const middle = (left + right) >> 1;",
                    "    const child = childNodes[middle];",
                    "    const start = locStart(child);",
                    "    const end = locEnd(child);",
                    "",
                    "    // The comment is completely contained by this child node.",
                    "    if (start <= commentStart && commentEnd <= end) {",
                    "      // Abandon the binary search at this level.",
                    "      return decorateComment(child, comment, options, child);",
                    "    }",
                    "",
                    "    if (end <= commentStart) {",
                    "      // This child node falls completely before the comment.",
                    "      // Because we will never consider this node or any nodes",
                    "      // before it again, this node must be the closest preceding",
                    "      // node we have encountered so far.",
                    "      precedingNode = child;",
                    "      left = middle + 1;",
                    "      continue;",
                    "    }",
                    "",
                    "    if (commentEnd <= start) {",
                    "      // This child node falls completely after the comment.",
                    "      // Because we will never consider this node or any nodes after",
                    "      // it again, this node must be the closest following node we",
                    "      // have encountered so far.",
                    "      followingNode = child;",
                    "      right = middle;",
                    "      continue;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw new Error(\"Comment location overlaps with node location\");",
                    "  }",
                    "",
                    "  // We don't want comments inside of different expressions inside of the same",
                    "  // template literal to move to another expression.",
                    "  if (enclosingNode && enclosingNode.type === \"TemplateLiteral\") {",
                    "    const { quasis } = enclosingNode;",
                    "    const commentIndex = findExpressionIndexForComment(",
                    "      quasis,",
                    "      comment,",
                    "      options",
                    "    );",
                    "",
                    "    if (",
                    "      precedingNode &&",
                    "      findExpressionIndexForComment(quasis, precedingNode, options) !==",
                    "        commentIndex",
                    "    ) {",
                    "      precedingNode = null;",
                    "    }",
                    "    if (",
                    "      followingNode &&",
                    "      findExpressionIndexForComment(quasis, followingNode, options) !==",
                    "        commentIndex",
                    "    ) {",
                    "      followingNode = null;",
                    "    }",
                    "  }",
                    "",
                    "  return { enclosingNode, precedingNode, followingNode };",
                    "}",
                    "",
                    "const returnFalse = () => false;",
                    "function attach(comments, ast, text, options) {",
                    "  if (!Array.isArray(comments)) {",
                    "    return;",
                    "  }",
                    "",
                    "  const tiesToBreak = [];",
                    "  const {",
                    "    locStart,",
                    "    locEnd,",
                    "    printer: { handleComments = {} },",
                    "  } = options;",
                    "  // TODO: Make this as default behavior",
                    "  const {",
                    "    avoidAstMutation,",
                    "    ownLine: handleOwnLineComment = returnFalse,",
                    "    endOfLine: handleEndOfLineComment = returnFalse,",
                    "    remaining: handleRemainingComment = returnFalse,",
                    "  } = handleComments;",
                    "",
                    "  const decoratedComments = comments.map((comment, index) => ({",
                    "    ...decorateComment(ast, comment, options),",
                    "    comment,",
                    "    text,",
                    "    options,",
                    "    ast,",
                    "    isLastComment: comments.length - 1 === index,",
                    "  }));",
                    "",
                    "  for (const [index, context] of decoratedComments.entries()) {",
                    "    const {",
                    "      comment,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      text,",
                    "      options,",
                    "      ast,",
                    "      isLastComment,",
                    "    } = context;",
                    "",
                    "    if (",
                    "      options.parser === \"json\" ||",
                    "      options.parser === \"json5\" ||",
                    "      options.parser === \"__js_expression\" ||",
                    "      options.parser === \"__vue_expression\" ||",
                    "      options.parser === \"__vue_ts_expression\"",
                    "    ) {",
                    "      if (locStart(comment) - locStart(ast) <= 0) {",
                    "        addLeadingComment(ast, comment);",
                    "        continue;",
                    "      }",
                    "      if (locEnd(comment) - locEnd(ast) >= 0) {",
                    "        addTrailingComment(ast, comment);",
                    "        continue;",
                    "      }",
                    "    }",
                    "",
                    "    let args;",
                    "    if (avoidAstMutation) {",
                    "      args = [context];",
                    "    } else {",
                    "      comment.enclosingNode = enclosingNode;",
                    "      comment.precedingNode = precedingNode;",
                    "      comment.followingNode = followingNode;",
                    "      args = [comment, text, options, ast, isLastComment];",
                    "    }",
                    "",
                    "    if (isOwnLineComment(text, options, decoratedComments, index)) {",
                    "      comment.placement = \"ownLine\";",
                    "      // If a comment exists on its own line, prefer a leading comment.",
                    "      // We also need to check if it's the first line of the file.",
                    "      if (handleOwnLineComment(...args)) {",
                    "        // We're good",
                    "      } else if (followingNode) {",
                    "        // Always a leading comment.",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (precedingNode) {",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    } else if (isEndOfLineComment(text, options, decoratedComments, index)) {",
                    "      comment.placement = \"endOfLine\";",
                    "      if (handleEndOfLineComment(...args)) {",
                    "        // We're good",
                    "      } else if (precedingNode) {",
                    "        // There is content before this comment on the same line, but",
                    "        // none after it, so prefer a trailing comment of the previous node.",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (followingNode) {",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    } else {",
                    "      comment.placement = \"remaining\";",
                    "      if (handleRemainingComment(...args)) {",
                    "        // We're good",
                    "      } else if (precedingNode && followingNode) {",
                    "        // Otherwise, text exists both before and after the comment on",
                    "        // the same line. If there is both a preceding and following",
                    "        // node, use a tie-breaking algorithm to determine if it should",
                    "        // be attached to the next or previous node. In the last case,",
                    "        // simply attach the right node;",
                    "        const tieCount = tiesToBreak.length;",
                    "        if (tieCount > 0) {",
                    "          const lastTie = tiesToBreak[tieCount - 1];",
                    "          if (lastTie.followingNode !== followingNode) {",
                    "            breakTies(tiesToBreak, text, options);",
                    "          }",
                    "        }",
                    "        tiesToBreak.push(context);",
                    "      } else if (precedingNode) {",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (followingNode) {",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  breakTies(tiesToBreak, text, options);",
                    "",
                    "  if (!avoidAstMutation) {",
                    "    for (const comment of comments) {",
                    "      // These node references were useful for breaking ties, but we",
                    "      // don't need them anymore, and they create cycles in the AST that",
                    "      // may lead to infinite recursion if we don't delete them here.",
                    "      delete comment.precedingNode;",
                    "      delete comment.enclosingNode;",
                    "      delete comment.followingNode;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "const isAllEmptyAndNoLineBreak = (text) => !/[\\S\\n\\u2028\\u2029]/.test(text);",
                    "function isOwnLineComment(text, options, decoratedComments, commentIndex) {",
                    "  const { comment, precedingNode } = decoratedComments[commentIndex];",
                    "  const { locStart, locEnd } = options;",
                    "  let start = locStart(comment);",
                    "",
                    "  if (precedingNode) {",
                    "    // Find first comment on the same line",
                    "    for (let index = commentIndex - 1; index >= 0; index--) {",
                    "      const { comment, precedingNode: currentCommentPrecedingNode } =",
                    "        decoratedComments[index];",
                    "      if (",
                    "        currentCommentPrecedingNode !== precedingNode ||",
                    "        !isAllEmptyAndNoLineBreak(text.slice(locEnd(comment), start))",
                    "      ) {",
                    "        break;",
                    "      }",
                    "      start = locStart(comment);",
                    "    }",
                    "  }",
                    "",
                    "  return hasNewline(text, start, { backwards: true });",
                    "}",
                    "",
                    "function isEndOfLineComment(text, options, decoratedComments, commentIndex) {",
                    "  const { comment, followingNode } = decoratedComments[commentIndex];",
                    "  const { locStart, locEnd } = options;",
                    "  let end = locEnd(comment);",
                    "",
                    "  if (followingNode) {",
                    "    // Find last comment on the same line",
                    "    for (",
                    "      let index = commentIndex + 1;",
                    "      index < decoratedComments.length;",
                    "      index++",
                    "    ) {",
                    "      const { comment, followingNode: currentCommentFollowingNode } =",
                    "        decoratedComments[index];",
                    "      if (",
                    "        currentCommentFollowingNode !== followingNode ||",
                    "        !isAllEmptyAndNoLineBreak(text.slice(end, locStart(comment)))",
                    "      ) {",
                    "        break;",
                    "      }",
                    "      end = locEnd(comment);",
                    "    }",
                    "  }",
                    "",
                    "  return hasNewline(text, end);",
                    "}",
                    "",
                    "function breakTies(tiesToBreak, text, options) {",
                    "  const tieCount = tiesToBreak.length;",
                    "  if (tieCount === 0) {",
                    "    return;",
                    "  }",
                    "  const { precedingNode, followingNode, enclosingNode } = tiesToBreak[0];",
                    "",
                    "  const gapRegExp =",
                    "    (options.printer.getGapRegex &&",
                    "      options.printer.getGapRegex(enclosingNode)) ||",
                    "    /^[\\s(]*$/;",
                    "",
                    "  let gapEndPos = options.locStart(followingNode);",
                    "",
                    "  // Iterate backwards through tiesToBreak, examining the gaps",
                    "  // between the tied comments. In order to qualify as leading, a",
                    "  // comment must be separated from followingNode by an unbroken series of",
                    "  // gaps (or other comments). Gaps should only contain whitespace or open",
                    "  // parentheses.",
                    "  let indexOfFirstLeadingComment;",
                    "  for (",
                    "    indexOfFirstLeadingComment = tieCount;",
                    "    indexOfFirstLeadingComment > 0;",
                    "    --indexOfFirstLeadingComment",
                    "  ) {",
                    "    const {",
                    "      comment,",
                    "      precedingNode: currentCommentPrecedingNode,",
                    "      followingNode: currentCommentFollowingNode,",
                    "    } = tiesToBreak[indexOfFirstLeadingComment - 1];",
                    "    assert.strictEqual(currentCommentPrecedingNode, precedingNode);",
                    "    assert.strictEqual(currentCommentFollowingNode, followingNode);",
                    "",
                    "    const gap = text.slice(options.locEnd(comment), gapEndPos);",
                    "",
                    "    if (gapRegExp.test(gap)) {",
                    "      gapEndPos = options.locStart(comment);",
                    "    } else {",
                    "      // The gap string contained something other than whitespace or open",
                    "      // parentheses.",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  for (const [i, { comment }] of tiesToBreak.entries()) {",
                    "    if (i < indexOfFirstLeadingComment) {",
                    "      addTrailingComment(precedingNode, comment);",
                    "    } else {",
                    "      addLeadingComment(followingNode, comment);",
                    "    }",
                    "  }",
                    "",
                    "  for (const node of [precedingNode, followingNode]) {",
                    "    if (node.comments && node.comments.length > 1) {",
                    "      node.comments.sort((a, b) => options.locStart(a) - options.locStart(b));",
                    "    }",
                    "  }",
                    "",
                    "  tiesToBreak.length = 0;",
                    "}",
                    "",
                    "function printComment(path, options) {",
                    "  const comment = path.getValue();",
                    "  comment.printed = true;",
                    "  return options.printer.printComment(path, options);",
                    "}",
                    "",
                    "function findExpressionIndexForComment(quasis, comment, options) {",
                    "  const startPos = options.locStart(comment) - 1;",
                    "",
                    "  for (let i = 1; i < quasis.length; ++i) {",
                    "    if (startPos < options.locStart(quasis[i])) {",
                    "      return i - 1;",
                    "    }",
                    "  }",
                    "",
                    "  // We haven't found it, it probably means that some of the locations are off.",
                    "  // Let's just return the first one.",
                    "  /* istanbul ignore next */",
                    "  return 0;",
                    "}",
                    "",
                    "function printLeadingComment(path, options) {",
                    "  const comment = path.getValue();",
                    "  const parts = [printComment(path, options)];",
                    "",
                    "  const { printer, originalText, locStart, locEnd } = options;",
                    "  const isBlock = printer.isBlockComment && printer.isBlockComment(comment);",
                    "",
                    "  // Leading block comments should see if they need to stay on the",
                    "  // same line or not.",
                    "  if (isBlock) {",
                    "    const lineBreak = hasNewline(originalText, locEnd(comment))",
                    "      ? hasNewline(originalText, locStart(comment), {",
                    "          backwards: true,",
                    "        })",
                    "        ? hardline",
                    "        : line",
                    "      : \" \";",
                    "",
                    "    parts.push(lineBreak);",
                    "  } else {",
                    "    parts.push(hardline);",
                    "  }",
                    "",
                    "  const index = skipNewline(",
                    "    originalText,",
                    "    skipSpaces(originalText, locEnd(comment))",
                    "  );",
                    "",
                    "  if (index !== false && hasNewline(originalText, index)) {",
                    "    parts.push(hardline);",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printTrailingComment(path, options) {",
                    "  const comment = path.getValue();",
                    "  const printed = printComment(path, options);",
                    "",
                    "  const { printer, originalText, locStart } = options;",
                    "  const isBlock = printer.isBlockComment && printer.isBlockComment(comment);",
                    "",
                    "  if (hasNewline(originalText, locStart(comment), { backwards: true })) {",
                    "    // This allows comments at the end of nested structures:",
                    "    // {",
                    "    //   x: 1,",
                    "    //   y: 2",
                    "    //   // A comment",
                    "    // }",
                    "    // Those kinds of comments are almost always leading comments, but",
                    "    // here it doesn't go \"outside\" the block and turns it into a",
                    "    // trailing comment for `2`. We can simulate the above by checking",
                    "    // if this a comment on its own line; normal trailing comments are",
                    "    // always at the end of another expression.",
                    "",
                    "    const isLineBeforeEmpty = isPreviousLineEmpty(",
                    "      originalText,",
                    "      comment,",
                    "      locStart",
                    "    );",
                    "",
                    "    return lineSuffix([hardline, isLineBeforeEmpty ? hardline : \"\", printed]);",
                    "  }",
                    "",
                    "  let parts = [\" \", printed];",
                    "",
                    "  // Trailing block comments never need a newline",
                    "  if (!isBlock) {",
                    "    parts = [lineSuffix(parts), breakParent];",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printDanglingComments(path, options, sameIndent, filter) {",
                    "  const parts = [];",
                    "  const node = path.getValue();",
                    "",
                    "  if (!node || !node.comments) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  path.each(() => {",
                    "    const comment = path.getValue();",
                    "    if (!comment.leading && !comment.trailing && (!filter || filter(comment))) {",
                    "      parts.push(printComment(path, options));",
                    "    }",
                    "  }, \"comments\");",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (sameIndent) {",
                    "    return join(hardline, parts);",
                    "  }",
                    "  return indent([hardline, join(hardline, parts)]);",
                    "}",
                    "",
                    "function printCommentsSeparately(path, options, ignored) {",
                    "  const value = path.getValue();",
                    "  if (!value) {",
                    "    return {};",
                    "  }",
                    "",
                    "  let comments = value.comments || [];",
                    "  if (ignored) {",
                    "    comments = comments.filter((comment) => !ignored.has(comment));",
                    "  }",
                    "  const isCursorNode = value === options.cursorNode;",
                    "",
                    "  if (comments.length === 0) {",
                    "    const maybeCursor = isCursorNode ? cursor : \"\";",
                    "    return { leading: maybeCursor, trailing: maybeCursor };",
                    "  }",
                    "",
                    "  const leadingParts = [];",
                    "  const trailingParts = [];",
                    "  path.each(() => {",
                    "    const comment = path.getValue();",
                    "    if (ignored && ignored.has(comment)) {",
                    "      return;",
                    "    }",
                    "",
                    "    const { leading, trailing } = comment;",
                    "    if (leading) {",
                    "      leadingParts.push(printLeadingComment(path, options));",
                    "    } else if (trailing) {",
                    "      trailingParts.push(printTrailingComment(path, options));",
                    "    }",
                    "  }, \"comments\");",
                    "",
                    "  if (isCursorNode) {",
                    "    leadingParts.unshift(cursor);",
                    "    trailingParts.push(cursor);",
                    "  }",
                    "",
                    "  return { leading: leadingParts, trailing: trailingParts };",
                    "}",
                    "",
                    "function printComments(path, doc, options, ignored) {",
                    "  const { leading, trailing } = printCommentsSeparately(path, options, ignored);",
                    "  if (!leading && !trailing) {",
                    "    return doc;",
                    "  }",
                    "  return [leading, doc, trailing];",
                    "}",
                    "",
                    "function ensureAllCommentsPrinted(astComments) {",
                    "  if (!astComments) {",
                    "    return;",
                    "  }",
                    "",
                    "  for (const comment of astComments) {",
                    "    if (!comment.printed) {",
                    "      throw new Error(",
                    "        'Comment \"' +",
                    "          comment.value.trim() +",
                    "          '\" was not printed. Please report this error!'",
                    "      );",
                    "    }",
                    "    delete comment.printed;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  attach,",
                    "  printComments,",
                    "  printCommentsSeparately,",
                    "  printDanglingComments,",
                    "  getSortedChildNodes,",
                    "  ensureAllCommentsPrinted,",
                    "};"
                ]
            },
            "core-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { outdent } = require(\"outdent\");",
                    "",
                    "const CATEGORY_CONFIG = \"Config\";",
                    "const CATEGORY_EDITOR = \"Editor\";",
                    "const CATEGORY_FORMAT = \"Format\";",
                    "const CATEGORY_OTHER = \"Other\";",
                    "const CATEGORY_OUTPUT = \"Output\";",
                    "const CATEGORY_GLOBAL = \"Global\";",
                    "const CATEGORY_SPECIAL = \"Special\";",
                    "",
                    "/**",
                    " * @typedef {Object} OptionInfo",
                    " * @property {string} [since] - available since version",
                    " * @property {string} category",
                    " * @property {'int' | 'boolean' | 'choice' | 'path' | 'string' | 'flag'} type",
                    " * @property {boolean} [array] - indicate it's an array of the specified type",
                    " * @property {OptionValueInfo} [default]",
                    " * @property {OptionRangeInfo} [range] - for type int",
                    " * @property {string} description",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionRedirectInfo} [redirect] - redirect deprecated option",
                    " * @property {(value: any) => boolean} [exception]",
                    " * @property {OptionChoiceInfo[]} [choices] - for type choice",
                    " * @property {string} [cliName]",
                    " * @property {string} [cliCategory]",
                    " * @property {string} [cliDescription]",
                    " *",
                    " * @typedef {number | boolean | string} OptionValue",
                    " * @typedef {OptionValue | [{ value: OptionValue[] }] | Array<{ since: string, value: OptionValue}>} OptionValueInfo",
                    " *",
                    " * @typedef {Object} OptionRedirectInfo",
                    " * @property {string} option",
                    " * @property {OptionValue} value",
                    " *",
                    " * @typedef {Object} OptionRangeInfo",
                    " * @property {number} start - recommended range start",
                    " * @property {number} end - recommended range end",
                    " * @property {number} step - recommended range step",
                    " *",
                    " * @typedef {Object} OptionChoiceInfo",
                    " * @property {boolean | string} value - boolean for the option that is originally boolean type",
                    " * @property {string} description",
                    " * @property {string} [since] - undefined if available since the first version of the option",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionValueInfo} [redirect] - redirect deprecated value",
                    " */",
                    "",
                    "/** @type {{ [name: string]: OptionInfo }} */",
                    "const options = {",
                    "  cursorOffset: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: -1,",
                    "    range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Print (to stderr) where a cursor at the given position would move to after formatting.",
                    "      This option cannot be used with --range-start and --range-end.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  endOfLine: {",
                    "    since: \"1.15.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.15.0\", value: \"auto\" },",
                    "      { since: \"2.0.0\", value: \"lf\" },",
                    "    ],",
                    "    description: \"Which end of line characters to apply.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"lf\",",
                    "        description:",
                    "          \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\",",
                    "      },",
                    "      {",
                    "        value: \"crlf\",",
                    "        description:",
                    "          \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\",",
                    "      },",
                    "      {",
                    "        value: \"cr\",",
                    "        description: \"Carriage Return character only (\\\\r), used very rarely\",",
                    "      },",
                    "      {",
                    "        value: \"auto\",",
                    "        description: outdent`",
                    "          Maintain existing",
                    "          (mixed values within one file are normalised by looking at what's used after the first line)",
                    "        `,",
                    "      },",
                    "    ],",
                    "  },",
                    "  filepath: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"path\",",
                    "    description:",
                    "      \"Specify the input filepath. This will be used to do parser inference.\",",
                    "    cliName: \"stdin-filepath\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "    cliDescription: \"Path to the file to pretend that stdin comes from.\",",
                    "  },",
                    "  insertPragma: {",
                    "    since: \"1.8.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Insert @format pragma into file's first docblock comment.\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  parser: {",
                    "    since: \"0.0.10\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"0.0.10\", value: \"babylon\" },",
                    "      { since: \"1.13.0\", value: undefined },",
                    "    ],",
                    "    description: \"Which parser to use.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"function\",",
                    "    choices: [",
                    "      { value: \"flow\", description: \"Flow\" },",
                    "      { value: \"babel\", since: \"1.16.0\", description: \"JavaScript\" },",
                    "      { value: \"babel-flow\", since: \"1.16.0\", description: \"Flow\" },",
                    "      { value: \"babel-ts\", since: \"2.0.0\", description: \"TypeScript\" },",
                    "      { value: \"typescript\", since: \"1.4.0\", description: \"TypeScript\" },",
                    "      { value: \"acorn\", since: \"2.6.0\", description: \"JavaScript\" },",
                    "      { value: \"espree\", since: \"2.2.0\", description: \"JavaScript\" },",
                    "      { value: \"meriyah\", since: \"2.2.0\", description: \"JavaScript\" },",
                    "      { value: \"css\", since: \"1.7.1\", description: \"CSS\" },",
                    "      { value: \"less\", since: \"1.7.1\", description: \"Less\" },",
                    "      { value: \"scss\", since: \"1.7.1\", description: \"SCSS\" },",
                    "      { value: \"json\", since: \"1.5.0\", description: \"JSON\" },",
                    "      { value: \"json5\", since: \"1.13.0\", description: \"JSON5\" },",
                    "      {",
                    "        value: \"json-stringify\",",
                    "        since: \"1.13.0\",",
                    "        description: \"JSON.stringify\",",
                    "      },",
                    "      { value: \"graphql\", since: \"1.5.0\", description: \"GraphQL\" },",
                    "      { value: \"markdown\", since: \"1.8.0\", description: \"Markdown\" },",
                    "      { value: \"mdx\", since: \"1.15.0\", description: \"MDX\" },",
                    "      { value: \"vue\", since: \"1.10.0\", description: \"Vue\" },",
                    "      { value: \"yaml\", since: \"1.14.0\", description: \"YAML\" },",
                    "      { value: \"glimmer\", since: \"2.3.0\", description: \"Ember / Handlebars\" },",
                    "      { value: \"html\", since: \"1.15.0\", description: \"HTML\" },",
                    "      { value: \"angular\", since: \"1.15.0\", description: \"Angular\" },",
                    "      {",
                    "        value: \"lwc\",",
                    "        since: \"1.17.0\",",
                    "        description: \"Lightning Web Components\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  plugins: {",
                    "    since: \"1.10.0\",",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description:",
                    "      \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  pluginSearchDirs: {",
                    "    since: \"1.13.0\",",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description: outdent`",
                    "      Custom directory that contains prettier plugins in node_modules subdirectory.",
                    "      Overrides default behavior when plugins are searched relatively to the location of Prettier.",
                    "      Multiple values are accepted.",
                    "    `,",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin-search-dir\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  printWidth: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"int\",",
                    "    default: 80,",
                    "    description: \"The line length where Prettier will try wrap.\",",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "  },",
                    "  rangeEnd: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: Number.POSITIVE_INFINITY,",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Format code ending at a given character offset (exclusive).",
                    "      The range will extend forwards to the end of the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  rangeStart: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: 0,",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Format code starting at a given character offset.",
                    "      The range will extend backwards to the start of the first line containing the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  requirePragma: {",
                    "    since: \"1.7.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: outdent`",
                    "      Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                    "      in order for it to be formatted.",
                    "    `,",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  tabWidth: {",
                    "    type: \"int\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    default: 2,",
                    "    description: \"Number of spaces per indentation level.\",",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "  },",
                    "  useTabs: {",
                    "    since: \"1.0.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent with tabs instead of spaces.\",",
                    "  },",
                    "  embeddedLanguageFormatting: {",
                    "    since: \"2.1.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: [{ since: \"2.1.0\", value: \"auto\" }],",
                    "    description:",
                    "      \"Control how Prettier formats quoted code embedded in the file.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"auto\",",
                    "        description:",
                    "          \"Format embedded code if Prettier can automatically identify it.\",",
                    "      },",
                    "      {",
                    "        value: \"off\",",
                    "        description: \"Never automatically format embedded code.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "};",
                    "",
                    "module.exports = {",
                    "  CATEGORY_CONFIG,",
                    "  CATEGORY_EDITOR,",
                    "  CATEGORY_FORMAT,",
                    "  CATEGORY_OTHER,",
                    "  CATEGORY_OUTPUT,",
                    "  CATEGORY_GLOBAL,",
                    "  CATEGORY_SPECIAL,",
                    "  options,",
                    "};"
                ]
            },
            "core.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { diffArrays } = require(\"diff\");",
                    "",
                    "const {",
                    "  printer: { printDocToString },",
                    "  debug: { printDocToDebug },",
                    "} = require(\"../document/index.js\");",
                    "const { getAlignmentSize } = require(\"../common/util.js\");",
                    "const {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "  countEndOfLineChars,",
                    "  normalizeEndOfLine,",
                    "} = require(\"../common/end-of-line.js\");",
                    "const normalizeOptions = require(\"./options.js\").normalize;",
                    "const massageAST = require(\"./massage-ast.js\");",
                    "const comments = require(\"./comments.js\");",
                    "const parser = require(\"./parser.js\");",
                    "const printAstToDoc = require(\"./ast-to-doc.js\");",
                    "const rangeUtil = require(\"./range-util.js\");",
                    "",
                    "const BOM = \"\\uFEFF\";",
                    "",
                    "const CURSOR = Symbol(\"cursor\");",
                    "",
                    "function attachComments(text, ast, opts) {",
                    "  const astComments = ast.comments;",
                    "  if (astComments) {",
                    "    delete ast.comments;",
                    "    comments.attach(astComments, ast, text, opts);",
                    "  }",
                    "  opts[Symbol.for(\"comments\")] = astComments || [];",
                    "  opts[Symbol.for(\"tokens\")] = ast.tokens || [];",
                    "  opts.originalText = text;",
                    "  return astComments;",
                    "}",
                    "",
                    "function coreFormat(originalText, opts, addAlignmentSize = 0) {",
                    "  if (!originalText || originalText.trim().length === 0) {",
                    "    return { formatted: \"\", cursorOffset: -1, comments: [] };",
                    "  }",
                    "",
                    "  const { ast, text } = parser.parse(originalText, opts);",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    const nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);",
                    "    if (nodeResult && nodeResult.node) {",
                    "      opts.cursorNode = nodeResult.node;",
                    "    }",
                    "  }",
                    "",
                    "  const astComments = attachComments(text, ast, opts);",
                    "  const doc = printAstToDoc(ast, opts, addAlignmentSize);",
                    "",
                    "  const result = printDocToString(doc, opts);",
                    "",
                    "  comments.ensureAllCommentsPrinted(astComments);",
                    "  // Remove extra leading indentation as well as the added indentation after last newline",
                    "  if (addAlignmentSize > 0) {",
                    "    const trimmed = result.formatted.trim();",
                    "",
                    "    if (result.cursorNodeStart !== undefined) {",
                    "      result.cursorNodeStart -= result.formatted.indexOf(trimmed);",
                    "    }",
                    "",
                    "    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);",
                    "  }",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    let oldCursorNodeStart;",
                    "    let oldCursorNodeText;",
                    "",
                    "    let cursorOffsetRelativeToOldCursorNode;",
                    "",
                    "    let newCursorNodeStart;",
                    "    let newCursorNodeText;",
                    "",
                    "    if (opts.cursorNode && result.cursorNodeText) {",
                    "      oldCursorNodeStart = opts.locStart(opts.cursorNode);",
                    "      oldCursorNodeText = text.slice(",
                    "        oldCursorNodeStart,",
                    "        opts.locEnd(opts.cursorNode)",
                    "      );",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode =",
                    "        opts.cursorOffset - oldCursorNodeStart;",
                    "",
                    "      newCursorNodeStart = result.cursorNodeStart;",
                    "      newCursorNodeText = result.cursorNodeText;",
                    "    } else {",
                    "      oldCursorNodeStart = 0;",
                    "      oldCursorNodeText = text;",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;",
                    "",
                    "      newCursorNodeStart = 0;",
                    "      newCursorNodeText = result.formatted;",
                    "    }",
                    "",
                    "    if (oldCursorNodeText === newCursorNodeText) {",
                    "      return {",
                    "        formatted: result.formatted,",
                    "        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,",
                    "        comments: astComments,",
                    "      };",
                    "    }",
                    "",
                    "    // diff old and new cursor node texts, with a special cursor",
                    "    // symbol inserted to find out where it moves to",
                    "",
                    "    const oldCursorNodeCharArray = [...oldCursorNodeText];",
                    "    oldCursorNodeCharArray.splice(",
                    "      cursorOffsetRelativeToOldCursorNode,",
                    "      0,",
                    "      CURSOR",
                    "    );",
                    "",
                    "    const newCursorNodeCharArray = [...newCursorNodeText];",
                    "",
                    "    const cursorNodeDiff = diffArrays(",
                    "      oldCursorNodeCharArray,",
                    "      newCursorNodeCharArray",
                    "    );",
                    "",
                    "    let cursorOffset = newCursorNodeStart;",
                    "    for (const entry of cursorNodeDiff) {",
                    "      if (entry.removed) {",
                    "        if (entry.value.includes(CURSOR)) {",
                    "          break;",
                    "        }",
                    "      } else {",
                    "        cursorOffset += entry.count;",
                    "      }",
                    "    }",
                    "",
                    "    return { formatted: result.formatted, cursorOffset, comments: astComments };",
                    "  }",
                    "",
                    "  return {",
                    "    formatted: result.formatted,",
                    "    cursorOffset: -1,",
                    "    comments: astComments,",
                    "  };",
                    "}",
                    "",
                    "function formatRange(originalText, opts) {",
                    "  const { ast, text } = parser.parse(originalText, opts);",
                    "  const { rangeStart, rangeEnd } = rangeUtil.calculateRange(text, opts, ast);",
                    "  const rangeString = text.slice(rangeStart, rangeEnd);",
                    "",
                    "  // Try to extend the range backwards to the beginning of the line.",
                    "  // This is so we can detect indentation correctly and restore it.",
                    "  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0",
                    "  const rangeStart2 = Math.min(",
                    "    rangeStart,",
                    "    text.lastIndexOf(\"\\n\", rangeStart) + 1",
                    "  );",
                    "  const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];",
                    "",
                    "  const alignmentSize = getAlignmentSize(indentString, opts.tabWidth);",
                    "",
                    "  const rangeResult = coreFormat(",
                    "    rangeString,",
                    "    {",
                    "      ...opts,",
                    "      rangeStart: 0,",
                    "      rangeEnd: Number.POSITIVE_INFINITY,",
                    "      // Track the cursor offset only if it's within our range",
                    "      cursorOffset:",
                    "        opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd",
                    "          ? opts.cursorOffset - rangeStart",
                    "          : -1,",
                    "      // Always use `lf` to format, we'll replace it later",
                    "      endOfLine: \"lf\",",
                    "    },",
                    "    alignmentSize",
                    "  );",
                    "",
                    "  // Since the range contracts to avoid trailing whitespace,",
                    "  // we need to remove the newline that was inserted by the `format` call.",
                    "  const rangeTrimmed = rangeResult.formatted.trimEnd();",
                    "",
                    "  let { cursorOffset } = opts;",
                    "  if (cursorOffset > rangeEnd) {",
                    "    // handle the case where the cursor was past the end of the range",
                    "    cursorOffset += rangeTrimmed.length - rangeString.length;",
                    "  } else if (rangeResult.cursorOffset >= 0) {",
                    "    // handle the case where the cursor was in the range",
                    "    cursorOffset = rangeResult.cursorOffset + rangeStart;",
                    "  }",
                    "  // keep the cursor as it was if it was before the start of the range",
                    "",
                    "  let formatted =",
                    "    text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);",
                    "  if (opts.endOfLine !== \"lf\") {",
                    "    const eol = convertEndOfLineToChars(opts.endOfLine);",
                    "    if (cursorOffset >= 0 && eol === \"\\r\\n\") {",
                    "      cursorOffset += countEndOfLineChars(",
                    "        formatted.slice(0, cursorOffset),",
                    "        \"\\n\"",
                    "      );",
                    "    }",
                    "",
                    "    formatted = formatted.replace(/\\n/g, eol);",
                    "  }",
                    "",
                    "  return { formatted, cursorOffset, comments: rangeResult.comments };",
                    "}",
                    "",
                    "function ensureIndexInText(text, index, defaultValue) {",
                    "  if (",
                    "    typeof index !== \"number\" ||",
                    "    Number.isNaN(index) ||",
                    "    index < 0 ||",
                    "    index > text.length",
                    "  ) {",
                    "    return defaultValue;",
                    "  }",
                    "",
                    "  return index;",
                    "}",
                    "",
                    "function normalizeIndexes(text, options) {",
                    "  let { cursorOffset, rangeStart, rangeEnd } = options;",
                    "  cursorOffset = ensureIndexInText(text, cursorOffset, -1);",
                    "  rangeStart = ensureIndexInText(text, rangeStart, 0);",
                    "  rangeEnd = ensureIndexInText(text, rangeEnd, text.length);",
                    "",
                    "  return { ...options, cursorOffset, rangeStart, rangeEnd };",
                    "}",
                    "",
                    "function normalizeInputAndOptions(text, options) {",
                    "  let { cursorOffset, rangeStart, rangeEnd, endOfLine } = normalizeIndexes(",
                    "    text,",
                    "    options",
                    "  );",
                    "",
                    "  const hasBOM = text.charAt(0) === BOM;",
                    "",
                    "  if (hasBOM) {",
                    "    text = text.slice(1);",
                    "    cursorOffset--;",
                    "    rangeStart--;",
                    "    rangeEnd--;",
                    "  }",
                    "",
                    "  if (endOfLine === \"auto\") {",
                    "    endOfLine = guessEndOfLine(text);",
                    "  }",
                    "",
                    "  // get rid of CR/CRLF parsing",
                    "  if (text.includes(\"\\r\")) {",
                    "    const countCrlfBefore = (index) =>",
                    "      countEndOfLineChars(text.slice(0, Math.max(index, 0)), \"\\r\\n\");",
                    "",
                    "    cursorOffset -= countCrlfBefore(cursorOffset);",
                    "    rangeStart -= countCrlfBefore(rangeStart);",
                    "    rangeEnd -= countCrlfBefore(rangeEnd);",
                    "",
                    "    text = normalizeEndOfLine(text);",
                    "  }",
                    "",
                    "  return {",
                    "    hasBOM,",
                    "    text,",
                    "    options: normalizeIndexes(text, {",
                    "      ...options,",
                    "      cursorOffset,",
                    "      rangeStart,",
                    "      rangeEnd,",
                    "      endOfLine,",
                    "    }),",
                    "  };",
                    "}",
                    "",
                    "function hasPragma(text, options) {",
                    "  const selectedParser = parser.resolveParser(options);",
                    "  return !selectedParser.hasPragma || selectedParser.hasPragma(text);",
                    "}",
                    "",
                    "function formatWithCursor(originalText, originalOptions) {",
                    "  let { hasBOM, text, options } = normalizeInputAndOptions(",
                    "    originalText,",
                    "    normalizeOptions(originalOptions)",
                    "  );",
                    "",
                    "  if (",
                    "    (options.rangeStart >= options.rangeEnd && text !== \"\") ||",
                    "    (options.requirePragma && !hasPragma(text, options))",
                    "  ) {",
                    "    return {",
                    "      formatted: originalText,",
                    "      cursorOffset: originalOptions.cursorOffset,",
                    "      comments: [],",
                    "    };",
                    "  }",
                    "",
                    "  let result;",
                    "",
                    "  if (options.rangeStart > 0 || options.rangeEnd < text.length) {",
                    "    result = formatRange(text, options);",
                    "  } else {",
                    "    if (",
                    "      !options.requirePragma &&",
                    "      options.insertPragma &&",
                    "      options.printer.insertPragma &&",
                    "      !hasPragma(text, options)",
                    "    ) {",
                    "      text = options.printer.insertPragma(text);",
                    "    }",
                    "    result = coreFormat(text, options);",
                    "  }",
                    "",
                    "  if (hasBOM) {",
                    "    result.formatted = BOM + result.formatted;",
                    "",
                    "    if (result.cursorOffset >= 0) {",
                    "      result.cursorOffset++;",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "module.exports = {",
                    "  formatWithCursor,",
                    "",
                    "  parse(originalText, originalOptions, massage) {",
                    "    const { text, options } = normalizeInputAndOptions(",
                    "      originalText,",
                    "      normalizeOptions(originalOptions)",
                    "    );",
                    "    const parsed = parser.parse(text, options);",
                    "    if (massage) {",
                    "      parsed.ast = massageAST(parsed.ast, options);",
                    "    }",
                    "    return parsed;",
                    "  },",
                    "",
                    "  formatAST(ast, options) {",
                    "    options = normalizeOptions(options);",
                    "    const doc = printAstToDoc(ast, options);",
                    "    return printDocToString(doc, options);",
                    "  },",
                    "",
                    "  // Doesn't handle shebang for now",
                    "  formatDoc(doc, options) {",
                    "    return formatWithCursor(printDocToDebug(doc), {",
                    "      ...options,",
                    "      parser: \"__js_expression\",",
                    "    }).formatted;",
                    "  },",
                    "",
                    "  printToDoc(originalText, options) {",
                    "    options = normalizeOptions(options);",
                    "    const { ast, text } = parser.parse(originalText, options);",
                    "    attachComments(text, ast, options);",
                    "    return printAstToDoc(ast, options);",
                    "  },",
                    "",
                    "  printDocToString(doc, options) {",
                    "    return printDocToString(doc, normalizeOptions(options));",
                    "  },",
                    "};"
                ]
            },
            "load-parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// This module only works in Node.js",
                    "// Will be replaced when bundling `standalone.js`",
                    "",
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const { ConfigError } = require(\"../common/errors.js\");",
                    "const { locStart, locEnd } = require(\"../language-js/loc.js\");",
                    "",
                    "function requireParser(parser) {",
                    "  try {",
                    "    return {",
                    "      parse: require(path.resolve(process.cwd(), parser)),",
                    "      astFormat: \"estree\",",
                    "      locStart,",
                    "      locEnd,",
                    "    };",
                    "  } catch {",
                    "    /* istanbul ignore next */",
                    "    throw new ConfigError(`Couldn't resolve parser \"${parser}\"`);",
                    "  }",
                    "}",
                    "",
                    "module.exports = requireParser;"
                ]
            },
            "massage-ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function massageAST(ast, options, parent) {",
                    "  if (Array.isArray(ast)) {",
                    "    return ast.map((e) => massageAST(e, options, parent)).filter(Boolean);",
                    "  }",
                    "",
                    "  if (!ast || typeof ast !== \"object\") {",
                    "    return ast;",
                    "  }",
                    "",
                    "  const cleanFunction = options.printer.massageAstNode;",
                    "  let ignoredProperties;",
                    "  if (cleanFunction && cleanFunction.ignoredProperties) {",
                    "    ignoredProperties = cleanFunction.ignoredProperties;",
                    "  } else {",
                    "    ignoredProperties = new Set();",
                    "  }",
                    "",
                    "  const newObj = {};",
                    "  for (const [key, value] of Object.entries(ast)) {",
                    "    if (!ignoredProperties.has(key) && typeof value !== \"function\") {",
                    "      newObj[key] = massageAST(value, options, ast);",
                    "    }",
                    "  }",
                    "",
                    "  if (cleanFunction) {",
                    "    const result = cleanFunction(ast, newObj, parent);",
                    "    if (result === null) {",
                    "      return;",
                    "    }",
                    "    if (result) {",
                    "      return result;",
                    "    }",
                    "  }",
                    "",
                    "  return newObj;",
                    "}",
                    "",
                    "module.exports = massageAST;"
                ]
            },
            "multiparser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  utils: { stripTrailingHardline },",
                    "} = require(\"../document/index.js\");",
                    "const { normalize } = require(\"./options.js\");",
                    "const comments = require(\"./comments.js\");",
                    "",
                    "function printSubtree(path, print, options, printAstToDoc) {",
                    "  if (options.printer.embed && options.embeddedLanguageFormatting === \"auto\") {",
                    "    return options.printer.embed(",
                    "      path,",
                    "      print,",
                    "      (text, partialNextOptions, textToDocOptions) =>",
                    "        textToDoc(",
                    "          text,",
                    "          partialNextOptions,",
                    "          options,",
                    "          printAstToDoc,",
                    "          textToDocOptions",
                    "        ),",
                    "      options",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function textToDoc(",
                    "  text,",
                    "  partialNextOptions,",
                    "  parentOptions,",
                    "  printAstToDoc,",
                    "  // TODO: remove `stripTrailingHardline` in v3.0.0",
                    "  { stripTrailingHardline: shouldStripTrailingHardline = false } = {}",
                    ") {",
                    "  const nextOptions = normalize(",
                    "    {",
                    "      ...parentOptions,",
                    "      ...partialNextOptions,",
                    "      parentParser: parentOptions.parser,",
                    "      originalText: text,",
                    "    },",
                    "    { passThrough: true }",
                    "  );",
                    "",
                    "  const result = require(\"./parser.js\").parse(text, nextOptions);",
                    "  const { ast } = result;",
                    "  text = result.text;",
                    "",
                    "  const astComments = ast.comments;",
                    "  delete ast.comments;",
                    "  comments.attach(astComments, ast, text, nextOptions);",
                    "  // @ts-expect-error -- Casting to `unique symbol` isn't allowed in JSDoc comment",
                    "  nextOptions[Symbol.for(\"comments\")] = astComments || [];",
                    "  // @ts-expect-error -- Casting to `unique symbol` isn't allowed in JSDoc comment",
                    "  nextOptions[Symbol.for(\"tokens\")] = ast.tokens || [];",
                    "",
                    "  const doc = printAstToDoc(ast, nextOptions);",
                    "  comments.ensureAllCommentsPrinted(astComments);",
                    "",
                    "  if (shouldStripTrailingHardline) {",
                    "    // TODO: move this to `stripTrailingHardline` function in `/src/document/doc-utils.js`",
                    "    if (typeof doc === \"string\") {",
                    "      return doc.replace(/(?:\\r?\\n)*$/, \"\");",
                    "    }",
                    "",
                    "    return stripTrailingHardline(doc);",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  return doc;",
                    "}",
                    "",
                    "module.exports = {",
                    "  printSubtree,",
                    "};"
                ]
            },
            "options-normalizer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const vnopts = require(\"vnopts\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "",
                    "/**",
                    " * @typedef {import(\"./support\").NamedOptionInfo} NamedOptionInfo",
                    " */",
                    "",
                    "const cliDescriptor = {",
                    "  key: (key) => (key.length === 1 ? `-${key}` : `--${key}`),",
                    "  value: (value) => vnopts.apiDescriptor.value(value),",
                    "  pair: ({ key, value }) =>",
                    "    value === false",
                    "      ? `--no-${key}`",
                    "      : value === true",
                    "      ? cliDescriptor.key(key)",
                    "      : value === \"\"",
                    "      ? `${cliDescriptor.key(key)} without an argument`",
                    "      : `${cliDescriptor.key(key)}=${value}`,",
                    "};",
                    "",
                    "// To prevent `chalk` and `leven` module from being included in the `standalone.js` bundle, it will take that as an argument if needed.",
                    "const getFlagSchema = ({ colorsModule, levenshteinDistance }) =>",
                    "  class FlagSchema extends vnopts.ChoiceSchema {",
                    "    constructor({ name, flags }) {",
                    "      super({ name, choices: flags });",
                    "      this._flags = [...flags].sort();",
                    "    }",
                    "    preprocess(value, utils) {",
                    "      if (",
                    "        typeof value === \"string\" &&",
                    "        value.length > 0 &&",
                    "        !this._flags.includes(value)",
                    "      ) {",
                    "        const suggestion = this._flags.find(",
                    "          (flag) => levenshteinDistance(flag, value) < 3",
                    "        );",
                    "        if (suggestion) {",
                    "          utils.logger.warn(",
                    "            [",
                    "              `Unknown flag ${colorsModule.yellow(",
                    "                utils.descriptor.value(value)",
                    "              )},`,",
                    "              `did you mean ${colorsModule.blue(",
                    "                utils.descriptor.value(suggestion)",
                    "              )}?`,",
                    "            ].join(\" \")",
                    "          );",
                    "          return suggestion;",
                    "        }",
                    "      }",
                    "      return value;",
                    "    }",
                    "    expected() {",
                    "      return \"a flag\";",
                    "    }",
                    "  };",
                    "",
                    "let hasDeprecationWarned;",
                    "",
                    "/**",
                    " * @param {*} options",
                    " * @param {*} optionInfos",
                    " * @param {{ logger?: false; isCLI?: boolean; passThrough?: boolean; colorsModule?: any; levenshteinDistance?: any }} param2",
                    " */",
                    "function normalizeOptions(",
                    "  options,",
                    "  optionInfos,",
                    "  {",
                    "    logger = false,",
                    "    isCLI = false,",
                    "    passThrough = false,",
                    "    colorsModule = null,",
                    "    levenshteinDistance = null,",
                    "  } = {}",
                    ") {",
                    "  const unknown = !passThrough",
                    "    ? (key, value, options) => {",
                    "        // Don't suggest `_` for unknown flags",
                    "        const { _, ...schemas } = options.schemas;",
                    "        return vnopts.levenUnknownHandler(key, value, {",
                    "          ...options,",
                    "          schemas,",
                    "        });",
                    "      }",
                    "    : Array.isArray(passThrough)",
                    "    ? (key, value) =>",
                    "        !passThrough.includes(key) ? undefined : { [key]: value }",
                    "    : (key, value) => ({ [key]: value });",
                    "",
                    "  const descriptor = isCLI ? cliDescriptor : vnopts.apiDescriptor;",
                    "  const schemas = optionInfosToSchemas(optionInfos, {",
                    "    isCLI,",
                    "    colorsModule,",
                    "    levenshteinDistance,",
                    "  });",
                    "  const normalizer = new vnopts.Normalizer(schemas, {",
                    "    logger,",
                    "    unknown,",
                    "    descriptor,",
                    "  });",
                    "",
                    "  const shouldSuppressDuplicateDeprecationWarnings = logger !== false;",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {",
                    "    // @ts-expect-error",
                    "    normalizer._hasDeprecationWarned = hasDeprecationWarned;",
                    "  }",
                    "",
                    "  const normalized = normalizer.normalize(options);",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings) {",
                    "    // @ts-expect-error",
                    "    hasDeprecationWarned = normalizer._hasDeprecationWarned;",
                    "  }",
                    "",
                    "  if (isCLI && normalized[\"plugin-search\"] === false) {",
                    "    normalized[\"plugin-search-dir\"] = false;",
                    "  }",
                    "",
                    "  return normalized;",
                    "}",
                    "",
                    "function optionInfosToSchemas(",
                    "  optionInfos,",
                    "  { isCLI, colorsModule, levenshteinDistance }",
                    ") {",
                    "  const schemas = [];",
                    "",
                    "  if (isCLI) {",
                    "    schemas.push(vnopts.AnySchema.create({ name: \"_\" }));",
                    "  }",
                    "",
                    "  for (const optionInfo of optionInfos) {",
                    "    schemas.push(",
                    "      optionInfoToSchema(optionInfo, {",
                    "        isCLI,",
                    "        optionInfos,",
                    "        colorsModule,",
                    "        levenshteinDistance,",
                    "      })",
                    "    );",
                    "",
                    "    if (optionInfo.alias && isCLI) {",
                    "      schemas.push(",
                    "        vnopts.AliasSchema.create({",
                    "          // @ts-expect-error",
                    "          name: optionInfo.alias,",
                    "          sourceName: optionInfo.name,",
                    "        })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return schemas;",
                    "}",
                    "",
                    "/**",
                    " * @param {NamedOptionInfo} optionInfo",
                    " * @param {any} param1",
                    " * @returns",
                    " */",
                    "function optionInfoToSchema(",
                    "  optionInfo,",
                    "  { isCLI, optionInfos, colorsModule, levenshteinDistance }",
                    ") {",
                    "  const { name } = optionInfo;",
                    "",
                    "  if (name === \"plugin-search-dir\" || name === \"pluginSearchDirs\") {",
                    "    return vnopts.AnySchema.create({",
                    "      // @ts-expect-error",
                    "      name,",
                    "      preprocess(value) {",
                    "        if (value === false) {",
                    "          return value;",
                    "        }",
                    "        value = Array.isArray(value) ? value : [value];",
                    "        return value;",
                    "      },",
                    "      /**",
                    "       * @param {Array<unknown> | false} value",
                    "       */",
                    "      validate(value) {",
                    "        if (value === false) {",
                    "          return true;",
                    "        }",
                    "        return value.every((dir) => typeof dir === \"string\");",
                    "      },",
                    "      expected() {",
                    "        return \"false or paths to plugin search dir\";",
                    "      },",
                    "    });",
                    "  }",
                    "",
                    "  const parameters = { name };",
                    "  let SchemaConstructor;",
                    "  const handlers = {};",
                    "",
                    "  switch (optionInfo.type) {",
                    "    case \"int\":",
                    "      SchemaConstructor = vnopts.IntegerSchema;",
                    "      if (isCLI) {",
                    "        parameters.preprocess = Number;",
                    "      }",
                    "      break;",
                    "    case \"string\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    case \"choice\":",
                    "      SchemaConstructor = vnopts.ChoiceSchema;",
                    "      parameters.choices = optionInfo.choices.map((choiceInfo) =>",
                    "        typeof choiceInfo === \"object\" && choiceInfo.redirect",
                    "          ? {",
                    "              ...choiceInfo,",
                    "              redirect: {",
                    "                to: { key: optionInfo.name, value: choiceInfo.redirect },",
                    "              },",
                    "            }",
                    "          : choiceInfo",
                    "      );",
                    "      break;",
                    "    case \"boolean\":",
                    "      SchemaConstructor = vnopts.BooleanSchema;",
                    "      break;",
                    "    case \"flag\":",
                    "      SchemaConstructor = getFlagSchema({ colorsModule, levenshteinDistance });",
                    "      parameters.flags = optionInfos.flatMap((optionInfo) =>",
                    "        [",
                    "          optionInfo.alias,",
                    "          optionInfo.description && optionInfo.name,",
                    "          optionInfo.oppositeDescription && `no-${optionInfo.name}`,",
                    "        ].filter(Boolean)",
                    "      );",
                    "      break;",
                    "    case \"path\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unexpected type ${optionInfo.type}`);",
                    "  }",
                    "",
                    "  if (optionInfo.exception) {",
                    "    parameters.validate = (value, schema, utils) =>",
                    "      optionInfo.exception(value) || schema.validate(value, utils);",
                    "  } else {",
                    "    parameters.validate = (value, schema, utils) =>",
                    "      value === undefined || schema.validate(value, utils);",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (optionInfo.redirect) {",
                    "    handlers.redirect = (value) =>",
                    "      !value",
                    "        ? undefined",
                    "        : {",
                    "            to: {",
                    "              key: optionInfo.redirect.option,",
                    "              value: optionInfo.redirect.value,",
                    "            },",
                    "          };",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (optionInfo.deprecated) {",
                    "    handlers.deprecated = true;",
                    "  }",
                    "",
                    "  // allow CLI overriding, e.g., prettier package.json --tab-width 1 --tab-width 2",
                    "  if (isCLI && !optionInfo.array) {",
                    "    const originalPreprocess = parameters.preprocess || ((x) => x);",
                    "    parameters.preprocess = (value, schema, utils) =>",
                    "      schema.preprocess(",
                    "        originalPreprocess(Array.isArray(value) ? getLast(value) : value),",
                    "        utils",
                    "      );",
                    "  }",
                    "",
                    "  return optionInfo.array",
                    "    ? vnopts.ArraySchema.create({",
                    "        ...(isCLI ? { preprocess: (v) => (Array.isArray(v) ? v : [v]) } : {}),",
                    "        ...handlers,",
                    "        // @ts-expect-error",
                    "        valueSchema: SchemaConstructor.create(parameters),",
                    "      })",
                    "    : SchemaConstructor.create({ ...parameters, ...handlers });",
                    "}",
                    "",
                    "function normalizeApiOptions(options, optionInfos, opts) {",
                    "  return normalizeOptions(options, optionInfos, opts);",
                    "}",
                    "",
                    "function normalizeCliOptions(options, optionInfos, opts) {",
                    "  /* istanbul ignore next */",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    if (!opts.colorsModule) {",
                    "      throw new Error(\"'colorsModule' option is required.\");",
                    "    }",
                    "",
                    "    if (!opts.levenshteinDistance) {",
                    "      throw new Error(\"'levenshteinDistance' option is required.\");",
                    "    }",
                    "  }",
                    "",
                    "  return normalizeOptions(options, optionInfos, { isCLI: true, ...opts });",
                    "}",
                    "",
                    "module.exports = {",
                    "  normalizeApiOptions,",
                    "  normalizeCliOptions,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const { UndefinedParserError } = require(\"../common/errors.js\");",
                    "const { getSupportInfo } = require(\"../main/support.js\");",
                    "const normalizer = require(\"./options-normalizer.js\");",
                    "const { resolveParser } = require(\"./parser.js\");",
                    "",
                    "const hiddenDefaults = {",
                    "  astFormat: \"estree\",",
                    "  printer: {},",
                    "  originalText: undefined,",
                    "  locStart: null,",
                    "  locEnd: null,",
                    "};",
                    "",
                    "// Copy options and fill in default values.",
                    "function normalize(options, opts = {}) {",
                    "  const rawOptions = { ...options };",
                    "",
                    "  const supportOptions = getSupportInfo({",
                    "    plugins: options.plugins,",
                    "    showUnreleased: true,",
                    "    showDeprecated: true,",
                    "  }).options;",
                    "",
                    "  const defaults = {",
                    "    ...hiddenDefaults,",
                    "    ...Object.fromEntries(",
                    "      supportOptions",
                    "        .filter((optionInfo) => optionInfo.default !== undefined)",
                    "        .map((option) => [option.name, option.default])",
                    "    ),",
                    "  };",
                    "  if (!rawOptions.parser) {",
                    "    if (!rawOptions.filepath) {",
                    "      const logger = opts.logger || console;",
                    "      logger.warn(",
                    "        \"No parser and no filepath given, using 'babel' the parser now \" +",
                    "          \"but this will throw an error in the future. \" +",
                    "          \"Please specify a parser or a filepath so one can be inferred.\"",
                    "      );",
                    "      rawOptions.parser = \"babel\";",
                    "    } else {",
                    "      rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);",
                    "      if (!rawOptions.parser) {",
                    "        throw new UndefinedParserError(",
                    "          `No parser could be inferred for file: ${rawOptions.filepath}`",
                    "        );",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const parser = resolveParser(",
                    "    normalizer.normalizeApiOptions(",
                    "      rawOptions,",
                    "      [supportOptions.find((x) => x.name === \"parser\")],",
                    "      { passThrough: true, logger: false }",
                    "    )",
                    "  );",
                    "  rawOptions.astFormat = parser.astFormat;",
                    "  rawOptions.locEnd = parser.locEnd;",
                    "  rawOptions.locStart = parser.locStart;",
                    "",
                    "  const plugin = getPlugin(rawOptions);",
                    "  rawOptions.printer = plugin.printers[rawOptions.astFormat];",
                    "",
                    "  const pluginDefaults = Object.fromEntries(",
                    "    supportOptions",
                    "      .filter(",
                    "        (optionInfo) =>",
                    "          optionInfo.pluginDefaults &&",
                    "          optionInfo.pluginDefaults[plugin.name] !== undefined",
                    "      )",
                    "      .map((optionInfo) => [",
                    "        optionInfo.name,",
                    "        optionInfo.pluginDefaults[plugin.name],",
                    "      ])",
                    "  );",
                    "",
                    "  const mixedDefaults = { ...defaults, ...pluginDefaults };",
                    "",
                    "  for (const [k, value] of Object.entries(mixedDefaults)) {",
                    "    if (rawOptions[k] === null || rawOptions[k] === undefined) {",
                    "      rawOptions[k] = value;",
                    "    }",
                    "  }",
                    "",
                    "  if (rawOptions.parser === \"json\") {",
                    "    rawOptions.trailingComma = \"none\";",
                    "  }",
                    "",
                    "  return normalizer.normalizeApiOptions(rawOptions, supportOptions, {",
                    "    passThrough: Object.keys(hiddenDefaults),",
                    "    ...opts,",
                    "  });",
                    "}",
                    "",
                    "function getPlugin(options) {",
                    "  const { astFormat } = options;",
                    "",
                    "  // TODO: test this with plugins",
                    "  /* istanbul ignore next */",
                    "  if (!astFormat) {",
                    "    throw new Error(\"getPlugin() requires astFormat to be set\");",
                    "  }",
                    "  const printerPlugin = options.plugins.find(",
                    "    (plugin) => plugin.printers && plugin.printers[astFormat]",
                    "  );",
                    "  // TODO: test this with plugins",
                    "  /* istanbul ignore next */",
                    "  if (!printerPlugin) {",
                    "    throw new Error(`Couldn't find plugin for AST format \"${astFormat}\"`);",
                    "  }",
                    "",
                    "  return printerPlugin;",
                    "}",
                    "",
                    "function inferParser(filepath, plugins) {",
                    "  const filename = path.basename(filepath).toLowerCase();",
                    "  const languages = getSupportInfo({ plugins }).languages.filter(",
                    "    (language) => language.since !== null",
                    "  );",
                    "",
                    "  // If the file has no extension, we can try to infer the language from the",
                    "  // interpreter in the shebang line, if any; but since this requires FS access,",
                    "  // do it last.",
                    "  let language = languages.find(",
                    "    (language) =>",
                    "      (language.extensions &&",
                    "        language.extensions.some((extension) =>",
                    "          filename.endsWith(extension)",
                    "        )) ||",
                    "      (language.filenames &&",
                    "        language.filenames.some((name) => name.toLowerCase() === filename))",
                    "  );",
                    "",
                    "  if (",
                    "    process.env.PRETTIER_TARGET !== \"universal\" &&",
                    "    !language &&",
                    "    !filename.includes(\".\")",
                    "  ) {",
                    "    // `getInterpreter` requires file access, put `require()` in the `if` block,",
                    "    // So we can easily remove this part during build",
                    "    const getInterpreter = require(\"../utils/get-interpreter.js\");",
                    "    const interpreter = getInterpreter(filepath);",
                    "    language = languages.find(",
                    "      (language) =>",
                    "        language.interpreters && language.interpreters.includes(interpreter)",
                    "    );",
                    "  }",
                    "",
                    "  return language && language.parsers[0];",
                    "}",
                    "",
                    "module.exports = { normalize, hiddenDefaults, inferParser };"
                ]
            },
            "parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { ConfigError } = require(\"../common/errors.js\");",
                    "const jsLoc = require(\"../language-js/loc.js\");",
                    "const loadParser = require(\"./load-parser.js\");",
                    "",
                    "const { locStart, locEnd } = jsLoc;",
                    "",
                    "// Use defineProperties()/getOwnPropertyDescriptor() to prevent",
                    "// triggering the parsers getters.",
                    "const ownNames = Object.getOwnPropertyNames;",
                    "const ownDescriptor = Object.getOwnPropertyDescriptor;",
                    "function getParsers(options) {",
                    "  const parsers = {};",
                    "  for (const plugin of options.plugins) {",
                    "    // TODO: test this with plugins",
                    "    /* istanbul ignore next */",
                    "    if (!plugin.parsers) {",
                    "      continue;",
                    "    }",
                    "",
                    "    for (const name of ownNames(plugin.parsers)) {",
                    "      Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));",
                    "    }",
                    "  }",
                    "",
                    "  return parsers;",
                    "}",
                    "",
                    "function resolveParser(opts, parsers = getParsers(opts)) {",
                    "  if (typeof opts.parser === \"function\") {",
                    "    // Custom parser API always works with JavaScript.",
                    "    return {",
                    "      parse: opts.parser,",
                    "      astFormat: \"estree\",",
                    "      locStart,",
                    "      locEnd,",
                    "    };",
                    "  }",
                    "",
                    "  if (typeof opts.parser === \"string\") {",
                    "    if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {",
                    "      return parsers[opts.parser];",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    if (process.env.PRETTIER_TARGET === \"universal\") {",
                    "      throw new ConfigError(",
                    "        `Couldn't resolve parser \"${opts.parser}\". Parsers must be explicitly added to the standalone bundle.`",
                    "      );",
                    "    }",
                    "",
                    "    return loadParser(opts.parser);",
                    "  }",
                    "}",
                    "",
                    "function parse(text, opts) {",
                    "  const parsers = getParsers(opts);",
                    "",
                    "  // Create a new object {parserName: parseFn}. Uses defineProperty() to only call",
                    "  // the parsers getters when actually calling the parser `parse` function.",
                    "  const parsersForCustomParserApi = Object.defineProperties(",
                    "    {},",
                    "    Object.fromEntries(",
                    "      Object.keys(parsers).map((parserName) => [",
                    "        parserName,",
                    "        {",
                    "          enumerable: true,",
                    "          get() {",
                    "            return parsers[parserName].parse;",
                    "          },",
                    "        },",
                    "      ])",
                    "    )",
                    "  );",
                    "",
                    "  const parser = resolveParser(opts, parsers);",
                    "",
                    "  try {",
                    "    if (parser.preprocess) {",
                    "      text = parser.preprocess(text, opts);",
                    "    }",
                    "",
                    "    return {",
                    "      text,",
                    "      ast: parser.parse(text, parsersForCustomParserApi, opts),",
                    "    };",
                    "  } catch (error) {",
                    "    const { loc } = error;",
                    "",
                    "    if (loc) {",
                    "      const { codeFrameColumns } = require(\"@babel/code-frame\");",
                    "      error.codeFrame = codeFrameColumns(text, loc, { highlightCode: true });",
                    "      error.message += \"\\n\" + error.codeFrame;",
                    "      throw error;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw error;",
                    "  }",
                    "}",
                    "",
                    "module.exports = { parse, resolveParser };"
                ]
            },
            "range-util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "const comments = require(\"./comments.js\");",
                    "",
                    "const isJsonParser = ({ parser }) =>",
                    "  parser === \"json\" || parser === \"json5\" || parser === \"json-stringify\";",
                    "",
                    "function findCommonAncestor(startNodeAndParents, endNodeAndParents) {",
                    "  const startNodeAndAncestors = [",
                    "    startNodeAndParents.node,",
                    "    ...startNodeAndParents.parentNodes,",
                    "  ];",
                    "  const endNodeAndAncestors = new Set([",
                    "    endNodeAndParents.node,",
                    "    ...endNodeAndParents.parentNodes,",
                    "  ]);",
                    "  return startNodeAndAncestors.find(",
                    "    (node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node)",
                    "  );",
                    "}",
                    "",
                    "function dropRootParents(parents) {",
                    "  let lastParentIndex = parents.length - 1;",
                    "  for (;;) {",
                    "    const parent = parents[lastParentIndex];",
                    "    if (parent && (parent.type === \"Program\" || parent.type === \"File\")) {",
                    "      lastParentIndex--;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "  return parents.slice(0, lastParentIndex + 1);",
                    "}",
                    "",
                    "function findSiblingAncestors(",
                    "  startNodeAndParents,",
                    "  endNodeAndParents,",
                    "  { locStart, locEnd }",
                    ") {",
                    "  let resultStartNode = startNodeAndParents.node;",
                    "  let resultEndNode = endNodeAndParents.node;",
                    "",
                    "  if (resultStartNode === resultEndNode) {",
                    "    return {",
                    "      startNode: resultStartNode,",
                    "      endNode: resultEndNode,",
                    "    };",
                    "  }",
                    "",
                    "  const startNodeStart = locStart(startNodeAndParents.node);",
                    "  for (const endParent of dropRootParents(endNodeAndParents.parentNodes)) {",
                    "    if (locStart(endParent) >= startNodeStart) {",
                    "      resultEndNode = endParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  const endNodeEnd = locEnd(endNodeAndParents.node);",
                    "  for (const startParent of dropRootParents(startNodeAndParents.parentNodes)) {",
                    "    if (locEnd(startParent) <= endNodeEnd) {",
                    "      resultStartNode = startParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "    if (resultStartNode === resultEndNode) {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  return {",
                    "    startNode: resultStartNode,",
                    "    endNode: resultEndNode,",
                    "  };",
                    "}",
                    "",
                    "function findNodeAtOffset(",
                    "  node,",
                    "  offset,",
                    "  options,",
                    "  predicate,",
                    "  parentNodes = [],",
                    "  type",
                    ") {",
                    "  const { locStart, locEnd } = options;",
                    "  const start = locStart(node);",
                    "  const end = locEnd(node);",
                    "",
                    "  if (",
                    "    offset > end ||",
                    "    offset < start ||",
                    "    (type === \"rangeEnd\" && offset === start) ||",
                    "    (type === \"rangeStart\" && offset === end)",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  for (const childNode of comments.getSortedChildNodes(node, options)) {",
                    "    const childResult = findNodeAtOffset(",
                    "      childNode,",
                    "      offset,",
                    "      options,",
                    "      predicate,",
                    "      [node, ...parentNodes],",
                    "      type",
                    "    );",
                    "    if (childResult) {",
                    "      return childResult;",
                    "    }",
                    "  }",
                    "",
                    "  if (!predicate || predicate(node, parentNodes[0])) {",
                    "    return {",
                    "      node,",
                    "      parentNodes,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "// See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5",
                    "function isJsSourceElement(type, parentType) {",
                    "  return (",
                    "    parentType !== \"DeclareExportDeclaration\" &&",
                    "    type !== \"TypeParameterDeclaration\" &&",
                    "    (type === \"Directive\" ||",
                    "      type === \"TypeAlias\" ||",
                    "      type === \"TSExportAssignment\" ||",
                    "      type.startsWith(\"Declare\") ||",
                    "      type.startsWith(\"TSDeclare\") ||",
                    "      type.endsWith(\"Statement\") ||",
                    "      type.endsWith(\"Declaration\"))",
                    "  );",
                    "}",
                    "",
                    "const jsonSourceElements = new Set([",
                    "  \"ObjectExpression\",",
                    "  \"ArrayExpression\",",
                    "  \"StringLiteral\",",
                    "  \"NumericLiteral\",",
                    "  \"BooleanLiteral\",",
                    "  \"NullLiteral\",",
                    "  \"UnaryExpression\",",
                    "  \"TemplateLiteral\",",
                    "]);",
                    "const graphqlSourceElements = new Set([",
                    "  \"OperationDefinition\",",
                    "  \"FragmentDefinition\",",
                    "  \"VariableDefinition\",",
                    "  \"TypeExtensionDefinition\",",
                    "  \"ObjectTypeDefinition\",",
                    "  \"FieldDefinition\",",
                    "  \"DirectiveDefinition\",",
                    "  \"EnumTypeDefinition\",",
                    "  \"EnumValueDefinition\",",
                    "  \"InputValueDefinition\",",
                    "  \"InputObjectTypeDefinition\",",
                    "  \"SchemaDefinition\",",
                    "  \"OperationTypeDefinition\",",
                    "  \"InterfaceTypeDefinition\",",
                    "  \"UnionTypeDefinition\",",
                    "  \"ScalarTypeDefinition\",",
                    "]);",
                    "function isSourceElement(opts, node, parentNode) {",
                    "  /* istanbul ignore next */",
                    "  if (!node) {",
                    "    return false;",
                    "  }",
                    "  switch (opts.parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"__babel_estree\":",
                    "      return isJsSourceElement(node.type, parentNode && parentNode.type);",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      return jsonSourceElements.has(node.type);",
                    "    case \"graphql\":",
                    "      return graphqlSourceElements.has(node.kind);",
                    "    case \"vue\":",
                    "      return node.tag !== \"root\";",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function calculateRange(text, opts, ast) {",
                    "  let { rangeStart: start, rangeEnd: end, locStart, locEnd } = opts;",
                    "  assert.ok(end > start);",
                    "  // Contract the range so that it has non-whitespace characters at its endpoints.",
                    "  // This ensures we can format a range that doesn't end on a node.",
                    "  const firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\\S/);",
                    "  const isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;",
                    "  if (!isAllWhitespace) {",
                    "    start += firstNonWhitespaceCharacterIndex;",
                    "    for (; end > start; --end) {",
                    "      if (/\\S/.test(text[end - 1])) {",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const startNodeAndParents = findNodeAtOffset(",
                    "    ast,",
                    "    start,",
                    "    opts,",
                    "    (node, parentNode) => isSourceElement(opts, node, parentNode),",
                    "    [],",
                    "    \"rangeStart\"",
                    "  );",
                    "  const endNodeAndParents =",
                    "    // No need find Node at `end`, it will be the same as `startNodeAndParents`",
                    "    isAllWhitespace",
                    "      ? startNodeAndParents",
                    "      : findNodeAtOffset(",
                    "          ast,",
                    "          end,",
                    "          opts,",
                    "          (node) => isSourceElement(opts, node),",
                    "          [],",
                    "          \"rangeEnd\"",
                    "        );",
                    "  if (!startNodeAndParents || !endNodeAndParents) {",
                    "    return {",
                    "      rangeStart: 0,",
                    "      rangeEnd: 0,",
                    "    };",
                    "  }",
                    "",
                    "  let startNode;",
                    "  let endNode;",
                    "  if (isJsonParser(opts)) {",
                    "    const commonAncestor = findCommonAncestor(",
                    "      startNodeAndParents,",
                    "      endNodeAndParents",
                    "    );",
                    "    startNode = commonAncestor;",
                    "    endNode = commonAncestor;",
                    "  } else {",
                    "    ({ startNode, endNode } = findSiblingAncestors(",
                    "      startNodeAndParents,",
                    "      endNodeAndParents,",
                    "      opts",
                    "    ));",
                    "  }",
                    "",
                    "  return {",
                    "    rangeStart: Math.min(locStart(startNode), locStart(endNode)),",
                    "    rangeEnd: Math.max(locEnd(startNode), locEnd(endNode)),",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  calculateRange,",
                    "  findNodeAtOffset,",
                    "};"
                ]
            },
            "support.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const semver = {",
                    "  compare: require(\"semver/functions/compare\"),",
                    "  lt: require(\"semver/functions/lt\"),",
                    "  gte: require(\"semver/functions/gte\"),",
                    "};",
                    "const arrayify = require(\"../utils/arrayify.js\");",
                    "const currentVersion = require(\"../../package.json\").version;",
                    "const coreOptions = require(\"./core-options.js\").options;",
                    "",
                    "/**",
                    " * @typedef {import(\"./core-options\").OptionInfo} OptionInfo",
                    " * @typedef {{ name: string; pluginDefaults: Array<any> } & OptionInfo} NamedOptionInfo",
                    " */",
                    "",
                    "/**",
                    " * Strings in `plugins` and `pluginSearchDirs` are handled by a wrapped version",
                    " * of this function created by `withPlugins`. Don't pass them here directly.",
                    " * @param {object} param0",
                    " * @param {(string | object)[]=} param0.plugins Strings are resolved by `withPlugins`.",
                    " * @param {string[]=} param0.pluginSearchDirs Added by `withPlugins`.",
                    " * @param {boolean=} param0.showUnreleased",
                    " * @param {boolean=} param0.showDeprecated",
                    " * @param {boolean=} param0.showInternal",
                    " * @return {{ languages: Array<any>, options: Array<NamedOptionInfo> }}",
                    " */",
                    "function getSupportInfo({",
                    "  plugins = [],",
                    "  showUnreleased = false,",
                    "  showDeprecated = false,",
                    "  showInternal = false,",
                    "} = {}) {",
                    "  // pre-release version is smaller than the normal version in semver,",
                    "  // we need to treat it as the normal one so as to test new features.",
                    "  const version = currentVersion.split(\"-\", 1)[0];",
                    "",
                    "  const languages = plugins",
                    "    .flatMap((plugin) => plugin.languages || [])",
                    "    .filter(filterSince);",
                    "",
                    "  const options = arrayify(",
                    "    Object.assign({}, ...plugins.map(({ options }) => options), coreOptions),",
                    "    \"name\"",
                    "  )",
                    "    .filter((option) => filterSince(option) && filterDeprecated(option))",
                    "    .sort((a, b) => (a.name === b.name ? 0 : a.name < b.name ? -1 : 1))",
                    "    .map(mapInternal)",
                    "    .map((option) => {",
                    "      option = { ...option };",
                    "",
                    "      if (Array.isArray(option.default)) {",
                    "        option.default =",
                    "          option.default.length === 1",
                    "            ? option.default[0].value",
                    "            : option.default",
                    "                .filter(filterSince)",
                    "                .sort((info1, info2) =>",
                    "                  semver.compare(info2.since, info1.since)",
                    "                )[0].value;",
                    "      }",
                    "",
                    "      if (Array.isArray(option.choices)) {",
                    "        option.choices = option.choices.filter(",
                    "          (option) => filterSince(option) && filterDeprecated(option)",
                    "        );",
                    "",
                    "        if (option.name === \"parser\") {",
                    "          collectParsersFromLanguages(option, languages, plugins);",
                    "        }",
                    "      }",
                    "",
                    "      const pluginDefaults = Object.fromEntries(",
                    "        plugins",
                    "          .filter(",
                    "            (plugin) =>",
                    "              plugin.defaultOptions &&",
                    "              plugin.defaultOptions[option.name] !== undefined",
                    "          )",
                    "          .map((plugin) => [plugin.name, plugin.defaultOptions[option.name]])",
                    "      );",
                    "",
                    "      return { ...option, pluginDefaults };",
                    "    });",
                    "",
                    "  return { languages, options };",
                    "",
                    "  function filterSince(object) {",
                    "    return (",
                    "      showUnreleased ||",
                    "      !(\"since\" in object) ||",
                    "      (object.since && semver.gte(version, object.since))",
                    "    );",
                    "  }",
                    "",
                    "  function filterDeprecated(object) {",
                    "    return (",
                    "      showDeprecated ||",
                    "      !(\"deprecated\" in object) ||",
                    "      (object.deprecated && semver.lt(version, object.deprecated))",
                    "    );",
                    "  }",
                    "",
                    "  function mapInternal(object) {",
                    "    if (showInternal) {",
                    "      return object;",
                    "    }",
                    "    const { cliName, cliCategory, cliDescription, ...newObject } = object;",
                    "    return newObject;",
                    "  }",
                    "}",
                    "",
                    "function collectParsersFromLanguages(option, languages, plugins) {",
                    "  const existingValues = new Set(option.choices.map((choice) => choice.value));",
                    "  for (const language of languages) {",
                    "    if (language.parsers) {",
                    "      for (const value of language.parsers) {",
                    "        if (!existingValues.has(value)) {",
                    "          existingValues.add(value);",
                    "          const plugin = plugins.find(",
                    "            (plugin) => plugin.parsers && plugin.parsers[value]",
                    "          );",
                    "          let description = language.name;",
                    "          if (plugin && plugin.name) {",
                    "            description += ` (plugin: ${plugin.name})`;",
                    "          }",
                    "          option.choices.push({ value, description });",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  getSupportInfo,",
                    "};"
                ]
            }
        },
        "utils": {
            "arrayify.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = (object, keyName) =>",
                    "  Object.entries(object).map(([key, value]) => ({",
                    "    [keyName]: key,",
                    "    ...value,",
                    "  }));"
                ]
            },
            "create-language.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = function (linguistData, override) {",
                    "  const { languageId, ...rest } = linguistData;",
                    "  return {",
                    "    linguistLanguageId: languageId,",
                    "    ...rest,",
                    "    ...override(linguistData),",
                    "  };",
                    "};"
                ]
            },
            "get-file-content-or-null.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\");",
                    "const fsAsync = fs.promises;",
                    "",
                    "/**",
                    " * @param {string} filename",
                    " * @returns {Promise<null | string>}",
                    " */",
                    "async function getFileContentOrNull(filename) {",
                    "  try {",
                    "    return await fsAsync.readFile(filename, \"utf8\");",
                    "  } catch (error) {",
                    "    return handleError(filename, error);",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {string} filename",
                    " * @returns {null | string}",
                    " */",
                    "getFileContentOrNull.sync = function (filename) {",
                    "  try {",
                    "    return fs.readFileSync(filename, \"utf8\");",
                    "  } catch (error) {",
                    "    return handleError(filename, error);",
                    "  }",
                    "};",
                    "",
                    "function handleError(filename, error) {",
                    "  if (error && error.code === \"ENOENT\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  throw new Error(`Unable to read ${filename}: ${error.message}`);",
                    "}",
                    "",
                    "module.exports = getFileContentOrNull;"
                ]
            },
            "get-interpreter.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\");",
                    "const readlines = require(\"n-readlines\");",
                    "",
                    "function getInterpreter(filepath) {",
                    "  /* istanbul ignore next */",
                    "  if (typeof filepath !== \"string\") {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  let fd;",
                    "  try {",
                    "    fd = fs.openSync(filepath, \"r\");",
                    "  } catch {",
                    "    // istanbul ignore next",
                    "    return \"\";",
                    "  }",
                    "",
                    "  try {",
                    "    const liner = new readlines(fd);",
                    "    const firstLine = liner.next().toString(\"utf8\");",
                    "",
                    "    // #!/bin/env node, #!/usr/bin/env node",
                    "    const m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);",
                    "    if (m1) {",
                    "      return m1[1];",
                    "    }",
                    "",
                    "    // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node",
                    "    const m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);",
                    "    if (m2) {",
                    "      return m2[1];",
                    "    }",
                    "    return \"\";",
                    "  } catch {",
                    "    // There are some weird cases where paths are missing, causing Jest",
                    "    // failures. It's unclear what these correspond to in the real world.",
                    "    /* istanbul ignore next */",
                    "    return \"\";",
                    "  } finally {",
                    "    try {",
                    "      // There are some weird cases where paths are missing, causing Jest",
                    "      // failures. It's unclear what these correspond to in the real world.",
                    "      fs.closeSync(fd);",
                    "    } catch {",
                    "      // nop",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = getInterpreter;"
                ]
            },
            "get-last.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = (arr) => arr[arr.length - 1];",
                    "",
                    "module.exports = getLast;"
                ]
            },
            "get-string-width.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const stringWidth = require(\"../../vendors/string-width.js\").default;",
                    "",
                    "const notAsciiRegex = /[^\\x20-\\x7F]/;",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @returns {number}",
                    " */",
                    "function getStringWidth(text) {",
                    "  if (!text) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`",
                    "  if (!notAsciiRegex.test(text)) {",
                    "    return text.length;",
                    "  }",
                    "",
                    "  return stringWidth(text);",
                    "}",
                    "",
                    "module.exports = getStringWidth;"
                ]
            },
            "is-non-empty-array.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * @param {any} object",
                    " * @returns {object is Array<any>}",
                    " */",
                    "function isNonEmptyArray(object) {",
                    "  return Array.isArray(object) && object.length > 0;",
                    "}",
                    "",
                    "module.exports = isNonEmptyArray;"
                ]
            },
            "line-column-to-index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// Super inefficient, needs to be cached.",
                    "module.exports = function (lineColumn, text) {",
                    "  let index = 0;",
                    "  for (let i = 0; i < lineColumn.line - 1; ++i) {",
                    "    index = text.indexOf(\"\\n\", index) + 1;",
                    "  }",
                    "  return index + lineColumn.column;",
                    "};"
                ]
            },
            "load-json5.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { parse } = require(\"json5\");",
                    "",
                    "module.exports = function (filePath, content) {",
                    "  try {",
                    "    return parse(content);",
                    "  } catch (error) {",
                    "    error.message = `JSON5 Error in ${filePath}:\\n${error.message}`;",
                    "    throw error;",
                    "  }",
                    "};"
                ]
            },
            "load-toml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const parse = require(\"@iarna/toml/parse-string\");",
                    "",
                    "module.exports = function (filePath, content) {",
                    "  try {",
                    "    return parse(content);",
                    "  } catch (error) {",
                    "    error.message = `TOML Error in ${filePath}:\\n${error.message}`;",
                    "    throw error;",
                    "  }",
                    "};"
                ]
            },
            "partition.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * @template Element",
                    " * @param {Array<Element>} array",
                    " * @param {(value: Element) => boolean} predicate",
                    " * @returns {[Array<Element>, Array<Element>]}",
                    " */",
                    "function partition(array, predicate) {",
                    "  /** @type {[Array<Element>, Array<Element>]} */",
                    "  const result = [[], []];",
                    "",
                    "  for (const value of array) {",
                    "    result[predicate(value) ? 0 : 1].push(value);",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "module.exports = partition;"
                ]
            },
            "try-combinations.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function tryCombinations(...combinations) {",
                    "  let firstError;",
                    "  for (const [index, fn] of combinations.entries()) {",
                    "    try {",
                    "      return { result: fn() };",
                    "    } catch (error) {",
                    "      if (index === 0) {",
                    "        firstError = error;",
                    "      }",
                    "    }",
                    "  }",
                    "  return { error: firstError };",
                    "}",
                    "",
                    "module.exports = tryCombinations;"
                ]
            },
            "uniq-by-key.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * @template {object} Element",
                    " * @param {Array<Element>} array",
                    " * @param {string | number | symbol} key",
                    " * @returns",
                    " */",
                    "function uniqByKey(array, key) {",
                    "  const result = [];",
                    "  const seen = new Set();",
                    "",
                    "  for (const element of array) {",
                    "    const value = element[key];",
                    "    if (!seen.has(value)) {",
                    "      seen.add(value);",
                    "      result.push(element);",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "module.exports = uniqByKey;"
                ]
            },
            "front-matter": {
                "parse.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const frontMatterRegex = new RegExp(",
                        "  \"^(?<startDelimiter>-{3}|\\\\+{3})\" +",
                        "    // trailing spaces after delimiters are allowed",
                        "    \"(?<language>[^\\\\n]*)\" +",
                        "    \"\\\\n(?:|(?<value>.*?)\\\\n)\" +",
                        "    // In some markdown processors such as pandoc,",
                        "    // \"...\" can be used as the end delimiter for YAML front-matter.",
                        "    // Adding `\\.{3}` make the regex matches `+++\\n...`, but we'll exclude it later",
                        "    \"(?<endDelimiter>\\\\k<startDelimiter>|\\\\.{3})\" +",
                        "    \"[^\\\\S\\\\n]*(?:\\\\n|$)\",",
                        "  \"s\"",
                        ");",
                        "",
                        "function parse(text) {",
                        "  const match = text.match(frontMatterRegex);",
                        "  if (!match) {",
                        "    return { content: text };",
                        "  }",
                        "",
                        "  const { startDelimiter, language, value = \"\", endDelimiter } = match.groups;",
                        "",
                        "  let lang = language.trim() || \"yaml\";",
                        "  if (startDelimiter === \"+++\") {",
                        "    lang = \"toml\";",
                        "  }",
                        "",
                        "  // Only allow yaml to parse with a different end delimiter",
                        "  if (lang !== \"yaml\" && startDelimiter !== endDelimiter) {",
                        "    return { content: text };",
                        "  }",
                        "",
                        "  const [raw] = match;",
                        "  const frontMatter = {",
                        "    type: \"front-matter\",",
                        "    lang,",
                        "    value,",
                        "    startDelimiter,",
                        "    endDelimiter,",
                        "    raw: raw.replace(/\\n$/, \"\"),",
                        "  };",
                        "",
                        "  return {",
                        "    frontMatter,",
                        "    content: raw.replace(/[^\\n]/g, \" \") + text.slice(raw.length),",
                        "  };",
                        "}",
                        "",
                        "module.exports = parse;"
                    ]
                },
                "print.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { hardline, markAsRoot },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "function print(node, textToDoc) {",
                        "  if (node.lang === \"yaml\") {",
                        "    const value = node.value.trim();",
                        "    const doc = value",
                        "      ? textToDoc(value, { parser: \"yaml\" }, { stripTrailingHardline: true })",
                        "      : \"\";",
                        "    return markAsRoot([",
                        "      node.startDelimiter,",
                        "      hardline,",
                        "      doc,",
                        "      doc ? hardline : \"\",",
                        "      node.endDelimiter,",
                        "    ]);",
                        "  }",
                        "}",
                        "",
                        "module.exports = print;"
                    ]
                }
            },
            "text": {
                "get-next-non-space-non-comment-character-index-with-start-index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const skipInlineComment = require(\"./skip-inline-comment.js\");",
                        "const skipNewline = require(\"./skip-newline.js\");",
                        "const skipTrailingComment = require(\"./skip-trailing-comment.js\");",
                        "const { skipSpaces } = require(\"./skip.js\");",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {number} idx",
                        " * @returns {number | false}",
                        " */",
                        "function getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {",
                        "  /** @type {number | false} */",
                        "  let oldIdx = null;",
                        "  /** @type {number | false} */",
                        "  let nextIdx = idx;",
                        "  while (nextIdx !== oldIdx) {",
                        "    oldIdx = nextIdx;",
                        "    nextIdx = skipSpaces(text, nextIdx);",
                        "    nextIdx = skipInlineComment(text, nextIdx);",
                        "    nextIdx = skipTrailingComment(text, nextIdx);",
                        "    nextIdx = skipNewline(text, nextIdx);",
                        "  }",
                        "  return nextIdx;",
                        "}",
                        "",
                        "module.exports = getNextNonSpaceNonCommentCharacterIndexWithStartIndex;"
                    ]
                },
                "skip-inline-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {number | false} index",
                        " * @returns {number | false}",
                        " */",
                        "function skipInlineComment(text, index) {",
                        "  /* istanbul ignore next */",
                        "  if (index === false) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {",
                        "    for (let i = index + 2; i < text.length; ++i) {",
                        "      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {",
                        "        return i + 2;",
                        "      }",
                        "    }",
                        "  }",
                        "  return index;",
                        "}",
                        "",
                        "module.exports = skipInlineComment;"
                    ]
                },
                "skip-newline.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/** @typedef {import(\"./skip\").SkipOptions} SkipOptions */",
                        "",
                        "// This one doesn't use the above helper function because it wants to",
                        "// test \\r\\n in order and `skip` doesn't support ordering and we only",
                        "// want to skip one newline. It's simple to implement.",
                        "/**",
                        " * @param {string} text",
                        " * @param {number | false} index",
                        " * @param {SkipOptions=} opts",
                        " * @returns {number | false}",
                        " */",
                        "function skipNewline(text, index, opts) {",
                        "  const backwards = opts && opts.backwards;",
                        "  if (index === false) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const atIndex = text.charAt(index);",
                        "  if (backwards) {",
                        "    // We already replace `\\r\\n` with `\\n` before parsing",
                        "    /* istanbul ignore next */",
                        "    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {",
                        "      return index - 2;",
                        "    }",
                        "    if (",
                        "      atIndex === \"\\n\" ||",
                        "      atIndex === \"\\r\" ||",
                        "      atIndex === \"\\u2028\" ||",
                        "      atIndex === \"\\u2029\"",
                        "    ) {",
                        "      return index - 1;",
                        "    }",
                        "  } else {",
                        "    // We already replace `\\r\\n` with `\\n` before parsing",
                        "    /* istanbul ignore next */",
                        "    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {",
                        "      return index + 2;",
                        "    }",
                        "    if (",
                        "      atIndex === \"\\n\" ||",
                        "      atIndex === \"\\r\" ||",
                        "      atIndex === \"\\u2028\" ||",
                        "      atIndex === \"\\u2029\"",
                        "    ) {",
                        "      return index + 1;",
                        "    }",
                        "  }",
                        "",
                        "  return index;",
                        "}",
                        "",
                        "module.exports = skipNewline;"
                    ]
                },
                "skip-trailing-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { skipEverythingButNewLine } = require(\"./skip.js\");",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {number | false} index",
                        " * @returns {number | false}",
                        " */",
                        "function skipTrailingComment(text, index) {",
                        "  /* istanbul ignore next */",
                        "  if (index === false) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {",
                        "    return skipEverythingButNewLine(text, index);",
                        "  }",
                        "  return index;",
                        "}",
                        "",
                        "module.exports = skipTrailingComment;"
                    ]
                },
                "skip.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * @typedef {{backwards?: boolean}} SkipOptions",
                        " */",
                        "",
                        "/**",
                        " * @param {string | RegExp} chars",
                        " * @returns {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                        " */",
                        "function skip(chars) {",
                        "  return (text, index, opts) => {",
                        "    const backwards = opts && opts.backwards;",
                        "",
                        "    // Allow `skip` functions to be threaded together without having",
                        "    // to check for failures (did someone say monads?).",
                        "    /* istanbul ignore next */",
                        "    if (index === false) {",
                        "      return false;",
                        "    }",
                        "",
                        "    const { length } = text;",
                        "    let cursor = index;",
                        "    while (cursor >= 0 && cursor < length) {",
                        "      const c = text.charAt(cursor);",
                        "      if (chars instanceof RegExp) {",
                        "        if (!chars.test(c)) {",
                        "          return cursor;",
                        "        }",
                        "      } else if (!chars.includes(c)) {",
                        "        return cursor;",
                        "      }",
                        "",
                        "      backwards ? cursor-- : cursor++;",
                        "    }",
                        "",
                        "    if (cursor === -1 || cursor === length) {",
                        "      // If we reached the beginning or end of the file, return the",
                        "      // out-of-bounds cursor. It's up to the caller to handle this",
                        "      // correctly. We don't want to indicate `false` though if it",
                        "      // actually skipped valid characters.",
                        "      return cursor;",
                        "    }",
                        "    return false;",
                        "  };",
                        "}",
                        "",
                        "/**",
                        " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                        " */",
                        "const skipWhitespace = skip(/\\s/);",
                        "/**",
                        " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                        " */",
                        "const skipSpaces = skip(\" \\t\");",
                        "/**",
                        " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                        " */",
                        "const skipToLineEnd = skip(\",; \\t\");",
                        "/**",
                        " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                        " */",
                        "const skipEverythingButNewLine = skip(/[^\\n\\r]/);",
                        "",
                        "module.exports = {",
                        "  skipWhitespace,",
                        "  skipSpaces,",
                        "  skipToLineEnd,",
                        "  skipEverythingButNewLine,",
                        "};"
                    ]
                }
            }
        }
    },
    "types": {
        "angular-html-parser": {
            "index.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "import \"angular-html-parser/lib/compiler/src/ml_parser/ast\";",
                    "import { HtmlTagDefinition } from \"angular-html-parser/lib/compiler/src/ml_parser/html_tags\";",
                    "",
                    "declare module \"angular-html-parser/lib/compiler/src/ml_parser/ast\" {",
                    "  interface Attribute {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "    // see restoreName in parser-html.js",
                    "    namespace?: string | null;",
                    "    hasExplicitNamespace?: boolean;",
                    "  }",
                    "",
                    "  interface CDATA {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface Comment {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface DocType {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface Element {",
                    "    tagDefinition: HtmlTagDefinition;",
                    "    // see restoreName in parser-html.js",
                    "    namespace?: string | null;",
                    "    hasExplicitNamespace?: boolean;",
                    "  }",
                    "",
                    "  interface Text {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "}"
                ]
            }
        },
        "espree": {
            "index.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "declare module \"espree\" {",
                    "  // https://github.com/eslint/espree#options",
                    "  export interface Options {",
                    "    range?: boolean;",
                    "    loc?: boolean;",
                    "    comment?: boolean;",
                    "    tokens?: boolean;",
                    "    ecmaVersion?:",
                    "      | 3",
                    "      | 5",
                    "      | 6",
                    "      | 7",
                    "      | 8",
                    "      | 9",
                    "      | 10",
                    "      | 11",
                    "      | 12",
                    "      | 2015",
                    "      | 2016",
                    "      | 2017",
                    "      | 2018",
                    "      | 2019",
                    "      | 2020",
                    "      | 2021",
                    "      | 2022",
                    "      | \"latest\";",
                    "    sourceType?: \"script\" | \"module\";",
                    "    ecmaFeatures?: {",
                    "      jsx?: boolean;",
                    "      globalReturn?: boolean;",
                    "      impliedStrict?: boolean;",
                    "    };",
                    "  }",
                    "  // https://github.com/eslint/espree#parse",
                    "  export function parse(code: string, options?: Options): any;",
                    "  // https://github.com/eslint/espree#tokenize",
                    "  export function tokenize(code: string, options?: Options): any;",
                    "}"
                ]
            }
        }
    },
    "vendors": {
        "README.md": {},
        "chalk.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// This file is generated automatically.",
                "export {default} from \"chalk\";",
                "export * from \"chalk\";"
            ]
        },
        "chalk.js": {
            "classes": [],
            "functions": [],
            "text": [
                "// @ts-nocheck",
                "// This file is generated automatically",
                "var __create = Object.create;",
                "var __defProp = Object.defineProperty;",
                "var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
                "var __getOwnPropNames = Object.getOwnPropertyNames;",
                "var __getProtoOf = Object.getPrototypeOf;",
                "var __hasOwnProp = Object.prototype.hasOwnProperty;",
                "var __export = (target, all) => {",
                "  for (var name in all)",
                "    __defProp(target, name, { get: all[name], enumerable: true });",
                "};",
                "var __copyProps = (to, from, except, desc) => {",
                "  if (from && typeof from === \"object\" || typeof from === \"function\") {",
                "    for (let key of __getOwnPropNames(from))",
                "      if (!__hasOwnProp.call(to, key) && key !== except)",
                "        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
                "  }",
                "  return to;",
                "};",
                "var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(",
                "  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,",
                "  mod",
                "));",
                "var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);",
                "",
                "// node_modules/chalk/source/index.js",
                "var source_exports = {};",
                "__export(source_exports, {",
                "  Chalk: () => Chalk,",
                "  chalkStderr: () => chalkStderr,",
                "  default: () => source_default,",
                "  supportsColor: () => stdoutColor,",
                "  supportsColorStderr: () => stderrColor",
                "});",
                "module.exports = __toCommonJS(source_exports);",
                "",
                "// node_modules/chalk/source/vendor/ansi-styles/index.js",
                "var ANSI_BACKGROUND_OFFSET = 10;",
                "var wrapAnsi16 = (offset = 0) => (code) => `\\x1B[${code + offset}m`;",
                "var wrapAnsi256 = (offset = 0) => (code) => `\\x1B[${38 + offset};5;${code}m`;",
                "var wrapAnsi16m = (offset = 0) => (red, green, blue) => `\\x1B[${38 + offset};2;${red};${green};${blue}m`;",
                "function assembleStyles() {",
                "  const codes = /* @__PURE__ */ new Map();",
                "  const styles2 = {",
                "    modifier: {",
                "      reset: [0, 0],",
                "      bold: [1, 22],",
                "      dim: [2, 22],",
                "      italic: [3, 23],",
                "      underline: [4, 24],",
                "      overline: [53, 55],",
                "      inverse: [7, 27],",
                "      hidden: [8, 28],",
                "      strikethrough: [9, 29]",
                "    },",
                "    color: {",
                "      black: [30, 39],",
                "      red: [31, 39],",
                "      green: [32, 39],",
                "      yellow: [33, 39],",
                "      blue: [34, 39],",
                "      magenta: [35, 39],",
                "      cyan: [36, 39],",
                "      white: [37, 39],",
                "      blackBright: [90, 39],",
                "      redBright: [91, 39],",
                "      greenBright: [92, 39],",
                "      yellowBright: [93, 39],",
                "      blueBright: [94, 39],",
                "      magentaBright: [95, 39],",
                "      cyanBright: [96, 39],",
                "      whiteBright: [97, 39]",
                "    },",
                "    bgColor: {",
                "      bgBlack: [40, 49],",
                "      bgRed: [41, 49],",
                "      bgGreen: [42, 49],",
                "      bgYellow: [43, 49],",
                "      bgBlue: [44, 49],",
                "      bgMagenta: [45, 49],",
                "      bgCyan: [46, 49],",
                "      bgWhite: [47, 49],",
                "      bgBlackBright: [100, 49],",
                "      bgRedBright: [101, 49],",
                "      bgGreenBright: [102, 49],",
                "      bgYellowBright: [103, 49],",
                "      bgBlueBright: [104, 49],",
                "      bgMagentaBright: [105, 49],",
                "      bgCyanBright: [106, 49],",
                "      bgWhiteBright: [107, 49]",
                "    }",
                "  };",
                "  styles2.color.gray = styles2.color.blackBright;",
                "  styles2.bgColor.bgGray = styles2.bgColor.bgBlackBright;",
                "  styles2.color.grey = styles2.color.blackBright;",
                "  styles2.bgColor.bgGrey = styles2.bgColor.bgBlackBright;",
                "  for (const [groupName, group] of Object.entries(styles2)) {",
                "    for (const [styleName, style] of Object.entries(group)) {",
                "      styles2[styleName] = {",
                "        open: `\\x1B[${style[0]}m`,",
                "        close: `\\x1B[${style[1]}m`",
                "      };",
                "      group[styleName] = styles2[styleName];",
                "      codes.set(style[0], style[1]);",
                "    }",
                "    Object.defineProperty(styles2, groupName, {",
                "      value: group,",
                "      enumerable: false",
                "    });",
                "  }",
                "  Object.defineProperty(styles2, \"codes\", {",
                "    value: codes,",
                "    enumerable: false",
                "  });",
                "  styles2.color.close = \"\\x1B[39m\";",
                "  styles2.bgColor.close = \"\\x1B[49m\";",
                "  styles2.color.ansi = wrapAnsi16();",
                "  styles2.color.ansi256 = wrapAnsi256();",
                "  styles2.color.ansi16m = wrapAnsi16m();",
                "  styles2.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);",
                "  styles2.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);",
                "  styles2.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);",
                "  Object.defineProperties(styles2, {",
                "    rgbToAnsi256: {",
                "      value: (red, green, blue) => {",
                "        if (red === green && green === blue) {",
                "          if (red < 8) {",
                "            return 16;",
                "          }",
                "          if (red > 248) {",
                "            return 231;",
                "          }",
                "          return Math.round((red - 8) / 247 * 24) + 232;",
                "        }",
                "        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);",
                "      },",
                "      enumerable: false",
                "    },",
                "    hexToRgb: {",
                "      value: (hex) => {",
                "        const matches = /(?<colorString>[a-f\\d]{6}|[a-f\\d]{3})/i.exec(hex.toString(16));",
                "        if (!matches) {",
                "          return [0, 0, 0];",
                "        }",
                "        let { colorString } = matches.groups;",
                "        if (colorString.length === 3) {",
                "          colorString = [...colorString].map((character) => character + character).join(\"\");",
                "        }",
                "        const integer = Number.parseInt(colorString, 16);",
                "        return [",
                "          integer >> 16 & 255,",
                "          integer >> 8 & 255,",
                "          integer & 255",
                "        ];",
                "      },",
                "      enumerable: false",
                "    },",
                "    hexToAnsi256: {",
                "      value: (hex) => styles2.rgbToAnsi256(...styles2.hexToRgb(hex)),",
                "      enumerable: false",
                "    },",
                "    ansi256ToAnsi: {",
                "      value: (code) => {",
                "        if (code < 8) {",
                "          return 30 + code;",
                "        }",
                "        if (code < 16) {",
                "          return 90 + (code - 8);",
                "        }",
                "        let red;",
                "        let green;",
                "        let blue;",
                "        if (code >= 232) {",
                "          red = ((code - 232) * 10 + 8) / 255;",
                "          green = red;",
                "          blue = red;",
                "        } else {",
                "          code -= 16;",
                "          const remainder = code % 36;",
                "          red = Math.floor(code / 36) / 5;",
                "          green = Math.floor(remainder / 6) / 5;",
                "          blue = remainder % 6 / 5;",
                "        }",
                "        const value = Math.max(red, green, blue) * 2;",
                "        if (value === 0) {",
                "          return 30;",
                "        }",
                "        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));",
                "        if (value === 2) {",
                "          result += 60;",
                "        }",
                "        return result;",
                "      },",
                "      enumerable: false",
                "    },",
                "    rgbToAnsi: {",
                "      value: (red, green, blue) => styles2.ansi256ToAnsi(styles2.rgbToAnsi256(red, green, blue)),",
                "      enumerable: false",
                "    },",
                "    hexToAnsi: {",
                "      value: (hex) => styles2.ansi256ToAnsi(styles2.hexToAnsi256(hex)),",
                "      enumerable: false",
                "    }",
                "  });",
                "  return styles2;",
                "}",
                "var ansiStyles = assembleStyles();",
                "var ansi_styles_default = ansiStyles;",
                "",
                "// node_modules/chalk/source/vendor/supports-color/index.js",
                "var import_node_process = __toESM(require(\"process\"), 1);",
                "var import_node_os = __toESM(require(\"os\"), 1);",
                "var import_node_tty = __toESM(require(\"tty\"), 1);",
                "function hasFlag(flag, argv = import_node_process.default.argv) {",
                "  const prefix = flag.startsWith(\"-\") ? \"\" : flag.length === 1 ? \"-\" : \"--\";",
                "  const position = argv.indexOf(prefix + flag);",
                "  const terminatorPosition = argv.indexOf(\"--\");",
                "  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);",
                "}",
                "var { env } = import_node_process.default;",
                "var flagForceColor;",
                "if (hasFlag(\"no-color\") || hasFlag(\"no-colors\") || hasFlag(\"color=false\") || hasFlag(\"color=never\")) {",
                "  flagForceColor = 0;",
                "} else if (hasFlag(\"color\") || hasFlag(\"colors\") || hasFlag(\"color=true\") || hasFlag(\"color=always\")) {",
                "  flagForceColor = 1;",
                "}",
                "function envForceColor() {",
                "  if (\"FORCE_COLOR\" in env) {",
                "    if (env.FORCE_COLOR === \"true\") {",
                "      return 1;",
                "    }",
                "    if (env.FORCE_COLOR === \"false\") {",
                "      return 0;",
                "    }",
                "    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);",
                "  }",
                "}",
                "function translateLevel(level) {",
                "  if (level === 0) {",
                "    return false;",
                "  }",
                "  return {",
                "    level,",
                "    hasBasic: true,",
                "    has256: level >= 2,",
                "    has16m: level >= 3",
                "  };",
                "}",
                "function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {",
                "  const noFlagForceColor = envForceColor();",
                "  if (noFlagForceColor !== void 0) {",
                "    flagForceColor = noFlagForceColor;",
                "  }",
                "  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;",
                "  if (forceColor === 0) {",
                "    return 0;",
                "  }",
                "  if (sniffFlags) {",
                "    if (hasFlag(\"color=16m\") || hasFlag(\"color=full\") || hasFlag(\"color=truecolor\")) {",
                "      return 3;",
                "    }",
                "    if (hasFlag(\"color=256\")) {",
                "      return 2;",
                "    }",
                "  }",
                "  if (haveStream && !streamIsTTY && forceColor === void 0) {",
                "    return 0;",
                "  }",
                "  const min = forceColor || 0;",
                "  if (env.TERM === \"dumb\") {",
                "    return min;",
                "  }",
                "  if (import_node_process.default.platform === \"win32\") {",
                "    const osRelease = import_node_os.default.release().split(\".\");",
                "    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {",
                "      return Number(osRelease[2]) >= 14931 ? 3 : 2;",
                "    }",
                "    return 1;",
                "  }",
                "  if (\"CI\" in env) {",
                "    if ([\"TRAVIS\", \"CIRCLECI\", \"APPVEYOR\", \"GITLAB_CI\", \"GITHUB_ACTIONS\", \"BUILDKITE\", \"DRONE\"].some((sign) => sign in env) || env.CI_NAME === \"codeship\") {",
                "      return 1;",
                "    }",
                "    return min;",
                "  }",
                "  if (\"TEAMCITY_VERSION\" in env) {",
                "    return /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;",
                "  }",
                "  if (\"TF_BUILD\" in env && \"AGENT_NAME\" in env) {",
                "    return 1;",
                "  }",
                "  if (env.COLORTERM === \"truecolor\") {",
                "    return 3;",
                "  }",
                "  if (\"TERM_PROGRAM\" in env) {",
                "    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || \"\").split(\".\")[0], 10);",
                "    switch (env.TERM_PROGRAM) {",
                "      case \"iTerm.app\":",
                "        return version >= 3 ? 3 : 2;",
                "      case \"Apple_Terminal\":",
                "        return 2;",
                "    }",
                "  }",
                "  if (/-256(color)?$/i.test(env.TERM)) {",
                "    return 2;",
                "  }",
                "  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {",
                "    return 1;",
                "  }",
                "  if (\"COLORTERM\" in env) {",
                "    return 1;",
                "  }",
                "  return min;",
                "}",
                "function createSupportsColor(stream, options = {}) {",
                "  const level = _supportsColor(stream, {",
                "    streamIsTTY: stream && stream.isTTY,",
                "    ...options",
                "  });",
                "  return translateLevel(level);",
                "}",
                "var supportsColor = {",
                "  stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),",
                "  stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })",
                "};",
                "var supports_color_default = supportsColor;",
                "",
                "// node_modules/chalk/source/utilities.js",
                "function stringReplaceAll(string, substring, replacer) {",
                "  let index = string.indexOf(substring);",
                "  if (index === -1) {",
                "    return string;",
                "  }",
                "  const substringLength = substring.length;",
                "  let endIndex = 0;",
                "  let returnValue = \"\";",
                "  do {",
                "    returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;",
                "    endIndex = index + substringLength;",
                "    index = string.indexOf(substring, endIndex);",
                "  } while (index !== -1);",
                "  returnValue += string.slice(endIndex);",
                "  return returnValue;",
                "}",
                "function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {",
                "  let endIndex = 0;",
                "  let returnValue = \"\";",
                "  do {",
                "    const gotCR = string[index - 1] === \"\\r\";",
                "    returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? \"\\r\\n\" : \"\\n\") + postfix;",
                "    endIndex = index + 1;",
                "    index = string.indexOf(\"\\n\", endIndex);",
                "  } while (index !== -1);",
                "  returnValue += string.slice(endIndex);",
                "  return returnValue;",
                "}",
                "",
                "// node_modules/chalk/source/index.js",
                "var { stdout: stdoutColor, stderr: stderrColor } = supports_color_default;",
                "var GENERATOR = Symbol(\"GENERATOR\");",
                "var STYLER = Symbol(\"STYLER\");",
                "var IS_EMPTY = Symbol(\"IS_EMPTY\");",
                "var levelMapping = [",
                "  \"ansi\",",
                "  \"ansi\",",
                "  \"ansi256\",",
                "  \"ansi16m\"",
                "];",
                "var styles = /* @__PURE__ */ Object.create(null);",
                "var applyOptions = (object, options = {}) => {",
                "  if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {",
                "    throw new Error(\"The `level` option should be an integer from 0 to 3\");",
                "  }",
                "  const colorLevel = stdoutColor ? stdoutColor.level : 0;",
                "  object.level = options.level === void 0 ? colorLevel : options.level;",
                "};",
                "var Chalk = class {",
                "  constructor(options) {",
                "    return chalkFactory(options);",
                "  }",
                "};",
                "var chalkFactory = (options) => {",
                "  const chalk2 = (...strings) => strings.join(\" \");",
                "  applyOptions(chalk2, options);",
                "  Object.setPrototypeOf(chalk2, createChalk.prototype);",
                "  return chalk2;",
                "};",
                "function createChalk(options) {",
                "  return chalkFactory(options);",
                "}",
                "Object.setPrototypeOf(createChalk.prototype, Function.prototype);",
                "for (const [styleName, style] of Object.entries(ansi_styles_default)) {",
                "  styles[styleName] = {",
                "    get() {",
                "      const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);",
                "      Object.defineProperty(this, styleName, { value: builder });",
                "      return builder;",
                "    }",
                "  };",
                "}",
                "styles.visible = {",
                "  get() {",
                "    const builder = createBuilder(this, this[STYLER], true);",
                "    Object.defineProperty(this, \"visible\", { value: builder });",
                "    return builder;",
                "  }",
                "};",
                "var getModelAnsi = (model, level, type, ...arguments_) => {",
                "  if (model === \"rgb\") {",
                "    if (level === \"ansi16m\") {",
                "      return ansi_styles_default[type].ansi16m(...arguments_);",
                "    }",
                "    if (level === \"ansi256\") {",
                "      return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));",
                "    }",
                "    return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));",
                "  }",
                "  if (model === \"hex\") {",
                "    return getModelAnsi(\"rgb\", level, type, ...ansi_styles_default.hexToRgb(...arguments_));",
                "  }",
                "  return ansi_styles_default[type][model](...arguments_);",
                "};",
                "var usedModels = [\"rgb\", \"hex\", \"ansi256\"];",
                "for (const model of usedModels) {",
                "  styles[model] = {",
                "    get() {",
                "      const { level } = this;",
                "      return function(...arguments_) {",
                "        const styler = createStyler(getModelAnsi(model, levelMapping[level], \"color\", ...arguments_), ansi_styles_default.color.close, this[STYLER]);",
                "        return createBuilder(this, styler, this[IS_EMPTY]);",
                "      };",
                "    }",
                "  };",
                "  const bgModel = \"bg\" + model[0].toUpperCase() + model.slice(1);",
                "  styles[bgModel] = {",
                "    get() {",
                "      const { level } = this;",
                "      return function(...arguments_) {",
                "        const styler = createStyler(getModelAnsi(model, levelMapping[level], \"bgColor\", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);",
                "        return createBuilder(this, styler, this[IS_EMPTY]);",
                "      };",
                "    }",
                "  };",
                "}",
                "var proto = Object.defineProperties(() => {",
                "}, {",
                "  ...styles,",
                "  level: {",
                "    enumerable: true,",
                "    get() {",
                "      return this[GENERATOR].level;",
                "    },",
                "    set(level) {",
                "      this[GENERATOR].level = level;",
                "    }",
                "  }",
                "});",
                "var createStyler = (open, close, parent) => {",
                "  let openAll;",
                "  let closeAll;",
                "  if (parent === void 0) {",
                "    openAll = open;",
                "    closeAll = close;",
                "  } else {",
                "    openAll = parent.openAll + open;",
                "    closeAll = close + parent.closeAll;",
                "  }",
                "  return {",
                "    open,",
                "    close,",
                "    openAll,",
                "    closeAll,",
                "    parent",
                "  };",
                "};",
                "var createBuilder = (self, _styler, _isEmpty) => {",
                "  const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? \"\" + arguments_[0] : arguments_.join(\" \"));",
                "  Object.setPrototypeOf(builder, proto);",
                "  builder[GENERATOR] = self;",
                "  builder[STYLER] = _styler;",
                "  builder[IS_EMPTY] = _isEmpty;",
                "  return builder;",
                "};",
                "var applyStyle = (self, string) => {",
                "  if (self.level <= 0 || !string) {",
                "    return self[IS_EMPTY] ? \"\" : string;",
                "  }",
                "  let styler = self[STYLER];",
                "  if (styler === void 0) {",
                "    return string;",
                "  }",
                "  const { openAll, closeAll } = styler;",
                "  if (string.includes(\"\\x1B\")) {",
                "    while (styler !== void 0) {",
                "      string = stringReplaceAll(string, styler.close, styler.open);",
                "      styler = styler.parent;",
                "    }",
                "  }",
                "  const lfIndex = string.indexOf(\"\\n\");",
                "  if (lfIndex !== -1) {",
                "    string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);",
                "  }",
                "  return openAll + string + closeAll;",
                "};",
                "Object.defineProperties(createChalk.prototype, styles);",
                "var chalk = createChalk();",
                "var chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });",
                "var source_default = chalk;",
                "// Annotate the CommonJS export names for ESM import in node:",
                "0 && (module.exports = {",
                "  Chalk,",
                "  chalkStderr,",
                "  supportsColor,",
                "  supportsColorStderr",
                "});"
            ]
        },
        "css-units-list.json": {},
        "escape-string-regexp.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// This file is generated automatically.",
                "export {default} from \"escape-string-regexp\";",
                "export * from \"escape-string-regexp\";"
            ]
        },
        "escape-string-regexp.js": {
            "classes": [],
            "functions": [],
            "text": [
                "// @ts-nocheck",
                "// This file is generated automatically",
                "var __defProp = Object.defineProperty;",
                "var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
                "var __getOwnPropNames = Object.getOwnPropertyNames;",
                "var __hasOwnProp = Object.prototype.hasOwnProperty;",
                "var __export = (target, all) => {",
                "  for (var name in all)",
                "    __defProp(target, name, { get: all[name], enumerable: true });",
                "};",
                "var __copyProps = (to, from, except, desc) => {",
                "  if (from && typeof from === \"object\" || typeof from === \"function\") {",
                "    for (let key of __getOwnPropNames(from))",
                "      if (!__hasOwnProp.call(to, key) && key !== except)",
                "        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
                "  }",
                "  return to;",
                "};",
                "var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);",
                "",
                "// node_modules/escape-string-regexp/index.js",
                "var escape_string_regexp_exports = {};",
                "__export(escape_string_regexp_exports, {",
                "  default: () => escapeStringRegexp",
                "});",
                "module.exports = __toCommonJS(escape_string_regexp_exports);",
                "function escapeStringRegexp(string) {",
                "  if (typeof string !== \"string\") {",
                "    throw new TypeError(\"Expected a string\");",
                "  }",
                "  return string.replace(/[|\\\\{}()[\\]^$+*?.]/g, \"\\\\$&\").replace(/-/g, \"\\\\x2d\");",
                "}",
                "// Annotate the CommonJS export names for ESM import in node:",
                "0 && (module.exports = {});"
            ]
        },
        "execa.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// This file is generated automatically.",
                "export * from \"execa\";"
            ]
        },
        "execa.js": {
            "classes": [],
            "functions": [],
            "text": [
                "// @ts-nocheck",
                "// This file is generated automatically",
                "var __create = Object.create;",
                "var __defProp = Object.defineProperty;",
                "var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
                "var __getOwnPropNames = Object.getOwnPropertyNames;",
                "var __getProtoOf = Object.getPrototypeOf;",
                "var __hasOwnProp = Object.prototype.hasOwnProperty;",
                "var __commonJS = (cb, mod) => function __require() {",
                "  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;",
                "};",
                "var __export = (target, all) => {",
                "  for (var name in all)",
                "    __defProp(target, name, { get: all[name], enumerable: true });",
                "};",
                "var __copyProps = (to, from, except, desc) => {",
                "  if (from && typeof from === \"object\" || typeof from === \"function\") {",
                "    for (let key of __getOwnPropNames(from))",
                "      if (!__hasOwnProp.call(to, key) && key !== except)",
                "        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
                "  }",
                "  return to;",
                "};",
                "var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(",
                "  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,",
                "  mod",
                "));",
                "var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);",
                "",
                "// node_modules/isexe/windows.js",
                "var require_windows = __commonJS({",
                "  \"node_modules/isexe/windows.js\"(exports, module2) {",
                "    module2.exports = isexe;",
                "    isexe.sync = sync;",
                "    var fs = require(\"fs\");",
                "    function checkPathExt(path3, options) {",
                "      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;",
                "      if (!pathext) {",
                "        return true;",
                "      }",
                "      pathext = pathext.split(\";\");",
                "      if (pathext.indexOf(\"\") !== -1) {",
                "        return true;",
                "      }",
                "      for (var i = 0; i < pathext.length; i++) {",
                "        var p = pathext[i].toLowerCase();",
                "        if (p && path3.substr(-p.length).toLowerCase() === p) {",
                "          return true;",
                "        }",
                "      }",
                "      return false;",
                "    }",
                "    function checkStat(stat, path3, options) {",
                "      if (!stat.isSymbolicLink() && !stat.isFile()) {",
                "        return false;",
                "      }",
                "      return checkPathExt(path3, options);",
                "    }",
                "    function isexe(path3, options, cb) {",
                "      fs.stat(path3, function(er, stat) {",
                "        cb(er, er ? false : checkStat(stat, path3, options));",
                "      });",
                "    }",
                "    function sync(path3, options) {",
                "      return checkStat(fs.statSync(path3), path3, options);",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/isexe/mode.js",
                "var require_mode = __commonJS({",
                "  \"node_modules/isexe/mode.js\"(exports, module2) {",
                "    module2.exports = isexe;",
                "    isexe.sync = sync;",
                "    var fs = require(\"fs\");",
                "    function isexe(path3, options, cb) {",
                "      fs.stat(path3, function(er, stat) {",
                "        cb(er, er ? false : checkStat(stat, options));",
                "      });",
                "    }",
                "    function sync(path3, options) {",
                "      return checkStat(fs.statSync(path3), options);",
                "    }",
                "    function checkStat(stat, options) {",
                "      return stat.isFile() && checkMode(stat, options);",
                "    }",
                "    function checkMode(stat, options) {",
                "      var mod = stat.mode;",
                "      var uid = stat.uid;",
                "      var gid = stat.gid;",
                "      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();",
                "      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();",
                "      var u = parseInt(\"100\", 8);",
                "      var g = parseInt(\"010\", 8);",
                "      var o = parseInt(\"001\", 8);",
                "      var ug = u | g;",
                "      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;",
                "      return ret;",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/isexe/index.js",
                "var require_isexe = __commonJS({",
                "  \"node_modules/isexe/index.js\"(exports, module2) {",
                "    var fs = require(\"fs\");",
                "    var core;",
                "    if (process.platform === \"win32\" || global.TESTING_WINDOWS) {",
                "      core = require_windows();",
                "    } else {",
                "      core = require_mode();",
                "    }",
                "    module2.exports = isexe;",
                "    isexe.sync = sync;",
                "    function isexe(path3, options, cb) {",
                "      if (typeof options === \"function\") {",
                "        cb = options;",
                "        options = {};",
                "      }",
                "      if (!cb) {",
                "        if (typeof Promise !== \"function\") {",
                "          throw new TypeError(\"callback not provided\");",
                "        }",
                "        return new Promise(function(resolve, reject) {",
                "          isexe(path3, options || {}, function(er, is) {",
                "            if (er) {",
                "              reject(er);",
                "            } else {",
                "              resolve(is);",
                "            }",
                "          });",
                "        });",
                "      }",
                "      core(path3, options || {}, function(er, is) {",
                "        if (er) {",
                "          if (er.code === \"EACCES\" || options && options.ignoreErrors) {",
                "            er = null;",
                "            is = false;",
                "          }",
                "        }",
                "        cb(er, is);",
                "      });",
                "    }",
                "    function sync(path3, options) {",
                "      try {",
                "        return core.sync(path3, options || {});",
                "      } catch (er) {",
                "        if (options && options.ignoreErrors || er.code === \"EACCES\") {",
                "          return false;",
                "        } else {",
                "          throw er;",
                "        }",
                "      }",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/which/which.js",
                "var require_which = __commonJS({",
                "  \"node_modules/which/which.js\"(exports, module2) {",
                "    var isWindows = process.platform === \"win32\" || process.env.OSTYPE === \"cygwin\" || process.env.OSTYPE === \"msys\";",
                "    var path3 = require(\"path\");",
                "    var COLON = isWindows ? \";\" : \":\";",
                "    var isexe = require_isexe();",
                "    var getNotFoundError = (cmd) => Object.assign(new Error(`not found: ${cmd}`), { code: \"ENOENT\" });",
                "    var getPathInfo = (cmd, opt) => {",
                "      const colon = opt.colon || COLON;",
                "      const pathEnv = cmd.match(/\\//) || isWindows && cmd.match(/\\\\/) ? [\"\"] : [",
                "        ...isWindows ? [process.cwd()] : [],",
                "        ...(opt.path || process.env.PATH || \"\").split(colon)",
                "      ];",
                "      const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || \".EXE;.CMD;.BAT;.COM\" : \"\";",
                "      const pathExt = isWindows ? pathExtExe.split(colon) : [\"\"];",
                "      if (isWindows) {",
                "        if (cmd.indexOf(\".\") !== -1 && pathExt[0] !== \"\")",
                "          pathExt.unshift(\"\");",
                "      }",
                "      return {",
                "        pathEnv,",
                "        pathExt,",
                "        pathExtExe",
                "      };",
                "    };",
                "    var which = (cmd, opt, cb) => {",
                "      if (typeof opt === \"function\") {",
                "        cb = opt;",
                "        opt = {};",
                "      }",
                "      if (!opt)",
                "        opt = {};",
                "      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);",
                "      const found = [];",
                "      const step = (i) => new Promise((resolve, reject) => {",
                "        if (i === pathEnv.length)",
                "          return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));",
                "        const ppRaw = pathEnv[i];",
                "        const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;",
                "        const pCmd = path3.join(pathPart, cmd);",
                "        const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;",
                "        resolve(subStep(p, i, 0));",
                "      });",
                "      const subStep = (p, i, ii) => new Promise((resolve, reject) => {",
                "        if (ii === pathExt.length)",
                "          return resolve(step(i + 1));",
                "        const ext = pathExt[ii];",
                "        isexe(p + ext, { pathExt: pathExtExe }, (er, is) => {",
                "          if (!er && is) {",
                "            if (opt.all)",
                "              found.push(p + ext);",
                "            else",
                "              return resolve(p + ext);",
                "          }",
                "          return resolve(subStep(p, i, ii + 1));",
                "        });",
                "      });",
                "      return cb ? step(0).then((res) => cb(null, res), cb) : step(0);",
                "    };",
                "    var whichSync = (cmd, opt) => {",
                "      opt = opt || {};",
                "      const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);",
                "      const found = [];",
                "      for (let i = 0; i < pathEnv.length; i++) {",
                "        const ppRaw = pathEnv[i];",
                "        const pathPart = /^\".*\"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;",
                "        const pCmd = path3.join(pathPart, cmd);",
                "        const p = !pathPart && /^\\.[\\\\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;",
                "        for (let j = 0; j < pathExt.length; j++) {",
                "          const cur = p + pathExt[j];",
                "          try {",
                "            const is = isexe.sync(cur, { pathExt: pathExtExe });",
                "            if (is) {",
                "              if (opt.all)",
                "                found.push(cur);",
                "              else",
                "                return cur;",
                "            }",
                "          } catch (ex) {",
                "          }",
                "        }",
                "      }",
                "      if (opt.all && found.length)",
                "        return found;",
                "      if (opt.nothrow)",
                "        return null;",
                "      throw getNotFoundError(cmd);",
                "    };",
                "    module2.exports = which;",
                "    which.sync = whichSync;",
                "  }",
                "});",
                "",
                "// node_modules/path-key/index.js",
                "var require_path_key = __commonJS({",
                "  \"node_modules/path-key/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var pathKey2 = (options = {}) => {",
                "      const environment = options.env || process.env;",
                "      const platform = options.platform || process.platform;",
                "      if (platform !== \"win32\") {",
                "        return \"PATH\";",
                "      }",
                "      return Object.keys(environment).reverse().find((key) => key.toUpperCase() === \"PATH\") || \"Path\";",
                "    };",
                "    module2.exports = pathKey2;",
                "    module2.exports.default = pathKey2;",
                "  }",
                "});",
                "",
                "// node_modules/cross-spawn/lib/util/resolveCommand.js",
                "var require_resolveCommand = __commonJS({",
                "  \"node_modules/cross-spawn/lib/util/resolveCommand.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var path3 = require(\"path\");",
                "    var which = require_which();",
                "    var getPathKey = require_path_key();",
                "    function resolveCommandAttempt(parsed, withoutPathExt) {",
                "      const env = parsed.options.env || process.env;",
                "      const cwd = process.cwd();",
                "      const hasCustomCwd = parsed.options.cwd != null;",
                "      const shouldSwitchCwd = hasCustomCwd && process.chdir !== void 0 && !process.chdir.disabled;",
                "      if (shouldSwitchCwd) {",
                "        try {",
                "          process.chdir(parsed.options.cwd);",
                "        } catch (err) {",
                "        }",
                "      }",
                "      let resolved;",
                "      try {",
                "        resolved = which.sync(parsed.command, {",
                "          path: env[getPathKey({ env })],",
                "          pathExt: withoutPathExt ? path3.delimiter : void 0",
                "        });",
                "      } catch (e) {",
                "      } finally {",
                "        if (shouldSwitchCwd) {",
                "          process.chdir(cwd);",
                "        }",
                "      }",
                "      if (resolved) {",
                "        resolved = path3.resolve(hasCustomCwd ? parsed.options.cwd : \"\", resolved);",
                "      }",
                "      return resolved;",
                "    }",
                "    function resolveCommand(parsed) {",
                "      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);",
                "    }",
                "    module2.exports = resolveCommand;",
                "  }",
                "});",
                "",
                "// node_modules/cross-spawn/lib/util/escape.js",
                "var require_escape = __commonJS({",
                "  \"node_modules/cross-spawn/lib/util/escape.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var metaCharsRegExp = /([()\\][%!^\"`<>&|;, *?])/g;",
                "    function escapeCommand(arg) {",
                "      arg = arg.replace(metaCharsRegExp, \"^$1\");",
                "      return arg;",
                "    }",
                "    function escapeArgument(arg, doubleEscapeMetaChars) {",
                "      arg = `${arg}`;",
                "      arg = arg.replace(/(\\\\*)\"/g, '$1$1\\\\\"');",
                "      arg = arg.replace(/(\\\\*)$/, \"$1$1\");",
                "      arg = `\"${arg}\"`;",
                "      arg = arg.replace(metaCharsRegExp, \"^$1\");",
                "      if (doubleEscapeMetaChars) {",
                "        arg = arg.replace(metaCharsRegExp, \"^$1\");",
                "      }",
                "      return arg;",
                "    }",
                "    module2.exports.command = escapeCommand;",
                "    module2.exports.argument = escapeArgument;",
                "  }",
                "});",
                "",
                "// node_modules/shebang-regex/index.js",
                "var require_shebang_regex = __commonJS({",
                "  \"node_modules/shebang-regex/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = /^#!(.*)/;",
                "  }",
                "});",
                "",
                "// node_modules/shebang-command/index.js",
                "var require_shebang_command = __commonJS({",
                "  \"node_modules/shebang-command/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var shebangRegex = require_shebang_regex();",
                "    module2.exports = (string = \"\") => {",
                "      const match = string.match(shebangRegex);",
                "      if (!match) {",
                "        return null;",
                "      }",
                "      const [path3, argument] = match[0].replace(/#! ?/, \"\").split(\" \");",
                "      const binary = path3.split(\"/\").pop();",
                "      if (binary === \"env\") {",
                "        return argument;",
                "      }",
                "      return argument ? `${binary} ${argument}` : binary;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/cross-spawn/lib/util/readShebang.js",
                "var require_readShebang = __commonJS({",
                "  \"node_modules/cross-spawn/lib/util/readShebang.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var fs = require(\"fs\");",
                "    var shebangCommand = require_shebang_command();",
                "    function readShebang(command) {",
                "      const size = 150;",
                "      const buffer = Buffer.alloc(size);",
                "      let fd;",
                "      try {",
                "        fd = fs.openSync(command, \"r\");",
                "        fs.readSync(fd, buffer, 0, size, 0);",
                "        fs.closeSync(fd);",
                "      } catch (e) {",
                "      }",
                "      return shebangCommand(buffer.toString());",
                "    }",
                "    module2.exports = readShebang;",
                "  }",
                "});",
                "",
                "// node_modules/cross-spawn/lib/parse.js",
                "var require_parse = __commonJS({",
                "  \"node_modules/cross-spawn/lib/parse.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var path3 = require(\"path\");",
                "    var resolveCommand = require_resolveCommand();",
                "    var escape = require_escape();",
                "    var readShebang = require_readShebang();",
                "    var isWin = process.platform === \"win32\";",
                "    var isExecutableRegExp = /\\.(?:com|exe)$/i;",
                "    var isCmdShimRegExp = /node_modules[\\\\/].bin[\\\\/][^\\\\/]+\\.cmd$/i;",
                "    function detectShebang(parsed) {",
                "      parsed.file = resolveCommand(parsed);",
                "      const shebang = parsed.file && readShebang(parsed.file);",
                "      if (shebang) {",
                "        parsed.args.unshift(parsed.file);",
                "        parsed.command = shebang;",
                "        return resolveCommand(parsed);",
                "      }",
                "      return parsed.file;",
                "    }",
                "    function parseNonShell(parsed) {",
                "      if (!isWin) {",
                "        return parsed;",
                "      }",
                "      const commandFile = detectShebang(parsed);",
                "      const needsShell = !isExecutableRegExp.test(commandFile);",
                "      if (parsed.options.forceShell || needsShell) {",
                "        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);",
                "        parsed.command = path3.normalize(parsed.command);",
                "        parsed.command = escape.command(parsed.command);",
                "        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));",
                "        const shellCommand = [parsed.command].concat(parsed.args).join(\" \");",
                "        parsed.args = [\"/d\", \"/s\", \"/c\", `\"${shellCommand}\"`];",
                "        parsed.command = process.env.comspec || \"cmd.exe\";",
                "        parsed.options.windowsVerbatimArguments = true;",
                "      }",
                "      return parsed;",
                "    }",
                "    function parse(command, args, options) {",
                "      if (args && !Array.isArray(args)) {",
                "        options = args;",
                "        args = null;",
                "      }",
                "      args = args ? args.slice(0) : [];",
                "      options = Object.assign({}, options);",
                "      const parsed = {",
                "        command,",
                "        args,",
                "        options,",
                "        file: void 0,",
                "        original: {",
                "          command,",
                "          args",
                "        }",
                "      };",
                "      return options.shell ? parsed : parseNonShell(parsed);",
                "    }",
                "    module2.exports = parse;",
                "  }",
                "});",
                "",
                "// node_modules/cross-spawn/lib/enoent.js",
                "var require_enoent = __commonJS({",
                "  \"node_modules/cross-spawn/lib/enoent.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var isWin = process.platform === \"win32\";",
                "    function notFoundError(original, syscall) {",
                "      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {",
                "        code: \"ENOENT\",",
                "        errno: \"ENOENT\",",
                "        syscall: `${syscall} ${original.command}`,",
                "        path: original.command,",
                "        spawnargs: original.args",
                "      });",
                "    }",
                "    function hookChildProcess(cp, parsed) {",
                "      if (!isWin) {",
                "        return;",
                "      }",
                "      const originalEmit = cp.emit;",
                "      cp.emit = function(name, arg1) {",
                "        if (name === \"exit\") {",
                "          const err = verifyENOENT(arg1, parsed, \"spawn\");",
                "          if (err) {",
                "            return originalEmit.call(cp, \"error\", err);",
                "          }",
                "        }",
                "        return originalEmit.apply(cp, arguments);",
                "      };",
                "    }",
                "    function verifyENOENT(status, parsed) {",
                "      if (isWin && status === 1 && !parsed.file) {",
                "        return notFoundError(parsed.original, \"spawn\");",
                "      }",
                "      return null;",
                "    }",
                "    function verifyENOENTSync(status, parsed) {",
                "      if (isWin && status === 1 && !parsed.file) {",
                "        return notFoundError(parsed.original, \"spawnSync\");",
                "      }",
                "      return null;",
                "    }",
                "    module2.exports = {",
                "      hookChildProcess,",
                "      verifyENOENT,",
                "      verifyENOENTSync,",
                "      notFoundError",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/cross-spawn/index.js",
                "var require_cross_spawn = __commonJS({",
                "  \"node_modules/cross-spawn/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var cp = require(\"child_process\");",
                "    var parse = require_parse();",
                "    var enoent = require_enoent();",
                "    function spawn(command, args, options) {",
                "      const parsed = parse(command, args, options);",
                "      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);",
                "      enoent.hookChildProcess(spawned, parsed);",
                "      return spawned;",
                "    }",
                "    function spawnSync(command, args, options) {",
                "      const parsed = parse(command, args, options);",
                "      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);",
                "      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);",
                "      return result;",
                "    }",
                "    module2.exports = spawn;",
                "    module2.exports.spawn = spawn;",
                "    module2.exports.sync = spawnSync;",
                "    module2.exports._parse = parse;",
                "    module2.exports._enoent = enoent;",
                "  }",
                "});",
                "",
                "// node_modules/signal-exit/signals.js",
                "var require_signals = __commonJS({",
                "  \"node_modules/signal-exit/signals.js\"(exports, module2) {",
                "    module2.exports = [",
                "      \"SIGABRT\",",
                "      \"SIGALRM\",",
                "      \"SIGHUP\",",
                "      \"SIGINT\",",
                "      \"SIGTERM\"",
                "    ];",
                "    if (process.platform !== \"win32\") {",
                "      module2.exports.push(",
                "        \"SIGVTALRM\",",
                "        \"SIGXCPU\",",
                "        \"SIGXFSZ\",",
                "        \"SIGUSR2\",",
                "        \"SIGTRAP\",",
                "        \"SIGSYS\",",
                "        \"SIGQUIT\",",
                "        \"SIGIOT\"",
                "      );",
                "    }",
                "    if (process.platform === \"linux\") {",
                "      module2.exports.push(",
                "        \"SIGIO\",",
                "        \"SIGPOLL\",",
                "        \"SIGPWR\",",
                "        \"SIGSTKFLT\",",
                "        \"SIGUNUSED\"",
                "      );",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/signal-exit/index.js",
                "var require_signal_exit = __commonJS({",
                "  \"node_modules/signal-exit/index.js\"(exports, module2) {",
                "    var process4 = global.process;",
                "    var processOk = function(process5) {",
                "      return process5 && typeof process5 === \"object\" && typeof process5.removeListener === \"function\" && typeof process5.emit === \"function\" && typeof process5.reallyExit === \"function\" && typeof process5.listeners === \"function\" && typeof process5.kill === \"function\" && typeof process5.pid === \"number\" && typeof process5.on === \"function\";",
                "    };",
                "    if (!processOk(process4)) {",
                "      module2.exports = function() {",
                "        return function() {",
                "        };",
                "      };",
                "    } else {",
                "      assert = require(\"assert\");",
                "      signals = require_signals();",
                "      isWin = /^win/i.test(process4.platform);",
                "      EE = require(\"events\");",
                "      if (typeof EE !== \"function\") {",
                "        EE = EE.EventEmitter;",
                "      }",
                "      if (process4.__signal_exit_emitter__) {",
                "        emitter = process4.__signal_exit_emitter__;",
                "      } else {",
                "        emitter = process4.__signal_exit_emitter__ = new EE();",
                "        emitter.count = 0;",
                "        emitter.emitted = {};",
                "      }",
                "      if (!emitter.infinite) {",
                "        emitter.setMaxListeners(Infinity);",
                "        emitter.infinite = true;",
                "      }",
                "      module2.exports = function(cb, opts) {",
                "        if (!processOk(global.process)) {",
                "          return function() {",
                "          };",
                "        }",
                "        assert.equal(typeof cb, \"function\", \"a callback must be provided for exit handler\");",
                "        if (loaded === false) {",
                "          load();",
                "        }",
                "        var ev = \"exit\";",
                "        if (opts && opts.alwaysLast) {",
                "          ev = \"afterexit\";",
                "        }",
                "        var remove = function() {",
                "          emitter.removeListener(ev, cb);",
                "          if (emitter.listeners(\"exit\").length === 0 && emitter.listeners(\"afterexit\").length === 0) {",
                "            unload();",
                "          }",
                "        };",
                "        emitter.on(ev, cb);",
                "        return remove;",
                "      };",
                "      unload = function unload2() {",
                "        if (!loaded || !processOk(global.process)) {",
                "          return;",
                "        }",
                "        loaded = false;",
                "        signals.forEach(function(sig) {",
                "          try {",
                "            process4.removeListener(sig, sigListeners[sig]);",
                "          } catch (er) {",
                "          }",
                "        });",
                "        process4.emit = originalProcessEmit;",
                "        process4.reallyExit = originalProcessReallyExit;",
                "        emitter.count -= 1;",
                "      };",
                "      module2.exports.unload = unload;",
                "      emit = function emit2(event, code, signal) {",
                "        if (emitter.emitted[event]) {",
                "          return;",
                "        }",
                "        emitter.emitted[event] = true;",
                "        emitter.emit(event, code, signal);",
                "      };",
                "      sigListeners = {};",
                "      signals.forEach(function(sig) {",
                "        sigListeners[sig] = function listener() {",
                "          if (!processOk(global.process)) {",
                "            return;",
                "          }",
                "          var listeners = process4.listeners(sig);",
                "          if (listeners.length === emitter.count) {",
                "            unload();",
                "            emit(\"exit\", null, sig);",
                "            emit(\"afterexit\", null, sig);",
                "            if (isWin && sig === \"SIGHUP\") {",
                "              sig = \"SIGINT\";",
                "            }",
                "            process4.kill(process4.pid, sig);",
                "          }",
                "        };",
                "      });",
                "      module2.exports.signals = function() {",
                "        return signals;",
                "      };",
                "      loaded = false;",
                "      load = function load2() {",
                "        if (loaded || !processOk(global.process)) {",
                "          return;",
                "        }",
                "        loaded = true;",
                "        emitter.count += 1;",
                "        signals = signals.filter(function(sig) {",
                "          try {",
                "            process4.on(sig, sigListeners[sig]);",
                "            return true;",
                "          } catch (er) {",
                "            return false;",
                "          }",
                "        });",
                "        process4.emit = processEmit;",
                "        process4.reallyExit = processReallyExit;",
                "      };",
                "      module2.exports.load = load;",
                "      originalProcessReallyExit = process4.reallyExit;",
                "      processReallyExit = function processReallyExit2(code) {",
                "        if (!processOk(global.process)) {",
                "          return;",
                "        }",
                "        process4.exitCode = code || 0;",
                "        emit(\"exit\", process4.exitCode, null);",
                "        emit(\"afterexit\", process4.exitCode, null);",
                "        originalProcessReallyExit.call(process4, process4.exitCode);",
                "      };",
                "      originalProcessEmit = process4.emit;",
                "      processEmit = function processEmit2(ev, arg) {",
                "        if (ev === \"exit\" && processOk(global.process)) {",
                "          if (arg !== void 0) {",
                "            process4.exitCode = arg;",
                "          }",
                "          var ret = originalProcessEmit.apply(this, arguments);",
                "          emit(\"exit\", process4.exitCode, null);",
                "          emit(\"afterexit\", process4.exitCode, null);",
                "          return ret;",
                "        } else {",
                "          return originalProcessEmit.apply(this, arguments);",
                "        }",
                "      };",
                "    }",
                "    var assert;",
                "    var signals;",
                "    var isWin;",
                "    var EE;",
                "    var emitter;",
                "    var unload;",
                "    var emit;",
                "    var sigListeners;",
                "    var loaded;",
                "    var load;",
                "    var originalProcessReallyExit;",
                "    var processReallyExit;",
                "    var originalProcessEmit;",
                "    var processEmit;",
                "  }",
                "});",
                "",
                "// node_modules/get-stream/buffer-stream.js",
                "var require_buffer_stream = __commonJS({",
                "  \"node_modules/get-stream/buffer-stream.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var { PassThrough: PassThroughStream } = require(\"stream\");",
                "    module2.exports = (options) => {",
                "      options = { ...options };",
                "      const { array } = options;",
                "      let { encoding } = options;",
                "      const isBuffer = encoding === \"buffer\";",
                "      let objectMode = false;",
                "      if (array) {",
                "        objectMode = !(encoding || isBuffer);",
                "      } else {",
                "        encoding = encoding || \"utf8\";",
                "      }",
                "      if (isBuffer) {",
                "        encoding = null;",
                "      }",
                "      const stream = new PassThroughStream({ objectMode });",
                "      if (encoding) {",
                "        stream.setEncoding(encoding);",
                "      }",
                "      let length = 0;",
                "      const chunks = [];",
                "      stream.on(\"data\", (chunk) => {",
                "        chunks.push(chunk);",
                "        if (objectMode) {",
                "          length = chunks.length;",
                "        } else {",
                "          length += chunk.length;",
                "        }",
                "      });",
                "      stream.getBufferedValue = () => {",
                "        if (array) {",
                "          return chunks;",
                "        }",
                "        return isBuffer ? Buffer.concat(chunks, length) : chunks.join(\"\");",
                "      };",
                "      stream.getBufferedLength = () => length;",
                "      return stream;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/get-stream/index.js",
                "var require_get_stream = __commonJS({",
                "  \"node_modules/get-stream/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var { constants: BufferConstants } = require(\"buffer\");",
                "    var stream = require(\"stream\");",
                "    var { promisify } = require(\"util\");",
                "    var bufferStream = require_buffer_stream();",
                "    var streamPipelinePromisified = promisify(stream.pipeline);",
                "    var MaxBufferError = class extends Error {",
                "      constructor() {",
                "        super(\"maxBuffer exceeded\");",
                "        this.name = \"MaxBufferError\";",
                "      }",
                "    };",
                "    async function getStream2(inputStream, options) {",
                "      if (!inputStream) {",
                "        throw new Error(\"Expected a stream\");",
                "      }",
                "      options = {",
                "        maxBuffer: Infinity,",
                "        ...options",
                "      };",
                "      const { maxBuffer } = options;",
                "      const stream2 = bufferStream(options);",
                "      await new Promise((resolve, reject) => {",
                "        const rejectPromise = (error) => {",
                "          if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {",
                "            error.bufferedData = stream2.getBufferedValue();",
                "          }",
                "          reject(error);",
                "        };",
                "        (async () => {",
                "          try {",
                "            await streamPipelinePromisified(inputStream, stream2);",
                "            resolve();",
                "          } catch (error) {",
                "            rejectPromise(error);",
                "          }",
                "        })();",
                "        stream2.on(\"data\", () => {",
                "          if (stream2.getBufferedLength() > maxBuffer) {",
                "            rejectPromise(new MaxBufferError());",
                "          }",
                "        });",
                "      });",
                "      return stream2.getBufferedValue();",
                "    }",
                "    module2.exports = getStream2;",
                "    module2.exports.buffer = (stream2, options) => getStream2(stream2, { ...options, encoding: \"buffer\" });",
                "    module2.exports.array = (stream2, options) => getStream2(stream2, { ...options, array: true });",
                "    module2.exports.MaxBufferError = MaxBufferError;",
                "  }",
                "});",
                "",
                "// node_modules/merge-stream/index.js",
                "var require_merge_stream = __commonJS({",
                "  \"node_modules/merge-stream/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var { PassThrough } = require(\"stream\");",
                "    module2.exports = function() {",
                "      var sources = [];",
                "      var output = new PassThrough({ objectMode: true });",
                "      output.setMaxListeners(0);",
                "      output.add = add;",
                "      output.isEmpty = isEmpty;",
                "      output.on(\"unpipe\", remove);",
                "      Array.prototype.slice.call(arguments).forEach(add);",
                "      return output;",
                "      function add(source) {",
                "        if (Array.isArray(source)) {",
                "          source.forEach(add);",
                "          return this;",
                "        }",
                "        sources.push(source);",
                "        source.once(\"end\", remove.bind(null, source));",
                "        source.once(\"error\", output.emit.bind(output, \"error\"));",
                "        source.pipe(output, { end: false });",
                "        return this;",
                "      }",
                "      function isEmpty() {",
                "        return sources.length == 0;",
                "      }",
                "      function remove(source) {",
                "        sources = sources.filter(function(it) {",
                "          return it !== source;",
                "        });",
                "        if (!sources.length && output.readable) {",
                "          output.end();",
                "        }",
                "      }",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/execa/index.js",
                "var execa_exports = {};",
                "__export(execa_exports, {",
                "  execa: () => execa,",
                "  execaCommand: () => execaCommand,",
                "  execaCommandSync: () => execaCommandSync,",
                "  execaNode: () => execaNode,",
                "  execaSync: () => execaSync",
                "});",
                "module.exports = __toCommonJS(execa_exports);",
                "var import_node_buffer = require(\"buffer\");",
                "var import_node_path2 = __toESM(require(\"path\"), 1);",
                "var import_node_child_process = __toESM(require(\"child_process\"), 1);",
                "var import_node_process2 = __toESM(require(\"process\"), 1);",
                "var import_cross_spawn = __toESM(require_cross_spawn(), 1);",
                "",
                "// node_modules/strip-final-newline/index.js",
                "function stripFinalNewline(input) {",
                "  const LF = typeof input === \"string\" ? \"\\n\" : \"\\n\".charCodeAt();",
                "  const CR = typeof input === \"string\" ? \"\\r\" : \"\\r\".charCodeAt();",
                "  if (input[input.length - 1] === LF) {",
                "    input = input.slice(0, -1);",
                "  }",
                "  if (input[input.length - 1] === CR) {",
                "    input = input.slice(0, -1);",
                "  }",
                "  return input;",
                "}",
                "",
                "// node_modules/npm-run-path/index.js",
                "var import_node_process = __toESM(require(\"process\"), 1);",
                "var import_node_path = __toESM(require(\"path\"), 1);",
                "var import_node_url = __toESM(require(\"url\"), 1);",
                "",
                "// node_modules/npm-run-path/node_modules/path-key/index.js",
                "function pathKey(options = {}) {",
                "  const {",
                "    env = process.env,",
                "    platform = process.platform",
                "  } = options;",
                "  if (platform !== \"win32\") {",
                "    return \"PATH\";",
                "  }",
                "  return Object.keys(env).reverse().find((key) => key.toUpperCase() === \"PATH\") || \"Path\";",
                "}",
                "",
                "// node_modules/npm-run-path/index.js",
                "function npmRunPath(options = {}) {",
                "  const {",
                "    cwd = import_node_process.default.cwd(),",
                "    path: path_ = import_node_process.default.env[pathKey()],",
                "    execPath = import_node_process.default.execPath",
                "  } = options;",
                "  let previous;",
                "  const cwdString = cwd instanceof URL ? import_node_url.default.fileURLToPath(cwd) : cwd;",
                "  let cwdPath = import_node_path.default.resolve(cwdString);",
                "  const result = [];",
                "  while (previous !== cwdPath) {",
                "    result.push(import_node_path.default.join(cwdPath, \"node_modules/.bin\"));",
                "    previous = cwdPath;",
                "    cwdPath = import_node_path.default.resolve(cwdPath, \"..\");",
                "  }",
                "  result.push(import_node_path.default.resolve(cwdString, execPath, \"..\"));",
                "  return [...result, path_].join(import_node_path.default.delimiter);",
                "}",
                "function npmRunPathEnv({ env = import_node_process.default.env, ...options } = {}) {",
                "  env = { ...env };",
                "  const path3 = pathKey({ env });",
                "  options.path = env[path3];",
                "  env[path3] = npmRunPath(options);",
                "  return env;",
                "}",
                "",
                "// node_modules/mimic-fn/index.js",
                "var copyProperty = (to, from, property, ignoreNonConfigurable) => {",
                "  if (property === \"length\" || property === \"prototype\") {",
                "    return;",
                "  }",
                "  if (property === \"arguments\" || property === \"caller\") {",
                "    return;",
                "  }",
                "  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);",
                "  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);",
                "  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {",
                "    return;",
                "  }",
                "  Object.defineProperty(to, property, fromDescriptor);",
                "};",
                "var canCopyProperty = function(toDescriptor, fromDescriptor) {",
                "  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);",
                "};",
                "var changePrototype = (to, from) => {",
                "  const fromPrototype = Object.getPrototypeOf(from);",
                "  if (fromPrototype === Object.getPrototypeOf(to)) {",
                "    return;",
                "  }",
                "  Object.setPrototypeOf(to, fromPrototype);",
                "};",
                "var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/",
                "${fromBody}`;",
                "var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, \"toString\");",
                "var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, \"name\");",
                "var changeToString = (to, from, name) => {",
                "  const withName = name === \"\" ? \"\" : `with ${name.trim()}() `;",
                "  const newToString = wrappedToString.bind(null, withName, from.toString());",
                "  Object.defineProperty(newToString, \"name\", toStringName);",
                "  Object.defineProperty(to, \"toString\", { ...toStringDescriptor, value: newToString });",
                "};",
                "function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {",
                "  const { name } = to;",
                "  for (const property of Reflect.ownKeys(from)) {",
                "    copyProperty(to, from, property, ignoreNonConfigurable);",
                "  }",
                "  changePrototype(to, from);",
                "  changeToString(to, from, name);",
                "  return to;",
                "}",
                "",
                "// node_modules/onetime/index.js",
                "var calledFunctions = /* @__PURE__ */ new WeakMap();",
                "var onetime = (function_, options = {}) => {",
                "  if (typeof function_ !== \"function\") {",
                "    throw new TypeError(\"Expected a function\");",
                "  }",
                "  let returnValue;",
                "  let callCount = 0;",
                "  const functionName = function_.displayName || function_.name || \"<anonymous>\";",
                "  const onetime2 = function(...arguments_) {",
                "    calledFunctions.set(onetime2, ++callCount);",
                "    if (callCount === 1) {",
                "      returnValue = function_.apply(this, arguments_);",
                "      function_ = null;",
                "    } else if (options.throw === true) {",
                "      throw new Error(`Function \\`${functionName}\\` can only be called once`);",
                "    }",
                "    return returnValue;",
                "  };",
                "  mimicFunction(onetime2, function_);",
                "  calledFunctions.set(onetime2, callCount);",
                "  return onetime2;",
                "};",
                "onetime.callCount = (function_) => {",
                "  if (!calledFunctions.has(function_)) {",
                "    throw new Error(`The given function \\`${function_.name}\\` is not wrapped by the \\`onetime\\` package`);",
                "  }",
                "  return calledFunctions.get(function_);",
                "};",
                "var onetime_default = onetime;",
                "",
                "// node_modules/human-signals/build/src/main.js",
                "var import_os2 = require(\"os\");",
                "",
                "// node_modules/human-signals/build/src/realtime.js",
                "var getRealtimeSignals = function() {",
                "  const length = SIGRTMAX - SIGRTMIN + 1;",
                "  return Array.from({ length }, getRealtimeSignal);",
                "};",
                "var getRealtimeSignal = function(value, index) {",
                "  return {",
                "    name: `SIGRT${index + 1}`,",
                "    number: SIGRTMIN + index,",
                "    action: \"terminate\",",
                "    description: \"Application-specific signal (realtime)\",",
                "    standard: \"posix\"",
                "  };",
                "};",
                "var SIGRTMIN = 34;",
                "var SIGRTMAX = 64;",
                "",
                "// node_modules/human-signals/build/src/signals.js",
                "var import_os = require(\"os\");",
                "",
                "// node_modules/human-signals/build/src/core.js",
                "var SIGNALS = [",
                "  {",
                "    name: \"SIGHUP\",",
                "    number: 1,",
                "    action: \"terminate\",",
                "    description: \"Terminal closed\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGINT\",",
                "    number: 2,",
                "    action: \"terminate\",",
                "    description: \"User interruption with CTRL-C\",",
                "    standard: \"ansi\"",
                "  },",
                "  {",
                "    name: \"SIGQUIT\",",
                "    number: 3,",
                "    action: \"core\",",
                "    description: \"User interruption with CTRL-\\\\\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGILL\",",
                "    number: 4,",
                "    action: \"core\",",
                "    description: \"Invalid machine instruction\",",
                "    standard: \"ansi\"",
                "  },",
                "  {",
                "    name: \"SIGTRAP\",",
                "    number: 5,",
                "    action: \"core\",",
                "    description: \"Debugger breakpoint\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGABRT\",",
                "    number: 6,",
                "    action: \"core\",",
                "    description: \"Aborted\",",
                "    standard: \"ansi\"",
                "  },",
                "  {",
                "    name: \"SIGIOT\",",
                "    number: 6,",
                "    action: \"core\",",
                "    description: \"Aborted\",",
                "    standard: \"bsd\"",
                "  },",
                "  {",
                "    name: \"SIGBUS\",",
                "    number: 7,",
                "    action: \"core\",",
                "    description: \"Bus error due to misaligned, non-existing address or paging error\",",
                "    standard: \"bsd\"",
                "  },",
                "  {",
                "    name: \"SIGEMT\",",
                "    number: 7,",
                "    action: \"terminate\",",
                "    description: \"Command should be emulated but is not implemented\",",
                "    standard: \"other\"",
                "  },",
                "  {",
                "    name: \"SIGFPE\",",
                "    number: 8,",
                "    action: \"core\",",
                "    description: \"Floating point arithmetic error\",",
                "    standard: \"ansi\"",
                "  },",
                "  {",
                "    name: \"SIGKILL\",",
                "    number: 9,",
                "    action: \"terminate\",",
                "    description: \"Forced termination\",",
                "    standard: \"posix\",",
                "    forced: true",
                "  },",
                "  {",
                "    name: \"SIGUSR1\",",
                "    number: 10,",
                "    action: \"terminate\",",
                "    description: \"Application-specific signal\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGSEGV\",",
                "    number: 11,",
                "    action: \"core\",",
                "    description: \"Segmentation fault\",",
                "    standard: \"ansi\"",
                "  },",
                "  {",
                "    name: \"SIGUSR2\",",
                "    number: 12,",
                "    action: \"terminate\",",
                "    description: \"Application-specific signal\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGPIPE\",",
                "    number: 13,",
                "    action: \"terminate\",",
                "    description: \"Broken pipe or socket\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGALRM\",",
                "    number: 14,",
                "    action: \"terminate\",",
                "    description: \"Timeout or timer\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGTERM\",",
                "    number: 15,",
                "    action: \"terminate\",",
                "    description: \"Termination\",",
                "    standard: \"ansi\"",
                "  },",
                "  {",
                "    name: \"SIGSTKFLT\",",
                "    number: 16,",
                "    action: \"terminate\",",
                "    description: \"Stack is empty or overflowed\",",
                "    standard: \"other\"",
                "  },",
                "  {",
                "    name: \"SIGCHLD\",",
                "    number: 17,",
                "    action: \"ignore\",",
                "    description: \"Child process terminated, paused or unpaused\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGCLD\",",
                "    number: 17,",
                "    action: \"ignore\",",
                "    description: \"Child process terminated, paused or unpaused\",",
                "    standard: \"other\"",
                "  },",
                "  {",
                "    name: \"SIGCONT\",",
                "    number: 18,",
                "    action: \"unpause\",",
                "    description: \"Unpaused\",",
                "    standard: \"posix\",",
                "    forced: true",
                "  },",
                "  {",
                "    name: \"SIGSTOP\",",
                "    number: 19,",
                "    action: \"pause\",",
                "    description: \"Paused\",",
                "    standard: \"posix\",",
                "    forced: true",
                "  },",
                "  {",
                "    name: \"SIGTSTP\",",
                "    number: 20,",
                "    action: \"pause\",",
                "    description: 'Paused using CTRL-Z or \"suspend\"',",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGTTIN\",",
                "    number: 21,",
                "    action: \"pause\",",
                "    description: \"Background process cannot read terminal input\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGBREAK\",",
                "    number: 21,",
                "    action: \"terminate\",",
                "    description: \"User interruption with CTRL-BREAK\",",
                "    standard: \"other\"",
                "  },",
                "  {",
                "    name: \"SIGTTOU\",",
                "    number: 22,",
                "    action: \"pause\",",
                "    description: \"Background process cannot write to terminal output\",",
                "    standard: \"posix\"",
                "  },",
                "  {",
                "    name: \"SIGURG\",",
                "    number: 23,",
                "    action: \"ignore\",",
                "    description: \"Socket received out-of-band data\",",
                "    standard: \"bsd\"",
                "  },",
                "  {",
                "    name: \"SIGXCPU\",",
                "    number: 24,",
                "    action: \"core\",",
                "    description: \"Process timed out\",",
                "    standard: \"bsd\"",
                "  },",
                "  {",
                "    name: \"SIGXFSZ\",",
                "    number: 25,",
                "    action: \"core\",",
                "    description: \"File too big\",",
                "    standard: \"bsd\"",
                "  },",
                "  {",
                "    name: \"SIGVTALRM\",",
                "    number: 26,",
                "    action: \"terminate\",",
                "    description: \"Timeout or timer\",",
                "    standard: \"bsd\"",
                "  },",
                "  {",
                "    name: \"SIGPROF\",",
                "    number: 27,",
                "    action: \"terminate\",",
                "    description: \"Timeout or timer\",",
                "    standard: \"bsd\"",
                "  },",
                "  {",
                "    name: \"SIGWINCH\",",
                "    number: 28,",
                "    action: \"ignore\",",
                "    description: \"Terminal window size changed\",",
                "    standard: \"bsd\"",
                "  },",
                "  {",
                "    name: \"SIGIO\",",
                "    number: 29,",
                "    action: \"terminate\",",
                "    description: \"I/O is available\",",
                "    standard: \"other\"",
                "  },",
                "  {",
                "    name: \"SIGPOLL\",",
                "    number: 29,",
                "    action: \"terminate\",",
                "    description: \"Watched event\",",
                "    standard: \"other\"",
                "  },",
                "  {",
                "    name: \"SIGINFO\",",
                "    number: 29,",
                "    action: \"ignore\",",
                "    description: \"Request for process information\",",
                "    standard: \"other\"",
                "  },",
                "  {",
                "    name: \"SIGPWR\",",
                "    number: 30,",
                "    action: \"terminate\",",
                "    description: \"Device running out of power\",",
                "    standard: \"systemv\"",
                "  },",
                "  {",
                "    name: \"SIGSYS\",",
                "    number: 31,",
                "    action: \"core\",",
                "    description: \"Invalid system call\",",
                "    standard: \"other\"",
                "  },",
                "  {",
                "    name: \"SIGUNUSED\",",
                "    number: 31,",
                "    action: \"terminate\",",
                "    description: \"Invalid system call\",",
                "    standard: \"other\"",
                "  }",
                "];",
                "",
                "// node_modules/human-signals/build/src/signals.js",
                "var getSignals = function() {",
                "  const realtimeSignals = getRealtimeSignals();",
                "  const signals = [...SIGNALS, ...realtimeSignals].map(normalizeSignal);",
                "  return signals;",
                "};",
                "var normalizeSignal = function({",
                "  name,",
                "  number: defaultNumber,",
                "  description,",
                "  action,",
                "  forced = false,",
                "  standard",
                "}) {",
                "  const {",
                "    signals: { [name]: constantSignal }",
                "  } = import_os.constants;",
                "  const supported = constantSignal !== void 0;",
                "  const number = supported ? constantSignal : defaultNumber;",
                "  return { name, number, description, supported, action, forced, standard };",
                "};",
                "",
                "// node_modules/human-signals/build/src/main.js",
                "var getSignalsByName = function() {",
                "  const signals = getSignals();",
                "  return signals.reduce(getSignalByName, {});",
                "};",
                "var getSignalByName = function(signalByNameMemo, { name, number, description, supported, action, forced, standard }) {",
                "  return {",
                "    ...signalByNameMemo,",
                "    [name]: { name, number, description, supported, action, forced, standard }",
                "  };",
                "};",
                "var signalsByName = getSignalsByName();",
                "var getSignalsByNumber = function() {",
                "  const signals = getSignals();",
                "  const length = SIGRTMAX + 1;",
                "  const signalsA = Array.from({ length }, (value, number) => getSignalByNumber(number, signals));",
                "  return Object.assign({}, ...signalsA);",
                "};",
                "var getSignalByNumber = function(number, signals) {",
                "  const signal = findSignalByNumber(number, signals);",
                "  if (signal === void 0) {",
                "    return {};",
                "  }",
                "  const { name, description, supported, action, forced, standard } = signal;",
                "  return {",
                "    [number]: {",
                "      name,",
                "      number,",
                "      description,",
                "      supported,",
                "      action,",
                "      forced,",
                "      standard",
                "    }",
                "  };",
                "};",
                "var findSignalByNumber = function(number, signals) {",
                "  const signal = signals.find(({ name }) => import_os2.constants.signals[name] === number);",
                "  if (signal !== void 0) {",
                "    return signal;",
                "  }",
                "  return signals.find((signalA) => signalA.number === number);",
                "};",
                "var signalsByNumber = getSignalsByNumber();",
                "",
                "// node_modules/execa/lib/error.js",
                "var getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled }) => {",
                "  if (timedOut) {",
                "    return `timed out after ${timeout} milliseconds`;",
                "  }",
                "  if (isCanceled) {",
                "    return \"was canceled\";",
                "  }",
                "  if (errorCode !== void 0) {",
                "    return `failed with ${errorCode}`;",
                "  }",
                "  if (signal !== void 0) {",
                "    return `was killed with ${signal} (${signalDescription})`;",
                "  }",
                "  if (exitCode !== void 0) {",
                "    return `failed with exit code ${exitCode}`;",
                "  }",
                "  return \"failed\";",
                "};",
                "var makeError = ({",
                "  stdout,",
                "  stderr,",
                "  all,",
                "  error,",
                "  signal,",
                "  exitCode,",
                "  command,",
                "  escapedCommand,",
                "  timedOut,",
                "  isCanceled,",
                "  killed,",
                "  parsed: { options: { timeout } }",
                "}) => {",
                "  exitCode = exitCode === null ? void 0 : exitCode;",
                "  signal = signal === null ? void 0 : signal;",
                "  const signalDescription = signal === void 0 ? void 0 : signalsByName[signal].description;",
                "  const errorCode = error && error.code;",
                "  const prefix = getErrorPrefix({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled });",
                "  const execaMessage = `Command ${prefix}: ${command}`;",
                "  const isError = Object.prototype.toString.call(error) === \"[object Error]\";",
                "  const shortMessage = isError ? `${execaMessage}",
                "${error.message}` : execaMessage;",
                "  const message = [shortMessage, stderr, stdout].filter(Boolean).join(\"\\n\");",
                "  if (isError) {",
                "    error.originalMessage = error.message;",
                "    error.message = message;",
                "  } else {",
                "    error = new Error(message);",
                "  }",
                "  error.shortMessage = shortMessage;",
                "  error.command = command;",
                "  error.escapedCommand = escapedCommand;",
                "  error.exitCode = exitCode;",
                "  error.signal = signal;",
                "  error.signalDescription = signalDescription;",
                "  error.stdout = stdout;",
                "  error.stderr = stderr;",
                "  if (all !== void 0) {",
                "    error.all = all;",
                "  }",
                "  if (\"bufferedData\" in error) {",
                "    delete error.bufferedData;",
                "  }",
                "  error.failed = true;",
                "  error.timedOut = Boolean(timedOut);",
                "  error.isCanceled = isCanceled;",
                "  error.killed = killed && !timedOut;",
                "  return error;",
                "};",
                "",
                "// node_modules/execa/lib/stdio.js",
                "var aliases = [\"stdin\", \"stdout\", \"stderr\"];",
                "var hasAlias = (options) => aliases.some((alias) => options[alias] !== void 0);",
                "var normalizeStdio = (options) => {",
                "  if (!options) {",
                "    return;",
                "  }",
                "  const { stdio } = options;",
                "  if (stdio === void 0) {",
                "    return aliases.map((alias) => options[alias]);",
                "  }",
                "  if (hasAlias(options)) {",
                "    throw new Error(`It's not possible to provide \\`stdio\\` in combination with one of ${aliases.map((alias) => `\\`${alias}\\``).join(\", \")}`);",
                "  }",
                "  if (typeof stdio === \"string\") {",
                "    return stdio;",
                "  }",
                "  if (!Array.isArray(stdio)) {",
                "    throw new TypeError(`Expected \\`stdio\\` to be of type \\`string\\` or \\`Array\\`, got \\`${typeof stdio}\\``);",
                "  }",
                "  const length = Math.max(stdio.length, aliases.length);",
                "  return Array.from({ length }, (value, index) => stdio[index]);",
                "};",
                "var normalizeStdioNode = (options) => {",
                "  const stdio = normalizeStdio(options);",
                "  if (stdio === \"ipc\") {",
                "    return \"ipc\";",
                "  }",
                "  if (stdio === void 0 || typeof stdio === \"string\") {",
                "    return [stdio, stdio, stdio, \"ipc\"];",
                "  }",
                "  if (stdio.includes(\"ipc\")) {",
                "    return stdio;",
                "  }",
                "  return [...stdio, \"ipc\"];",
                "};",
                "",
                "// node_modules/execa/lib/kill.js",
                "var import_node_os = __toESM(require(\"os\"), 1);",
                "var import_signal_exit = __toESM(require_signal_exit(), 1);",
                "var DEFAULT_FORCE_KILL_TIMEOUT = 1e3 * 5;",
                "var spawnedKill = (kill, signal = \"SIGTERM\", options = {}) => {",
                "  const killResult = kill(signal);",
                "  setKillTimeout(kill, signal, options, killResult);",
                "  return killResult;",
                "};",
                "var setKillTimeout = (kill, signal, options, killResult) => {",
                "  if (!shouldForceKill(signal, options, killResult)) {",
                "    return;",
                "  }",
                "  const timeout = getForceKillAfterTimeout(options);",
                "  const t = setTimeout(() => {",
                "    kill(\"SIGKILL\");",
                "  }, timeout);",
                "  if (t.unref) {",
                "    t.unref();",
                "  }",
                "};",
                "var shouldForceKill = (signal, { forceKillAfterTimeout }, killResult) => isSigterm(signal) && forceKillAfterTimeout !== false && killResult;",
                "var isSigterm = (signal) => signal === import_node_os.default.constants.signals.SIGTERM || typeof signal === \"string\" && signal.toUpperCase() === \"SIGTERM\";",
                "var getForceKillAfterTimeout = ({ forceKillAfterTimeout = true }) => {",
                "  if (forceKillAfterTimeout === true) {",
                "    return DEFAULT_FORCE_KILL_TIMEOUT;",
                "  }",
                "  if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {",
                "    throw new TypeError(`Expected the \\`forceKillAfterTimeout\\` option to be a non-negative integer, got \\`${forceKillAfterTimeout}\\` (${typeof forceKillAfterTimeout})`);",
                "  }",
                "  return forceKillAfterTimeout;",
                "};",
                "var spawnedCancel = (spawned, context) => {",
                "  const killResult = spawned.kill();",
                "  if (killResult) {",
                "    context.isCanceled = true;",
                "  }",
                "};",
                "var timeoutKill = (spawned, signal, reject) => {",
                "  spawned.kill(signal);",
                "  reject(Object.assign(new Error(\"Timed out\"), { timedOut: true, signal }));",
                "};",
                "var setupTimeout = (spawned, { timeout, killSignal = \"SIGTERM\" }, spawnedPromise) => {",
                "  if (timeout === 0 || timeout === void 0) {",
                "    return spawnedPromise;",
                "  }",
                "  let timeoutId;",
                "  const timeoutPromise = new Promise((resolve, reject) => {",
                "    timeoutId = setTimeout(() => {",
                "      timeoutKill(spawned, killSignal, reject);",
                "    }, timeout);",
                "  });",
                "  const safeSpawnedPromise = spawnedPromise.finally(() => {",
                "    clearTimeout(timeoutId);",
                "  });",
                "  return Promise.race([timeoutPromise, safeSpawnedPromise]);",
                "};",
                "var validateTimeout = ({ timeout }) => {",
                "  if (timeout !== void 0 && (!Number.isFinite(timeout) || timeout < 0)) {",
                "    throw new TypeError(`Expected the \\`timeout\\` option to be a non-negative integer, got \\`${timeout}\\` (${typeof timeout})`);",
                "  }",
                "};",
                "var setExitHandler = async (spawned, { cleanup, detached }, timedPromise) => {",
                "  if (!cleanup || detached) {",
                "    return timedPromise;",
                "  }",
                "  const removeExitHandler = (0, import_signal_exit.default)(() => {",
                "    spawned.kill();",
                "  });",
                "  return timedPromise.finally(() => {",
                "    removeExitHandler();",
                "  });",
                "};",
                "",
                "// node_modules/is-stream/index.js",
                "function isStream(stream) {",
                "  return stream !== null && typeof stream === \"object\" && typeof stream.pipe === \"function\";",
                "}",
                "",
                "// node_modules/execa/lib/stream.js",
                "var import_get_stream = __toESM(require_get_stream(), 1);",
                "var import_merge_stream = __toESM(require_merge_stream(), 1);",
                "var handleInput = (spawned, input) => {",
                "  if (input === void 0 || spawned.stdin === void 0) {",
                "    return;",
                "  }",
                "  if (isStream(input)) {",
                "    input.pipe(spawned.stdin);",
                "  } else {",
                "    spawned.stdin.end(input);",
                "  }",
                "};",
                "var makeAllStream = (spawned, { all }) => {",
                "  if (!all || !spawned.stdout && !spawned.stderr) {",
                "    return;",
                "  }",
                "  const mixed = (0, import_merge_stream.default)();",
                "  if (spawned.stdout) {",
                "    mixed.add(spawned.stdout);",
                "  }",
                "  if (spawned.stderr) {",
                "    mixed.add(spawned.stderr);",
                "  }",
                "  return mixed;",
                "};",
                "var getBufferedData = async (stream, streamPromise) => {",
                "  if (!stream) {",
                "    return;",
                "  }",
                "  stream.destroy();",
                "  try {",
                "    return await streamPromise;",
                "  } catch (error) {",
                "    return error.bufferedData;",
                "  }",
                "};",
                "var getStreamPromise = (stream, { encoding, buffer, maxBuffer }) => {",
                "  if (!stream || !buffer) {",
                "    return;",
                "  }",
                "  if (encoding) {",
                "    return (0, import_get_stream.default)(stream, { encoding, maxBuffer });",
                "  }",
                "  return import_get_stream.default.buffer(stream, { maxBuffer });",
                "};",
                "var getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone) => {",
                "  const stdoutPromise = getStreamPromise(stdout, { encoding, buffer, maxBuffer });",
                "  const stderrPromise = getStreamPromise(stderr, { encoding, buffer, maxBuffer });",
                "  const allPromise = getStreamPromise(all, { encoding, buffer, maxBuffer: maxBuffer * 2 });",
                "  try {",
                "    return await Promise.all([processDone, stdoutPromise, stderrPromise, allPromise]);",
                "  } catch (error) {",
                "    return Promise.all([",
                "      { error, signal: error.signal, timedOut: error.timedOut },",
                "      getBufferedData(stdout, stdoutPromise),",
                "      getBufferedData(stderr, stderrPromise),",
                "      getBufferedData(all, allPromise)",
                "    ]);",
                "  }",
                "};",
                "var validateInputSync = ({ input }) => {",
                "  if (isStream(input)) {",
                "    throw new TypeError(\"The `input` option cannot be a stream in sync mode\");",
                "  }",
                "};",
                "",
                "// node_modules/execa/lib/promise.js",
                "var nativePromisePrototype = (async () => {",
                "})().constructor.prototype;",
                "var descriptors = [\"then\", \"catch\", \"finally\"].map((property) => [",
                "  property,",
                "  Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)",
                "]);",
                "var mergePromise = (spawned, promise) => {",
                "  for (const [property, descriptor] of descriptors) {",
                "    const value = typeof promise === \"function\" ? (...args) => Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);",
                "    Reflect.defineProperty(spawned, property, { ...descriptor, value });",
                "  }",
                "  return spawned;",
                "};",
                "var getSpawnedPromise = (spawned) => new Promise((resolve, reject) => {",
                "  spawned.on(\"exit\", (exitCode, signal) => {",
                "    resolve({ exitCode, signal });",
                "  });",
                "  spawned.on(\"error\", (error) => {",
                "    reject(error);",
                "  });",
                "  if (spawned.stdin) {",
                "    spawned.stdin.on(\"error\", (error) => {",
                "      reject(error);",
                "    });",
                "  }",
                "});",
                "",
                "// node_modules/execa/lib/command.js",
                "var normalizeArgs = (file, args = []) => {",
                "  if (!Array.isArray(args)) {",
                "    return [file];",
                "  }",
                "  return [file, ...args];",
                "};",
                "var NO_ESCAPE_REGEXP = /^[\\w.-]+$/;",
                "var DOUBLE_QUOTES_REGEXP = /\"/g;",
                "var escapeArg = (arg) => {",
                "  if (typeof arg !== \"string\" || NO_ESCAPE_REGEXP.test(arg)) {",
                "    return arg;",
                "  }",
                "  return `\"${arg.replace(DOUBLE_QUOTES_REGEXP, '\\\\\"')}\"`;",
                "};",
                "var joinCommand = (file, args) => normalizeArgs(file, args).join(\" \");",
                "var getEscapedCommand = (file, args) => normalizeArgs(file, args).map((arg) => escapeArg(arg)).join(\" \");",
                "var SPACES_REGEXP = / +/g;",
                "var parseCommand = (command) => {",
                "  const tokens = [];",
                "  for (const token of command.trim().split(SPACES_REGEXP)) {",
                "    const previousToken = tokens[tokens.length - 1];",
                "    if (previousToken && previousToken.endsWith(\"\\\\\")) {",
                "      tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;",
                "    } else {",
                "      tokens.push(token);",
                "    }",
                "  }",
                "  return tokens;",
                "};",
                "",
                "// node_modules/execa/index.js",
                "var DEFAULT_MAX_BUFFER = 1e3 * 1e3 * 100;",
                "var getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath }) => {",
                "  const env = extendEnv ? { ...import_node_process2.default.env, ...envOption } : envOption;",
                "  if (preferLocal) {",
                "    return npmRunPathEnv({ env, cwd: localDir, execPath });",
                "  }",
                "  return env;",
                "};",
                "var handleArguments = (file, args, options = {}) => {",
                "  const parsed = import_cross_spawn.default._parse(file, args, options);",
                "  file = parsed.command;",
                "  args = parsed.args;",
                "  options = parsed.options;",
                "  options = {",
                "    maxBuffer: DEFAULT_MAX_BUFFER,",
                "    buffer: true,",
                "    stripFinalNewline: true,",
                "    extendEnv: true,",
                "    preferLocal: false,",
                "    localDir: options.cwd || import_node_process2.default.cwd(),",
                "    execPath: import_node_process2.default.execPath,",
                "    encoding: \"utf8\",",
                "    reject: true,",
                "    cleanup: true,",
                "    all: false,",
                "    windowsHide: true,",
                "    ...options",
                "  };",
                "  options.env = getEnv(options);",
                "  options.stdio = normalizeStdio(options);",
                "  if (import_node_process2.default.platform === \"win32\" && import_node_path2.default.basename(file, \".exe\") === \"cmd\") {",
                "    args.unshift(\"/q\");",
                "  }",
                "  return { file, args, options, parsed };",
                "};",
                "var handleOutput = (options, value, error) => {",
                "  if (typeof value !== \"string\" && !import_node_buffer.Buffer.isBuffer(value)) {",
                "    return error === void 0 ? void 0 : \"\";",
                "  }",
                "  if (options.stripFinalNewline) {",
                "    return stripFinalNewline(value);",
                "  }",
                "  return value;",
                "};",
                "function execa(file, args, options) {",
                "  const parsed = handleArguments(file, args, options);",
                "  const command = joinCommand(file, args);",
                "  const escapedCommand = getEscapedCommand(file, args);",
                "  validateTimeout(parsed.options);",
                "  let spawned;",
                "  try {",
                "    spawned = import_node_child_process.default.spawn(parsed.file, parsed.args, parsed.options);",
                "  } catch (error) {",
                "    const dummySpawned = new import_node_child_process.default.ChildProcess();",
                "    const errorPromise = Promise.reject(makeError({",
                "      error,",
                "      stdout: \"\",",
                "      stderr: \"\",",
                "      all: \"\",",
                "      command,",
                "      escapedCommand,",
                "      parsed,",
                "      timedOut: false,",
                "      isCanceled: false,",
                "      killed: false",
                "    }));",
                "    return mergePromise(dummySpawned, errorPromise);",
                "  }",
                "  const spawnedPromise = getSpawnedPromise(spawned);",
                "  const timedPromise = setupTimeout(spawned, parsed.options, spawnedPromise);",
                "  const processDone = setExitHandler(spawned, parsed.options, timedPromise);",
                "  const context = { isCanceled: false };",
                "  spawned.kill = spawnedKill.bind(null, spawned.kill.bind(spawned));",
                "  spawned.cancel = spawnedCancel.bind(null, spawned, context);",
                "  const handlePromise = async () => {",
                "    const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await getSpawnedResult(spawned, parsed.options, processDone);",
                "    const stdout = handleOutput(parsed.options, stdoutResult);",
                "    const stderr = handleOutput(parsed.options, stderrResult);",
                "    const all = handleOutput(parsed.options, allResult);",
                "    if (error || exitCode !== 0 || signal !== null) {",
                "      const returnedError = makeError({",
                "        error,",
                "        exitCode,",
                "        signal,",
                "        stdout,",
                "        stderr,",
                "        all,",
                "        command,",
                "        escapedCommand,",
                "        parsed,",
                "        timedOut,",
                "        isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),",
                "        killed: spawned.killed",
                "      });",
                "      if (!parsed.options.reject) {",
                "        return returnedError;",
                "      }",
                "      throw returnedError;",
                "    }",
                "    return {",
                "      command,",
                "      escapedCommand,",
                "      exitCode: 0,",
                "      stdout,",
                "      stderr,",
                "      all,",
                "      failed: false,",
                "      timedOut: false,",
                "      isCanceled: false,",
                "      killed: false",
                "    };",
                "  };",
                "  const handlePromiseOnce = onetime_default(handlePromise);",
                "  handleInput(spawned, parsed.options.input);",
                "  spawned.all = makeAllStream(spawned, parsed.options);",
                "  return mergePromise(spawned, handlePromiseOnce);",
                "}",
                "function execaSync(file, args, options) {",
                "  const parsed = handleArguments(file, args, options);",
                "  const command = joinCommand(file, args);",
                "  const escapedCommand = getEscapedCommand(file, args);",
                "  validateInputSync(parsed.options);",
                "  let result;",
                "  try {",
                "    result = import_node_child_process.default.spawnSync(parsed.file, parsed.args, parsed.options);",
                "  } catch (error) {",
                "    throw makeError({",
                "      error,",
                "      stdout: \"\",",
                "      stderr: \"\",",
                "      all: \"\",",
                "      command,",
                "      escapedCommand,",
                "      parsed,",
                "      timedOut: false,",
                "      isCanceled: false,",
                "      killed: false",
                "    });",
                "  }",
                "  const stdout = handleOutput(parsed.options, result.stdout, result.error);",
                "  const stderr = handleOutput(parsed.options, result.stderr, result.error);",
                "  if (result.error || result.status !== 0 || result.signal !== null) {",
                "    const error = makeError({",
                "      stdout,",
                "      stderr,",
                "      error: result.error,",
                "      signal: result.signal,",
                "      exitCode: result.status,",
                "      command,",
                "      escapedCommand,",
                "      parsed,",
                "      timedOut: result.error && result.error.code === \"ETIMEDOUT\",",
                "      isCanceled: false,",
                "      killed: result.signal !== null",
                "    });",
                "    if (!parsed.options.reject) {",
                "      return error;",
                "    }",
                "    throw error;",
                "  }",
                "  return {",
                "    command,",
                "    escapedCommand,",
                "    exitCode: 0,",
                "    stdout,",
                "    stderr,",
                "    failed: false,",
                "    timedOut: false,",
                "    isCanceled: false,",
                "    killed: false",
                "  };",
                "}",
                "function execaCommand(command, options) {",
                "  const [file, ...args] = parseCommand(command);",
                "  return execa(file, args, options);",
                "}",
                "function execaCommandSync(command, options) {",
                "  const [file, ...args] = parseCommand(command);",
                "  return execaSync(file, args, options);",
                "}",
                "function execaNode(scriptPath, args, options = {}) {",
                "  if (args && !Array.isArray(args) && typeof args === \"object\") {",
                "    options = args;",
                "    args = [];",
                "  }",
                "  const stdio = normalizeStdioNode(options);",
                "  const defaultExecArgv = import_node_process2.default.execArgv.filter((arg) => !arg.startsWith(\"--inspect\"));",
                "  const {",
                "    nodePath = import_node_process2.default.execPath,",
                "    nodeOptions = defaultExecArgv",
                "  } = options;",
                "  return execa(",
                "    nodePath,",
                "    [",
                "      ...nodeOptions,",
                "      scriptPath,",
                "      ...Array.isArray(args) ? args : []",
                "    ],",
                "    {",
                "      ...options,",
                "      stdin: void 0,",
                "      stdout: void 0,",
                "      stderr: void 0,",
                "      stdio,",
                "      shell: false",
                "    }",
                "  );",
                "}",
                "// Annotate the CommonJS export names for ESM import in node:",
                "0 && (module.exports = {",
                "  execa,",
                "  execaCommand,",
                "  execaCommandSync,",
                "  execaNode,",
                "  execaSync",
                "});"
            ]
        },
        "html-element-attributes.json": {},
        "html-tag-names.json": {},
        "leven.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// This file is generated automatically.",
                "export {default} from \"leven\";",
                "export * from \"leven\";"
            ]
        },
        "leven.js": {
            "classes": [],
            "functions": [],
            "text": [
                "// @ts-nocheck",
                "// This file is generated automatically",
                "var __defProp = Object.defineProperty;",
                "var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
                "var __getOwnPropNames = Object.getOwnPropertyNames;",
                "var __hasOwnProp = Object.prototype.hasOwnProperty;",
                "var __export = (target, all) => {",
                "  for (var name in all)",
                "    __defProp(target, name, { get: all[name], enumerable: true });",
                "};",
                "var __copyProps = (to, from, except, desc) => {",
                "  if (from && typeof from === \"object\" || typeof from === \"function\") {",
                "    for (let key of __getOwnPropNames(from))",
                "      if (!__hasOwnProp.call(to, key) && key !== except)",
                "        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
                "  }",
                "  return to;",
                "};",
                "var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);",
                "",
                "// node_modules/leven/index.js",
                "var leven_exports = {};",
                "__export(leven_exports, {",
                "  default: () => leven",
                "});",
                "module.exports = __toCommonJS(leven_exports);",
                "var array = [];",
                "var characterCodeCache = [];",
                "function leven(first, second) {",
                "  if (first === second) {",
                "    return 0;",
                "  }",
                "  const swap = first;",
                "  if (first.length > second.length) {",
                "    first = second;",
                "    second = swap;",
                "  }",
                "  let firstLength = first.length;",
                "  let secondLength = second.length;",
                "  while (firstLength > 0 && first.charCodeAt(~-firstLength) === second.charCodeAt(~-secondLength)) {",
                "    firstLength--;",
                "    secondLength--;",
                "  }",
                "  let start = 0;",
                "  while (start < firstLength && first.charCodeAt(start) === second.charCodeAt(start)) {",
                "    start++;",
                "  }",
                "  firstLength -= start;",
                "  secondLength -= start;",
                "  if (firstLength === 0) {",
                "    return secondLength;",
                "  }",
                "  let bCharacterCode;",
                "  let result;",
                "  let temporary;",
                "  let temporary2;",
                "  let index = 0;",
                "  let index2 = 0;",
                "  while (index < firstLength) {",
                "    characterCodeCache[index] = first.charCodeAt(start + index);",
                "    array[index] = ++index;",
                "  }",
                "  while (index2 < secondLength) {",
                "    bCharacterCode = second.charCodeAt(start + index2);",
                "    temporary = index2++;",
                "    result = index2;",
                "    for (index = 0; index < firstLength; index++) {",
                "      temporary2 = bCharacterCode === characterCodeCache[index] ? temporary : temporary + 1;",
                "      temporary = array[index];",
                "      result = array[index] = temporary > result ? temporary2 > result ? result + 1 : temporary2 : temporary2 > temporary ? temporary + 1 : temporary2;",
                "    }",
                "  }",
                "  return result;",
                "}",
                "// Annotate the CommonJS export names for ESM import in node:",
                "0 && (module.exports = {});"
            ]
        },
        "mem.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// This file is generated automatically.",
                "export {default} from \"mem\";",
                "export * from \"mem\";"
            ]
        },
        "mem.js": {
            "classes": [],
            "functions": [],
            "text": [
                "// @ts-nocheck",
                "// This file is generated automatically",
                "var __create = Object.create;",
                "var __defProp = Object.defineProperty;",
                "var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
                "var __getOwnPropNames = Object.getOwnPropertyNames;",
                "var __getProtoOf = Object.getPrototypeOf;",
                "var __hasOwnProp = Object.prototype.hasOwnProperty;",
                "var __commonJS = (cb, mod) => function __require() {",
                "  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;",
                "};",
                "var __export = (target, all) => {",
                "  for (var name in all)",
                "    __defProp(target, name, { get: all[name], enumerable: true });",
                "};",
                "var __copyProps = (to, from, except, desc) => {",
                "  if (from && typeof from === \"object\" || typeof from === \"function\") {",
                "    for (let key of __getOwnPropNames(from))",
                "      if (!__hasOwnProp.call(to, key) && key !== except)",
                "        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
                "  }",
                "  return to;",
                "};",
                "var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(",
                "  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,",
                "  mod",
                "));",
                "var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);",
                "",
                "// node_modules/p-defer/index.js",
                "var require_p_defer = __commonJS({",
                "  \"node_modules/p-defer/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = () => {",
                "      const ret = {};",
                "      ret.promise = new Promise((resolve, reject) => {",
                "        ret.resolve = resolve;",
                "        ret.reject = reject;",
                "      });",
                "      return ret;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/map-age-cleaner/dist/index.js",
                "var require_dist = __commonJS({",
                "  \"node_modules/map-age-cleaner/dist/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {",
                "      return new (P || (P = Promise))(function(resolve, reject) {",
                "        function fulfilled(value) {",
                "          try {",
                "            step(generator.next(value));",
                "          } catch (e) {",
                "            reject(e);",
                "          }",
                "        }",
                "        function rejected(value) {",
                "          try {",
                "            step(generator[\"throw\"](value));",
                "          } catch (e) {",
                "            reject(e);",
                "          }",
                "        }",
                "        function step(result) {",
                "          result.done ? resolve(result.value) : new P(function(resolve2) {",
                "            resolve2(result.value);",
                "          }).then(fulfilled, rejected);",
                "        }",
                "        step((generator = generator.apply(thisArg, _arguments || [])).next());",
                "      });",
                "    };",
                "    var __importDefault = exports && exports.__importDefault || function(mod) {",
                "      return mod && mod.__esModule ? mod : { \"default\": mod };",
                "    };",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var p_defer_1 = __importDefault(require_p_defer());",
                "    function mapAgeCleaner2(map, property = \"maxAge\") {",
                "      let processingKey;",
                "      let processingTimer;",
                "      let processingDeferred;",
                "      const cleanup = () => __awaiter(this, void 0, void 0, function* () {",
                "        if (processingKey !== void 0) {",
                "          return;",
                "        }",
                "        const setupTimer = (item) => __awaiter(this, void 0, void 0, function* () {",
                "          processingDeferred = p_defer_1.default();",
                "          const delay = item[1][property] - Date.now();",
                "          if (delay <= 0) {",
                "            map.delete(item[0]);",
                "            processingDeferred.resolve();",
                "            return;",
                "          }",
                "          processingKey = item[0];",
                "          processingTimer = setTimeout(() => {",
                "            map.delete(item[0]);",
                "            if (processingDeferred) {",
                "              processingDeferred.resolve();",
                "            }",
                "          }, delay);",
                "          if (typeof processingTimer.unref === \"function\") {",
                "            processingTimer.unref();",
                "          }",
                "          return processingDeferred.promise;",
                "        });",
                "        try {",
                "          for (const entry of map) {",
                "            yield setupTimer(entry);",
                "          }",
                "        } catch (_a) {",
                "        }",
                "        processingKey = void 0;",
                "      });",
                "      const reset = () => {",
                "        processingKey = void 0;",
                "        if (processingTimer !== void 0) {",
                "          clearTimeout(processingTimer);",
                "          processingTimer = void 0;",
                "        }",
                "        if (processingDeferred !== void 0) {",
                "          processingDeferred.reject(void 0);",
                "          processingDeferred = void 0;",
                "        }",
                "      };",
                "      const originalSet = map.set.bind(map);",
                "      map.set = (key, value) => {",
                "        if (map.has(key)) {",
                "          map.delete(key);",
                "        }",
                "        const result = originalSet(key, value);",
                "        if (processingKey && processingKey === key) {",
                "          reset();",
                "        }",
                "        cleanup();",
                "        return result;",
                "      };",
                "      cleanup();",
                "      return map;",
                "    }",
                "    exports.default = mapAgeCleaner2;",
                "    module2.exports = mapAgeCleaner2;",
                "    module2.exports.default = mapAgeCleaner2;",
                "  }",
                "});",
                "",
                "// node_modules/mem/dist/index.js",
                "var dist_exports = {};",
                "__export(dist_exports, {",
                "  default: () => mem,",
                "  memClear: () => memClear,",
                "  memDecorator: () => memDecorator",
                "});",
                "module.exports = __toCommonJS(dist_exports);",
                "",
                "// node_modules/mimic-fn/index.js",
                "var copyProperty = (to, from, property, ignoreNonConfigurable) => {",
                "  if (property === \"length\" || property === \"prototype\") {",
                "    return;",
                "  }",
                "  if (property === \"arguments\" || property === \"caller\") {",
                "    return;",
                "  }",
                "  const toDescriptor = Object.getOwnPropertyDescriptor(to, property);",
                "  const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);",
                "  if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {",
                "    return;",
                "  }",
                "  Object.defineProperty(to, property, fromDescriptor);",
                "};",
                "var canCopyProperty = function(toDescriptor, fromDescriptor) {",
                "  return toDescriptor === void 0 || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);",
                "};",
                "var changePrototype = (to, from) => {",
                "  const fromPrototype = Object.getPrototypeOf(from);",
                "  if (fromPrototype === Object.getPrototypeOf(to)) {",
                "    return;",
                "  }",
                "  Object.setPrototypeOf(to, fromPrototype);",
                "};",
                "var wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/",
                "${fromBody}`;",
                "var toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, \"toString\");",
                "var toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, \"name\");",
                "var changeToString = (to, from, name) => {",
                "  const withName = name === \"\" ? \"\" : `with ${name.trim()}() `;",
                "  const newToString = wrappedToString.bind(null, withName, from.toString());",
                "  Object.defineProperty(newToString, \"name\", toStringName);",
                "  Object.defineProperty(to, \"toString\", { ...toStringDescriptor, value: newToString });",
                "};",
                "function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {",
                "  const { name } = to;",
                "  for (const property of Reflect.ownKeys(from)) {",
                "    copyProperty(to, from, property, ignoreNonConfigurable);",
                "  }",
                "  changePrototype(to, from);",
                "  changeToString(to, from, name);",
                "  return to;",
                "}",
                "",
                "// node_modules/mem/dist/index.js",
                "var import_map_age_cleaner = __toESM(require_dist(), 1);",
                "var cacheStore = /* @__PURE__ */ new WeakMap();",
                "function mem(fn, { cacheKey, cache = /* @__PURE__ */ new Map(), maxAge } = {}) {",
                "  if (typeof maxAge === \"number\") {",
                "    (0, import_map_age_cleaner.default)(cache);",
                "  }",
                "  const memoized = function(...arguments_) {",
                "    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];",
                "    const cacheItem = cache.get(key);",
                "    if (cacheItem) {",
                "      return cacheItem.data;",
                "    }",
                "    const result = fn.apply(this, arguments_);",
                "    cache.set(key, {",
                "      data: result,",
                "      maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY",
                "    });",
                "    return result;",
                "  };",
                "  mimicFunction(memoized, fn, {",
                "    ignoreNonConfigurable: true",
                "  });",
                "  cacheStore.set(memoized, cache);",
                "  return memoized;",
                "}",
                "function memDecorator(options = {}) {",
                "  const instanceMap = /* @__PURE__ */ new WeakMap();",
                "  return (target, propertyKey, descriptor) => {",
                "    const input = target[propertyKey];",
                "    if (typeof input !== \"function\") {",
                "      throw new TypeError(\"The decorated value must be a function\");",
                "    }",
                "    delete descriptor.value;",
                "    delete descriptor.writable;",
                "    descriptor.get = function() {",
                "      if (!instanceMap.has(this)) {",
                "        const value = mem(input, options);",
                "        instanceMap.set(this, value);",
                "        return value;",
                "      }",
                "      return instanceMap.get(this);",
                "    };",
                "  };",
                "}",
                "function memClear(fn) {",
                "  const cache = cacheStore.get(fn);",
                "  if (!cache) {",
                "    throw new TypeError(\"Can't clear a function that was not memoized!\");",
                "  }",
                "  if (typeof cache.clear !== \"function\") {",
                "    throw new TypeError(\"The cache Map can't be cleared!\");",
                "  }",
                "  cache.clear();",
                "}",
                "// Annotate the CommonJS export names for ESM import in node:",
                "0 && (module.exports = {",
                "  memClear,",
                "  memDecorator",
                "});"
            ]
        },
        "sdbm.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// This file is generated automatically.",
                "export {default} from \"sdbm\";",
                "export * from \"sdbm\";"
            ]
        },
        "sdbm.js": {
            "classes": [],
            "functions": [],
            "text": [
                "// @ts-nocheck",
                "// This file is generated automatically",
                "var __defProp = Object.defineProperty;",
                "var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
                "var __getOwnPropNames = Object.getOwnPropertyNames;",
                "var __hasOwnProp = Object.prototype.hasOwnProperty;",
                "var __export = (target, all) => {",
                "  for (var name in all)",
                "    __defProp(target, name, { get: all[name], enumerable: true });",
                "};",
                "var __copyProps = (to, from, except, desc) => {",
                "  if (from && typeof from === \"object\" || typeof from === \"function\") {",
                "    for (let key of __getOwnPropNames(from))",
                "      if (!__hasOwnProp.call(to, key) && key !== except)",
                "        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
                "  }",
                "  return to;",
                "};",
                "var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);",
                "",
                "// node_modules/sdbm/index.js",
                "var sdbm_exports = {};",
                "__export(sdbm_exports, {",
                "  default: () => sdbm",
                "});",
                "module.exports = __toCommonJS(sdbm_exports);",
                "function sdbm(string) {",
                "  let hash = 0;",
                "  for (let i = 0; i < string.length; i++) {",
                "    hash = string.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;",
                "  }",
                "  return hash >>> 0;",
                "}",
                "// Annotate the CommonJS export names for ESM import in node:",
                "0 && (module.exports = {});"
            ]
        },
        "string-width.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// This file is generated automatically.",
                "export {default} from \"string-width\";",
                "export * from \"string-width\";"
            ]
        },
        "string-width.js": {
            "classes": [],
            "functions": [],
            "text": [
                "// @ts-nocheck",
                "// This file is generated automatically",
                "var __create = Object.create;",
                "var __defProp = Object.defineProperty;",
                "var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
                "var __getOwnPropNames = Object.getOwnPropertyNames;",
                "var __getProtoOf = Object.getPrototypeOf;",
                "var __hasOwnProp = Object.prototype.hasOwnProperty;",
                "var __commonJS = (cb, mod) => function __require() {",
                "  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;",
                "};",
                "var __export = (target, all) => {",
                "  for (var name in all)",
                "    __defProp(target, name, { get: all[name], enumerable: true });",
                "};",
                "var __copyProps = (to, from, except, desc) => {",
                "  if (from && typeof from === \"object\" || typeof from === \"function\") {",
                "    for (let key of __getOwnPropNames(from))",
                "      if (!__hasOwnProp.call(to, key) && key !== except)",
                "        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
                "  }",
                "  return to;",
                "};",
                "var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(",
                "  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,",
                "  mod",
                "));",
                "var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);",
                "",
                "// node_modules/emoji-regex/index.js",
                "var require_emoji_regex = __commonJS({",
                "  \"node_modules/emoji-regex/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = function() {",
                "      return /\\uD83C\\uDFF4\\uDB40\\uDC67\\uDB40\\uDC62(?:\\uDB40\\uDC77\\uDB40\\uDC6C\\uDB40\\uDC73|\\uDB40\\uDC73\\uDB40\\uDC63\\uDB40\\uDC74|\\uDB40\\uDC65\\uDB40\\uDC6E\\uDB40\\uDC67)\\uDB40\\uDC7F|(?:\\uD83E\\uDDD1\\uD83C\\uDFFF\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFF\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFE])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFE\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFE\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFD\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFD\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFC\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFC\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|(?:\\uD83E\\uDDD1\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83E\\uDDD1|\\uD83D\\uDC69\\uD83C\\uDFFB\\u200D\\uD83E\\uDD1D\\u200D(?:\\uD83D[\\uDC68\\uDC69]))(?:\\uD83C[\\uDFFC-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C\\uDFFB(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFC-\\uDFFF])|[\\u2695\\u2696\\u2708]\\uFE0F|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))?|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFF]))|\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D)?\\uD83D\\uDC68|(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFE])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB-\\uDFFD\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFC\\uDFFE\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83D\\uDC68(?:\\uD83C[\\uDFFB\\uDFFD-\\uDFFF])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])\\uFE0F|\\u200D(?:(?:\\uD83D[\\uDC68\\uDC69])\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D[\\uDC66\\uDC67])|\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC)?|(?:\\uD83D\\uDC69(?:\\uD83C\\uDFFB\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|(?:\\uD83C[\\uDFFC-\\uDFFF])\\u200D\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69]))|\\uD83E\\uDDD1(?:\\uD83C[\\uDFFB-\\uDFFF])\\u200D\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1)(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67]))|\\uD83D\\uDC69(?:\\u200D(?:\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDC8B\\u200D(?:\\uD83D[\\uDC68\\uDC69])|\\uD83D[\\uDC68\\uDC69])|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83E\\uDDD1(?:\\u200D(?:\\uD83E\\uDD1D\\u200D\\uD83E\\uDDD1|\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFF\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFE\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFD\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFC\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD])|\\uD83C\\uDFFB\\u200D(?:\\uD83C[\\uDF3E\\uDF73\\uDF7C\\uDF84\\uDF93\\uDFA4\\uDFA8\\uDFEB\\uDFED]|\\uD83D[\\uDCBB\\uDCBC\\uDD27\\uDD2C\\uDE80\\uDE92]|\\uD83E[\\uDDAF-\\uDDB3\\uDDBC\\uDDBD]))|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66\\u200D\\uD83D\\uDC66|\\uD83D\\uDC69\\u200D\\uD83D\\uDC69\\u200D(?:\\uD83D[\\uDC66\\uDC67])|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67\\u200D(?:\\uD83D[\\uDC66\\uDC67])|(?:\\uD83D\\uDC41\\uFE0F\\u200D\\uD83D\\uDDE8|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDC69(?:\\uD83C\\uDFFF\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFE\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFD\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFC\\u200D[\\u2695\\u2696\\u2708]|\\uD83C\\uDFFB\\u200D[\\u2695\\u2696\\u2708]|\\u200D[\\u2695\\u2696\\u2708])|\\uD83D\\uDE36\\u200D\\uD83C\\uDF2B|\\uD83C\\uDFF3\\uFE0F\\u200D\\u26A7|\\uD83D\\uDC3B\\u200D\\u2744|(?:(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF])\\u200D[\\u2640\\u2642]|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])\\u200D[\\u2640\\u2642]|\\uD83C\\uDFF4\\u200D\\u2620|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])\\u200D[\\u2640\\u2642]|[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u2328\\u23CF\\u23ED-\\u23EF\\u23F1\\u23F2\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB\\u25FC\\u2600-\\u2604\\u260E\\u2611\\u2618\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u2692\\u2694-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A7\\u26B0\\u26B1\\u26C8\\u26CF\\u26D1\\u26D3\\u26E9\\u26F0\\u26F1\\u26F4\\u26F7\\u26F8\\u2702\\u2708\\u2709\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2733\\u2734\\u2744\\u2747\\u2763\\u27A1\\u2934\\u2935\\u2B05-\\u2B07\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDE02\\uDE37\\uDF21\\uDF24-\\uDF2C\\uDF36\\uDF7D\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E\\uDF9F\\uDFCD\\uDFCE\\uDFD4-\\uDFDF\\uDFF5\\uDFF7]|\\uD83D[\\uDC3F\\uDCFD\\uDD49\\uDD4A\\uDD6F\\uDD70\\uDD73\\uDD76-\\uDD79\\uDD87\\uDD8A-\\uDD8D\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA\\uDECB\\uDECD-\\uDECF\\uDEE0-\\uDEE5\\uDEE9\\uDEF0\\uDEF3])\\uFE0F|\\uD83C\\uDFF3\\uFE0F\\u200D\\uD83C\\uDF08|\\uD83D\\uDC69\\u200D\\uD83D\\uDC67|\\uD83D\\uDC69\\u200D\\uD83D\\uDC66|\\uD83D\\uDE35\\u200D\\uD83D\\uDCAB|\\uD83D\\uDE2E\\u200D\\uD83D\\uDCA8|\\uD83D\\uDC15\\u200D\\uD83E\\uDDBA|\\uD83E\\uDDD1(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83D\\uDC69(?:\\uD83C\\uDFFF|\\uD83C\\uDFFE|\\uD83C\\uDFFD|\\uD83C\\uDFFC|\\uD83C\\uDFFB)?|\\uD83C\\uDDFD\\uD83C\\uDDF0|\\uD83C\\uDDF6\\uD83C\\uDDE6|\\uD83C\\uDDF4\\uD83C\\uDDF2|\\uD83D\\uDC08\\u200D\\u2B1B|\\u2764\\uFE0F\\u200D(?:\\uD83D\\uDD25|\\uD83E\\uDE79)|\\uD83D\\uDC41\\uFE0F|\\uD83C\\uDFF3\\uFE0F|\\uD83C\\uDDFF(?:\\uD83C[\\uDDE6\\uDDF2\\uDDFC])|\\uD83C\\uDDFE(?:\\uD83C[\\uDDEA\\uDDF9])|\\uD83C\\uDDFC(?:\\uD83C[\\uDDEB\\uDDF8])|\\uD83C\\uDDFB(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDEE\\uDDF3\\uDDFA])|\\uD83C\\uDDFA(?:\\uD83C[\\uDDE6\\uDDEC\\uDDF2\\uDDF3\\uDDF8\\uDDFE\\uDDFF])|\\uD83C\\uDDF9(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDED\\uDDEF-\\uDDF4\\uDDF7\\uDDF9\\uDDFB\\uDDFC\\uDDFF])|\\uD83C\\uDDF8(?:\\uD83C[\\uDDE6-\\uDDEA\\uDDEC-\\uDDF4\\uDDF7-\\uDDF9\\uDDFB\\uDDFD-\\uDDFF])|\\uD83C\\uDDF7(?:\\uD83C[\\uDDEA\\uDDF4\\uDDF8\\uDDFA\\uDDFC])|\\uD83C\\uDDF5(?:\\uD83C[\\uDDE6\\uDDEA-\\uDDED\\uDDF0-\\uDDF3\\uDDF7-\\uDDF9\\uDDFC\\uDDFE])|\\uD83C\\uDDF3(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA-\\uDDEC\\uDDEE\\uDDF1\\uDDF4\\uDDF5\\uDDF7\\uDDFA\\uDDFF])|\\uD83C\\uDDF2(?:\\uD83C[\\uDDE6\\uDDE8-\\uDDED\\uDDF0-\\uDDFF])|\\uD83C\\uDDF1(?:\\uD83C[\\uDDE6-\\uDDE8\\uDDEE\\uDDF0\\uDDF7-\\uDDFB\\uDDFE])|\\uD83C\\uDDF0(?:\\uD83C[\\uDDEA\\uDDEC-\\uDDEE\\uDDF2\\uDDF3\\uDDF5\\uDDF7\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDEF(?:\\uD83C[\\uDDEA\\uDDF2\\uDDF4\\uDDF5])|\\uD83C\\uDDEE(?:\\uD83C[\\uDDE8-\\uDDEA\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9])|\\uD83C\\uDDED(?:\\uD83C[\\uDDF0\\uDDF2\\uDDF3\\uDDF7\\uDDF9\\uDDFA])|\\uD83C\\uDDEC(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEE\\uDDF1-\\uDDF3\\uDDF5-\\uDDFA\\uDDFC\\uDDFE])|\\uD83C\\uDDEB(?:\\uD83C[\\uDDEE-\\uDDF0\\uDDF2\\uDDF4\\uDDF7])|\\uD83C\\uDDEA(?:\\uD83C[\\uDDE6\\uDDE8\\uDDEA\\uDDEC\\uDDED\\uDDF7-\\uDDFA])|\\uD83C\\uDDE9(?:\\uD83C[\\uDDEA\\uDDEC\\uDDEF\\uDDF0\\uDDF2\\uDDF4\\uDDFF])|\\uD83C\\uDDE8(?:\\uD83C[\\uDDE6\\uDDE8\\uDDE9\\uDDEB-\\uDDEE\\uDDF0-\\uDDF5\\uDDF7\\uDDFA-\\uDDFF])|\\uD83C\\uDDE7(?:\\uD83C[\\uDDE6\\uDDE7\\uDDE9-\\uDDEF\\uDDF1-\\uDDF4\\uDDF6-\\uDDF9\\uDDFB\\uDDFC\\uDDFE\\uDDFF])|\\uD83C\\uDDE6(?:\\uD83C[\\uDDE8-\\uDDEC\\uDDEE\\uDDF1\\uDDF2\\uDDF4\\uDDF6-\\uDDFA\\uDDFC\\uDDFD\\uDDFF])|[#\\*0-9]\\uFE0F\\u20E3|\\u2764\\uFE0F|(?:\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:\\u26F9|\\uD83C[\\uDFCB\\uDFCC]|\\uD83D\\uDD75)(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|\\uD83C\\uDFF4|(?:[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5])(?:\\uD83C[\\uDFFB-\\uDFFF])|(?:[\\u261D\\u270C\\u270D]|\\uD83D[\\uDD74\\uDD90])(?:\\uFE0F|\\uD83C[\\uDFFB-\\uDFFF])|[\\u270A\\u270B]|\\uD83C[\\uDF85\\uDFC2\\uDFC7]|\\uD83D[\\uDC08\\uDC15\\uDC3B\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66\\uDC67\\uDC6B-\\uDC6D\\uDC72\\uDC74-\\uDC76\\uDC78\\uDC7C\\uDC83\\uDC85\\uDC8F\\uDC91\\uDCAA\\uDD7A\\uDD95\\uDD96\\uDE2E\\uDE35\\uDE36\\uDE4C\\uDE4F\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1C\\uDD1E\\uDD1F\\uDD30-\\uDD34\\uDD36\\uDD77\\uDDB5\\uDDB6\\uDDBB\\uDDD2\\uDDD3\\uDDD5]|\\uD83C[\\uDFC3\\uDFC4\\uDFCA]|\\uD83D[\\uDC6E\\uDC70\\uDC71\\uDC73\\uDC77\\uDC81\\uDC82\\uDC86\\uDC87\\uDE45-\\uDE47\\uDE4B\\uDE4D\\uDE4E\\uDEA3\\uDEB4-\\uDEB6]|\\uD83E[\\uDD26\\uDD35\\uDD37-\\uDD39\\uDD3D\\uDD3E\\uDDB8\\uDDB9\\uDDCD-\\uDDCF\\uDDD4\\uDDD6-\\uDDDD]|\\uD83D\\uDC6F|\\uD83E[\\uDD3C\\uDDDE\\uDDDF]|[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF84\\uDF86-\\uDF93\\uDFA0-\\uDFC1\\uDFC5\\uDFC6\\uDFC8\\uDFC9\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC07\\uDC09-\\uDC14\\uDC16-\\uDC3A\\uDC3C-\\uDC3E\\uDC40\\uDC44\\uDC45\\uDC51-\\uDC65\\uDC6A\\uDC79-\\uDC7B\\uDC7D-\\uDC80\\uDC84\\uDC88-\\uDC8E\\uDC90\\uDC92-\\uDCA9\\uDCAB-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDDA4\\uDDFB-\\uDE2D\\uDE2F-\\uDE34\\uDE37-\\uDE44\\uDE48-\\uDE4A\\uDE80-\\uDEA2\\uDEA4-\\uDEB3\\uDEB7-\\uDEBF\\uDEC1-\\uDEC5\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0D\\uDD0E\\uDD10-\\uDD17\\uDD1D\\uDD20-\\uDD25\\uDD27-\\uDD2F\\uDD3A\\uDD3F-\\uDD45\\uDD47-\\uDD76\\uDD78\\uDD7A-\\uDDB4\\uDDB7\\uDDBA\\uDDBC-\\uDDCB\\uDDD0\\uDDE0-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6]|(?:[\\u231A\\u231B\\u23E9-\\u23EC\\u23F0\\u23F3\\u25FD\\u25FE\\u2614\\u2615\\u2648-\\u2653\\u267F\\u2693\\u26A1\\u26AA\\u26AB\\u26BD\\u26BE\\u26C4\\u26C5\\u26CE\\u26D4\\u26EA\\u26F2\\u26F3\\u26F5\\u26FA\\u26FD\\u2705\\u270A\\u270B\\u2728\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2795-\\u2797\\u27B0\\u27BF\\u2B1B\\u2B1C\\u2B50\\u2B55]|\\uD83C[\\uDC04\\uDCCF\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE1A\\uDE2F\\uDE32-\\uDE36\\uDE38-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF20\\uDF2D-\\uDF35\\uDF37-\\uDF7C\\uDF7E-\\uDF93\\uDFA0-\\uDFCA\\uDFCF-\\uDFD3\\uDFE0-\\uDFF0\\uDFF4\\uDFF8-\\uDFFF]|\\uD83D[\\uDC00-\\uDC3E\\uDC40\\uDC42-\\uDCFC\\uDCFF-\\uDD3D\\uDD4B-\\uDD4E\\uDD50-\\uDD67\\uDD7A\\uDD95\\uDD96\\uDDA4\\uDDFB-\\uDE4F\\uDE80-\\uDEC5\\uDECC\\uDED0-\\uDED2\\uDED5-\\uDED7\\uDEEB\\uDEEC\\uDEF4-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])|(?:[#\\*0-9\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2604\\u260E\\u2611\\u2614\\u2615\\u2618\\u261D\\u2620\\u2622\\u2623\\u2626\\u262A\\u262E\\u262F\\u2638-\\u263A\\u2640\\u2642\\u2648-\\u2653\\u265F\\u2660\\u2663\\u2665\\u2666\\u2668\\u267B\\u267E\\u267F\\u2692-\\u2697\\u2699\\u269B\\u269C\\u26A0\\u26A1\\u26A7\\u26AA\\u26AB\\u26B0\\u26B1\\u26BD\\u26BE\\u26C4\\u26C5\\u26C8\\u26CE\\u26CF\\u26D1\\u26D3\\u26D4\\u26E9\\u26EA\\u26F0-\\u26F5\\u26F7-\\u26FA\\u26FD\\u2702\\u2705\\u2708-\\u270D\\u270F\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763\\u2764\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC04\\uDCCF\\uDD70\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDE6-\\uDDFF\\uDE01\\uDE02\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE50\\uDE51\\uDF00-\\uDF21\\uDF24-\\uDF93\\uDF96\\uDF97\\uDF99-\\uDF9B\\uDF9E-\\uDFF0\\uDFF3-\\uDFF5\\uDFF7-\\uDFFF]|\\uD83D[\\uDC00-\\uDCFD\\uDCFF-\\uDD3D\\uDD49-\\uDD4E\\uDD50-\\uDD67\\uDD6F\\uDD70\\uDD73-\\uDD7A\\uDD87\\uDD8A-\\uDD8D\\uDD90\\uDD95\\uDD96\\uDDA4\\uDDA5\\uDDA8\\uDDB1\\uDDB2\\uDDBC\\uDDC2-\\uDDC4\\uDDD1-\\uDDD3\\uDDDC-\\uDDDE\\uDDE1\\uDDE3\\uDDE8\\uDDEF\\uDDF3\\uDDFA-\\uDE4F\\uDE80-\\uDEC5\\uDECB-\\uDED2\\uDED5-\\uDED7\\uDEE0-\\uDEE5\\uDEE9\\uDEEB\\uDEEC\\uDEF0\\uDEF3-\\uDEFC\\uDFE0-\\uDFEB]|\\uD83E[\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDD78\\uDD7A-\\uDDCB\\uDDCD-\\uDDFF\\uDE70-\\uDE74\\uDE78-\\uDE7A\\uDE80-\\uDE86\\uDE90-\\uDEA8\\uDEB0-\\uDEB6\\uDEC0-\\uDEC2\\uDED0-\\uDED6])\\uFE0F|(?:[\\u261D\\u26F9\\u270A-\\u270D]|\\uD83C[\\uDF85\\uDFC2-\\uDFC4\\uDFC7\\uDFCA-\\uDFCC]|\\uD83D[\\uDC42\\uDC43\\uDC46-\\uDC50\\uDC66-\\uDC78\\uDC7C\\uDC81-\\uDC83\\uDC85-\\uDC87\\uDC8F\\uDC91\\uDCAA\\uDD74\\uDD75\\uDD7A\\uDD90\\uDD95\\uDD96\\uDE45-\\uDE47\\uDE4B-\\uDE4F\\uDEA3\\uDEB4-\\uDEB6\\uDEC0\\uDECC]|\\uD83E[\\uDD0C\\uDD0F\\uDD18-\\uDD1F\\uDD26\\uDD30-\\uDD39\\uDD3C-\\uDD3E\\uDD77\\uDDB5\\uDDB6\\uDDB8\\uDDB9\\uDDBB\\uDDCD-\\uDDCF\\uDDD1-\\uDDDD])/g;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/string-width/index.js",
                "var string_width_exports = {};",
                "__export(string_width_exports, {",
                "  default: () => stringWidth",
                "});",
                "module.exports = __toCommonJS(string_width_exports);",
                "",
                "// node_modules/strip-ansi/node_modules/ansi-regex/index.js",
                "function ansiRegex({ onlyFirst = false } = {}) {",
                "  const pattern = [",
                "    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",",
                "    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"",
                "  ].join(\"|\");",
                "  return new RegExp(pattern, onlyFirst ? void 0 : \"g\");",
                "}",
                "",
                "// node_modules/strip-ansi/index.js",
                "function stripAnsi(string) {",
                "  if (typeof string !== \"string\") {",
                "    throw new TypeError(`Expected a \\`string\\`, got \\`${typeof string}\\``);",
                "  }",
                "  return string.replace(ansiRegex(), \"\");",
                "}",
                "",
                "// node_modules/is-fullwidth-code-point/index.js",
                "function isFullwidthCodePoint(codePoint) {",
                "  if (!Number.isInteger(codePoint)) {",
                "    return false;",
                "  }",
                "  return codePoint >= 4352 && (codePoint <= 4447 || codePoint === 9001 || codePoint === 9002 || 11904 <= codePoint && codePoint <= 12871 && codePoint !== 12351 || 12880 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65131 || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 262141);",
                "}",
                "",
                "// node_modules/string-width/index.js",
                "var import_emoji_regex = __toESM(require_emoji_regex(), 1);",
                "function stringWidth(string) {",
                "  if (typeof string !== \"string\" || string.length === 0) {",
                "    return 0;",
                "  }",
                "  string = stripAnsi(string);",
                "  if (string.length === 0) {",
                "    return 0;",
                "  }",
                "  string = string.replace((0, import_emoji_regex.default)(), \"  \");",
                "  let width = 0;",
                "  for (let index = 0; index < string.length; index++) {",
                "    const codePoint = string.codePointAt(index);",
                "    if (codePoint <= 31 || codePoint >= 127 && codePoint <= 159) {",
                "      continue;",
                "    }",
                "    if (codePoint >= 768 && codePoint <= 879) {",
                "      continue;",
                "    }",
                "    if (codePoint > 65535) {",
                "      index++;",
                "    }",
                "    width += isFullwidthCodePoint(codePoint) ? 2 : 1;",
                "  }",
                "  return width;",
                "}",
                "// Annotate the CommonJS export names for ESM import in node:",
                "0 && (module.exports = {});"
            ]
        },
        "strip-ansi.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// This file is generated automatically.",
                "export {default} from \"strip-ansi\";",
                "export * from \"strip-ansi\";"
            ]
        },
        "strip-ansi.js": {
            "classes": [],
            "functions": [],
            "text": [
                "// @ts-nocheck",
                "// This file is generated automatically",
                "var __defProp = Object.defineProperty;",
                "var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
                "var __getOwnPropNames = Object.getOwnPropertyNames;",
                "var __hasOwnProp = Object.prototype.hasOwnProperty;",
                "var __export = (target, all) => {",
                "  for (var name in all)",
                "    __defProp(target, name, { get: all[name], enumerable: true });",
                "};",
                "var __copyProps = (to, from, except, desc) => {",
                "  if (from && typeof from === \"object\" || typeof from === \"function\") {",
                "    for (let key of __getOwnPropNames(from))",
                "      if (!__hasOwnProp.call(to, key) && key !== except)",
                "        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
                "  }",
                "  return to;",
                "};",
                "var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);",
                "",
                "// node_modules/strip-ansi/index.js",
                "var strip_ansi_exports = {};",
                "__export(strip_ansi_exports, {",
                "  default: () => stripAnsi",
                "});",
                "module.exports = __toCommonJS(strip_ansi_exports);",
                "",
                "// node_modules/strip-ansi/node_modules/ansi-regex/index.js",
                "function ansiRegex({ onlyFirst = false } = {}) {",
                "  const pattern = [",
                "    \"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)\",",
                "    \"(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\"",
                "  ].join(\"|\");",
                "  return new RegExp(pattern, onlyFirst ? void 0 : \"g\");",
                "}",
                "",
                "// node_modules/strip-ansi/index.js",
                "function stripAnsi(string) {",
                "  if (typeof string !== \"string\") {",
                "    throw new TypeError(`Expected a \\`string\\`, got \\`${typeof string}\\``);",
                "  }",
                "  return string.replace(ansiRegex(), \"\");",
                "}",
                "// Annotate the CommonJS export names for ESM import in node:",
                "0 && (module.exports = {});"
            ]
        },
        "tempy.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// This file is generated automatically.",
                "export {default} from \"tempy\";",
                "export * from \"tempy\";"
            ]
        },
        "tempy.js": {
            "classes": [],
            "functions": [],
            "text": [
                "// @ts-nocheck",
                "// This file is generated automatically",
                "var __create = Object.create;",
                "var __defProp = Object.defineProperty;",
                "var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
                "var __getOwnPropNames = Object.getOwnPropertyNames;",
                "var __getProtoOf = Object.getPrototypeOf;",
                "var __hasOwnProp = Object.prototype.hasOwnProperty;",
                "var __commonJS = (cb, mod) => function __require() {",
                "  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;",
                "};",
                "var __export = (target, all) => {",
                "  for (var name in all)",
                "    __defProp(target, name, { get: all[name], enumerable: true });",
                "};",
                "var __copyProps = (to, from, except, desc) => {",
                "  if (from && typeof from === \"object\" || typeof from === \"function\") {",
                "    for (let key of __getOwnPropNames(from))",
                "      if (!__hasOwnProp.call(to, key) && key !== except)",
                "        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
                "  }",
                "  return to;",
                "};",
                "var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(",
                "  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,",
                "  mod",
                "));",
                "var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);",
                "",
                "// node_modules/temp-dir/index.js",
                "var require_temp_dir = __commonJS({",
                "  \"node_modules/temp-dir/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var fs2 = require(\"fs\");",
                "    var os = require(\"os\");",
                "    var tempDirectorySymbol = Symbol.for(\"__RESOLVED_TEMP_DIRECTORY__\");",
                "    if (!global[tempDirectorySymbol]) {",
                "      Object.defineProperty(global, tempDirectorySymbol, {",
                "        value: fs2.realpathSync(os.tmpdir())",
                "      });",
                "    }",
                "    module2.exports = global[tempDirectorySymbol];",
                "  }",
                "});",
                "",
                "// node_modules/array-union/index.js",
                "var require_array_union = __commonJS({",
                "  \"node_modules/array-union/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = (...arguments_) => {",
                "      return [...new Set([].concat(...arguments_))];",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/merge2/index.js",
                "var require_merge2 = __commonJS({",
                "  \"node_modules/merge2/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var Stream = require(\"stream\");",
                "    var PassThrough = Stream.PassThrough;",
                "    var slice = Array.prototype.slice;",
                "    module2.exports = merge2;",
                "    function merge2() {",
                "      const streamsQueue = [];",
                "      const args = slice.call(arguments);",
                "      let merging = false;",
                "      let options = args[args.length - 1];",
                "      if (options && !Array.isArray(options) && options.pipe == null) {",
                "        args.pop();",
                "      } else {",
                "        options = {};",
                "      }",
                "      const doEnd = options.end !== false;",
                "      const doPipeError = options.pipeError === true;",
                "      if (options.objectMode == null) {",
                "        options.objectMode = true;",
                "      }",
                "      if (options.highWaterMark == null) {",
                "        options.highWaterMark = 64 * 1024;",
                "      }",
                "      const mergedStream = PassThrough(options);",
                "      function addStream() {",
                "        for (let i = 0, len = arguments.length; i < len; i++) {",
                "          streamsQueue.push(pauseStreams(arguments[i], options));",
                "        }",
                "        mergeStream();",
                "        return this;",
                "      }",
                "      function mergeStream() {",
                "        if (merging) {",
                "          return;",
                "        }",
                "        merging = true;",
                "        let streams = streamsQueue.shift();",
                "        if (!streams) {",
                "          process.nextTick(endStream);",
                "          return;",
                "        }",
                "        if (!Array.isArray(streams)) {",
                "          streams = [streams];",
                "        }",
                "        let pipesCount = streams.length + 1;",
                "        function next() {",
                "          if (--pipesCount > 0) {",
                "            return;",
                "          }",
                "          merging = false;",
                "          mergeStream();",
                "        }",
                "        function pipe(stream2) {",
                "          function onend() {",
                "            stream2.removeListener(\"merge2UnpipeEnd\", onend);",
                "            stream2.removeListener(\"end\", onend);",
                "            if (doPipeError) {",
                "              stream2.removeListener(\"error\", onerror);",
                "            }",
                "            next();",
                "          }",
                "          function onerror(err) {",
                "            mergedStream.emit(\"error\", err);",
                "          }",
                "          if (stream2._readableState.endEmitted) {",
                "            return next();",
                "          }",
                "          stream2.on(\"merge2UnpipeEnd\", onend);",
                "          stream2.on(\"end\", onend);",
                "          if (doPipeError) {",
                "            stream2.on(\"error\", onerror);",
                "          }",
                "          stream2.pipe(mergedStream, { end: false });",
                "          stream2.resume();",
                "        }",
                "        for (let i = 0; i < streams.length; i++) {",
                "          pipe(streams[i]);",
                "        }",
                "        next();",
                "      }",
                "      function endStream() {",
                "        merging = false;",
                "        mergedStream.emit(\"queueDrain\");",
                "        if (doEnd) {",
                "          mergedStream.end();",
                "        }",
                "      }",
                "      mergedStream.setMaxListeners(0);",
                "      mergedStream.add = addStream;",
                "      mergedStream.on(\"unpipe\", function(stream2) {",
                "        stream2.emit(\"merge2UnpipeEnd\");",
                "      });",
                "      if (args.length) {",
                "        addStream.apply(null, args);",
                "      }",
                "      return mergedStream;",
                "    }",
                "    function pauseStreams(streams, options) {",
                "      if (!Array.isArray(streams)) {",
                "        if (!streams._readableState && streams.pipe) {",
                "          streams = streams.pipe(PassThrough(options));",
                "        }",
                "        if (!streams._readableState || !streams.pause || !streams.pipe) {",
                "          throw new Error(\"Only readable stream can be merged.\");",
                "        }",
                "        streams.pause();",
                "      } else {",
                "        for (let i = 0, len = streams.length; i < len; i++) {",
                "          streams[i] = pauseStreams(streams[i], options);",
                "        }",
                "      }",
                "      return streams;",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/utils/array.js",
                "var require_array = __commonJS({",
                "  \"node_modules/fast-glob/out/utils/array.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.splitWhen = exports.flatten = void 0;",
                "    function flatten(items) {",
                "      return items.reduce((collection, item) => [].concat(collection, item), []);",
                "    }",
                "    exports.flatten = flatten;",
                "    function splitWhen(items, predicate) {",
                "      const result = [[]];",
                "      let groupIndex = 0;",
                "      for (const item of items) {",
                "        if (predicate(item)) {",
                "          groupIndex++;",
                "          result[groupIndex] = [];",
                "        } else {",
                "          result[groupIndex].push(item);",
                "        }",
                "      }",
                "      return result;",
                "    }",
                "    exports.splitWhen = splitWhen;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/utils/errno.js",
                "var require_errno = __commonJS({",
                "  \"node_modules/fast-glob/out/utils/errno.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.isEnoentCodeError = void 0;",
                "    function isEnoentCodeError(error) {",
                "      return error.code === \"ENOENT\";",
                "    }",
                "    exports.isEnoentCodeError = isEnoentCodeError;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/utils/fs.js",
                "var require_fs = __commonJS({",
                "  \"node_modules/fast-glob/out/utils/fs.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.createDirentFromStats = void 0;",
                "    var DirentFromStats = class {",
                "      constructor(name, stats) {",
                "        this.name = name;",
                "        this.isBlockDevice = stats.isBlockDevice.bind(stats);",
                "        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);",
                "        this.isDirectory = stats.isDirectory.bind(stats);",
                "        this.isFIFO = stats.isFIFO.bind(stats);",
                "        this.isFile = stats.isFile.bind(stats);",
                "        this.isSocket = stats.isSocket.bind(stats);",
                "        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);",
                "      }",
                "    };",
                "    function createDirentFromStats(name, stats) {",
                "      return new DirentFromStats(name, stats);",
                "    }",
                "    exports.createDirentFromStats = createDirentFromStats;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/utils/path.js",
                "var require_path = __commonJS({",
                "  \"node_modules/fast-glob/out/utils/path.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.removeLeadingDotSegment = exports.escape = exports.makeAbsolute = exports.unixify = void 0;",
                "    var path2 = require(\"path\");",
                "    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;",
                "    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\\\?)([()*?[\\]{|}]|^!|[!+@](?=\\())/g;",
                "    function unixify(filepath) {",
                "      return filepath.replace(/\\\\/g, \"/\");",
                "    }",
                "    exports.unixify = unixify;",
                "    function makeAbsolute(cwd, filepath) {",
                "      return path2.resolve(cwd, filepath);",
                "    }",
                "    exports.makeAbsolute = makeAbsolute;",
                "    function escape(pattern) {",
                "      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, \"\\\\$2\");",
                "    }",
                "    exports.escape = escape;",
                "    function removeLeadingDotSegment(entry) {",
                "      if (entry.charAt(0) === \".\") {",
                "        const secondCharactery = entry.charAt(1);",
                "        if (secondCharactery === \"/\" || secondCharactery === \"\\\\\") {",
                "          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);",
                "        }",
                "      }",
                "      return entry;",
                "    }",
                "    exports.removeLeadingDotSegment = removeLeadingDotSegment;",
                "  }",
                "});",
                "",
                "// node_modules/is-extglob/index.js",
                "var require_is_extglob = __commonJS({",
                "  \"node_modules/is-extglob/index.js\"(exports, module2) {",
                "    module2.exports = function isExtglob(str) {",
                "      if (typeof str !== \"string\" || str === \"\") {",
                "        return false;",
                "      }",
                "      var match;",
                "      while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {",
                "        if (match[2])",
                "          return true;",
                "        str = str.slice(match.index + match[0].length);",
                "      }",
                "      return false;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/is-glob/index.js",
                "var require_is_glob = __commonJS({",
                "  \"node_modules/is-glob/index.js\"(exports, module2) {",
                "    var isExtglob = require_is_extglob();",
                "    var chars = { \"{\": \"}\", \"(\": \")\", \"[\": \"]\" };",
                "    var strictCheck = function(str) {",
                "      if (str[0] === \"!\") {",
                "        return true;",
                "      }",
                "      var index = 0;",
                "      var pipeIndex = -2;",
                "      var closeSquareIndex = -2;",
                "      var closeCurlyIndex = -2;",
                "      var closeParenIndex = -2;",
                "      var backSlashIndex = -2;",
                "      while (index < str.length) {",
                "        if (str[index] === \"*\") {",
                "          return true;",
                "        }",
                "        if (str[index + 1] === \"?\" && /[\\].+)]/.test(str[index])) {",
                "          return true;",
                "        }",
                "        if (closeSquareIndex !== -1 && str[index] === \"[\" && str[index + 1] !== \"]\") {",
                "          if (closeSquareIndex < index) {",
                "            closeSquareIndex = str.indexOf(\"]\", index);",
                "          }",
                "          if (closeSquareIndex > index) {",
                "            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {",
                "              return true;",
                "            }",
                "            backSlashIndex = str.indexOf(\"\\\\\", index);",
                "            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {",
                "              return true;",
                "            }",
                "          }",
                "        }",
                "        if (closeCurlyIndex !== -1 && str[index] === \"{\" && str[index + 1] !== \"}\") {",
                "          closeCurlyIndex = str.indexOf(\"}\", index);",
                "          if (closeCurlyIndex > index) {",
                "            backSlashIndex = str.indexOf(\"\\\\\", index);",
                "            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {",
                "              return true;",
                "            }",
                "          }",
                "        }",
                "        if (closeParenIndex !== -1 && str[index] === \"(\" && str[index + 1] === \"?\" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== \")\") {",
                "          closeParenIndex = str.indexOf(\")\", index);",
                "          if (closeParenIndex > index) {",
                "            backSlashIndex = str.indexOf(\"\\\\\", index);",
                "            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {",
                "              return true;",
                "            }",
                "          }",
                "        }",
                "        if (pipeIndex !== -1 && str[index] === \"(\" && str[index + 1] !== \"|\") {",
                "          if (pipeIndex < index) {",
                "            pipeIndex = str.indexOf(\"|\", index);",
                "          }",
                "          if (pipeIndex !== -1 && str[pipeIndex + 1] !== \")\") {",
                "            closeParenIndex = str.indexOf(\")\", pipeIndex);",
                "            if (closeParenIndex > pipeIndex) {",
                "              backSlashIndex = str.indexOf(\"\\\\\", pipeIndex);",
                "              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {",
                "                return true;",
                "              }",
                "            }",
                "          }",
                "        }",
                "        if (str[index] === \"\\\\\") {",
                "          var open = str[index + 1];",
                "          index += 2;",
                "          var close = chars[open];",
                "          if (close) {",
                "            var n = str.indexOf(close, index);",
                "            if (n !== -1) {",
                "              index = n + 1;",
                "            }",
                "          }",
                "          if (str[index] === \"!\") {",
                "            return true;",
                "          }",
                "        } else {",
                "          index++;",
                "        }",
                "      }",
                "      return false;",
                "    };",
                "    var relaxedCheck = function(str) {",
                "      if (str[0] === \"!\") {",
                "        return true;",
                "      }",
                "      var index = 0;",
                "      while (index < str.length) {",
                "        if (/[*?{}()[\\]]/.test(str[index])) {",
                "          return true;",
                "        }",
                "        if (str[index] === \"\\\\\") {",
                "          var open = str[index + 1];",
                "          index += 2;",
                "          var close = chars[open];",
                "          if (close) {",
                "            var n = str.indexOf(close, index);",
                "            if (n !== -1) {",
                "              index = n + 1;",
                "            }",
                "          }",
                "          if (str[index] === \"!\") {",
                "            return true;",
                "          }",
                "        } else {",
                "          index++;",
                "        }",
                "      }",
                "      return false;",
                "    };",
                "    module2.exports = function isGlob(str, options) {",
                "      if (typeof str !== \"string\" || str === \"\") {",
                "        return false;",
                "      }",
                "      if (isExtglob(str)) {",
                "        return true;",
                "      }",
                "      var check = strictCheck;",
                "      if (options && options.strict === false) {",
                "        check = relaxedCheck;",
                "      }",
                "      return check(str);",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/glob-parent/index.js",
                "var require_glob_parent = __commonJS({",
                "  \"node_modules/glob-parent/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var isGlob = require_is_glob();",
                "    var pathPosixDirname = require(\"path\").posix.dirname;",
                "    var isWin32 = require(\"os\").platform() === \"win32\";",
                "    var slash = \"/\";",
                "    var backslash = /\\\\/g;",
                "    var enclosure = /[\\{\\[].*[\\}\\]]$/;",
                "    var globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;",
                "    var escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;",
                "    module2.exports = function globParent(str, opts) {",
                "      var options = Object.assign({ flipBackslashes: true }, opts);",
                "      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {",
                "        str = str.replace(backslash, slash);",
                "      }",
                "      if (enclosure.test(str)) {",
                "        str += slash;",
                "      }",
                "      str += \"a\";",
                "      do {",
                "        str = pathPosixDirname(str);",
                "      } while (isGlob(str) || globby.test(str));",
                "      return str.replace(escaped, \"$1\");",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/braces/lib/utils.js",
                "var require_utils = __commonJS({",
                "  \"node_modules/braces/lib/utils.js\"(exports) {",
                "    \"use strict\";",
                "    exports.isInteger = (num) => {",
                "      if (typeof num === \"number\") {",
                "        return Number.isInteger(num);",
                "      }",
                "      if (typeof num === \"string\" && num.trim() !== \"\") {",
                "        return Number.isInteger(Number(num));",
                "      }",
                "      return false;",
                "    };",
                "    exports.find = (node, type) => node.nodes.find((node2) => node2.type === type);",
                "    exports.exceedsLimit = (min, max, step = 1, limit) => {",
                "      if (limit === false)",
                "        return false;",
                "      if (!exports.isInteger(min) || !exports.isInteger(max))",
                "        return false;",
                "      return (Number(max) - Number(min)) / Number(step) >= limit;",
                "    };",
                "    exports.escapeNode = (block, n = 0, type) => {",
                "      let node = block.nodes[n];",
                "      if (!node)",
                "        return;",
                "      if (type && node.type === type || node.type === \"open\" || node.type === \"close\") {",
                "        if (node.escaped !== true) {",
                "          node.value = \"\\\\\" + node.value;",
                "          node.escaped = true;",
                "        }",
                "      }",
                "    };",
                "    exports.encloseBrace = (node) => {",
                "      if (node.type !== \"brace\")",
                "        return false;",
                "      if (node.commas >> 0 + node.ranges >> 0 === 0) {",
                "        node.invalid = true;",
                "        return true;",
                "      }",
                "      return false;",
                "    };",
                "    exports.isInvalidBrace = (block) => {",
                "      if (block.type !== \"brace\")",
                "        return false;",
                "      if (block.invalid === true || block.dollar)",
                "        return true;",
                "      if (block.commas >> 0 + block.ranges >> 0 === 0) {",
                "        block.invalid = true;",
                "        return true;",
                "      }",
                "      if (block.open !== true || block.close !== true) {",
                "        block.invalid = true;",
                "        return true;",
                "      }",
                "      return false;",
                "    };",
                "    exports.isOpenOrClose = (node) => {",
                "      if (node.type === \"open\" || node.type === \"close\") {",
                "        return true;",
                "      }",
                "      return node.open === true || node.close === true;",
                "    };",
                "    exports.reduce = (nodes) => nodes.reduce((acc, node) => {",
                "      if (node.type === \"text\")",
                "        acc.push(node.value);",
                "      if (node.type === \"range\")",
                "        node.type = \"text\";",
                "      return acc;",
                "    }, []);",
                "    exports.flatten = (...args) => {",
                "      const result = [];",
                "      const flat = (arr) => {",
                "        for (let i = 0; i < arr.length; i++) {",
                "          let ele = arr[i];",
                "          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);",
                "        }",
                "        return result;",
                "      };",
                "      flat(args);",
                "      return result;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/braces/lib/stringify.js",
                "var require_stringify = __commonJS({",
                "  \"node_modules/braces/lib/stringify.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var utils = require_utils();",
                "    module2.exports = (ast, options = {}) => {",
                "      let stringify = (node, parent = {}) => {",
                "        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);",
                "        let invalidNode = node.invalid === true && options.escapeInvalid === true;",
                "        let output = \"\";",
                "        if (node.value) {",
                "          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {",
                "            return \"\\\\\" + node.value;",
                "          }",
                "          return node.value;",
                "        }",
                "        if (node.value) {",
                "          return node.value;",
                "        }",
                "        if (node.nodes) {",
                "          for (let child of node.nodes) {",
                "            output += stringify(child);",
                "          }",
                "        }",
                "        return output;",
                "      };",
                "      return stringify(ast);",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/is-number/index.js",
                "var require_is_number = __commonJS({",
                "  \"node_modules/is-number/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = function(num) {",
                "      if (typeof num === \"number\") {",
                "        return num - num === 0;",
                "      }",
                "      if (typeof num === \"string\" && num.trim() !== \"\") {",
                "        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);",
                "      }",
                "      return false;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/to-regex-range/index.js",
                "var require_to_regex_range = __commonJS({",
                "  \"node_modules/to-regex-range/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var isNumber = require_is_number();",
                "    var toRegexRange = (min, max, options) => {",
                "      if (isNumber(min) === false) {",
                "        throw new TypeError(\"toRegexRange: expected the first argument to be a number\");",
                "      }",
                "      if (max === void 0 || min === max) {",
                "        return String(min);",
                "      }",
                "      if (isNumber(max) === false) {",
                "        throw new TypeError(\"toRegexRange: expected the second argument to be a number.\");",
                "      }",
                "      let opts = { relaxZeros: true, ...options };",
                "      if (typeof opts.strictZeros === \"boolean\") {",
                "        opts.relaxZeros = opts.strictZeros === false;",
                "      }",
                "      let relax = String(opts.relaxZeros);",
                "      let shorthand = String(opts.shorthand);",
                "      let capture = String(opts.capture);",
                "      let wrap = String(opts.wrap);",
                "      let cacheKey = min + \":\" + max + \"=\" + relax + shorthand + capture + wrap;",
                "      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {",
                "        return toRegexRange.cache[cacheKey].result;",
                "      }",
                "      let a = Math.min(min, max);",
                "      let b = Math.max(min, max);",
                "      if (Math.abs(a - b) === 1) {",
                "        let result = min + \"|\" + max;",
                "        if (opts.capture) {",
                "          return `(${result})`;",
                "        }",
                "        if (opts.wrap === false) {",
                "          return result;",
                "        }",
                "        return `(?:${result})`;",
                "      }",
                "      let isPadded = hasPadding(min) || hasPadding(max);",
                "      let state = { min, max, a, b };",
                "      let positives = [];",
                "      let negatives = [];",
                "      if (isPadded) {",
                "        state.isPadded = isPadded;",
                "        state.maxLen = String(state.max).length;",
                "      }",
                "      if (a < 0) {",
                "        let newMin = b < 0 ? Math.abs(b) : 1;",
                "        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);",
                "        a = state.a = 0;",
                "      }",
                "      if (b >= 0) {",
                "        positives = splitToPatterns(a, b, state, opts);",
                "      }",
                "      state.negatives = negatives;",
                "      state.positives = positives;",
                "      state.result = collatePatterns(negatives, positives, opts);",
                "      if (opts.capture === true) {",
                "        state.result = `(${state.result})`;",
                "      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {",
                "        state.result = `(?:${state.result})`;",
                "      }",
                "      toRegexRange.cache[cacheKey] = state;",
                "      return state.result;",
                "    };",
                "    function collatePatterns(neg, pos, options) {",
                "      let onlyNegative = filterPatterns(neg, pos, \"-\", false, options) || [];",
                "      let onlyPositive = filterPatterns(pos, neg, \"\", false, options) || [];",
                "      let intersected = filterPatterns(neg, pos, \"-?\", true, options) || [];",
                "      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);",
                "      return subpatterns.join(\"|\");",
                "    }",
                "    function splitToRanges(min, max) {",
                "      let nines = 1;",
                "      let zeros = 1;",
                "      let stop = countNines(min, nines);",
                "      let stops = /* @__PURE__ */ new Set([max]);",
                "      while (min <= stop && stop <= max) {",
                "        stops.add(stop);",
                "        nines += 1;",
                "        stop = countNines(min, nines);",
                "      }",
                "      stop = countZeros(max + 1, zeros) - 1;",
                "      while (min < stop && stop <= max) {",
                "        stops.add(stop);",
                "        zeros += 1;",
                "        stop = countZeros(max + 1, zeros) - 1;",
                "      }",
                "      stops = [...stops];",
                "      stops.sort(compare);",
                "      return stops;",
                "    }",
                "    function rangeToPattern(start, stop, options) {",
                "      if (start === stop) {",
                "        return { pattern: start, count: [], digits: 0 };",
                "      }",
                "      let zipped = zip(start, stop);",
                "      let digits = zipped.length;",
                "      let pattern = \"\";",
                "      let count = 0;",
                "      for (let i = 0; i < digits; i++) {",
                "        let [startDigit, stopDigit] = zipped[i];",
                "        if (startDigit === stopDigit) {",
                "          pattern += startDigit;",
                "        } else if (startDigit !== \"0\" || stopDigit !== \"9\") {",
                "          pattern += toCharacterClass(startDigit, stopDigit, options);",
                "        } else {",
                "          count++;",
                "        }",
                "      }",
                "      if (count) {",
                "        pattern += options.shorthand === true ? \"\\\\d\" : \"[0-9]\";",
                "      }",
                "      return { pattern, count: [count], digits };",
                "    }",
                "    function splitToPatterns(min, max, tok, options) {",
                "      let ranges = splitToRanges(min, max);",
                "      let tokens = [];",
                "      let start = min;",
                "      let prev;",
                "      for (let i = 0; i < ranges.length; i++) {",
                "        let max2 = ranges[i];",
                "        let obj = rangeToPattern(String(start), String(max2), options);",
                "        let zeros = \"\";",
                "        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {",
                "          if (prev.count.length > 1) {",
                "            prev.count.pop();",
                "          }",
                "          prev.count.push(obj.count[0]);",
                "          prev.string = prev.pattern + toQuantifier(prev.count);",
                "          start = max2 + 1;",
                "          continue;",
                "        }",
                "        if (tok.isPadded) {",
                "          zeros = padZeros(max2, tok, options);",
                "        }",
                "        obj.string = zeros + obj.pattern + toQuantifier(obj.count);",
                "        tokens.push(obj);",
                "        start = max2 + 1;",
                "        prev = obj;",
                "      }",
                "      return tokens;",
                "    }",
                "    function filterPatterns(arr, comparison, prefix, intersection, options) {",
                "      let result = [];",
                "      for (let ele of arr) {",
                "        let { string } = ele;",
                "        if (!intersection && !contains(comparison, \"string\", string)) {",
                "          result.push(prefix + string);",
                "        }",
                "        if (intersection && contains(comparison, \"string\", string)) {",
                "          result.push(prefix + string);",
                "        }",
                "      }",
                "      return result;",
                "    }",
                "    function zip(a, b) {",
                "      let arr = [];",
                "      for (let i = 0; i < a.length; i++)",
                "        arr.push([a[i], b[i]]);",
                "      return arr;",
                "    }",
                "    function compare(a, b) {",
                "      return a > b ? 1 : b > a ? -1 : 0;",
                "    }",
                "    function contains(arr, key, val) {",
                "      return arr.some((ele) => ele[key] === val);",
                "    }",
                "    function countNines(min, len) {",
                "      return Number(String(min).slice(0, -len) + \"9\".repeat(len));",
                "    }",
                "    function countZeros(integer, zeros) {",
                "      return integer - integer % Math.pow(10, zeros);",
                "    }",
                "    function toQuantifier(digits) {",
                "      let [start = 0, stop = \"\"] = digits;",
                "      if (stop || start > 1) {",
                "        return `{${start + (stop ? \",\" + stop : \"\")}}`;",
                "      }",
                "      return \"\";",
                "    }",
                "    function toCharacterClass(a, b, options) {",
                "      return `[${a}${b - a === 1 ? \"\" : \"-\"}${b}]`;",
                "    }",
                "    function hasPadding(str) {",
                "      return /^-?(0+)\\d/.test(str);",
                "    }",
                "    function padZeros(value, tok, options) {",
                "      if (!tok.isPadded) {",
                "        return value;",
                "      }",
                "      let diff = Math.abs(tok.maxLen - String(value).length);",
                "      let relax = options.relaxZeros !== false;",
                "      switch (diff) {",
                "        case 0:",
                "          return \"\";",
                "        case 1:",
                "          return relax ? \"0?\" : \"0\";",
                "        case 2:",
                "          return relax ? \"0{0,2}\" : \"00\";",
                "        default: {",
                "          return relax ? `0{0,${diff}}` : `0{${diff}}`;",
                "        }",
                "      }",
                "    }",
                "    toRegexRange.cache = {};",
                "    toRegexRange.clearCache = () => toRegexRange.cache = {};",
                "    module2.exports = toRegexRange;",
                "  }",
                "});",
                "",
                "// node_modules/fill-range/index.js",
                "var require_fill_range = __commonJS({",
                "  \"node_modules/fill-range/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var util = require(\"util\");",
                "    var toRegexRange = require_to_regex_range();",
                "    var isObject = (val) => val !== null && typeof val === \"object\" && !Array.isArray(val);",
                "    var transform = (toNumber) => {",
                "      return (value) => toNumber === true ? Number(value) : String(value);",
                "    };",
                "    var isValidValue = (value) => {",
                "      return typeof value === \"number\" || typeof value === \"string\" && value !== \"\";",
                "    };",
                "    var isNumber = (num) => Number.isInteger(+num);",
                "    var zeros = (input) => {",
                "      let value = `${input}`;",
                "      let index = -1;",
                "      if (value[0] === \"-\")",
                "        value = value.slice(1);",
                "      if (value === \"0\")",
                "        return false;",
                "      while (value[++index] === \"0\")",
                "        ;",
                "      return index > 0;",
                "    };",
                "    var stringify = (start, end, options) => {",
                "      if (typeof start === \"string\" || typeof end === \"string\") {",
                "        return true;",
                "      }",
                "      return options.stringify === true;",
                "    };",
                "    var pad = (input, maxLength, toNumber) => {",
                "      if (maxLength > 0) {",
                "        let dash = input[0] === \"-\" ? \"-\" : \"\";",
                "        if (dash)",
                "          input = input.slice(1);",
                "        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, \"0\");",
                "      }",
                "      if (toNumber === false) {",
                "        return String(input);",
                "      }",
                "      return input;",
                "    };",
                "    var toMaxLen = (input, maxLength) => {",
                "      let negative = input[0] === \"-\" ? \"-\" : \"\";",
                "      if (negative) {",
                "        input = input.slice(1);",
                "        maxLength--;",
                "      }",
                "      while (input.length < maxLength)",
                "        input = \"0\" + input;",
                "      return negative ? \"-\" + input : input;",
                "    };",
                "    var toSequence = (parts, options) => {",
                "      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);",
                "      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);",
                "      let prefix = options.capture ? \"\" : \"?:\";",
                "      let positives = \"\";",
                "      let negatives = \"\";",
                "      let result;",
                "      if (parts.positives.length) {",
                "        positives = parts.positives.join(\"|\");",
                "      }",
                "      if (parts.negatives.length) {",
                "        negatives = `-(${prefix}${parts.negatives.join(\"|\")})`;",
                "      }",
                "      if (positives && negatives) {",
                "        result = `${positives}|${negatives}`;",
                "      } else {",
                "        result = positives || negatives;",
                "      }",
                "      if (options.wrap) {",
                "        return `(${prefix}${result})`;",
                "      }",
                "      return result;",
                "    };",
                "    var toRange = (a, b, isNumbers, options) => {",
                "      if (isNumbers) {",
                "        return toRegexRange(a, b, { wrap: false, ...options });",
                "      }",
                "      let start = String.fromCharCode(a);",
                "      if (a === b)",
                "        return start;",
                "      let stop = String.fromCharCode(b);",
                "      return `[${start}-${stop}]`;",
                "    };",
                "    var toRegex = (start, end, options) => {",
                "      if (Array.isArray(start)) {",
                "        let wrap = options.wrap === true;",
                "        let prefix = options.capture ? \"\" : \"?:\";",
                "        return wrap ? `(${prefix}${start.join(\"|\")})` : start.join(\"|\");",
                "      }",
                "      return toRegexRange(start, end, options);",
                "    };",
                "    var rangeError = (...args) => {",
                "      return new RangeError(\"Invalid range arguments: \" + util.inspect(...args));",
                "    };",
                "    var invalidRange = (start, end, options) => {",
                "      if (options.strictRanges === true)",
                "        throw rangeError([start, end]);",
                "      return [];",
                "    };",
                "    var invalidStep = (step, options) => {",
                "      if (options.strictRanges === true) {",
                "        throw new TypeError(`Expected step \"${step}\" to be a number`);",
                "      }",
                "      return [];",
                "    };",
                "    var fillNumbers = (start, end, step = 1, options = {}) => {",
                "      let a = Number(start);",
                "      let b = Number(end);",
                "      if (!Number.isInteger(a) || !Number.isInteger(b)) {",
                "        if (options.strictRanges === true)",
                "          throw rangeError([start, end]);",
                "        return [];",
                "      }",
                "      if (a === 0)",
                "        a = 0;",
                "      if (b === 0)",
                "        b = 0;",
                "      let descending = a > b;",
                "      let startString = String(start);",
                "      let endString = String(end);",
                "      let stepString = String(step);",
                "      step = Math.max(Math.abs(step), 1);",
                "      let padded = zeros(startString) || zeros(endString) || zeros(stepString);",
                "      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;",
                "      let toNumber = padded === false && stringify(start, end, options) === false;",
                "      let format = options.transform || transform(toNumber);",
                "      if (options.toRegex && step === 1) {",
                "        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);",
                "      }",
                "      let parts = { negatives: [], positives: [] };",
                "      let push = (num) => parts[num < 0 ? \"negatives\" : \"positives\"].push(Math.abs(num));",
                "      let range = [];",
                "      let index = 0;",
                "      while (descending ? a >= b : a <= b) {",
                "        if (options.toRegex === true && step > 1) {",
                "          push(a);",
                "        } else {",
                "          range.push(pad(format(a, index), maxLen, toNumber));",
                "        }",
                "        a = descending ? a - step : a + step;",
                "        index++;",
                "      }",
                "      if (options.toRegex === true) {",
                "        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });",
                "      }",
                "      return range;",
                "    };",
                "    var fillLetters = (start, end, step = 1, options = {}) => {",
                "      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {",
                "        return invalidRange(start, end, options);",
                "      }",
                "      let format = options.transform || ((val) => String.fromCharCode(val));",
                "      let a = `${start}`.charCodeAt(0);",
                "      let b = `${end}`.charCodeAt(0);",
                "      let descending = a > b;",
                "      let min = Math.min(a, b);",
                "      let max = Math.max(a, b);",
                "      if (options.toRegex && step === 1) {",
                "        return toRange(min, max, false, options);",
                "      }",
                "      let range = [];",
                "      let index = 0;",
                "      while (descending ? a >= b : a <= b) {",
                "        range.push(format(a, index));",
                "        a = descending ? a - step : a + step;",
                "        index++;",
                "      }",
                "      if (options.toRegex === true) {",
                "        return toRegex(range, null, { wrap: false, options });",
                "      }",
                "      return range;",
                "    };",
                "    var fill = (start, end, step, options = {}) => {",
                "      if (end == null && isValidValue(start)) {",
                "        return [start];",
                "      }",
                "      if (!isValidValue(start) || !isValidValue(end)) {",
                "        return invalidRange(start, end, options);",
                "      }",
                "      if (typeof step === \"function\") {",
                "        return fill(start, end, 1, { transform: step });",
                "      }",
                "      if (isObject(step)) {",
                "        return fill(start, end, 0, step);",
                "      }",
                "      let opts = { ...options };",
                "      if (opts.capture === true)",
                "        opts.wrap = true;",
                "      step = step || opts.step || 1;",
                "      if (!isNumber(step)) {",
                "        if (step != null && !isObject(step))",
                "          return invalidStep(step, opts);",
                "        return fill(start, end, 1, step);",
                "      }",
                "      if (isNumber(start) && isNumber(end)) {",
                "        return fillNumbers(start, end, step, opts);",
                "      }",
                "      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);",
                "    };",
                "    module2.exports = fill;",
                "  }",
                "});",
                "",
                "// node_modules/braces/lib/compile.js",
                "var require_compile = __commonJS({",
                "  \"node_modules/braces/lib/compile.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var fill = require_fill_range();",
                "    var utils = require_utils();",
                "    var compile = (ast, options = {}) => {",
                "      let walk = (node, parent = {}) => {",
                "        let invalidBlock = utils.isInvalidBrace(parent);",
                "        let invalidNode = node.invalid === true && options.escapeInvalid === true;",
                "        let invalid = invalidBlock === true || invalidNode === true;",
                "        let prefix = options.escapeInvalid === true ? \"\\\\\" : \"\";",
                "        let output = \"\";",
                "        if (node.isOpen === true) {",
                "          return prefix + node.value;",
                "        }",
                "        if (node.isClose === true) {",
                "          return prefix + node.value;",
                "        }",
                "        if (node.type === \"open\") {",
                "          return invalid ? prefix + node.value : \"(\";",
                "        }",
                "        if (node.type === \"close\") {",
                "          return invalid ? prefix + node.value : \")\";",
                "        }",
                "        if (node.type === \"comma\") {",
                "          return node.prev.type === \"comma\" ? \"\" : invalid ? node.value : \"|\";",
                "        }",
                "        if (node.value) {",
                "          return node.value;",
                "        }",
                "        if (node.nodes && node.ranges > 0) {",
                "          let args = utils.reduce(node.nodes);",
                "          let range = fill(...args, { ...options, wrap: false, toRegex: true });",
                "          if (range.length !== 0) {",
                "            return args.length > 1 && range.length > 1 ? `(${range})` : range;",
                "          }",
                "        }",
                "        if (node.nodes) {",
                "          for (let child of node.nodes) {",
                "            output += walk(child, node);",
                "          }",
                "        }",
                "        return output;",
                "      };",
                "      return walk(ast);",
                "    };",
                "    module2.exports = compile;",
                "  }",
                "});",
                "",
                "// node_modules/braces/lib/expand.js",
                "var require_expand = __commonJS({",
                "  \"node_modules/braces/lib/expand.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var fill = require_fill_range();",
                "    var stringify = require_stringify();",
                "    var utils = require_utils();",
                "    var append = (queue = \"\", stash = \"\", enclose = false) => {",
                "      let result = [];",
                "      queue = [].concat(queue);",
                "      stash = [].concat(stash);",
                "      if (!stash.length)",
                "        return queue;",
                "      if (!queue.length) {",
                "        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;",
                "      }",
                "      for (let item of queue) {",
                "        if (Array.isArray(item)) {",
                "          for (let value of item) {",
                "            result.push(append(value, stash, enclose));",
                "          }",
                "        } else {",
                "          for (let ele of stash) {",
                "            if (enclose === true && typeof ele === \"string\")",
                "              ele = `{${ele}}`;",
                "            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);",
                "          }",
                "        }",
                "      }",
                "      return utils.flatten(result);",
                "    };",
                "    var expand = (ast, options = {}) => {",
                "      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;",
                "      let walk = (node, parent = {}) => {",
                "        node.queue = [];",
                "        let p = parent;",
                "        let q = parent.queue;",
                "        while (p.type !== \"brace\" && p.type !== \"root\" && p.parent) {",
                "          p = p.parent;",
                "          q = p.queue;",
                "        }",
                "        if (node.invalid || node.dollar) {",
                "          q.push(append(q.pop(), stringify(node, options)));",
                "          return;",
                "        }",
                "        if (node.type === \"brace\" && node.invalid !== true && node.nodes.length === 2) {",
                "          q.push(append(q.pop(), [\"{}\"]));",
                "          return;",
                "        }",
                "        if (node.nodes && node.ranges > 0) {",
                "          let args = utils.reduce(node.nodes);",
                "          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {",
                "            throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\");",
                "          }",
                "          let range = fill(...args, options);",
                "          if (range.length === 0) {",
                "            range = stringify(node, options);",
                "          }",
                "          q.push(append(q.pop(), range));",
                "          node.nodes = [];",
                "          return;",
                "        }",
                "        let enclose = utils.encloseBrace(node);",
                "        let queue = node.queue;",
                "        let block = node;",
                "        while (block.type !== \"brace\" && block.type !== \"root\" && block.parent) {",
                "          block = block.parent;",
                "          queue = block.queue;",
                "        }",
                "        for (let i = 0; i < node.nodes.length; i++) {",
                "          let child = node.nodes[i];",
                "          if (child.type === \"comma\" && node.type === \"brace\") {",
                "            if (i === 1)",
                "              queue.push(\"\");",
                "            queue.push(\"\");",
                "            continue;",
                "          }",
                "          if (child.type === \"close\") {",
                "            q.push(append(q.pop(), queue, enclose));",
                "            continue;",
                "          }",
                "          if (child.value && child.type !== \"open\") {",
                "            queue.push(append(queue.pop(), child.value));",
                "            continue;",
                "          }",
                "          if (child.nodes) {",
                "            walk(child, node);",
                "          }",
                "        }",
                "        return queue;",
                "      };",
                "      return utils.flatten(walk(ast));",
                "    };",
                "    module2.exports = expand;",
                "  }",
                "});",
                "",
                "// node_modules/braces/lib/constants.js",
                "var require_constants = __commonJS({",
                "  \"node_modules/braces/lib/constants.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = {",
                "      MAX_LENGTH: 1024 * 64,",
                "      CHAR_0: \"0\",",
                "      CHAR_9: \"9\",",
                "      CHAR_UPPERCASE_A: \"A\",",
                "      CHAR_LOWERCASE_A: \"a\",",
                "      CHAR_UPPERCASE_Z: \"Z\",",
                "      CHAR_LOWERCASE_Z: \"z\",",
                "      CHAR_LEFT_PARENTHESES: \"(\",",
                "      CHAR_RIGHT_PARENTHESES: \")\",",
                "      CHAR_ASTERISK: \"*\",",
                "      CHAR_AMPERSAND: \"&\",",
                "      CHAR_AT: \"@\",",
                "      CHAR_BACKSLASH: \"\\\\\",",
                "      CHAR_BACKTICK: \"`\",",
                "      CHAR_CARRIAGE_RETURN: \"\\r\",",
                "      CHAR_CIRCUMFLEX_ACCENT: \"^\",",
                "      CHAR_COLON: \":\",",
                "      CHAR_COMMA: \",\",",
                "      CHAR_DOLLAR: \"$\",",
                "      CHAR_DOT: \".\",",
                "      CHAR_DOUBLE_QUOTE: '\"',",
                "      CHAR_EQUAL: \"=\",",
                "      CHAR_EXCLAMATION_MARK: \"!\",",
                "      CHAR_FORM_FEED: \"\\f\",",
                "      CHAR_FORWARD_SLASH: \"/\",",
                "      CHAR_HASH: \"#\",",
                "      CHAR_HYPHEN_MINUS: \"-\",",
                "      CHAR_LEFT_ANGLE_BRACKET: \"<\",",
                "      CHAR_LEFT_CURLY_BRACE: \"{\",",
                "      CHAR_LEFT_SQUARE_BRACKET: \"[\",",
                "      CHAR_LINE_FEED: \"\\n\",",
                "      CHAR_NO_BREAK_SPACE: \"\\xA0\",",
                "      CHAR_PERCENT: \"%\",",
                "      CHAR_PLUS: \"+\",",
                "      CHAR_QUESTION_MARK: \"?\",",
                "      CHAR_RIGHT_ANGLE_BRACKET: \">\",",
                "      CHAR_RIGHT_CURLY_BRACE: \"}\",",
                "      CHAR_RIGHT_SQUARE_BRACKET: \"]\",",
                "      CHAR_SEMICOLON: \";\",",
                "      CHAR_SINGLE_QUOTE: \"'\",",
                "      CHAR_SPACE: \" \",",
                "      CHAR_TAB: \"\t\",",
                "      CHAR_UNDERSCORE: \"_\",",
                "      CHAR_VERTICAL_LINE: \"|\",",
                "      CHAR_ZERO_WIDTH_NOBREAK_SPACE: \"\\uFEFF\"",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/braces/lib/parse.js",
                "var require_parse = __commonJS({",
                "  \"node_modules/braces/lib/parse.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var stringify = require_stringify();",
                "    var {",
                "      MAX_LENGTH,",
                "      CHAR_BACKSLASH,",
                "      CHAR_BACKTICK,",
                "      CHAR_COMMA,",
                "      CHAR_DOT,",
                "      CHAR_LEFT_PARENTHESES,",
                "      CHAR_RIGHT_PARENTHESES,",
                "      CHAR_LEFT_CURLY_BRACE,",
                "      CHAR_RIGHT_CURLY_BRACE,",
                "      CHAR_LEFT_SQUARE_BRACKET,",
                "      CHAR_RIGHT_SQUARE_BRACKET,",
                "      CHAR_DOUBLE_QUOTE,",
                "      CHAR_SINGLE_QUOTE,",
                "      CHAR_NO_BREAK_SPACE,",
                "      CHAR_ZERO_WIDTH_NOBREAK_SPACE",
                "    } = require_constants();",
                "    var parse = (input, options = {}) => {",
                "      if (typeof input !== \"string\") {",
                "        throw new TypeError(\"Expected a string\");",
                "      }",
                "      let opts = options || {};",
                "      let max = typeof opts.maxLength === \"number\" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;",
                "      if (input.length > max) {",
                "        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);",
                "      }",
                "      let ast = { type: \"root\", input, nodes: [] };",
                "      let stack = [ast];",
                "      let block = ast;",
                "      let prev = ast;",
                "      let brackets = 0;",
                "      let length = input.length;",
                "      let index = 0;",
                "      let depth = 0;",
                "      let value;",
                "      let memo = {};",
                "      const advance = () => input[index++];",
                "      const push = (node) => {",
                "        if (node.type === \"text\" && prev.type === \"dot\") {",
                "          prev.type = \"text\";",
                "        }",
                "        if (prev && prev.type === \"text\" && node.type === \"text\") {",
                "          prev.value += node.value;",
                "          return;",
                "        }",
                "        block.nodes.push(node);",
                "        node.parent = block;",
                "        node.prev = prev;",
                "        prev = node;",
                "        return node;",
                "      };",
                "      push({ type: \"bos\" });",
                "      while (index < length) {",
                "        block = stack[stack.length - 1];",
                "        value = advance();",
                "        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {",
                "          continue;",
                "        }",
                "        if (value === CHAR_BACKSLASH) {",
                "          push({ type: \"text\", value: (options.keepEscaping ? value : \"\") + advance() });",
                "          continue;",
                "        }",
                "        if (value === CHAR_RIGHT_SQUARE_BRACKET) {",
                "          push({ type: \"text\", value: \"\\\\\" + value });",
                "          continue;",
                "        }",
                "        if (value === CHAR_LEFT_SQUARE_BRACKET) {",
                "          brackets++;",
                "          let closed = true;",
                "          let next;",
                "          while (index < length && (next = advance())) {",
                "            value += next;",
                "            if (next === CHAR_LEFT_SQUARE_BRACKET) {",
                "              brackets++;",
                "              continue;",
                "            }",
                "            if (next === CHAR_BACKSLASH) {",
                "              value += advance();",
                "              continue;",
                "            }",
                "            if (next === CHAR_RIGHT_SQUARE_BRACKET) {",
                "              brackets--;",
                "              if (brackets === 0) {",
                "                break;",
                "              }",
                "            }",
                "          }",
                "          push({ type: \"text\", value });",
                "          continue;",
                "        }",
                "        if (value === CHAR_LEFT_PARENTHESES) {",
                "          block = push({ type: \"paren\", nodes: [] });",
                "          stack.push(block);",
                "          push({ type: \"text\", value });",
                "          continue;",
                "        }",
                "        if (value === CHAR_RIGHT_PARENTHESES) {",
                "          if (block.type !== \"paren\") {",
                "            push({ type: \"text\", value });",
                "            continue;",
                "          }",
                "          block = stack.pop();",
                "          push({ type: \"text\", value });",
                "          block = stack[stack.length - 1];",
                "          continue;",
                "        }",
                "        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {",
                "          let open = value;",
                "          let next;",
                "          if (options.keepQuotes !== true) {",
                "            value = \"\";",
                "          }",
                "          while (index < length && (next = advance())) {",
                "            if (next === CHAR_BACKSLASH) {",
                "              value += next + advance();",
                "              continue;",
                "            }",
                "            if (next === open) {",
                "              if (options.keepQuotes === true)",
                "                value += next;",
                "              break;",
                "            }",
                "            value += next;",
                "          }",
                "          push({ type: \"text\", value });",
                "          continue;",
                "        }",
                "        if (value === CHAR_LEFT_CURLY_BRACE) {",
                "          depth++;",
                "          let dollar = prev.value && prev.value.slice(-1) === \"$\" || block.dollar === true;",
                "          let brace = {",
                "            type: \"brace\",",
                "            open: true,",
                "            close: false,",
                "            dollar,",
                "            depth,",
                "            commas: 0,",
                "            ranges: 0,",
                "            nodes: []",
                "          };",
                "          block = push(brace);",
                "          stack.push(block);",
                "          push({ type: \"open\", value });",
                "          continue;",
                "        }",
                "        if (value === CHAR_RIGHT_CURLY_BRACE) {",
                "          if (block.type !== \"brace\") {",
                "            push({ type: \"text\", value });",
                "            continue;",
                "          }",
                "          let type = \"close\";",
                "          block = stack.pop();",
                "          block.close = true;",
                "          push({ type, value });",
                "          depth--;",
                "          block = stack[stack.length - 1];",
                "          continue;",
                "        }",
                "        if (value === CHAR_COMMA && depth > 0) {",
                "          if (block.ranges > 0) {",
                "            block.ranges = 0;",
                "            let open = block.nodes.shift();",
                "            block.nodes = [open, { type: \"text\", value: stringify(block) }];",
                "          }",
                "          push({ type: \"comma\", value });",
                "          block.commas++;",
                "          continue;",
                "        }",
                "        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {",
                "          let siblings = block.nodes;",
                "          if (depth === 0 || siblings.length === 0) {",
                "            push({ type: \"text\", value });",
                "            continue;",
                "          }",
                "          if (prev.type === \"dot\") {",
                "            block.range = [];",
                "            prev.value += value;",
                "            prev.type = \"range\";",
                "            if (block.nodes.length !== 3 && block.nodes.length !== 5) {",
                "              block.invalid = true;",
                "              block.ranges = 0;",
                "              prev.type = \"text\";",
                "              continue;",
                "            }",
                "            block.ranges++;",
                "            block.args = [];",
                "            continue;",
                "          }",
                "          if (prev.type === \"range\") {",
                "            siblings.pop();",
                "            let before = siblings[siblings.length - 1];",
                "            before.value += prev.value + value;",
                "            prev = before;",
                "            block.ranges--;",
                "            continue;",
                "          }",
                "          push({ type: \"dot\", value });",
                "          continue;",
                "        }",
                "        push({ type: \"text\", value });",
                "      }",
                "      do {",
                "        block = stack.pop();",
                "        if (block.type !== \"root\") {",
                "          block.nodes.forEach((node) => {",
                "            if (!node.nodes) {",
                "              if (node.type === \"open\")",
                "                node.isOpen = true;",
                "              if (node.type === \"close\")",
                "                node.isClose = true;",
                "              if (!node.nodes)",
                "                node.type = \"text\";",
                "              node.invalid = true;",
                "            }",
                "          });",
                "          let parent = stack[stack.length - 1];",
                "          let index2 = parent.nodes.indexOf(block);",
                "          parent.nodes.splice(index2, 1, ...block.nodes);",
                "        }",
                "      } while (stack.length > 0);",
                "      push({ type: \"eos\" });",
                "      return ast;",
                "    };",
                "    module2.exports = parse;",
                "  }",
                "});",
                "",
                "// node_modules/braces/index.js",
                "var require_braces = __commonJS({",
                "  \"node_modules/braces/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var stringify = require_stringify();",
                "    var compile = require_compile();",
                "    var expand = require_expand();",
                "    var parse = require_parse();",
                "    var braces = (input, options = {}) => {",
                "      let output = [];",
                "      if (Array.isArray(input)) {",
                "        for (let pattern of input) {",
                "          let result = braces.create(pattern, options);",
                "          if (Array.isArray(result)) {",
                "            output.push(...result);",
                "          } else {",
                "            output.push(result);",
                "          }",
                "        }",
                "      } else {",
                "        output = [].concat(braces.create(input, options));",
                "      }",
                "      if (options && options.expand === true && options.nodupes === true) {",
                "        output = [...new Set(output)];",
                "      }",
                "      return output;",
                "    };",
                "    braces.parse = (input, options = {}) => parse(input, options);",
                "    braces.stringify = (input, options = {}) => {",
                "      if (typeof input === \"string\") {",
                "        return stringify(braces.parse(input, options), options);",
                "      }",
                "      return stringify(input, options);",
                "    };",
                "    braces.compile = (input, options = {}) => {",
                "      if (typeof input === \"string\") {",
                "        input = braces.parse(input, options);",
                "      }",
                "      return compile(input, options);",
                "    };",
                "    braces.expand = (input, options = {}) => {",
                "      if (typeof input === \"string\") {",
                "        input = braces.parse(input, options);",
                "      }",
                "      let result = expand(input, options);",
                "      if (options.noempty === true) {",
                "        result = result.filter(Boolean);",
                "      }",
                "      if (options.nodupes === true) {",
                "        result = [...new Set(result)];",
                "      }",
                "      return result;",
                "    };",
                "    braces.create = (input, options = {}) => {",
                "      if (input === \"\" || input.length < 3) {",
                "        return [input];",
                "      }",
                "      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);",
                "    };",
                "    module2.exports = braces;",
                "  }",
                "});",
                "",
                "// node_modules/picomatch/lib/constants.js",
                "var require_constants2 = __commonJS({",
                "  \"node_modules/picomatch/lib/constants.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var path2 = require(\"path\");",
                "    var WIN_SLASH = \"\\\\\\\\/\";",
                "    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;",
                "    var DOT_LITERAL = \"\\\\.\";",
                "    var PLUS_LITERAL = \"\\\\+\";",
                "    var QMARK_LITERAL = \"\\\\?\";",
                "    var SLASH_LITERAL = \"\\\\/\";",
                "    var ONE_CHAR = \"(?=.)\";",
                "    var QMARK = \"[^/]\";",
                "    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;",
                "    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;",
                "    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;",
                "    var NO_DOT = `(?!${DOT_LITERAL})`;",
                "    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;",
                "    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;",
                "    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;",
                "    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;",
                "    var STAR = `${QMARK}*?`;",
                "    var POSIX_CHARS = {",
                "      DOT_LITERAL,",
                "      PLUS_LITERAL,",
                "      QMARK_LITERAL,",
                "      SLASH_LITERAL,",
                "      ONE_CHAR,",
                "      QMARK,",
                "      END_ANCHOR,",
                "      DOTS_SLASH,",
                "      NO_DOT,",
                "      NO_DOTS,",
                "      NO_DOT_SLASH,",
                "      NO_DOTS_SLASH,",
                "      QMARK_NO_DOT,",
                "      STAR,",
                "      START_ANCHOR",
                "    };",
                "    var WINDOWS_CHARS = {",
                "      ...POSIX_CHARS,",
                "      SLASH_LITERAL: `[${WIN_SLASH}]`,",
                "      QMARK: WIN_NO_SLASH,",
                "      STAR: `${WIN_NO_SLASH}*?`,",
                "      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,",
                "      NO_DOT: `(?!${DOT_LITERAL})`,",
                "      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,",
                "      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,",
                "      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,",
                "      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,",
                "      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,",
                "      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`",
                "    };",
                "    var POSIX_REGEX_SOURCE = {",
                "      alnum: \"a-zA-Z0-9\",",
                "      alpha: \"a-zA-Z\",",
                "      ascii: \"\\\\x00-\\\\x7F\",",
                "      blank: \" \\\\t\",",
                "      cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",",
                "      digit: \"0-9\",",
                "      graph: \"\\\\x21-\\\\x7E\",",
                "      lower: \"a-z\",",
                "      print: \"\\\\x20-\\\\x7E \",",
                "      punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",",
                "      space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",",
                "      upper: \"A-Z\",",
                "      word: \"A-Za-z0-9_\",",
                "      xdigit: \"A-Fa-f0-9\"",
                "    };",
                "    module2.exports = {",
                "      MAX_LENGTH: 1024 * 64,",
                "      POSIX_REGEX_SOURCE,",
                "      REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,",
                "      REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,",
                "      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,",
                "      REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,",
                "      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,",
                "      REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,",
                "      REPLACEMENTS: {",
                "        \"***\": \"*\",",
                "        \"**/**\": \"**\",",
                "        \"**/**/**\": \"**\"",
                "      },",
                "      CHAR_0: 48,",
                "      CHAR_9: 57,",
                "      CHAR_UPPERCASE_A: 65,",
                "      CHAR_LOWERCASE_A: 97,",
                "      CHAR_UPPERCASE_Z: 90,",
                "      CHAR_LOWERCASE_Z: 122,",
                "      CHAR_LEFT_PARENTHESES: 40,",
                "      CHAR_RIGHT_PARENTHESES: 41,",
                "      CHAR_ASTERISK: 42,",
                "      CHAR_AMPERSAND: 38,",
                "      CHAR_AT: 64,",
                "      CHAR_BACKWARD_SLASH: 92,",
                "      CHAR_CARRIAGE_RETURN: 13,",
                "      CHAR_CIRCUMFLEX_ACCENT: 94,",
                "      CHAR_COLON: 58,",
                "      CHAR_COMMA: 44,",
                "      CHAR_DOT: 46,",
                "      CHAR_DOUBLE_QUOTE: 34,",
                "      CHAR_EQUAL: 61,",
                "      CHAR_EXCLAMATION_MARK: 33,",
                "      CHAR_FORM_FEED: 12,",
                "      CHAR_FORWARD_SLASH: 47,",
                "      CHAR_GRAVE_ACCENT: 96,",
                "      CHAR_HASH: 35,",
                "      CHAR_HYPHEN_MINUS: 45,",
                "      CHAR_LEFT_ANGLE_BRACKET: 60,",
                "      CHAR_LEFT_CURLY_BRACE: 123,",
                "      CHAR_LEFT_SQUARE_BRACKET: 91,",
                "      CHAR_LINE_FEED: 10,",
                "      CHAR_NO_BREAK_SPACE: 160,",
                "      CHAR_PERCENT: 37,",
                "      CHAR_PLUS: 43,",
                "      CHAR_QUESTION_MARK: 63,",
                "      CHAR_RIGHT_ANGLE_BRACKET: 62,",
                "      CHAR_RIGHT_CURLY_BRACE: 125,",
                "      CHAR_RIGHT_SQUARE_BRACKET: 93,",
                "      CHAR_SEMICOLON: 59,",
                "      CHAR_SINGLE_QUOTE: 39,",
                "      CHAR_SPACE: 32,",
                "      CHAR_TAB: 9,",
                "      CHAR_UNDERSCORE: 95,",
                "      CHAR_VERTICAL_LINE: 124,",
                "      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,",
                "      SEP: path2.sep,",
                "      extglobChars(chars) {",
                "        return {",
                "          \"!\": { type: \"negate\", open: \"(?:(?!(?:\", close: `))${chars.STAR})` },",
                "          \"?\": { type: \"qmark\", open: \"(?:\", close: \")?\" },",
                "          \"+\": { type: \"plus\", open: \"(?:\", close: \")+\" },",
                "          \"*\": { type: \"star\", open: \"(?:\", close: \")*\" },",
                "          \"@\": { type: \"at\", open: \"(?:\", close: \")\" }",
                "        };",
                "      },",
                "      globChars(win32) {",
                "        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;",
                "      }",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/picomatch/lib/utils.js",
                "var require_utils2 = __commonJS({",
                "  \"node_modules/picomatch/lib/utils.js\"(exports) {",
                "    \"use strict\";",
                "    var path2 = require(\"path\");",
                "    var win32 = process.platform === \"win32\";",
                "    var {",
                "      REGEX_BACKSLASH,",
                "      REGEX_REMOVE_BACKSLASH,",
                "      REGEX_SPECIAL_CHARS,",
                "      REGEX_SPECIAL_CHARS_GLOBAL",
                "    } = require_constants2();",
                "    exports.isObject = (val) => val !== null && typeof val === \"object\" && !Array.isArray(val);",
                "    exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);",
                "    exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);",
                "    exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, \"\\\\$1\");",
                "    exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, \"/\");",
                "    exports.removeBackslashes = (str) => {",
                "      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {",
                "        return match === \"\\\\\" ? \"\" : match;",
                "      });",
                "    };",
                "    exports.supportsLookbehinds = () => {",
                "      const segs = process.version.slice(1).split(\".\").map(Number);",
                "      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {",
                "        return true;",
                "      }",
                "      return false;",
                "    };",
                "    exports.isWindows = (options) => {",
                "      if (options && typeof options.windows === \"boolean\") {",
                "        return options.windows;",
                "      }",
                "      return win32 === true || path2.sep === \"\\\\\";",
                "    };",
                "    exports.escapeLast = (input, char, lastIdx) => {",
                "      const idx = input.lastIndexOf(char, lastIdx);",
                "      if (idx === -1)",
                "        return input;",
                "      if (input[idx - 1] === \"\\\\\")",
                "        return exports.escapeLast(input, char, idx - 1);",
                "      return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;",
                "    };",
                "    exports.removePrefix = (input, state = {}) => {",
                "      let output = input;",
                "      if (output.startsWith(\"./\")) {",
                "        output = output.slice(2);",
                "        state.prefix = \"./\";",
                "      }",
                "      return output;",
                "    };",
                "    exports.wrapOutput = (input, state = {}, options = {}) => {",
                "      const prepend = options.contains ? \"\" : \"^\";",
                "      const append = options.contains ? \"\" : \"$\";",
                "      let output = `${prepend}(?:${input})${append}`;",
                "      if (state.negated === true) {",
                "        output = `(?:^(?!${output}).*$)`;",
                "      }",
                "      return output;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/picomatch/lib/scan.js",
                "var require_scan = __commonJS({",
                "  \"node_modules/picomatch/lib/scan.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var utils = require_utils2();",
                "    var {",
                "      CHAR_ASTERISK,",
                "      CHAR_AT,",
                "      CHAR_BACKWARD_SLASH,",
                "      CHAR_COMMA,",
                "      CHAR_DOT,",
                "      CHAR_EXCLAMATION_MARK,",
                "      CHAR_FORWARD_SLASH,",
                "      CHAR_LEFT_CURLY_BRACE,",
                "      CHAR_LEFT_PARENTHESES,",
                "      CHAR_LEFT_SQUARE_BRACKET,",
                "      CHAR_PLUS,",
                "      CHAR_QUESTION_MARK,",
                "      CHAR_RIGHT_CURLY_BRACE,",
                "      CHAR_RIGHT_PARENTHESES,",
                "      CHAR_RIGHT_SQUARE_BRACKET",
                "    } = require_constants2();",
                "    var isPathSeparator = (code) => {",
                "      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;",
                "    };",
                "    var depth = (token) => {",
                "      if (token.isPrefix !== true) {",
                "        token.depth = token.isGlobstar ? Infinity : 1;",
                "      }",
                "    };",
                "    var scan = (input, options) => {",
                "      const opts = options || {};",
                "      const length = input.length - 1;",
                "      const scanToEnd = opts.parts === true || opts.scanToEnd === true;",
                "      const slashes = [];",
                "      const tokens = [];",
                "      const parts = [];",
                "      let str = input;",
                "      let index = -1;",
                "      let start = 0;",
                "      let lastIndex = 0;",
                "      let isBrace = false;",
                "      let isBracket = false;",
                "      let isGlob = false;",
                "      let isExtglob = false;",
                "      let isGlobstar = false;",
                "      let braceEscaped = false;",
                "      let backslashes = false;",
                "      let negated = false;",
                "      let negatedExtglob = false;",
                "      let finished = false;",
                "      let braces = 0;",
                "      let prev;",
                "      let code;",
                "      let token = { value: \"\", depth: 0, isGlob: false };",
                "      const eos = () => index >= length;",
                "      const peek = () => str.charCodeAt(index + 1);",
                "      const advance = () => {",
                "        prev = code;",
                "        return str.charCodeAt(++index);",
                "      };",
                "      while (index < length) {",
                "        code = advance();",
                "        let next;",
                "        if (code === CHAR_BACKWARD_SLASH) {",
                "          backslashes = token.backslashes = true;",
                "          code = advance();",
                "          if (code === CHAR_LEFT_CURLY_BRACE) {",
                "            braceEscaped = true;",
                "          }",
                "          continue;",
                "        }",
                "        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {",
                "          braces++;",
                "          while (eos() !== true && (code = advance())) {",
                "            if (code === CHAR_BACKWARD_SLASH) {",
                "              backslashes = token.backslashes = true;",
                "              advance();",
                "              continue;",
                "            }",
                "            if (code === CHAR_LEFT_CURLY_BRACE) {",
                "              braces++;",
                "              continue;",
                "            }",
                "            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {",
                "              isBrace = token.isBrace = true;",
                "              isGlob = token.isGlob = true;",
                "              finished = true;",
                "              if (scanToEnd === true) {",
                "                continue;",
                "              }",
                "              break;",
                "            }",
                "            if (braceEscaped !== true && code === CHAR_COMMA) {",
                "              isBrace = token.isBrace = true;",
                "              isGlob = token.isGlob = true;",
                "              finished = true;",
                "              if (scanToEnd === true) {",
                "                continue;",
                "              }",
                "              break;",
                "            }",
                "            if (code === CHAR_RIGHT_CURLY_BRACE) {",
                "              braces--;",
                "              if (braces === 0) {",
                "                braceEscaped = false;",
                "                isBrace = token.isBrace = true;",
                "                finished = true;",
                "                break;",
                "              }",
                "            }",
                "          }",
                "          if (scanToEnd === true) {",
                "            continue;",
                "          }",
                "          break;",
                "        }",
                "        if (code === CHAR_FORWARD_SLASH) {",
                "          slashes.push(index);",
                "          tokens.push(token);",
                "          token = { value: \"\", depth: 0, isGlob: false };",
                "          if (finished === true)",
                "            continue;",
                "          if (prev === CHAR_DOT && index === start + 1) {",
                "            start += 2;",
                "            continue;",
                "          }",
                "          lastIndex = index + 1;",
                "          continue;",
                "        }",
                "        if (opts.noext !== true) {",
                "          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;",
                "          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {",
                "            isGlob = token.isGlob = true;",
                "            isExtglob = token.isExtglob = true;",
                "            finished = true;",
                "            if (code === CHAR_EXCLAMATION_MARK && index === start) {",
                "              negatedExtglob = true;",
                "            }",
                "            if (scanToEnd === true) {",
                "              while (eos() !== true && (code = advance())) {",
                "                if (code === CHAR_BACKWARD_SLASH) {",
                "                  backslashes = token.backslashes = true;",
                "                  code = advance();",
                "                  continue;",
                "                }",
                "                if (code === CHAR_RIGHT_PARENTHESES) {",
                "                  isGlob = token.isGlob = true;",
                "                  finished = true;",
                "                  break;",
                "                }",
                "              }",
                "              continue;",
                "            }",
                "            break;",
                "          }",
                "        }",
                "        if (code === CHAR_ASTERISK) {",
                "          if (prev === CHAR_ASTERISK)",
                "            isGlobstar = token.isGlobstar = true;",
                "          isGlob = token.isGlob = true;",
                "          finished = true;",
                "          if (scanToEnd === true) {",
                "            continue;",
                "          }",
                "          break;",
                "        }",
                "        if (code === CHAR_QUESTION_MARK) {",
                "          isGlob = token.isGlob = true;",
                "          finished = true;",
                "          if (scanToEnd === true) {",
                "            continue;",
                "          }",
                "          break;",
                "        }",
                "        if (code === CHAR_LEFT_SQUARE_BRACKET) {",
                "          while (eos() !== true && (next = advance())) {",
                "            if (next === CHAR_BACKWARD_SLASH) {",
                "              backslashes = token.backslashes = true;",
                "              advance();",
                "              continue;",
                "            }",
                "            if (next === CHAR_RIGHT_SQUARE_BRACKET) {",
                "              isBracket = token.isBracket = true;",
                "              isGlob = token.isGlob = true;",
                "              finished = true;",
                "              break;",
                "            }",
                "          }",
                "          if (scanToEnd === true) {",
                "            continue;",
                "          }",
                "          break;",
                "        }",
                "        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {",
                "          negated = token.negated = true;",
                "          start++;",
                "          continue;",
                "        }",
                "        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {",
                "          isGlob = token.isGlob = true;",
                "          if (scanToEnd === true) {",
                "            while (eos() !== true && (code = advance())) {",
                "              if (code === CHAR_LEFT_PARENTHESES) {",
                "                backslashes = token.backslashes = true;",
                "                code = advance();",
                "                continue;",
                "              }",
                "              if (code === CHAR_RIGHT_PARENTHESES) {",
                "                finished = true;",
                "                break;",
                "              }",
                "            }",
                "            continue;",
                "          }",
                "          break;",
                "        }",
                "        if (isGlob === true) {",
                "          finished = true;",
                "          if (scanToEnd === true) {",
                "            continue;",
                "          }",
                "          break;",
                "        }",
                "      }",
                "      if (opts.noext === true) {",
                "        isExtglob = false;",
                "        isGlob = false;",
                "      }",
                "      let base = str;",
                "      let prefix = \"\";",
                "      let glob = \"\";",
                "      if (start > 0) {",
                "        prefix = str.slice(0, start);",
                "        str = str.slice(start);",
                "        lastIndex -= start;",
                "      }",
                "      if (base && isGlob === true && lastIndex > 0) {",
                "        base = str.slice(0, lastIndex);",
                "        glob = str.slice(lastIndex);",
                "      } else if (isGlob === true) {",
                "        base = \"\";",
                "        glob = str;",
                "      } else {",
                "        base = str;",
                "      }",
                "      if (base && base !== \"\" && base !== \"/\" && base !== str) {",
                "        if (isPathSeparator(base.charCodeAt(base.length - 1))) {",
                "          base = base.slice(0, -1);",
                "        }",
                "      }",
                "      if (opts.unescape === true) {",
                "        if (glob)",
                "          glob = utils.removeBackslashes(glob);",
                "        if (base && backslashes === true) {",
                "          base = utils.removeBackslashes(base);",
                "        }",
                "      }",
                "      const state = {",
                "        prefix,",
                "        input,",
                "        start,",
                "        base,",
                "        glob,",
                "        isBrace,",
                "        isBracket,",
                "        isGlob,",
                "        isExtglob,",
                "        isGlobstar,",
                "        negated,",
                "        negatedExtglob",
                "      };",
                "      if (opts.tokens === true) {",
                "        state.maxDepth = 0;",
                "        if (!isPathSeparator(code)) {",
                "          tokens.push(token);",
                "        }",
                "        state.tokens = tokens;",
                "      }",
                "      if (opts.parts === true || opts.tokens === true) {",
                "        let prevIndex;",
                "        for (let idx = 0; idx < slashes.length; idx++) {",
                "          const n = prevIndex ? prevIndex + 1 : start;",
                "          const i = slashes[idx];",
                "          const value = input.slice(n, i);",
                "          if (opts.tokens) {",
                "            if (idx === 0 && start !== 0) {",
                "              tokens[idx].isPrefix = true;",
                "              tokens[idx].value = prefix;",
                "            } else {",
                "              tokens[idx].value = value;",
                "            }",
                "            depth(tokens[idx]);",
                "            state.maxDepth += tokens[idx].depth;",
                "          }",
                "          if (idx !== 0 || value !== \"\") {",
                "            parts.push(value);",
                "          }",
                "          prevIndex = i;",
                "        }",
                "        if (prevIndex && prevIndex + 1 < input.length) {",
                "          const value = input.slice(prevIndex + 1);",
                "          parts.push(value);",
                "          if (opts.tokens) {",
                "            tokens[tokens.length - 1].value = value;",
                "            depth(tokens[tokens.length - 1]);",
                "            state.maxDepth += tokens[tokens.length - 1].depth;",
                "          }",
                "        }",
                "        state.slashes = slashes;",
                "        state.parts = parts;",
                "      }",
                "      return state;",
                "    };",
                "    module2.exports = scan;",
                "  }",
                "});",
                "",
                "// node_modules/picomatch/lib/parse.js",
                "var require_parse2 = __commonJS({",
                "  \"node_modules/picomatch/lib/parse.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var constants = require_constants2();",
                "    var utils = require_utils2();",
                "    var {",
                "      MAX_LENGTH,",
                "      POSIX_REGEX_SOURCE,",
                "      REGEX_NON_SPECIAL_CHARS,",
                "      REGEX_SPECIAL_CHARS_BACKREF,",
                "      REPLACEMENTS",
                "    } = constants;",
                "    var expandRange = (args, options) => {",
                "      if (typeof options.expandRange === \"function\") {",
                "        return options.expandRange(...args, options);",
                "      }",
                "      args.sort();",
                "      const value = `[${args.join(\"-\")}]`;",
                "      try {",
                "        new RegExp(value);",
                "      } catch (ex) {",
                "        return args.map((v) => utils.escapeRegex(v)).join(\"..\");",
                "      }",
                "      return value;",
                "    };",
                "    var syntaxError = (type, char) => {",
                "      return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;",
                "    };",
                "    var parse = (input, options) => {",
                "      if (typeof input !== \"string\") {",
                "        throw new TypeError(\"Expected a string\");",
                "      }",
                "      input = REPLACEMENTS[input] || input;",
                "      const opts = { ...options };",
                "      const max = typeof opts.maxLength === \"number\" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;",
                "      let len = input.length;",
                "      if (len > max) {",
                "        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);",
                "      }",
                "      const bos = { type: \"bos\", value: \"\", output: opts.prepend || \"\" };",
                "      const tokens = [bos];",
                "      const capture = opts.capture ? \"\" : \"?:\";",
                "      const win32 = utils.isWindows(options);",
                "      const PLATFORM_CHARS = constants.globChars(win32);",
                "      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);",
                "      const {",
                "        DOT_LITERAL,",
                "        PLUS_LITERAL,",
                "        SLASH_LITERAL,",
                "        ONE_CHAR,",
                "        DOTS_SLASH,",
                "        NO_DOT,",
                "        NO_DOT_SLASH,",
                "        NO_DOTS_SLASH,",
                "        QMARK,",
                "        QMARK_NO_DOT,",
                "        STAR,",
                "        START_ANCHOR",
                "      } = PLATFORM_CHARS;",
                "      const globstar = (opts2) => {",
                "        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;",
                "      };",
                "      const nodot = opts.dot ? \"\" : NO_DOT;",
                "      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;",
                "      let star = opts.bash === true ? globstar(opts) : STAR;",
                "      if (opts.capture) {",
                "        star = `(${star})`;",
                "      }",
                "      if (typeof opts.noext === \"boolean\") {",
                "        opts.noextglob = opts.noext;",
                "      }",
                "      const state = {",
                "        input,",
                "        index: -1,",
                "        start: 0,",
                "        dot: opts.dot === true,",
                "        consumed: \"\",",
                "        output: \"\",",
                "        prefix: \"\",",
                "        backtrack: false,",
                "        negated: false,",
                "        brackets: 0,",
                "        braces: 0,",
                "        parens: 0,",
                "        quotes: 0,",
                "        globstar: false,",
                "        tokens",
                "      };",
                "      input = utils.removePrefix(input, state);",
                "      len = input.length;",
                "      const extglobs = [];",
                "      const braces = [];",
                "      const stack = [];",
                "      let prev = bos;",
                "      let value;",
                "      const eos = () => state.index === len - 1;",
                "      const peek = state.peek = (n = 1) => input[state.index + n];",
                "      const advance = state.advance = () => input[++state.index] || \"\";",
                "      const remaining = () => input.slice(state.index + 1);",
                "      const consume = (value2 = \"\", num = 0) => {",
                "        state.consumed += value2;",
                "        state.index += num;",
                "      };",
                "      const append = (token) => {",
                "        state.output += token.output != null ? token.output : token.value;",
                "        consume(token.value);",
                "      };",
                "      const negate = () => {",
                "        let count = 1;",
                "        while (peek() === \"!\" && (peek(2) !== \"(\" || peek(3) === \"?\")) {",
                "          advance();",
                "          state.start++;",
                "          count++;",
                "        }",
                "        if (count % 2 === 0) {",
                "          return false;",
                "        }",
                "        state.negated = true;",
                "        state.start++;",
                "        return true;",
                "      };",
                "      const increment = (type) => {",
                "        state[type]++;",
                "        stack.push(type);",
                "      };",
                "      const decrement = (type) => {",
                "        state[type]--;",
                "        stack.pop();",
                "      };",
                "      const push = (tok) => {",
                "        if (prev.type === \"globstar\") {",
                "          const isBrace = state.braces > 0 && (tok.type === \"comma\" || tok.type === \"brace\");",
                "          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === \"pipe\" || tok.type === \"paren\");",
                "          if (tok.type !== \"slash\" && tok.type !== \"paren\" && !isBrace && !isExtglob) {",
                "            state.output = state.output.slice(0, -prev.output.length);",
                "            prev.type = \"star\";",
                "            prev.value = \"*\";",
                "            prev.output = star;",
                "            state.output += prev.output;",
                "          }",
                "        }",
                "        if (extglobs.length && tok.type !== \"paren\") {",
                "          extglobs[extglobs.length - 1].inner += tok.value;",
                "        }",
                "        if (tok.value || tok.output)",
                "          append(tok);",
                "        if (prev && prev.type === \"text\" && tok.type === \"text\") {",
                "          prev.value += tok.value;",
                "          prev.output = (prev.output || \"\") + tok.value;",
                "          return;",
                "        }",
                "        tok.prev = prev;",
                "        tokens.push(tok);",
                "        prev = tok;",
                "      };",
                "      const extglobOpen = (type, value2) => {",
                "        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: \"\" };",
                "        token.prev = prev;",
                "        token.parens = state.parens;",
                "        token.output = state.output;",
                "        const output = (opts.capture ? \"(\" : \"\") + token.open;",
                "        increment(\"parens\");",
                "        push({ type, value: value2, output: state.output ? \"\" : ONE_CHAR });",
                "        push({ type: \"paren\", extglob: true, value: advance(), output });",
                "        extglobs.push(token);",
                "      };",
                "      const extglobClose = (token) => {",
                "        let output = token.close + (opts.capture ? \")\" : \"\");",
                "        let rest;",
                "        if (token.type === \"negate\") {",
                "          let extglobStar = star;",
                "          if (token.inner && token.inner.length > 1 && token.inner.includes(\"/\")) {",
                "            extglobStar = globstar(opts);",
                "          }",
                "          if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {",
                "            output = token.close = `)$))${extglobStar}`;",
                "          }",
                "          if (token.inner.includes(\"*\") && (rest = remaining()) && /^\\.[^\\\\/.]+$/.test(rest)) {",
                "            const expression = parse(rest, { ...options, fastpaths: false }).output;",
                "            output = token.close = `)${expression})${extglobStar})`;",
                "          }",
                "          if (token.prev.type === \"bos\") {",
                "            state.negatedExtglob = true;",
                "          }",
                "        }",
                "        push({ type: \"paren\", extglob: true, value, output });",
                "        decrement(\"parens\");",
                "      };",
                "      if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {",
                "        let backslashes = false;",
                "        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {",
                "          if (first === \"\\\\\") {",
                "            backslashes = true;",
                "            return m;",
                "          }",
                "          if (first === \"?\") {",
                "            if (esc) {",
                "              return esc + first + (rest ? QMARK.repeat(rest.length) : \"\");",
                "            }",
                "            if (index === 0) {",
                "              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : \"\");",
                "            }",
                "            return QMARK.repeat(chars.length);",
                "          }",
                "          if (first === \".\") {",
                "            return DOT_LITERAL.repeat(chars.length);",
                "          }",
                "          if (first === \"*\") {",
                "            if (esc) {",
                "              return esc + first + (rest ? star : \"\");",
                "            }",
                "            return star;",
                "          }",
                "          return esc ? m : `\\\\${m}`;",
                "        });",
                "        if (backslashes === true) {",
                "          if (opts.unescape === true) {",
                "            output = output.replace(/\\\\/g, \"\");",
                "          } else {",
                "            output = output.replace(/\\\\+/g, (m) => {",
                "              return m.length % 2 === 0 ? \"\\\\\\\\\" : m ? \"\\\\\" : \"\";",
                "            });",
                "          }",
                "        }",
                "        if (output === input && opts.contains === true) {",
                "          state.output = input;",
                "          return state;",
                "        }",
                "        state.output = utils.wrapOutput(output, state, options);",
                "        return state;",
                "      }",
                "      while (!eos()) {",
                "        value = advance();",
                "        if (value === \"\\0\") {",
                "          continue;",
                "        }",
                "        if (value === \"\\\\\") {",
                "          const next = peek();",
                "          if (next === \"/\" && opts.bash !== true) {",
                "            continue;",
                "          }",
                "          if (next === \".\" || next === \";\") {",
                "            continue;",
                "          }",
                "          if (!next) {",
                "            value += \"\\\\\";",
                "            push({ type: \"text\", value });",
                "            continue;",
                "          }",
                "          const match = /^\\\\+/.exec(remaining());",
                "          let slashes = 0;",
                "          if (match && match[0].length > 2) {",
                "            slashes = match[0].length;",
                "            state.index += slashes;",
                "            if (slashes % 2 !== 0) {",
                "              value += \"\\\\\";",
                "            }",
                "          }",
                "          if (opts.unescape === true) {",
                "            value = advance();",
                "          } else {",
                "            value += advance();",
                "          }",
                "          if (state.brackets === 0) {",
                "            push({ type: \"text\", value });",
                "            continue;",
                "          }",
                "        }",
                "        if (state.brackets > 0 && (value !== \"]\" || prev.value === \"[\" || prev.value === \"[^\")) {",
                "          if (opts.posix !== false && value === \":\") {",
                "            const inner = prev.value.slice(1);",
                "            if (inner.includes(\"[\")) {",
                "              prev.posix = true;",
                "              if (inner.includes(\":\")) {",
                "                const idx = prev.value.lastIndexOf(\"[\");",
                "                const pre = prev.value.slice(0, idx);",
                "                const rest2 = prev.value.slice(idx + 2);",
                "                const posix = POSIX_REGEX_SOURCE[rest2];",
                "                if (posix) {",
                "                  prev.value = pre + posix;",
                "                  state.backtrack = true;",
                "                  advance();",
                "                  if (!bos.output && tokens.indexOf(prev) === 1) {",
                "                    bos.output = ONE_CHAR;",
                "                  }",
                "                  continue;",
                "                }",
                "              }",
                "            }",
                "          }",
                "          if (value === \"[\" && peek() !== \":\" || value === \"-\" && peek() === \"]\") {",
                "            value = `\\\\${value}`;",
                "          }",
                "          if (value === \"]\" && (prev.value === \"[\" || prev.value === \"[^\")) {",
                "            value = `\\\\${value}`;",
                "          }",
                "          if (opts.posix === true && value === \"!\" && prev.value === \"[\") {",
                "            value = \"^\";",
                "          }",
                "          prev.value += value;",
                "          append({ value });",
                "          continue;",
                "        }",
                "        if (state.quotes === 1 && value !== '\"') {",
                "          value = utils.escapeRegex(value);",
                "          prev.value += value;",
                "          append({ value });",
                "          continue;",
                "        }",
                "        if (value === '\"') {",
                "          state.quotes = state.quotes === 1 ? 0 : 1;",
                "          if (opts.keepQuotes === true) {",
                "            push({ type: \"text\", value });",
                "          }",
                "          continue;",
                "        }",
                "        if (value === \"(\") {",
                "          increment(\"parens\");",
                "          push({ type: \"paren\", value });",
                "          continue;",
                "        }",
                "        if (value === \")\") {",
                "          if (state.parens === 0 && opts.strictBrackets === true) {",
                "            throw new SyntaxError(syntaxError(\"opening\", \"(\"));",
                "          }",
                "          const extglob = extglobs[extglobs.length - 1];",
                "          if (extglob && state.parens === extglob.parens + 1) {",
                "            extglobClose(extglobs.pop());",
                "            continue;",
                "          }",
                "          push({ type: \"paren\", value, output: state.parens ? \")\" : \"\\\\)\" });",
                "          decrement(\"parens\");",
                "          continue;",
                "        }",
                "        if (value === \"[\") {",
                "          if (opts.nobracket === true || !remaining().includes(\"]\")) {",
                "            if (opts.nobracket !== true && opts.strictBrackets === true) {",
                "              throw new SyntaxError(syntaxError(\"closing\", \"]\"));",
                "            }",
                "            value = `\\\\${value}`;",
                "          } else {",
                "            increment(\"brackets\");",
                "          }",
                "          push({ type: \"bracket\", value });",
                "          continue;",
                "        }",
                "        if (value === \"]\") {",
                "          if (opts.nobracket === true || prev && prev.type === \"bracket\" && prev.value.length === 1) {",
                "            push({ type: \"text\", value, output: `\\\\${value}` });",
                "            continue;",
                "          }",
                "          if (state.brackets === 0) {",
                "            if (opts.strictBrackets === true) {",
                "              throw new SyntaxError(syntaxError(\"opening\", \"[\"));",
                "            }",
                "            push({ type: \"text\", value, output: `\\\\${value}` });",
                "            continue;",
                "          }",
                "          decrement(\"brackets\");",
                "          const prevValue = prev.value.slice(1);",
                "          if (prev.posix !== true && prevValue[0] === \"^\" && !prevValue.includes(\"/\")) {",
                "            value = `/${value}`;",
                "          }",
                "          prev.value += value;",
                "          append({ value });",
                "          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {",
                "            continue;",
                "          }",
                "          const escaped = utils.escapeRegex(prev.value);",
                "          state.output = state.output.slice(0, -prev.value.length);",
                "          if (opts.literalBrackets === true) {",
                "            state.output += escaped;",
                "            prev.value = escaped;",
                "            continue;",
                "          }",
                "          prev.value = `(${capture}${escaped}|${prev.value})`;",
                "          state.output += prev.value;",
                "          continue;",
                "        }",
                "        if (value === \"{\" && opts.nobrace !== true) {",
                "          increment(\"braces\");",
                "          const open = {",
                "            type: \"brace\",",
                "            value,",
                "            output: \"(\",",
                "            outputIndex: state.output.length,",
                "            tokensIndex: state.tokens.length",
                "          };",
                "          braces.push(open);",
                "          push(open);",
                "          continue;",
                "        }",
                "        if (value === \"}\") {",
                "          const brace = braces[braces.length - 1];",
                "          if (opts.nobrace === true || !brace) {",
                "            push({ type: \"text\", value, output: value });",
                "            continue;",
                "          }",
                "          let output = \")\";",
                "          if (brace.dots === true) {",
                "            const arr = tokens.slice();",
                "            const range = [];",
                "            for (let i = arr.length - 1; i >= 0; i--) {",
                "              tokens.pop();",
                "              if (arr[i].type === \"brace\") {",
                "                break;",
                "              }",
                "              if (arr[i].type !== \"dots\") {",
                "                range.unshift(arr[i].value);",
                "              }",
                "            }",
                "            output = expandRange(range, opts);",
                "            state.backtrack = true;",
                "          }",
                "          if (brace.comma !== true && brace.dots !== true) {",
                "            const out = state.output.slice(0, brace.outputIndex);",
                "            const toks = state.tokens.slice(brace.tokensIndex);",
                "            brace.value = brace.output = \"\\\\{\";",
                "            value = output = \"\\\\}\";",
                "            state.output = out;",
                "            for (const t of toks) {",
                "              state.output += t.output || t.value;",
                "            }",
                "          }",
                "          push({ type: \"brace\", value, output });",
                "          decrement(\"braces\");",
                "          braces.pop();",
                "          continue;",
                "        }",
                "        if (value === \"|\") {",
                "          if (extglobs.length > 0) {",
                "            extglobs[extglobs.length - 1].conditions++;",
                "          }",
                "          push({ type: \"text\", value });",
                "          continue;",
                "        }",
                "        if (value === \",\") {",
                "          let output = value;",
                "          const brace = braces[braces.length - 1];",
                "          if (brace && stack[stack.length - 1] === \"braces\") {",
                "            brace.comma = true;",
                "            output = \"|\";",
                "          }",
                "          push({ type: \"comma\", value, output });",
                "          continue;",
                "        }",
                "        if (value === \"/\") {",
                "          if (prev.type === \"dot\" && state.index === state.start + 1) {",
                "            state.start = state.index + 1;",
                "            state.consumed = \"\";",
                "            state.output = \"\";",
                "            tokens.pop();",
                "            prev = bos;",
                "            continue;",
                "          }",
                "          push({ type: \"slash\", value, output: SLASH_LITERAL });",
                "          continue;",
                "        }",
                "        if (value === \".\") {",
                "          if (state.braces > 0 && prev.type === \"dot\") {",
                "            if (prev.value === \".\")",
                "              prev.output = DOT_LITERAL;",
                "            const brace = braces[braces.length - 1];",
                "            prev.type = \"dots\";",
                "            prev.output += value;",
                "            prev.value += value;",
                "            brace.dots = true;",
                "            continue;",
                "          }",
                "          if (state.braces + state.parens === 0 && prev.type !== \"bos\" && prev.type !== \"slash\") {",
                "            push({ type: \"text\", value, output: DOT_LITERAL });",
                "            continue;",
                "          }",
                "          push({ type: \"dot\", value, output: DOT_LITERAL });",
                "          continue;",
                "        }",
                "        if (value === \"?\") {",
                "          const isGroup = prev && prev.value === \"(\";",
                "          if (!isGroup && opts.noextglob !== true && peek() === \"(\" && peek(2) !== \"?\") {",
                "            extglobOpen(\"qmark\", value);",
                "            continue;",
                "          }",
                "          if (prev && prev.type === \"paren\") {",
                "            const next = peek();",
                "            let output = value;",
                "            if (next === \"<\" && !utils.supportsLookbehinds()) {",
                "              throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");",
                "            }",
                "            if (prev.value === \"(\" && !/[!=<:]/.test(next) || next === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {",
                "              output = `\\\\${value}`;",
                "            }",
                "            push({ type: \"text\", value, output });",
                "            continue;",
                "          }",
                "          if (opts.dot !== true && (prev.type === \"slash\" || prev.type === \"bos\")) {",
                "            push({ type: \"qmark\", value, output: QMARK_NO_DOT });",
                "            continue;",
                "          }",
                "          push({ type: \"qmark\", value, output: QMARK });",
                "          continue;",
                "        }",
                "        if (value === \"!\") {",
                "          if (opts.noextglob !== true && peek() === \"(\") {",
                "            if (peek(2) !== \"?\" || !/[!=<:]/.test(peek(3))) {",
                "              extglobOpen(\"negate\", value);",
                "              continue;",
                "            }",
                "          }",
                "          if (opts.nonegate !== true && state.index === 0) {",
                "            negate();",
                "            continue;",
                "          }",
                "        }",
                "        if (value === \"+\") {",
                "          if (opts.noextglob !== true && peek() === \"(\" && peek(2) !== \"?\") {",
                "            extglobOpen(\"plus\", value);",
                "            continue;",
                "          }",
                "          if (prev && prev.value === \"(\" || opts.regex === false) {",
                "            push({ type: \"plus\", value, output: PLUS_LITERAL });",
                "            continue;",
                "          }",
                "          if (prev && (prev.type === \"bracket\" || prev.type === \"paren\" || prev.type === \"brace\") || state.parens > 0) {",
                "            push({ type: \"plus\", value });",
                "            continue;",
                "          }",
                "          push({ type: \"plus\", value: PLUS_LITERAL });",
                "          continue;",
                "        }",
                "        if (value === \"@\") {",
                "          if (opts.noextglob !== true && peek() === \"(\" && peek(2) !== \"?\") {",
                "            push({ type: \"at\", extglob: true, value, output: \"\" });",
                "            continue;",
                "          }",
                "          push({ type: \"text\", value });",
                "          continue;",
                "        }",
                "        if (value !== \"*\") {",
                "          if (value === \"$\" || value === \"^\") {",
                "            value = `\\\\${value}`;",
                "          }",
                "          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());",
                "          if (match) {",
                "            value += match[0];",
                "            state.index += match[0].length;",
                "          }",
                "          push({ type: \"text\", value });",
                "          continue;",
                "        }",
                "        if (prev && (prev.type === \"globstar\" || prev.star === true)) {",
                "          prev.type = \"star\";",
                "          prev.star = true;",
                "          prev.value += value;",
                "          prev.output = star;",
                "          state.backtrack = true;",
                "          state.globstar = true;",
                "          consume(value);",
                "          continue;",
                "        }",
                "        let rest = remaining();",
                "        if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {",
                "          extglobOpen(\"star\", value);",
                "          continue;",
                "        }",
                "        if (prev.type === \"star\") {",
                "          if (opts.noglobstar === true) {",
                "            consume(value);",
                "            continue;",
                "          }",
                "          const prior = prev.prev;",
                "          const before = prior.prev;",
                "          const isStart = prior.type === \"slash\" || prior.type === \"bos\";",
                "          const afterStar = before && (before.type === \"star\" || before.type === \"globstar\");",
                "          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== \"/\")) {",
                "            push({ type: \"star\", value, output: \"\" });",
                "            continue;",
                "          }",
                "          const isBrace = state.braces > 0 && (prior.type === \"comma\" || prior.type === \"brace\");",
                "          const isExtglob = extglobs.length && (prior.type === \"pipe\" || prior.type === \"paren\");",
                "          if (!isStart && prior.type !== \"paren\" && !isBrace && !isExtglob) {",
                "            push({ type: \"star\", value, output: \"\" });",
                "            continue;",
                "          }",
                "          while (rest.slice(0, 3) === \"/**\") {",
                "            const after = input[state.index + 4];",
                "            if (after && after !== \"/\") {",
                "              break;",
                "            }",
                "            rest = rest.slice(3);",
                "            consume(\"/**\", 3);",
                "          }",
                "          if (prior.type === \"bos\" && eos()) {",
                "            prev.type = \"globstar\";",
                "            prev.value += value;",
                "            prev.output = globstar(opts);",
                "            state.output = prev.output;",
                "            state.globstar = true;",
                "            consume(value);",
                "            continue;",
                "          }",
                "          if (prior.type === \"slash\" && prior.prev.type !== \"bos\" && !afterStar && eos()) {",
                "            state.output = state.output.slice(0, -(prior.output + prev.output).length);",
                "            prior.output = `(?:${prior.output}`;",
                "            prev.type = \"globstar\";",
                "            prev.output = globstar(opts) + (opts.strictSlashes ? \")\" : \"|$)\");",
                "            prev.value += value;",
                "            state.globstar = true;",
                "            state.output += prior.output + prev.output;",
                "            consume(value);",
                "            continue;",
                "          }",
                "          if (prior.type === \"slash\" && prior.prev.type !== \"bos\" && rest[0] === \"/\") {",
                "            const end = rest[1] !== void 0 ? \"|$\" : \"\";",
                "            state.output = state.output.slice(0, -(prior.output + prev.output).length);",
                "            prior.output = `(?:${prior.output}`;",
                "            prev.type = \"globstar\";",
                "            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;",
                "            prev.value += value;",
                "            state.output += prior.output + prev.output;",
                "            state.globstar = true;",
                "            consume(value + advance());",
                "            push({ type: \"slash\", value: \"/\", output: \"\" });",
                "            continue;",
                "          }",
                "          if (prior.type === \"bos\" && rest[0] === \"/\") {",
                "            prev.type = \"globstar\";",
                "            prev.value += value;",
                "            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;",
                "            state.output = prev.output;",
                "            state.globstar = true;",
                "            consume(value + advance());",
                "            push({ type: \"slash\", value: \"/\", output: \"\" });",
                "            continue;",
                "          }",
                "          state.output = state.output.slice(0, -prev.output.length);",
                "          prev.type = \"globstar\";",
                "          prev.output = globstar(opts);",
                "          prev.value += value;",
                "          state.output += prev.output;",
                "          state.globstar = true;",
                "          consume(value);",
                "          continue;",
                "        }",
                "        const token = { type: \"star\", value, output: star };",
                "        if (opts.bash === true) {",
                "          token.output = \".*?\";",
                "          if (prev.type === \"bos\" || prev.type === \"slash\") {",
                "            token.output = nodot + token.output;",
                "          }",
                "          push(token);",
                "          continue;",
                "        }",
                "        if (prev && (prev.type === \"bracket\" || prev.type === \"paren\") && opts.regex === true) {",
                "          token.output = value;",
                "          push(token);",
                "          continue;",
                "        }",
                "        if (state.index === state.start || prev.type === \"slash\" || prev.type === \"dot\") {",
                "          if (prev.type === \"dot\") {",
                "            state.output += NO_DOT_SLASH;",
                "            prev.output += NO_DOT_SLASH;",
                "          } else if (opts.dot === true) {",
                "            state.output += NO_DOTS_SLASH;",
                "            prev.output += NO_DOTS_SLASH;",
                "          } else {",
                "            state.output += nodot;",
                "            prev.output += nodot;",
                "          }",
                "          if (peek() !== \"*\") {",
                "            state.output += ONE_CHAR;",
                "            prev.output += ONE_CHAR;",
                "          }",
                "        }",
                "        push(token);",
                "      }",
                "      while (state.brackets > 0) {",
                "        if (opts.strictBrackets === true)",
                "          throw new SyntaxError(syntaxError(\"closing\", \"]\"));",
                "        state.output = utils.escapeLast(state.output, \"[\");",
                "        decrement(\"brackets\");",
                "      }",
                "      while (state.parens > 0) {",
                "        if (opts.strictBrackets === true)",
                "          throw new SyntaxError(syntaxError(\"closing\", \")\"));",
                "        state.output = utils.escapeLast(state.output, \"(\");",
                "        decrement(\"parens\");",
                "      }",
                "      while (state.braces > 0) {",
                "        if (opts.strictBrackets === true)",
                "          throw new SyntaxError(syntaxError(\"closing\", \"}\"));",
                "        state.output = utils.escapeLast(state.output, \"{\");",
                "        decrement(\"braces\");",
                "      }",
                "      if (opts.strictSlashes !== true && (prev.type === \"star\" || prev.type === \"bracket\")) {",
                "        push({ type: \"maybe_slash\", value: \"\", output: `${SLASH_LITERAL}?` });",
                "      }",
                "      if (state.backtrack === true) {",
                "        state.output = \"\";",
                "        for (const token of state.tokens) {",
                "          state.output += token.output != null ? token.output : token.value;",
                "          if (token.suffix) {",
                "            state.output += token.suffix;",
                "          }",
                "        }",
                "      }",
                "      return state;",
                "    };",
                "    parse.fastpaths = (input, options) => {",
                "      const opts = { ...options };",
                "      const max = typeof opts.maxLength === \"number\" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;",
                "      const len = input.length;",
                "      if (len > max) {",
                "        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);",
                "      }",
                "      input = REPLACEMENTS[input] || input;",
                "      const win32 = utils.isWindows(options);",
                "      const {",
                "        DOT_LITERAL,",
                "        SLASH_LITERAL,",
                "        ONE_CHAR,",
                "        DOTS_SLASH,",
                "        NO_DOT,",
                "        NO_DOTS,",
                "        NO_DOTS_SLASH,",
                "        STAR,",
                "        START_ANCHOR",
                "      } = constants.globChars(win32);",
                "      const nodot = opts.dot ? NO_DOTS : NO_DOT;",
                "      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;",
                "      const capture = opts.capture ? \"\" : \"?:\";",
                "      const state = { negated: false, prefix: \"\" };",
                "      let star = opts.bash === true ? \".*?\" : STAR;",
                "      if (opts.capture) {",
                "        star = `(${star})`;",
                "      }",
                "      const globstar = (opts2) => {",
                "        if (opts2.noglobstar === true)",
                "          return star;",
                "        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;",
                "      };",
                "      const create = (str) => {",
                "        switch (str) {",
                "          case \"*\":",
                "            return `${nodot}${ONE_CHAR}${star}`;",
                "          case \".*\":",
                "            return `${DOT_LITERAL}${ONE_CHAR}${star}`;",
                "          case \"*.*\":",
                "            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;",
                "          case \"*/*\":",
                "            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;",
                "          case \"**\":",
                "            return nodot + globstar(opts);",
                "          case \"**/*\":",
                "            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;",
                "          case \"**/*.*\":",
                "            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;",
                "          case \"**/.*\":",
                "            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;",
                "          default: {",
                "            const match = /^(.*?)\\.(\\w+)$/.exec(str);",
                "            if (!match)",
                "              return;",
                "            const source2 = create(match[1]);",
                "            if (!source2)",
                "              return;",
                "            return source2 + DOT_LITERAL + match[2];",
                "          }",
                "        }",
                "      };",
                "      const output = utils.removePrefix(input, state);",
                "      let source = create(output);",
                "      if (source && opts.strictSlashes !== true) {",
                "        source += `${SLASH_LITERAL}?`;",
                "      }",
                "      return source;",
                "    };",
                "    module2.exports = parse;",
                "  }",
                "});",
                "",
                "// node_modules/picomatch/lib/picomatch.js",
                "var require_picomatch = __commonJS({",
                "  \"node_modules/picomatch/lib/picomatch.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var path2 = require(\"path\");",
                "    var scan = require_scan();",
                "    var parse = require_parse2();",
                "    var utils = require_utils2();",
                "    var constants = require_constants2();",
                "    var isObject = (val) => val && typeof val === \"object\" && !Array.isArray(val);",
                "    var picomatch = (glob, options, returnState = false) => {",
                "      if (Array.isArray(glob)) {",
                "        const fns = glob.map((input) => picomatch(input, options, returnState));",
                "        const arrayMatcher = (str) => {",
                "          for (const isMatch of fns) {",
                "            const state2 = isMatch(str);",
                "            if (state2)",
                "              return state2;",
                "          }",
                "          return false;",
                "        };",
                "        return arrayMatcher;",
                "      }",
                "      const isState = isObject(glob) && glob.tokens && glob.input;",
                "      if (glob === \"\" || typeof glob !== \"string\" && !isState) {",
                "        throw new TypeError(\"Expected pattern to be a non-empty string\");",
                "      }",
                "      const opts = options || {};",
                "      const posix = utils.isWindows(options);",
                "      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);",
                "      const state = regex.state;",
                "      delete regex.state;",
                "      let isIgnored = () => false;",
                "      if (opts.ignore) {",
                "        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };",
                "        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);",
                "      }",
                "      const matcher = (input, returnObject = false) => {",
                "        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });",
                "        const result = { glob, state, regex, posix, input, output, match, isMatch };",
                "        if (typeof opts.onResult === \"function\") {",
                "          opts.onResult(result);",
                "        }",
                "        if (isMatch === false) {",
                "          result.isMatch = false;",
                "          return returnObject ? result : false;",
                "        }",
                "        if (isIgnored(input)) {",
                "          if (typeof opts.onIgnore === \"function\") {",
                "            opts.onIgnore(result);",
                "          }",
                "          result.isMatch = false;",
                "          return returnObject ? result : false;",
                "        }",
                "        if (typeof opts.onMatch === \"function\") {",
                "          opts.onMatch(result);",
                "        }",
                "        return returnObject ? result : true;",
                "      };",
                "      if (returnState) {",
                "        matcher.state = state;",
                "      }",
                "      return matcher;",
                "    };",
                "    picomatch.test = (input, regex, options, { glob, posix } = {}) => {",
                "      if (typeof input !== \"string\") {",
                "        throw new TypeError(\"Expected input to be a string\");",
                "      }",
                "      if (input === \"\") {",
                "        return { isMatch: false, output: \"\" };",
                "      }",
                "      const opts = options || {};",
                "      const format = opts.format || (posix ? utils.toPosixSlashes : null);",
                "      let match = input === glob;",
                "      let output = match && format ? format(input) : input;",
                "      if (match === false) {",
                "        output = format ? format(input) : input;",
                "        match = output === glob;",
                "      }",
                "      if (match === false || opts.capture === true) {",
                "        if (opts.matchBase === true || opts.basename === true) {",
                "          match = picomatch.matchBase(input, regex, options, posix);",
                "        } else {",
                "          match = regex.exec(output);",
                "        }",
                "      }",
                "      return { isMatch: Boolean(match), match, output };",
                "    };",
                "    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {",
                "      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);",
                "      return regex.test(path2.basename(input));",
                "    };",
                "    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);",
                "    picomatch.parse = (pattern, options) => {",
                "      if (Array.isArray(pattern))",
                "        return pattern.map((p) => picomatch.parse(p, options));",
                "      return parse(pattern, { ...options, fastpaths: false });",
                "    };",
                "    picomatch.scan = (input, options) => scan(input, options);",
                "    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {",
                "      if (returnOutput === true) {",
                "        return state.output;",
                "      }",
                "      const opts = options || {};",
                "      const prepend = opts.contains ? \"\" : \"^\";",
                "      const append = opts.contains ? \"\" : \"$\";",
                "      let source = `${prepend}(?:${state.output})${append}`;",
                "      if (state && state.negated === true) {",
                "        source = `^(?!${source}).*$`;",
                "      }",
                "      const regex = picomatch.toRegex(source, options);",
                "      if (returnState === true) {",
                "        regex.state = state;",
                "      }",
                "      return regex;",
                "    };",
                "    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {",
                "      if (!input || typeof input !== \"string\") {",
                "        throw new TypeError(\"Expected a non-empty string\");",
                "      }",
                "      let parsed = { negated: false, fastpaths: true };",
                "      if (options.fastpaths !== false && (input[0] === \".\" || input[0] === \"*\")) {",
                "        parsed.output = parse.fastpaths(input, options);",
                "      }",
                "      if (!parsed.output) {",
                "        parsed = parse(input, options);",
                "      }",
                "      return picomatch.compileRe(parsed, options, returnOutput, returnState);",
                "    };",
                "    picomatch.toRegex = (source, options) => {",
                "      try {",
                "        const opts = options || {};",
                "        return new RegExp(source, opts.flags || (opts.nocase ? \"i\" : \"\"));",
                "      } catch (err) {",
                "        if (options && options.debug === true)",
                "          throw err;",
                "        return /$^/;",
                "      }",
                "    };",
                "    picomatch.constants = constants;",
                "    module2.exports = picomatch;",
                "  }",
                "});",
                "",
                "// node_modules/picomatch/index.js",
                "var require_picomatch2 = __commonJS({",
                "  \"node_modules/picomatch/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = require_picomatch();",
                "  }",
                "});",
                "",
                "// node_modules/micromatch/index.js",
                "var require_micromatch = __commonJS({",
                "  \"node_modules/micromatch/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var util = require(\"util\");",
                "    var braces = require_braces();",
                "    var picomatch = require_picomatch2();",
                "    var utils = require_utils2();",
                "    var isEmptyString = (val) => val === \"\" || val === \"./\";",
                "    var micromatch = (list, patterns, options) => {",
                "      patterns = [].concat(patterns);",
                "      list = [].concat(list);",
                "      let omit = /* @__PURE__ */ new Set();",
                "      let keep = /* @__PURE__ */ new Set();",
                "      let items = /* @__PURE__ */ new Set();",
                "      let negatives = 0;",
                "      let onResult = (state) => {",
                "        items.add(state.output);",
                "        if (options && options.onResult) {",
                "          options.onResult(state);",
                "        }",
                "      };",
                "      for (let i = 0; i < patterns.length; i++) {",
                "        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);",
                "        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;",
                "        if (negated)",
                "          negatives++;",
                "        for (let item of list) {",
                "          let matched = isMatch(item, true);",
                "          let match = negated ? !matched.isMatch : matched.isMatch;",
                "          if (!match)",
                "            continue;",
                "          if (negated) {",
                "            omit.add(matched.output);",
                "          } else {",
                "            omit.delete(matched.output);",
                "            keep.add(matched.output);",
                "          }",
                "        }",
                "      }",
                "      let result = negatives === patterns.length ? [...items] : [...keep];",
                "      let matches = result.filter((item) => !omit.has(item));",
                "      if (options && matches.length === 0) {",
                "        if (options.failglob === true) {",
                "          throw new Error(`No matches found for \"${patterns.join(\", \")}\"`);",
                "        }",
                "        if (options.nonull === true || options.nullglob === true) {",
                "          return options.unescape ? patterns.map((p) => p.replace(/\\\\/g, \"\")) : patterns;",
                "        }",
                "      }",
                "      return matches;",
                "    };",
                "    micromatch.match = micromatch;",
                "    micromatch.matcher = (pattern, options) => picomatch(pattern, options);",
                "    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);",
                "    micromatch.any = micromatch.isMatch;",
                "    micromatch.not = (list, patterns, options = {}) => {",
                "      patterns = [].concat(patterns).map(String);",
                "      let result = /* @__PURE__ */ new Set();",
                "      let items = [];",
                "      let onResult = (state) => {",
                "        if (options.onResult)",
                "          options.onResult(state);",
                "        items.push(state.output);",
                "      };",
                "      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));",
                "      for (let item of items) {",
                "        if (!matches.has(item)) {",
                "          result.add(item);",
                "        }",
                "      }",
                "      return [...result];",
                "    };",
                "    micromatch.contains = (str, pattern, options) => {",
                "      if (typeof str !== \"string\") {",
                "        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);",
                "      }",
                "      if (Array.isArray(pattern)) {",
                "        return pattern.some((p) => micromatch.contains(str, p, options));",
                "      }",
                "      if (typeof pattern === \"string\") {",
                "        if (isEmptyString(str) || isEmptyString(pattern)) {",
                "          return false;",
                "        }",
                "        if (str.includes(pattern) || str.startsWith(\"./\") && str.slice(2).includes(pattern)) {",
                "          return true;",
                "        }",
                "      }",
                "      return micromatch.isMatch(str, pattern, { ...options, contains: true });",
                "    };",
                "    micromatch.matchKeys = (obj, patterns, options) => {",
                "      if (!utils.isObject(obj)) {",
                "        throw new TypeError(\"Expected the first argument to be an object\");",
                "      }",
                "      let keys = micromatch(Object.keys(obj), patterns, options);",
                "      let res = {};",
                "      for (let key of keys)",
                "        res[key] = obj[key];",
                "      return res;",
                "    };",
                "    micromatch.some = (list, patterns, options) => {",
                "      let items = [].concat(list);",
                "      for (let pattern of [].concat(patterns)) {",
                "        let isMatch = picomatch(String(pattern), options);",
                "        if (items.some((item) => isMatch(item))) {",
                "          return true;",
                "        }",
                "      }",
                "      return false;",
                "    };",
                "    micromatch.every = (list, patterns, options) => {",
                "      let items = [].concat(list);",
                "      for (let pattern of [].concat(patterns)) {",
                "        let isMatch = picomatch(String(pattern), options);",
                "        if (!items.every((item) => isMatch(item))) {",
                "          return false;",
                "        }",
                "      }",
                "      return true;",
                "    };",
                "    micromatch.all = (str, patterns, options) => {",
                "      if (typeof str !== \"string\") {",
                "        throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);",
                "      }",
                "      return [].concat(patterns).every((p) => picomatch(p, options)(str));",
                "    };",
                "    micromatch.capture = (glob, input, options) => {",
                "      let posix = utils.isWindows(options);",
                "      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });",
                "      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);",
                "      if (match) {",
                "        return match.slice(1).map((v) => v === void 0 ? \"\" : v);",
                "      }",
                "    };",
                "    micromatch.makeRe = (...args) => picomatch.makeRe(...args);",
                "    micromatch.scan = (...args) => picomatch.scan(...args);",
                "    micromatch.parse = (patterns, options) => {",
                "      let res = [];",
                "      for (let pattern of [].concat(patterns || [])) {",
                "        for (let str of braces(String(pattern), options)) {",
                "          res.push(picomatch.parse(str, options));",
                "        }",
                "      }",
                "      return res;",
                "    };",
                "    micromatch.braces = (pattern, options) => {",
                "      if (typeof pattern !== \"string\")",
                "        throw new TypeError(\"Expected a string\");",
                "      if (options && options.nobrace === true || !/\\{.*\\}/.test(pattern)) {",
                "        return [pattern];",
                "      }",
                "      return braces(pattern, options);",
                "    };",
                "    micromatch.braceExpand = (pattern, options) => {",
                "      if (typeof pattern !== \"string\")",
                "        throw new TypeError(\"Expected a string\");",
                "      return micromatch.braces(pattern, { ...options, expand: true });",
                "    };",
                "    module2.exports = micromatch;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/utils/pattern.js",
                "var require_pattern = __commonJS({",
                "  \"node_modules/fast-glob/out/utils/pattern.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.matchAny = exports.convertPatternsToRe = exports.makeRe = exports.getPatternParts = exports.expandBraceExpansion = exports.expandPatternsWithBraceExpansion = exports.isAffectDepthOfReadingPattern = exports.endsWithSlashGlobStar = exports.hasGlobStar = exports.getBaseDirectory = exports.isPatternRelatedToParentDirectory = exports.getPatternsOutsideCurrentDirectory = exports.getPatternsInsideCurrentDirectory = exports.getPositivePatterns = exports.getNegativePatterns = exports.isPositivePattern = exports.isNegativePattern = exports.convertToNegativePattern = exports.convertToPositivePattern = exports.isDynamicPattern = exports.isStaticPattern = void 0;",
                "    var path2 = require(\"path\");",
                "    var globParent = require_glob_parent();",
                "    var micromatch = require_micromatch();",
                "    var GLOBSTAR = \"**\";",
                "    var ESCAPE_SYMBOL = \"\\\\\";",
                "    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;",
                "    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\\[[^[]*]/;",
                "    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\\([^(]*\\|[^|]*\\)/;",
                "    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\\([^(]*\\)/;",
                "    var BRACE_EXPANSION_SEPARATORS_RE = /,|\\.\\./;",
                "    function isStaticPattern(pattern, options = {}) {",
                "      return !isDynamicPattern(pattern, options);",
                "    }",
                "    exports.isStaticPattern = isStaticPattern;",
                "    function isDynamicPattern(pattern, options = {}) {",
                "      if (pattern === \"\") {",
                "        return false;",
                "      }",
                "      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {",
                "        return true;",
                "      }",
                "      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {",
                "        return true;",
                "      }",
                "      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {",
                "        return true;",
                "      }",
                "      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {",
                "        return true;",
                "      }",
                "      return false;",
                "    }",
                "    exports.isDynamicPattern = isDynamicPattern;",
                "    function hasBraceExpansion(pattern) {",
                "      const openingBraceIndex = pattern.indexOf(\"{\");",
                "      if (openingBraceIndex === -1) {",
                "        return false;",
                "      }",
                "      const closingBraceIndex = pattern.indexOf(\"}\", openingBraceIndex + 1);",
                "      if (closingBraceIndex === -1) {",
                "        return false;",
                "      }",
                "      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);",
                "      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);",
                "    }",
                "    function convertToPositivePattern(pattern) {",
                "      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;",
                "    }",
                "    exports.convertToPositivePattern = convertToPositivePattern;",
                "    function convertToNegativePattern(pattern) {",
                "      return \"!\" + pattern;",
                "    }",
                "    exports.convertToNegativePattern = convertToNegativePattern;",
                "    function isNegativePattern(pattern) {",
                "      return pattern.startsWith(\"!\") && pattern[1] !== \"(\";",
                "    }",
                "    exports.isNegativePattern = isNegativePattern;",
                "    function isPositivePattern(pattern) {",
                "      return !isNegativePattern(pattern);",
                "    }",
                "    exports.isPositivePattern = isPositivePattern;",
                "    function getNegativePatterns(patterns) {",
                "      return patterns.filter(isNegativePattern);",
                "    }",
                "    exports.getNegativePatterns = getNegativePatterns;",
                "    function getPositivePatterns(patterns) {",
                "      return patterns.filter(isPositivePattern);",
                "    }",
                "    exports.getPositivePatterns = getPositivePatterns;",
                "    function getPatternsInsideCurrentDirectory(patterns) {",
                "      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));",
                "    }",
                "    exports.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;",
                "    function getPatternsOutsideCurrentDirectory(patterns) {",
                "      return patterns.filter(isPatternRelatedToParentDirectory);",
                "    }",
                "    exports.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;",
                "    function isPatternRelatedToParentDirectory(pattern) {",
                "      return pattern.startsWith(\"..\") || pattern.startsWith(\"./..\");",
                "    }",
                "    exports.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;",
                "    function getBaseDirectory(pattern) {",
                "      return globParent(pattern, { flipBackslashes: false });",
                "    }",
                "    exports.getBaseDirectory = getBaseDirectory;",
                "    function hasGlobStar(pattern) {",
                "      return pattern.includes(GLOBSTAR);",
                "    }",
                "    exports.hasGlobStar = hasGlobStar;",
                "    function endsWithSlashGlobStar(pattern) {",
                "      return pattern.endsWith(\"/\" + GLOBSTAR);",
                "    }",
                "    exports.endsWithSlashGlobStar = endsWithSlashGlobStar;",
                "    function isAffectDepthOfReadingPattern(pattern) {",
                "      const basename = path2.basename(pattern);",
                "      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);",
                "    }",
                "    exports.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;",
                "    function expandPatternsWithBraceExpansion(patterns) {",
                "      return patterns.reduce((collection, pattern) => {",
                "        return collection.concat(expandBraceExpansion(pattern));",
                "      }, []);",
                "    }",
                "    exports.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;",
                "    function expandBraceExpansion(pattern) {",
                "      return micromatch.braces(pattern, {",
                "        expand: true,",
                "        nodupes: true",
                "      });",
                "    }",
                "    exports.expandBraceExpansion = expandBraceExpansion;",
                "    function getPatternParts(pattern, options) {",
                "      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));",
                "      if (parts.length === 0) {",
                "        parts = [pattern];",
                "      }",
                "      if (parts[0].startsWith(\"/\")) {",
                "        parts[0] = parts[0].slice(1);",
                "        parts.unshift(\"\");",
                "      }",
                "      return parts;",
                "    }",
                "    exports.getPatternParts = getPatternParts;",
                "    function makeRe(pattern, options) {",
                "      return micromatch.makeRe(pattern, options);",
                "    }",
                "    exports.makeRe = makeRe;",
                "    function convertPatternsToRe(patterns, options) {",
                "      return patterns.map((pattern) => makeRe(pattern, options));",
                "    }",
                "    exports.convertPatternsToRe = convertPatternsToRe;",
                "    function matchAny(entry, patternsRe) {",
                "      return patternsRe.some((patternRe) => patternRe.test(entry));",
                "    }",
                "    exports.matchAny = matchAny;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/utils/stream.js",
                "var require_stream = __commonJS({",
                "  \"node_modules/fast-glob/out/utils/stream.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.merge = void 0;",
                "    var merge2 = require_merge2();",
                "    function merge(streams) {",
                "      const mergedStream = merge2(streams);",
                "      streams.forEach((stream2) => {",
                "        stream2.once(\"error\", (error) => mergedStream.emit(\"error\", error));",
                "      });",
                "      mergedStream.once(\"close\", () => propagateCloseEventToSources(streams));",
                "      mergedStream.once(\"end\", () => propagateCloseEventToSources(streams));",
                "      return mergedStream;",
                "    }",
                "    exports.merge = merge;",
                "    function propagateCloseEventToSources(streams) {",
                "      streams.forEach((stream2) => stream2.emit(\"close\"));",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/utils/string.js",
                "var require_string = __commonJS({",
                "  \"node_modules/fast-glob/out/utils/string.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.isEmpty = exports.isString = void 0;",
                "    function isString(input) {",
                "      return typeof input === \"string\";",
                "    }",
                "    exports.isString = isString;",
                "    function isEmpty(input) {",
                "      return input === \"\";",
                "    }",
                "    exports.isEmpty = isEmpty;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/utils/index.js",
                "var require_utils3 = __commonJS({",
                "  \"node_modules/fast-glob/out/utils/index.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.string = exports.stream = exports.pattern = exports.path = exports.fs = exports.errno = exports.array = void 0;",
                "    var array = require_array();",
                "    exports.array = array;",
                "    var errno = require_errno();",
                "    exports.errno = errno;",
                "    var fs2 = require_fs();",
                "    exports.fs = fs2;",
                "    var path2 = require_path();",
                "    exports.path = path2;",
                "    var pattern = require_pattern();",
                "    exports.pattern = pattern;",
                "    var stream2 = require_stream();",
                "    exports.stream = stream2;",
                "    var string = require_string();",
                "    exports.string = string;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/managers/tasks.js",
                "var require_tasks = __commonJS({",
                "  \"node_modules/fast-glob/out/managers/tasks.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.convertPatternGroupToTask = exports.convertPatternGroupsToTasks = exports.groupPatternsByBaseDirectory = exports.getNegativePatternsAsPositive = exports.getPositivePatterns = exports.convertPatternsToTasks = exports.generate = void 0;",
                "    var utils = require_utils3();",
                "    function generate(patterns, settings) {",
                "      const positivePatterns = getPositivePatterns(patterns);",
                "      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);",
                "      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));",
                "      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));",
                "      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);",
                "      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);",
                "      return staticTasks.concat(dynamicTasks);",
                "    }",
                "    exports.generate = generate;",
                "    function convertPatternsToTasks(positive, negative, dynamic) {",
                "      const tasks = [];",
                "      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);",
                "      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);",
                "      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);",
                "      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);",
                "      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));",
                "      if (\".\" in insideCurrentDirectoryGroup) {",
                "        tasks.push(convertPatternGroupToTask(\".\", patternsInsideCurrentDirectory, negative, dynamic));",
                "      } else {",
                "        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));",
                "      }",
                "      return tasks;",
                "    }",
                "    exports.convertPatternsToTasks = convertPatternsToTasks;",
                "    function getPositivePatterns(patterns) {",
                "      return utils.pattern.getPositivePatterns(patterns);",
                "    }",
                "    exports.getPositivePatterns = getPositivePatterns;",
                "    function getNegativePatternsAsPositive(patterns, ignore) {",
                "      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);",
                "      const positive = negative.map(utils.pattern.convertToPositivePattern);",
                "      return positive;",
                "    }",
                "    exports.getNegativePatternsAsPositive = getNegativePatternsAsPositive;",
                "    function groupPatternsByBaseDirectory(patterns) {",
                "      const group = {};",
                "      return patterns.reduce((collection, pattern) => {",
                "        const base = utils.pattern.getBaseDirectory(pattern);",
                "        if (base in collection) {",
                "          collection[base].push(pattern);",
                "        } else {",
                "          collection[base] = [pattern];",
                "        }",
                "        return collection;",
                "      }, group);",
                "    }",
                "    exports.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;",
                "    function convertPatternGroupsToTasks(positive, negative, dynamic) {",
                "      return Object.keys(positive).map((base) => {",
                "        return convertPatternGroupToTask(base, positive[base], negative, dynamic);",
                "      });",
                "    }",
                "    exports.convertPatternGroupsToTasks = convertPatternGroupsToTasks;",
                "    function convertPatternGroupToTask(base, positive, negative, dynamic) {",
                "      return {",
                "        dynamic,",
                "        positive,",
                "        negative,",
                "        base,",
                "        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))",
                "      };",
                "    }",
                "    exports.convertPatternGroupToTask = convertPatternGroupToTask;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/managers/patterns.js",
                "var require_patterns = __commonJS({",
                "  \"node_modules/fast-glob/out/managers/patterns.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.removeDuplicateSlashes = exports.transform = void 0;",
                "    var DOUBLE_SLASH_RE = /(?!^)\\/{2,}/g;",
                "    function transform(patterns) {",
                "      return patterns.map((pattern) => removeDuplicateSlashes(pattern));",
                "    }",
                "    exports.transform = transform;",
                "    function removeDuplicateSlashes(pattern) {",
                "      return pattern.replace(DOUBLE_SLASH_RE, \"/\");",
                "    }",
                "    exports.removeDuplicateSlashes = removeDuplicateSlashes;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.stat/out/providers/async.js",
                "var require_async = __commonJS({",
                "  \"node_modules/@nodelib/fs.stat/out/providers/async.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.read = void 0;",
                "    function read(path2, settings, callback) {",
                "      settings.fs.lstat(path2, (lstatError, lstat) => {",
                "        if (lstatError !== null) {",
                "          callFailureCallback(callback, lstatError);",
                "          return;",
                "        }",
                "        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {",
                "          callSuccessCallback(callback, lstat);",
                "          return;",
                "        }",
                "        settings.fs.stat(path2, (statError, stat) => {",
                "          if (statError !== null) {",
                "            if (settings.throwErrorOnBrokenSymbolicLink) {",
                "              callFailureCallback(callback, statError);",
                "              return;",
                "            }",
                "            callSuccessCallback(callback, lstat);",
                "            return;",
                "          }",
                "          if (settings.markSymbolicLink) {",
                "            stat.isSymbolicLink = () => true;",
                "          }",
                "          callSuccessCallback(callback, stat);",
                "        });",
                "      });",
                "    }",
                "    exports.read = read;",
                "    function callFailureCallback(callback, error) {",
                "      callback(error);",
                "    }",
                "    function callSuccessCallback(callback, result) {",
                "      callback(null, result);",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.stat/out/providers/sync.js",
                "var require_sync = __commonJS({",
                "  \"node_modules/@nodelib/fs.stat/out/providers/sync.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.read = void 0;",
                "    function read(path2, settings) {",
                "      const lstat = settings.fs.lstatSync(path2);",
                "      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {",
                "        return lstat;",
                "      }",
                "      try {",
                "        const stat = settings.fs.statSync(path2);",
                "        if (settings.markSymbolicLink) {",
                "          stat.isSymbolicLink = () => true;",
                "        }",
                "        return stat;",
                "      } catch (error) {",
                "        if (!settings.throwErrorOnBrokenSymbolicLink) {",
                "          return lstat;",
                "        }",
                "        throw error;",
                "      }",
                "    }",
                "    exports.read = read;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.stat/out/adapters/fs.js",
                "var require_fs2 = __commonJS({",
                "  \"node_modules/@nodelib/fs.stat/out/adapters/fs.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;",
                "    var fs2 = require(\"fs\");",
                "    exports.FILE_SYSTEM_ADAPTER = {",
                "      lstat: fs2.lstat,",
                "      stat: fs2.stat,",
                "      lstatSync: fs2.lstatSync,",
                "      statSync: fs2.statSync",
                "    };",
                "    function createFileSystemAdapter(fsMethods) {",
                "      if (fsMethods === void 0) {",
                "        return exports.FILE_SYSTEM_ADAPTER;",
                "      }",
                "      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);",
                "    }",
                "    exports.createFileSystemAdapter = createFileSystemAdapter;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.stat/out/settings.js",
                "var require_settings = __commonJS({",
                "  \"node_modules/@nodelib/fs.stat/out/settings.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var fs2 = require_fs2();",
                "    var Settings = class {",
                "      constructor(_options = {}) {",
                "        this._options = _options;",
                "        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);",
                "        this.fs = fs2.createFileSystemAdapter(this._options.fs);",
                "        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);",
                "        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);",
                "      }",
                "      _getValue(option, value) {",
                "        return option !== null && option !== void 0 ? option : value;",
                "      }",
                "    };",
                "    exports.default = Settings;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.stat/out/index.js",
                "var require_out = __commonJS({",
                "  \"node_modules/@nodelib/fs.stat/out/index.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.statSync = exports.stat = exports.Settings = void 0;",
                "    var async = require_async();",
                "    var sync = require_sync();",
                "    var settings_1 = require_settings();",
                "    exports.Settings = settings_1.default;",
                "    function stat(path2, optionsOrSettingsOrCallback, callback) {",
                "      if (typeof optionsOrSettingsOrCallback === \"function\") {",
                "        async.read(path2, getSettings(), optionsOrSettingsOrCallback);",
                "        return;",
                "      }",
                "      async.read(path2, getSettings(optionsOrSettingsOrCallback), callback);",
                "    }",
                "    exports.stat = stat;",
                "    function statSync(path2, optionsOrSettings) {",
                "      const settings = getSettings(optionsOrSettings);",
                "      return sync.read(path2, settings);",
                "    }",
                "    exports.statSync = statSync;",
                "    function getSettings(settingsOrOptions = {}) {",
                "      if (settingsOrOptions instanceof settings_1.default) {",
                "        return settingsOrOptions;",
                "      }",
                "      return new settings_1.default(settingsOrOptions);",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/queue-microtask/index.js",
                "var require_queue_microtask = __commonJS({",
                "  \"node_modules/queue-microtask/index.js\"(exports, module2) {",
                "    var promise;",
                "    module2.exports = typeof queueMicrotask === \"function\" ? queueMicrotask.bind(typeof window !== \"undefined\" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {",
                "      throw err;",
                "    }, 0));",
                "  }",
                "});",
                "",
                "// node_modules/run-parallel/index.js",
                "var require_run_parallel = __commonJS({",
                "  \"node_modules/run-parallel/index.js\"(exports, module2) {",
                "    module2.exports = runParallel;",
                "    var queueMicrotask2 = require_queue_microtask();",
                "    function runParallel(tasks, cb) {",
                "      let results, pending, keys;",
                "      let isSync = true;",
                "      if (Array.isArray(tasks)) {",
                "        results = [];",
                "        pending = tasks.length;",
                "      } else {",
                "        keys = Object.keys(tasks);",
                "        results = {};",
                "        pending = keys.length;",
                "      }",
                "      function done(err) {",
                "        function end() {",
                "          if (cb)",
                "            cb(err, results);",
                "          cb = null;",
                "        }",
                "        if (isSync)",
                "          queueMicrotask2(end);",
                "        else",
                "          end();",
                "      }",
                "      function each(i, err, result) {",
                "        results[i] = result;",
                "        if (--pending === 0 || err) {",
                "          done(err);",
                "        }",
                "      }",
                "      if (!pending) {",
                "        done(null);",
                "      } else if (keys) {",
                "        keys.forEach(function(key) {",
                "          tasks[key](function(err, result) {",
                "            each(key, err, result);",
                "          });",
                "        });",
                "      } else {",
                "        tasks.forEach(function(task, i) {",
                "          task(function(err, result) {",
                "            each(i, err, result);",
                "          });",
                "        });",
                "      }",
                "      isSync = false;",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.scandir/out/constants.js",
                "var require_constants3 = __commonJS({",
                "  \"node_modules/@nodelib/fs.scandir/out/constants.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;",
                "    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(\".\");",
                "    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {",
                "      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);",
                "    }",
                "    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);",
                "    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);",
                "    var SUPPORTED_MAJOR_VERSION = 10;",
                "    var SUPPORTED_MINOR_VERSION = 10;",
                "    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;",
                "    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;",
                "    exports.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.scandir/out/utils/fs.js",
                "var require_fs3 = __commonJS({",
                "  \"node_modules/@nodelib/fs.scandir/out/utils/fs.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.createDirentFromStats = void 0;",
                "    var DirentFromStats = class {",
                "      constructor(name, stats) {",
                "        this.name = name;",
                "        this.isBlockDevice = stats.isBlockDevice.bind(stats);",
                "        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);",
                "        this.isDirectory = stats.isDirectory.bind(stats);",
                "        this.isFIFO = stats.isFIFO.bind(stats);",
                "        this.isFile = stats.isFile.bind(stats);",
                "        this.isSocket = stats.isSocket.bind(stats);",
                "        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);",
                "      }",
                "    };",
                "    function createDirentFromStats(name, stats) {",
                "      return new DirentFromStats(name, stats);",
                "    }",
                "    exports.createDirentFromStats = createDirentFromStats;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.scandir/out/utils/index.js",
                "var require_utils4 = __commonJS({",
                "  \"node_modules/@nodelib/fs.scandir/out/utils/index.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.fs = void 0;",
                "    var fs2 = require_fs3();",
                "    exports.fs = fs2;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.scandir/out/providers/common.js",
                "var require_common = __commonJS({",
                "  \"node_modules/@nodelib/fs.scandir/out/providers/common.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.joinPathSegments = void 0;",
                "    function joinPathSegments(a, b, separator) {",
                "      if (a.endsWith(separator)) {",
                "        return a + b;",
                "      }",
                "      return a + separator + b;",
                "    }",
                "    exports.joinPathSegments = joinPathSegments;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.scandir/out/providers/async.js",
                "var require_async2 = __commonJS({",
                "  \"node_modules/@nodelib/fs.scandir/out/providers/async.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;",
                "    var fsStat = require_out();",
                "    var rpl = require_run_parallel();",
                "    var constants_1 = require_constants3();",
                "    var utils = require_utils4();",
                "    var common = require_common();",
                "    function read(directory, settings, callback) {",
                "      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {",
                "        readdirWithFileTypes(directory, settings, callback);",
                "        return;",
                "      }",
                "      readdir(directory, settings, callback);",
                "    }",
                "    exports.read = read;",
                "    function readdirWithFileTypes(directory, settings, callback) {",
                "      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {",
                "        if (readdirError !== null) {",
                "          callFailureCallback(callback, readdirError);",
                "          return;",
                "        }",
                "        const entries = dirents.map((dirent) => ({",
                "          dirent,",
                "          name: dirent.name,",
                "          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)",
                "        }));",
                "        if (!settings.followSymbolicLinks) {",
                "          callSuccessCallback(callback, entries);",
                "          return;",
                "        }",
                "        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));",
                "        rpl(tasks, (rplError, rplEntries) => {",
                "          if (rplError !== null) {",
                "            callFailureCallback(callback, rplError);",
                "            return;",
                "          }",
                "          callSuccessCallback(callback, rplEntries);",
                "        });",
                "      });",
                "    }",
                "    exports.readdirWithFileTypes = readdirWithFileTypes;",
                "    function makeRplTaskEntry(entry, settings) {",
                "      return (done) => {",
                "        if (!entry.dirent.isSymbolicLink()) {",
                "          done(null, entry);",
                "          return;",
                "        }",
                "        settings.fs.stat(entry.path, (statError, stats) => {",
                "          if (statError !== null) {",
                "            if (settings.throwErrorOnBrokenSymbolicLink) {",
                "              done(statError);",
                "              return;",
                "            }",
                "            done(null, entry);",
                "            return;",
                "          }",
                "          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);",
                "          done(null, entry);",
                "        });",
                "      };",
                "    }",
                "    function readdir(directory, settings, callback) {",
                "      settings.fs.readdir(directory, (readdirError, names) => {",
                "        if (readdirError !== null) {",
                "          callFailureCallback(callback, readdirError);",
                "          return;",
                "        }",
                "        const tasks = names.map((name) => {",
                "          const path2 = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);",
                "          return (done) => {",
                "            fsStat.stat(path2, settings.fsStatSettings, (error, stats) => {",
                "              if (error !== null) {",
                "                done(error);",
                "                return;",
                "              }",
                "              const entry = {",
                "                name,",
                "                path: path2,",
                "                dirent: utils.fs.createDirentFromStats(name, stats)",
                "              };",
                "              if (settings.stats) {",
                "                entry.stats = stats;",
                "              }",
                "              done(null, entry);",
                "            });",
                "          };",
                "        });",
                "        rpl(tasks, (rplError, entries) => {",
                "          if (rplError !== null) {",
                "            callFailureCallback(callback, rplError);",
                "            return;",
                "          }",
                "          callSuccessCallback(callback, entries);",
                "        });",
                "      });",
                "    }",
                "    exports.readdir = readdir;",
                "    function callFailureCallback(callback, error) {",
                "      callback(error);",
                "    }",
                "    function callSuccessCallback(callback, result) {",
                "      callback(null, result);",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.scandir/out/providers/sync.js",
                "var require_sync2 = __commonJS({",
                "  \"node_modules/@nodelib/fs.scandir/out/providers/sync.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.readdir = exports.readdirWithFileTypes = exports.read = void 0;",
                "    var fsStat = require_out();",
                "    var constants_1 = require_constants3();",
                "    var utils = require_utils4();",
                "    var common = require_common();",
                "    function read(directory, settings) {",
                "      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {",
                "        return readdirWithFileTypes(directory, settings);",
                "      }",
                "      return readdir(directory, settings);",
                "    }",
                "    exports.read = read;",
                "    function readdirWithFileTypes(directory, settings) {",
                "      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });",
                "      return dirents.map((dirent) => {",
                "        const entry = {",
                "          dirent,",
                "          name: dirent.name,",
                "          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)",
                "        };",
                "        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {",
                "          try {",
                "            const stats = settings.fs.statSync(entry.path);",
                "            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);",
                "          } catch (error) {",
                "            if (settings.throwErrorOnBrokenSymbolicLink) {",
                "              throw error;",
                "            }",
                "          }",
                "        }",
                "        return entry;",
                "      });",
                "    }",
                "    exports.readdirWithFileTypes = readdirWithFileTypes;",
                "    function readdir(directory, settings) {",
                "      const names = settings.fs.readdirSync(directory);",
                "      return names.map((name) => {",
                "        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);",
                "        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);",
                "        const entry = {",
                "          name,",
                "          path: entryPath,",
                "          dirent: utils.fs.createDirentFromStats(name, stats)",
                "        };",
                "        if (settings.stats) {",
                "          entry.stats = stats;",
                "        }",
                "        return entry;",
                "      });",
                "    }",
                "    exports.readdir = readdir;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.scandir/out/adapters/fs.js",
                "var require_fs4 = __commonJS({",
                "  \"node_modules/@nodelib/fs.scandir/out/adapters/fs.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.createFileSystemAdapter = exports.FILE_SYSTEM_ADAPTER = void 0;",
                "    var fs2 = require(\"fs\");",
                "    exports.FILE_SYSTEM_ADAPTER = {",
                "      lstat: fs2.lstat,",
                "      stat: fs2.stat,",
                "      lstatSync: fs2.lstatSync,",
                "      statSync: fs2.statSync,",
                "      readdir: fs2.readdir,",
                "      readdirSync: fs2.readdirSync",
                "    };",
                "    function createFileSystemAdapter(fsMethods) {",
                "      if (fsMethods === void 0) {",
                "        return exports.FILE_SYSTEM_ADAPTER;",
                "      }",
                "      return Object.assign(Object.assign({}, exports.FILE_SYSTEM_ADAPTER), fsMethods);",
                "    }",
                "    exports.createFileSystemAdapter = createFileSystemAdapter;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.scandir/out/settings.js",
                "var require_settings2 = __commonJS({",
                "  \"node_modules/@nodelib/fs.scandir/out/settings.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var path2 = require(\"path\");",
                "    var fsStat = require_out();",
                "    var fs2 = require_fs4();",
                "    var Settings = class {",
                "      constructor(_options = {}) {",
                "        this._options = _options;",
                "        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);",
                "        this.fs = fs2.createFileSystemAdapter(this._options.fs);",
                "        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path2.sep);",
                "        this.stats = this._getValue(this._options.stats, false);",
                "        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);",
                "        this.fsStatSettings = new fsStat.Settings({",
                "          followSymbolicLink: this.followSymbolicLinks,",
                "          fs: this.fs,",
                "          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink",
                "        });",
                "      }",
                "      _getValue(option, value) {",
                "        return option !== null && option !== void 0 ? option : value;",
                "      }",
                "    };",
                "    exports.default = Settings;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.scandir/out/index.js",
                "var require_out2 = __commonJS({",
                "  \"node_modules/@nodelib/fs.scandir/out/index.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.Settings = exports.scandirSync = exports.scandir = void 0;",
                "    var async = require_async2();",
                "    var sync = require_sync2();",
                "    var settings_1 = require_settings2();",
                "    exports.Settings = settings_1.default;",
                "    function scandir(path2, optionsOrSettingsOrCallback, callback) {",
                "      if (typeof optionsOrSettingsOrCallback === \"function\") {",
                "        async.read(path2, getSettings(), optionsOrSettingsOrCallback);",
                "        return;",
                "      }",
                "      async.read(path2, getSettings(optionsOrSettingsOrCallback), callback);",
                "    }",
                "    exports.scandir = scandir;",
                "    function scandirSync(path2, optionsOrSettings) {",
                "      const settings = getSettings(optionsOrSettings);",
                "      return sync.read(path2, settings);",
                "    }",
                "    exports.scandirSync = scandirSync;",
                "    function getSettings(settingsOrOptions = {}) {",
                "      if (settingsOrOptions instanceof settings_1.default) {",
                "        return settingsOrOptions;",
                "      }",
                "      return new settings_1.default(settingsOrOptions);",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/reusify/reusify.js",
                "var require_reusify = __commonJS({",
                "  \"node_modules/reusify/reusify.js\"(exports, module2) {",
                "    \"use strict\";",
                "    function reusify(Constructor) {",
                "      var head = new Constructor();",
                "      var tail = head;",
                "      function get() {",
                "        var current = head;",
                "        if (current.next) {",
                "          head = current.next;",
                "        } else {",
                "          head = new Constructor();",
                "          tail = head;",
                "        }",
                "        current.next = null;",
                "        return current;",
                "      }",
                "      function release(obj) {",
                "        tail.next = obj;",
                "        tail = obj;",
                "      }",
                "      return {",
                "        get,",
                "        release",
                "      };",
                "    }",
                "    module2.exports = reusify;",
                "  }",
                "});",
                "",
                "// node_modules/fastq/queue.js",
                "var require_queue = __commonJS({",
                "  \"node_modules/fastq/queue.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var reusify = require_reusify();",
                "    function fastqueue(context, worker, concurrency) {",
                "      if (typeof context === \"function\") {",
                "        concurrency = worker;",
                "        worker = context;",
                "        context = null;",
                "      }",
                "      if (concurrency < 1) {",
                "        throw new Error(\"fastqueue concurrency must be greater than 1\");",
                "      }",
                "      var cache = reusify(Task);",
                "      var queueHead = null;",
                "      var queueTail = null;",
                "      var _running = 0;",
                "      var errorHandler = null;",
                "      var self = {",
                "        push,",
                "        drain: noop,",
                "        saturated: noop,",
                "        pause,",
                "        paused: false,",
                "        concurrency,",
                "        running,",
                "        resume,",
                "        idle,",
                "        length,",
                "        getQueue,",
                "        unshift,",
                "        empty: noop,",
                "        kill,",
                "        killAndDrain,",
                "        error",
                "      };",
                "      return self;",
                "      function running() {",
                "        return _running;",
                "      }",
                "      function pause() {",
                "        self.paused = true;",
                "      }",
                "      function length() {",
                "        var current = queueHead;",
                "        var counter = 0;",
                "        while (current) {",
                "          current = current.next;",
                "          counter++;",
                "        }",
                "        return counter;",
                "      }",
                "      function getQueue() {",
                "        var current = queueHead;",
                "        var tasks = [];",
                "        while (current) {",
                "          tasks.push(current.value);",
                "          current = current.next;",
                "        }",
                "        return tasks;",
                "      }",
                "      function resume() {",
                "        if (!self.paused)",
                "          return;",
                "        self.paused = false;",
                "        for (var i = 0; i < self.concurrency; i++) {",
                "          _running++;",
                "          release();",
                "        }",
                "      }",
                "      function idle() {",
                "        return _running === 0 && self.length() === 0;",
                "      }",
                "      function push(value, done) {",
                "        var current = cache.get();",
                "        current.context = context;",
                "        current.release = release;",
                "        current.value = value;",
                "        current.callback = done || noop;",
                "        current.errorHandler = errorHandler;",
                "        if (_running === self.concurrency || self.paused) {",
                "          if (queueTail) {",
                "            queueTail.next = current;",
                "            queueTail = current;",
                "          } else {",
                "            queueHead = current;",
                "            queueTail = current;",
                "            self.saturated();",
                "          }",
                "        } else {",
                "          _running++;",
                "          worker.call(context, current.value, current.worked);",
                "        }",
                "      }",
                "      function unshift(value, done) {",
                "        var current = cache.get();",
                "        current.context = context;",
                "        current.release = release;",
                "        current.value = value;",
                "        current.callback = done || noop;",
                "        if (_running === self.concurrency || self.paused) {",
                "          if (queueHead) {",
                "            current.next = queueHead;",
                "            queueHead = current;",
                "          } else {",
                "            queueHead = current;",
                "            queueTail = current;",
                "            self.saturated();",
                "          }",
                "        } else {",
                "          _running++;",
                "          worker.call(context, current.value, current.worked);",
                "        }",
                "      }",
                "      function release(holder) {",
                "        if (holder) {",
                "          cache.release(holder);",
                "        }",
                "        var next = queueHead;",
                "        if (next) {",
                "          if (!self.paused) {",
                "            if (queueTail === queueHead) {",
                "              queueTail = null;",
                "            }",
                "            queueHead = next.next;",
                "            next.next = null;",
                "            worker.call(context, next.value, next.worked);",
                "            if (queueTail === null) {",
                "              self.empty();",
                "            }",
                "          } else {",
                "            _running--;",
                "          }",
                "        } else if (--_running === 0) {",
                "          self.drain();",
                "        }",
                "      }",
                "      function kill() {",
                "        queueHead = null;",
                "        queueTail = null;",
                "        self.drain = noop;",
                "      }",
                "      function killAndDrain() {",
                "        queueHead = null;",
                "        queueTail = null;",
                "        self.drain();",
                "        self.drain = noop;",
                "      }",
                "      function error(handler) {",
                "        errorHandler = handler;",
                "      }",
                "    }",
                "    function noop() {",
                "    }",
                "    function Task() {",
                "      this.value = null;",
                "      this.callback = noop;",
                "      this.next = null;",
                "      this.release = noop;",
                "      this.context = null;",
                "      this.errorHandler = null;",
                "      var self = this;",
                "      this.worked = function worked(err, result) {",
                "        var callback = self.callback;",
                "        var errorHandler = self.errorHandler;",
                "        var val = self.value;",
                "        self.value = null;",
                "        self.callback = noop;",
                "        if (self.errorHandler) {",
                "          errorHandler(err, val);",
                "        }",
                "        callback.call(self.context, err, result);",
                "        self.release(self);",
                "      };",
                "    }",
                "    function queueAsPromised(context, worker, concurrency) {",
                "      if (typeof context === \"function\") {",
                "        concurrency = worker;",
                "        worker = context;",
                "        context = null;",
                "      }",
                "      function asyncWrapper(arg, cb) {",
                "        worker.call(this, arg).then(function(res) {",
                "          cb(null, res);",
                "        }, cb);",
                "      }",
                "      var queue = fastqueue(context, asyncWrapper, concurrency);",
                "      var pushCb = queue.push;",
                "      var unshiftCb = queue.unshift;",
                "      queue.push = push;",
                "      queue.unshift = unshift;",
                "      queue.drained = drained;",
                "      return queue;",
                "      function push(value) {",
                "        var p = new Promise(function(resolve, reject) {",
                "          pushCb(value, function(err, result) {",
                "            if (err) {",
                "              reject(err);",
                "              return;",
                "            }",
                "            resolve(result);",
                "          });",
                "        });",
                "        p.catch(noop);",
                "        return p;",
                "      }",
                "      function unshift(value) {",
                "        var p = new Promise(function(resolve, reject) {",
                "          unshiftCb(value, function(err, result) {",
                "            if (err) {",
                "              reject(err);",
                "              return;",
                "            }",
                "            resolve(result);",
                "          });",
                "        });",
                "        p.catch(noop);",
                "        return p;",
                "      }",
                "      function drained() {",
                "        var previousDrain = queue.drain;",
                "        var p = new Promise(function(resolve) {",
                "          queue.drain = function() {",
                "            previousDrain();",
                "            resolve();",
                "          };",
                "        });",
                "        return p;",
                "      }",
                "    }",
                "    module2.exports = fastqueue;",
                "    module2.exports.promise = queueAsPromised;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.walk/out/readers/common.js",
                "var require_common2 = __commonJS({",
                "  \"node_modules/@nodelib/fs.walk/out/readers/common.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.joinPathSegments = exports.replacePathSegmentSeparator = exports.isAppliedFilter = exports.isFatalError = void 0;",
                "    function isFatalError(settings, error) {",
                "      if (settings.errorFilter === null) {",
                "        return true;",
                "      }",
                "      return !settings.errorFilter(error);",
                "    }",
                "    exports.isFatalError = isFatalError;",
                "    function isAppliedFilter(filter, value) {",
                "      return filter === null || filter(value);",
                "    }",
                "    exports.isAppliedFilter = isAppliedFilter;",
                "    function replacePathSegmentSeparator(filepath, separator) {",
                "      return filepath.split(/[/\\\\]/).join(separator);",
                "    }",
                "    exports.replacePathSegmentSeparator = replacePathSegmentSeparator;",
                "    function joinPathSegments(a, b, separator) {",
                "      if (a === \"\") {",
                "        return b;",
                "      }",
                "      if (a.endsWith(separator)) {",
                "        return a + b;",
                "      }",
                "      return a + separator + b;",
                "    }",
                "    exports.joinPathSegments = joinPathSegments;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.walk/out/readers/reader.js",
                "var require_reader = __commonJS({",
                "  \"node_modules/@nodelib/fs.walk/out/readers/reader.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var common = require_common2();",
                "    var Reader = class {",
                "      constructor(_root, _settings) {",
                "        this._root = _root;",
                "        this._settings = _settings;",
                "        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);",
                "      }",
                "    };",
                "    exports.default = Reader;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.walk/out/readers/async.js",
                "var require_async3 = __commonJS({",
                "  \"node_modules/@nodelib/fs.walk/out/readers/async.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var events_1 = require(\"events\");",
                "    var fsScandir = require_out2();",
                "    var fastq = require_queue();",
                "    var common = require_common2();",
                "    var reader_1 = require_reader();",
                "    var AsyncReader = class extends reader_1.default {",
                "      constructor(_root, _settings) {",
                "        super(_root, _settings);",
                "        this._settings = _settings;",
                "        this._scandir = fsScandir.scandir;",
                "        this._emitter = new events_1.EventEmitter();",
                "        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);",
                "        this._isFatalError = false;",
                "        this._isDestroyed = false;",
                "        this._queue.drain = () => {",
                "          if (!this._isFatalError) {",
                "            this._emitter.emit(\"end\");",
                "          }",
                "        };",
                "      }",
                "      read() {",
                "        this._isFatalError = false;",
                "        this._isDestroyed = false;",
                "        setImmediate(() => {",
                "          this._pushToQueue(this._root, this._settings.basePath);",
                "        });",
                "        return this._emitter;",
                "      }",
                "      get isDestroyed() {",
                "        return this._isDestroyed;",
                "      }",
                "      destroy() {",
                "        if (this._isDestroyed) {",
                "          throw new Error(\"The reader is already destroyed\");",
                "        }",
                "        this._isDestroyed = true;",
                "        this._queue.killAndDrain();",
                "      }",
                "      onEntry(callback) {",
                "        this._emitter.on(\"entry\", callback);",
                "      }",
                "      onError(callback) {",
                "        this._emitter.once(\"error\", callback);",
                "      }",
                "      onEnd(callback) {",
                "        this._emitter.once(\"end\", callback);",
                "      }",
                "      _pushToQueue(directory, base) {",
                "        const queueItem = { directory, base };",
                "        this._queue.push(queueItem, (error) => {",
                "          if (error !== null) {",
                "            this._handleError(error);",
                "          }",
                "        });",
                "      }",
                "      _worker(item, done) {",
                "        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {",
                "          if (error !== null) {",
                "            done(error, void 0);",
                "            return;",
                "          }",
                "          for (const entry of entries) {",
                "            this._handleEntry(entry, item.base);",
                "          }",
                "          done(null, void 0);",
                "        });",
                "      }",
                "      _handleError(error) {",
                "        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {",
                "          return;",
                "        }",
                "        this._isFatalError = true;",
                "        this._isDestroyed = true;",
                "        this._emitter.emit(\"error\", error);",
                "      }",
                "      _handleEntry(entry, base) {",
                "        if (this._isDestroyed || this._isFatalError) {",
                "          return;",
                "        }",
                "        const fullpath = entry.path;",
                "        if (base !== void 0) {",
                "          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);",
                "        }",
                "        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {",
                "          this._emitEntry(entry);",
                "        }",
                "        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {",
                "          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);",
                "        }",
                "      }",
                "      _emitEntry(entry) {",
                "        this._emitter.emit(\"entry\", entry);",
                "      }",
                "    };",
                "    exports.default = AsyncReader;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.walk/out/providers/async.js",
                "var require_async4 = __commonJS({",
                "  \"node_modules/@nodelib/fs.walk/out/providers/async.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var async_1 = require_async3();",
                "    var AsyncProvider = class {",
                "      constructor(_root, _settings) {",
                "        this._root = _root;",
                "        this._settings = _settings;",
                "        this._reader = new async_1.default(this._root, this._settings);",
                "        this._storage = [];",
                "      }",
                "      read(callback) {",
                "        this._reader.onError((error) => {",
                "          callFailureCallback(callback, error);",
                "        });",
                "        this._reader.onEntry((entry) => {",
                "          this._storage.push(entry);",
                "        });",
                "        this._reader.onEnd(() => {",
                "          callSuccessCallback(callback, this._storage);",
                "        });",
                "        this._reader.read();",
                "      }",
                "    };",
                "    exports.default = AsyncProvider;",
                "    function callFailureCallback(callback, error) {",
                "      callback(error);",
                "    }",
                "    function callSuccessCallback(callback, entries) {",
                "      callback(null, entries);",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.walk/out/providers/stream.js",
                "var require_stream2 = __commonJS({",
                "  \"node_modules/@nodelib/fs.walk/out/providers/stream.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var stream_1 = require(\"stream\");",
                "    var async_1 = require_async3();",
                "    var StreamProvider = class {",
                "      constructor(_root, _settings) {",
                "        this._root = _root;",
                "        this._settings = _settings;",
                "        this._reader = new async_1.default(this._root, this._settings);",
                "        this._stream = new stream_1.Readable({",
                "          objectMode: true,",
                "          read: () => {",
                "          },",
                "          destroy: () => {",
                "            if (!this._reader.isDestroyed) {",
                "              this._reader.destroy();",
                "            }",
                "          }",
                "        });",
                "      }",
                "      read() {",
                "        this._reader.onError((error) => {",
                "          this._stream.emit(\"error\", error);",
                "        });",
                "        this._reader.onEntry((entry) => {",
                "          this._stream.push(entry);",
                "        });",
                "        this._reader.onEnd(() => {",
                "          this._stream.push(null);",
                "        });",
                "        this._reader.read();",
                "        return this._stream;",
                "      }",
                "    };",
                "    exports.default = StreamProvider;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.walk/out/readers/sync.js",
                "var require_sync3 = __commonJS({",
                "  \"node_modules/@nodelib/fs.walk/out/readers/sync.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var fsScandir = require_out2();",
                "    var common = require_common2();",
                "    var reader_1 = require_reader();",
                "    var SyncReader = class extends reader_1.default {",
                "      constructor() {",
                "        super(...arguments);",
                "        this._scandir = fsScandir.scandirSync;",
                "        this._storage = [];",
                "        this._queue = /* @__PURE__ */ new Set();",
                "      }",
                "      read() {",
                "        this._pushToQueue(this._root, this._settings.basePath);",
                "        this._handleQueue();",
                "        return this._storage;",
                "      }",
                "      _pushToQueue(directory, base) {",
                "        this._queue.add({ directory, base });",
                "      }",
                "      _handleQueue() {",
                "        for (const item of this._queue.values()) {",
                "          this._handleDirectory(item.directory, item.base);",
                "        }",
                "      }",
                "      _handleDirectory(directory, base) {",
                "        try {",
                "          const entries = this._scandir(directory, this._settings.fsScandirSettings);",
                "          for (const entry of entries) {",
                "            this._handleEntry(entry, base);",
                "          }",
                "        } catch (error) {",
                "          this._handleError(error);",
                "        }",
                "      }",
                "      _handleError(error) {",
                "        if (!common.isFatalError(this._settings, error)) {",
                "          return;",
                "        }",
                "        throw error;",
                "      }",
                "      _handleEntry(entry, base) {",
                "        const fullpath = entry.path;",
                "        if (base !== void 0) {",
                "          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);",
                "        }",
                "        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {",
                "          this._pushToStorage(entry);",
                "        }",
                "        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {",
                "          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);",
                "        }",
                "      }",
                "      _pushToStorage(entry) {",
                "        this._storage.push(entry);",
                "      }",
                "    };",
                "    exports.default = SyncReader;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.walk/out/providers/sync.js",
                "var require_sync4 = __commonJS({",
                "  \"node_modules/@nodelib/fs.walk/out/providers/sync.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var sync_1 = require_sync3();",
                "    var SyncProvider = class {",
                "      constructor(_root, _settings) {",
                "        this._root = _root;",
                "        this._settings = _settings;",
                "        this._reader = new sync_1.default(this._root, this._settings);",
                "      }",
                "      read() {",
                "        return this._reader.read();",
                "      }",
                "    };",
                "    exports.default = SyncProvider;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.walk/out/settings.js",
                "var require_settings3 = __commonJS({",
                "  \"node_modules/@nodelib/fs.walk/out/settings.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var path2 = require(\"path\");",
                "    var fsScandir = require_out2();",
                "    var Settings = class {",
                "      constructor(_options = {}) {",
                "        this._options = _options;",
                "        this.basePath = this._getValue(this._options.basePath, void 0);",
                "        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);",
                "        this.deepFilter = this._getValue(this._options.deepFilter, null);",
                "        this.entryFilter = this._getValue(this._options.entryFilter, null);",
                "        this.errorFilter = this._getValue(this._options.errorFilter, null);",
                "        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path2.sep);",
                "        this.fsScandirSettings = new fsScandir.Settings({",
                "          followSymbolicLinks: this._options.followSymbolicLinks,",
                "          fs: this._options.fs,",
                "          pathSegmentSeparator: this._options.pathSegmentSeparator,",
                "          stats: this._options.stats,",
                "          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink",
                "        });",
                "      }",
                "      _getValue(option, value) {",
                "        return option !== null && option !== void 0 ? option : value;",
                "      }",
                "    };",
                "    exports.default = Settings;",
                "  }",
                "});",
                "",
                "// node_modules/@nodelib/fs.walk/out/index.js",
                "var require_out3 = __commonJS({",
                "  \"node_modules/@nodelib/fs.walk/out/index.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.Settings = exports.walkStream = exports.walkSync = exports.walk = void 0;",
                "    var async_1 = require_async4();",
                "    var stream_1 = require_stream2();",
                "    var sync_1 = require_sync4();",
                "    var settings_1 = require_settings3();",
                "    exports.Settings = settings_1.default;",
                "    function walk(directory, optionsOrSettingsOrCallback, callback) {",
                "      if (typeof optionsOrSettingsOrCallback === \"function\") {",
                "        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);",
                "        return;",
                "      }",
                "      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);",
                "    }",
                "    exports.walk = walk;",
                "    function walkSync(directory, optionsOrSettings) {",
                "      const settings = getSettings(optionsOrSettings);",
                "      const provider = new sync_1.default(directory, settings);",
                "      return provider.read();",
                "    }",
                "    exports.walkSync = walkSync;",
                "    function walkStream(directory, optionsOrSettings) {",
                "      const settings = getSettings(optionsOrSettings);",
                "      const provider = new stream_1.default(directory, settings);",
                "      return provider.read();",
                "    }",
                "    exports.walkStream = walkStream;",
                "    function getSettings(settingsOrOptions = {}) {",
                "      if (settingsOrOptions instanceof settings_1.default) {",
                "        return settingsOrOptions;",
                "      }",
                "      return new settings_1.default(settingsOrOptions);",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/readers/reader.js",
                "var require_reader2 = __commonJS({",
                "  \"node_modules/fast-glob/out/readers/reader.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var path2 = require(\"path\");",
                "    var fsStat = require_out();",
                "    var utils = require_utils3();",
                "    var Reader = class {",
                "      constructor(_settings) {",
                "        this._settings = _settings;",
                "        this._fsStatSettings = new fsStat.Settings({",
                "          followSymbolicLink: this._settings.followSymbolicLinks,",
                "          fs: this._settings.fs,",
                "          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks",
                "        });",
                "      }",
                "      _getFullEntryPath(filepath) {",
                "        return path2.resolve(this._settings.cwd, filepath);",
                "      }",
                "      _makeEntry(stats, pattern) {",
                "        const entry = {",
                "          name: pattern,",
                "          path: pattern,",
                "          dirent: utils.fs.createDirentFromStats(pattern, stats)",
                "        };",
                "        if (this._settings.stats) {",
                "          entry.stats = stats;",
                "        }",
                "        return entry;",
                "      }",
                "      _isFatalError(error) {",
                "        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;",
                "      }",
                "    };",
                "    exports.default = Reader;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/readers/stream.js",
                "var require_stream3 = __commonJS({",
                "  \"node_modules/fast-glob/out/readers/stream.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var stream_1 = require(\"stream\");",
                "    var fsStat = require_out();",
                "    var fsWalk = require_out3();",
                "    var reader_1 = require_reader2();",
                "    var ReaderStream = class extends reader_1.default {",
                "      constructor() {",
                "        super(...arguments);",
                "        this._walkStream = fsWalk.walkStream;",
                "        this._stat = fsStat.stat;",
                "      }",
                "      dynamic(root, options) {",
                "        return this._walkStream(root, options);",
                "      }",
                "      static(patterns, options) {",
                "        const filepaths = patterns.map(this._getFullEntryPath, this);",
                "        const stream2 = new stream_1.PassThrough({ objectMode: true });",
                "        stream2._write = (index, _enc, done) => {",
                "          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {",
                "            if (entry !== null && options.entryFilter(entry)) {",
                "              stream2.push(entry);",
                "            }",
                "            if (index === filepaths.length - 1) {",
                "              stream2.end();",
                "            }",
                "            done();",
                "          }).catch(done);",
                "        };",
                "        for (let i = 0; i < filepaths.length; i++) {",
                "          stream2.write(i);",
                "        }",
                "        return stream2;",
                "      }",
                "      _getEntry(filepath, pattern, options) {",
                "        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {",
                "          if (options.errorFilter(error)) {",
                "            return null;",
                "          }",
                "          throw error;",
                "        });",
                "      }",
                "      _getStat(filepath) {",
                "        return new Promise((resolve, reject) => {",
                "          this._stat(filepath, this._fsStatSettings, (error, stats) => {",
                "            return error === null ? resolve(stats) : reject(error);",
                "          });",
                "        });",
                "      }",
                "    };",
                "    exports.default = ReaderStream;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/readers/async.js",
                "var require_async5 = __commonJS({",
                "  \"node_modules/fast-glob/out/readers/async.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var fsWalk = require_out3();",
                "    var reader_1 = require_reader2();",
                "    var stream_1 = require_stream3();",
                "    var ReaderAsync = class extends reader_1.default {",
                "      constructor() {",
                "        super(...arguments);",
                "        this._walkAsync = fsWalk.walk;",
                "        this._readerStream = new stream_1.default(this._settings);",
                "      }",
                "      dynamic(root, options) {",
                "        return new Promise((resolve, reject) => {",
                "          this._walkAsync(root, options, (error, entries) => {",
                "            if (error === null) {",
                "              resolve(entries);",
                "            } else {",
                "              reject(error);",
                "            }",
                "          });",
                "        });",
                "      }",
                "      async static(patterns, options) {",
                "        const entries = [];",
                "        const stream2 = this._readerStream.static(patterns, options);",
                "        return new Promise((resolve, reject) => {",
                "          stream2.once(\"error\", reject);",
                "          stream2.on(\"data\", (entry) => entries.push(entry));",
                "          stream2.once(\"end\", () => resolve(entries));",
                "        });",
                "      }",
                "    };",
                "    exports.default = ReaderAsync;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/matchers/matcher.js",
                "var require_matcher = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/matchers/matcher.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var utils = require_utils3();",
                "    var Matcher = class {",
                "      constructor(_patterns, _settings, _micromatchOptions) {",
                "        this._patterns = _patterns;",
                "        this._settings = _settings;",
                "        this._micromatchOptions = _micromatchOptions;",
                "        this._storage = [];",
                "        this._fillStorage();",
                "      }",
                "      _fillStorage() {",
                "        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);",
                "        for (const pattern of patterns) {",
                "          const segments = this._getPatternSegments(pattern);",
                "          const sections = this._splitSegmentsIntoSections(segments);",
                "          this._storage.push({",
                "            complete: sections.length <= 1,",
                "            pattern,",
                "            segments,",
                "            sections",
                "          });",
                "        }",
                "      }",
                "      _getPatternSegments(pattern) {",
                "        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);",
                "        return parts.map((part) => {",
                "          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);",
                "          if (!dynamic) {",
                "            return {",
                "              dynamic: false,",
                "              pattern: part",
                "            };",
                "          }",
                "          return {",
                "            dynamic: true,",
                "            pattern: part,",
                "            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)",
                "          };",
                "        });",
                "      }",
                "      _splitSegmentsIntoSections(segments) {",
                "        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));",
                "      }",
                "    };",
                "    exports.default = Matcher;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/matchers/partial.js",
                "var require_partial = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/matchers/partial.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var matcher_1 = require_matcher();",
                "    var PartialMatcher = class extends matcher_1.default {",
                "      match(filepath) {",
                "        const parts = filepath.split(\"/\");",
                "        const levels = parts.length;",
                "        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);",
                "        for (const pattern of patterns) {",
                "          const section = pattern.sections[0];",
                "          if (!pattern.complete && levels > section.length) {",
                "            return true;",
                "          }",
                "          const match = parts.every((part, index) => {",
                "            const segment = pattern.segments[index];",
                "            if (segment.dynamic && segment.patternRe.test(part)) {",
                "              return true;",
                "            }",
                "            if (!segment.dynamic && segment.pattern === part) {",
                "              return true;",
                "            }",
                "            return false;",
                "          });",
                "          if (match) {",
                "            return true;",
                "          }",
                "        }",
                "        return false;",
                "      }",
                "    };",
                "    exports.default = PartialMatcher;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/filters/deep.js",
                "var require_deep = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/filters/deep.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var utils = require_utils3();",
                "    var partial_1 = require_partial();",
                "    var DeepFilter = class {",
                "      constructor(_settings, _micromatchOptions) {",
                "        this._settings = _settings;",
                "        this._micromatchOptions = _micromatchOptions;",
                "      }",
                "      getFilter(basePath, positive, negative) {",
                "        const matcher = this._getMatcher(positive);",
                "        const negativeRe = this._getNegativePatternsRe(negative);",
                "        return (entry) => this._filter(basePath, entry, matcher, negativeRe);",
                "      }",
                "      _getMatcher(patterns) {",
                "        return new partial_1.default(patterns, this._settings, this._micromatchOptions);",
                "      }",
                "      _getNegativePatternsRe(patterns) {",
                "        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);",
                "        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);",
                "      }",
                "      _filter(basePath, entry, matcher, negativeRe) {",
                "        if (this._isSkippedByDeep(basePath, entry.path)) {",
                "          return false;",
                "        }",
                "        if (this._isSkippedSymbolicLink(entry)) {",
                "          return false;",
                "        }",
                "        const filepath = utils.path.removeLeadingDotSegment(entry.path);",
                "        if (this._isSkippedByPositivePatterns(filepath, matcher)) {",
                "          return false;",
                "        }",
                "        return this._isSkippedByNegativePatterns(filepath, negativeRe);",
                "      }",
                "      _isSkippedByDeep(basePath, entryPath) {",
                "        if (this._settings.deep === Infinity) {",
                "          return false;",
                "        }",
                "        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;",
                "      }",
                "      _getEntryLevel(basePath, entryPath) {",
                "        const entryPathDepth = entryPath.split(\"/\").length;",
                "        if (basePath === \"\") {",
                "          return entryPathDepth;",
                "        }",
                "        const basePathDepth = basePath.split(\"/\").length;",
                "        return entryPathDepth - basePathDepth;",
                "      }",
                "      _isSkippedSymbolicLink(entry) {",
                "        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();",
                "      }",
                "      _isSkippedByPositivePatterns(entryPath, matcher) {",
                "        return !this._settings.baseNameMatch && !matcher.match(entryPath);",
                "      }",
                "      _isSkippedByNegativePatterns(entryPath, patternsRe) {",
                "        return !utils.pattern.matchAny(entryPath, patternsRe);",
                "      }",
                "    };",
                "    exports.default = DeepFilter;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/filters/entry.js",
                "var require_entry = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/filters/entry.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var utils = require_utils3();",
                "    var EntryFilter = class {",
                "      constructor(_settings, _micromatchOptions) {",
                "        this._settings = _settings;",
                "        this._micromatchOptions = _micromatchOptions;",
                "        this.index = /* @__PURE__ */ new Map();",
                "      }",
                "      getFilter(positive, negative) {",
                "        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);",
                "        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);",
                "        return (entry) => this._filter(entry, positiveRe, negativeRe);",
                "      }",
                "      _filter(entry, positiveRe, negativeRe) {",
                "        if (this._settings.unique && this._isDuplicateEntry(entry)) {",
                "          return false;",
                "        }",
                "        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {",
                "          return false;",
                "        }",
                "        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {",
                "          return false;",
                "        }",
                "        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;",
                "        const isDirectory = entry.dirent.isDirectory();",
                "        const isMatched = this._isMatchToPatterns(filepath, positiveRe, isDirectory) && !this._isMatchToPatterns(entry.path, negativeRe, isDirectory);",
                "        if (this._settings.unique && isMatched) {",
                "          this._createIndexRecord(entry);",
                "        }",
                "        return isMatched;",
                "      }",
                "      _isDuplicateEntry(entry) {",
                "        return this.index.has(entry.path);",
                "      }",
                "      _createIndexRecord(entry) {",
                "        this.index.set(entry.path, void 0);",
                "      }",
                "      _onlyFileFilter(entry) {",
                "        return this._settings.onlyFiles && !entry.dirent.isFile();",
                "      }",
                "      _onlyDirectoryFilter(entry) {",
                "        return this._settings.onlyDirectories && !entry.dirent.isDirectory();",
                "      }",
                "      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {",
                "        if (!this._settings.absolute) {",
                "          return false;",
                "        }",
                "        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);",
                "        return utils.pattern.matchAny(fullpath, patternsRe);",
                "      }",
                "      _isMatchToPatterns(entryPath, patternsRe, isDirectory) {",
                "        const filepath = utils.path.removeLeadingDotSegment(entryPath);",
                "        const isMatched = utils.pattern.matchAny(filepath, patternsRe);",
                "        if (!isMatched && isDirectory) {",
                "          return utils.pattern.matchAny(filepath + \"/\", patternsRe);",
                "        }",
                "        return isMatched;",
                "      }",
                "    };",
                "    exports.default = EntryFilter;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/filters/error.js",
                "var require_error = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/filters/error.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var utils = require_utils3();",
                "    var ErrorFilter = class {",
                "      constructor(_settings) {",
                "        this._settings = _settings;",
                "      }",
                "      getFilter() {",
                "        return (error) => this._isNonFatalError(error);",
                "      }",
                "      _isNonFatalError(error) {",
                "        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;",
                "      }",
                "    };",
                "    exports.default = ErrorFilter;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/transformers/entry.js",
                "var require_entry2 = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/transformers/entry.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var utils = require_utils3();",
                "    var EntryTransformer = class {",
                "      constructor(_settings) {",
                "        this._settings = _settings;",
                "      }",
                "      getTransformer() {",
                "        return (entry) => this._transform(entry);",
                "      }",
                "      _transform(entry) {",
                "        let filepath = entry.path;",
                "        if (this._settings.absolute) {",
                "          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);",
                "          filepath = utils.path.unixify(filepath);",
                "        }",
                "        if (this._settings.markDirectories && entry.dirent.isDirectory()) {",
                "          filepath += \"/\";",
                "        }",
                "        if (!this._settings.objectMode) {",
                "          return filepath;",
                "        }",
                "        return Object.assign(Object.assign({}, entry), { path: filepath });",
                "      }",
                "    };",
                "    exports.default = EntryTransformer;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/provider.js",
                "var require_provider = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/provider.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var path2 = require(\"path\");",
                "    var deep_1 = require_deep();",
                "    var entry_1 = require_entry();",
                "    var error_1 = require_error();",
                "    var entry_2 = require_entry2();",
                "    var Provider = class {",
                "      constructor(_settings) {",
                "        this._settings = _settings;",
                "        this.errorFilter = new error_1.default(this._settings);",
                "        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());",
                "        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());",
                "        this.entryTransformer = new entry_2.default(this._settings);",
                "      }",
                "      _getRootDirectory(task) {",
                "        return path2.resolve(this._settings.cwd, task.base);",
                "      }",
                "      _getReaderOptions(task) {",
                "        const basePath = task.base === \".\" ? \"\" : task.base;",
                "        return {",
                "          basePath,",
                "          pathSegmentSeparator: \"/\",",
                "          concurrency: this._settings.concurrency,",
                "          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),",
                "          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),",
                "          errorFilter: this.errorFilter.getFilter(),",
                "          followSymbolicLinks: this._settings.followSymbolicLinks,",
                "          fs: this._settings.fs,",
                "          stats: this._settings.stats,",
                "          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,",
                "          transform: this.entryTransformer.getTransformer()",
                "        };",
                "      }",
                "      _getMicromatchOptions() {",
                "        return {",
                "          dot: this._settings.dot,",
                "          matchBase: this._settings.baseNameMatch,",
                "          nobrace: !this._settings.braceExpansion,",
                "          nocase: !this._settings.caseSensitiveMatch,",
                "          noext: !this._settings.extglob,",
                "          noglobstar: !this._settings.globstar,",
                "          posix: true,",
                "          strictSlashes: false",
                "        };",
                "      }",
                "    };",
                "    exports.default = Provider;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/async.js",
                "var require_async6 = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/async.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var async_1 = require_async5();",
                "    var provider_1 = require_provider();",
                "    var ProviderAsync = class extends provider_1.default {",
                "      constructor() {",
                "        super(...arguments);",
                "        this._reader = new async_1.default(this._settings);",
                "      }",
                "      async read(task) {",
                "        const root = this._getRootDirectory(task);",
                "        const options = this._getReaderOptions(task);",
                "        const entries = await this.api(root, task, options);",
                "        return entries.map((entry) => options.transform(entry));",
                "      }",
                "      api(root, task, options) {",
                "        if (task.dynamic) {",
                "          return this._reader.dynamic(root, options);",
                "        }",
                "        return this._reader.static(task.patterns, options);",
                "      }",
                "    };",
                "    exports.default = ProviderAsync;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/stream.js",
                "var require_stream4 = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/stream.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var stream_1 = require(\"stream\");",
                "    var stream_2 = require_stream3();",
                "    var provider_1 = require_provider();",
                "    var ProviderStream = class extends provider_1.default {",
                "      constructor() {",
                "        super(...arguments);",
                "        this._reader = new stream_2.default(this._settings);",
                "      }",
                "      read(task) {",
                "        const root = this._getRootDirectory(task);",
                "        const options = this._getReaderOptions(task);",
                "        const source = this.api(root, task, options);",
                "        const destination = new stream_1.Readable({ objectMode: true, read: () => {",
                "        } });",
                "        source.once(\"error\", (error) => destination.emit(\"error\", error)).on(\"data\", (entry) => destination.emit(\"data\", options.transform(entry))).once(\"end\", () => destination.emit(\"end\"));",
                "        destination.once(\"close\", () => source.destroy());",
                "        return destination;",
                "      }",
                "      api(root, task, options) {",
                "        if (task.dynamic) {",
                "          return this._reader.dynamic(root, options);",
                "        }",
                "        return this._reader.static(task.patterns, options);",
                "      }",
                "    };",
                "    exports.default = ProviderStream;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/readers/sync.js",
                "var require_sync5 = __commonJS({",
                "  \"node_modules/fast-glob/out/readers/sync.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var fsStat = require_out();",
                "    var fsWalk = require_out3();",
                "    var reader_1 = require_reader2();",
                "    var ReaderSync = class extends reader_1.default {",
                "      constructor() {",
                "        super(...arguments);",
                "        this._walkSync = fsWalk.walkSync;",
                "        this._statSync = fsStat.statSync;",
                "      }",
                "      dynamic(root, options) {",
                "        return this._walkSync(root, options);",
                "      }",
                "      static(patterns, options) {",
                "        const entries = [];",
                "        for (const pattern of patterns) {",
                "          const filepath = this._getFullEntryPath(pattern);",
                "          const entry = this._getEntry(filepath, pattern, options);",
                "          if (entry === null || !options.entryFilter(entry)) {",
                "            continue;",
                "          }",
                "          entries.push(entry);",
                "        }",
                "        return entries;",
                "      }",
                "      _getEntry(filepath, pattern, options) {",
                "        try {",
                "          const stats = this._getStat(filepath);",
                "          return this._makeEntry(stats, pattern);",
                "        } catch (error) {",
                "          if (options.errorFilter(error)) {",
                "            return null;",
                "          }",
                "          throw error;",
                "        }",
                "      }",
                "      _getStat(filepath) {",
                "        return this._statSync(filepath, this._fsStatSettings);",
                "      }",
                "    };",
                "    exports.default = ReaderSync;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/providers/sync.js",
                "var require_sync6 = __commonJS({",
                "  \"node_modules/fast-glob/out/providers/sync.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    var sync_1 = require_sync5();",
                "    var provider_1 = require_provider();",
                "    var ProviderSync = class extends provider_1.default {",
                "      constructor() {",
                "        super(...arguments);",
                "        this._reader = new sync_1.default(this._settings);",
                "      }",
                "      read(task) {",
                "        const root = this._getRootDirectory(task);",
                "        const options = this._getReaderOptions(task);",
                "        const entries = this.api(root, task, options);",
                "        return entries.map(options.transform);",
                "      }",
                "      api(root, task, options) {",
                "        if (task.dynamic) {",
                "          return this._reader.dynamic(root, options);",
                "        }",
                "        return this._reader.static(task.patterns, options);",
                "      }",
                "    };",
                "    exports.default = ProviderSync;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/settings.js",
                "var require_settings4 = __commonJS({",
                "  \"node_modules/fast-glob/out/settings.js\"(exports) {",
                "    \"use strict\";",
                "    Object.defineProperty(exports, \"__esModule\", { value: true });",
                "    exports.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;",
                "    var fs2 = require(\"fs\");",
                "    var os = require(\"os\");",
                "    var CPU_COUNT = Math.max(os.cpus().length, 1);",
                "    exports.DEFAULT_FILE_SYSTEM_ADAPTER = {",
                "      lstat: fs2.lstat,",
                "      lstatSync: fs2.lstatSync,",
                "      stat: fs2.stat,",
                "      statSync: fs2.statSync,",
                "      readdir: fs2.readdir,",
                "      readdirSync: fs2.readdirSync",
                "    };",
                "    var Settings = class {",
                "      constructor(_options = {}) {",
                "        this._options = _options;",
                "        this.absolute = this._getValue(this._options.absolute, false);",
                "        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);",
                "        this.braceExpansion = this._getValue(this._options.braceExpansion, true);",
                "        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);",
                "        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);",
                "        this.cwd = this._getValue(this._options.cwd, process.cwd());",
                "        this.deep = this._getValue(this._options.deep, Infinity);",
                "        this.dot = this._getValue(this._options.dot, false);",
                "        this.extglob = this._getValue(this._options.extglob, true);",
                "        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);",
                "        this.fs = this._getFileSystemMethods(this._options.fs);",
                "        this.globstar = this._getValue(this._options.globstar, true);",
                "        this.ignore = this._getValue(this._options.ignore, []);",
                "        this.markDirectories = this._getValue(this._options.markDirectories, false);",
                "        this.objectMode = this._getValue(this._options.objectMode, false);",
                "        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);",
                "        this.onlyFiles = this._getValue(this._options.onlyFiles, true);",
                "        this.stats = this._getValue(this._options.stats, false);",
                "        this.suppressErrors = this._getValue(this._options.suppressErrors, false);",
                "        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);",
                "        this.unique = this._getValue(this._options.unique, true);",
                "        if (this.onlyDirectories) {",
                "          this.onlyFiles = false;",
                "        }",
                "        if (this.stats) {",
                "          this.objectMode = true;",
                "        }",
                "      }",
                "      _getValue(option, value) {",
                "        return option === void 0 ? value : option;",
                "      }",
                "      _getFileSystemMethods(methods = {}) {",
                "        return Object.assign(Object.assign({}, exports.DEFAULT_FILE_SYSTEM_ADAPTER), methods);",
                "      }",
                "    };",
                "    exports.default = Settings;",
                "  }",
                "});",
                "",
                "// node_modules/fast-glob/out/index.js",
                "var require_out4 = __commonJS({",
                "  \"node_modules/fast-glob/out/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var taskManager = require_tasks();",
                "    var patternManager = require_patterns();",
                "    var async_1 = require_async6();",
                "    var stream_1 = require_stream4();",
                "    var sync_1 = require_sync6();",
                "    var settings_1 = require_settings4();",
                "    var utils = require_utils3();",
                "    async function FastGlob(source, options) {",
                "      assertPatternsInput(source);",
                "      const works = getWorks(source, async_1.default, options);",
                "      const result = await Promise.all(works);",
                "      return utils.array.flatten(result);",
                "    }",
                "    (function(FastGlob2) {",
                "      function sync(source, options) {",
                "        assertPatternsInput(source);",
                "        const works = getWorks(source, sync_1.default, options);",
                "        return utils.array.flatten(works);",
                "      }",
                "      FastGlob2.sync = sync;",
                "      function stream2(source, options) {",
                "        assertPatternsInput(source);",
                "        const works = getWorks(source, stream_1.default, options);",
                "        return utils.stream.merge(works);",
                "      }",
                "      FastGlob2.stream = stream2;",
                "      function generateTasks(source, options) {",
                "        assertPatternsInput(source);",
                "        const patterns = patternManager.transform([].concat(source));",
                "        const settings = new settings_1.default(options);",
                "        return taskManager.generate(patterns, settings);",
                "      }",
                "      FastGlob2.generateTasks = generateTasks;",
                "      function isDynamicPattern(source, options) {",
                "        assertPatternsInput(source);",
                "        const settings = new settings_1.default(options);",
                "        return utils.pattern.isDynamicPattern(source, settings);",
                "      }",
                "      FastGlob2.isDynamicPattern = isDynamicPattern;",
                "      function escapePath(source) {",
                "        assertPatternsInput(source);",
                "        return utils.path.escape(source);",
                "      }",
                "      FastGlob2.escapePath = escapePath;",
                "    })(FastGlob || (FastGlob = {}));",
                "    function getWorks(source, _Provider, options) {",
                "      const patterns = patternManager.transform([].concat(source));",
                "      const settings = new settings_1.default(options);",
                "      const tasks = taskManager.generate(patterns, settings);",
                "      const provider = new _Provider(settings);",
                "      return tasks.map(provider.read, provider);",
                "    }",
                "    function assertPatternsInput(input) {",
                "      const source = [].concat(input);",
                "      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));",
                "      if (!isValidSource) {",
                "        throw new TypeError(\"Patterns must be a string (non empty) or an array of strings\");",
                "      }",
                "    }",
                "    module2.exports = FastGlob;",
                "  }",
                "});",
                "",
                "// node_modules/path-type/index.js",
                "var require_path_type = __commonJS({",
                "  \"node_modules/path-type/index.js\"(exports) {",
                "    \"use strict\";",
                "    var { promisify: promisify3 } = require(\"util\");",
                "    var fs2 = require(\"fs\");",
                "    async function isType(fsStatType, statsMethodName, filePath) {",
                "      if (typeof filePath !== \"string\") {",
                "        throw new TypeError(`Expected a string, got ${typeof filePath}`);",
                "      }",
                "      try {",
                "        const stats = await promisify3(fs2[fsStatType])(filePath);",
                "        return stats[statsMethodName]();",
                "      } catch (error) {",
                "        if (error.code === \"ENOENT\") {",
                "          return false;",
                "        }",
                "        throw error;",
                "      }",
                "    }",
                "    function isTypeSync(fsStatType, statsMethodName, filePath) {",
                "      if (typeof filePath !== \"string\") {",
                "        throw new TypeError(`Expected a string, got ${typeof filePath}`);",
                "      }",
                "      try {",
                "        return fs2[fsStatType](filePath)[statsMethodName]();",
                "      } catch (error) {",
                "        if (error.code === \"ENOENT\") {",
                "          return false;",
                "        }",
                "        throw error;",
                "      }",
                "    }",
                "    exports.isFile = isType.bind(null, \"stat\", \"isFile\");",
                "    exports.isDirectory = isType.bind(null, \"stat\", \"isDirectory\");",
                "    exports.isSymlink = isType.bind(null, \"lstat\", \"isSymbolicLink\");",
                "    exports.isFileSync = isTypeSync.bind(null, \"statSync\", \"isFile\");",
                "    exports.isDirectorySync = isTypeSync.bind(null, \"statSync\", \"isDirectory\");",
                "    exports.isSymlinkSync = isTypeSync.bind(null, \"lstatSync\", \"isSymbolicLink\");",
                "  }",
                "});",
                "",
                "// node_modules/dir-glob/index.js",
                "var require_dir_glob = __commonJS({",
                "  \"node_modules/dir-glob/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var path2 = require(\"path\");",
                "    var pathType = require_path_type();",
                "    var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(\",\")}}` : extensions[0];",
                "    var getPath2 = (filepath, cwd) => {",
                "      const pth = filepath[0] === \"!\" ? filepath.slice(1) : filepath;",
                "      return path2.isAbsolute(pth) ? pth : path2.join(cwd, pth);",
                "    };",
                "    var addExtensions = (file, extensions) => {",
                "      if (path2.extname(file)) {",
                "        return `**/${file}`;",
                "      }",
                "      return `**/${file}.${getExtensions(extensions)}`;",
                "    };",
                "    var getGlob = (directory, options) => {",
                "      if (options.files && !Array.isArray(options.files)) {",
                "        throw new TypeError(`Expected \\`files\\` to be of type \\`Array\\` but received type \\`${typeof options.files}\\``);",
                "      }",
                "      if (options.extensions && !Array.isArray(options.extensions)) {",
                "        throw new TypeError(`Expected \\`extensions\\` to be of type \\`Array\\` but received type \\`${typeof options.extensions}\\``);",
                "      }",
                "      if (options.files && options.extensions) {",
                "        return options.files.map((x) => path2.posix.join(directory, addExtensions(x, options.extensions)));",
                "      }",
                "      if (options.files) {",
                "        return options.files.map((x) => path2.posix.join(directory, `**/${x}`));",
                "      }",
                "      if (options.extensions) {",
                "        return [path2.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];",
                "      }",
                "      return [path2.posix.join(directory, \"**\")];",
                "    };",
                "    module2.exports = async (input, options) => {",
                "      options = {",
                "        cwd: process.cwd(),",
                "        ...options",
                "      };",
                "      if (typeof options.cwd !== \"string\") {",
                "        throw new TypeError(`Expected \\`cwd\\` to be of type \\`string\\` but received type \\`${typeof options.cwd}\\``);",
                "      }",
                "      const globs = await Promise.all([].concat(input).map(async (x) => {",
                "        const isDirectory = await pathType.isDirectory(getPath2(x, options.cwd));",
                "        return isDirectory ? getGlob(x, options) : x;",
                "      }));",
                "      return [].concat.apply([], globs);",
                "    };",
                "    module2.exports.sync = (input, options) => {",
                "      options = {",
                "        cwd: process.cwd(),",
                "        ...options",
                "      };",
                "      if (typeof options.cwd !== \"string\") {",
                "        throw new TypeError(`Expected \\`cwd\\` to be of type \\`string\\` but received type \\`${typeof options.cwd}\\``);",
                "      }",
                "      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath2(x, options.cwd)) ? getGlob(x, options) : x);",
                "      return [].concat.apply([], globs);",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/globby/node_modules/ignore/index.js",
                "var require_ignore = __commonJS({",
                "  \"node_modules/globby/node_modules/ignore/index.js\"(exports, module2) {",
                "    function makeArray(subject) {",
                "      return Array.isArray(subject) ? subject : [subject];",
                "    }",
                "    var EMPTY = \"\";",
                "    var SPACE = \" \";",
                "    var ESCAPE = \"\\\\\";",
                "    var REGEX_TEST_BLANK_LINE = /^\\s+$/;",
                "    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/;",
                "    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/;",
                "    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/;",
                "    var REGEX_SPLITALL_CRLF = /\\r?\\n/g;",
                "    var REGEX_TEST_INVALID_PATH = /^\\.*\\/|^\\.+$/;",
                "    var SLASH = \"/\";",
                "    var TMP_KEY_IGNORE = \"node-ignore\";",
                "    if (typeof Symbol !== \"undefined\") {",
                "      TMP_KEY_IGNORE = Symbol.for(\"node-ignore\");",
                "    }",
                "    var KEY_IGNORE = TMP_KEY_IGNORE;",
                "    var define = (object, key, value) => Object.defineProperty(object, key, { value });",
                "    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;",
                "    var RETURN_FALSE = () => false;",
                "    var sanitizeRange = (range) => range.replace(",
                "      REGEX_REGEXP_RANGE,",
                "      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY",
                "    );",
                "    var cleanRangeBackSlash = (slashes) => {",
                "      const { length } = slashes;",
                "      return slashes.slice(0, length - length % 2);",
                "    };",
                "    var REPLACERS = [",
                "      [",
                "        /\\\\?\\s+$/,",
                "        (match) => match.indexOf(\"\\\\\") === 0 ? SPACE : EMPTY",
                "      ],",
                "      [",
                "        /\\\\\\s/g,",
                "        () => SPACE",
                "      ],",
                "      [",
                "        /[\\\\$.|*+(){^]/g,",
                "        (match) => `\\\\${match}`",
                "      ],",
                "      [",
                "        /(?!\\\\)\\?/g,",
                "        () => \"[^/]\"",
                "      ],",
                "      [",
                "        /^\\//,",
                "        () => \"^\"",
                "      ],",
                "      [",
                "        /\\//g,",
                "        () => \"\\\\/\"",
                "      ],",
                "      [",
                "        /^\\^*\\\\\\*\\\\\\*\\\\\\//,",
                "        () => \"^(?:.*\\\\/)?\"",
                "      ],",
                "      [",
                "        /^(?=[^^])/,",
                "        function startingReplacer() {",
                "          return !/\\/(?!$)/.test(this) ? \"(?:^|\\\\/)\" : \"^\";",
                "        }",
                "      ],",
                "      [",
                "        /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,",
                "        (_, index, str) => index + 6 < str.length ? \"(?:\\\\/[^\\\\/]+)*\" : \"\\\\/.+\"",
                "      ],",
                "      [",
                "        /(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,",
                "        (_, p1, p2) => {",
                "          const unescaped = p2.replace(/\\\\\\*/g, \"[^\\\\/]*\");",
                "          return p1 + unescaped;",
                "        }",
                "      ],",
                "      [",
                "        /\\\\\\\\\\\\(?=[$.|*+(){^])/g,",
                "        () => ESCAPE",
                "      ],",
                "      [",
                "        /\\\\\\\\/g,",
                "        () => ESCAPE",
                "      ],",
                "      [",
                "        /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,",
                "        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === \"]\" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : \"[]\" : \"[]\"",
                "      ],",
                "      [",
                "        /(?:[^*])$/,",
                "        (match) => /\\/$/.test(match) ? `${match}$` : `${match}(?=$|\\\\/$)`",
                "      ],",
                "      [",
                "        /(\\^|\\\\\\/)?\\\\\\*$/,",
                "        (_, p1) => {",
                "          const prefix = p1 ? `${p1}[^/]+` : \"[^/]*\";",
                "          return `${prefix}(?=$|\\\\/$)`;",
                "        }",
                "      ]",
                "    ];",
                "    var regexCache = /* @__PURE__ */ Object.create(null);",
                "    var makeRegex = (pattern, ignoreCase) => {",
                "      let source = regexCache[pattern];",
                "      if (!source) {",
                "        source = REPLACERS.reduce(",
                "          (prev, current) => prev.replace(current[0], current[1].bind(pattern)),",
                "          pattern",
                "        );",
                "        regexCache[pattern] = source;",
                "      }",
                "      return ignoreCase ? new RegExp(source, \"i\") : new RegExp(source);",
                "    };",
                "    var isString = (subject) => typeof subject === \"string\";",
                "    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf(\"#\") !== 0;",
                "    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);",
                "    var IgnoreRule = class {",
                "      constructor(origin, pattern, negative, regex) {",
                "        this.origin = origin;",
                "        this.pattern = pattern;",
                "        this.negative = negative;",
                "        this.regex = regex;",
                "      }",
                "    };",
                "    var createRule = (pattern, ignoreCase) => {",
                "      const origin = pattern;",
                "      let negative = false;",
                "      if (pattern.indexOf(\"!\") === 0) {",
                "        negative = true;",
                "        pattern = pattern.substr(1);",
                "      }",
                "      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, \"!\").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, \"#\");",
                "      const regex = makeRegex(pattern, ignoreCase);",
                "      return new IgnoreRule(",
                "        origin,",
                "        pattern,",
                "        negative,",
                "        regex",
                "      );",
                "    };",
                "    var throwError = (message, Ctor) => {",
                "      throw new Ctor(message);",
                "    };",
                "    var checkPath = (path2, originalPath, doThrow) => {",
                "      if (!isString(path2)) {",
                "        return doThrow(",
                "          `path must be a string, but got \\`${originalPath}\\``,",
                "          TypeError",
                "        );",
                "      }",
                "      if (!path2) {",
                "        return doThrow(`path must not be empty`, TypeError);",
                "      }",
                "      if (checkPath.isNotRelative(path2)) {",
                "        const r = \"`path.relative()`d\";",
                "        return doThrow(",
                "          `path should be a ${r} string, but got \"${originalPath}\"`,",
                "          RangeError",
                "        );",
                "      }",
                "      return true;",
                "    };",
                "    var isNotRelative = (path2) => REGEX_TEST_INVALID_PATH.test(path2);",
                "    checkPath.isNotRelative = isNotRelative;",
                "    checkPath.convert = (p) => p;",
                "    var Ignore = class {",
                "      constructor({",
                "        ignorecase = true,",
                "        ignoreCase = ignorecase,",
                "        allowRelativePaths = false",
                "      } = {}) {",
                "        define(this, KEY_IGNORE, true);",
                "        this._rules = [];",
                "        this._ignoreCase = ignoreCase;",
                "        this._allowRelativePaths = allowRelativePaths;",
                "        this._initCache();",
                "      }",
                "      _initCache() {",
                "        this._ignoreCache = /* @__PURE__ */ Object.create(null);",
                "        this._testCache = /* @__PURE__ */ Object.create(null);",
                "      }",
                "      _addPattern(pattern) {",
                "        if (pattern && pattern[KEY_IGNORE]) {",
                "          this._rules = this._rules.concat(pattern._rules);",
                "          this._added = true;",
                "          return;",
                "        }",
                "        if (checkPattern(pattern)) {",
                "          const rule = createRule(pattern, this._ignoreCase);",
                "          this._added = true;",
                "          this._rules.push(rule);",
                "        }",
                "      }",
                "      add(pattern) {",
                "        this._added = false;",
                "        makeArray(",
                "          isString(pattern) ? splitPattern(pattern) : pattern",
                "        ).forEach(this._addPattern, this);",
                "        if (this._added) {",
                "          this._initCache();",
                "        }",
                "        return this;",
                "      }",
                "      addPattern(pattern) {",
                "        return this.add(pattern);",
                "      }",
                "      _testOne(path2, checkUnignored) {",
                "        let ignored = false;",
                "        let unignored = false;",
                "        this._rules.forEach((rule) => {",
                "          const { negative } = rule;",
                "          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {",
                "            return;",
                "          }",
                "          const matched = rule.regex.test(path2);",
                "          if (matched) {",
                "            ignored = !negative;",
                "            unignored = negative;",
                "          }",
                "        });",
                "        return {",
                "          ignored,",
                "          unignored",
                "        };",
                "      }",
                "      _test(originalPath, cache, checkUnignored, slices) {",
                "        const path2 = originalPath && checkPath.convert(originalPath);",
                "        checkPath(",
                "          path2,",
                "          originalPath,",
                "          this._allowRelativePaths ? RETURN_FALSE : throwError",
                "        );",
                "        return this._t(path2, cache, checkUnignored, slices);",
                "      }",
                "      _t(path2, cache, checkUnignored, slices) {",
                "        if (path2 in cache) {",
                "          return cache[path2];",
                "        }",
                "        if (!slices) {",
                "          slices = path2.split(SLASH);",
                "        }",
                "        slices.pop();",
                "        if (!slices.length) {",
                "          return cache[path2] = this._testOne(path2, checkUnignored);",
                "        }",
                "        const parent = this._t(",
                "          slices.join(SLASH) + SLASH,",
                "          cache,",
                "          checkUnignored,",
                "          slices",
                "        );",
                "        return cache[path2] = parent.ignored ? parent : this._testOne(path2, checkUnignored);",
                "      }",
                "      ignores(path2) {",
                "        return this._test(path2, this._ignoreCache, false).ignored;",
                "      }",
                "      createFilter() {",
                "        return (path2) => !this.ignores(path2);",
                "      }",
                "      filter(paths) {",
                "        return makeArray(paths).filter(this.createFilter());",
                "      }",
                "      test(path2) {",
                "        return this._test(path2, this._testCache, true);",
                "      }",
                "    };",
                "    var factory = (options) => new Ignore(options);",
                "    var isPathValid = (path2) => checkPath(path2 && checkPath.convert(path2), path2, RETURN_FALSE);",
                "    factory.isPathValid = isPathValid;",
                "    factory.default = factory;",
                "    module2.exports = factory;",
                "    if (typeof process !== \"undefined\" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === \"win32\")) {",
                "      const makePosix = (str) => /^\\\\\\\\\\?\\\\/.test(str) || /[\"<>|\\u0000-\\u001F]+/u.test(str) ? str : str.replace(/\\\\/g, \"/\");",
                "      checkPath.convert = makePosix;",
                "      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i;",
                "      checkPath.isNotRelative = (path2) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path2) || isNotRelative(path2);",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/slash/index.js",
                "var require_slash = __commonJS({",
                "  \"node_modules/slash/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = (path2) => {",
                "      const isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(path2);",
                "      const hasNonAscii = /[^\\u0000-\\u0080]+/.test(path2);",
                "      if (isExtendedLengthPath || hasNonAscii) {",
                "        return path2;",
                "      }",
                "      return path2.replace(/\\\\/g, \"/\");",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/globby/gitignore.js",
                "var require_gitignore = __commonJS({",
                "  \"node_modules/globby/gitignore.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var { promisify: promisify3 } = require(\"util\");",
                "    var fs2 = require(\"fs\");",
                "    var path2 = require(\"path\");",
                "    var fastGlob = require_out4();",
                "    var gitIgnore = require_ignore();",
                "    var slash = require_slash();",
                "    var DEFAULT_IGNORE = [",
                "      \"**/node_modules/**\",",
                "      \"**/flow-typed/**\",",
                "      \"**/coverage/**\",",
                "      \"**/.git\"",
                "    ];",
                "    var readFileP = promisify3(fs2.readFile);",
                "    var mapGitIgnorePatternTo = (base) => (ignore) => {",
                "      if (ignore.startsWith(\"!\")) {",
                "        return \"!\" + path2.posix.join(base, ignore.slice(1));",
                "      }",
                "      return path2.posix.join(base, ignore);",
                "    };",
                "    var parseGitIgnore = (content, options) => {",
                "      const base = slash(path2.relative(options.cwd, path2.dirname(options.fileName)));",
                "      return content.split(/\\r?\\n/).filter(Boolean).filter((line) => !line.startsWith(\"#\")).map(mapGitIgnorePatternTo(base));",
                "    };",
                "    var reduceIgnore = (files) => {",
                "      const ignores = gitIgnore();",
                "      for (const file of files) {",
                "        ignores.add(parseGitIgnore(file.content, {",
                "          cwd: file.cwd,",
                "          fileName: file.filePath",
                "        }));",
                "      }",
                "      return ignores;",
                "    };",
                "    var ensureAbsolutePathForCwd = (cwd, p) => {",
                "      cwd = slash(cwd);",
                "      if (path2.isAbsolute(p)) {",
                "        if (slash(p).startsWith(cwd)) {",
                "          return p;",
                "        }",
                "        throw new Error(`Path ${p} is not in cwd ${cwd}`);",
                "      }",
                "      return path2.join(cwd, p);",
                "    };",
                "    var getIsIgnoredPredecate = (ignores, cwd) => {",
                "      return (p) => ignores.ignores(slash(path2.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));",
                "    };",
                "    var getFile = async (file, cwd) => {",
                "      const filePath = path2.join(cwd, file);",
                "      const content = await readFileP(filePath, \"utf8\");",
                "      return {",
                "        cwd,",
                "        filePath,",
                "        content",
                "      };",
                "    };",
                "    var getFileSync = (file, cwd) => {",
                "      const filePath = path2.join(cwd, file);",
                "      const content = fs2.readFileSync(filePath, \"utf8\");",
                "      return {",
                "        cwd,",
                "        filePath,",
                "        content",
                "      };",
                "    };",
                "    var normalizeOptions = ({",
                "      ignore = [],",
                "      cwd = slash(process.cwd())",
                "    } = {}) => {",
                "      return { ignore, cwd };",
                "    };",
                "    module2.exports = async (options) => {",
                "      options = normalizeOptions(options);",
                "      const paths = await fastGlob(\"**/.gitignore\", {",
                "        ignore: DEFAULT_IGNORE.concat(options.ignore),",
                "        cwd: options.cwd",
                "      });",
                "      const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));",
                "      const ignores = reduceIgnore(files);",
                "      return getIsIgnoredPredecate(ignores, options.cwd);",
                "    };",
                "    module2.exports.sync = (options) => {",
                "      options = normalizeOptions(options);",
                "      const paths = fastGlob.sync(\"**/.gitignore\", {",
                "        ignore: DEFAULT_IGNORE.concat(options.ignore),",
                "        cwd: options.cwd",
                "      });",
                "      const files = paths.map((file) => getFileSync(file, options.cwd));",
                "      const ignores = reduceIgnore(files);",
                "      return getIsIgnoredPredecate(ignores, options.cwd);",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/globby/stream-utils.js",
                "var require_stream_utils = __commonJS({",
                "  \"node_modules/globby/stream-utils.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var { Transform } = require(\"stream\");",
                "    var ObjectTransform = class extends Transform {",
                "      constructor() {",
                "        super({",
                "          objectMode: true",
                "        });",
                "      }",
                "    };",
                "    var FilterStream = class extends ObjectTransform {",
                "      constructor(filter) {",
                "        super();",
                "        this._filter = filter;",
                "      }",
                "      _transform(data, encoding, callback) {",
                "        if (this._filter(data)) {",
                "          this.push(data);",
                "        }",
                "        callback();",
                "      }",
                "    };",
                "    var UniqueStream = class extends ObjectTransform {",
                "      constructor() {",
                "        super();",
                "        this._pushed = /* @__PURE__ */ new Set();",
                "      }",
                "      _transform(data, encoding, callback) {",
                "        if (!this._pushed.has(data)) {",
                "          this.push(data);",
                "          this._pushed.add(data);",
                "        }",
                "        callback();",
                "      }",
                "    };",
                "    module2.exports = {",
                "      FilterStream,",
                "      UniqueStream",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/globby/index.js",
                "var require_globby = __commonJS({",
                "  \"node_modules/globby/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var fs2 = require(\"fs\");",
                "    var arrayUnion = require_array_union();",
                "    var merge2 = require_merge2();",
                "    var fastGlob = require_out4();",
                "    var dirGlob = require_dir_glob();",
                "    var gitignore = require_gitignore();",
                "    var { FilterStream, UniqueStream } = require_stream_utils();",
                "    var DEFAULT_FILTER = () => false;",
                "    var isNegative = (pattern) => pattern[0] === \"!\";",
                "    var assertPatternsInput = (patterns) => {",
                "      if (!patterns.every((pattern) => typeof pattern === \"string\")) {",
                "        throw new TypeError(\"Patterns must be a string or an array of strings\");",
                "      }",
                "    };",
                "    var checkCwdOption = (options = {}) => {",
                "      if (!options.cwd) {",
                "        return;",
                "      }",
                "      let stat;",
                "      try {",
                "        stat = fs2.statSync(options.cwd);",
                "      } catch {",
                "        return;",
                "      }",
                "      if (!stat.isDirectory()) {",
                "        throw new Error(\"The `cwd` option must be a path to a directory\");",
                "      }",
                "    };",
                "    var getPathString = (p) => p.stats instanceof fs2.Stats ? p.path : p;",
                "    var generateGlobTasks = (patterns, taskOptions) => {",
                "      patterns = arrayUnion([].concat(patterns));",
                "      assertPatternsInput(patterns);",
                "      checkCwdOption(taskOptions);",
                "      const globTasks = [];",
                "      taskOptions = {",
                "        ignore: [],",
                "        expandDirectories: true,",
                "        ...taskOptions",
                "      };",
                "      for (const [index, pattern] of patterns.entries()) {",
                "        if (isNegative(pattern)) {",
                "          continue;",
                "        }",
                "        const ignore = patterns.slice(index).filter((pattern2) => isNegative(pattern2)).map((pattern2) => pattern2.slice(1));",
                "        const options = {",
                "          ...taskOptions,",
                "          ignore: taskOptions.ignore.concat(ignore)",
                "        };",
                "        globTasks.push({ pattern, options });",
                "      }",
                "      return globTasks;",
                "    };",
                "    var globDirs = (task, fn) => {",
                "      let options = {};",
                "      if (task.options.cwd) {",
                "        options.cwd = task.options.cwd;",
                "      }",
                "      if (Array.isArray(task.options.expandDirectories)) {",
                "        options = {",
                "          ...options,",
                "          files: task.options.expandDirectories",
                "        };",
                "      } else if (typeof task.options.expandDirectories === \"object\") {",
                "        options = {",
                "          ...options,",
                "          ...task.options.expandDirectories",
                "        };",
                "      }",
                "      return fn(task.pattern, options);",
                "    };",
                "    var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];",
                "    var getFilterSync = (options) => {",
                "      return options && options.gitignore ? gitignore.sync({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;",
                "    };",
                "    var globToTask = (task) => (glob) => {",
                "      const { options } = task;",
                "      if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {",
                "        options.ignore = dirGlob.sync(options.ignore);",
                "      }",
                "      return {",
                "        pattern: glob,",
                "        options",
                "      };",
                "    };",
                "    module2.exports = async (patterns, options) => {",
                "      const globTasks = generateGlobTasks(patterns, options);",
                "      const getFilter = async () => {",
                "        return options && options.gitignore ? gitignore({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;",
                "      };",
                "      const getTasks = async () => {",
                "        const tasks2 = await Promise.all(globTasks.map(async (task) => {",
                "          const globs = await getPattern(task, dirGlob);",
                "          return Promise.all(globs.map(globToTask(task)));",
                "        }));",
                "        return arrayUnion(...tasks2);",
                "      };",
                "      const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);",
                "      const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));",
                "      return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));",
                "    };",
                "    module2.exports.sync = (patterns, options) => {",
                "      const globTasks = generateGlobTasks(patterns, options);",
                "      const tasks = [];",
                "      for (const task of globTasks) {",
                "        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));",
                "        tasks.push(...newTask);",
                "      }",
                "      const filter = getFilterSync(options);",
                "      let matches = [];",
                "      for (const task of tasks) {",
                "        matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));",
                "      }",
                "      return matches.filter((path_) => !filter(path_));",
                "    };",
                "    module2.exports.stream = (patterns, options) => {",
                "      const globTasks = generateGlobTasks(patterns, options);",
                "      const tasks = [];",
                "      for (const task of globTasks) {",
                "        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));",
                "        tasks.push(...newTask);",
                "      }",
                "      const filter = getFilterSync(options);",
                "      const filterStream = new FilterStream((p) => !filter(p));",
                "      const uniqueStream = new UniqueStream();",
                "      return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);",
                "    };",
                "    module2.exports.generateGlobTasks = generateGlobTasks;",
                "    module2.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => fastGlob.isDynamicPattern(pattern, options));",
                "    module2.exports.gitignore = gitignore;",
                "  }",
                "});",
                "",
                "// node_modules/graceful-fs/polyfills.js",
                "var require_polyfills = __commonJS({",
                "  \"node_modules/graceful-fs/polyfills.js\"(exports, module2) {",
                "    var constants = require(\"constants\");",
                "    var origCwd = process.cwd;",
                "    var cwd = null;",
                "    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;",
                "    process.cwd = function() {",
                "      if (!cwd)",
                "        cwd = origCwd.call(process);",
                "      return cwd;",
                "    };",
                "    try {",
                "      process.cwd();",
                "    } catch (er) {",
                "    }",
                "    if (typeof process.chdir === \"function\") {",
                "      chdir = process.chdir;",
                "      process.chdir = function(d) {",
                "        cwd = null;",
                "        chdir.call(process, d);",
                "      };",
                "      if (Object.setPrototypeOf)",
                "        Object.setPrototypeOf(process.chdir, chdir);",
                "    }",
                "    var chdir;",
                "    module2.exports = patch;",
                "    function patch(fs2) {",
                "      if (constants.hasOwnProperty(\"O_SYMLINK\") && process.version.match(/^v0\\.6\\.[0-2]|^v0\\.5\\./)) {",
                "        patchLchmod(fs2);",
                "      }",
                "      if (!fs2.lutimes) {",
                "        patchLutimes(fs2);",
                "      }",
                "      fs2.chown = chownFix(fs2.chown);",
                "      fs2.fchown = chownFix(fs2.fchown);",
                "      fs2.lchown = chownFix(fs2.lchown);",
                "      fs2.chmod = chmodFix(fs2.chmod);",
                "      fs2.fchmod = chmodFix(fs2.fchmod);",
                "      fs2.lchmod = chmodFix(fs2.lchmod);",
                "      fs2.chownSync = chownFixSync(fs2.chownSync);",
                "      fs2.fchownSync = chownFixSync(fs2.fchownSync);",
                "      fs2.lchownSync = chownFixSync(fs2.lchownSync);",
                "      fs2.chmodSync = chmodFixSync(fs2.chmodSync);",
                "      fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);",
                "      fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);",
                "      fs2.stat = statFix(fs2.stat);",
                "      fs2.fstat = statFix(fs2.fstat);",
                "      fs2.lstat = statFix(fs2.lstat);",
                "      fs2.statSync = statFixSync(fs2.statSync);",
                "      fs2.fstatSync = statFixSync(fs2.fstatSync);",
                "      fs2.lstatSync = statFixSync(fs2.lstatSync);",
                "      if (fs2.chmod && !fs2.lchmod) {",
                "        fs2.lchmod = function(path2, mode, cb) {",
                "          if (cb)",
                "            process.nextTick(cb);",
                "        };",
                "        fs2.lchmodSync = function() {",
                "        };",
                "      }",
                "      if (fs2.chown && !fs2.lchown) {",
                "        fs2.lchown = function(path2, uid, gid, cb) {",
                "          if (cb)",
                "            process.nextTick(cb);",
                "        };",
                "        fs2.lchownSync = function() {",
                "        };",
                "      }",
                "      if (platform === \"win32\") {",
                "        fs2.rename = typeof fs2.rename !== \"function\" ? fs2.rename : function(fs$rename) {",
                "          function rename(from, to, cb) {",
                "            var start = Date.now();",
                "            var backoff = 0;",
                "            fs$rename(from, to, function CB(er) {",
                "              if (er && (er.code === \"EACCES\" || er.code === \"EPERM\") && Date.now() - start < 6e4) {",
                "                setTimeout(function() {",
                "                  fs2.stat(to, function(stater, st) {",
                "                    if (stater && stater.code === \"ENOENT\")",
                "                      fs$rename(from, to, CB);",
                "                    else",
                "                      cb(er);",
                "                  });",
                "                }, backoff);",
                "                if (backoff < 100)",
                "                  backoff += 10;",
                "                return;",
                "              }",
                "              if (cb)",
                "                cb(er);",
                "            });",
                "          }",
                "          if (Object.setPrototypeOf)",
                "            Object.setPrototypeOf(rename, fs$rename);",
                "          return rename;",
                "        }(fs2.rename);",
                "      }",
                "      fs2.read = typeof fs2.read !== \"function\" ? fs2.read : function(fs$read) {",
                "        function read(fd, buffer, offset, length, position, callback_) {",
                "          var callback;",
                "          if (callback_ && typeof callback_ === \"function\") {",
                "            var eagCounter = 0;",
                "            callback = function(er, _, __) {",
                "              if (er && er.code === \"EAGAIN\" && eagCounter < 10) {",
                "                eagCounter++;",
                "                return fs$read.call(fs2, fd, buffer, offset, length, position, callback);",
                "              }",
                "              callback_.apply(this, arguments);",
                "            };",
                "          }",
                "          return fs$read.call(fs2, fd, buffer, offset, length, position, callback);",
                "        }",
                "        if (Object.setPrototypeOf)",
                "          Object.setPrototypeOf(read, fs$read);",
                "        return read;",
                "      }(fs2.read);",
                "      fs2.readSync = typeof fs2.readSync !== \"function\" ? fs2.readSync : function(fs$readSync) {",
                "        return function(fd, buffer, offset, length, position) {",
                "          var eagCounter = 0;",
                "          while (true) {",
                "            try {",
                "              return fs$readSync.call(fs2, fd, buffer, offset, length, position);",
                "            } catch (er) {",
                "              if (er.code === \"EAGAIN\" && eagCounter < 10) {",
                "                eagCounter++;",
                "                continue;",
                "              }",
                "              throw er;",
                "            }",
                "          }",
                "        };",
                "      }(fs2.readSync);",
                "      function patchLchmod(fs3) {",
                "        fs3.lchmod = function(path2, mode, callback) {",
                "          fs3.open(",
                "            path2,",
                "            constants.O_WRONLY | constants.O_SYMLINK,",
                "            mode,",
                "            function(err, fd) {",
                "              if (err) {",
                "                if (callback)",
                "                  callback(err);",
                "                return;",
                "              }",
                "              fs3.fchmod(fd, mode, function(err2) {",
                "                fs3.close(fd, function(err22) {",
                "                  if (callback)",
                "                    callback(err2 || err22);",
                "                });",
                "              });",
                "            }",
                "          );",
                "        };",
                "        fs3.lchmodSync = function(path2, mode) {",
                "          var fd = fs3.openSync(path2, constants.O_WRONLY | constants.O_SYMLINK, mode);",
                "          var threw = true;",
                "          var ret;",
                "          try {",
                "            ret = fs3.fchmodSync(fd, mode);",
                "            threw = false;",
                "          } finally {",
                "            if (threw) {",
                "              try {",
                "                fs3.closeSync(fd);",
                "              } catch (er) {",
                "              }",
                "            } else {",
                "              fs3.closeSync(fd);",
                "            }",
                "          }",
                "          return ret;",
                "        };",
                "      }",
                "      function patchLutimes(fs3) {",
                "        if (constants.hasOwnProperty(\"O_SYMLINK\") && fs3.futimes) {",
                "          fs3.lutimes = function(path2, at, mt, cb) {",
                "            fs3.open(path2, constants.O_SYMLINK, function(er, fd) {",
                "              if (er) {",
                "                if (cb)",
                "                  cb(er);",
                "                return;",
                "              }",
                "              fs3.futimes(fd, at, mt, function(er2) {",
                "                fs3.close(fd, function(er22) {",
                "                  if (cb)",
                "                    cb(er2 || er22);",
                "                });",
                "              });",
                "            });",
                "          };",
                "          fs3.lutimesSync = function(path2, at, mt) {",
                "            var fd = fs3.openSync(path2, constants.O_SYMLINK);",
                "            var ret;",
                "            var threw = true;",
                "            try {",
                "              ret = fs3.futimesSync(fd, at, mt);",
                "              threw = false;",
                "            } finally {",
                "              if (threw) {",
                "                try {",
                "                  fs3.closeSync(fd);",
                "                } catch (er) {",
                "                }",
                "              } else {",
                "                fs3.closeSync(fd);",
                "              }",
                "            }",
                "            return ret;",
                "          };",
                "        } else if (fs3.futimes) {",
                "          fs3.lutimes = function(_a, _b, _c, cb) {",
                "            if (cb)",
                "              process.nextTick(cb);",
                "          };",
                "          fs3.lutimesSync = function() {",
                "          };",
                "        }",
                "      }",
                "      function chmodFix(orig) {",
                "        if (!orig)",
                "          return orig;",
                "        return function(target, mode, cb) {",
                "          return orig.call(fs2, target, mode, function(er) {",
                "            if (chownErOk(er))",
                "              er = null;",
                "            if (cb)",
                "              cb.apply(this, arguments);",
                "          });",
                "        };",
                "      }",
                "      function chmodFixSync(orig) {",
                "        if (!orig)",
                "          return orig;",
                "        return function(target, mode) {",
                "          try {",
                "            return orig.call(fs2, target, mode);",
                "          } catch (er) {",
                "            if (!chownErOk(er))",
                "              throw er;",
                "          }",
                "        };",
                "      }",
                "      function chownFix(orig) {",
                "        if (!orig)",
                "          return orig;",
                "        return function(target, uid, gid, cb) {",
                "          return orig.call(fs2, target, uid, gid, function(er) {",
                "            if (chownErOk(er))",
                "              er = null;",
                "            if (cb)",
                "              cb.apply(this, arguments);",
                "          });",
                "        };",
                "      }",
                "      function chownFixSync(orig) {",
                "        if (!orig)",
                "          return orig;",
                "        return function(target, uid, gid) {",
                "          try {",
                "            return orig.call(fs2, target, uid, gid);",
                "          } catch (er) {",
                "            if (!chownErOk(er))",
                "              throw er;",
                "          }",
                "        };",
                "      }",
                "      function statFix(orig) {",
                "        if (!orig)",
                "          return orig;",
                "        return function(target, options, cb) {",
                "          if (typeof options === \"function\") {",
                "            cb = options;",
                "            options = null;",
                "          }",
                "          function callback(er, stats) {",
                "            if (stats) {",
                "              if (stats.uid < 0)",
                "                stats.uid += 4294967296;",
                "              if (stats.gid < 0)",
                "                stats.gid += 4294967296;",
                "            }",
                "            if (cb)",
                "              cb.apply(this, arguments);",
                "          }",
                "          return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);",
                "        };",
                "      }",
                "      function statFixSync(orig) {",
                "        if (!orig)",
                "          return orig;",
                "        return function(target, options) {",
                "          var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);",
                "          if (stats) {",
                "            if (stats.uid < 0)",
                "              stats.uid += 4294967296;",
                "            if (stats.gid < 0)",
                "              stats.gid += 4294967296;",
                "          }",
                "          return stats;",
                "        };",
                "      }",
                "      function chownErOk(er) {",
                "        if (!er)",
                "          return true;",
                "        if (er.code === \"ENOSYS\")",
                "          return true;",
                "        var nonroot = !process.getuid || process.getuid() !== 0;",
                "        if (nonroot) {",
                "          if (er.code === \"EINVAL\" || er.code === \"EPERM\")",
                "            return true;",
                "        }",
                "        return false;",
                "      }",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/graceful-fs/legacy-streams.js",
                "var require_legacy_streams = __commonJS({",
                "  \"node_modules/graceful-fs/legacy-streams.js\"(exports, module2) {",
                "    var Stream = require(\"stream\").Stream;",
                "    module2.exports = legacy;",
                "    function legacy(fs2) {",
                "      return {",
                "        ReadStream,",
                "        WriteStream",
                "      };",
                "      function ReadStream(path2, options) {",
                "        if (!(this instanceof ReadStream))",
                "          return new ReadStream(path2, options);",
                "        Stream.call(this);",
                "        var self = this;",
                "        this.path = path2;",
                "        this.fd = null;",
                "        this.readable = true;",
                "        this.paused = false;",
                "        this.flags = \"r\";",
                "        this.mode = 438;",
                "        this.bufferSize = 64 * 1024;",
                "        options = options || {};",
                "        var keys = Object.keys(options);",
                "        for (var index = 0, length = keys.length; index < length; index++) {",
                "          var key = keys[index];",
                "          this[key] = options[key];",
                "        }",
                "        if (this.encoding)",
                "          this.setEncoding(this.encoding);",
                "        if (this.start !== void 0) {",
                "          if (\"number\" !== typeof this.start) {",
                "            throw TypeError(\"start must be a Number\");",
                "          }",
                "          if (this.end === void 0) {",
                "            this.end = Infinity;",
                "          } else if (\"number\" !== typeof this.end) {",
                "            throw TypeError(\"end must be a Number\");",
                "          }",
                "          if (this.start > this.end) {",
                "            throw new Error(\"start must be <= end\");",
                "          }",
                "          this.pos = this.start;",
                "        }",
                "        if (this.fd !== null) {",
                "          process.nextTick(function() {",
                "            self._read();",
                "          });",
                "          return;",
                "        }",
                "        fs2.open(this.path, this.flags, this.mode, function(err, fd) {",
                "          if (err) {",
                "            self.emit(\"error\", err);",
                "            self.readable = false;",
                "            return;",
                "          }",
                "          self.fd = fd;",
                "          self.emit(\"open\", fd);",
                "          self._read();",
                "        });",
                "      }",
                "      function WriteStream(path2, options) {",
                "        if (!(this instanceof WriteStream))",
                "          return new WriteStream(path2, options);",
                "        Stream.call(this);",
                "        this.path = path2;",
                "        this.fd = null;",
                "        this.writable = true;",
                "        this.flags = \"w\";",
                "        this.encoding = \"binary\";",
                "        this.mode = 438;",
                "        this.bytesWritten = 0;",
                "        options = options || {};",
                "        var keys = Object.keys(options);",
                "        for (var index = 0, length = keys.length; index < length; index++) {",
                "          var key = keys[index];",
                "          this[key] = options[key];",
                "        }",
                "        if (this.start !== void 0) {",
                "          if (\"number\" !== typeof this.start) {",
                "            throw TypeError(\"start must be a Number\");",
                "          }",
                "          if (this.start < 0) {",
                "            throw new Error(\"start must be >= zero\");",
                "          }",
                "          this.pos = this.start;",
                "        }",
                "        this.busy = false;",
                "        this._queue = [];",
                "        if (this.fd === null) {",
                "          this._open = fs2.open;",
                "          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);",
                "          this.flush();",
                "        }",
                "      }",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/graceful-fs/clone.js",
                "var require_clone = __commonJS({",
                "  \"node_modules/graceful-fs/clone.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = clone;",
                "    var getPrototypeOf = Object.getPrototypeOf || function(obj) {",
                "      return obj.__proto__;",
                "    };",
                "    function clone(obj) {",
                "      if (obj === null || typeof obj !== \"object\")",
                "        return obj;",
                "      if (obj instanceof Object)",
                "        var copy = { __proto__: getPrototypeOf(obj) };",
                "      else",
                "        var copy = /* @__PURE__ */ Object.create(null);",
                "      Object.getOwnPropertyNames(obj).forEach(function(key) {",
                "        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));",
                "      });",
                "      return copy;",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/graceful-fs/graceful-fs.js",
                "var require_graceful_fs = __commonJS({",
                "  \"node_modules/graceful-fs/graceful-fs.js\"(exports, module2) {",
                "    var fs2 = require(\"fs\");",
                "    var polyfills = require_polyfills();",
                "    var legacy = require_legacy_streams();",
                "    var clone = require_clone();",
                "    var util = require(\"util\");",
                "    var gracefulQueue;",
                "    var previousSymbol;",
                "    if (typeof Symbol === \"function\" && typeof Symbol.for === \"function\") {",
                "      gracefulQueue = Symbol.for(\"graceful-fs.queue\");",
                "      previousSymbol = Symbol.for(\"graceful-fs.previous\");",
                "    } else {",
                "      gracefulQueue = \"___graceful-fs.queue\";",
                "      previousSymbol = \"___graceful-fs.previous\";",
                "    }",
                "    function noop() {",
                "    }",
                "    function publishQueue(context, queue2) {",
                "      Object.defineProperty(context, gracefulQueue, {",
                "        get: function() {",
                "          return queue2;",
                "        }",
                "      });",
                "    }",
                "    var debug = noop;",
                "    if (util.debuglog)",
                "      debug = util.debuglog(\"gfs4\");",
                "    else if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || \"\"))",
                "      debug = function() {",
                "        var m = util.format.apply(util, arguments);",
                "        m = \"GFS4: \" + m.split(/\\n/).join(\"\\nGFS4: \");",
                "        console.error(m);",
                "      };",
                "    if (!fs2[gracefulQueue]) {",
                "      queue = global[gracefulQueue] || [];",
                "      publishQueue(fs2, queue);",
                "      fs2.close = function(fs$close) {",
                "        function close(fd, cb) {",
                "          return fs$close.call(fs2, fd, function(err) {",
                "            if (!err) {",
                "              resetQueue();",
                "            }",
                "            if (typeof cb === \"function\")",
                "              cb.apply(this, arguments);",
                "          });",
                "        }",
                "        Object.defineProperty(close, previousSymbol, {",
                "          value: fs$close",
                "        });",
                "        return close;",
                "      }(fs2.close);",
                "      fs2.closeSync = function(fs$closeSync) {",
                "        function closeSync(fd) {",
                "          fs$closeSync.apply(fs2, arguments);",
                "          resetQueue();",
                "        }",
                "        Object.defineProperty(closeSync, previousSymbol, {",
                "          value: fs$closeSync",
                "        });",
                "        return closeSync;",
                "      }(fs2.closeSync);",
                "      if (/\\bgfs4\\b/i.test(process.env.NODE_DEBUG || \"\")) {",
                "        process.on(\"exit\", function() {",
                "          debug(fs2[gracefulQueue]);",
                "          require(\"assert\").equal(fs2[gracefulQueue].length, 0);",
                "        });",
                "      }",
                "    }",
                "    var queue;",
                "    if (!global[gracefulQueue]) {",
                "      publishQueue(global, fs2[gracefulQueue]);",
                "    }",
                "    module2.exports = patch(clone(fs2));",
                "    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {",
                "      module2.exports = patch(fs2);",
                "      fs2.__patched = true;",
                "    }",
                "    function patch(fs3) {",
                "      polyfills(fs3);",
                "      fs3.gracefulify = patch;",
                "      fs3.createReadStream = createReadStream;",
                "      fs3.createWriteStream = createWriteStream;",
                "      var fs$readFile = fs3.readFile;",
                "      fs3.readFile = readFile;",
                "      function readFile(path2, options, cb) {",
                "        if (typeof options === \"function\")",
                "          cb = options, options = null;",
                "        return go$readFile(path2, options, cb);",
                "        function go$readFile(path3, options2, cb2, startTime) {",
                "          return fs$readFile(path3, options2, function(err) {",
                "            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))",
                "              enqueue([go$readFile, [path3, options2, cb2], err, startTime || Date.now(), Date.now()]);",
                "            else {",
                "              if (typeof cb2 === \"function\")",
                "                cb2.apply(this, arguments);",
                "            }",
                "          });",
                "        }",
                "      }",
                "      var fs$writeFile = fs3.writeFile;",
                "      fs3.writeFile = writeFile;",
                "      function writeFile(path2, data, options, cb) {",
                "        if (typeof options === \"function\")",
                "          cb = options, options = null;",
                "        return go$writeFile(path2, data, options, cb);",
                "        function go$writeFile(path3, data2, options2, cb2, startTime) {",
                "          return fs$writeFile(path3, data2, options2, function(err) {",
                "            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))",
                "              enqueue([go$writeFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);",
                "            else {",
                "              if (typeof cb2 === \"function\")",
                "                cb2.apply(this, arguments);",
                "            }",
                "          });",
                "        }",
                "      }",
                "      var fs$appendFile = fs3.appendFile;",
                "      if (fs$appendFile)",
                "        fs3.appendFile = appendFile;",
                "      function appendFile(path2, data, options, cb) {",
                "        if (typeof options === \"function\")",
                "          cb = options, options = null;",
                "        return go$appendFile(path2, data, options, cb);",
                "        function go$appendFile(path3, data2, options2, cb2, startTime) {",
                "          return fs$appendFile(path3, data2, options2, function(err) {",
                "            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))",
                "              enqueue([go$appendFile, [path3, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);",
                "            else {",
                "              if (typeof cb2 === \"function\")",
                "                cb2.apply(this, arguments);",
                "            }",
                "          });",
                "        }",
                "      }",
                "      var fs$copyFile = fs3.copyFile;",
                "      if (fs$copyFile)",
                "        fs3.copyFile = copyFile;",
                "      function copyFile(src, dest, flags, cb) {",
                "        if (typeof flags === \"function\") {",
                "          cb = flags;",
                "          flags = 0;",
                "        }",
                "        return go$copyFile(src, dest, flags, cb);",
                "        function go$copyFile(src2, dest2, flags2, cb2, startTime) {",
                "          return fs$copyFile(src2, dest2, flags2, function(err) {",
                "            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))",
                "              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);",
                "            else {",
                "              if (typeof cb2 === \"function\")",
                "                cb2.apply(this, arguments);",
                "            }",
                "          });",
                "        }",
                "      }",
                "      var fs$readdir = fs3.readdir;",
                "      fs3.readdir = readdir;",
                "      var noReaddirOptionVersions = /^v[0-5]\\./;",
                "      function readdir(path2, options, cb) {",
                "        if (typeof options === \"function\")",
                "          cb = options, options = null;",
                "        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path3, options2, cb2, startTime) {",
                "          return fs$readdir(path3, fs$readdirCallback(",
                "            path3,",
                "            options2,",
                "            cb2,",
                "            startTime",
                "          ));",
                "        } : function go$readdir2(path3, options2, cb2, startTime) {",
                "          return fs$readdir(path3, options2, fs$readdirCallback(",
                "            path3,",
                "            options2,",
                "            cb2,",
                "            startTime",
                "          ));",
                "        };",
                "        return go$readdir(path2, options, cb);",
                "        function fs$readdirCallback(path3, options2, cb2, startTime) {",
                "          return function(err, files) {",
                "            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))",
                "              enqueue([",
                "                go$readdir,",
                "                [path3, options2, cb2],",
                "                err,",
                "                startTime || Date.now(),",
                "                Date.now()",
                "              ]);",
                "            else {",
                "              if (files && files.sort)",
                "                files.sort();",
                "              if (typeof cb2 === \"function\")",
                "                cb2.call(this, err, files);",
                "            }",
                "          };",
                "        }",
                "      }",
                "      if (process.version.substr(0, 4) === \"v0.8\") {",
                "        var legStreams = legacy(fs3);",
                "        ReadStream = legStreams.ReadStream;",
                "        WriteStream = legStreams.WriteStream;",
                "      }",
                "      var fs$ReadStream = fs3.ReadStream;",
                "      if (fs$ReadStream) {",
                "        ReadStream.prototype = Object.create(fs$ReadStream.prototype);",
                "        ReadStream.prototype.open = ReadStream$open;",
                "      }",
                "      var fs$WriteStream = fs3.WriteStream;",
                "      if (fs$WriteStream) {",
                "        WriteStream.prototype = Object.create(fs$WriteStream.prototype);",
                "        WriteStream.prototype.open = WriteStream$open;",
                "      }",
                "      Object.defineProperty(fs3, \"ReadStream\", {",
                "        get: function() {",
                "          return ReadStream;",
                "        },",
                "        set: function(val) {",
                "          ReadStream = val;",
                "        },",
                "        enumerable: true,",
                "        configurable: true",
                "      });",
                "      Object.defineProperty(fs3, \"WriteStream\", {",
                "        get: function() {",
                "          return WriteStream;",
                "        },",
                "        set: function(val) {",
                "          WriteStream = val;",
                "        },",
                "        enumerable: true,",
                "        configurable: true",
                "      });",
                "      var FileReadStream = ReadStream;",
                "      Object.defineProperty(fs3, \"FileReadStream\", {",
                "        get: function() {",
                "          return FileReadStream;",
                "        },",
                "        set: function(val) {",
                "          FileReadStream = val;",
                "        },",
                "        enumerable: true,",
                "        configurable: true",
                "      });",
                "      var FileWriteStream = WriteStream;",
                "      Object.defineProperty(fs3, \"FileWriteStream\", {",
                "        get: function() {",
                "          return FileWriteStream;",
                "        },",
                "        set: function(val) {",
                "          FileWriteStream = val;",
                "        },",
                "        enumerable: true,",
                "        configurable: true",
                "      });",
                "      function ReadStream(path2, options) {",
                "        if (this instanceof ReadStream)",
                "          return fs$ReadStream.apply(this, arguments), this;",
                "        else",
                "          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);",
                "      }",
                "      function ReadStream$open() {",
                "        var that = this;",
                "        open(that.path, that.flags, that.mode, function(err, fd) {",
                "          if (err) {",
                "            if (that.autoClose)",
                "              that.destroy();",
                "            that.emit(\"error\", err);",
                "          } else {",
                "            that.fd = fd;",
                "            that.emit(\"open\", fd);",
                "            that.read();",
                "          }",
                "        });",
                "      }",
                "      function WriteStream(path2, options) {",
                "        if (this instanceof WriteStream)",
                "          return fs$WriteStream.apply(this, arguments), this;",
                "        else",
                "          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);",
                "      }",
                "      function WriteStream$open() {",
                "        var that = this;",
                "        open(that.path, that.flags, that.mode, function(err, fd) {",
                "          if (err) {",
                "            that.destroy();",
                "            that.emit(\"error\", err);",
                "          } else {",
                "            that.fd = fd;",
                "            that.emit(\"open\", fd);",
                "          }",
                "        });",
                "      }",
                "      function createReadStream(path2, options) {",
                "        return new fs3.ReadStream(path2, options);",
                "      }",
                "      function createWriteStream(path2, options) {",
                "        return new fs3.WriteStream(path2, options);",
                "      }",
                "      var fs$open = fs3.open;",
                "      fs3.open = open;",
                "      function open(path2, flags, mode, cb) {",
                "        if (typeof mode === \"function\")",
                "          cb = mode, mode = null;",
                "        return go$open(path2, flags, mode, cb);",
                "        function go$open(path3, flags2, mode2, cb2, startTime) {",
                "          return fs$open(path3, flags2, mode2, function(err, fd) {",
                "            if (err && (err.code === \"EMFILE\" || err.code === \"ENFILE\"))",
                "              enqueue([go$open, [path3, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);",
                "            else {",
                "              if (typeof cb2 === \"function\")",
                "                cb2.apply(this, arguments);",
                "            }",
                "          });",
                "        }",
                "      }",
                "      return fs3;",
                "    }",
                "    function enqueue(elem) {",
                "      debug(\"ENQUEUE\", elem[0].name, elem[1]);",
                "      fs2[gracefulQueue].push(elem);",
                "      retry();",
                "    }",
                "    var retryTimer;",
                "    function resetQueue() {",
                "      var now = Date.now();",
                "      for (var i = 0; i < fs2[gracefulQueue].length; ++i) {",
                "        if (fs2[gracefulQueue][i].length > 2) {",
                "          fs2[gracefulQueue][i][3] = now;",
                "          fs2[gracefulQueue][i][4] = now;",
                "        }",
                "      }",
                "      retry();",
                "    }",
                "    function retry() {",
                "      clearTimeout(retryTimer);",
                "      retryTimer = void 0;",
                "      if (fs2[gracefulQueue].length === 0)",
                "        return;",
                "      var elem = fs2[gracefulQueue].shift();",
                "      var fn = elem[0];",
                "      var args = elem[1];",
                "      var err = elem[2];",
                "      var startTime = elem[3];",
                "      var lastTime = elem[4];",
                "      if (startTime === void 0) {",
                "        debug(\"RETRY\", fn.name, args);",
                "        fn.apply(null, args);",
                "      } else if (Date.now() - startTime >= 6e4) {",
                "        debug(\"TIMEOUT\", fn.name, args);",
                "        var cb = args.pop();",
                "        if (typeof cb === \"function\")",
                "          cb.call(null, err);",
                "      } else {",
                "        var sinceAttempt = Date.now() - lastTime;",
                "        var sinceStart = Math.max(lastTime - startTime, 1);",
                "        var desiredDelay = Math.min(sinceStart * 1.2, 100);",
                "        if (sinceAttempt >= desiredDelay) {",
                "          debug(\"RETRY\", fn.name, args);",
                "          fn.apply(null, args.concat([startTime]));",
                "        } else {",
                "          fs2[gracefulQueue].push(elem);",
                "        }",
                "      }",
                "      if (retryTimer === void 0) {",
                "        retryTimer = setTimeout(retry, 0);",
                "      }",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/is-path-cwd/index.js",
                "var require_is_path_cwd = __commonJS({",
                "  \"node_modules/is-path-cwd/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var path2 = require(\"path\");",
                "    module2.exports = (path_) => {",
                "      let cwd = process.cwd();",
                "      path_ = path2.resolve(path_);",
                "      if (process.platform === \"win32\") {",
                "        cwd = cwd.toLowerCase();",
                "        path_ = path_.toLowerCase();",
                "      }",
                "      return path_ === cwd;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/is-path-inside/index.js",
                "var require_is_path_inside = __commonJS({",
                "  \"node_modules/is-path-inside/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var path2 = require(\"path\");",
                "    module2.exports = (childPath, parentPath) => {",
                "      const relation = path2.relative(parentPath, childPath);",
                "      return Boolean(",
                "        relation && relation !== \"..\" && !relation.startsWith(`..${path2.sep}`) && relation !== path2.resolve(childPath)",
                "      );",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/fs.realpath/old.js",
                "var require_old = __commonJS({",
                "  \"node_modules/fs.realpath/old.js\"(exports) {",
                "    var pathModule = require(\"path\");",
                "    var isWindows = process.platform === \"win32\";",
                "    var fs2 = require(\"fs\");",
                "    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);",
                "    function rethrow() {",
                "      var callback;",
                "      if (DEBUG) {",
                "        var backtrace = new Error();",
                "        callback = debugCallback;",
                "      } else",
                "        callback = missingCallback;",
                "      return callback;",
                "      function debugCallback(err) {",
                "        if (err) {",
                "          backtrace.message = err.message;",
                "          err = backtrace;",
                "          missingCallback(err);",
                "        }",
                "      }",
                "      function missingCallback(err) {",
                "        if (err) {",
                "          if (process.throwDeprecation)",
                "            throw err;",
                "          else if (!process.noDeprecation) {",
                "            var msg = \"fs: missing callback \" + (err.stack || err.message);",
                "            if (process.traceDeprecation)",
                "              console.trace(msg);",
                "            else",
                "              console.error(msg);",
                "          }",
                "        }",
                "      }",
                "    }",
                "    function maybeCallback(cb) {",
                "      return typeof cb === \"function\" ? cb : rethrow();",
                "    }",
                "    var normalize = pathModule.normalize;",
                "    if (isWindows) {",
                "      nextPartRe = /(.*?)(?:[\\/\\\\]+|$)/g;",
                "    } else {",
                "      nextPartRe = /(.*?)(?:[\\/]+|$)/g;",
                "    }",
                "    var nextPartRe;",
                "    if (isWindows) {",
                "      splitRootRe = /^(?:[a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/][^\\\\\\/]+)?[\\\\\\/]*/;",
                "    } else {",
                "      splitRootRe = /^[\\/]*/;",
                "    }",
                "    var splitRootRe;",
                "    exports.realpathSync = function realpathSync(p, cache) {",
                "      p = pathModule.resolve(p);",
                "      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {",
                "        return cache[p];",
                "      }",
                "      var original = p, seenLinks = {}, knownHard = {};",
                "      var pos;",
                "      var current;",
                "      var base;",
                "      var previous;",
                "      start();",
                "      function start() {",
                "        var m = splitRootRe.exec(p);",
                "        pos = m[0].length;",
                "        current = m[0];",
                "        base = m[0];",
                "        previous = \"\";",
                "        if (isWindows && !knownHard[base]) {",
                "          fs2.lstatSync(base);",
                "          knownHard[base] = true;",
                "        }",
                "      }",
                "      while (pos < p.length) {",
                "        nextPartRe.lastIndex = pos;",
                "        var result = nextPartRe.exec(p);",
                "        previous = current;",
                "        current += result[0];",
                "        base = previous + result[1];",
                "        pos = nextPartRe.lastIndex;",
                "        if (knownHard[base] || cache && cache[base] === base) {",
                "          continue;",
                "        }",
                "        var resolvedLink;",
                "        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {",
                "          resolvedLink = cache[base];",
                "        } else {",
                "          var stat = fs2.lstatSync(base);",
                "          if (!stat.isSymbolicLink()) {",
                "            knownHard[base] = true;",
                "            if (cache)",
                "              cache[base] = base;",
                "            continue;",
                "          }",
                "          var linkTarget = null;",
                "          if (!isWindows) {",
                "            var id = stat.dev.toString(32) + \":\" + stat.ino.toString(32);",
                "            if (seenLinks.hasOwnProperty(id)) {",
                "              linkTarget = seenLinks[id];",
                "            }",
                "          }",
                "          if (linkTarget === null) {",
                "            fs2.statSync(base);",
                "            linkTarget = fs2.readlinkSync(base);",
                "          }",
                "          resolvedLink = pathModule.resolve(previous, linkTarget);",
                "          if (cache)",
                "            cache[base] = resolvedLink;",
                "          if (!isWindows)",
                "            seenLinks[id] = linkTarget;",
                "        }",
                "        p = pathModule.resolve(resolvedLink, p.slice(pos));",
                "        start();",
                "      }",
                "      if (cache)",
                "        cache[original] = p;",
                "      return p;",
                "    };",
                "    exports.realpath = function realpath(p, cache, cb) {",
                "      if (typeof cb !== \"function\") {",
                "        cb = maybeCallback(cache);",
                "        cache = null;",
                "      }",
                "      p = pathModule.resolve(p);",
                "      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {",
                "        return process.nextTick(cb.bind(null, null, cache[p]));",
                "      }",
                "      var original = p, seenLinks = {}, knownHard = {};",
                "      var pos;",
                "      var current;",
                "      var base;",
                "      var previous;",
                "      start();",
                "      function start() {",
                "        var m = splitRootRe.exec(p);",
                "        pos = m[0].length;",
                "        current = m[0];",
                "        base = m[0];",
                "        previous = \"\";",
                "        if (isWindows && !knownHard[base]) {",
                "          fs2.lstat(base, function(err) {",
                "            if (err)",
                "              return cb(err);",
                "            knownHard[base] = true;",
                "            LOOP();",
                "          });",
                "        } else {",
                "          process.nextTick(LOOP);",
                "        }",
                "      }",
                "      function LOOP() {",
                "        if (pos >= p.length) {",
                "          if (cache)",
                "            cache[original] = p;",
                "          return cb(null, p);",
                "        }",
                "        nextPartRe.lastIndex = pos;",
                "        var result = nextPartRe.exec(p);",
                "        previous = current;",
                "        current += result[0];",
                "        base = previous + result[1];",
                "        pos = nextPartRe.lastIndex;",
                "        if (knownHard[base] || cache && cache[base] === base) {",
                "          return process.nextTick(LOOP);",
                "        }",
                "        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {",
                "          return gotResolvedLink(cache[base]);",
                "        }",
                "        return fs2.lstat(base, gotStat);",
                "      }",
                "      function gotStat(err, stat) {",
                "        if (err)",
                "          return cb(err);",
                "        if (!stat.isSymbolicLink()) {",
                "          knownHard[base] = true;",
                "          if (cache)",
                "            cache[base] = base;",
                "          return process.nextTick(LOOP);",
                "        }",
                "        if (!isWindows) {",
                "          var id = stat.dev.toString(32) + \":\" + stat.ino.toString(32);",
                "          if (seenLinks.hasOwnProperty(id)) {",
                "            return gotTarget(null, seenLinks[id], base);",
                "          }",
                "        }",
                "        fs2.stat(base, function(err2) {",
                "          if (err2)",
                "            return cb(err2);",
                "          fs2.readlink(base, function(err3, target) {",
                "            if (!isWindows)",
                "              seenLinks[id] = target;",
                "            gotTarget(err3, target);",
                "          });",
                "        });",
                "      }",
                "      function gotTarget(err, target, base2) {",
                "        if (err)",
                "          return cb(err);",
                "        var resolvedLink = pathModule.resolve(previous, target);",
                "        if (cache)",
                "          cache[base2] = resolvedLink;",
                "        gotResolvedLink(resolvedLink);",
                "      }",
                "      function gotResolvedLink(resolvedLink) {",
                "        p = pathModule.resolve(resolvedLink, p.slice(pos));",
                "        start();",
                "      }",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/fs.realpath/index.js",
                "var require_fs5 = __commonJS({",
                "  \"node_modules/fs.realpath/index.js\"(exports, module2) {",
                "    module2.exports = realpath;",
                "    realpath.realpath = realpath;",
                "    realpath.sync = realpathSync;",
                "    realpath.realpathSync = realpathSync;",
                "    realpath.monkeypatch = monkeypatch;",
                "    realpath.unmonkeypatch = unmonkeypatch;",
                "    var fs2 = require(\"fs\");",
                "    var origRealpath = fs2.realpath;",
                "    var origRealpathSync = fs2.realpathSync;",
                "    var version = process.version;",
                "    var ok = /^v[0-5]\\./.test(version);",
                "    var old = require_old();",
                "    function newError(er) {",
                "      return er && er.syscall === \"realpath\" && (er.code === \"ELOOP\" || er.code === \"ENOMEM\" || er.code === \"ENAMETOOLONG\");",
                "    }",
                "    function realpath(p, cache, cb) {",
                "      if (ok) {",
                "        return origRealpath(p, cache, cb);",
                "      }",
                "      if (typeof cache === \"function\") {",
                "        cb = cache;",
                "        cache = null;",
                "      }",
                "      origRealpath(p, cache, function(er, result) {",
                "        if (newError(er)) {",
                "          old.realpath(p, cache, cb);",
                "        } else {",
                "          cb(er, result);",
                "        }",
                "      });",
                "    }",
                "    function realpathSync(p, cache) {",
                "      if (ok) {",
                "        return origRealpathSync(p, cache);",
                "      }",
                "      try {",
                "        return origRealpathSync(p, cache);",
                "      } catch (er) {",
                "        if (newError(er)) {",
                "          return old.realpathSync(p, cache);",
                "        } else {",
                "          throw er;",
                "        }",
                "      }",
                "    }",
                "    function monkeypatch() {",
                "      fs2.realpath = realpath;",
                "      fs2.realpathSync = realpathSync;",
                "    }",
                "    function unmonkeypatch() {",
                "      fs2.realpath = origRealpath;",
                "      fs2.realpathSync = origRealpathSync;",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/concat-map/index.js",
                "var require_concat_map = __commonJS({",
                "  \"node_modules/concat-map/index.js\"(exports, module2) {",
                "    module2.exports = function(xs, fn) {",
                "      var res = [];",
                "      for (var i = 0; i < xs.length; i++) {",
                "        var x = fn(xs[i], i);",
                "        if (isArray(x))",
                "          res.push.apply(res, x);",
                "        else",
                "          res.push(x);",
                "      }",
                "      return res;",
                "    };",
                "    var isArray = Array.isArray || function(xs) {",
                "      return Object.prototype.toString.call(xs) === \"[object Array]\";",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/balanced-match/index.js",
                "var require_balanced_match = __commonJS({",
                "  \"node_modules/balanced-match/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = balanced;",
                "    function balanced(a, b, str) {",
                "      if (a instanceof RegExp)",
                "        a = maybeMatch(a, str);",
                "      if (b instanceof RegExp)",
                "        b = maybeMatch(b, str);",
                "      var r = range(a, b, str);",
                "      return r && {",
                "        start: r[0],",
                "        end: r[1],",
                "        pre: str.slice(0, r[0]),",
                "        body: str.slice(r[0] + a.length, r[1]),",
                "        post: str.slice(r[1] + b.length)",
                "      };",
                "    }",
                "    function maybeMatch(reg, str) {",
                "      var m = str.match(reg);",
                "      return m ? m[0] : null;",
                "    }",
                "    balanced.range = range;",
                "    function range(a, b, str) {",
                "      var begs, beg, left, right, result;",
                "      var ai = str.indexOf(a);",
                "      var bi = str.indexOf(b, ai + 1);",
                "      var i = ai;",
                "      if (ai >= 0 && bi > 0) {",
                "        if (a === b) {",
                "          return [ai, bi];",
                "        }",
                "        begs = [];",
                "        left = str.length;",
                "        while (i >= 0 && !result) {",
                "          if (i == ai) {",
                "            begs.push(i);",
                "            ai = str.indexOf(a, i + 1);",
                "          } else if (begs.length == 1) {",
                "            result = [begs.pop(), bi];",
                "          } else {",
                "            beg = begs.pop();",
                "            if (beg < left) {",
                "              left = beg;",
                "              right = bi;",
                "            }",
                "            bi = str.indexOf(b, i + 1);",
                "          }",
                "          i = ai < bi && ai >= 0 ? ai : bi;",
                "        }",
                "        if (begs.length) {",
                "          result = [left, right];",
                "        }",
                "      }",
                "      return result;",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/brace-expansion/index.js",
                "var require_brace_expansion = __commonJS({",
                "  \"node_modules/brace-expansion/index.js\"(exports, module2) {",
                "    var concatMap = require_concat_map();",
                "    var balanced = require_balanced_match();",
                "    module2.exports = expandTop;",
                "    var escSlash = \"\\0SLASH\" + Math.random() + \"\\0\";",
                "    var escOpen = \"\\0OPEN\" + Math.random() + \"\\0\";",
                "    var escClose = \"\\0CLOSE\" + Math.random() + \"\\0\";",
                "    var escComma = \"\\0COMMA\" + Math.random() + \"\\0\";",
                "    var escPeriod = \"\\0PERIOD\" + Math.random() + \"\\0\";",
                "    function numeric(str) {",
                "      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);",
                "    }",
                "    function escapeBraces(str) {",
                "      return str.split(\"\\\\\\\\\").join(escSlash).split(\"\\\\{\").join(escOpen).split(\"\\\\}\").join(escClose).split(\"\\\\,\").join(escComma).split(\"\\\\.\").join(escPeriod);",
                "    }",
                "    function unescapeBraces(str) {",
                "      return str.split(escSlash).join(\"\\\\\").split(escOpen).join(\"{\").split(escClose).join(\"}\").split(escComma).join(\",\").split(escPeriod).join(\".\");",
                "    }",
                "    function parseCommaParts(str) {",
                "      if (!str)",
                "        return [\"\"];",
                "      var parts = [];",
                "      var m = balanced(\"{\", \"}\", str);",
                "      if (!m)",
                "        return str.split(\",\");",
                "      var pre = m.pre;",
                "      var body = m.body;",
                "      var post = m.post;",
                "      var p = pre.split(\",\");",
                "      p[p.length - 1] += \"{\" + body + \"}\";",
                "      var postParts = parseCommaParts(post);",
                "      if (post.length) {",
                "        p[p.length - 1] += postParts.shift();",
                "        p.push.apply(p, postParts);",
                "      }",
                "      parts.push.apply(parts, p);",
                "      return parts;",
                "    }",
                "    function expandTop(str) {",
                "      if (!str)",
                "        return [];",
                "      if (str.substr(0, 2) === \"{}\") {",
                "        str = \"\\\\{\\\\}\" + str.substr(2);",
                "      }",
                "      return expand(escapeBraces(str), true).map(unescapeBraces);",
                "    }",
                "    function embrace(str) {",
                "      return \"{\" + str + \"}\";",
                "    }",
                "    function isPadded(el) {",
                "      return /^-?0\\d/.test(el);",
                "    }",
                "    function lte(i, y) {",
                "      return i <= y;",
                "    }",
                "    function gte(i, y) {",
                "      return i >= y;",
                "    }",
                "    function expand(str, isTop) {",
                "      var expansions = [];",
                "      var m = balanced(\"{\", \"}\", str);",
                "      if (!m || /\\$$/.test(m.pre))",
                "        return [str];",
                "      var isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body);",
                "      var isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body);",
                "      var isSequence = isNumericSequence || isAlphaSequence;",
                "      var isOptions = m.body.indexOf(\",\") >= 0;",
                "      if (!isSequence && !isOptions) {",
                "        if (m.post.match(/,.*\\}/)) {",
                "          str = m.pre + \"{\" + m.body + escClose + m.post;",
                "          return expand(str);",
                "        }",
                "        return [str];",
                "      }",
                "      var n;",
                "      if (isSequence) {",
                "        n = m.body.split(/\\.\\./);",
                "      } else {",
                "        n = parseCommaParts(m.body);",
                "        if (n.length === 1) {",
                "          n = expand(n[0], false).map(embrace);",
                "          if (n.length === 1) {",
                "            var post = m.post.length ? expand(m.post, false) : [\"\"];",
                "            return post.map(function(p) {",
                "              return m.pre + n[0] + p;",
                "            });",
                "          }",
                "        }",
                "      }",
                "      var pre = m.pre;",
                "      var post = m.post.length ? expand(m.post, false) : [\"\"];",
                "      var N;",
                "      if (isSequence) {",
                "        var x = numeric(n[0]);",
                "        var y = numeric(n[1]);",
                "        var width = Math.max(n[0].length, n[1].length);",
                "        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;",
                "        var test = lte;",
                "        var reverse = y < x;",
                "        if (reverse) {",
                "          incr *= -1;",
                "          test = gte;",
                "        }",
                "        var pad = n.some(isPadded);",
                "        N = [];",
                "        for (var i = x; test(i, y); i += incr) {",
                "          var c;",
                "          if (isAlphaSequence) {",
                "            c = String.fromCharCode(i);",
                "            if (c === \"\\\\\")",
                "              c = \"\";",
                "          } else {",
                "            c = String(i);",
                "            if (pad) {",
                "              var need = width - c.length;",
                "              if (need > 0) {",
                "                var z = new Array(need + 1).join(\"0\");",
                "                if (i < 0)",
                "                  c = \"-\" + z + c.slice(1);",
                "                else",
                "                  c = z + c;",
                "              }",
                "            }",
                "          }",
                "          N.push(c);",
                "        }",
                "      } else {",
                "        N = concatMap(n, function(el) {",
                "          return expand(el, false);",
                "        });",
                "      }",
                "      for (var j = 0; j < N.length; j++) {",
                "        for (var k = 0; k < post.length; k++) {",
                "          var expansion = pre + N[j] + post[k];",
                "          if (!isTop || isSequence || expansion)",
                "            expansions.push(expansion);",
                "        }",
                "      }",
                "      return expansions;",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/minimatch/minimatch.js",
                "var require_minimatch = __commonJS({",
                "  \"node_modules/minimatch/minimatch.js\"(exports, module2) {",
                "    module2.exports = minimatch;",
                "    minimatch.Minimatch = Minimatch;",
                "    var path2 = function() {",
                "      try {",
                "        return require(\"path\");",
                "      } catch (e) {",
                "      }",
                "    }() || {",
                "      sep: \"/\"",
                "    };",
                "    minimatch.sep = path2.sep;",
                "    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};",
                "    var expand = require_brace_expansion();",
                "    var plTypes = {",
                "      \"!\": { open: \"(?:(?!(?:\", close: \"))[^/]*?)\" },",
                "      \"?\": { open: \"(?:\", close: \")?\" },",
                "      \"+\": { open: \"(?:\", close: \")+\" },",
                "      \"*\": { open: \"(?:\", close: \")*\" },",
                "      \"@\": { open: \"(?:\", close: \")\" }",
                "    };",
                "    var qmark = \"[^/]\";",
                "    var star = qmark + \"*?\";",
                "    var twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";",
                "    var twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";",
                "    var reSpecials = charSet(\"().*{}+?[]^$\\\\!\");",
                "    function charSet(s) {",
                "      return s.split(\"\").reduce(function(set, c) {",
                "        set[c] = true;",
                "        return set;",
                "      }, {});",
                "    }",
                "    var slashSplit = /\\/+/;",
                "    minimatch.filter = filter;",
                "    function filter(pattern, options) {",
                "      options = options || {};",
                "      return function(p, i, list) {",
                "        return minimatch(p, pattern, options);",
                "      };",
                "    }",
                "    function ext(a, b) {",
                "      b = b || {};",
                "      var t = {};",
                "      Object.keys(a).forEach(function(k) {",
                "        t[k] = a[k];",
                "      });",
                "      Object.keys(b).forEach(function(k) {",
                "        t[k] = b[k];",
                "      });",
                "      return t;",
                "    }",
                "    minimatch.defaults = function(def) {",
                "      if (!def || typeof def !== \"object\" || !Object.keys(def).length) {",
                "        return minimatch;",
                "      }",
                "      var orig = minimatch;",
                "      var m = function minimatch2(p, pattern, options) {",
                "        return orig(p, pattern, ext(def, options));",
                "      };",
                "      m.Minimatch = function Minimatch2(pattern, options) {",
                "        return new orig.Minimatch(pattern, ext(def, options));",
                "      };",
                "      m.Minimatch.defaults = function defaults(options) {",
                "        return orig.defaults(ext(def, options)).Minimatch;",
                "      };",
                "      m.filter = function filter2(pattern, options) {",
                "        return orig.filter(pattern, ext(def, options));",
                "      };",
                "      m.defaults = function defaults(options) {",
                "        return orig.defaults(ext(def, options));",
                "      };",
                "      m.makeRe = function makeRe2(pattern, options) {",
                "        return orig.makeRe(pattern, ext(def, options));",
                "      };",
                "      m.braceExpand = function braceExpand2(pattern, options) {",
                "        return orig.braceExpand(pattern, ext(def, options));",
                "      };",
                "      m.match = function(list, pattern, options) {",
                "        return orig.match(list, pattern, ext(def, options));",
                "      };",
                "      return m;",
                "    };",
                "    Minimatch.defaults = function(def) {",
                "      return minimatch.defaults(def).Minimatch;",
                "    };",
                "    function minimatch(p, pattern, options) {",
                "      assertValidPattern(pattern);",
                "      if (!options)",
                "        options = {};",
                "      if (!options.nocomment && pattern.charAt(0) === \"#\") {",
                "        return false;",
                "      }",
                "      return new Minimatch(pattern, options).match(p);",
                "    }",
                "    function Minimatch(pattern, options) {",
                "      if (!(this instanceof Minimatch)) {",
                "        return new Minimatch(pattern, options);",
                "      }",
                "      assertValidPattern(pattern);",
                "      if (!options)",
                "        options = {};",
                "      pattern = pattern.trim();",
                "      if (!options.allowWindowsEscape && path2.sep !== \"/\") {",
                "        pattern = pattern.split(path2.sep).join(\"/\");",
                "      }",
                "      this.options = options;",
                "      this.set = [];",
                "      this.pattern = pattern;",
                "      this.regexp = null;",
                "      this.negate = false;",
                "      this.comment = false;",
                "      this.empty = false;",
                "      this.partial = !!options.partial;",
                "      this.make();",
                "    }",
                "    Minimatch.prototype.debug = function() {",
                "    };",
                "    Minimatch.prototype.make = make;",
                "    function make() {",
                "      var pattern = this.pattern;",
                "      var options = this.options;",
                "      if (!options.nocomment && pattern.charAt(0) === \"#\") {",
                "        this.comment = true;",
                "        return;",
                "      }",
                "      if (!pattern) {",
                "        this.empty = true;",
                "        return;",
                "      }",
                "      this.parseNegate();",
                "      var set = this.globSet = this.braceExpand();",
                "      if (options.debug)",
                "        this.debug = function debug() {",
                "          console.error.apply(console, arguments);",
                "        };",
                "      this.debug(this.pattern, set);",
                "      set = this.globParts = set.map(function(s) {",
                "        return s.split(slashSplit);",
                "      });",
                "      this.debug(this.pattern, set);",
                "      set = set.map(function(s, si, set2) {",
                "        return s.map(this.parse, this);",
                "      }, this);",
                "      this.debug(this.pattern, set);",
                "      set = set.filter(function(s) {",
                "        return s.indexOf(false) === -1;",
                "      });",
                "      this.debug(this.pattern, set);",
                "      this.set = set;",
                "    }",
                "    Minimatch.prototype.parseNegate = parseNegate;",
                "    function parseNegate() {",
                "      var pattern = this.pattern;",
                "      var negate = false;",
                "      var options = this.options;",
                "      var negateOffset = 0;",
                "      if (options.nonegate)",
                "        return;",
                "      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === \"!\"; i++) {",
                "        negate = !negate;",
                "        negateOffset++;",
                "      }",
                "      if (negateOffset)",
                "        this.pattern = pattern.substr(negateOffset);",
                "      this.negate = negate;",
                "    }",
                "    minimatch.braceExpand = function(pattern, options) {",
                "      return braceExpand(pattern, options);",
                "    };",
                "    Minimatch.prototype.braceExpand = braceExpand;",
                "    function braceExpand(pattern, options) {",
                "      if (!options) {",
                "        if (this instanceof Minimatch) {",
                "          options = this.options;",
                "        } else {",
                "          options = {};",
                "        }",
                "      }",
                "      pattern = typeof pattern === \"undefined\" ? this.pattern : pattern;",
                "      assertValidPattern(pattern);",
                "      if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {",
                "        return [pattern];",
                "      }",
                "      return expand(pattern);",
                "    }",
                "    var MAX_PATTERN_LENGTH = 1024 * 64;",
                "    var assertValidPattern = function(pattern) {",
                "      if (typeof pattern !== \"string\") {",
                "        throw new TypeError(\"invalid pattern\");",
                "      }",
                "      if (pattern.length > MAX_PATTERN_LENGTH) {",
                "        throw new TypeError(\"pattern is too long\");",
                "      }",
                "    };",
                "    Minimatch.prototype.parse = parse;",
                "    var SUBPARSE = {};",
                "    function parse(pattern, isSub) {",
                "      assertValidPattern(pattern);",
                "      var options = this.options;",
                "      if (pattern === \"**\") {",
                "        if (!options.noglobstar)",
                "          return GLOBSTAR;",
                "        else",
                "          pattern = \"*\";",
                "      }",
                "      if (pattern === \"\")",
                "        return \"\";",
                "      var re = \"\";",
                "      var hasMagic = !!options.nocase;",
                "      var escaping = false;",
                "      var patternListStack = [];",
                "      var negativeLists = [];",
                "      var stateChar;",
                "      var inClass = false;",
                "      var reClassStart = -1;",
                "      var classStart = -1;",
                "      var patternStart = pattern.charAt(0) === \".\" ? \"\" : options.dot ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";",
                "      var self = this;",
                "      function clearStateChar() {",
                "        if (stateChar) {",
                "          switch (stateChar) {",
                "            case \"*\":",
                "              re += star;",
                "              hasMagic = true;",
                "              break;",
                "            case \"?\":",
                "              re += qmark;",
                "              hasMagic = true;",
                "              break;",
                "            default:",
                "              re += \"\\\\\" + stateChar;",
                "              break;",
                "          }",
                "          self.debug(\"clearStateChar %j %j\", stateChar, re);",
                "          stateChar = false;",
                "        }",
                "      }",
                "      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {",
                "        this.debug(\"%s\t%s %s %j\", pattern, i, re, c);",
                "        if (escaping && reSpecials[c]) {",
                "          re += \"\\\\\" + c;",
                "          escaping = false;",
                "          continue;",
                "        }",
                "        switch (c) {",
                "          case \"/\": {",
                "            return false;",
                "          }",
                "          case \"\\\\\":",
                "            clearStateChar();",
                "            escaping = true;",
                "            continue;",
                "          case \"?\":",
                "          case \"*\":",
                "          case \"+\":",
                "          case \"@\":",
                "          case \"!\":",
                "            this.debug(\"%s\t%s %s %j <-- stateChar\", pattern, i, re, c);",
                "            if (inClass) {",
                "              this.debug(\"  in class\");",
                "              if (c === \"!\" && i === classStart + 1)",
                "                c = \"^\";",
                "              re += c;",
                "              continue;",
                "            }",
                "            self.debug(\"call clearStateChar %j\", stateChar);",
                "            clearStateChar();",
                "            stateChar = c;",
                "            if (options.noext)",
                "              clearStateChar();",
                "            continue;",
                "          case \"(\":",
                "            if (inClass) {",
                "              re += \"(\";",
                "              continue;",
                "            }",
                "            if (!stateChar) {",
                "              re += \"\\\\(\";",
                "              continue;",
                "            }",
                "            patternListStack.push({",
                "              type: stateChar,",
                "              start: i - 1,",
                "              reStart: re.length,",
                "              open: plTypes[stateChar].open,",
                "              close: plTypes[stateChar].close",
                "            });",
                "            re += stateChar === \"!\" ? \"(?:(?!(?:\" : \"(?:\";",
                "            this.debug(\"plType %j %j\", stateChar, re);",
                "            stateChar = false;",
                "            continue;",
                "          case \")\":",
                "            if (inClass || !patternListStack.length) {",
                "              re += \"\\\\)\";",
                "              continue;",
                "            }",
                "            clearStateChar();",
                "            hasMagic = true;",
                "            var pl = patternListStack.pop();",
                "            re += pl.close;",
                "            if (pl.type === \"!\") {",
                "              negativeLists.push(pl);",
                "            }",
                "            pl.reEnd = re.length;",
                "            continue;",
                "          case \"|\":",
                "            if (inClass || !patternListStack.length || escaping) {",
                "              re += \"\\\\|\";",
                "              escaping = false;",
                "              continue;",
                "            }",
                "            clearStateChar();",
                "            re += \"|\";",
                "            continue;",
                "          case \"[\":",
                "            clearStateChar();",
                "            if (inClass) {",
                "              re += \"\\\\\" + c;",
                "              continue;",
                "            }",
                "            inClass = true;",
                "            classStart = i;",
                "            reClassStart = re.length;",
                "            re += c;",
                "            continue;",
                "          case \"]\":",
                "            if (i === classStart + 1 || !inClass) {",
                "              re += \"\\\\\" + c;",
                "              escaping = false;",
                "              continue;",
                "            }",
                "            var cs = pattern.substring(classStart + 1, i);",
                "            try {",
                "              RegExp(\"[\" + cs + \"]\");",
                "            } catch (er) {",
                "              var sp = this.parse(cs, SUBPARSE);",
                "              re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0] + \"\\\\]\";",
                "              hasMagic = hasMagic || sp[1];",
                "              inClass = false;",
                "              continue;",
                "            }",
                "            hasMagic = true;",
                "            inClass = false;",
                "            re += c;",
                "            continue;",
                "          default:",
                "            clearStateChar();",
                "            if (escaping) {",
                "              escaping = false;",
                "            } else if (reSpecials[c] && !(c === \"^\" && inClass)) {",
                "              re += \"\\\\\";",
                "            }",
                "            re += c;",
                "        }",
                "      }",
                "      if (inClass) {",
                "        cs = pattern.substr(classStart + 1);",
                "        sp = this.parse(cs, SUBPARSE);",
                "        re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0];",
                "        hasMagic = hasMagic || sp[1];",
                "      }",
                "      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {",
                "        var tail = re.slice(pl.reStart + pl.open.length);",
                "        this.debug(\"setting tail\", re, pl);",
                "        tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function(_, $1, $2) {",
                "          if (!$2) {",
                "            $2 = \"\\\\\";",
                "          }",
                "          return $1 + $1 + $2 + \"|\";",
                "        });",
                "        this.debug(\"tail=%j\\n   %s\", tail, tail, pl, re);",
                "        var t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;",
                "        hasMagic = true;",
                "        re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;",
                "      }",
                "      clearStateChar();",
                "      if (escaping) {",
                "        re += \"\\\\\\\\\";",
                "      }",
                "      var addPatternStart = false;",
                "      switch (re.charAt(0)) {",
                "        case \"[\":",
                "        case \".\":",
                "        case \"(\":",
                "          addPatternStart = true;",
                "      }",
                "      for (var n = negativeLists.length - 1; n > -1; n--) {",
                "        var nl = negativeLists[n];",
                "        var nlBefore = re.slice(0, nl.reStart);",
                "        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);",
                "        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);",
                "        var nlAfter = re.slice(nl.reEnd);",
                "        nlLast += nlAfter;",
                "        var openParensBefore = nlBefore.split(\"(\").length - 1;",
                "        var cleanAfter = nlAfter;",
                "        for (i = 0; i < openParensBefore; i++) {",
                "          cleanAfter = cleanAfter.replace(/\\)[+*?]?/, \"\");",
                "        }",
                "        nlAfter = cleanAfter;",
                "        var dollar = \"\";",
                "        if (nlAfter === \"\" && isSub !== SUBPARSE) {",
                "          dollar = \"$\";",
                "        }",
                "        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;",
                "        re = newRe;",
                "      }",
                "      if (re !== \"\" && hasMagic) {",
                "        re = \"(?=.)\" + re;",
                "      }",
                "      if (addPatternStart) {",
                "        re = patternStart + re;",
                "      }",
                "      if (isSub === SUBPARSE) {",
                "        return [re, hasMagic];",
                "      }",
                "      if (!hasMagic) {",
                "        return globUnescape(pattern);",
                "      }",
                "      var flags = options.nocase ? \"i\" : \"\";",
                "      try {",
                "        var regExp = new RegExp(\"^\" + re + \"$\", flags);",
                "      } catch (er) {",
                "        return new RegExp(\"$.\");",
                "      }",
                "      regExp._glob = pattern;",
                "      regExp._src = re;",
                "      return regExp;",
                "    }",
                "    minimatch.makeRe = function(pattern, options) {",
                "      return new Minimatch(pattern, options || {}).makeRe();",
                "    };",
                "    Minimatch.prototype.makeRe = makeRe;",
                "    function makeRe() {",
                "      if (this.regexp || this.regexp === false)",
                "        return this.regexp;",
                "      var set = this.set;",
                "      if (!set.length) {",
                "        this.regexp = false;",
                "        return this.regexp;",
                "      }",
                "      var options = this.options;",
                "      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;",
                "      var flags = options.nocase ? \"i\" : \"\";",
                "      var re = set.map(function(pattern) {",
                "        return pattern.map(function(p) {",
                "          return p === GLOBSTAR ? twoStar : typeof p === \"string\" ? regExpEscape(p) : p._src;",
                "        }).join(\"\\\\/\");",
                "      }).join(\"|\");",
                "      re = \"^(?:\" + re + \")$\";",
                "      if (this.negate)",
                "        re = \"^(?!\" + re + \").*$\";",
                "      try {",
                "        this.regexp = new RegExp(re, flags);",
                "      } catch (ex) {",
                "        this.regexp = false;",
                "      }",
                "      return this.regexp;",
                "    }",
                "    minimatch.match = function(list, pattern, options) {",
                "      options = options || {};",
                "      var mm = new Minimatch(pattern, options);",
                "      list = list.filter(function(f) {",
                "        return mm.match(f);",
                "      });",
                "      if (mm.options.nonull && !list.length) {",
                "        list.push(pattern);",
                "      }",
                "      return list;",
                "    };",
                "    Minimatch.prototype.match = function match(f, partial) {",
                "      if (typeof partial === \"undefined\")",
                "        partial = this.partial;",
                "      this.debug(\"match\", f, this.pattern);",
                "      if (this.comment)",
                "        return false;",
                "      if (this.empty)",
                "        return f === \"\";",
                "      if (f === \"/\" && partial)",
                "        return true;",
                "      var options = this.options;",
                "      if (path2.sep !== \"/\") {",
                "        f = f.split(path2.sep).join(\"/\");",
                "      }",
                "      f = f.split(slashSplit);",
                "      this.debug(this.pattern, \"split\", f);",
                "      var set = this.set;",
                "      this.debug(this.pattern, \"set\", set);",
                "      var filename;",
                "      var i;",
                "      for (i = f.length - 1; i >= 0; i--) {",
                "        filename = f[i];",
                "        if (filename)",
                "          break;",
                "      }",
                "      for (i = 0; i < set.length; i++) {",
                "        var pattern = set[i];",
                "        var file = f;",
                "        if (options.matchBase && pattern.length === 1) {",
                "          file = [filename];",
                "        }",
                "        var hit = this.matchOne(file, pattern, partial);",
                "        if (hit) {",
                "          if (options.flipNegate)",
                "            return true;",
                "          return !this.negate;",
                "        }",
                "      }",
                "      if (options.flipNegate)",
                "        return false;",
                "      return this.negate;",
                "    };",
                "    Minimatch.prototype.matchOne = function(file, pattern, partial) {",
                "      var options = this.options;",
                "      this.debug(",
                "        \"matchOne\",",
                "        { \"this\": this, file, pattern }",
                "      );",
                "      this.debug(\"matchOne\", file.length, pattern.length);",
                "      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {",
                "        this.debug(\"matchOne loop\");",
                "        var p = pattern[pi];",
                "        var f = file[fi];",
                "        this.debug(pattern, p, f);",
                "        if (p === false)",
                "          return false;",
                "        if (p === GLOBSTAR) {",
                "          this.debug(\"GLOBSTAR\", [pattern, p, f]);",
                "          var fr = fi;",
                "          var pr = pi + 1;",
                "          if (pr === pl) {",
                "            this.debug(\"** at the end\");",
                "            for (; fi < fl; fi++) {",
                "              if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\")",
                "                return false;",
                "            }",
                "            return true;",
                "          }",
                "          while (fr < fl) {",
                "            var swallowee = file[fr];",
                "            this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);",
                "            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {",
                "              this.debug(\"globstar found match!\", fr, fl, swallowee);",
                "              return true;",
                "            } else {",
                "              if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {",
                "                this.debug(\"dot detected!\", file, fr, pattern, pr);",
                "                break;",
                "              }",
                "              this.debug(\"globstar swallow a segment, and continue\");",
                "              fr++;",
                "            }",
                "          }",
                "          if (partial) {",
                "            this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);",
                "            if (fr === fl)",
                "              return true;",
                "          }",
                "          return false;",
                "        }",
                "        var hit;",
                "        if (typeof p === \"string\") {",
                "          hit = f === p;",
                "          this.debug(\"string match\", p, f, hit);",
                "        } else {",
                "          hit = f.match(p);",
                "          this.debug(\"pattern match\", p, f, hit);",
                "        }",
                "        if (!hit)",
                "          return false;",
                "      }",
                "      if (fi === fl && pi === pl) {",
                "        return true;",
                "      } else if (fi === fl) {",
                "        return partial;",
                "      } else if (pi === pl) {",
                "        return fi === fl - 1 && file[fi] === \"\";",
                "      }",
                "      throw new Error(\"wtf?\");",
                "    };",
                "    function globUnescape(s) {",
                "      return s.replace(/\\\\(.)/g, \"$1\");",
                "    }",
                "    function regExpEscape(s) {",
                "      return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/inherits/inherits_browser.js",
                "var require_inherits_browser = __commonJS({",
                "  \"node_modules/inherits/inherits_browser.js\"(exports, module2) {",
                "    if (typeof Object.create === \"function\") {",
                "      module2.exports = function inherits(ctor, superCtor) {",
                "        if (superCtor) {",
                "          ctor.super_ = superCtor;",
                "          ctor.prototype = Object.create(superCtor.prototype, {",
                "            constructor: {",
                "              value: ctor,",
                "              enumerable: false,",
                "              writable: true,",
                "              configurable: true",
                "            }",
                "          });",
                "        }",
                "      };",
                "    } else {",
                "      module2.exports = function inherits(ctor, superCtor) {",
                "        if (superCtor) {",
                "          ctor.super_ = superCtor;",
                "          var TempCtor = function() {",
                "          };",
                "          TempCtor.prototype = superCtor.prototype;",
                "          ctor.prototype = new TempCtor();",
                "          ctor.prototype.constructor = ctor;",
                "        }",
                "      };",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/inherits/inherits.js",
                "var require_inherits = __commonJS({",
                "  \"node_modules/inherits/inherits.js\"(exports, module2) {",
                "    try {",
                "      util = require(\"util\");",
                "      if (typeof util.inherits !== \"function\")",
                "        throw \"\";",
                "      module2.exports = util.inherits;",
                "    } catch (e) {",
                "      module2.exports = require_inherits_browser();",
                "    }",
                "    var util;",
                "  }",
                "});",
                "",
                "// node_modules/path-is-absolute/index.js",
                "var require_path_is_absolute = __commonJS({",
                "  \"node_modules/path-is-absolute/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    function posix(path2) {",
                "      return path2.charAt(0) === \"/\";",
                "    }",
                "    function win32(path2) {",
                "      var splitDeviceRe = /^([a-zA-Z]:|[\\\\\\/]{2}[^\\\\\\/]+[\\\\\\/]+[^\\\\\\/]+)?([\\\\\\/])?([\\s\\S]*?)$/;",
                "      var result = splitDeviceRe.exec(path2);",
                "      var device = result[1] || \"\";",
                "      var isUnc = Boolean(device && device.charAt(1) !== \":\");",
                "      return Boolean(result[2] || isUnc);",
                "    }",
                "    module2.exports = process.platform === \"win32\" ? win32 : posix;",
                "    module2.exports.posix = posix;",
                "    module2.exports.win32 = win32;",
                "  }",
                "});",
                "",
                "// node_modules/glob/common.js",
                "var require_common3 = __commonJS({",
                "  \"node_modules/glob/common.js\"(exports) {",
                "    exports.setopts = setopts;",
                "    exports.ownProp = ownProp;",
                "    exports.makeAbs = makeAbs;",
                "    exports.finish = finish;",
                "    exports.mark = mark;",
                "    exports.isIgnored = isIgnored;",
                "    exports.childrenIgnored = childrenIgnored;",
                "    function ownProp(obj, field) {",
                "      return Object.prototype.hasOwnProperty.call(obj, field);",
                "    }",
                "    var fs2 = require(\"fs\");",
                "    var path2 = require(\"path\");",
                "    var minimatch = require_minimatch();",
                "    var isAbsolute = require_path_is_absolute();",
                "    var Minimatch = minimatch.Minimatch;",
                "    function alphasort(a, b) {",
                "      return a.localeCompare(b, \"en\");",
                "    }",
                "    function setupIgnores(self, options) {",
                "      self.ignore = options.ignore || [];",
                "      if (!Array.isArray(self.ignore))",
                "        self.ignore = [self.ignore];",
                "      if (self.ignore.length) {",
                "        self.ignore = self.ignore.map(ignoreMap);",
                "      }",
                "    }",
                "    function ignoreMap(pattern) {",
                "      var gmatcher = null;",
                "      if (pattern.slice(-3) === \"/**\") {",
                "        var gpattern = pattern.replace(/(\\/\\*\\*)+$/, \"\");",
                "        gmatcher = new Minimatch(gpattern, { dot: true });",
                "      }",
                "      return {",
                "        matcher: new Minimatch(pattern, { dot: true }),",
                "        gmatcher",
                "      };",
                "    }",
                "    function setopts(self, pattern, options) {",
                "      if (!options)",
                "        options = {};",
                "      if (options.matchBase && -1 === pattern.indexOf(\"/\")) {",
                "        if (options.noglobstar) {",
                "          throw new Error(\"base matching requires globstar\");",
                "        }",
                "        pattern = \"**/\" + pattern;",
                "      }",
                "      self.silent = !!options.silent;",
                "      self.pattern = pattern;",
                "      self.strict = options.strict !== false;",
                "      self.realpath = !!options.realpath;",
                "      self.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);",
                "      self.follow = !!options.follow;",
                "      self.dot = !!options.dot;",
                "      self.mark = !!options.mark;",
                "      self.nodir = !!options.nodir;",
                "      if (self.nodir)",
                "        self.mark = true;",
                "      self.sync = !!options.sync;",
                "      self.nounique = !!options.nounique;",
                "      self.nonull = !!options.nonull;",
                "      self.nosort = !!options.nosort;",
                "      self.nocase = !!options.nocase;",
                "      self.stat = !!options.stat;",
                "      self.noprocess = !!options.noprocess;",
                "      self.absolute = !!options.absolute;",
                "      self.fs = options.fs || fs2;",
                "      self.maxLength = options.maxLength || Infinity;",
                "      self.cache = options.cache || /* @__PURE__ */ Object.create(null);",
                "      self.statCache = options.statCache || /* @__PURE__ */ Object.create(null);",
                "      self.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);",
                "      setupIgnores(self, options);",
                "      self.changedCwd = false;",
                "      var cwd = process.cwd();",
                "      if (!ownProp(options, \"cwd\"))",
                "        self.cwd = cwd;",
                "      else {",
                "        self.cwd = path2.resolve(options.cwd);",
                "        self.changedCwd = self.cwd !== cwd;",
                "      }",
                "      self.root = options.root || path2.resolve(self.cwd, \"/\");",
                "      self.root = path2.resolve(self.root);",
                "      if (process.platform === \"win32\")",
                "        self.root = self.root.replace(/\\\\/g, \"/\");",
                "      self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd);",
                "      if (process.platform === \"win32\")",
                "        self.cwdAbs = self.cwdAbs.replace(/\\\\/g, \"/\");",
                "      self.nomount = !!options.nomount;",
                "      options.nonegate = true;",
                "      options.nocomment = true;",
                "      options.allowWindowsEscape = false;",
                "      self.minimatch = new Minimatch(pattern, options);",
                "      self.options = self.minimatch.options;",
                "    }",
                "    function finish(self) {",
                "      var nou = self.nounique;",
                "      var all = nou ? [] : /* @__PURE__ */ Object.create(null);",
                "      for (var i = 0, l = self.matches.length; i < l; i++) {",
                "        var matches = self.matches[i];",
                "        if (!matches || Object.keys(matches).length === 0) {",
                "          if (self.nonull) {",
                "            var literal = self.minimatch.globSet[i];",
                "            if (nou)",
                "              all.push(literal);",
                "            else",
                "              all[literal] = true;",
                "          }",
                "        } else {",
                "          var m = Object.keys(matches);",
                "          if (nou)",
                "            all.push.apply(all, m);",
                "          else",
                "            m.forEach(function(m2) {",
                "              all[m2] = true;",
                "            });",
                "        }",
                "      }",
                "      if (!nou)",
                "        all = Object.keys(all);",
                "      if (!self.nosort)",
                "        all = all.sort(alphasort);",
                "      if (self.mark) {",
                "        for (var i = 0; i < all.length; i++) {",
                "          all[i] = self._mark(all[i]);",
                "        }",
                "        if (self.nodir) {",
                "          all = all.filter(function(e) {",
                "            var notDir = !/\\/$/.test(e);",
                "            var c = self.cache[e] || self.cache[makeAbs(self, e)];",
                "            if (notDir && c)",
                "              notDir = c !== \"DIR\" && !Array.isArray(c);",
                "            return notDir;",
                "          });",
                "        }",
                "      }",
                "      if (self.ignore.length)",
                "        all = all.filter(function(m2) {",
                "          return !isIgnored(self, m2);",
                "        });",
                "      self.found = all;",
                "    }",
                "    function mark(self, p) {",
                "      var abs = makeAbs(self, p);",
                "      var c = self.cache[abs];",
                "      var m = p;",
                "      if (c) {",
                "        var isDir = c === \"DIR\" || Array.isArray(c);",
                "        var slash = p.slice(-1) === \"/\";",
                "        if (isDir && !slash)",
                "          m += \"/\";",
                "        else if (!isDir && slash)",
                "          m = m.slice(0, -1);",
                "        if (m !== p) {",
                "          var mabs = makeAbs(self, m);",
                "          self.statCache[mabs] = self.statCache[abs];",
                "          self.cache[mabs] = self.cache[abs];",
                "        }",
                "      }",
                "      return m;",
                "    }",
                "    function makeAbs(self, f) {",
                "      var abs = f;",
                "      if (f.charAt(0) === \"/\") {",
                "        abs = path2.join(self.root, f);",
                "      } else if (isAbsolute(f) || f === \"\") {",
                "        abs = f;",
                "      } else if (self.changedCwd) {",
                "        abs = path2.resolve(self.cwd, f);",
                "      } else {",
                "        abs = path2.resolve(f);",
                "      }",
                "      if (process.platform === \"win32\")",
                "        abs = abs.replace(/\\\\/g, \"/\");",
                "      return abs;",
                "    }",
                "    function isIgnored(self, path3) {",
                "      if (!self.ignore.length)",
                "        return false;",
                "      return self.ignore.some(function(item) {",
                "        return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));",
                "      });",
                "    }",
                "    function childrenIgnored(self, path3) {",
                "      if (!self.ignore.length)",
                "        return false;",
                "      return self.ignore.some(function(item) {",
                "        return !!(item.gmatcher && item.gmatcher.match(path3));",
                "      });",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/glob/sync.js",
                "var require_sync7 = __commonJS({",
                "  \"node_modules/glob/sync.js\"(exports, module2) {",
                "    module2.exports = globSync;",
                "    globSync.GlobSync = GlobSync;",
                "    var rp = require_fs5();",
                "    var minimatch = require_minimatch();",
                "    var Minimatch = minimatch.Minimatch;",
                "    var Glob = require_glob().Glob;",
                "    var util = require(\"util\");",
                "    var path2 = require(\"path\");",
                "    var assert = require(\"assert\");",
                "    var isAbsolute = require_path_is_absolute();",
                "    var common = require_common3();",
                "    var setopts = common.setopts;",
                "    var ownProp = common.ownProp;",
                "    var childrenIgnored = common.childrenIgnored;",
                "    var isIgnored = common.isIgnored;",
                "    function globSync(pattern, options) {",
                "      if (typeof options === \"function\" || arguments.length === 3)",
                "        throw new TypeError(\"callback provided to sync glob\\nSee: https://github.com/isaacs/node-glob/issues/167\");",
                "      return new GlobSync(pattern, options).found;",
                "    }",
                "    function GlobSync(pattern, options) {",
                "      if (!pattern)",
                "        throw new Error(\"must provide pattern\");",
                "      if (typeof options === \"function\" || arguments.length === 3)",
                "        throw new TypeError(\"callback provided to sync glob\\nSee: https://github.com/isaacs/node-glob/issues/167\");",
                "      if (!(this instanceof GlobSync))",
                "        return new GlobSync(pattern, options);",
                "      setopts(this, pattern, options);",
                "      if (this.noprocess)",
                "        return this;",
                "      var n = this.minimatch.set.length;",
                "      this.matches = new Array(n);",
                "      for (var i = 0; i < n; i++) {",
                "        this._process(this.minimatch.set[i], i, false);",
                "      }",
                "      this._finish();",
                "    }",
                "    GlobSync.prototype._finish = function() {",
                "      assert.ok(this instanceof GlobSync);",
                "      if (this.realpath) {",
                "        var self = this;",
                "        this.matches.forEach(function(matchset, index) {",
                "          var set = self.matches[index] = /* @__PURE__ */ Object.create(null);",
                "          for (var p in matchset) {",
                "            try {",
                "              p = self._makeAbs(p);",
                "              var real = rp.realpathSync(p, self.realpathCache);",
                "              set[real] = true;",
                "            } catch (er) {",
                "              if (er.syscall === \"stat\")",
                "                set[self._makeAbs(p)] = true;",
                "              else",
                "                throw er;",
                "            }",
                "          }",
                "        });",
                "      }",
                "      common.finish(this);",
                "    };",
                "    GlobSync.prototype._process = function(pattern, index, inGlobStar) {",
                "      assert.ok(this instanceof GlobSync);",
                "      var n = 0;",
                "      while (typeof pattern[n] === \"string\") {",
                "        n++;",
                "      }",
                "      var prefix;",
                "      switch (n) {",
                "        case pattern.length:",
                "          this._processSimple(pattern.join(\"/\"), index);",
                "          return;",
                "        case 0:",
                "          prefix = null;",
                "          break;",
                "        default:",
                "          prefix = pattern.slice(0, n).join(\"/\");",
                "          break;",
                "      }",
                "      var remain = pattern.slice(n);",
                "      var read;",
                "      if (prefix === null)",
                "        read = \".\";",
                "      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {",
                "        return typeof p === \"string\" ? p : \"[*]\";",
                "      }).join(\"/\"))) {",
                "        if (!prefix || !isAbsolute(prefix))",
                "          prefix = \"/\" + prefix;",
                "        read = prefix;",
                "      } else",
                "        read = prefix;",
                "      var abs = this._makeAbs(read);",
                "      if (childrenIgnored(this, read))",
                "        return;",
                "      var isGlobStar = remain[0] === minimatch.GLOBSTAR;",
                "      if (isGlobStar)",
                "        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);",
                "      else",
                "        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);",
                "    };",
                "    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {",
                "      var entries = this._readdir(abs, inGlobStar);",
                "      if (!entries)",
                "        return;",
                "      var pn = remain[0];",
                "      var negate = !!this.minimatch.negate;",
                "      var rawGlob = pn._glob;",
                "      var dotOk = this.dot || rawGlob.charAt(0) === \".\";",
                "      var matchedEntries = [];",
                "      for (var i = 0; i < entries.length; i++) {",
                "        var e = entries[i];",
                "        if (e.charAt(0) !== \".\" || dotOk) {",
                "          var m;",
                "          if (negate && !prefix) {",
                "            m = !e.match(pn);",
                "          } else {",
                "            m = e.match(pn);",
                "          }",
                "          if (m)",
                "            matchedEntries.push(e);",
                "        }",
                "      }",
                "      var len = matchedEntries.length;",
                "      if (len === 0)",
                "        return;",
                "      if (remain.length === 1 && !this.mark && !this.stat) {",
                "        if (!this.matches[index])",
                "          this.matches[index] = /* @__PURE__ */ Object.create(null);",
                "        for (var i = 0; i < len; i++) {",
                "          var e = matchedEntries[i];",
                "          if (prefix) {",
                "            if (prefix.slice(-1) !== \"/\")",
                "              e = prefix + \"/\" + e;",
                "            else",
                "              e = prefix + e;",
                "          }",
                "          if (e.charAt(0) === \"/\" && !this.nomount) {",
                "            e = path2.join(this.root, e);",
                "          }",
                "          this._emitMatch(index, e);",
                "        }",
                "        return;",
                "      }",
                "      remain.shift();",
                "      for (var i = 0; i < len; i++) {",
                "        var e = matchedEntries[i];",
                "        var newPattern;",
                "        if (prefix)",
                "          newPattern = [prefix, e];",
                "        else",
                "          newPattern = [e];",
                "        this._process(newPattern.concat(remain), index, inGlobStar);",
                "      }",
                "    };",
                "    GlobSync.prototype._emitMatch = function(index, e) {",
                "      if (isIgnored(this, e))",
                "        return;",
                "      var abs = this._makeAbs(e);",
                "      if (this.mark)",
                "        e = this._mark(e);",
                "      if (this.absolute) {",
                "        e = abs;",
                "      }",
                "      if (this.matches[index][e])",
                "        return;",
                "      if (this.nodir) {",
                "        var c = this.cache[abs];",
                "        if (c === \"DIR\" || Array.isArray(c))",
                "          return;",
                "      }",
                "      this.matches[index][e] = true;",
                "      if (this.stat)",
                "        this._stat(e);",
                "    };",
                "    GlobSync.prototype._readdirInGlobStar = function(abs) {",
                "      if (this.follow)",
                "        return this._readdir(abs, false);",
                "      var entries;",
                "      var lstat;",
                "      var stat;",
                "      try {",
                "        lstat = this.fs.lstatSync(abs);",
                "      } catch (er) {",
                "        if (er.code === \"ENOENT\") {",
                "          return null;",
                "        }",
                "      }",
                "      var isSym = lstat && lstat.isSymbolicLink();",
                "      this.symlinks[abs] = isSym;",
                "      if (!isSym && lstat && !lstat.isDirectory())",
                "        this.cache[abs] = \"FILE\";",
                "      else",
                "        entries = this._readdir(abs, false);",
                "      return entries;",
                "    };",
                "    GlobSync.prototype._readdir = function(abs, inGlobStar) {",
                "      var entries;",
                "      if (inGlobStar && !ownProp(this.symlinks, abs))",
                "        return this._readdirInGlobStar(abs);",
                "      if (ownProp(this.cache, abs)) {",
                "        var c = this.cache[abs];",
                "        if (!c || c === \"FILE\")",
                "          return null;",
                "        if (Array.isArray(c))",
                "          return c;",
                "      }",
                "      try {",
                "        return this._readdirEntries(abs, this.fs.readdirSync(abs));",
                "      } catch (er) {",
                "        this._readdirError(abs, er);",
                "        return null;",
                "      }",
                "    };",
                "    GlobSync.prototype._readdirEntries = function(abs, entries) {",
                "      if (!this.mark && !this.stat) {",
                "        for (var i = 0; i < entries.length; i++) {",
                "          var e = entries[i];",
                "          if (abs === \"/\")",
                "            e = abs + e;",
                "          else",
                "            e = abs + \"/\" + e;",
                "          this.cache[e] = true;",
                "        }",
                "      }",
                "      this.cache[abs] = entries;",
                "      return entries;",
                "    };",
                "    GlobSync.prototype._readdirError = function(f, er) {",
                "      switch (er.code) {",
                "        case \"ENOTSUP\":",
                "        case \"ENOTDIR\":",
                "          var abs = this._makeAbs(f);",
                "          this.cache[abs] = \"FILE\";",
                "          if (abs === this.cwdAbs) {",
                "            var error = new Error(er.code + \" invalid cwd \" + this.cwd);",
                "            error.path = this.cwd;",
                "            error.code = er.code;",
                "            throw error;",
                "          }",
                "          break;",
                "        case \"ENOENT\":",
                "        case \"ELOOP\":",
                "        case \"ENAMETOOLONG\":",
                "        case \"UNKNOWN\":",
                "          this.cache[this._makeAbs(f)] = false;",
                "          break;",
                "        default:",
                "          this.cache[this._makeAbs(f)] = false;",
                "          if (this.strict)",
                "            throw er;",
                "          if (!this.silent)",
                "            console.error(\"glob error\", er);",
                "          break;",
                "      }",
                "    };",
                "    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {",
                "      var entries = this._readdir(abs, inGlobStar);",
                "      if (!entries)",
                "        return;",
                "      var remainWithoutGlobStar = remain.slice(1);",
                "      var gspref = prefix ? [prefix] : [];",
                "      var noGlobStar = gspref.concat(remainWithoutGlobStar);",
                "      this._process(noGlobStar, index, false);",
                "      var len = entries.length;",
                "      var isSym = this.symlinks[abs];",
                "      if (isSym && inGlobStar)",
                "        return;",
                "      for (var i = 0; i < len; i++) {",
                "        var e = entries[i];",
                "        if (e.charAt(0) === \".\" && !this.dot)",
                "          continue;",
                "        var instead = gspref.concat(entries[i], remainWithoutGlobStar);",
                "        this._process(instead, index, true);",
                "        var below = gspref.concat(entries[i], remain);",
                "        this._process(below, index, true);",
                "      }",
                "    };",
                "    GlobSync.prototype._processSimple = function(prefix, index) {",
                "      var exists = this._stat(prefix);",
                "      if (!this.matches[index])",
                "        this.matches[index] = /* @__PURE__ */ Object.create(null);",
                "      if (!exists)",
                "        return;",
                "      if (prefix && isAbsolute(prefix) && !this.nomount) {",
                "        var trail = /[\\/\\\\]$/.test(prefix);",
                "        if (prefix.charAt(0) === \"/\") {",
                "          prefix = path2.join(this.root, prefix);",
                "        } else {",
                "          prefix = path2.resolve(this.root, prefix);",
                "          if (trail)",
                "            prefix += \"/\";",
                "        }",
                "      }",
                "      if (process.platform === \"win32\")",
                "        prefix = prefix.replace(/\\\\/g, \"/\");",
                "      this._emitMatch(index, prefix);",
                "    };",
                "    GlobSync.prototype._stat = function(f) {",
                "      var abs = this._makeAbs(f);",
                "      var needDir = f.slice(-1) === \"/\";",
                "      if (f.length > this.maxLength)",
                "        return false;",
                "      if (!this.stat && ownProp(this.cache, abs)) {",
                "        var c = this.cache[abs];",
                "        if (Array.isArray(c))",
                "          c = \"DIR\";",
                "        if (!needDir || c === \"DIR\")",
                "          return c;",
                "        if (needDir && c === \"FILE\")",
                "          return false;",
                "      }",
                "      var exists;",
                "      var stat = this.statCache[abs];",
                "      if (!stat) {",
                "        var lstat;",
                "        try {",
                "          lstat = this.fs.lstatSync(abs);",
                "        } catch (er) {",
                "          if (er && (er.code === \"ENOENT\" || er.code === \"ENOTDIR\")) {",
                "            this.statCache[abs] = false;",
                "            return false;",
                "          }",
                "        }",
                "        if (lstat && lstat.isSymbolicLink()) {",
                "          try {",
                "            stat = this.fs.statSync(abs);",
                "          } catch (er) {",
                "            stat = lstat;",
                "          }",
                "        } else {",
                "          stat = lstat;",
                "        }",
                "      }",
                "      this.statCache[abs] = stat;",
                "      var c = true;",
                "      if (stat)",
                "        c = stat.isDirectory() ? \"DIR\" : \"FILE\";",
                "      this.cache[abs] = this.cache[abs] || c;",
                "      if (needDir && c === \"FILE\")",
                "        return false;",
                "      return c;",
                "    };",
                "    GlobSync.prototype._mark = function(p) {",
                "      return common.mark(this, p);",
                "    };",
                "    GlobSync.prototype._makeAbs = function(f) {",
                "      return common.makeAbs(this, f);",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/wrappy/wrappy.js",
                "var require_wrappy = __commonJS({",
                "  \"node_modules/wrappy/wrappy.js\"(exports, module2) {",
                "    module2.exports = wrappy;",
                "    function wrappy(fn, cb) {",
                "      if (fn && cb)",
                "        return wrappy(fn)(cb);",
                "      if (typeof fn !== \"function\")",
                "        throw new TypeError(\"need wrapper function\");",
                "      Object.keys(fn).forEach(function(k) {",
                "        wrapper[k] = fn[k];",
                "      });",
                "      return wrapper;",
                "      function wrapper() {",
                "        var args = new Array(arguments.length);",
                "        for (var i = 0; i < args.length; i++) {",
                "          args[i] = arguments[i];",
                "        }",
                "        var ret = fn.apply(this, args);",
                "        var cb2 = args[args.length - 1];",
                "        if (typeof ret === \"function\" && ret !== cb2) {",
                "          Object.keys(cb2).forEach(function(k) {",
                "            ret[k] = cb2[k];",
                "          });",
                "        }",
                "        return ret;",
                "      }",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/once/once.js",
                "var require_once = __commonJS({",
                "  \"node_modules/once/once.js\"(exports, module2) {",
                "    var wrappy = require_wrappy();",
                "    module2.exports = wrappy(once);",
                "    module2.exports.strict = wrappy(onceStrict);",
                "    once.proto = once(function() {",
                "      Object.defineProperty(Function.prototype, \"once\", {",
                "        value: function() {",
                "          return once(this);",
                "        },",
                "        configurable: true",
                "      });",
                "      Object.defineProperty(Function.prototype, \"onceStrict\", {",
                "        value: function() {",
                "          return onceStrict(this);",
                "        },",
                "        configurable: true",
                "      });",
                "    });",
                "    function once(fn) {",
                "      var f = function() {",
                "        if (f.called)",
                "          return f.value;",
                "        f.called = true;",
                "        return f.value = fn.apply(this, arguments);",
                "      };",
                "      f.called = false;",
                "      return f;",
                "    }",
                "    function onceStrict(fn) {",
                "      var f = function() {",
                "        if (f.called)",
                "          throw new Error(f.onceError);",
                "        f.called = true;",
                "        return f.value = fn.apply(this, arguments);",
                "      };",
                "      var name = fn.name || \"Function wrapped with `once`\";",
                "      f.onceError = name + \" shouldn't be called more than once\";",
                "      f.called = false;",
                "      return f;",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/inflight/inflight.js",
                "var require_inflight = __commonJS({",
                "  \"node_modules/inflight/inflight.js\"(exports, module2) {",
                "    var wrappy = require_wrappy();",
                "    var reqs = /* @__PURE__ */ Object.create(null);",
                "    var once = require_once();",
                "    module2.exports = wrappy(inflight);",
                "    function inflight(key, cb) {",
                "      if (reqs[key]) {",
                "        reqs[key].push(cb);",
                "        return null;",
                "      } else {",
                "        reqs[key] = [cb];",
                "        return makeres(key);",
                "      }",
                "    }",
                "    function makeres(key) {",
                "      return once(function RES() {",
                "        var cbs = reqs[key];",
                "        var len = cbs.length;",
                "        var args = slice(arguments);",
                "        try {",
                "          for (var i = 0; i < len; i++) {",
                "            cbs[i].apply(null, args);",
                "          }",
                "        } finally {",
                "          if (cbs.length > len) {",
                "            cbs.splice(0, len);",
                "            process.nextTick(function() {",
                "              RES.apply(null, args);",
                "            });",
                "          } else {",
                "            delete reqs[key];",
                "          }",
                "        }",
                "      });",
                "    }",
                "    function slice(args) {",
                "      var length = args.length;",
                "      var array = [];",
                "      for (var i = 0; i < length; i++)",
                "        array[i] = args[i];",
                "      return array;",
                "    }",
                "  }",
                "});",
                "",
                "// node_modules/glob/glob.js",
                "var require_glob = __commonJS({",
                "  \"node_modules/glob/glob.js\"(exports, module2) {",
                "    module2.exports = glob;",
                "    var rp = require_fs5();",
                "    var minimatch = require_minimatch();",
                "    var Minimatch = minimatch.Minimatch;",
                "    var inherits = require_inherits();",
                "    var EE = require(\"events\").EventEmitter;",
                "    var path2 = require(\"path\");",
                "    var assert = require(\"assert\");",
                "    var isAbsolute = require_path_is_absolute();",
                "    var globSync = require_sync7();",
                "    var common = require_common3();",
                "    var setopts = common.setopts;",
                "    var ownProp = common.ownProp;",
                "    var inflight = require_inflight();",
                "    var util = require(\"util\");",
                "    var childrenIgnored = common.childrenIgnored;",
                "    var isIgnored = common.isIgnored;",
                "    var once = require_once();",
                "    function glob(pattern, options, cb) {",
                "      if (typeof options === \"function\")",
                "        cb = options, options = {};",
                "      if (!options)",
                "        options = {};",
                "      if (options.sync) {",
                "        if (cb)",
                "          throw new TypeError(\"callback provided to sync glob\");",
                "        return globSync(pattern, options);",
                "      }",
                "      return new Glob(pattern, options, cb);",
                "    }",
                "    glob.sync = globSync;",
                "    var GlobSync = glob.GlobSync = globSync.GlobSync;",
                "    glob.glob = glob;",
                "    function extend(origin, add) {",
                "      if (add === null || typeof add !== \"object\") {",
                "        return origin;",
                "      }",
                "      var keys = Object.keys(add);",
                "      var i = keys.length;",
                "      while (i--) {",
                "        origin[keys[i]] = add[keys[i]];",
                "      }",
                "      return origin;",
                "    }",
                "    glob.hasMagic = function(pattern, options_) {",
                "      var options = extend({}, options_);",
                "      options.noprocess = true;",
                "      var g = new Glob(pattern, options);",
                "      var set = g.minimatch.set;",
                "      if (!pattern)",
                "        return false;",
                "      if (set.length > 1)",
                "        return true;",
                "      for (var j = 0; j < set[0].length; j++) {",
                "        if (typeof set[0][j] !== \"string\")",
                "          return true;",
                "      }",
                "      return false;",
                "    };",
                "    glob.Glob = Glob;",
                "    inherits(Glob, EE);",
                "    function Glob(pattern, options, cb) {",
                "      if (typeof options === \"function\") {",
                "        cb = options;",
                "        options = null;",
                "      }",
                "      if (options && options.sync) {",
                "        if (cb)",
                "          throw new TypeError(\"callback provided to sync glob\");",
                "        return new GlobSync(pattern, options);",
                "      }",
                "      if (!(this instanceof Glob))",
                "        return new Glob(pattern, options, cb);",
                "      setopts(this, pattern, options);",
                "      this._didRealPath = false;",
                "      var n = this.minimatch.set.length;",
                "      this.matches = new Array(n);",
                "      if (typeof cb === \"function\") {",
                "        cb = once(cb);",
                "        this.on(\"error\", cb);",
                "        this.on(\"end\", function(matches) {",
                "          cb(null, matches);",
                "        });",
                "      }",
                "      var self = this;",
                "      this._processing = 0;",
                "      this._emitQueue = [];",
                "      this._processQueue = [];",
                "      this.paused = false;",
                "      if (this.noprocess)",
                "        return this;",
                "      if (n === 0)",
                "        return done();",
                "      var sync = true;",
                "      for (var i = 0; i < n; i++) {",
                "        this._process(this.minimatch.set[i], i, false, done);",
                "      }",
                "      sync = false;",
                "      function done() {",
                "        --self._processing;",
                "        if (self._processing <= 0) {",
                "          if (sync) {",
                "            process.nextTick(function() {",
                "              self._finish();",
                "            });",
                "          } else {",
                "            self._finish();",
                "          }",
                "        }",
                "      }",
                "    }",
                "    Glob.prototype._finish = function() {",
                "      assert(this instanceof Glob);",
                "      if (this.aborted)",
                "        return;",
                "      if (this.realpath && !this._didRealpath)",
                "        return this._realpath();",
                "      common.finish(this);",
                "      this.emit(\"end\", this.found);",
                "    };",
                "    Glob.prototype._realpath = function() {",
                "      if (this._didRealpath)",
                "        return;",
                "      this._didRealpath = true;",
                "      var n = this.matches.length;",
                "      if (n === 0)",
                "        return this._finish();",
                "      var self = this;",
                "      for (var i = 0; i < this.matches.length; i++)",
                "        this._realpathSet(i, next);",
                "      function next() {",
                "        if (--n === 0)",
                "          self._finish();",
                "      }",
                "    };",
                "    Glob.prototype._realpathSet = function(index, cb) {",
                "      var matchset = this.matches[index];",
                "      if (!matchset)",
                "        return cb();",
                "      var found = Object.keys(matchset);",
                "      var self = this;",
                "      var n = found.length;",
                "      if (n === 0)",
                "        return cb();",
                "      var set = this.matches[index] = /* @__PURE__ */ Object.create(null);",
                "      found.forEach(function(p, i) {",
                "        p = self._makeAbs(p);",
                "        rp.realpath(p, self.realpathCache, function(er, real) {",
                "          if (!er)",
                "            set[real] = true;",
                "          else if (er.syscall === \"stat\")",
                "            set[p] = true;",
                "          else",
                "            self.emit(\"error\", er);",
                "          if (--n === 0) {",
                "            self.matches[index] = set;",
                "            cb();",
                "          }",
                "        });",
                "      });",
                "    };",
                "    Glob.prototype._mark = function(p) {",
                "      return common.mark(this, p);",
                "    };",
                "    Glob.prototype._makeAbs = function(f) {",
                "      return common.makeAbs(this, f);",
                "    };",
                "    Glob.prototype.abort = function() {",
                "      this.aborted = true;",
                "      this.emit(\"abort\");",
                "    };",
                "    Glob.prototype.pause = function() {",
                "      if (!this.paused) {",
                "        this.paused = true;",
                "        this.emit(\"pause\");",
                "      }",
                "    };",
                "    Glob.prototype.resume = function() {",
                "      if (this.paused) {",
                "        this.emit(\"resume\");",
                "        this.paused = false;",
                "        if (this._emitQueue.length) {",
                "          var eq = this._emitQueue.slice(0);",
                "          this._emitQueue.length = 0;",
                "          for (var i = 0; i < eq.length; i++) {",
                "            var e = eq[i];",
                "            this._emitMatch(e[0], e[1]);",
                "          }",
                "        }",
                "        if (this._processQueue.length) {",
                "          var pq = this._processQueue.slice(0);",
                "          this._processQueue.length = 0;",
                "          for (var i = 0; i < pq.length; i++) {",
                "            var p = pq[i];",
                "            this._processing--;",
                "            this._process(p[0], p[1], p[2], p[3]);",
                "          }",
                "        }",
                "      }",
                "    };",
                "    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {",
                "      assert(this instanceof Glob);",
                "      assert(typeof cb === \"function\");",
                "      if (this.aborted)",
                "        return;",
                "      this._processing++;",
                "      if (this.paused) {",
                "        this._processQueue.push([pattern, index, inGlobStar, cb]);",
                "        return;",
                "      }",
                "      var n = 0;",
                "      while (typeof pattern[n] === \"string\") {",
                "        n++;",
                "      }",
                "      var prefix;",
                "      switch (n) {",
                "        case pattern.length:",
                "          this._processSimple(pattern.join(\"/\"), index, cb);",
                "          return;",
                "        case 0:",
                "          prefix = null;",
                "          break;",
                "        default:",
                "          prefix = pattern.slice(0, n).join(\"/\");",
                "          break;",
                "      }",
                "      var remain = pattern.slice(n);",
                "      var read;",
                "      if (prefix === null)",
                "        read = \".\";",
                "      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {",
                "        return typeof p === \"string\" ? p : \"[*]\";",
                "      }).join(\"/\"))) {",
                "        if (!prefix || !isAbsolute(prefix))",
                "          prefix = \"/\" + prefix;",
                "        read = prefix;",
                "      } else",
                "        read = prefix;",
                "      var abs = this._makeAbs(read);",
                "      if (childrenIgnored(this, read))",
                "        return cb();",
                "      var isGlobStar = remain[0] === minimatch.GLOBSTAR;",
                "      if (isGlobStar)",
                "        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);",
                "      else",
                "        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);",
                "    };",
                "    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {",
                "      var self = this;",
                "      this._readdir(abs, inGlobStar, function(er, entries) {",
                "        return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);",
                "      });",
                "    };",
                "    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {",
                "      if (!entries)",
                "        return cb();",
                "      var pn = remain[0];",
                "      var negate = !!this.minimatch.negate;",
                "      var rawGlob = pn._glob;",
                "      var dotOk = this.dot || rawGlob.charAt(0) === \".\";",
                "      var matchedEntries = [];",
                "      for (var i = 0; i < entries.length; i++) {",
                "        var e = entries[i];",
                "        if (e.charAt(0) !== \".\" || dotOk) {",
                "          var m;",
                "          if (negate && !prefix) {",
                "            m = !e.match(pn);",
                "          } else {",
                "            m = e.match(pn);",
                "          }",
                "          if (m)",
                "            matchedEntries.push(e);",
                "        }",
                "      }",
                "      var len = matchedEntries.length;",
                "      if (len === 0)",
                "        return cb();",
                "      if (remain.length === 1 && !this.mark && !this.stat) {",
                "        if (!this.matches[index])",
                "          this.matches[index] = /* @__PURE__ */ Object.create(null);",
                "        for (var i = 0; i < len; i++) {",
                "          var e = matchedEntries[i];",
                "          if (prefix) {",
                "            if (prefix !== \"/\")",
                "              e = prefix + \"/\" + e;",
                "            else",
                "              e = prefix + e;",
                "          }",
                "          if (e.charAt(0) === \"/\" && !this.nomount) {",
                "            e = path2.join(this.root, e);",
                "          }",
                "          this._emitMatch(index, e);",
                "        }",
                "        return cb();",
                "      }",
                "      remain.shift();",
                "      for (var i = 0; i < len; i++) {",
                "        var e = matchedEntries[i];",
                "        var newPattern;",
                "        if (prefix) {",
                "          if (prefix !== \"/\")",
                "            e = prefix + \"/\" + e;",
                "          else",
                "            e = prefix + e;",
                "        }",
                "        this._process([e].concat(remain), index, inGlobStar, cb);",
                "      }",
                "      cb();",
                "    };",
                "    Glob.prototype._emitMatch = function(index, e) {",
                "      if (this.aborted)",
                "        return;",
                "      if (isIgnored(this, e))",
                "        return;",
                "      if (this.paused) {",
                "        this._emitQueue.push([index, e]);",
                "        return;",
                "      }",
                "      var abs = isAbsolute(e) ? e : this._makeAbs(e);",
                "      if (this.mark)",
                "        e = this._mark(e);",
                "      if (this.absolute)",
                "        e = abs;",
                "      if (this.matches[index][e])",
                "        return;",
                "      if (this.nodir) {",
                "        var c = this.cache[abs];",
                "        if (c === \"DIR\" || Array.isArray(c))",
                "          return;",
                "      }",
                "      this.matches[index][e] = true;",
                "      var st = this.statCache[abs];",
                "      if (st)",
                "        this.emit(\"stat\", e, st);",
                "      this.emit(\"match\", e);",
                "    };",
                "    Glob.prototype._readdirInGlobStar = function(abs, cb) {",
                "      if (this.aborted)",
                "        return;",
                "      if (this.follow)",
                "        return this._readdir(abs, false, cb);",
                "      var lstatkey = \"lstat\\0\" + abs;",
                "      var self = this;",
                "      var lstatcb = inflight(lstatkey, lstatcb_);",
                "      if (lstatcb)",
                "        self.fs.lstat(abs, lstatcb);",
                "      function lstatcb_(er, lstat) {",
                "        if (er && er.code === \"ENOENT\")",
                "          return cb();",
                "        var isSym = lstat && lstat.isSymbolicLink();",
                "        self.symlinks[abs] = isSym;",
                "        if (!isSym && lstat && !lstat.isDirectory()) {",
                "          self.cache[abs] = \"FILE\";",
                "          cb();",
                "        } else",
                "          self._readdir(abs, false, cb);",
                "      }",
                "    };",
                "    Glob.prototype._readdir = function(abs, inGlobStar, cb) {",
                "      if (this.aborted)",
                "        return;",
                "      cb = inflight(\"readdir\\0\" + abs + \"\\0\" + inGlobStar, cb);",
                "      if (!cb)",
                "        return;",
                "      if (inGlobStar && !ownProp(this.symlinks, abs))",
                "        return this._readdirInGlobStar(abs, cb);",
                "      if (ownProp(this.cache, abs)) {",
                "        var c = this.cache[abs];",
                "        if (!c || c === \"FILE\")",
                "          return cb();",
                "        if (Array.isArray(c))",
                "          return cb(null, c);",
                "      }",
                "      var self = this;",
                "      self.fs.readdir(abs, readdirCb(this, abs, cb));",
                "    };",
                "    function readdirCb(self, abs, cb) {",
                "      return function(er, entries) {",
                "        if (er)",
                "          self._readdirError(abs, er, cb);",
                "        else",
                "          self._readdirEntries(abs, entries, cb);",
                "      };",
                "    }",
                "    Glob.prototype._readdirEntries = function(abs, entries, cb) {",
                "      if (this.aborted)",
                "        return;",
                "      if (!this.mark && !this.stat) {",
                "        for (var i = 0; i < entries.length; i++) {",
                "          var e = entries[i];",
                "          if (abs === \"/\")",
                "            e = abs + e;",
                "          else",
                "            e = abs + \"/\" + e;",
                "          this.cache[e] = true;",
                "        }",
                "      }",
                "      this.cache[abs] = entries;",
                "      return cb(null, entries);",
                "    };",
                "    Glob.prototype._readdirError = function(f, er, cb) {",
                "      if (this.aborted)",
                "        return;",
                "      switch (er.code) {",
                "        case \"ENOTSUP\":",
                "        case \"ENOTDIR\":",
                "          var abs = this._makeAbs(f);",
                "          this.cache[abs] = \"FILE\";",
                "          if (abs === this.cwdAbs) {",
                "            var error = new Error(er.code + \" invalid cwd \" + this.cwd);",
                "            error.path = this.cwd;",
                "            error.code = er.code;",
                "            this.emit(\"error\", error);",
                "            this.abort();",
                "          }",
                "          break;",
                "        case \"ENOENT\":",
                "        case \"ELOOP\":",
                "        case \"ENAMETOOLONG\":",
                "        case \"UNKNOWN\":",
                "          this.cache[this._makeAbs(f)] = false;",
                "          break;",
                "        default:",
                "          this.cache[this._makeAbs(f)] = false;",
                "          if (this.strict) {",
                "            this.emit(\"error\", er);",
                "            this.abort();",
                "          }",
                "          if (!this.silent)",
                "            console.error(\"glob error\", er);",
                "          break;",
                "      }",
                "      return cb();",
                "    };",
                "    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {",
                "      var self = this;",
                "      this._readdir(abs, inGlobStar, function(er, entries) {",
                "        self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);",
                "      });",
                "    };",
                "    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {",
                "      if (!entries)",
                "        return cb();",
                "      var remainWithoutGlobStar = remain.slice(1);",
                "      var gspref = prefix ? [prefix] : [];",
                "      var noGlobStar = gspref.concat(remainWithoutGlobStar);",
                "      this._process(noGlobStar, index, false, cb);",
                "      var isSym = this.symlinks[abs];",
                "      var len = entries.length;",
                "      if (isSym && inGlobStar)",
                "        return cb();",
                "      for (var i = 0; i < len; i++) {",
                "        var e = entries[i];",
                "        if (e.charAt(0) === \".\" && !this.dot)",
                "          continue;",
                "        var instead = gspref.concat(entries[i], remainWithoutGlobStar);",
                "        this._process(instead, index, true, cb);",
                "        var below = gspref.concat(entries[i], remain);",
                "        this._process(below, index, true, cb);",
                "      }",
                "      cb();",
                "    };",
                "    Glob.prototype._processSimple = function(prefix, index, cb) {",
                "      var self = this;",
                "      this._stat(prefix, function(er, exists) {",
                "        self._processSimple2(prefix, index, er, exists, cb);",
                "      });",
                "    };",
                "    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {",
                "      if (!this.matches[index])",
                "        this.matches[index] = /* @__PURE__ */ Object.create(null);",
                "      if (!exists)",
                "        return cb();",
                "      if (prefix && isAbsolute(prefix) && !this.nomount) {",
                "        var trail = /[\\/\\\\]$/.test(prefix);",
                "        if (prefix.charAt(0) === \"/\") {",
                "          prefix = path2.join(this.root, prefix);",
                "        } else {",
                "          prefix = path2.resolve(this.root, prefix);",
                "          if (trail)",
                "            prefix += \"/\";",
                "        }",
                "      }",
                "      if (process.platform === \"win32\")",
                "        prefix = prefix.replace(/\\\\/g, \"/\");",
                "      this._emitMatch(index, prefix);",
                "      cb();",
                "    };",
                "    Glob.prototype._stat = function(f, cb) {",
                "      var abs = this._makeAbs(f);",
                "      var needDir = f.slice(-1) === \"/\";",
                "      if (f.length > this.maxLength)",
                "        return cb();",
                "      if (!this.stat && ownProp(this.cache, abs)) {",
                "        var c = this.cache[abs];",
                "        if (Array.isArray(c))",
                "          c = \"DIR\";",
                "        if (!needDir || c === \"DIR\")",
                "          return cb(null, c);",
                "        if (needDir && c === \"FILE\")",
                "          return cb();",
                "      }",
                "      var exists;",
                "      var stat = this.statCache[abs];",
                "      if (stat !== void 0) {",
                "        if (stat === false)",
                "          return cb(null, stat);",
                "        else {",
                "          var type = stat.isDirectory() ? \"DIR\" : \"FILE\";",
                "          if (needDir && type === \"FILE\")",
                "            return cb();",
                "          else",
                "            return cb(null, type, stat);",
                "        }",
                "      }",
                "      var self = this;",
                "      var statcb = inflight(\"stat\\0\" + abs, lstatcb_);",
                "      if (statcb)",
                "        self.fs.lstat(abs, statcb);",
                "      function lstatcb_(er, lstat) {",
                "        if (lstat && lstat.isSymbolicLink()) {",
                "          return self.fs.stat(abs, function(er2, stat2) {",
                "            if (er2)",
                "              self._stat2(f, abs, null, lstat, cb);",
                "            else",
                "              self._stat2(f, abs, er2, stat2, cb);",
                "          });",
                "        } else {",
                "          self._stat2(f, abs, er, lstat, cb);",
                "        }",
                "      }",
                "    };",
                "    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {",
                "      if (er && (er.code === \"ENOENT\" || er.code === \"ENOTDIR\")) {",
                "        this.statCache[abs] = false;",
                "        return cb();",
                "      }",
                "      var needDir = f.slice(-1) === \"/\";",
                "      this.statCache[abs] = stat;",
                "      if (abs.slice(-1) === \"/\" && stat && !stat.isDirectory())",
                "        return cb(null, false, stat);",
                "      var c = true;",
                "      if (stat)",
                "        c = stat.isDirectory() ? \"DIR\" : \"FILE\";",
                "      this.cache[abs] = this.cache[abs] || c;",
                "      if (needDir && c === \"FILE\")",
                "        return cb();",
                "      return cb(null, c, stat);",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/rimraf/rimraf.js",
                "var require_rimraf = __commonJS({",
                "  \"node_modules/rimraf/rimraf.js\"(exports, module2) {",
                "    var assert = require(\"assert\");",
                "    var path2 = require(\"path\");",
                "    var fs2 = require(\"fs\");",
                "    var glob = void 0;",
                "    try {",
                "      glob = require_glob();",
                "    } catch (_err) {",
                "    }",
                "    var defaultGlobOpts = {",
                "      nosort: true,",
                "      silent: true",
                "    };",
                "    var timeout = 0;",
                "    var isWindows = process.platform === \"win32\";",
                "    var defaults = (options) => {",
                "      const methods = [",
                "        \"unlink\",",
                "        \"chmod\",",
                "        \"stat\",",
                "        \"lstat\",",
                "        \"rmdir\",",
                "        \"readdir\"",
                "      ];",
                "      methods.forEach((m) => {",
                "        options[m] = options[m] || fs2[m];",
                "        m = m + \"Sync\";",
                "        options[m] = options[m] || fs2[m];",
                "      });",
                "      options.maxBusyTries = options.maxBusyTries || 3;",
                "      options.emfileWait = options.emfileWait || 1e3;",
                "      if (options.glob === false) {",
                "        options.disableGlob = true;",
                "      }",
                "      if (options.disableGlob !== true && glob === void 0) {",
                "        throw Error(\"glob dependency not found, set `options.disableGlob = true` if intentional\");",
                "      }",
                "      options.disableGlob = options.disableGlob || false;",
                "      options.glob = options.glob || defaultGlobOpts;",
                "    };",
                "    var rimraf = (p, options, cb) => {",
                "      if (typeof options === \"function\") {",
                "        cb = options;",
                "        options = {};",
                "      }",
                "      assert(p, \"rimraf: missing path\");",
                "      assert.equal(typeof p, \"string\", \"rimraf: path should be a string\");",
                "      assert.equal(typeof cb, \"function\", \"rimraf: callback function required\");",
                "      assert(options, \"rimraf: invalid options argument provided\");",
                "      assert.equal(typeof options, \"object\", \"rimraf: options should be object\");",
                "      defaults(options);",
                "      let busyTries = 0;",
                "      let errState = null;",
                "      let n = 0;",
                "      const next = (er) => {",
                "        errState = errState || er;",
                "        if (--n === 0)",
                "          cb(errState);",
                "      };",
                "      const afterGlob = (er, results) => {",
                "        if (er)",
                "          return cb(er);",
                "        n = results.length;",
                "        if (n === 0)",
                "          return cb();",
                "        results.forEach((p2) => {",
                "          const CB = (er2) => {",
                "            if (er2) {",
                "              if ((er2.code === \"EBUSY\" || er2.code === \"ENOTEMPTY\" || er2.code === \"EPERM\") && busyTries < options.maxBusyTries) {",
                "                busyTries++;",
                "                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);",
                "              }",
                "              if (er2.code === \"EMFILE\" && timeout < options.emfileWait) {",
                "                return setTimeout(() => rimraf_(p2, options, CB), timeout++);",
                "              }",
                "              if (er2.code === \"ENOENT\")",
                "                er2 = null;",
                "            }",
                "            timeout = 0;",
                "            next(er2);",
                "          };",
                "          rimraf_(p2, options, CB);",
                "        });",
                "      };",
                "      if (options.disableGlob || !glob.hasMagic(p))",
                "        return afterGlob(null, [p]);",
                "      options.lstat(p, (er, stat) => {",
                "        if (!er)",
                "          return afterGlob(null, [p]);",
                "        glob(p, options.glob, afterGlob);",
                "      });",
                "    };",
                "    var rimraf_ = (p, options, cb) => {",
                "      assert(p);",
                "      assert(options);",
                "      assert(typeof cb === \"function\");",
                "      options.lstat(p, (er, st) => {",
                "        if (er && er.code === \"ENOENT\")",
                "          return cb(null);",
                "        if (er && er.code === \"EPERM\" && isWindows)",
                "          fixWinEPERM(p, options, er, cb);",
                "        if (st && st.isDirectory())",
                "          return rmdir(p, options, er, cb);",
                "        options.unlink(p, (er2) => {",
                "          if (er2) {",
                "            if (er2.code === \"ENOENT\")",
                "              return cb(null);",
                "            if (er2.code === \"EPERM\")",
                "              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);",
                "            if (er2.code === \"EISDIR\")",
                "              return rmdir(p, options, er2, cb);",
                "          }",
                "          return cb(er2);",
                "        });",
                "      });",
                "    };",
                "    var fixWinEPERM = (p, options, er, cb) => {",
                "      assert(p);",
                "      assert(options);",
                "      assert(typeof cb === \"function\");",
                "      options.chmod(p, 438, (er2) => {",
                "        if (er2)",
                "          cb(er2.code === \"ENOENT\" ? null : er);",
                "        else",
                "          options.stat(p, (er3, stats) => {",
                "            if (er3)",
                "              cb(er3.code === \"ENOENT\" ? null : er);",
                "            else if (stats.isDirectory())",
                "              rmdir(p, options, er, cb);",
                "            else",
                "              options.unlink(p, cb);",
                "          });",
                "      });",
                "    };",
                "    var fixWinEPERMSync = (p, options, er) => {",
                "      assert(p);",
                "      assert(options);",
                "      try {",
                "        options.chmodSync(p, 438);",
                "      } catch (er2) {",
                "        if (er2.code === \"ENOENT\")",
                "          return;",
                "        else",
                "          throw er;",
                "      }",
                "      let stats;",
                "      try {",
                "        stats = options.statSync(p);",
                "      } catch (er3) {",
                "        if (er3.code === \"ENOENT\")",
                "          return;",
                "        else",
                "          throw er;",
                "      }",
                "      if (stats.isDirectory())",
                "        rmdirSync(p, options, er);",
                "      else",
                "        options.unlinkSync(p);",
                "    };",
                "    var rmdir = (p, options, originalEr, cb) => {",
                "      assert(p);",
                "      assert(options);",
                "      assert(typeof cb === \"function\");",
                "      options.rmdir(p, (er) => {",
                "        if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))",
                "          rmkids(p, options, cb);",
                "        else if (er && er.code === \"ENOTDIR\")",
                "          cb(originalEr);",
                "        else",
                "          cb(er);",
                "      });",
                "    };",
                "    var rmkids = (p, options, cb) => {",
                "      assert(p);",
                "      assert(options);",
                "      assert(typeof cb === \"function\");",
                "      options.readdir(p, (er, files) => {",
                "        if (er)",
                "          return cb(er);",
                "        let n = files.length;",
                "        if (n === 0)",
                "          return options.rmdir(p, cb);",
                "        let errState;",
                "        files.forEach((f) => {",
                "          rimraf(path2.join(p, f), options, (er2) => {",
                "            if (errState)",
                "              return;",
                "            if (er2)",
                "              return cb(errState = er2);",
                "            if (--n === 0)",
                "              options.rmdir(p, cb);",
                "          });",
                "        });",
                "      });",
                "    };",
                "    var rimrafSync = (p, options) => {",
                "      options = options || {};",
                "      defaults(options);",
                "      assert(p, \"rimraf: missing path\");",
                "      assert.equal(typeof p, \"string\", \"rimraf: path should be a string\");",
                "      assert(options, \"rimraf: missing options\");",
                "      assert.equal(typeof options, \"object\", \"rimraf: options should be object\");",
                "      let results;",
                "      if (options.disableGlob || !glob.hasMagic(p)) {",
                "        results = [p];",
                "      } else {",
                "        try {",
                "          options.lstatSync(p);",
                "          results = [p];",
                "        } catch (er) {",
                "          results = glob.sync(p, options.glob);",
                "        }",
                "      }",
                "      if (!results.length)",
                "        return;",
                "      for (let i = 0; i < results.length; i++) {",
                "        const p2 = results[i];",
                "        let st;",
                "        try {",
                "          st = options.lstatSync(p2);",
                "        } catch (er) {",
                "          if (er.code === \"ENOENT\")",
                "            return;",
                "          if (er.code === \"EPERM\" && isWindows)",
                "            fixWinEPERMSync(p2, options, er);",
                "        }",
                "        try {",
                "          if (st && st.isDirectory())",
                "            rmdirSync(p2, options, null);",
                "          else",
                "            options.unlinkSync(p2);",
                "        } catch (er) {",
                "          if (er.code === \"ENOENT\")",
                "            return;",
                "          if (er.code === \"EPERM\")",
                "            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);",
                "          if (er.code !== \"EISDIR\")",
                "            throw er;",
                "          rmdirSync(p2, options, er);",
                "        }",
                "      }",
                "    };",
                "    var rmdirSync = (p, options, originalEr) => {",
                "      assert(p);",
                "      assert(options);",
                "      try {",
                "        options.rmdirSync(p);",
                "      } catch (er) {",
                "        if (er.code === \"ENOENT\")",
                "          return;",
                "        if (er.code === \"ENOTDIR\")",
                "          throw originalEr;",
                "        if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")",
                "          rmkidsSync(p, options);",
                "      }",
                "    };",
                "    var rmkidsSync = (p, options) => {",
                "      assert(p);",
                "      assert(options);",
                "      options.readdirSync(p).forEach((f) => rimrafSync(path2.join(p, f), options));",
                "      const retries = isWindows ? 100 : 1;",
                "      let i = 0;",
                "      do {",
                "        let threw = true;",
                "        try {",
                "          const ret = options.rmdirSync(p, options);",
                "          threw = false;",
                "          return ret;",
                "        } finally {",
                "          if (++i < retries && threw)",
                "            continue;",
                "        }",
                "      } while (true);",
                "    };",
                "    module2.exports = rimraf;",
                "    rimraf.sync = rimrafSync;",
                "  }",
                "});",
                "",
                "// node_modules/indent-string/index.js",
                "var require_indent_string = __commonJS({",
                "  \"node_modules/indent-string/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    module2.exports = (string, count = 1, options) => {",
                "      options = {",
                "        indent: \" \",",
                "        includeEmptyLines: false,",
                "        ...options",
                "      };",
                "      if (typeof string !== \"string\") {",
                "        throw new TypeError(",
                "          `Expected \\`input\\` to be a \\`string\\`, got \\`${typeof string}\\``",
                "        );",
                "      }",
                "      if (typeof count !== \"number\") {",
                "        throw new TypeError(",
                "          `Expected \\`count\\` to be a \\`number\\`, got \\`${typeof count}\\``",
                "        );",
                "      }",
                "      if (typeof options.indent !== \"string\") {",
                "        throw new TypeError(",
                "          `Expected \\`options.indent\\` to be a \\`string\\`, got \\`${typeof options.indent}\\``",
                "        );",
                "      }",
                "      if (count === 0) {",
                "        return string;",
                "      }",
                "      const regex = options.includeEmptyLines ? /^/gm : /^(?!\\s*$)/gm;",
                "      return string.replace(regex, options.indent.repeat(count));",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/clean-stack/index.js",
                "var require_clean_stack = __commonJS({",
                "  \"node_modules/clean-stack/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var os = require(\"os\");",
                "    var extractPathRegex = /\\s+at.*(?:\\(|\\s)(.*)\\)?/;",
                "    var pathRegex = /^(?:(?:(?:node|(?:internal\\/[\\w/]*|.*node_modules\\/(?:babel-polyfill|pirates)\\/.*)?\\w+)\\.js:\\d+:\\d+)|native)/;",
                "    var homeDir = typeof os.homedir === \"undefined\" ? \"\" : os.homedir();",
                "    module2.exports = (stack, options) => {",
                "      options = Object.assign({ pretty: false }, options);",
                "      return stack.replace(/\\\\/g, \"/\").split(\"\\n\").filter((line) => {",
                "        const pathMatches = line.match(extractPathRegex);",
                "        if (pathMatches === null || !pathMatches[1]) {",
                "          return true;",
                "        }",
                "        const match = pathMatches[1];",
                "        if (match.includes(\".app/Contents/Resources/electron.asar\") || match.includes(\".app/Contents/Resources/default_app.asar\")) {",
                "          return false;",
                "        }",
                "        return !pathRegex.test(match);",
                "      }).filter((line) => line.trim() !== \"\").map((line) => {",
                "        if (options.pretty) {",
                "          return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, \"~\")));",
                "        }",
                "        return line;",
                "      }).join(\"\\n\");",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/aggregate-error/index.js",
                "var require_aggregate_error = __commonJS({",
                "  \"node_modules/aggregate-error/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var indentString = require_indent_string();",
                "    var cleanStack = require_clean_stack();",
                "    var cleanInternalStack = (stack) => stack.replace(/\\s+at .*aggregate-error\\/index.js:\\d+:\\d+\\)?/g, \"\");",
                "    var AggregateError = class extends Error {",
                "      constructor(errors) {",
                "        if (!Array.isArray(errors)) {",
                "          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);",
                "        }",
                "        errors = [...errors].map((error) => {",
                "          if (error instanceof Error) {",
                "            return error;",
                "          }",
                "          if (error !== null && typeof error === \"object\") {",
                "            return Object.assign(new Error(error.message), error);",
                "          }",
                "          return new Error(error);",
                "        });",
                "        let message = errors.map((error) => {",
                "          return typeof error.stack === \"string\" ? cleanInternalStack(cleanStack(error.stack)) : String(error);",
                "        }).join(\"\\n\");",
                "        message = \"\\n\" + indentString(message, 4);",
                "        super(message);",
                "        this.name = \"AggregateError\";",
                "        Object.defineProperty(this, \"_errors\", { value: errors });",
                "      }",
                "      *[Symbol.iterator]() {",
                "        for (const error of this._errors) {",
                "          yield error;",
                "        }",
                "      }",
                "    };",
                "    module2.exports = AggregateError;",
                "  }",
                "});",
                "",
                "// node_modules/p-map/index.js",
                "var require_p_map = __commonJS({",
                "  \"node_modules/p-map/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var AggregateError = require_aggregate_error();",
                "    module2.exports = async (iterable, mapper, {",
                "      concurrency = Infinity,",
                "      stopOnError = true",
                "    } = {}) => {",
                "      return new Promise((resolve, reject) => {",
                "        if (typeof mapper !== \"function\") {",
                "          throw new TypeError(\"Mapper function is required\");",
                "        }",
                "        if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {",
                "          throw new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);",
                "        }",
                "        const result = [];",
                "        const errors = [];",
                "        const iterator = iterable[Symbol.iterator]();",
                "        let isRejected = false;",
                "        let isIterableDone = false;",
                "        let resolvingCount = 0;",
                "        let currentIndex = 0;",
                "        const next = () => {",
                "          if (isRejected) {",
                "            return;",
                "          }",
                "          const nextItem = iterator.next();",
                "          const index = currentIndex;",
                "          currentIndex++;",
                "          if (nextItem.done) {",
                "            isIterableDone = true;",
                "            if (resolvingCount === 0) {",
                "              if (!stopOnError && errors.length !== 0) {",
                "                reject(new AggregateError(errors));",
                "              } else {",
                "                resolve(result);",
                "              }",
                "            }",
                "            return;",
                "          }",
                "          resolvingCount++;",
                "          (async () => {",
                "            try {",
                "              const element = await nextItem.value;",
                "              result[index] = await mapper(element, index);",
                "              resolvingCount--;",
                "              next();",
                "            } catch (error) {",
                "              if (stopOnError) {",
                "                isRejected = true;",
                "                reject(error);",
                "              } else {",
                "                errors.push(error);",
                "                resolvingCount--;",
                "                next();",
                "              }",
                "            }",
                "          })();",
                "        };",
                "        for (let i = 0; i < concurrency; i++) {",
                "          next();",
                "          if (isIterableDone) {",
                "            break;",
                "          }",
                "        }",
                "      });",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/del/index.js",
                "var require_del = __commonJS({",
                "  \"node_modules/del/index.js\"(exports, module2) {",
                "    \"use strict\";",
                "    var { promisify: promisify3 } = require(\"util\");",
                "    var path2 = require(\"path\");",
                "    var globby = require_globby();",
                "    var isGlob = require_is_glob();",
                "    var slash = require_slash();",
                "    var gracefulFs = require_graceful_fs();",
                "    var isPathCwd = require_is_path_cwd();",
                "    var isPathInside = require_is_path_inside();",
                "    var rimraf = require_rimraf();",
                "    var pMap = require_p_map();",
                "    var rimrafP = promisify3(rimraf);",
                "    var rimrafOptions = {",
                "      glob: false,",
                "      unlink: gracefulFs.unlink,",
                "      unlinkSync: gracefulFs.unlinkSync,",
                "      chmod: gracefulFs.chmod,",
                "      chmodSync: gracefulFs.chmodSync,",
                "      stat: gracefulFs.stat,",
                "      statSync: gracefulFs.statSync,",
                "      lstat: gracefulFs.lstat,",
                "      lstatSync: gracefulFs.lstatSync,",
                "      rmdir: gracefulFs.rmdir,",
                "      rmdirSync: gracefulFs.rmdirSync,",
                "      readdir: gracefulFs.readdir,",
                "      readdirSync: gracefulFs.readdirSync",
                "    };",
                "    function safeCheck(file, cwd) {",
                "      if (isPathCwd(file)) {",
                "        throw new Error(\"Cannot delete the current working directory. Can be overridden with the `force` option.\");",
                "      }",
                "      if (!isPathInside(file, cwd)) {",
                "        throw new Error(\"Cannot delete files/directories outside the current working directory. Can be overridden with the `force` option.\");",
                "      }",
                "    }",
                "    function normalizePatterns(patterns) {",
                "      patterns = Array.isArray(patterns) ? patterns : [patterns];",
                "      patterns = patterns.map((pattern) => {",
                "        if (process.platform === \"win32\" && isGlob(pattern) === false) {",
                "          return slash(pattern);",
                "        }",
                "        return pattern;",
                "      });",
                "      return patterns;",
                "    }",
                "    module2.exports = async (patterns, { force, dryRun, cwd = process.cwd(), onProgress = () => {",
                "    }, ...options } = {}) => {",
                "      options = {",
                "        expandDirectories: false,",
                "        onlyFiles: false,",
                "        followSymbolicLinks: false,",
                "        cwd,",
                "        ...options",
                "      };",
                "      patterns = normalizePatterns(patterns);",
                "      const files = (await globby(patterns, options)).sort((a, b) => b.localeCompare(a));",
                "      if (files.length === 0) {",
                "        onProgress({",
                "          totalCount: 0,",
                "          deletedCount: 0,",
                "          percent: 1",
                "        });",
                "      }",
                "      let deletedCount = 0;",
                "      const mapper = async (file) => {",
                "        file = path2.resolve(cwd, file);",
                "        if (!force) {",
                "          safeCheck(file, cwd);",
                "        }",
                "        if (!dryRun) {",
                "          await rimrafP(file, rimrafOptions);",
                "        }",
                "        deletedCount += 1;",
                "        onProgress({",
                "          totalCount: files.length,",
                "          deletedCount,",
                "          percent: deletedCount / files.length",
                "        });",
                "        return file;",
                "      };",
                "      const removedFiles = await pMap(files, mapper, options);",
                "      removedFiles.sort((a, b) => a.localeCompare(b));",
                "      return removedFiles;",
                "    };",
                "    module2.exports.sync = (patterns, { force, dryRun, cwd = process.cwd(), ...options } = {}) => {",
                "      options = {",
                "        expandDirectories: false,",
                "        onlyFiles: false,",
                "        followSymbolicLinks: false,",
                "        cwd,",
                "        ...options",
                "      };",
                "      patterns = normalizePatterns(patterns);",
                "      const files = globby.sync(patterns, options).sort((a, b) => b.localeCompare(a));",
                "      const removedFiles = files.map((file) => {",
                "        file = path2.resolve(cwd, file);",
                "        if (!force) {",
                "          safeCheck(file, cwd);",
                "        }",
                "        if (!dryRun) {",
                "          rimraf.sync(file, rimrafOptions);",
                "        }",
                "        return file;",
                "      });",
                "      removedFiles.sort((a, b) => a.localeCompare(b));",
                "      return removedFiles;",
                "    };",
                "  }",
                "});",
                "",
                "// node_modules/tempy/index.js",
                "var tempy_exports = {};",
                "__export(tempy_exports, {",
                "  default: () => tempy_default",
                "});",
                "module.exports = __toCommonJS(tempy_exports);",
                "var import_node_fs = __toESM(require(\"fs\"), 1);",
                "var import_node_path = __toESM(require(\"path\"), 1);",
                "var import_node_stream = __toESM(require(\"stream\"), 1);",
                "var import_node_util = require(\"util\");",
                "",
                "// node_modules/crypto-random-string/index.js",
                "var import_util = require(\"util\");",
                "var import_crypto = __toESM(require(\"crypto\"), 1);",
                "var randomBytesAsync = (0, import_util.promisify)(import_crypto.default.randomBytes);",
                "var urlSafeCharacters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~\".split(\"\");",
                "var numericCharacters = \"0123456789\".split(\"\");",
                "var distinguishableCharacters = \"CDEHKMPRTUWXY012458\".split(\"\");",
                "var asciiPrintableCharacters = \"!\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\".split(\"\");",
                "var alphanumericCharacters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\".split(\"\");",
                "var generateForCustomCharacters = (length, characters) => {",
                "  const characterCount = characters.length;",
                "  const maxValidSelector = Math.floor(65536 / characterCount) * characterCount - 1;",
                "  const entropyLength = 2 * Math.ceil(1.1 * length);",
                "  let string = \"\";",
                "  let stringLength = 0;",
                "  while (stringLength < length) {",
                "    const entropy = import_crypto.default.randomBytes(entropyLength);",
                "    let entropyPosition = 0;",
                "    while (entropyPosition < entropyLength && stringLength < length) {",
                "      const entropyValue = entropy.readUInt16LE(entropyPosition);",
                "      entropyPosition += 2;",
                "      if (entropyValue > maxValidSelector) {",
                "        continue;",
                "      }",
                "      string += characters[entropyValue % characterCount];",
                "      stringLength++;",
                "    }",
                "  }",
                "  return string;",
                "};",
                "var generateForCustomCharactersAsync = async (length, characters) => {",
                "  const characterCount = characters.length;",
                "  const maxValidSelector = Math.floor(65536 / characterCount) * characterCount - 1;",
                "  const entropyLength = 2 * Math.ceil(1.1 * length);",
                "  let string = \"\";",
                "  let stringLength = 0;",
                "  while (stringLength < length) {",
                "    const entropy = await randomBytesAsync(entropyLength);",
                "    let entropyPosition = 0;",
                "    while (entropyPosition < entropyLength && stringLength < length) {",
                "      const entropyValue = entropy.readUInt16LE(entropyPosition);",
                "      entropyPosition += 2;",
                "      if (entropyValue > maxValidSelector) {",
                "        continue;",
                "      }",
                "      string += characters[entropyValue % characterCount];",
                "      stringLength++;",
                "    }",
                "  }",
                "  return string;",
                "};",
                "var generateRandomBytes = (byteLength, type, length) => import_crypto.default.randomBytes(byteLength).toString(type).slice(0, length);",
                "var generateRandomBytesAsync = async (byteLength, type, length) => {",
                "  const buffer = await randomBytesAsync(byteLength);",
                "  return buffer.toString(type).slice(0, length);",
                "};",
                "var allowedTypes = /* @__PURE__ */ new Set([",
                "  void 0,",
                "  \"hex\",",
                "  \"base64\",",
                "  \"url-safe\",",
                "  \"numeric\",",
                "  \"distinguishable\",",
                "  \"ascii-printable\",",
                "  \"alphanumeric\"",
                "]);",
                "var createGenerator = (generateForCustomCharacters2, generateRandomBytes2) => ({ length, type, characters }) => {",
                "  if (!(length >= 0 && Number.isFinite(length))) {",
                "    throw new TypeError(\"Expected a `length` to be a non-negative finite number\");",
                "  }",
                "  if (type !== void 0 && characters !== void 0) {",
                "    throw new TypeError(\"Expected either `type` or `characters`\");",
                "  }",
                "  if (characters !== void 0 && typeof characters !== \"string\") {",
                "    throw new TypeError(\"Expected `characters` to be string\");",
                "  }",
                "  if (!allowedTypes.has(type)) {",
                "    throw new TypeError(`Unknown type: ${type}`);",
                "  }",
                "  if (type === void 0 && characters === void 0) {",
                "    type = \"hex\";",
                "  }",
                "  if (type === \"hex\" || type === void 0 && characters === void 0) {",
                "    return generateRandomBytes2(Math.ceil(length * 0.5), \"hex\", length);",
                "  }",
                "  if (type === \"base64\") {",
                "    return generateRandomBytes2(Math.ceil(length * 0.75), \"base64\", length);",
                "  }",
                "  if (type === \"url-safe\") {",
                "    return generateForCustomCharacters2(length, urlSafeCharacters);",
                "  }",
                "  if (type === \"numeric\") {",
                "    return generateForCustomCharacters2(length, numericCharacters);",
                "  }",
                "  if (type === \"distinguishable\") {",
                "    return generateForCustomCharacters2(length, distinguishableCharacters);",
                "  }",
                "  if (type === \"ascii-printable\") {",
                "    return generateForCustomCharacters2(length, asciiPrintableCharacters);",
                "  }",
                "  if (type === \"alphanumeric\") {",
                "    return generateForCustomCharacters2(length, alphanumericCharacters);",
                "  }",
                "  if (characters.length === 0) {",
                "    throw new TypeError(\"Expected `characters` string length to be greater than or equal to 1\");",
                "  }",
                "  if (characters.length > 65536) {",
                "    throw new TypeError(\"Expected `characters` string length to be less or equal to 65536\");",
                "  }",
                "  return generateForCustomCharacters2(length, characters.split(\"\"));",
                "};",
                "var cryptoRandomString = createGenerator(generateForCustomCharacters, generateRandomBytes);",
                "cryptoRandomString.async = createGenerator(generateForCustomCharactersAsync, generateRandomBytesAsync);",
                "var crypto_random_string_default = cryptoRandomString;",
                "",
                "// node_modules/unique-string/index.js",
                "function uniqueString() {",
                "  return crypto_random_string_default({ length: 32 });",
                "}",
                "",
                "// node_modules/tempy/index.js",
                "var import_temp_dir = __toESM(require_temp_dir(), 1);",
                "",
                "// node_modules/is-stream/index.js",
                "function isStream(stream2) {",
                "  return stream2 !== null && typeof stream2 === \"object\" && typeof stream2.pipe === \"function\";",
                "}",
                "",
                "// node_modules/tempy/index.js",
                "var import_del = __toESM(require_del(), 1);",
                "var pipeline = (0, import_node_util.promisify)(import_node_stream.default.pipeline);",
                "var getPath = (prefix = \"\") => import_node_path.default.join(import_temp_dir.default, prefix + uniqueString());",
                "var writeStream = async (filePath, data) => pipeline(data, import_node_fs.default.createWriteStream(filePath));",
                "var createTask = (tempyFunction, { extraArguments = 0 } = {}) => async (...arguments_) => {",
                "  const [callback, options] = arguments_.slice(extraArguments);",
                "  const result = await tempyFunction(...arguments_.slice(0, extraArguments), options);",
                "  try {",
                "    return await callback(result);",
                "  } finally {",
                "    await (0, import_del.default)(result, { force: true });",
                "  }",
                "};",
                "var tempy = {};",
                "tempy.file = (options) => {",
                "  options = {",
                "    ...options",
                "  };",
                "  if (options.name) {",
                "    if (options.extension !== void 0 && options.extension !== null) {",
                "      throw new Error(\"The `name` and `extension` options are mutually exclusive\");",
                "    }",
                "    return import_node_path.default.join(tempy.directory(), options.name);",
                "  }",
                "  return getPath() + (options.extension === void 0 || options.extension === null ? \"\" : \".\" + options.extension.replace(/^\\./, \"\"));",
                "};",
                "tempy.file.task = createTask(tempy.file);",
                "tempy.directory = ({ prefix = \"\" } = {}) => {",
                "  const directory = getPath(prefix);",
                "  import_node_fs.default.mkdirSync(directory);",
                "  return directory;",
                "};",
                "tempy.directory.task = createTask(tempy.directory);",
                "tempy.write = async (data, options) => {",
                "  const filename = tempy.file(options);",
                "  const write = isStream(data) ? writeStream : import_node_fs.promises.writeFile;",
                "  await write(filename, data);",
                "  return filename;",
                "};",
                "tempy.write.task = createTask(tempy.write, { extraArguments: 1 });",
                "tempy.writeSync = (data, options) => {",
                "  const filename = tempy.file(options);",
                "  import_node_fs.default.writeFileSync(filename, data);",
                "  return filename;",
                "};",
                "Object.defineProperty(tempy, \"root\", {",
                "  get() {",
                "    return import_temp_dir.default;",
                "  }",
                "});",
                "var tempy_default = tempy;",
                "// Annotate the CommonJS export names for ESM import in node:",
                "0 && (module.exports = {});",
                "/*! Bundled license information:",
                "",
                "is-extglob/index.js:",
                "  (*!",
                "   * is-extglob <https://github.com/jonschlinkert/is-extglob>",
                "   *",
                "   * Copyright (c) 2014-2016, Jon Schlinkert.",
                "   * Licensed under the MIT License.",
                "   *)",
                "",
                "is-glob/index.js:",
                "  (*!",
                "   * is-glob <https://github.com/jonschlinkert/is-glob>",
                "   *",
                "   * Copyright (c) 2014-2017, Jon Schlinkert.",
                "   * Released under the MIT License.",
                "   *)",
                "",
                "is-number/index.js:",
                "  (*!",
                "   * is-number <https://github.com/jonschlinkert/is-number>",
                "   *",
                "   * Copyright (c) 2014-present, Jon Schlinkert.",
                "   * Released under the MIT License.",
                "   *)",
                "",
                "to-regex-range/index.js:",
                "  (*!",
                "   * to-regex-range <https://github.com/micromatch/to-regex-range>",
                "   *",
                "   * Copyright (c) 2015-present, Jon Schlinkert.",
                "   * Released under the MIT License.",
                "   *)",
                "",
                "fill-range/index.js:",
                "  (*!",
                "   * fill-range <https://github.com/jonschlinkert/fill-range>",
                "   *",
                "   * Copyright (c) 2014-present, Jon Schlinkert.",
                "   * Licensed under the MIT License.",
                "   *)",
                "",
                "queue-microtask/index.js:",
                "  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)",
                "",
                "run-parallel/index.js:",
                "  (*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)",
                "*/"
            ]
        }
    },
    "website": {
        "README.md": {},
        "package.json": {},
        "sidebars.json": {},
        "siteConfig.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "// Docs: https://docusaurus.io/docs/en/site-config.html",
                "",
                "const path = require(\"path\");",
                "const fs = require(\"fs\");",
                "const { load: parseYaml } = require(\"js-yaml\");",
                "",
                "const PACKAGE = require(\"../package.json\");",
                "const GITHUB_URL = `https://github.com/${PACKAGE.repository}`;",
                "",
                "function loadYaml(fsPath) {",
                "  return parseYaml(fs.readFileSync(path.join(__dirname, fsPath), \"utf8\"));",
                "}",
                "",
                "const users = loadYaml(\"./data/users.yml\");",
                "const editors = loadYaml(\"./data/editors.yml\");",
                "const supportedLanguages = loadYaml(\"./data/languages.yml\");",
                "",
                "const siteConfig = {",
                "  title: \"Prettier\",",
                "  tagline: \"Opinionated Code Formatter\",",
                "  githubUrl: GITHUB_URL,",
                "  url: PACKAGE.homepage,",
                "  baseUrl: \"/\",",
                "  projectName: PACKAGE.name,",
                "  repo: PACKAGE.repository,",
                "  cname: \"prettier.io\",",
                "  users,",
                "  editors,",
                "  supportedLanguages,",
                "  tideliftUrl:",
                "    \"https://tidelift.com/subscription/pkg/npm-prettier?utm_source=npm-prettier&utm_medium=referral&utm_campaign=website\",",
                "  /* base url for editing docs, usage example: editUrl + 'en/doc1.md' */",
                "  editUrl: `${GITHUB_URL}/edit/main/docs/`,",
                "  headerLinks: [",
                "    { href: \"/playground/\", label: \"Playground\" },",
                "    { doc: \"index\", label: \"Docs\" },",
                "    { blog: true, label: \"Blog\" },",
                "    { search: true },",
                "    { href: \"https://opencollective.com/prettier\", label: \"Donate\" },",
                "    { href: GITHUB_URL, label: \"GitHub\" },",
                "  ],",
                "  /* path to images for header/footer */",
                "  headerIcon: \"icon.png\",",
                "  footerIcon: \"icon.png\",",
                "  favicon: \"icon.png\",",
                "  /* colors for website */",
                "  colors: {",
                "    primaryColor: \"#1A2B34\",",
                "    secondaryColor: \"#808080\",",
                "  },",
                "  highlight: {",
                "    theme: \"default\",",
                "    version: require(\"highlight.js/package.json\").version,",
                "  },",
                "  usePrism: [\"javascript\", \"jsx\", \"typescript\", \"ts\", \"js\", \"html\", \"css\"],",
                "  useEnglishUrl: true,",
                "  scripts: [",
                "    \"https://buttons.github.io/buttons.js\",",
                "    \"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js\",",
                "    \"/js/code-block-buttons.js\",",
                "  ],",
                "  stylesheets: [",
                "    \"//unpkg.com/@sandhose/prettier-animated-logo@1.0.3/dist/wide.css\",",
                "  ],",
                "  algolia: {",
                "    apiKey: process.env.ALGOLIA_PRETTIER_API_KEY,",
                "    indexName: \"prettier\",",
                "  },",
                "  markdownPlugins: [",
                "    // ignore `<!-- prettier-ignore -->` before passing into Docusaurus to avoid mis-parsing (#3322)",
                "    (md) => {",
                "      md.block.ruler.before(",
                "        \"htmlblock\",",
                "        \"prettierignore\",",
                "        (state, startLine) => {",
                "          const pos = state.bMarks[startLine];",
                "          const max = state.eMarks[startLine];",
                "          if (/<!-- prettier-ignore -->/.test(state.src.slice(pos, max))) {",
                "            state.line += 1;",
                "            return true;",
                "          }",
                "          return false;",
                "        }",
                "      );",
                "    },",
                "  ],",
                "  separateCss: [\"static/separate-css\"],",
                "  gaTrackingId: \"UA-111350464-1\",",
                "  twitter: true,",
                "  twitterUsername: \"PrettierCode\",",
                "  twitterImage: \"icon.png\",",
                "  ogImage: \"icon.png\",",
                "  onPageNav: \"separate\",",
                "};",
                "",
                "module.exports = siteConfig;"
            ]
        },
        "versions.json": {},
        "webpack.config.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "module.exports = {",
                "  entry: {",
                "    playground: \"./playground/index.js\",",
                "  },",
                "  output: {",
                "    filename: \"[name].js\",",
                "    path: __dirname + \"/static/\",",
                "  },",
                "  module: {",
                "    rules: [",
                "      {",
                "        test: /\\.js$/,",
                "        exclude: /node_modules/,",
                "        loader: \"babel-loader\",",
                "        options: {",
                "          presets: [\"@babel/env\", \"@babel/react\"],",
                "        },",
                "      },",
                "    ],",
                "  },",
                "  externals: {",
                "    clipboard: \"ClipboardJS\",",
                "    codemirror: \"CodeMirror\",",
                "    react: \"React\",",
                "    \"react-dom\": \"ReactDOM\",",
                "  },",
                "};"
            ]
        },
        "yarn.lock": {},
        "blog": {
            "2017-04-13-1.0.0.md": {},
            "2017-04-20-1.2.0.md": {},
            "2017-05-03-1.3.0.md": {},
            "2017-06-03-1.4.0.md": {},
            "2017-06-28-1.5.0.md": {},
            "2017-08-29-1.6.0.md": {},
            "2017-09-15-1.7.0.md": {},
            "2017-11-07-1.8.0.md": {},
            "2017-12-05-1.9.0.md": {},
            "2018-01-10-1.10.0.md": {},
            "2018-02-26-1.11.0.md": {},
            "2018-04-09-plugin-php-0.1.md": {},
            "2018-04-11-1.12.0.md": {},
            "2018-05-27-1.13.0.md": {},
            "2018-07-29-1.14.0.md": {},
            "2018-11-07-1.15.0.md": {},
            "2019-01-20-1.16.0.md": {},
            "2019-04-12-1.17.0.md": {},
            "2019-06-06-1.18.0.md": {},
            "2019-11-09-1.19.0.md": {},
            "2020-03-21-2.0.0.md": {},
            "2020-08-24-2.1.0.md": {},
            "2020-11-20-2.2.0.md": {},
            "2020-12-11-plugin-ruby-1.0.md": {},
            "2021-05-09-2.3.0.md": {},
            "2021-09-09-2.4.0.md": {},
            "2021-11-25-2.5.0.md": {},
            "2022-01-06-prettier-begins-paying-maintainers.md": {},
            "2022-03-16-2.6.0.md": {},
            "2022-06-14-2.7.0.md": {},
            "2022-11-23-2.8.0.md": {}
        },
        "core": {
            "Footer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const React = require(\"react\");",
                    "const PropTypes = require(\"prop-types\");",
                    "",
                    "const GithubButton = (props) => (",
                    "  <a",
                    "    className=\"github-button\"",
                    "    href={props.config.githubUrl}",
                    "    data-icon=\"octicon-star\"",
                    "    data-show-count=\"true\"",
                    "    aria-label=\"Star this project on GitHub\"",
                    "  >",
                    "    Star",
                    "  </a>",
                    ");",
                    "",
                    "GithubButton.propTypes = {",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "class Footer extends React.Component {",
                    "  url(path) {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}docs/${language}${path}`;",
                    "  }",
                    "",
                    "  usersUrl() {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}${language}/users`;",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <footer className=\"footerSection nav-footer\" id=\"footer\">",
                    "        <section className=\"sitemap\">",
                    "          <a href={this.props.config.baseUrl} className=\"nav-home\">",
                    "            <img",
                    "              src={this.props.config.baseUrl + this.props.config.footerIcon}",
                    "              alt={this.props.config.title}",
                    "            />",
                    "          </a>",
                    "          <div>",
                    "            <h5>Docs</h5>",
                    "            <a href={this.url(\"/index.html\")}>About</a>",
                    "            <a href={this.url(\"/install.html\")}>Usage</a>",
                    "            <br />",
                    "            <a href=\"https://www.netlify.com\">",
                    "              <img src=\"https://www.netlify.com/img/global/badges/netlify-color-accent.svg\" />",
                    "            </a>",
                    "          </div>",
                    "          <div>",
                    "            <h5>Community</h5>",
                    "            <a href={this.usersUrl()}>User Showcase</a>",
                    "            <a",
                    "              href=\"http://stackoverflow.com/questions/tagged/prettier\"",
                    "              target=\"_blank\"",
                    "              rel=\"noopener noreferrer\"",
                    "            >",
                    "              Stack Overflow",
                    "            </a>",
                    "            <a href=\"https://twitter.com/PrettierCode\">",
                    "              @PrettierCode on Twitter",
                    "            </a>",
                    "            <object",
                    "              type=\"image/svg+xml\"",
                    "              data=\"https://img.shields.io/twitter/follow/prettiercode.svg?label=Follow+Prettier&style=social\"",
                    "            >",
                    "              <a href=\"https://twitter.com/intent/follow?screen_name=prettiercode\">",
                    "                <img",
                    "                  alt=\"Follow Prettier on Twitter\"",
                    "                  src=\"https://img.shields.io/twitter/follow/prettiercode.png?label=Follow+Prettier&style=social\"",
                    "                />",
                    "              </a>",
                    "            </object>",
                    "          </div>",
                    "          <div>",
                    "            <h5>More</h5>",
                    "            <a href={this.props.config.baseUrl + \"blog\"}>Blog</a>",
                    "            <a href={this.props.config.githubUrl}>GitHub</a>",
                    "            <a href={this.props.config.githubUrl + \"/issues\"}>Issues</a>",
                    "            <GithubButton config={this.props.config} />",
                    "          </div>",
                    "        </section>",
                    "      </footer>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "Footer.propTypes = {",
                    "  language: PropTypes.string,",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "module.exports = Footer;"
                ]
            }
        },
        "data": {
            "editors.yml": {},
            "languages.yml": {},
            "users.yml": {}
        },
        "pages": {
            "googlefe164a33bda4034b.html": {},
            "playground-redirect.html": {},
            "en": {
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const React = require(\"react\");",
                        "const PropTypes = require(\"prop-types\");",
                        "const AnimatedLogo = require(\"@sandhose/prettier-animated-logo\");",
                        "const { MarkdownBlock, Container } = require(\"../../core/CompLibrary.js\");",
                        "",
                        "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                        "",
                        "const ButtonGroup = (props) => (",
                        "  <div className=\"buttonGroup buttonWrapper\">{props.children}</div>",
                        ");",
                        "",
                        "ButtonGroup.propTypes = {",
                        "  children: PropTypes.node,",
                        "};",
                        "",
                        "class Button extends React.Component {",
                        "  render() {",
                        "    return (",
                        "      <div className=\"pluginWrapper buttonWrapper\">",
                        "        <a className=\"button\" href={this.props.href} target={this.props.target}>",
                        "          {this.props.children}",
                        "        </a>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Button.defaultProps = {",
                        "  target: \"_self\",",
                        "};",
                        "",
                        "Button.propTypes = {",
                        "  href: PropTypes.string,",
                        "  target: PropTypes.string,",
                        "  children: PropTypes.any,",
                        "};",
                        "",
                        "function Tidelift() {",
                        "  return (",
                        "    <a className=\"tidelift\" href={siteConfig.tideliftUrl}>",
                        "      PRETTIER FOR ENTERPRISE",
                        "    </a>",
                        "  );",
                        "}",
                        "",
                        "const HomeSplash = (props) => (",
                        "  <div className=\"homeContainer\">",
                        "    <Tidelift />",
                        "    <div className=\"homeSplashFade\">",
                        "      <div className=\"wrapper homeWrapper\">",
                        "        <div className=\"animatedLogoWrapper\">",
                        "          <AnimatedLogo version=\"wide\" />",
                        "        </div>",
                        "        <div className=\"inner\">",
                        "          <div className=\"section promoSection\">",
                        "            <div className=\"promoRow\">",
                        "              <div className=\"pluginRowBlock\">",
                        "                <Button href=\"/playground/\">Try It Online</Button>&nbsp;",
                        "                <Button href={\"/docs/\" + props.language + \"/install.html\"}>",
                        "                  Install Prettier",
                        "                </Button>",
                        "              </div>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </div>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "HomeSplash.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const TldrSection = ({ language }) => (",
                        "  <div className=\"tldrSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-evenly\",",
                        "        }}",
                        "      >",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>What is Prettier?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>An opinionated code formatter</li>",
                        "            <li>Supports many languages</li>",
                        "            <li>Integrates with most editors</li>",
                        "            <li>Has few options</li>",
                        "          </ul>",
                        "        </div>",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>Why?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>Your code is formatted on save</li>",
                        "            <li>No need to discuss style in code review</li>",
                        "            <li>Saves you time and energy</li>",
                        "            <li>",
                        "              <a",
                        "                style={{ color: \"inherit !important\", fontSize: \"inherit\" }}",
                        "                href={\"/docs/\" + language + \"/why-prettier.html\"}",
                        "              >",
                        "                And more &raquo;",
                        "              </a>",
                        "            </li>",
                        "          </ul>",
                        "        </div>",
                        "      </div>",
                        "    </Container>",
                        "  </div>",
                        ");",
                        "",
                        "TldrSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const Language = ({ name, nameLink, showName, image, variants }) => (",
                        "  <div",
                        "    className=\"languageCategory\"",
                        "    style={{",
                        "      display: \"flex\",",
                        "      alignItems: \"flex-start\",",
                        "      paddingBottom: \"1em\",",
                        "    }}",
                        "  >",
                        "    <img src={image} style={{ width: \"50px\", padding: \"0 20px\" }} />",
                        "    <ul>",
                        "      {showName && (",
                        "        <li className=\"accented\">",
                        "          {nameLink ? <a href={nameLink}>{name}</a> : name}",
                        "        </li>",
                        "      )}",
                        "      {variants.map((variant) => (",
                        "        <li key={variant}>",
                        "          <MarkdownBlock>{variant}</MarkdownBlock>",
                        "        </li>",
                        "      ))}",
                        "    </ul>",
                        "  </div>",
                        ");",
                        "",
                        "Language.propTypes = {",
                        "  name: PropTypes.string,",
                        "  nameLink: PropTypes.string,",
                        "  showName: PropTypes.bool,",
                        "  image: PropTypes.string,",
                        "  variants: PropTypes.array,",
                        "};",
                        "",
                        "const LanguagesSection = () => {",
                        "  const languageChunks = siteConfig.supportedLanguages.reduce(",
                        "    (acc, language) => {",
                        "      const last = acc[acc.length - 1];",
                        "      if (",
                        "        last &&",
                        "        last.length < 2 &&",
                        "        last.reduce((sum, lang) => sum + lang.variants.length, 0) +",
                        "          language.variants.length <",
                        "          9",
                        "      ) {",
                        "        last.push(language);",
                        "      } else {",
                        "        acc.push([language]);",
                        "      }",
                        "      return acc;",
                        "    },",
                        "    []",
                        "  );",
                        "",
                        "  return (",
                        "    <div",
                        "      className=\"languagesSection productShowcaseSection\"",
                        "      style={{ textAlign: \"center\" }}",
                        "    >",
                        "      <Container>",
                        "        <h2>Works with the Tools You Use</h2>",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {languageChunks.map((languageChunk, index) => (",
                        "            <div key={index} style={{ flex: \"1 1 auto\" }}>",
                        "              {languageChunk.map((language) => (",
                        "                <Language key={language.name} {...language} />",
                        "              ))}",
                        "            </div>",
                        "          ))}",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "const Editor = ({ content = \"\", image, name }) => (",
                        "  <div className=\"editor\">",
                        "    <img className=\"editorImage\" src={image} />",
                        "    <div className=\"editorInfo\">",
                        "      <h3 className=\"editorName\">{name}</h3>",
                        "      <MarkdownBlock>{content.replace(/\\n/g, \"  \\n\")}</MarkdownBlock>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "Editor.propTypes = {",
                        "  content: PropTypes.string,",
                        "  image: PropTypes.string.isRequired,",
                        "  name: PropTypes.string.isRequired,",
                        "};",
                        "",
                        "const EditorSupportSection = () => (",
                        "  <div className=\"editorSupportSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <h2>Editor Support</h2>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-around\",",
                        "        }}",
                        "      >",
                        "        {siteConfig.editors.map((editor) => (",
                        "          <Editor key={editor.name} {...editor} />",
                        "        ))}",
                        "      </div>",
                        "    </Container>",
                        "",
                        "    <div style={{ float: \"right\" }}>",
                        "      <span>Got more? </span>",
                        "      <a",
                        "        href={`${siteConfig.githubUrl}/edit/main/website/data/editors.yml`}",
                        "        className=\"button\"",
                        "      >",
                        "        Send a PR",
                        "      </a>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "const UsersSection = ({ language }) => {",
                        "  const showcase = siteConfig.users",
                        "    .filter((user) => user.pinned)",
                        "    .map((user, i) => (",
                        "      <a key={i} className=\"growOnHover alignCenter\" href={user.infoLink}>",
                        "        <img className=\"user\" src={user.greyImage} title={user.caption} />",
                        "      </a>",
                        "    ));",
                        "",
                        "  return (",
                        "    <div className=\"usersSection productShowcaseSection\">",
                        "      <Container>",
                        "        <h2>Used By People You Rely On</h2>",
                        "        <div style={{ textAlign: \"right\" }} />",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {showcase}",
                        "        </div>",
                        "        <div className=\"more-users\">",
                        "          <a",
                        "            className=\"button\"",
                        "            href={siteConfig.baseUrl + language + \"/users/\"}",
                        "            target=\"_self\"",
                        "            style={{ marginRight: \"10px\" }}",
                        "          >",
                        "            See Others",
                        "          </a>",
                        "        </div>",
                        "",
                        "        <h2 className=\"ecosystemSubHeader\">Established in the Ecosystem</h2>",
                        "        <div",
                        "          className=\"ecosystemSubSection\"",
                        "          style={{",
                        "            display: \"flex\",",
                        "            justifyContent: \"space-around\",",
                        "            flexFlow: \"row wrap\",",
                        "          }}",
                        "        >",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://2021.stateofjs.com/en-US/other-tools/utilities\"",
                        "              style={{ marginTop: \"15px\" }}",
                        "            >",
                        "              <img",
                        "                src=\"/images/state_of_js_grey.svg\"",
                        "                style={{ width: \"80px\" }}",
                        "              />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>Regularly used by:</p>",
                        "              <ul style={{ marginBottom: \"0\" }}>",
                        "                <li>",
                        "                  <a href=\"https://2021.stateofjs.com/en-US/other-tools/#utilities\">",
                        "                    More than 83% of respondents to State of JS 2021.",
                        "                  </a>",
                        "                </li>",
                        "                <li>",
                        "                  <a href=\"https://2020.stateofjs.com/en-US/other-tools/#utilities\">",
                        "                    More than 70% of respondents to State of JS 2020.",
                        "                  </a>",
                        "                </li>",
                        "              </ul>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a href=\"https://github.com/prettier/prettier\">",
                        "              <img src=\"/images/github_grey.svg\" style={{ width: \"80px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than{\" \"}",
                        "                <strong data-placeholder=\"dependent-github\">5.2 million</strong>{\" \"}",
                        "                dependent repositories on GitHub",
                        "              </p>",
                        "              <Button href=\"https://github.com/prettier/prettier/network/dependents\">",
                        "                Check Them Out",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a href=\"https://npmjs.com/package/prettier\">",
                        "              <img src=\"/images/npm_grey.svg\" style={{ width: \"80px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than <strong data-placeholder=\"dependent-npm\">13k</strong>{\" \"}",
                        "                dependent packages on npm",
                        "              </p>",
                        "              <Button href=\"https://www.npmjs.com/browse/depended/prettier\">",
                        "                See them all",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "UsersSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "class Index extends React.Component {",
                        "  render() {",
                        "    const language = this.props.language || \"en\";",
                        "",
                        "    return (",
                        "      <div>",
                        "        <script src=\"landing.js\" />",
                        "        <HomeSplash language={language} />",
                        "        <div className=\"mainContainer landingContainer\">",
                        "          <TldrSection language={language} />",
                        "          <LanguagesSection />",
                        "          <EditorSupportSection />",
                        "          <UsersSection language={language} />",
                        "        </div>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Index.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "module.exports = Index;"
                    ]
                },
                "versions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * Copyright (c) 2017-present, Facebook, Inc.",
                        " *",
                        " * This source code is licensed under the MIT license found in the",
                        " * LICENSE file in the root directory of this source tree.",
                        " */",
                        "",
                        "const React = require(\"react\");",
                        "const { Container } = require(\"../../core/CompLibrary.js\");",
                        "",
                        "const CWD = process.cwd();",
                        "",
                        "const versions = require(`${CWD}/versions.json`);",
                        "",
                        "const rootPackageJson = require(`${CWD}/../package.json`);",
                        "const defaultBranchVersion = rootPackageJson.version;",
                        "const isDefaultBranchDevVersion = defaultBranchVersion.endsWith(\"-dev\");",
                        "const devVersion = isDefaultBranchDevVersion ? defaultBranchVersion : null;",
                        "const latestVersion = isDefaultBranchDevVersion",
                        "  ? rootPackageJson.devDependencies.prettier",
                        "  : defaultBranchVersion;",
                        "const [latestDocsVersion, ...pastDocsVersions] = versions;",
                        "",
                        "function Versions(props) {",
                        "  const { config: siteConfig } = props;",
                        "  return (",
                        "    <div className=\"docMainWrapper wrapper\">",
                        "      <Container className=\"mainContainer versionsContainer\">",
                        "        <div className=\"post\">",
                        "          <header className=\"postHeader\">",
                        "            <h1>{siteConfig.title} Versions</h1>",
                        "          </header>",
                        "          <table className=\"versions\">",
                        "            <tbody>",
                        "              <tr>",
                        "                <th>Version</th>",
                        "                <th>Install with</th>",
                        "                <th>Documentation</th>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{latestVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/index.html`}>",
                        "                    {latestDocsVersion}",
                        "                  </a>{\" \"}",
                        "                  (latest)",
                        "                </td>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{devVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier/prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/next/index.html`}>",
                        "                    next",
                        "                  </a>{\" \"}",
                        "                  (main)",
                        "                </td>",
                        "              </tr>",
                        "              {pastDocsVersions.length > 0 &&",
                        "                pastDocsVersions.map((pastDocsVersion, index) => {",
                        "                  const pastMajorVersion = pastDocsVersion.replace(/^v/, \"\");",
                        "                  return (",
                        "                    <tr key={index}>",
                        "                      <td>{pastMajorVersion}.x</td>",
                        "                      <td>",
                        "                        <code>",
                        "                          npm install prettier@",
                        "                          {pastMajorVersion}",
                        "                        </code>",
                        "                      </td>",
                        "                      <td>",
                        "                        <a",
                        "                          href={`${siteConfig.baseUrl}docs/en/${pastDocsVersion}/index.html`}",
                        "                        >",
                        "                          {pastDocsVersion}",
                        "                        </a>",
                        "                      </td>",
                        "                    </tr>",
                        "                  );",
                        "                })}",
                        "            </tbody>",
                        "          </table>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "module.exports = Versions;"
                    ]
                },
                "help": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container, GridBlock } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "class Help extends React.Component {",
                            "  render() {",
                            "    const supportLinks = [",
                            "      {",
                            "        content:",
                            "          \"Learn more using the [documentation on this site.](/docs/en/why-prettier.html)\\n\",",
                            "        title: \"Browse Docs\",",
                            "      },",
                            "      {",
                            "        content: \"Ask questions about the documentation and project\\n\",",
                            "        title: \"Join the community\",",
                            "      },",
                            "      {",
                            "        content: \"Find out what's new with this project\\n\",",
                            "        title: \"Stay up to date\",",
                            "      },",
                            "    ];",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"docMainWrapper wrapper\">",
                            "          <Container className=\"mainContainer documentContainer postContainer\">",
                            "            <div className=\"post\">",
                            "              <header className=\"postHeader\">",
                            "                <h2>Need help?</h2>",
                            "              </header>",
                            "              <p>This project is maintained by a dedicated group of people;</p>",
                            "              <GridBlock contents={supportLinks} layout=\"threeColumn\" />",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Help.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "module.exports = Help;"
                        ]
                    }
                },
                "users": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                            "",
                            "class Users extends React.Component {",
                            "  render() {",
                            "    const showcase = siteConfig.users.map((user, i) => (",
                            "      <a key={i} href={user.infoLink}>",
                            "        <img src={user.image} title={user.caption} />",
                            "      </a>",
                            "    ));",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"mainContainer\">",
                            "          <Container padding={[\"bottom\", \"top\"]}>",
                            "            <div className=\"showcaseSection\">",
                            "              <div className=\"prose\">",
                            "                <h1>Who\u2019s Using This?</h1>",
                            "              </div>",
                            "              <blockquote",
                            "                style={{",
                            "                  fontSize: \"125%\",",
                            "                  textAlign: \"left\",",
                            "                }}",
                            "              >",
                            "                <p>Prettier is regularly used by:</p>",
                            "                <ul>",
                            "                  <li>",
                            "                    <a href=\"https://2021.stateofjs.com/en-US/other-tools/#utilities\">",
                            "                      More than <strong>83%</strong> of respondents to State of",
                            "                      JS 2021 (10282 developers out of 12360).",
                            "                    </a>",
                            "                  </li>",
                            "                  <li>",
                            "                    <a href=\"https://2020.stateofjs.com/en-US/other-tools/#utilities\">",
                            "                      More than <strong>70%</strong> of respondents to State of",
                            "                      JS 2020 (14880 developers out of 20974).",
                            "                    </a>",
                            "                  </li>",
                            "                </ul>",
                            "              </blockquote>",
                            "              <div className=\"logos\">{showcase}</div>",
                            "              <div className=\"prose\">",
                            "                ...and{\" \"}",
                            "                <a href=\"https://www.npmjs.com/browse/depended/prettier\">",
                            "                  many more projects",
                            "                </a>",
                            "              </div>",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Users.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "Users.title = \"Who's using Prettier?\";",
                            "",
                            "module.exports = Users;"
                        ]
                    }
                }
            },
            "playground": {
                "index.html": {}
            }
        },
        "playground": {
            "BottomBar.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"bottom-bar\");",
                    "",
                    "export default function BottomBar({ left, right }) {",
                    "  return ReactDOM.createPortal(",
                    "    <React.Fragment>",
                    "      <div className=\"bottom-bar-buttons\">{left}</div>",
                    "      <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">{right}</div>",
                    "    </React.Fragment>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "EditorState.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { stateToggler, shallowEqual } from \"./helpers.js\";",
                    "import * as storage from \"./storage.js\";",
                    "",
                    "export default class EditorState extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = {",
                    "      showSidebar: window.innerWidth > window.innerHeight,",
                    "      showAst: false,",
                    "      showDoc: false,",
                    "      showComments: false,",
                    "      showSecondFormat: false,",
                    "      showInput: true,",
                    "      showOutput: true,",
                    "      rethrowEmbedErrors: false,",
                    "      toggleSidebar: () => this.setState(stateToggler(\"showSidebar\")),",
                    "      toggleAst: () => this.setState(stateToggler(\"showAst\")),",
                    "      toggleDoc: () => this.setState(stateToggler(\"showDoc\")),",
                    "      toggleComments: () => this.setState(stateToggler(\"showComments\")),",
                    "      toggleSecondFormat: () => this.setState(stateToggler(\"showSecondFormat\")),",
                    "      toggleInput: () => this.setState(stateToggler(\"showInput\")),",
                    "      toggleOutput: () => this.setState(stateToggler(\"showOutput\")),",
                    "      toggleEmbedErrors: () =>",
                    "        this.setState(stateToggler(\"rethrowEmbedErrors\")),",
                    "      ...storage.get(\"editor_state\"),",
                    "    };",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    if (!shallowEqual(this.state, prevState)) {",
                    "      storage.set(\"editor_state\", this.state);",
                    "    }",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "Playground.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { Button, ClipboardButton } from \"./buttons.js\";",
                    "import EditorState from \"./EditorState.js\";",
                    "import { DebugPanel, InputPanel, OutputPanel } from \"./panels.js\";",
                    "import PrettierFormat from \"./PrettierFormat.js\";",
                    "import { shallowEqual } from \"./helpers.js\";",
                    "import * as urlHash from \"./urlHash.js\";",
                    "import formatMarkdown from \"./markdown.js\";",
                    "import * as util from \"./util.js\";",
                    "import getCodeSample from \"./codeSamples.js\";",
                    "",
                    "import { Sidebar, SidebarCategory } from \"./sidebar/components.js\";",
                    "import SidebarOptions from \"./sidebar/SidebarOptions.js\";",
                    "import Option from \"./sidebar/options.js\";",
                    "import { Checkbox } from \"./sidebar/inputs.js\";",
                    "",
                    "const CATEGORIES_ORDER = [",
                    "  \"Global\",",
                    "  \"Common\",",
                    "  \"JavaScript\",",
                    "  \"Markdown\",",
                    "  \"HTML\",",
                    "  \"Special\",",
                    "];",
                    "const ISSUES_URL = \"https://github.com/prettier/prettier/issues/new?body=\";",
                    "const MAX_LENGTH = 8000 - ISSUES_URL.length; // it seems that GitHub limit is 8195",
                    "const COPY_MESSAGE =",
                    "  \"<!-- The issue body has been saved to the clipboard. Please paste it after this line! \ud83d\udc47 -->\\n\";",
                    "",
                    "const ENABLED_OPTIONS = [",
                    "  \"parser\",",
                    "  \"printWidth\",",
                    "  \"tabWidth\",",
                    "  \"useTabs\",",
                    "  \"semi\",",
                    "  \"singleQuote\",",
                    "  \"bracketSpacing\",",
                    "  \"jsxSingleQuote\",",
                    "  \"quoteProps\",",
                    "  \"arrowParens\",",
                    "  \"trailingComma\",",
                    "  \"proseWrap\",",
                    "  \"htmlWhitespaceSensitivity\",",
                    "  \"insertPragma\",",
                    "  \"requirePragma\",",
                    "  \"vueIndentScriptAndStyle\",",
                    "  \"embeddedLanguageFormatting\",",
                    "  \"bracketSameLine\",",
                    "  \"singleAttributePerLine\",",
                    "];",
                    "",
                    "class Playground extends React.Component {",
                    "  constructor(props) {",
                    "    super();",
                    "",
                    "    const original = urlHash.read();",
                    "",
                    "    const defaultOptions = util.getDefaults(",
                    "      props.availableOptions,",
                    "      ENABLED_OPTIONS",
                    "    );",
                    "",
                    "    const options = Object.assign(defaultOptions, original.options);",
                    "",
                    "    // backwards support for old parser `babylon`",
                    "    if (options.parser === \"babylon\") {",
                    "      options.parser = \"babel\";",
                    "    }",
                    "",
                    "    const codeSample = getCodeSample(options.parser);",
                    "    const content = original.content || codeSample;",
                    "    const needsClickForFirstRun =",
                    "      options.parser === \"doc-explorer\" && content !== codeSample;",
                    "    const selection = {};",
                    "",
                    "    this.state = { content, options, selection, needsClickForFirstRun };",
                    "",
                    "    this.handleOptionValueChange = this.handleOptionValueChange.bind(this);",
                    "",
                    "    this.setContent = (content) => this.setState({ content });",
                    "    this.clearContent = this.setContent.bind(this, \"\");",
                    "    this.resetOptions = () => this.setState({ options: defaultOptions });",
                    "    this.setSelection = (selection) => this.setState({ selection });",
                    "    this.setSelectionAsRange = () => {",
                    "      const { selection, content, options } = this.state;",
                    "      const [rangeStart, rangeEnd] = util.convertSelectionToRange(",
                    "        selection,",
                    "        content",
                    "      );",
                    "      const updatedOptions = { ...options, rangeStart, rangeEnd };",
                    "      if (rangeStart === rangeEnd) {",
                    "        delete updatedOptions.rangeStart;",
                    "        delete updatedOptions.rangeEnd;",
                    "      }",
                    "      this.setState({ options: updatedOptions });",
                    "    };",
                    "",
                    "    this.enabledOptions = orderOptions(props.availableOptions, ENABLED_OPTIONS);",
                    "    this.rangeStartOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeStart\"",
                    "    );",
                    "    this.rangeEndOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeEnd\"",
                    "    );",
                    "",
                    "    this.handleInputPanelFormat = this.handleInputPanelFormat.bind(this);",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    const { content, options } = this.state;",
                    "    if (",
                    "      !shallowEqual(prevState.options, this.state.options) ||",
                    "      prevState.content !== content",
                    "    ) {",
                    "      urlHash.replace({ content, options });",
                    "    }",
                    "  }",
                    "",
                    "  handleOptionValueChange(option, value) {",
                    "    this.setState((state) => {",
                    "      const options = { ...state.options };",
                    "",
                    "      if (option.type === \"int\" && Number.isNaN(value)) {",
                    "        delete options[option.name];",
                    "      } else {",
                    "        options[option.name] = value;",
                    "      }",
                    "",
                    "      const content =",
                    "        state.content === \"\" ||",
                    "        state.content === getCodeSample(state.options.parser)",
                    "          ? getCodeSample(options.parser)",
                    "          : state.content;",
                    "",
                    "      if (option.name === \"parser\") {",
                    "        state.needsClickForFirstRun = false;",
                    "      }",
                    "",
                    "      return { options, content };",
                    "    });",
                    "  }",
                    "",
                    "  getMarkdown({ formatted, reformatted, full, doc }) {",
                    "    const { content, options } = this.state;",
                    "    const { availableOptions, version } = this.props;",
                    "    const orderedOptions = orderOptions(availableOptions, [",
                    "      ...ENABLED_OPTIONS,",
                    "      \"rangeStart\",",
                    "      \"rangeEnd\",",
                    "    ]);",
                    "    const cliOptions = util.buildCliArgs(orderedOptions, options);",
                    "",
                    "    return formatMarkdown({",
                    "      input: content,",
                    "      output: formatted,",
                    "      output2: reformatted,",
                    "      doc,",
                    "      version,",
                    "      url: window.location.href,",
                    "      options,",
                    "      cliOptions,",
                    "      full,",
                    "    });",
                    "  }",
                    "",
                    "  handleInputPanelFormat() {",
                    "    if (this.state.options.parser !== \"doc-explorer\") {",
                    "      return;",
                    "    }",
                    "",
                    "    const { content, selection } = this.state;",
                    "",
                    "    return this.props.worker",
                    "      .format(content, {",
                    "        parser: \"__js_expression\",",
                    "        cursorOffset: util.convertSelectionToRange(selection, content)[0],",
                    "      })",
                    "      .then(({ error, formatted, cursorOffset }) => {",
                    "        if (error) {",
                    "          return;",
                    "        }",
                    "",
                    "        return {",
                    "          value: formatted,",
                    "          cursor: util.convertOffsetToPosition(cursorOffset, formatted),",
                    "        };",
                    "      });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { worker, version } = this.props;",
                    "    const { content, options } = this.state;",
                    "",
                    "    // TODO: remove this when v2.3.0 is released",
                    "    const [major, minor] = version.split(\".\", 2).map(Number);",
                    "    const showShowComments =",
                    "      Number.isNaN(major) || (major === 2 && minor >= 3) || major > 2;",
                    "",
                    "    return (",
                    "      <EditorState>",
                    "        {(editorState) => (",
                    "          <PrettierFormat",
                    "            enabled={!this.state.needsClickForFirstRun}",
                    "            worker={worker}",
                    "            code={content}",
                    "            options={options}",
                    "            debugAst={editorState.showAst}",
                    "            debugDoc={editorState.showDoc}",
                    "            debugComments={showShowComments && editorState.showComments}",
                    "            reformat={editorState.showSecondFormat}",
                    "            rethrowEmbedErrors={editorState.rethrowEmbedErrors}",
                    "          >",
                    "            {({ formatted, debug }) => {",
                    "              const fullReport = this.getMarkdown({",
                    "                formatted,",
                    "                reformatted: debug.reformatted,",
                    "                full: true,",
                    "              });",
                    "              const showFullReport =",
                    "                encodeURIComponent(fullReport).length < MAX_LENGTH;",
                    "              return (",
                    "                <React.Fragment>",
                    "                  <div className=\"editors-container\">",
                    "                    <Sidebar visible={editorState.showSidebar}>",
                    "                      <SidebarOptions",
                    "                        categories={CATEGORIES_ORDER}",
                    "                        availableOptions={this.enabledOptions}",
                    "                        optionValues={options}",
                    "                        onOptionValueChange={this.handleOptionValueChange}",
                    "                      />",
                    "                      <SidebarCategory title=\"Range\">",
                    "                        <label>",
                    "                          The selected range will be highlighted in yellow in",
                    "                          the input editor",
                    "                        </label>",
                    "                        <Option",
                    "                          option={this.rangeStartOption}",
                    "                          value={",
                    "                            typeof options.rangeStart === \"number\"",
                    "                              ? options.rangeStart",
                    "                              : \"\"",
                    "                          }",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "                        <Option",
                    "                          option={this.rangeEndOption}",
                    "                          value={",
                    "                            typeof options.rangeEnd === \"number\"",
                    "                              ? options.rangeEnd",
                    "                              : \"\"",
                    "                          }",
                    "                          overrideMax={content.length}",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "",
                    "                        <Button onClick={this.setSelectionAsRange}>",
                    "                          Set selected text as range",
                    "                        </Button>",
                    "                      </SidebarCategory>",
                    "                      <SidebarCategory title=\"Debug\">",
                    "                        <Checkbox",
                    "                          label=\"show input\"",
                    "                          checked={editorState.showInput}",
                    "                          onChange={editorState.toggleInput}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show AST\"",
                    "                          checked={editorState.showAst}",
                    "                          onChange={editorState.toggleAst}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show doc\"",
                    "                          checked={editorState.showDoc}",
                    "                          onChange={editorState.toggleDoc}",
                    "                        />",
                    "                        {showShowComments && (",
                    "                          <Checkbox",
                    "                            label=\"show comments\"",
                    "                            checked={editorState.showComments}",
                    "                            onChange={editorState.toggleComments}",
                    "                          />",
                    "                        )}",
                    "                        <Checkbox",
                    "                          label=\"show output\"",
                    "                          checked={editorState.showOutput}",
                    "                          onChange={editorState.toggleOutput}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show second format\"",
                    "                          checked={editorState.showSecondFormat}",
                    "                          onChange={editorState.toggleSecondFormat}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"rethrow embed errors\"",
                    "                          checked={editorState.rethrowEmbedErrors}",
                    "                          onChange={editorState.toggleEmbedErrors}",
                    "                        />",
                    "                        {editorState.showDoc && (",
                    "                          <ClipboardButton",
                    "                            copy={() => this.getMarkdown({ doc: debug.doc })}",
                    "                            disabled={!debug.doc}",
                    "                          >",
                    "                            Copy doc",
                    "                          </ClipboardButton>",
                    "                        )}",
                    "                      </SidebarCategory>",
                    "                      <div className=\"sub-options\">",
                    "                        <Button onClick={this.resetOptions}>",
                    "                          Reset to defaults",
                    "                        </Button>",
                    "                      </div>",
                    "                    </Sidebar>",
                    "                    <div className=\"editors\">",
                    "                      {editorState.showInput ? (",
                    "                        <InputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          ruler={options.printWidth}",
                    "                          value={content}",
                    "                          codeSample={getCodeSample(options.parser)}",
                    "                          overlayStart={options.rangeStart}",
                    "                          overlayEnd={options.rangeEnd}",
                    "                          onChange={this.setContent}",
                    "                          onSelectionChange={this.setSelection}",
                    "                          onFormat={this.handleInputPanelFormat}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showAst ? (",
                    "                        <DebugPanel",
                    "                          value={debug.ast || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showDoc ? (",
                    "                        <DebugPanel value={debug.doc || \"\"} />",
                    "                      ) : null}",
                    "                      {showShowComments && editorState.showComments ? (",
                    "                        <DebugPanel",
                    "                          value={debug.comments || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showOutput ? (",
                    "                        this.state.needsClickForFirstRun ? (",
                    "                          <div className=\"editor disabled-output-panel\">",
                    "                            <div className=\"explanation\">",
                    "                              <code>doc-explorer</code> involves running code",
                    "                              provided by users.",
                    "                            </div>",
                    "                            <div className=\"explanation\">",
                    "                              To stay on the safe side and prevent abuse, an",
                    "                              explicit user action is required when a direct",
                    "                              link to a <code>doc-explorer</code> playground is",
                    "                              opened.",
                    "                            </div>",
                    "                            <div className=\"explanation\">",
                    "                              Click the button below to start the playground.",
                    "                            </div>",
                    "                            <Button",
                    "                              onClick={() =>",
                    "                                this.setState({ needsClickForFirstRun: false })",
                    "                              }",
                    "                            >",
                    "                              Start",
                    "                            </Button>",
                    "                          </div>",
                    "                        ) : (",
                    "                          <OutputPanel",
                    "                            mode={util.getCodemirrorMode(options.parser)}",
                    "                            value={formatted}",
                    "                            ruler={options.printWidth}",
                    "                          />",
                    "                        )",
                    "                      ) : null}",
                    "                      {editorState.showSecondFormat ? (",
                    "                        <OutputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          value={getSecondFormat(formatted, debug.reformatted)}",
                    "                          ruler={options.printWidth}",
                    "                        />",
                    "                      ) : null}",
                    "                    </div>",
                    "                  </div>",
                    "                  <div className=\"bottom-bar\">",
                    "                    <div className=\"bottom-bar-buttons\">",
                    "                      <Button onClick={editorState.toggleSidebar}>",
                    "                        {editorState.showSidebar ? \"Hide\" : \"Show\"} options",
                    "                      </Button>",
                    "                      <Button onClick={this.clearContent}>Clear</Button>",
                    "                      <ClipboardButton",
                    "                        copy={JSON.stringify(",
                    "                          // Remove `parser` since people usually paste this",
                    "                          // into their .prettierrc and specifying a top-level",
                    "                          // parser there is an anti-pattern. Note:",
                    "                          // `JSON.stringify` omits keys whose values are",
                    "                          // `undefined`.",
                    "                          { ...options, parser: undefined },",
                    "                          null,",
                    "                          2",
                    "                        )}",
                    "                      >",
                    "                        Copy config JSON",
                    "                      </ClipboardButton>",
                    "                    </div>",
                    "                    <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">",
                    "                      <ClipboardButton copy={window.location.href}>",
                    "                        Copy link",
                    "                      </ClipboardButton>",
                    "                      <ClipboardButton",
                    "                        copy={() =>",
                    "                          this.getMarkdown({",
                    "                            formatted,",
                    "                            reformatted: debug.reformatted,",
                    "                          })",
                    "                        }",
                    "                      >",
                    "                        Copy markdown",
                    "                      </ClipboardButton>",
                    "                      <a",
                    "                        href={getReportLink(",
                    "                          showFullReport ? fullReport : COPY_MESSAGE",
                    "                        )}",
                    "                        target=\"_blank\"",
                    "                        rel=\"noopener noreferrer\"",
                    "                      >",
                    "                        <ClipboardButton",
                    "                          copy={() => (showFullReport ? \"\" : fullReport)}",
                    "                        >",
                    "                          Report issue",
                    "                        </ClipboardButton>",
                    "                      </a>",
                    "                    </div>",
                    "                  </div>",
                    "                </React.Fragment>",
                    "              );",
                    "            }}",
                    "          </PrettierFormat>",
                    "        )}",
                    "      </EditorState>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function orderOptions(availableOptions, order) {",
                    "  const optionsByName = {};",
                    "  for (const option of availableOptions) {",
                    "    optionsByName[option.name] = option;",
                    "  }",
                    "",
                    "  return order.map((name) => optionsByName[name]);",
                    "}",
                    "",
                    "function getReportLink(reportBody) {",
                    "  return `${ISSUES_URL}${encodeURIComponent(reportBody)}`;",
                    "}",
                    "",
                    "function getSecondFormat(formatted, reformatted) {",
                    "  return formatted === \"\"",
                    "    ? \"\"",
                    "    : formatted === reformatted",
                    "    ? \"\u2713 Second format is unchanged.\"",
                    "    : reformatted;",
                    "}",
                    "",
                    "export default Playground;"
                ]
            },
            "PrettierFormat.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "export default class PrettierFormat extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { formatted: \"\", debug: {} };",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.format();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    for (const key of [",
                    "      \"enabled\",",
                    "      \"code\",",
                    "      \"options\",",
                    "      \"debugAst\",",
                    "      \"debugDoc\",",
                    "      \"debugComments\",",
                    "      \"reformat\",",
                    "      \"rethrowEmbedErrors\",",
                    "    ]) {",
                    "      if (prevProps[key] !== this.props[key]) {",
                    "        this.format();",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  format() {",
                    "    const {",
                    "      enabled,",
                    "      worker,",
                    "      code,",
                    "      options,",
                    "      debugAst: ast,",
                    "      debugDoc: doc,",
                    "      debugComments: comments,",
                    "      reformat,",
                    "      rethrowEmbedErrors,",
                    "    } = this.props;",
                    "",
                    "    if (!enabled) {",
                    "      return;",
                    "    }",
                    "",
                    "    worker",
                    "      .format(code, options, {",
                    "        ast,",
                    "        doc,",
                    "        comments,",
                    "        reformat,",
                    "        rethrowEmbedErrors,",
                    "      })",
                    "      .then((result) => this.setState(result));",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "VersionLink.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"version\");",
                    "",
                    "export default function VersionLink({ version }) {",
                    "  const match = version.match(/^pr-(\\d+)$/);",
                    "  let href;",
                    "  if (match) {",
                    "    href = `pull/${match[1]}`;",
                    "  } else if (/\\.0$/.test(version)) {",
                    "    href = `releases/tag/${version}`;",
                    "  } else {",
                    "    href = `blob/main/CHANGELOG.md#${version.replace(/\\./g, \"\")}`;",
                    "  }",
                    "",
                    "  const formattedVersion = match ? `PR #${match[1]}` : `v${version}`;",
                    "",
                    "  React.useEffect(() => {",
                    "    document.title = `Prettier ${formattedVersion}`;",
                    "  }, [formattedVersion]);",
                    "",
                    "  return ReactDOM.createPortal(",
                    "    <a",
                    "      href={`https://github.com/prettier/prettier/${href}`}",
                    "      target=\"_blank\"",
                    "      rel=\"noreferrer noopener\"",
                    "    >",
                    "      {formattedVersion}",
                    "    </a>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "WorkerApi.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export default function WorkerApi(source) {",
                    "  const worker = new Worker(source);",
                    "  let counter = 0;",
                    "  const handlers = {};",
                    "",
                    "  worker.addEventListener(\"message\", (event) => {",
                    "    const { uid, message, error } = event.data;",
                    "",
                    "    if (!handlers[uid]) {",
                    "      return;",
                    "    }",
                    "",
                    "    const [resolve, reject] = handlers[uid];",
                    "    delete handlers[uid];",
                    "",
                    "    if (error) {",
                    "      reject(error);",
                    "    } else {",
                    "      resolve(message);",
                    "    }",
                    "  });",
                    "",
                    "  function postMessage(message) {",
                    "    const uid = ++counter;",
                    "    return new Promise((resolve, reject) => {",
                    "      handlers[uid] = [resolve, reject];",
                    "      worker.postMessage({ uid, message });",
                    "    });",
                    "  }",
                    "",
                    "  return {",
                    "    getMetadata() {",
                    "      return postMessage({ type: \"meta\" });",
                    "    },",
                    "    format(code, options, debug = {}) {",
                    "      return postMessage({ type: \"format\", code, options, debug });",
                    "    },",
                    "    postMessage,",
                    "  };",
                    "}"
                ]
            },
            "buttons.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import ClipboardJS from \"clipboard\";",
                    "",
                    "export const Button = React.forwardRef((props, ref) => (",
                    "  <button type=\"button\" className=\"btn\" ref={ref} {...props} />",
                    "));",
                    "",
                    "export class ClipboardButton extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { showTooltip: false, tooltipText: \"\" };",
                    "    this.timer = null;",
                    "    this.ref = React.createRef();",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.clipboard = new ClipboardJS(this.ref.current, {",
                    "      text: () => {",
                    "        const { copy } = this.props;",
                    "        return typeof copy === \"function\" ? copy() : copy;",
                    "      },",
                    "    });",
                    "    this.clipboard.on(\"success\", () => this.showTooltip(\"Copied!\"));",
                    "    this.clipboard.on(\"error\", () => this.showTooltip(\"Press ctrl+c to copy\"));",
                    "  }",
                    "",
                    "  showTooltip(text) {",
                    "    this.setState({ showTooltip: true, tooltipText: text }, () => {",
                    "      if (this.timer) {",
                    "        clearTimeout(this.timer);",
                    "      }",
                    "      this.timer = setTimeout(() => {",
                    "        this.timer = null;",
                    "        this.setState({ showTooltip: false });",
                    "      }, 2000);",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { children, copy, ...rest } = this.props;",
                    "    const { showTooltip, tooltipText } = this.state;",
                    "",
                    "    return (",
                    "      <Button ref={this.ref} {...rest}>",
                    "        {showTooltip ? <span className=\"tooltip\">{tooltipText}</span> : null}",
                    "        {children}",
                    "      </Button>",
                    "    );",
                    "  }",
                    "}"
                ]
            },
            "codeSamples.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export default function getCodeSamples(parser) {",
                    "  switch (parser) {",
                    "    case \"babel\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "      return [",
                    "        'function HelloWorld({greeting = \"hello\", greeted = \\'\"World\"\\', silent = false, onMouseOver,}) {',",
                    "        \"\",",
                    "        \"  if(!greeting){return null};\",",
                    "        \"\",",
                    "        \"     // TODO: Don't use random in render\",",
                    "        '  let num = Math.floor (Math.random() * 1E+7).toString().replace(/\\\\.\\\\d+/ig, \"\")',",
                    "        \"\",",
                    "        \"  return <div className='HelloWorld' title={`You are visitor number ${ num }`} onMouseOver={onMouseOver}>\",",
                    "        \"\",",
                    "        \"    <strong>{ greeting.slice( 0, 1 ).toUpperCase() + greeting.slice(1).toLowerCase() }</strong>\",",
                    "        '    {greeting.endsWith(\",\") ? \" \" : <span style={{color: \\'\\\\grey\\'}}>\", \"</span> }',",
                    "        \"    <em>\",",
                    "        \"\\t{ greeted }\",",
                    "        \"\\t</em>\",",
                    "        \"    { (silent)\",",
                    "        '      ? \".\"',",
                    "        '      : \"!\"}',",
                    "        \"\",",
                    "        \"    </div>;\",",
                    "        \"\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"flow\":",
                    "    case \"babel-flow\":",
                    "      return [",
                    "        \"declare export function graphql<Props, Variables, Component: React$ComponentType<Props>>\",",
                    "        \"  (query: GQLDocument, config?: Config<Props, QueryConfigOptions<Variables>>):\",",
                    "        \"  (Component: Component) => React$ComponentType<$Diff<React$ElementConfig<Component>, {\",",
                    "        \"    data: Object|void,\",",
                    "        \"    mutate: Function|void\",",
                    "        \"  }>>\",",
                    "        \"\",",
                    "        'declare type FetchPolicy = \"cache-first\" | \"cache-and-network\" | \"network-only\" | \"cache-only\"',",
                    "      ].join(\"\\n\");",
                    "    case \"typescript\":",
                    "    case \"babel-ts\":",
                    "      return [",
                    "        \"interface MyInterface {\",",
                    "        \"  foo(): string,\",",
                    "        \"  bar: Array<number>,\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"export abstract class Foo implements MyInterface {\",",
                    "        \"  foo() {\",",
                    "        \"            // TODO: return an actual value here\",",
                    "        \"        return 'hello'\",",
                    "        \"      }\",",
                    "        \"  get bar() {\",",
                    "        \"    return [  1,\",",
                    "        \"\",",
                    "        \"      2, 3,\",",
                    "        \"    ]\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"type RequestType = 'GET' | 'HEAD' | 'POST' | 'PUT' | 'OPTIONS' | 'CONNECT' | 'DELETE' | 'TRACE'\",",
                    "      ].join(\"\\n\");",
                    "    case \"css\":",
                    "      // Excerpted from the Bootstrap source, which is licensed under the MIT license:",
                    "      // https://github.com/twbs/bootstrap/blob/v4.0.0-beta.3/LICENSE",
                    "      return [",
                    "        \"@media (max-width: 480px) {\",",
                    "        \"  .bd-examples {margin-right: -.75rem;margin-left: -.75rem\",",
                    "        \"  }\",",
                    "        \"  \",",
                    "        ' .bd-examples>[class^=\"col-\"]  {',",
                    "        \"    padding-right: .75rem;\",",
                    "        \"    padding-left: .75rem;\",",
                    "        \"  \",",
                    "        \"  }\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"scss\":",
                    "      // Excerpted from the Bootstrap source, which is licensed under the MIT license:",
                    "      // https://github.com/twbs/bootstrap/blob/v4.0.0-beta.3/LICENSE",
                    "      return [",
                    "        \"@function color-yiq($color) {\",",
                    "        \"  $r: red($color);$g: green($color);$b: blue($color);\",",
                    "        \"\",",
                    "        \"  $yiq: (($r * 299) + ($g * 587) + ($b * 114)) / 1000;\",",
                    "        \"\",",
                    "        \"  @if ($yiq >= $yiq-contrasted-threshold) {\",",
                    "        \"    @return $yiq-text-dark;\",",
                    "        \"} @else {\",",
                    "        \"    @return $yiq-text-light;\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"@each $color, $value in $colors {\",",
                    "        \"  .swatch-#{$color} {\",",
                    "        \"    color: color-yiq($value);\",",
                    "        \"    background-color: #{$value};\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"less\":",
                    "      // Copied from http://lesscss.org/features/#detached-rulesets-feature",
                    "      return [",
                    "        \"@my-ruleset: {\",",
                    "        \"    .my-selector {\",",
                    "        \"      @media tv {\",",
                    "        \"        background-color: black;\",",
                    "        \"      }\",",
                    "        \"    }\",",
                    "        \"  };\",",
                    "        \"@media (orientation:portrait) {\",",
                    "        \"    @my-ruleset();\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      // Excerpted & adapted from Wikipedia, under the Creative Commons Attribution-ShareAlike License",
                    "      // https://en.wikipedia.org/wiki/JSON#Example",
                    "      return [",
                    "        '{\"allOn\": \"Single\", \"Line\": \"example\",',",
                    "        '\"noSpace\":true,',",
                    "        '  \"quote\": {',",
                    "        \"    'singleQuote': 'example',\",",
                    "        '                  \"indented\": true,',",
                    "        \"  },\",",
                    "        '  \"phoneNumbers\": [',",
                    "        '    {\"type\": \"home\",',",
                    "        '      \"number\": \"212 555-1234\"},',",
                    "        '    {\"type\": \"office\",',",
                    "        '      \"trailing\": \"commas by accident\"},',",
                    "        \"  ],\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"graphql\":",
                    "      return [",
                    "        \"query Browse($offset: Int, $limit: Int, $categories: [String!], $search: String) {\",",
                    "        \"  browse(limit: $limit, offset: $offset, categories: $categories, search: $search) {\",",
                    "        \"    total,\",",
                    "        \"    results {\",",
                    "        \"        title\",",
                    "        \"        price\",",
                    "        \"    }\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"markdown\":",
                    "      return [",
                    "        \"Header\",",
                    "        \"======\",",
                    "        \"\",",
                    "        \"_Look,_ code blocks are formatted *too!*\",",
                    "        \"\",",
                    "        \"``` js\",",
                    "        \"function identity(x) { return x }\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"Pilot|Airport|Hours\",",
                    "        \"--|:--:|--:\",",
                    "        \"John Doe|SKG|1338\",",
                    "        \"Jane Roe|JFK|314\",",
                    "        \"\",",
                    "        \"- - - - - - - - - - - - - - -\",",
                    "        \"\",",
                    "        \"+ List\",",
                    "        \" + with a [link] (/to/somewhere)\",",
                    "        \"+ and [another one]\",",
                    "        \"\",",
                    "        \"\",",
                    "        \"  [another one]:  http://example.com 'Example title'\",",
                    "        \"\",",
                    "        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",",
                    "        \"Curabitur consectetur maximus risus, sed maximus tellus tincidunt et.\",",
                    "      ].join(\"\\n\");",
                    "    case \"mdx\":",
                    "      // modified from https://github.com/mdx-js/mdx/blob/master/packages/mdx/test/fixtures/blog-post.md",
                    "      return [",
                    "        \"import     {     Baz } from     './Fixture'\",",
                    "        \"import { Buz  }   from './Fixture'\",",
                    "        \"\",",
                    "        \"export  const   foo    = {\",",
                    "        \"  hi:     `Fudge ${Baz.displayName || 'Baz'}`,\",",
                    "        \"  authors: [\",",
                    "        \"     'fred',\",",
                    "        \"           'sally'\",",
                    "        \"    ]\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"# Hello,    world!\",",
                    "        \"\",",
                    "        \"\",",
                    "        \" I'm an awesome   paragraph.\",",
                    "        \"\",",
                    "        \"<!-- I'm a comment -->\",",
                    "        \"\",",
                    "        \"<Foo bg='red'>\",",
                    "        \"      <Bar    >hi    </Bar>\",",
                    "        \"       {  hello       }\",",
                    "        \"       {     /* another comment */}\",",
                    "        \"</Foo>\",",
                    "        \"\",",
                    "        \"```\",",
                    "        \"test codeblock\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"```js\",",
                    "        \"module.exports = 'test'\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"```sh\",",
                    "        \"npm i -g foo\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"| Test  | Table   |\",",
                    "        \"|    :---     | :----  |\",",
                    "        \"|   Col1  | Col2    |\",",
                    "        \"\",",
                    "        \"export   default     ({children   }) => < div>{    children}</div>\",",
                    "        \"\",",
                    "      ].join(\"\\n\");",
                    "    case \"vue\":",
                    "      return [",
                    "        \"<template>\",",
                    "        \"  <p>Templates are formatted as well...\",",
                    "        \"    </p>\",",
                    "        \"</template>\",",
                    "        \"\",",
                    "        \"<script>\",",
                    "        \"let Prettier = format => { your.js('though') }\",",
                    "        \"</script>\",",
                    "        \"\",",
                    "        \"<style>\",",
                    "        \".and { css: too !important }\",",
                    "        \"</style>\",",
                    "      ].join(\"\\n\");",
                    "    case \"yaml\":",
                    "      // modified from http://yaml.org/start.html",
                    "      return [",
                    "        \"---\",",
                    "        \"invoice   :   34843\",",
                    "        \"date   :    2001-01-23\",",
                    "        \"bill-to:    &id001\",",
                    "        \"    given    : Chris\",",
                    "        \"    family  : Dumars\",",
                    "        \"    address:\",",
                    "        \"        lines: |\",",
                    "        \"            458 Walkman Dr.\",",
                    "        \"            Suite #292\",",
                    "        \"        city        : Royal Oak\",",
                    "        \"        state      : MI\",",
                    "        \"        postal  : 48046\",",
                    "        \"ship-to: *id001\",",
                    "        \"product:\",",
                    "        \"    - \",",
                    "        \"    \",",
                    "        \"      sku         : BL394D\",",
                    "        \"      ? quantity    \",",
                    "        \"      : 4\",",
                    "        \"      description : Basketball\",",
                    "        \"      ? price       \",",
                    "        \"      : 450.00\",",
                    "        \"      \",",
                    "        \"      \",",
                    "        \"    - \",",
                    "        \"      sku          :   BL4438H\",",
                    "        \"      quantity      :  1\",",
                    "        \"      description:      Super Hoop\",",
                    "        \"      price         :  2392.00\",",
                    "        \"      \",",
                    "        \"      \",",
                    "        \"tax  :  251.42\",",
                    "        \"total : 4443.52\",",
                    "        \"comments: >\",",
                    "        \"    Late afternoon is best.\",",
                    "        \"    Backup contact is Nancy\",",
                    "        \"    Billsmer @ 338-4338.\",",
                    "        \"\",",
                    "      ].join(\"\\n\");",
                    "    case \"glimmer\":",
                    "      // modified from http://handlebarsjs.com/",
                    "      return [",
                    "        '  <div     class=\"entry\"    >',",
                    "        \"  <h1>{{  title    }}</h1>\",",
                    "        '  <div   class=\"body\">',",
                    "        \"            {{   body         }}\",",
                    "        \"</div> </div>\",",
                    "      ].join(\"\\n\");",
                    "    case \"html\":",
                    "    case \"angular\":",
                    "    case \"lwc\":",
                    "      return [",
                    "        \"<!DOCTYPE html>\",",
                    "        '<HTML CLASS=\"no-js mY-ClAsS\">',",
                    "        \"  <HEAD>\",",
                    "        '    <META CHARSET=\"utf-8\">',",
                    "        \"    <TITLE>My tITlE</TITLE>\",",
                    "        '    <META NAME=\"description\" content=\"My CoNtEnT\">',",
                    "        \"  </HEAD>\",",
                    "        \"  <body>\",",
                    "        \"    <P>Hello world!<BR> This is HTML5 Boilerplate.</P>\",",
                    "        \"    <SCRIPT>\",",
                    "        \"      window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;\",",
                    "        \"      ga('create', 'UA-XXXXX-Y', 'auto'); ga('send', 'pageview')\",",
                    "        \"    </SCRIPT>\",",
                    "        '    <SCRIPT src=\"https://www.google-analytics.com/analytics.js\" ASYNC DEFER></SCRIPT>',",
                    "        \"  </body>\",",
                    "        \"</HTML>\",",
                    "      ].join(\"\\n\");",
                    "    case \"doc-explorer\":",
                    "      return [",
                    "        \"group([\",",
                    "        '  \"(*\",',",
                    "        \"  indent([\",",
                    "        \"    line,\",",
                    "        '    \"Prettier:\",',",
                    "        \"    line,\",",
                    "        '    \"Opinionated,\",',",
                    "        \"    line,\",",
                    "        '    \"Code,\",',",
                    "        \"    line,\",",
                    "        '    \"Formatter\",',",
                    "        \"  ]),\",",
                    "        \"  line,\",",
                    "        '  \"*)\",',",
                    "        \"])\",",
                    "      ].join(\"\\n\");",
                    "    default:",
                    "      return \"\";",
                    "  }",
                    "}"
                ]
            },
            "helpers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function stateToggler(key) {",
                    "  return (state) => ({ [key]: !state[key] });",
                    "}",
                    "",
                    "const { hasOwnProperty } = Object.prototype;",
                    "",
                    "function is(x, y) {",
                    "  // SameValue algorithm",
                    "  if (x === y) {",
                    "    // Steps 1-5, 7-10",
                    "    // Steps 6.b-6.e: +0 != -0",
                    "    return x !== 0 || 1 / x === 1 / y;",
                    "  }",
                    "  // Step 6.a: NaN == NaN",
                    "  return x !== x && y !== y;",
                    "}",
                    "",
                    "export function shallowEqual(objA, objB) {",
                    "  if (is(objA, objB)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    typeof objA !== \"object\" ||",
                    "    objA === null ||",
                    "    typeof objB !== \"object\" ||",
                    "    objB === null",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const keysA = Object.keys(objA);",
                    "  const keysB = Object.keys(objB);",
                    "",
                    "  if (keysA.length !== keysB.length) {",
                    "    return false;",
                    "  }",
                    "",
                    "  for (let i = 0; i < keysA.length; i++) {",
                    "    if (",
                    "      !hasOwnProperty.call(objB, keysA[i]) ||",
                    "      !is(objA[keysA[i]], objB[keysA[i]])",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import \"codemirror-graphql/mode\";",
                    "",
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "import Playground from \"./Playground.js\";",
                    "import VersionLink from \"./VersionLink.js\";",
                    "import WorkerApi from \"./WorkerApi.js\";",
                    "import { fixPrettierVersion } from \"./util.js\";",
                    "",
                    "class App extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { loaded: false };",
                    "    this.worker = new WorkerApi(\"/worker.js\");",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.worker.getMetadata().then(({ supportInfo, version }) => {",
                    "      this.setState({",
                    "        loaded: true,",
                    "        availableOptions: supportInfo.options.map(augmentOption),",
                    "        version: fixPrettierVersion(version),",
                    "      });",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { loaded, availableOptions, version } = this.state;",
                    "",
                    "    if (!loaded) {",
                    "      return \"Loading...\";",
                    "    }",
                    "",
                    "    return (",
                    "      <React.Fragment>",
                    "        <VersionLink version={version} />",
                    "        <Playground",
                    "          worker={this.worker}",
                    "          availableOptions={availableOptions}",
                    "          version={version}",
                    "        />",
                    "      </React.Fragment>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function augmentOption(option) {",
                    "  if (option.type === \"boolean\" && option.default === true) {",
                    "    option.inverted = true;",
                    "  }",
                    "",
                    "  option.cliName =",
                    "    \"--\" +",
                    "    (option.inverted ? \"no-\" : \"\") +",
                    "    option.name.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();",
                    "",
                    "  return option;",
                    "}",
                    "",
                    "ReactDOM.render(<App />, document.getElementById(\"root\"));"
                ]
            },
            "markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function formatMarkdown({",
                    "  input,",
                    "  output,",
                    "  output2,",
                    "  doc,",
                    "  version,",
                    "  url,",
                    "  options,",
                    "  cliOptions,",
                    "  full,",
                    "}) {",
                    "  const syntax = getMarkdownSyntax(options);",
                    "  const optionsString = formatCLIOptions(cliOptions);",
                    "  const isIdempotent = !output2 || output === output2;",
                    "",
                    "  return [",
                    "    `**Prettier ${version}**`,",
                    "    `[Playground link](${url})`,",
                    "    optionsString === \"\" ? null : codeBlock(optionsString, \"sh\"),",
                    "    \"\",",
                    "    \"**Input:**\",",
                    "    codeBlock(input, syntax),",
                    "    ...(doc ? [\"\", \"**Doc:**\", codeBlock(doc, \"js\")] : []),",
                    "    ...(output === undefined",
                    "      ? []",
                    "      : [\"\", \"**Output:**\", codeBlock(output, syntax)]),",
                    "    ...(isIdempotent",
                    "      ? []",
                    "      : [\"\", \"**Second Output:**\", codeBlock(output2, syntax)]),",
                    "    ...(full ? [\"\", \"**Expected behavior:**\", \"\"] : []),",
                    "  ]",
                    "    .filter((part) => part !== null)",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function getMarkdownSyntax(options) {",
                    "  switch (options.parser) {",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"flow\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"doc-explorer\":",
                    "      return \"jsx\";",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "      return \"tsx\";",
                    "    case \"json\":",
                    "    case \"json-stringify\":",
                    "      return \"jsonc\";",
                    "    case \"glimmer\":",
                    "      return \"hbs\";",
                    "    case \"angular\":",
                    "    case \"lwc\":",
                    "      return \"html\";",
                    "    default:",
                    "      return options.parser;",
                    "  }",
                    "}",
                    "",
                    "function formatCLIOptions(cliOptions) {",
                    "  return cliOptions",
                    "    .map(([name, value]) => (value === true ? name : `${name} ${value}`))",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function codeBlock(content, syntax) {",
                    "  const backtickSequences = content.match(/`+/g) || [];",
                    "  const longestBacktickSequenceLength = Math.max(",
                    "    ...backtickSequences.map(({ length }) => length)",
                    "  );",
                    "  const prettierIgnoreComment = \"<!-- prettier-ignore -->\";",
                    "  const fenceLength = Math.max(3, longestBacktickSequenceLength + 1);",
                    "  const fence = \"`\".repeat(fenceLength);",
                    "  return [prettierIgnoreComment, fence + (syntax || \"\"), content, fence].join(",
                    "    \"\\n\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = formatMarkdown;"
                ]
            },
            "panels.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import CodeMirror from \"codemirror\";",
                    "import * as React from \"react\";",
                    "",
                    "class CodeMirrorPanel extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this._textareaRef = React.createRef();",
                    "    this._codeMirror = null;",
                    "    this._cached = \"\";",
                    "    this._overlay = null;",
                    "    this.handleChange = this.handleChange.bind(this);",
                    "    this.handleFocus = this.handleFocus.bind(this);",
                    "    this.handleSelectionChange = this.handleSelectionChange.bind(this);",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    const options = { ...this.props };",
                    "    delete options.ruler;",
                    "    delete options.rulerColor;",
                    "    delete options.value;",
                    "    delete options.onChange;",
                    "    delete options.onFormat;",
                    "",
                    "    options.rulers = [makeRuler(this.props)];",
                    "",
                    "    if (options.foldGutter) {",
                    "      options.gutters = [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"];",
                    "    }",
                    "",
                    "    if (this.props.onFormat) {",
                    "      options.extraKeys = {",
                    "        \"Shift-Alt-F\": this.handleFormat.bind(this),",
                    "      };",
                    "    }",
                    "",
                    "    this._codeMirror = CodeMirror.fromTextArea(",
                    "      this._textareaRef.current,",
                    "      options",
                    "    );",
                    "    this._codeMirror.on(\"change\", this.handleChange);",
                    "    this._codeMirror.on(\"focus\", this.handleFocus);",
                    "    this._codeMirror.on(\"beforeSelectionChange\", this.handleSelectionChange);",
                    "",
                    "    window.CodeMirror.keyMap.pcSublime[\"Ctrl-L\"] = false;",
                    "    window.CodeMirror.keyMap.sublime[\"Ctrl-L\"] = false;",
                    "",
                    "    this.updateValue(this.props.value || \"\");",
                    "    this.updateOverlay();",
                    "  }",
                    "",
                    "  componentWillUnmount() {",
                    "    this._codeMirror && this._codeMirror.toTextArea();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    if (this.props.value !== this._cached) {",
                    "      this.updateValue(this.props.value);",
                    "    }",
                    "    if (",
                    "      this.props.overlayStart !== prevProps.overlayStart ||",
                    "      this.props.overlayEnd !== prevProps.overlayEnd",
                    "    ) {",
                    "      this.updateOverlay();",
                    "    }",
                    "    if (this.props.mode !== prevProps.mode) {",
                    "      this._codeMirror.setOption(\"mode\", this.props.mode);",
                    "    }",
                    "    if (this.props.ruler !== prevProps.ruler) {",
                    "      this._codeMirror.setOption(\"rulers\", [makeRuler(this.props)]);",
                    "    }",
                    "  }",
                    "",
                    "  updateValue(value) {",
                    "    this._cached = value;",
                    "    this._codeMirror.setValue(value);",
                    "",
                    "    if (this.props.autoFold instanceof RegExp) {",
                    "      const lines = value.split(\"\\n\");",
                    "      // going backwards to prevent unfolding folds created earlier",
                    "      for (let i = lines.length - 1; i >= 0; i--) {",
                    "        if (this.props.autoFold.test(lines[i])) {",
                    "          this._codeMirror.foldCode(i);",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  updateOverlay() {",
                    "    if (!this.props.readOnly) {",
                    "      if (this._overlay) {",
                    "        this._codeMirror.removeOverlay(this._overlay);",
                    "      }",
                    "      const [start, end] = getIndexPosition(this.props.value, [",
                    "        this.props.overlayStart,",
                    "        this.props.overlayEnd,",
                    "      ]);",
                    "      this._overlay = createOverlay(start, end);",
                    "      this._codeMirror.addOverlay(this._overlay);",
                    "    }",
                    "  }",
                    "",
                    "  handleFocus(/* codeMirror, event */) {",
                    "    if (this._codeMirror.getValue() === this.props.codeSample) {",
                    "      this._codeMirror.execCommand(\"selectAll\");",
                    "    }",
                    "  }",
                    "",
                    "  handleChange(doc, change) {",
                    "    if (change.origin !== \"setValue\") {",
                    "      this._cached = doc.getValue();",
                    "      this.props.onChange(this._cached);",
                    "      this.updateOverlay();",
                    "    }",
                    "  }",
                    "",
                    "  handleSelectionChange(doc, change) {",
                    "    if (this.props.onSelectionChange) {",
                    "      this.props.onSelectionChange(change.ranges[0]);",
                    "    }",
                    "  }",
                    "",
                    "  handleFormat() {",
                    "    const result = this.props.onFormat();",
                    "    if (!result) {",
                    "      return;",
                    "    }",
                    "    Promise.resolve(result).then(({ value, cursor }) => {",
                    "      this.props.onChange(value);",
                    "      this._codeMirror.setCursor(cursor);",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <div className=\"editor input\">",
                    "        <textarea ref={this._textareaRef} />",
                    "      </div>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function getIndexPosition(text, indexes) {",
                    "  indexes = [...indexes];",
                    "  let line = 0;",
                    "  let count = 0;",
                    "  let lineStart = 0;",
                    "  const result = [];",
                    "",
                    "  while (indexes.length > 0) {",
                    "    const index = indexes.shift();",
                    "",
                    "    while (count < index && count < text.length) {",
                    "      if (text[count] === \"\\n\") {",
                    "        line++;",
                    "        lineStart = count + 1;",
                    "      }",
                    "      count++;",
                    "    }",
                    "",
                    "    result.push({ line, pos: count - lineStart });",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function createOverlay(start, end) {",
                    "  return {",
                    "    token(stream) {",
                    "      const { line } = stream.lineOracle;",
                    "",
                    "      if (line < start.line || line > end.line) {",
                    "        stream.skipToEnd();",
                    "      } else if (line === start.line && stream.pos < start.pos) {",
                    "        stream.pos = start.pos;",
                    "      } else if (line === end.line) {",
                    "        if (stream.pos < end.pos) {",
                    "          stream.pos = end.pos;",
                    "          return \"searching\";",
                    "        }",
                    "        stream.skipToEnd();",
                    "      } else {",
                    "        stream.skipToEnd();",
                    "        return \"searching\";",
                    "      }",
                    "    },",
                    "  };",
                    "}",
                    "",
                    "function makeRuler(props) {",
                    "  return { column: props.ruler, color: props.rulerColor };",
                    "}",
                    "",
                    "export function InputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      lineNumbers={true}",
                    "      keyMap=\"sublime\"",
                    "      autoCloseBrackets={true}",
                    "      matchBrackets={true}",
                    "      showCursorWhenSelecting={true}",
                    "      tabSize={4}",
                    "      rulerColor=\"#eeeeee\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function OutputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={true}",
                    "      rulerColor=\"#444444\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function DebugPanel({ value, autoFold }) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={false}",
                    "      foldGutter={true}",
                    "      autoFold={autoFold}",
                    "      mode=\"jsx\"",
                    "      value={value}",
                    "    />",
                    "  );",
                    "}"
                ]
            },
            "storage.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function get(key) {",
                    "  try {",
                    "    return JSON.parse(window.localStorage.getItem(key));",
                    "  } catch {",
                    "    // noop",
                    "  }",
                    "}",
                    "",
                    "export function set(key, value) {",
                    "  try {",
                    "    window.localStorage.setItem(key, JSON.stringify(value));",
                    "  } catch {",
                    "    // noop",
                    "  }",
                    "}"
                ]
            },
            "urlHash.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import LZString from \"lz-string\";",
                    "",
                    "export function read() {",
                    "  const hash = document.location.hash.slice(1);",
                    "  if (!hash) {",
                    "    return {};",
                    "  }",
                    "",
                    "  // backwards support for old json encoded URIComponent",
                    "  const decode = hash.includes(\"%7B%22\")",
                    "    ? decodeURIComponent",
                    "    : LZString.decompressFromEncodedURIComponent;",
                    "",
                    "  try {",
                    "    return JSON.parse(decode(hash));",
                    "  } catch {",
                    "    return {};",
                    "  }",
                    "}",
                    "",
                    "export function replace(state) {",
                    "  const hash = LZString.compressToEncodedURIComponent(JSON.stringify(state));",
                    "  if (",
                    "    typeof URL === \"function\" &&",
                    "    typeof history === \"object\" &&",
                    "    typeof history.replaceState === \"function\"",
                    "  ) {",
                    "    const url = new URL(location);",
                    "    url.hash = hash;",
                    "    history.replaceState(null, null, url);",
                    "  } else {",
                    "    location.hash = hash;",
                    "  }",
                    "}"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function fixPrettierVersion(version) {",
                    "  const match = version.match(/^\\d+\\.\\d+\\.\\d+-pr.(\\d+)$/);",
                    "  if (match) {",
                    "    return `pr-${match[1]}`;",
                    "  }",
                    "  return version;",
                    "}",
                    "",
                    "export function getDefaults(availableOptions, optionNames) {",
                    "  const defaults = {};",
                    "  for (const option of availableOptions) {",
                    "    if (optionNames.includes(option.name)) {",
                    "      defaults[option.name] =",
                    "        option.name === \"parser\" ? \"babel\" : option.default;",
                    "    }",
                    "  }",
                    "  return defaults;",
                    "}",
                    "",
                    "export function buildCliArgs(availableOptions, options) {",
                    "  const args = [];",
                    "  for (const option of availableOptions) {",
                    "    const value = options[option.name];",
                    "",
                    "    if (typeof value === \"undefined\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (option.type === \"boolean\") {",
                    "      if ((value && !option.inverted) || (!value && option.inverted)) {",
                    "        args.push([option.cliName, true]);",
                    "      }",
                    "    } else if (value !== option.default || option.name === \"rangeStart\") {",
                    "      args.push([option.cliName, value]);",
                    "    }",
                    "  }",
                    "  return args;",
                    "}",
                    "",
                    "export function getCodemirrorMode(parser) {",
                    "  switch (parser) {",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return \"css\";",
                    "    case \"graphql\":",
                    "      return \"graphql\";",
                    "    case \"markdown\":",
                    "      return \"markdown\";",
                    "    default:",
                    "      return \"jsx\";",
                    "  }",
                    "}",
                    "",
                    "const astAutoFold = {",
                    "  estree:",
                    "    /^\\s*\"(loc|start|end|tokens|leadingComments|trailingComments|innerComments)\":/,",
                    "  postcss: /^\\s*\"(source|input|raws|file)\":/,",
                    "  html: /^\\s*\"(sourceSpan|valueSpan|nameSpan|startSourceSpan|endSourceSpan|tagDefinition)\":/,",
                    "  mdast: /^\\s*\"position\":/,",
                    "  yaml: /^\\s*\"position\":/,",
                    "  glimmer: /^\\s*\"loc\":/,",
                    "};",
                    "",
                    "export function getAstAutoFold(parser) {",
                    "  switch (parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      return astAutoFold.estree;",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return astAutoFold.postcss;",
                    "    case \"html\":",
                    "    case \"angular\":",
                    "    case \"vue\":",
                    "    case \"lwc\":",
                    "      return astAutoFold.html;",
                    "    case \"markdown\":",
                    "    case \"mdx\":",
                    "      return astAutoFold.mdast;",
                    "    case \"yaml\":",
                    "      return astAutoFold.yaml;",
                    "    case \"glimmer\":",
                    "      return astAutoFold.glimmer;",
                    "  }",
                    "}",
                    "",
                    "export function convertSelectionToRange({ head, anchor }, content) {",
                    "  const lines = content.split(\"\\n\");",
                    "  return [head, anchor]",
                    "    .map(",
                    "      ({ ch, line }) =>",
                    "        lines.slice(0, line).join(\"\\n\").length + ch + (line ? 1 : 0)",
                    "    )",
                    "    .sort((a, b) => a - b);",
                    "}",
                    "",
                    "export function convertOffsetToPosition(offset, content) {",
                    "  let line = 0;",
                    "  let ch = 0;",
                    "  for (let i = 0; i < offset && i <= content.length; i++) {",
                    "    if (content[i] === \"\\n\") {",
                    "      line++;",
                    "      ch = 0;",
                    "    } else {",
                    "      ch++;",
                    "    }",
                    "  }",
                    "  return { line, ch };",
                    "}",
                    "",
                    "/**",
                    " * Copied from https://github.com/prettier/prettier/blob/6fe21780115cf5f74f83876d64b03a727fbab220/src/cli/utils.js#L6-L27",
                    " * @template Obj",
                    " * @template Key",
                    " * @param {Array<Obj>} array",
                    " * @param {(value: Obj) => Key} iteratee",
                    " * @returns {{[p in Key]: T}}",
                    " */",
                    "export function groupBy(array, iteratee) {",
                    "  const result = Object.create(null);",
                    "",
                    "  for (const value of array) {",
                    "    const key = iteratee(value);",
                    "",
                    "    if (Array.isArray(result[key])) {",
                    "      result[key].push(value);",
                    "    } else {",
                    "      result[key] = [value];",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}"
                ]
            },
            "sidebar": {
                "SidebarOptions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "import { groupBy } from \"../util.js\";",
                        "",
                        "import { SidebarCategory } from \"./components.js\";",
                        "import Option from \"./options.js\";",
                        "",
                        "export default function SidebarOptions({",
                        "  categories,",
                        "  availableOptions,",
                        "  optionValues,",
                        "  onOptionValueChange,",
                        "}) {",
                        "  const options = groupBy(availableOptions, (option) => option.category);",
                        "  return categories.map((category) =>",
                        "    options[category] ? (",
                        "      <SidebarCategory key={category} title={category}>",
                        "        {options[category].map((option) => (",
                        "          <Option",
                        "            key={option.name}",
                        "            option={option}",
                        "            value={optionValues[option.name]}",
                        "            onChange={onOptionValueChange}",
                        "          />",
                        "        ))}",
                        "      </SidebarCategory>",
                        "    ) : null",
                        "  );",
                        "}"
                    ]
                },
                "components.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Sidebar({ visible, children }) {",
                        "  return (",
                        "    <div className={`options-container ${visible ? \"open\" : \"\"}`}>",
                        "      <div className=\"options\">{children}</div>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "export function SidebarCategory({ title, children }) {",
                        "  return (",
                        "    <details className=\"sub-options\" open=\"true\">",
                        "      <summary>{title}</summary>",
                        "      {children}",
                        "    </details>",
                        "  );",
                        "}"
                    ]
                },
                "inputs.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Checkbox({ label: _label, title, checked, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      <input",
                        "        type=\"checkbox\"",
                        "        checked={checked}",
                        "        onChange={(ev) => onChange(ev.target.checked)}",
                        "      />{\" \"}",
                        "      {_label}",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function Select({ label: _label, title, values, selected, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <select value={selected} onChange={(ev) => onChange(ev.target.value)}>",
                        "        {values.map((val) => (",
                        "          <option key={val} value={val}>",
                        "            {val}",
                        "          </option>",
                        "        ))}",
                        "      </select>",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function NumberInput({",
                        "  label: _label,",
                        "  title,",
                        "  value,",
                        "  min,",
                        "  max,",
                        "  step,",
                        "  onChange,",
                        "}) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <input",
                        "        type=\"number\"",
                        "        min={min}",
                        "        max={max}",
                        "        step={step}",
                        "        value={value}",
                        "        onChange={(ev) => onChange(Number.parseInt(ev.target.value, 10))}",
                        "      />",
                        "    </label>",
                        "  );",
                        "}"
                    ]
                },
                "options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "import { Checkbox, Select, NumberInput } from \"./inputs.js\";",
                        "",
                        "export function BooleanOption({ option, value, onChange }) {",
                        "  function maybeInvert(value) {",
                        "    return option.inverted ? !value : value;",
                        "  }",
                        "  return (",
                        "    <Checkbox",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      checked={maybeInvert(value)}",
                        "      onChange={(checked) => onChange(option, maybeInvert(checked))}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function ChoiceOption({ option, value, onChange }) {",
                        "  return (",
                        "    <Select",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      values={option.choices.map((choice) => choice.value)}",
                        "      selected={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function NumberOption({ option, value, onChange }) {",
                        "  return (",
                        "    <NumberInput",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      min={option.range.start}",
                        "      max={option.range.end}",
                        "      step={option.range.step}",
                        "      value={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export default function Option(props) {",
                        "  switch (props.option.type) {",
                        "    case \"boolean\":",
                        "      return <BooleanOption {...props} />;",
                        "    case \"int\":",
                        "      return <NumberOption {...props} />;",
                        "    case \"choice\":",
                        "      return <ChoiceOption {...props} />;",
                        "    default:",
                        "      throw new Error(\"unsupported type\");",
                        "  }",
                        "}",
                        "",
                        "function getDescription(option) {",
                        "  const description = option.inverted",
                        "    ? option.oppositeDescription",
                        "    : option.description;",
                        "  return description && description.replace(/\\n/g, \" \");",
                        "}"
                    ]
                }
            }
        },
        "static": {
            "_redirects": {},
            "icon.png": {},
            "install-service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "if (\"serviceWorker\" in navigator) {",
                    "  navigator.serviceWorker.register(\"/service-worker.js\", {",
                    "    scope: \"/playground/\",",
                    "  });",
                    "}"
                ]
            },
            "landing.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "if (location.hash.slice(1).startsWith(encodeURIComponent(\"{\"))) {",
                    "  location.pathname = \"/playground/\";",
                    "}",
                    "",
                    "window.addEventListener(\"load\", () => {",
                    "  // We don't have access to a unique body css attribute for just the homepage",
                    "  // so instead it is set on load. It's only really visible on a vertical overscroll",
                    "  document.body.style.backgroundColor = \"rgb(24, 32, 37)\";",
                    "",
                    "  const logoWrapper = document.querySelector(\".animatedLogoWrapper\");",
                    "  const logo = document.querySelector(\".prettier-logo-wide\");",
                    "  const lastDash = logo.querySelector(\"g:last-of-type path:last-of-type\");",
                    "",
                    "  function handleLogoDrag(event) {",
                    "    logo.classList.add(\"rolling\");",
                    "    event.preventDefault();",
                    "  }",
                    "",
                    "  logoWrapper.setAttribute(\"draggable\", \"true\");",
                    "  logoWrapper.addEventListener(\"touchstart\", handleLogoDrag);",
                    "  logoWrapper.addEventListener(\"dragstart\", handleLogoDrag);",
                    "",
                    "  lastDash.addEventListener(\"animationend\", (event) => {",
                    "    if (/roll/.test(event.animationName)) {",
                    "      logo.classList.remove(\"rolling\");",
                    "    }",
                    "  });",
                    "});"
                ]
            },
            "manifest.json": {},
            "overrides.css": {},
            "prettier-centered-logo-static.svg": {},
            "prettier.png": {},
            "service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* global toolbox parsersLocation */",
                    "",
                    "\"use strict\";",
                    "",
                    "importScripts(\"lib/parsers-location.js\");",
                    "importScripts(\"https://unpkg.com/sw-toolbox@3.6.0/sw-toolbox.js\");",
                    "",
                    "const parsers = Object.keys(parsersLocation).map((file) => `lib/${file}`);",
                    "",
                    "toolbox.precache([",
                    "  // Scripts",
                    "  \"lib/standalone.js\",",
                    "  \"lib/parsers-location.js\",",
                    "  ...parsers,",
                    "  \"playground.js\",",
                    "  \"https://unpkg.com/sw-toolbox@3.6.0/sw-toolbox.js\",",
                    "",
                    "  // CodeMirror; keep this in sync with website/pages/playground/index.html",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/codemirror.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/fold/foldgutter.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/codemirror.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/javascript/javascript.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/xml/xml.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/jsx/jsx.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/css/css.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/markdown/markdown.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/display/placeholder.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/display/rulers.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/search/searchcursor.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/edit/matchbrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/edit/closebrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/comment/comment.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/wrap/hardwrap.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/fold/foldcode.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/fold/foldgutter.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/fold/brace-fold.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/keymap/sublime.min.js\",",
                    "",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react/17.0.1/umd/react.production.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.1/umd/react-dom.production.min.js\",",
                    "",
                    "  // Images",
                    "  \"/prettier.png\",",
                    "]);",
                    "",
                    "// Default to hit the cache only if there's a network error",
                    "toolbox.router.default = toolbox.networkFirst;",
                    "",
                    "// For scripts, stylesheets and images, we can use the \"fastest\" strategy",
                    "// This means you need to reload twice to get new changes",
                    "toolbox.router.get(/\\.(js|css|png|svg)$/, toolbox.fastest);"
                ]
            },
            "worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* globals prettier prettierPlugins parsersLocation */",
                    "",
                    "\"use strict\";",
                    "",
                    "const imported = Object.create(null);",
                    "function importScriptOnce(url) {",
                    "  if (!imported[url]) {",
                    "    imported[url] = true;",
                    "    importScripts(url);",
                    "  }",
                    "}",
                    "",
                    "importScripts(\"lib/parsers-location.js\");",
                    "importScripts(\"lib/standalone.js\");",
                    "",
                    "// this is required to only load parsers when we need them",
                    "const parsers = Object.create(null);",
                    "for (const file in parsersLocation) {",
                    "  const { parsers: moduleParsers, property } = parsersLocation[file];",
                    "  const url = `lib/${file}`;",
                    "  for (const parserName of moduleParsers) {",
                    "    Object.defineProperty(parsers, parserName, {",
                    "      get() {",
                    "        importScriptOnce(url);",
                    "        return prettierPlugins[property].parsers[parserName];",
                    "      },",
                    "    });",
                    "  }",
                    "}",
                    "",
                    "const docExplorerPlugin = {",
                    "  parsers: {",
                    "    \"doc-explorer\": {",
                    "      parse: (text) =>",
                    "        new Function(",
                    "          `{ ${Object.keys(prettier.doc.builders)} }`,",
                    "          `const result = (${text || \"''\"}\\n); return result;`",
                    "        )(prettier.doc.builders),",
                    "      astFormat: \"doc-explorer\",",
                    "    },",
                    "  },",
                    "  printers: {",
                    "    \"doc-explorer\": {",
                    "      print: (path) => path.getValue(),",
                    "    },",
                    "  },",
                    "  languages: [{ name: \"doc-explorer\", parsers: [\"doc-explorer\"] }],",
                    "};",
                    "",
                    "self.onmessage = function (event) {",
                    "  self.postMessage({",
                    "    uid: event.data.uid,",
                    "    message: handleMessage(event.data.message),",
                    "  });",
                    "};",
                    "",
                    "function serializeAst(ast) {",
                    "  return JSON.stringify(",
                    "    ast,",
                    "    (_, value) =>",
                    "      value instanceof Error",
                    "        ? { name: value.name, message: value.message, ...value }",
                    "        : typeof value === \"bigint\"",
                    "        ? `BigInt('${String(value)}')`",
                    "        : typeof value === \"symbol\"",
                    "        ? String(value)",
                    "        : value,",
                    "    2",
                    "  );",
                    "}",
                    "",
                    "function handleMessage(message) {",
                    "  switch (message.type) {",
                    "    case \"meta\":",
                    "      return handleMetaMessage();",
                    "    case \"format\":",
                    "      return handleFormatMessage(message);",
                    "  }",
                    "}",
                    "",
                    "function handleMetaMessage() {",
                    "  return {",
                    "    type: \"meta\",",
                    "    supportInfo: JSON.parse(",
                    "      JSON.stringify(",
                    "        prettier.getSupportInfo({",
                    "          showUnreleased: true,",
                    "          plugins: [docExplorerPlugin],",
                    "        })",
                    "      )",
                    "    ),",
                    "    version: prettier.version,",
                    "  };",
                    "}",
                    "",
                    "function handleFormatMessage(message) {",
                    "  const plugins = [{ parsers }, docExplorerPlugin];",
                    "  const options = { ...message.options, plugins };",
                    "",
                    "  delete options.ast;",
                    "  delete options.doc;",
                    "  delete options.output2;",
                    "",
                    "  const formatResult = formatCode(",
                    "    message.code,",
                    "    options,",
                    "    message.debug.rethrowEmbedErrors",
                    "  );",
                    "",
                    "  const response = {",
                    "    formatted: formatResult.formatted,",
                    "    cursorOffset: formatResult.cursorOffset,",
                    "    error: formatResult.error,",
                    "    debug: {",
                    "      ast: null,",
                    "      doc: null,",
                    "      comments: null,",
                    "      reformatted: null,",
                    "    },",
                    "  };",
                    "",
                    "  if (message.debug.ast) {",
                    "    let ast;",
                    "    let errored = false;",
                    "    try {",
                    "      ast = serializeAst(prettier.__debug.parse(message.code, options).ast);",
                    "    } catch (e) {",
                    "      errored = true;",
                    "      ast = String(e);",
                    "    }",
                    "",
                    "    if (!errored) {",
                    "      try {",
                    "        ast = formatCode(ast, { parser: \"json\", plugins }).formatted;",
                    "      } catch {",
                    "        ast = serializeAst(ast);",
                    "      }",
                    "    }",
                    "    response.debug.ast = ast;",
                    "  }",
                    "",
                    "  if (message.debug.doc) {",
                    "    try {",
                    "      response.debug.doc = prettier.__debug.formatDoc(",
                    "        prettier.__debug.printToDoc(message.code, options),",
                    "        { plugins }",
                    "      );",
                    "    } catch {",
                    "      response.debug.doc = \"\";",
                    "    }",
                    "  }",
                    "",
                    "  if (message.debug.comments) {",
                    "    response.debug.comments = formatCode(",
                    "      JSON.stringify(formatResult.comments || []),",
                    "      { parser: \"json\", plugins }",
                    "    ).formatted;",
                    "  }",
                    "",
                    "  if (message.debug.reformat) {",
                    "    response.debug.reformatted = formatCode(",
                    "      response.formatted,",
                    "      options",
                    "    ).formatted;",
                    "  }",
                    "",
                    "  return response;",
                    "}",
                    "",
                    "function formatCode(text, options, rethrowEmbedErrors) {",
                    "  try {",
                    "    self.PRETTIER_DEBUG = rethrowEmbedErrors;",
                    "    return prettier.formatWithCursor(text, options);",
                    "  } catch (e) {",
                    "    if (e.constructor && e.constructor.name === \"SyntaxError\") {",
                    "      // Likely something wrong with the user's code",
                    "      return { formatted: String(e), error: true };",
                    "    }",
                    "    // Likely a bug in Prettier",
                    "    // Provide the whole stack for debugging",
                    "    return { formatted: stringifyError(e), error: true };",
                    "  } finally {",
                    "    self.PRETTIER_DEBUG = undefined;",
                    "  }",
                    "}",
                    "",
                    "function stringifyError(e) {",
                    "  const stringified = String(e);",
                    "  if (typeof e.stack !== \"string\") {",
                    "    return stringified;",
                    "  }",
                    "  if (e.stack.includes(stringified)) {",
                    "    // Chrome",
                    "    return e.stack;",
                    "  }",
                    "  // Firefox",
                    "  return stringified + \"\\n\" + e.stack;",
                    "}"
                ]
            },
            "css": {
                "code-block-buttons.css": {}
            },
            "images": {
                "get_started_rects.svg": {},
                "github.svg": {},
                "github_grey.svg": {},
                "npm.svg": {},
                "npm_grey.svg": {},
                "state_of_js_grey.svg": {},
                "tidelift-small.png": {},
                "editors": {
                    "atom-128px.png": {},
                    "editor_atom.svg": {},
                    "editor_emacs.svg": {},
                    "editor_espresso.svg": {},
                    "editor_nova.svg": {},
                    "editor_sublime.svg": {},
                    "editor_vim.svg": {},
                    "editor_vs.svg": {},
                    "editor_vscode.svg": {},
                    "editor_webstorm.svg": {},
                    "emacs-128px.png": {},
                    "espresso-128px.png": {},
                    "sublimetext-128px.png": {},
                    "vim-128px.png": {},
                    "visualstudio-128px.png": {},
                    "vscode-128px.png": {},
                    "webstorm-128px.png": {}
                },
                "languages": {
                    "css-128px.png": {},
                    "css_small_grey.svg": {},
                    "graphql-128px.png": {},
                    "graphql_small_grey.svg": {},
                    "js-128px.png": {},
                    "js_small_grey.svg": {},
                    "markdown-128px.png": {},
                    "markdown_small_grey.svg": {},
                    "python_small_grey.svg": {},
                    "swift_small_grey.svg": {},
                    "tools_css.svg": {},
                    "tools_gql.svg": {},
                    "tools_html.svg": {},
                    "tools_js.svg": {},
                    "tools_md.svg": {},
                    "tools_wip.svg": {},
                    "tools_yaml.svg": {}
                },
                "users": {
                    "3yourmind.svg": {},
                    "aircall.svg": {},
                    "algolia-200x100.png": {},
                    "assertible-200x100.png": {},
                    "babel-200x100.png": {},
                    "brigad-200x100.png": {},
                    "buildcom.svg": {},
                    "campusjaeger.svg": {},
                    "charlietango-200x100.png": {},
                    "chillicream.svg": {},
                    "codecarrot.svg": {},
                    "codemix-200x100.png": {},
                    "computerbase.svg": {},
                    "contiamo-200x100.png": {},
                    "danger-200x100.png": {},
                    "dev-it-jobs-200-100.jpg": {},
                    "discord-200x100.png": {},
                    "drizly-200x100.png": {},
                    "dropbox.svg": {},
                    "dropbox_grey.svg": {},
                    "escrow-200x100.png": {},
                    "estalee.svg": {},
                    "eventstag-200x100.png": {},
                    "exponea.svg": {},
                    "eyesquare-200x100.png": {},
                    "facebook-200x100.png": {},
                    "freelancer-200x100.png": {},
                    "getonboard-200x100.png": {},
                    "gumgum-200x100.png": {},
                    "hackclub-200x100.png": {},
                    "hasura-200x100.png": {},
                    "hearthsim-200x100.png": {},
                    "heroku.svg": {},
                    "holidaycheck-200x100.png": {},
                    "housinganywhere.svg": {},
                    "hudl-200x100.png": {},
                    "icons8.svg": {},
                    "ideati-200x100.png": {},
                    "iress-200x100.png": {},
                    "jane-200x100.png": {},
                    "jest-200x100.png": {},
                    "leesa.svg": {},
                    "lifesum-200x100.png": {},
                    "loyaltylion-200x100.png": {},
                    "m6web-200x100.png": {},
                    "materialui-200x100.png": {},
                    "mathrioshka-200x100.png": {},
                    "metric-ai-white.svg": {},
                    "monei-200x100.png": {},
                    "mongodb-200x100.png": {},
                    "moonmail-200x100.png": {},
                    "n26-200x100.png": {},
                    "nhl-200x100.png": {},
                    "nrwl-200x100.png": {},
                    "openbravo-200x100.png": {},
                    "outreach-200x100.png": {},
                    "paypal-200x100.png": {},
                    "quip.svg": {},
                    "react-200x100.png": {},
                    "researchanddesign.svg": {},
                    "rnfirebase-200x100.png": {},
                    "salesforce.svg": {},
                    "sevenspan-200x100.png": {},
                    "shelf-200x100.png": {},
                    "smooth-code-200x100.png": {},
                    "storybook-200x100.png": {},
                    "swissdev-devops-jobs-200-100.png": {},
                    "talkable-200x100.png": {},
                    "toptal.png": {},
                    "tradeshift-200x100.png": {},
                    "tradie-training.png": {},
                    "transloadit-200x100.png": {},
                    "troops-200x100.png": {},
                    "used_by_babel.svg": {},
                    "used_by_danger.svg": {},
                    "used_by_facebook.svg": {},
                    "used_by_jest.svg": {},
                    "used_by_react.svg": {},
                    "used_by_spotify.svg": {},
                    "used_by_storybook.svg": {},
                    "used_by_webpack.svg": {},
                    "used_by_yarn.svg": {},
                    "used_by_zeit.svg": {},
                    "vercel-logotype-dark.svg": {},
                    "webflow-200x100.png": {},
                    "webpack-200x100.png": {},
                    "wingify-200x100.png": {},
                    "wire-200x100.png": {},
                    "yarn-200x100.png": {},
                    "yelp-200x100.png": {},
                    "zipch-200x100.png": {}
                }
            },
            "js": {
                "code-block-buttons.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/* global ClipboardJS */",
                        "",
                        "\"use strict\";",
                        "",
                        "(function () {",
                        "  const CONTAINER_CLASS_NAME = \"code-block-with-actions\";",
                        "  const ACTIONS_CONTAINER_CLASS_NAME = \"code-block-actions\";",
                        "  const COPY_BUTTON_CLASS_NAME = \"code-block-copy-button\";",
                        "  const COPY_BUTTON_COPIED_CLASS_NAME = `${COPY_BUTTON_CLASS_NAME}--copied`;",
                        "  const COPY_BUTTON_ICON_CLASS_NAME = `${COPY_BUTTON_CLASS_NAME}__icon`;",
                        "  const COPY_BUTTON_COPY_ICON_CLASS_NAME = `${COPY_BUTTON_ICON_CLASS_NAME}--copy`;",
                        "  const COPY_BUTTON_COPIED_ICON_CLASS_NAME = `${COPY_BUTTON_ICON_CLASS_NAME}--copied`;",
                        "  const ARIA_LABEL = \"Copy code to clipboard\";",
                        "  const ARIA_LABEL_COPIED = \"Copied\";",
                        "",
                        "  function init(codeBlock) {",
                        "    const container = codeBlock.parentNode;",
                        "    container.classList.add(CONTAINER_CLASS_NAME);",
                        "",
                        "    const actionsContainer = Object.assign(document.createElement(\"div\"), {",
                        "      className: ACTIONS_CONTAINER_CLASS_NAME,",
                        "    });",
                        "    const copyButton = Object.assign(document.createElement(\"button\"), {",
                        "      className: COPY_BUTTON_CLASS_NAME,",
                        "      type: \"button\",",
                        "      innerHTML:",
                        "        `<svg class=\"${COPY_BUTTON_ICON_CLASS_NAME} ${COPY_BUTTON_COPY_ICON_CLASS_NAME}\" viewBox=\"0 0 24 24\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg>` +",
                        "        `<svg class=\"${COPY_BUTTON_ICON_CLASS_NAME} ${COPY_BUTTON_COPIED_ICON_CLASS_NAME}\" viewBox=\"0 0 24 24\"><path d=\"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z\"></path></svg>`,",
                        "    });",
                        "    copyButton.setAttribute(\"aria-label\", ARIA_LABEL);",
                        "",
                        "    new ClipboardJS(copyButton, { target: () => codeBlock }).on(",
                        "      \"success\",",
                        "      (event) => {",
                        "        event.clearSelection();",
                        "        copyButton.classList.add(COPY_BUTTON_COPIED_CLASS_NAME);",
                        "        copyButton.setAttribute(\"aria-label\", ARIA_LABEL_COPIED);",
                        "        copyButton.disabled = true;",
                        "",
                        "        setTimeout(() => {",
                        "          copyButton.classList.remove(COPY_BUTTON_COPIED_CLASS_NAME);",
                        "          copyButton.setAttribute(\"aria-label\", ARIA_LABEL);",
                        "          copyButton.disabled = false;",
                        "        }, 2000);",
                        "      }",
                        "    );",
                        "",
                        "    actionsContainer.appendChild(copyButton);",
                        "    container.appendChild(actionsContainer);",
                        "  }",
                        "",
                        "  window.addEventListener(\"load\", () => {",
                        "    for (const codeBlock of document.querySelectorAll(\"pre > code.hljs\")) {",
                        "      init(codeBlock);",
                        "    }",
                        "  });",
                        "})();"
                    ]
                }
            },
            "separate-css": {
                "playground.css": {}
            }
        },
        "versioned_docs": {
            "version-stable": {
                "api.md": {},
                "browser.md": {},
                "cli.md": {},
                "comparison.md": {},
                "configuration.md": {},
                "editors.md": {},
                "for-enterprise.md": {},
                "ignore.md": {},
                "index.md": {},
                "install.md": {},
                "integrating-with-linters.md": {},
                "option-philosophy.md": {},
                "options.md": {},
                "plugins.md": {},
                "precommit.md": {},
                "rationale.md": {},
                "related-projects.md": {},
                "technical-details.md": {},
                "vim.md": {},
                "watching-files.md": {},
                "webstorm.md": {},
                "why-prettier.md": {}
            }
        },
        "versioned_sidebars": {
            "version-stable-sidebars.json": {}
        }
    }
}