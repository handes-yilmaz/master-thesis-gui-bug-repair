{
    "1": {
        "bug_file": "src/language-js/printer-estree.js",
        "compressed": "YES",
        "line_numbers": 845,
        "compressed_line_numbers": 76,
        "compressed_bug_file_content": "\n\n/** @typedef {import(\"../document\").Doc} Doc */\n\n// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\n  // Their decorators are handled themselves, and they can't have parentheses\n\n\n  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons\n\n\n    // In member-chain print, it add `label` to the doc, if we return array here it will be broken\n\n\n  /** @type{Doc[]} */\n\n\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n\n\n    // Babel extension.\n\n\n        /** sameIndent */ true,\n\n\n      // Do not append semicolon after the only JSX element in a program\n\n\n    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\n\n\n    // Babel 6\n\n\n        // For ExpressionStatements and for-loop heads, which are among\n        // the few places a SequenceExpression appears unparenthesized, we want\n        // to indent expressions after the first.\n\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n\n\n        // Indent first var to comply with eslint one-var rule\n\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n\n\n        /* sameLine */ true\n\n\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n\n    // JSX extensions below.\n\n\n    // For hack-style pipeline\n\n\n      /* istanbul ignore next */\n\n\n    // `babel-ts` don't have similar node for `class Foo { bar() /* bat */; }`\n\n\n    // TODO: Make this as default behavior\n\n\n"
    },
    "2": {
        "bug_file": "src/language-js/parse/babel.js",
        "compressed": "NO",
        "line_numbers": 260,
        "compressed_line_numbers": 260,
        "compressed_bug_file_content": "\"use strict\";\n\nconst tryCombinations = require(\"../../utils/try-combinations.js\");\nconst getShebang = require(\"../utils/get-shebang.js\");\nconst getNextNonSpaceNonCommentCharacterIndexWithStartIndex = require(\"../../utils/text/get-next-non-space-non-comment-character-index-with-start-index.js\");\nconst createParser = require(\"./utils/create-parser.js\");\nconst createBabelParseError = require(\"./utils/create-babel-parse-error.js\");\nconst postprocess = require(\"./postprocess/index.js\");\nconst jsonParsers = require(\"./json.js\");\n\n/**\n * @typedef {import(\"@babel/parser\").parse | import(\"@babel/parser\").parseExpression} Parse\n * @typedef {import(\"@babel/parser\").ParserOptions} ParserOptions\n * @typedef {import(\"@babel/parser\").ParserPlugin} ParserPlugin\n */\n\n/** @type {ParserOptions} */\nconst parseOptions = {\n  sourceType: \"module\",\n  allowImportExportEverywhere: true,\n  allowReturnOutsideFunction: true,\n  allowSuperOutsideMethod: true,\n  allowUndeclaredExports: true,\n  errorRecovery: true,\n  createParenthesizedExpressions: true,\n  plugins: [\n    // When adding a plugin, please add a test in `tests/format/js/babel-plugins`,\n    // To remove plugins, remove it here and run `yarn test tests/format/js/babel-plugins` to verify\n    \"doExpressions\",\n    \"exportDefaultFrom\",\n    \"functionBind\",\n    \"functionSent\",\n    \"throwExpressions\",\n    \"partialApplication\",\n    [\"decorators\", { decoratorsBeforeExport: false }],\n    \"importAssertions\",\n    \"decimal\",\n    \"moduleBlocks\",\n    \"asyncDoExpressions\",\n    \"regexpUnicodeSets\",\n    \"destructuringPrivate\",\n    \"decoratorAutoAccessors\",\n  ],\n  tokens: true,\n  ranges: true,\n};\n\n/** @type {ParserPlugin} */\nconst recordAndTuplePlugin = [\"recordAndTuple\", { syntaxType: \"hash\" }];\n\n/** @type {ParserPlugin} */\nconst v8intrinsicPlugin = \"v8intrinsic\";\n\n/** @type {Array<ParserPlugin>} */\nconst pipelineOperatorPlugins = [\n  [\"pipelineOperator\", { proposal: \"hack\", topicToken: \"%\" }],\n  [\"pipelineOperator\", { proposal: \"minimal\" }],\n  [\"pipelineOperator\", { proposal: \"fsharp\" }],\n];\nconst appendPlugins = (plugins, options = parseOptions) => ({\n  ...options,\n  plugins: [...options.plugins, ...plugins],\n});\n\n// Similar to babel\n// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67\nconst FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;\nfunction isFlowFile(text, options) {\n  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {\n    return true;\n  }\n\n  const shebang = getShebang(text);\n  if (shebang) {\n    text = text.slice(shebang.length);\n  }\n\n  const firstNonSpaceNonCommentCharacterIndex =\n    getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, 0);\n\n  if (firstNonSpaceNonCommentCharacterIndex !== false) {\n    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);\n  }\n\n  return FLOW_PRAGMA_REGEX.test(text);\n}\n\nfunction parseWithOptions(parseMethod, text, options) {\n  // Inline the require to avoid loading all the JS if we don't use it\n  /** @type {Parse} */\n  const parse = require(\"@babel/parser\")[parseMethod];\n  const ast = parse(text, options);\n  const error = ast.errors.find(\n    (error) => !allowedMessageCodes.has(error.reasonCode)\n  );\n  if (error) {\n    throw error;\n  }\n  return ast;\n}\n\nfunction createParse(parseMethod, ...optionsCombinations) {\n  return (text, parsers, opts = {}) => {\n    if (\n      (opts.parser === \"babel\" || opts.parser === \"__babel_estree\") &&\n      isFlowFile(text, opts)\n    ) {\n      opts.parser = \"babel-flow\";\n      return parseFlow(text, parsers, opts);\n    }\n\n    let combinations = optionsCombinations;\n    if (opts.__babelSourceType === \"script\") {\n      combinations = combinations.map((options) => ({\n        ...options,\n        sourceType: \"script\",\n      }));\n    }\n\n    if (/#[[{]/.test(text)) {\n      combinations = combinations.map((options) =>\n        appendPlugins([recordAndTuplePlugin], options)\n      );\n    }\n\n    const shouldEnableV8intrinsicPlugin = /%[A-Z]/.test(text);\n    if (text.includes(\"|>\")) {\n      const conflictsPlugins = shouldEnableV8intrinsicPlugin\n        ? [...pipelineOperatorPlugins, v8intrinsicPlugin]\n        : pipelineOperatorPlugins;\n      combinations = conflictsPlugins.flatMap((pipelineOperatorPlugin) =>\n        combinations.map((options) =>\n          appendPlugins([pipelineOperatorPlugin], options)\n        )\n      );\n    } else if (shouldEnableV8intrinsicPlugin) {\n      combinations = combinations.map((options) =>\n        appendPlugins([v8intrinsicPlugin], options)\n      );\n    }\n\n    const { result: ast, error } = tryCombinations(\n      ...combinations.map(\n        (options) => () => parseWithOptions(parseMethod, text, options)\n      )\n    );\n\n    if (!ast) {\n      throw createBabelParseError(error);\n    }\n\n    opts.originalText = text;\n    return postprocess(ast, opts);\n  };\n}\n\nconst parse = createParse(\"parse\", appendPlugins([\"jsx\", \"flow\"]));\nconst parseFlow = createParse(\n  \"parse\",\n  appendPlugins([\"jsx\", [\"flow\", { all: true, enums: true }]])\n);\nconst parseTypeScript = createParse(\n  \"parse\",\n  appendPlugins([\"jsx\", \"typescript\"]),\n  appendPlugins([\"typescript\"])\n);\nconst parseEstree = createParse(\n  \"parse\",\n  appendPlugins([\"jsx\", \"flow\", \"estree\"])\n);\nconst parseExpression = createParse(\"parseExpression\", appendPlugins([\"jsx\"]));\n\nconst parseTSExpression = createParse(\n  \"parseExpression\",\n  appendPlugins([\"typescript\"])\n);\n\n// Error codes are defined in\n//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/parser/error-message.js\n//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/typescript/index.js#L69-L153\n//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/flow/index.js#L51-L140\n//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/jsx/index.js#L23-L39\nconst allowedMessageCodes = new Set([\n  \"StrictNumericEscape\",\n  \"StrictWith\",\n  \"StrictOctalLiteral\",\n  \"StrictDelete\",\n  \"StrictEvalArguments\",\n  \"StrictEvalArgumentsBinding\",\n  \"StrictFunction\",\n\n  \"EmptyTypeArguments\",\n  \"EmptyTypeParameters\",\n  \"ConstructorHasTypeParameters\",\n\n  \"UnsupportedParameterPropertyKind\",\n  \"UnexpectedParameterModifier\",\n\n  \"MixedLabeledAndUnlabeledElements\",\n  \"InvalidTupleMemberLabel\",\n\n  \"NonClassMethodPropertyHasAbstractModifer\",\n  \"ReadonlyForMethodSignature\",\n  \"ClassMethodHasDeclare\",\n  \"ClassMethodHasReadonly\",\n  \"InvalidModifierOnTypeMember\",\n  \"DuplicateAccessibilityModifier\",\n  \"IndexSignatureHasDeclare\",\n\n  \"DecoratorExportClass\",\n  \"ParamDupe\",\n  \"InvalidDecimal\",\n  \"RestTrailingComma\",\n  \"UnsupportedParameterDecorator\",\n  \"UnterminatedJsxContent\",\n  \"UnexpectedReservedWord\",\n  \"ModuleAttributesWithDuplicateKeys\",\n  \"LineTerminatorBeforeArrow\",\n  \"InvalidEscapeSequenceTemplate\",\n  \"NonAbstractClassHasAbstractMethod\",\n  \"UnsupportedPropertyDecorator\",\n  \"OptionalTypeBeforeRequired\",\n  \"PatternIsOptional\",\n  \"OptionalBindingPattern\",\n  \"DeclareClassFieldHasInitializer\",\n  \"TypeImportCannotSpecifyDefaultAndNamed\",\n  \"DeclareFunctionHasImplementation\",\n  \"ConstructorClassField\",\n\n  \"VarRedeclaration\",\n  \"InvalidPrivateFieldResolution\",\n  \"DuplicateExport\",\n]);\n\nconst babel = createParser(parse);\nconst babelTs = createParser(parseTypeScript);\nconst babelExpression = createParser(parseExpression);\nconst babelTSExpression = createParser(parseTSExpression);\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    babel,\n    \"babel-flow\": createParser(parseFlow),\n    \"babel-ts\": babelTs,\n    ...jsonParsers,\n    /** @internal */\n    __js_expression: babelExpression,\n    /** for vue filter */\n    __vue_expression: babelExpression,\n    /** for vue filter written in TS */\n    __vue_ts_expression: babelTSExpression,\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel,\n    /** for vue event binding written in TS to handle semicolon */\n    __vue_ts_event_binding: babelTs,\n    /** verify that we can print this AST */\n    __babel_estree: createParser(parseEstree),\n  },\n};"
    },
    "3": {
        "bug_file": "src/language-js/print/object.js",
        "compressed": "NO",
        "line_numbers": 246,
        "compressed_line_numbers": 246,
        "compressed_bug_file_content": "\"use strict\";\n\nconst { printDanglingComments } = require(\"../../main/comments.js\");\nconst {\n  builders: { line, softline, group, indent, ifBreak, hardline },\n} = require(\"../../document/index.js\");\nconst {\n  getLast,\n  hasNewlineInRange,\n  hasNewline,\n  isNonEmptyArray,\n} = require(\"../../common/util.js\");\nconst {\n  shouldPrintComma,\n  hasComment,\n  getComments,\n  CommentCheckFlags,\n  isNextLineEmpty,\n} = require(\"../utils/index.js\");\nconst { locStart, locEnd } = require(\"../loc.js\");\n\nconst { printOptionalToken, printTypeAnnotation } = require(\"./misc.js\");\nconst { shouldHugFunctionParameters } = require(\"./function-parameters.js\");\nconst { shouldHugType } = require(\"./type-annotation.js\");\nconst { printHardlineAfterHeritage } = require(\"./class.js\");\n\n/** @typedef {import(\"../../document\").Doc} Doc */\n\nfunction printObject(path, options, print) {\n  const semi = options.semi ? \";\" : \"\";\n  const node = path.getValue();\n\n  let propertiesField;\n\n  if (node.type === \"TSTypeLiteral\") {\n    propertiesField = \"members\";\n  } else if (node.type === \"TSInterfaceBody\") {\n    propertiesField = \"body\";\n  } else {\n    propertiesField = \"properties\";\n  }\n\n  const isTypeAnnotation = node.type === \"ObjectTypeAnnotation\";\n  const fields = [propertiesField];\n  if (isTypeAnnotation) {\n    fields.push(\"indexers\", \"callProperties\", \"internalSlots\");\n  }\n\n  const firstProperty = fields\n    .map((field) => node[field][0])\n    .sort((a, b) => locStart(a) - locStart(b))[0];\n\n  const parent = path.getParentNode(0);\n  const isFlowInterfaceLikeBody =\n    isTypeAnnotation &&\n    parent &&\n    (parent.type === \"InterfaceDeclaration\" ||\n      parent.type === \"DeclareInterface\" ||\n      parent.type === \"DeclareClass\") &&\n    path.getName() === \"body\";\n  const shouldBreak =\n    node.type === \"TSInterfaceBody\" ||\n    isFlowInterfaceLikeBody ||\n    (node.type === \"ObjectPattern\" &&\n      parent.type !== \"FunctionDeclaration\" &&\n      parent.type !== \"FunctionExpression\" &&\n      parent.type !== \"ArrowFunctionExpression\" &&\n      parent.type !== \"ObjectMethod\" &&\n      parent.type !== \"ClassMethod\" &&\n      parent.type !== \"ClassPrivateMethod\" &&\n      parent.type !== \"AssignmentPattern\" &&\n      parent.type !== \"CatchClause\" &&\n      node.properties.some(\n        (property) =>\n          property.value &&\n          (property.value.type === \"ObjectPattern\" ||\n            property.value.type === \"ArrayPattern\")\n      )) ||\n    (node.type !== \"ObjectPattern\" &&\n      firstProperty &&\n      hasNewlineInRange(\n        options.originalText,\n        locStart(node),\n        locStart(firstProperty)\n      ));\n\n  const separator = isFlowInterfaceLikeBody\n    ? \";\"\n    : node.type === \"TSInterfaceBody\" || node.type === \"TSTypeLiteral\"\n    ? ifBreak(semi, \";\")\n    : \",\";\n  const leftBrace =\n    node.type === \"RecordExpression\" ? \"#{\" : node.exact ? \"{|\" : \"{\";\n  const rightBrace = node.exact ? \"|}\" : \"}\";\n\n  // Unfortunately, things are grouped together in the ast can be\n  // interleaved in the source code. So we need to reorder them before\n  // printing them.\n  const propsAndLoc = [];\n  for (const field of fields) {\n    path.each((childPath) => {\n      const node = childPath.getValue();\n      propsAndLoc.push({\n        node,\n        printed: print(),\n        loc: locStart(node),\n      });\n    }, field);\n  }\n\n  if (fields.length > 1) {\n    propsAndLoc.sort((a, b) => a.loc - b.loc);\n  }\n\n  /** @type {Doc[]} */\n  let separatorParts = [];\n  const props = propsAndLoc.map((prop) => {\n    const result = [...separatorParts, group(prop.printed)];\n    separatorParts = [separator, line];\n    if (\n      (prop.node.type === \"TSPropertySignature\" ||\n        prop.node.type === \"TSMethodSignature\" ||\n        prop.node.type === \"TSConstructSignatureDeclaration\") &&\n      hasComment(prop.node, CommentCheckFlags.PrettierIgnore)\n    ) {\n      separatorParts.shift();\n    }\n    if (isNextLineEmpty(prop.node, options)) {\n      separatorParts.push(hardline);\n    }\n    return result;\n  });\n\n  if (node.inexact) {\n    let printed;\n    if (hasComment(node, CommentCheckFlags.Dangling)) {\n      const hasLineComments = hasComment(node, CommentCheckFlags.Line);\n      const printedDanglingComments = printDanglingComments(\n        path,\n        options,\n        /* sameIndent */ true\n      );\n      printed = [\n        printedDanglingComments,\n        hasLineComments ||\n        hasNewline(options.originalText, locEnd(getLast(getComments(node))))\n          ? hardline\n          : line,\n        \"...\",\n      ];\n    } else {\n      printed = [\"...\"];\n    }\n    props.push([...separatorParts, ...printed]);\n  }\n\n  const lastElem = getLast(node[propertiesField]);\n\n  const canHaveTrailingSeparator = !(\n    node.inexact ||\n    (lastElem && lastElem.type === \"RestElement\") ||\n    (lastElem &&\n      (lastElem.type === \"TSPropertySignature\" ||\n        lastElem.type === \"TSCallSignatureDeclaration\" ||\n        lastElem.type === \"TSMethodSignature\" ||\n        lastElem.type === \"TSConstructSignatureDeclaration\") &&\n      hasComment(lastElem, CommentCheckFlags.PrettierIgnore))\n  );\n\n  let content;\n  if (props.length === 0) {\n    if (!hasComment(node, CommentCheckFlags.Dangling)) {\n      return [leftBrace, rightBrace, printTypeAnnotation(path, options, print)];\n    }\n\n    content = group([\n      leftBrace,\n      printDanglingComments(path, options),\n      softline,\n      rightBrace,\n      printOptionalToken(path),\n      printTypeAnnotation(path, options, print),\n    ]);\n  } else {\n    content = [\n      isFlowInterfaceLikeBody && isNonEmptyArray(node.properties)\n        ? printHardlineAfterHeritage(parent)\n        : \"\",\n      leftBrace,\n      indent([options.bracketSpacing ? line : softline, ...props]),\n      ifBreak(\n        canHaveTrailingSeparator &&\n          (separator !== \",\" || shouldPrintComma(options))\n          ? separator\n          : \"\"\n      ),\n      options.bracketSpacing ? line : softline,\n      rightBrace,\n      printOptionalToken(path),\n      printTypeAnnotation(path, options, print),\n    ];\n  }\n\n  // If we inline the object as first argument of the parent, we don't want\n  // to create another group so that the object breaks before the return\n  // type\n  if (\n    path.match(\n      (node) => node.type === \"ObjectPattern\" && !node.decorators,\n      (node, name, number) =>\n        shouldHugFunctionParameters(node) &&\n        (name === \"params\" ||\n          name === \"parameters\" ||\n          name === \"this\" ||\n          name === \"rest\") &&\n        number === 0\n    ) ||\n    path.match(\n      shouldHugType,\n      (node, name) => name === \"typeAnnotation\",\n      (node, name) => name === \"typeAnnotation\",\n      (node, name, number) =>\n        shouldHugFunctionParameters(node) &&\n        (name === \"params\" ||\n          name === \"parameters\" ||\n          name === \"this\" ||\n          name === \"rest\") &&\n        number === 0\n    ) ||\n    // Assignment printing logic (printAssignment) is responsible\n    // for adding a group if needed\n    (!shouldBreak &&\n      path.match(\n        (node) => node.type === \"ObjectPattern\",\n        (node) =>\n          node.type === \"AssignmentExpression\" ||\n          node.type === \"VariableDeclarator\"\n      ))\n  ) {\n    return content;\n  }\n\n  return group(content, { shouldBreak });\n}\n\nmodule.exports = { printObject };"
    }
}