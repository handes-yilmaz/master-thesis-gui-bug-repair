{
    "1": {
        "bug_file": "src/language-js/print/typescript.js",
        "compressed": "YES",
        "line_numbers": 530,
        "compressed_line_numbers": 36,
        "compressed_bug_file_content": "\n\n  // TypeScript nodes always starts with `TS`\n\n\n      // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n      // The typescript parser accepts multiple parameters here. If you're\n      // using them, it makes sense to have a trailing comma. But if you\n      // aren't, this is more like a computed property name than an array.\n      // So we leave off the trailing comma when there's just one parameter.\n\n\n            /* expandArg */ false,\n            /* printTypeParams */ true\n\n\n        // \"abstract\" and \"declare\" are supported by only \"babel-ts\"\n        // https://github.com/prettier/prettier/issues/9760\n\n\n        /* expandArg */ false,\n        /* printTypeParams */ true\n\n\n        // Global declaration looks like this:\n        // (declare)? global { ... }\n\n\n    // These are not valid TypeScript. Printing them just for the sake of error recovery.\n\n\n      /* istanbul ignore next */\n\n\n"
    },
    "2": {
        "bug_file": "src/language-js/parse/typescript.js",
        "compressed": "NO",
        "line_numbers": 76,
        "compressed_line_numbers": 76,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../../common/parser-create-error.js\");\nconst tryCombinations = require(\"../../utils/try-combinations.js\");\nconst createParser = require(\"./utils/create-parser.js\");\nconst replaceHashbang = require(\"./utils/replace-hashbang.js\");\nconst postprocess = require(\"./postprocess/index.js\");\n\n/** @type {import(\"@typescript-eslint/typescript-estree\").TSESTreeOptions} */\nconst parseOptions = {\n  // `jest@<=26.4.2` rely on `loc`\n  // https://github.com/facebook/jest/issues/10444\n  loc: true,\n  range: true,\n  comment: true,\n  jsx: true,\n  tokens: true,\n  loggerFn: false,\n  project: [],\n};\n\nfunction createParseError(error) {\n  const { message, lineNumber, column } = error;\n\n  /* istanbul ignore next */\n  if (typeof lineNumber !== \"number\") {\n    return error;\n  }\n\n  return createError(message, {\n    start: { line: lineNumber, column: column + 1 },\n  });\n}\n\nfunction parse(text, parsers, opts) {\n  const textToParse = replaceHashbang(text);\n  const jsx = isProbablyJsx(text);\n\n  const { parseWithNodeMaps } = require(\"@typescript-eslint/typescript-estree\");\n  const { result, error: firstError } = tryCombinations(\n    // Try passing with our best guess first.\n    () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx }),\n    // But if we get it wrong, try the opposite.\n    () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx: !jsx })\n  );\n\n  if (!result) {\n    // Suppose our guess is correct, throw the first error\n    throw createParseError(firstError);\n  }\n\n  opts.originalText = text;\n  opts.tsParseResult = result;\n  return postprocess(result.ast, opts);\n}\n\n/**\n * Use a naive regular expression to detect JSX\n */\nfunction isProbablyJsx(text) {\n  return new RegExp(\n    [\n      \"(?:^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string\n      \"|\",\n      \"(?:^[^/]{2}.*/>)\", // Contains \"/>\" on line not starting with \"//\"\n    ].join(\"\"),\n    \"m\"\n  ).test(text);\n}\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    typescript: createParser(parse),\n  },\n};"
    },
    "3": {
        "bug_file": "src/language-js/print/type-parameters.js",
        "compressed": "NO",
        "line_numbers": 151,
        "compressed_line_numbers": 151,
        "compressed_bug_file_content": "\"use strict\";\n\nconst { printDanglingComments } = require(\"../../main/comments.js\");\nconst {\n  builders: { join, line, hardline, softline, group, indent, ifBreak },\n} = require(\"../../document/index.js\");\nconst {\n  isTestCall,\n  hasComment,\n  CommentCheckFlags,\n  isTSXFile,\n  shouldPrintComma,\n  getFunctionParameters,\n  isObjectType,\n} = require(\"../utils.js\");\nconst { createGroupIdMapper } = require(\"../../common/util.js\");\nconst { shouldHugType } = require(\"./type-annotation.js\");\nconst { isArrowFunctionVariableDeclarator } = require(\"./assignment.js\");\n\nconst getTypeParametersGroupId = createGroupIdMapper(\"typeParameters\");\n\nfunction printTypeParameters(path, options, print, paramsKey) {\n  const node = path.getValue();\n\n  if (!node[paramsKey]) {\n    return \"\";\n  }\n\n  // for TypeParameterDeclaration typeParameters is a single node\n  if (!Array.isArray(node[paramsKey])) {\n    return print(paramsKey);\n  }\n\n  const grandparent = path.getNode(2);\n  const isParameterInTestCall = grandparent && isTestCall(grandparent);\n\n  const isArrowFunctionVariable = path.match(\n    (node) =>\n      !(node[paramsKey].length === 1 && isObjectType(node[paramsKey][0])),\n    undefined,\n    (node, name) => name === \"typeAnnotation\",\n    (node) => node.type === \"Identifier\",\n    isArrowFunctionVariableDeclarator\n  );\n\n  const shouldInline =\n    !isArrowFunctionVariable &&\n    (isParameterInTestCall ||\n      node[paramsKey].length === 0 ||\n      (node[paramsKey].length === 1 &&\n        (node[paramsKey][0].type === \"NullableTypeAnnotation\" ||\n          shouldHugType(node[paramsKey][0]))));\n\n  if (shouldInline) {\n    return [\n      \"<\",\n      join(\", \", path.map(print, paramsKey)),\n      printDanglingCommentsForInline(path, options),\n      \">\",\n    ];\n  }\n\n  // Keep comma if the file extension is .tsx and\n  // has one type parameter that isn't extend with any types.\n  // Because, otherwise formatted result will be invalid as tsx.\n  const trailingComma =\n    node.type === \"TSTypeParameterInstantiation\" // https://github.com/microsoft/TypeScript/issues/21984\n      ? \"\"\n      : getFunctionParameters(node).length === 1 &&\n        isTSXFile(options) &&\n        !node[paramsKey][0].constraint &&\n        path.getParentNode().type === \"ArrowFunctionExpression\"\n      ? \",\"\n      : shouldPrintComma(options, \"all\")\n      ? ifBreak(\",\")\n      : \"\";\n\n  return group(\n    [\n      \"<\",\n      indent([softline, join([\",\", line], path.map(print, paramsKey))]),\n      trailingComma,\n      softline,\n      \">\",\n    ],\n    { id: getTypeParametersGroupId(node) }\n  );\n}\n\nfunction printDanglingCommentsForInline(path, options) {\n  const node = path.getValue();\n  if (!hasComment(node, CommentCheckFlags.Dangling)) {\n    return \"\";\n  }\n  const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);\n  const printed = printDanglingComments(\n    path,\n    options,\n    /* sameIndent */ hasOnlyBlockComments\n  );\n  if (hasOnlyBlockComments) {\n    return printed;\n  }\n  return [printed, hardline];\n}\n\nfunction printTypeParameter(path, options, print) {\n  const node = path.getValue();\n  const parts = [];\n  const parent = path.getParentNode();\n  if (parent.type === \"TSMappedType\") {\n    parts.push(\"[\", print(\"name\"));\n    if (node.constraint) {\n      parts.push(\" in \", print(\"constraint\"));\n    }\n    if (parent.nameType) {\n      parts.push(\n        \" as \",\n        path.callParent(() => print(\"nameType\"))\n      );\n    }\n    parts.push(\"]\");\n    return parts;\n  }\n\n  if (node.variance) {\n    parts.push(print(\"variance\"));\n  }\n\n  parts.push(print(\"name\"));\n\n  if (node.bound) {\n    parts.push(\": \", print(\"bound\"));\n  }\n\n  if (node.constraint) {\n    parts.push(\" extends \", print(\"constraint\"));\n  }\n\n  if (node.default) {\n    parts.push(\" = \", print(\"default\"));\n  }\n\n  return parts;\n}\n\nmodule.exports = {\n  printTypeParameter,\n  printTypeParameters,\n  getTypeParametersGroupId,\n};"
    }
}