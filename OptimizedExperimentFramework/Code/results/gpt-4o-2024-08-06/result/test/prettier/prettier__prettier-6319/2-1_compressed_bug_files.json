{
    "1": {
        "bug_file": "src/language-js/parser-babel.js",
        "compressed": "NO",
        "line_numbers": 199,
        "compressed_line_numbers": 199,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst { hasPragma } = require(\"./pragma\");\nconst locFns = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nfunction babelOptions(extraPlugins = []) {\n  return {\n    sourceType: \"module\",\n    allowAwaitOutsideFunction: true,\n    allowImportExportEverywhere: true,\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    allowUndeclaredExports: true,\n    errorRecovery: true,\n    createParenthesizedExpressions: true,\n    plugins: [\n      \"doExpressions\",\n      \"objectRestSpread\",\n      \"classProperties\",\n      \"exportDefaultFrom\",\n      \"exportNamespaceFrom\",\n      \"asyncGenerators\",\n      \"functionBind\",\n      \"functionSent\",\n      \"dynamicImport\",\n      \"numericSeparator\",\n      \"importMeta\",\n      \"optionalCatchBinding\",\n      \"optionalChaining\",\n      \"classPrivateProperties\",\n      [\"pipelineOperator\", { proposal: \"minimal\" }],\n      \"nullishCoalescingOperator\",\n      \"bigInt\",\n      \"throwExpressions\",\n      \"logicalAssignment\",\n      \"classPrivateMethods\",\n      \"v8intrinsic\",\n      \"partialApplication\",\n      [\"decorators\", { decoratorsBeforeExport: false }],\n      ...extraPlugins,\n    ],\n  };\n}\n\nfunction createParse(parseMethod, ...pluginCombinations) {\n  return (text, parsers, opts) => {\n    // Inline the require to avoid loading all the JS if we don't use it\n    const babel = require(\"@babel/parser\");\n\n    let ast;\n    try {\n      ast = tryCombinations(\n        (options) => babel[parseMethod](text, options),\n        pluginCombinations.map(babelOptions)\n      );\n    } catch (error) {\n      throw createError(\n        // babel error prints (l:c) with cols that are zero indexed\n        // so we need our custom error\n        error.message.replace(/ \\(.*\\)/, \"\"),\n        {\n          start: {\n            line: error.loc.line,\n            column: error.loc.column + 1,\n          },\n        }\n      );\n    }\n    delete ast.tokens;\n    return postprocess(ast, { ...opts, originalText: text });\n  };\n}\n\nconst parse = createParse(\"parse\", [\"jsx\", \"flow\"]);\nconst parseFlow = createParse(\"parse\", [\n  \"jsx\",\n  [\"flow\", { all: true, enums: true }],\n]);\nconst parseTypeScript = createParse(\n  \"parse\",\n  [\"jsx\", \"typescript\"],\n  [\"typescript\"]\n);\nconst parseExpression = createParse(\"parseExpression\", [\"jsx\"]);\n\nfunction tryCombinations(fn, combinations) {\n  let error;\n  for (let i = 0; i < combinations.length; i++) {\n    try {\n      return fn(combinations[i]);\n    } catch (_error) {\n      if (!error) {\n        error = _error;\n      }\n    }\n  }\n  throw error;\n}\n\nfunction parseJson(text, parsers, opts) {\n  const ast = parseExpression(text, parsers, opts);\n\n  ast.comments.forEach(assertJsonNode);\n  assertJsonNode(ast);\n\n  return ast;\n}\n\nfunction assertJsonNode(node, parent) {\n  switch (node.type) {\n    case \"ArrayExpression\":\n      return node.elements.forEach(assertJsonChildNode);\n    case \"ObjectExpression\":\n      return node.properties.forEach(assertJsonChildNode);\n    case \"ObjectProperty\":\n      // istanbul ignore if\n      if (node.computed) {\n        throw createJsonError(\"computed\");\n      }\n      // istanbul ignore if\n      if (node.shorthand) {\n        throw createJsonError(\"shorthand\");\n      }\n      return [node.key, node.value].forEach(assertJsonChildNode);\n    case \"UnaryExpression\":\n      switch (node.operator) {\n        case \"+\":\n        case \"-\":\n          return assertJsonChildNode(node.argument);\n        // istanbul ignore next\n        default:\n          throw createJsonError(\"operator\");\n      }\n    case \"Identifier\":\n      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {\n        return;\n      }\n      throw createJsonError();\n    case \"NullLiteral\":\n    case \"BooleanLiteral\":\n    case \"NumericLiteral\":\n    case \"StringLiteral\":\n      return;\n    // istanbul ignore next\n    default:\n      throw createJsonError();\n  }\n\n  function assertJsonChildNode(child) {\n    return assertJsonNode(child, node);\n  }\n\n  // istanbul ignore next\n  function createJsonError(attribute) {\n    const name = !attribute\n      ? node.type\n      : `${node.type} with ${attribute}=${JSON.stringify(node[attribute])}`;\n    return createError(`${name} is not allowed in JSON.`, {\n      start: {\n        line: node.loc.start.line,\n        column: node.loc.start.column + 1,\n      },\n    });\n  }\n}\n\nconst babel = { parse, astFormat: \"estree\", hasPragma, ...locFns };\nconst babelFlow = { ...babel, parse: parseFlow };\nconst babelTypeScript = { ...babel, parse: parseTypeScript };\nconst babelExpression = { ...babel, parse: parseExpression };\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    babel,\n    \"babel-flow\": babelFlow,\n    \"babel-ts\": babelTypeScript,\n    json: {\n      ...babelExpression,\n      hasPragma() {\n        return true;\n      },\n    },\n    json5: babelExpression,\n    \"json-stringify\": {\n      parse: parseJson,\n      astFormat: \"estree-json\",\n      ...locFns,\n    },\n    /** @internal */\n    __js_expression: babelExpression,\n    /** for vue filter */\n    __vue_expression: babelExpression,\n    /** for vue event binding to handle semicolon */\n    __vue_event_binding: babel,\n  },\n};"
    },
    "2": {
        "bug_file": "src/language-js/options.js",
        "compressed": "NO",
        "line_numbers": 100,
        "compressed_line_numbers": 100,
        "compressed_bug_file_content": "\"use strict\";\n\nconst commonOptions = require(\"../common/common-options\");\n\nconst CATEGORY_JAVASCRIPT = \"JavaScript\";\n\n// format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js\nmodule.exports = {\n  arrowParens: {\n    since: \"1.9.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: [\n      { since: \"1.9.0\", value: \"avoid\" },\n      { since: \"2.0.0\", value: \"always\" },\n    ],\n    description: \"Include parentheses around a sole arrow function parameter.\",\n    choices: [\n      {\n        value: \"always\",\n        description: \"Always include parens. Example: `(x) => x`\",\n      },\n      {\n        value: \"avoid\",\n        description: \"Omit parens when possible. Example: `x => x`\",\n      },\n    ],\n  },\n  bracketSpacing: commonOptions.bracketSpacing,\n  jsxBracketSameLine: {\n    since: \"0.17.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Put > on the last line instead of at a new line.\",\n  },\n  semi: {\n    since: \"1.0.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: true,\n    description: \"Print semicolons.\",\n    oppositeDescription:\n      \"Do not print semicolons, except at the beginning of lines which may need them.\",\n  },\n  singleQuote: commonOptions.singleQuote,\n  jsxSingleQuote: {\n    since: \"1.15.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"boolean\",\n    default: false,\n    description: \"Use single quotes in JSX.\",\n  },\n  quoteProps: {\n    since: \"1.17.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: \"as-needed\",\n    description: \"Change when properties in objects are quoted.\",\n    choices: [\n      {\n        value: \"as-needed\",\n        description: \"Only add quotes around object properties where required.\",\n      },\n      {\n        value: \"consistent\",\n        description:\n          \"If at least one property in an object requires quotes, quote all properties.\",\n      },\n      {\n        value: \"preserve\",\n        description: \"Respect the input use of quotes in object properties.\",\n      },\n    ],\n  },\n  trailingComma: {\n    since: \"0.0.0\",\n    category: CATEGORY_JAVASCRIPT,\n    type: \"choice\",\n    default: [\n      { since: \"0.0.0\", value: false },\n      { since: \"0.19.0\", value: \"none\" },\n      { since: \"2.0.0\", value: \"es5\" },\n    ],\n    description: \"Print trailing commas wherever possible when multi-line.\",\n    choices: [\n      {\n        value: \"es5\",\n        description:\n          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",\n      },\n      { value: \"none\", description: \"No trailing commas.\" },\n      {\n        value: \"all\",\n        description:\n          \"Trailing commas wherever possible (including function arguments).\",\n      },\n    ],\n  },\n};"
    },
    "3": {
        "bug_file": "src/language-js/parser-flow.js",
        "compressed": "NO",
        "line_numbers": 40,
        "compressed_line_numbers": 40,
        "compressed_bug_file_content": "\"use strict\";\n\nconst createError = require(\"../common/parser-create-error\");\nconst includeShebang = require(\"../common/parser-include-shebang\");\nconst { hasPragma } = require(\"./pragma\");\nconst locFns = require(\"./loc\");\nconst postprocess = require(\"./postprocess\");\n\nfunction parse(text, parsers, opts) {\n  // Inline the require to avoid loading all the JS if we don't use it\n  const flowParser = require(\"flow-parser\");\n\n  const ast = flowParser.parse(text, {\n    enums: true,\n    esproposal_decorators: true,\n    esproposal_class_instance_fields: true,\n    esproposal_class_static_fields: true,\n    esproposal_export_star_as: true,\n    esproposal_optional_chaining: true,\n    esproposal_nullish_coalescing: true,\n  });\n\n  if (ast.errors.length > 0) {\n    const { loc } = ast.errors[0];\n    throw createError(ast.errors[0].message, {\n      start: { line: loc.start.line, column: loc.start.column + 1 },\n      end: { line: loc.end.line, column: loc.end.column + 1 },\n    });\n  }\n\n  includeShebang(text, ast);\n  return postprocess(ast, { ...opts, originalText: text });\n}\n\n// Export as a plugin so we can reuse the same bundle for UMD loading\nmodule.exports = {\n  parsers: {\n    flow: { parse, astFormat: \"estree\", hasPragma, ...locFns },\n  },\n};"
    },
    "4": {
        "bug_file": "src/main/options.js",
        "compressed": "NO",
        "line_numbers": 195,
        "compressed_line_numbers": 195,
        "compressed_bug_file_content": "\"use strict\";\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst readlines = require(\"n-readlines\");\nconst fromPairs = require(\"lodash/fromPairs\");\nconst { UndefinedParserError } = require(\"../common/errors\");\nconst { getSupportInfo } = require(\"../main/support\");\nconst normalizer = require(\"./options-normalizer\");\nconst { resolveParser } = require(\"./parser\");\n\nconst hiddenDefaults = {\n  astFormat: \"estree\",\n  printer: {},\n  originalText: undefined,\n  locStart: null,\n  locEnd: null,\n};\n\n// Copy options and fill in default values.\nfunction normalize(options, opts) {\n  opts = opts || {};\n\n  const rawOptions = { ...options };\n\n  const supportOptions = getSupportInfo({\n    plugins: options.plugins,\n    showUnreleased: true,\n    showDeprecated: true,\n  }).options;\n\n  const defaults = {\n    ...hiddenDefaults,\n    ...fromPairs(\n      supportOptions\n        .filter((optionInfo) => optionInfo.default !== undefined)\n        .map((option) => [option.name, option.default])\n    ),\n  };\n  if (!rawOptions.parser) {\n    if (!rawOptions.filepath) {\n      const logger = opts.logger || console;\n      logger.warn(\n        \"No parser and no filepath given, using 'babel' the parser now \" +\n          \"but this will throw an error in the future. \" +\n          \"Please specify a parser or a filepath so one can be inferred.\"\n      );\n      rawOptions.parser = \"babel\";\n    } else {\n      rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);\n      if (!rawOptions.parser) {\n        throw new UndefinedParserError(\n          `No parser could be inferred for file: ${rawOptions.filepath}`\n        );\n      }\n    }\n  }\n\n  const parser = resolveParser(\n    normalizer.normalizeApiOptions(\n      rawOptions,\n      [supportOptions.find((x) => x.name === \"parser\")],\n      { passThrough: true, logger: false }\n    )\n  );\n  rawOptions.astFormat = parser.astFormat;\n  rawOptions.locEnd = parser.locEnd;\n  rawOptions.locStart = parser.locStart;\n\n  const plugin = getPlugin(rawOptions);\n  rawOptions.printer = plugin.printers[rawOptions.astFormat];\n\n  const pluginDefaults = supportOptions\n    .filter(\n      (optionInfo) =>\n        optionInfo.pluginDefaults &&\n        optionInfo.pluginDefaults[plugin.name] !== undefined\n    )\n    .reduce(\n      (reduced, optionInfo) =>\n        Object.assign(reduced, {\n          [optionInfo.name]: optionInfo.pluginDefaults[plugin.name],\n        }),\n      {}\n    );\n\n  const mixedDefaults = { ...defaults, ...pluginDefaults };\n\n  Object.keys(mixedDefaults).forEach((k) => {\n    if (rawOptions[k] == null) {\n      rawOptions[k] = mixedDefaults[k];\n    }\n  });\n\n  if (rawOptions.parser === \"json\") {\n    rawOptions.trailingComma = \"none\";\n  }\n\n  return normalizer.normalizeApiOptions(rawOptions, supportOptions, {\n    passThrough: Object.keys(hiddenDefaults),\n    ...opts,\n  });\n}\n\nfunction getPlugin(options) {\n  const { astFormat } = options;\n\n  if (!astFormat) {\n    throw new Error(\"getPlugin() requires astFormat to be set\");\n  }\n  const printerPlugin = options.plugins.find(\n    (plugin) => plugin.printers && plugin.printers[astFormat]\n  );\n  if (!printerPlugin) {\n    throw new Error(`Couldn't find plugin for AST format \"${astFormat}\"`);\n  }\n\n  return printerPlugin;\n}\n\nfunction getInterpreter(filepath) {\n  if (typeof filepath !== \"string\") {\n    return \"\";\n  }\n\n  let fd;\n  try {\n    fd = fs.openSync(filepath, \"r\");\n  } catch (err) {\n    // istanbul ignore next\n    return \"\";\n  }\n\n  try {\n    const liner = new readlines(fd);\n    const firstLine = liner.next().toString(\"utf8\");\n\n    // #!/bin/env node, #!/usr/bin/env node\n    const m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);\n    if (m1) {\n      return m1[1];\n    }\n\n    // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node\n    const m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);\n    if (m2) {\n      return m2[1];\n    }\n    return \"\";\n  } catch (err) {\n    // There are some weird cases where paths are missing, causing Jest\n    // failures. It's unclear what these correspond to in the real world.\n    return \"\";\n  } finally {\n    try {\n      // There are some weird cases where paths are missing, causing Jest\n      // failures. It's unclear what these correspond to in the real world.\n      fs.closeSync(fd);\n    } catch (err) {\n      // nop\n    }\n  }\n}\n\nfunction inferParser(filepath, plugins) {\n  const filename = path.basename(filepath).toLowerCase();\n  const languages = getSupportInfo({ plugins }).languages.filter(\n    (language) => language.since !== null\n  );\n\n  // If the file has no extension, we can try to infer the language from the\n  // interpreter in the shebang line, if any; but since this requires FS access,\n  // do it last.\n  let language = languages.find(\n    (language) =>\n      (language.extensions &&\n        language.extensions.some((extension) =>\n          filename.endsWith(extension)\n        )) ||\n      (language.filenames &&\n        language.filenames.find((name) => name.toLowerCase() === filename))\n  );\n\n  if (!language && !filename.includes(\".\")) {\n    const interpreter = getInterpreter(filepath);\n    language = languages.find(\n      (language) =>\n        language.interpreters && language.interpreters.includes(interpreter)\n    );\n  }\n\n  return language && language.parsers[0];\n}\n\nmodule.exports = { normalize, hiddenDefaults, inferParser };"
    },
    "5": {
        "bug_file": "tests_integration/__tests__/syntax-error.js",
        "compressed": "NO",
        "line_numbers": 11,
        "compressed_line_numbers": 11,
        "compressed_bug_file_content": "\"use strict\";\n\nconst runPrettier = require(\"../runPrettier\");\n\ndescribe(\"exits with non-zero code when input has a syntax error\", () => {\n  runPrettier(\"cli/with-shebang\", [\"--parser\", \"babel\"], {\n    input: \"a.2\",\n  }).test({\n    status: 2,\n  });\n});"
    }
}