{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) 1-501",
            "file_path": "src/language-markdown/printer-markdown.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "import collapseWhiteSpace from \"collapse-white-space\";",
                "",
                "import {",
                "  align,",
                "  fill,",
                "  group,",
                "  hardline,",
                "  indent,",
                "  line,",
                "  literalline,",
                "  markAsRoot,",
                "  softline,",
                "} from \"../document/builders.js\";",
                "import { DOC_TYPE_STRING } from \"../document/constants.js\";",
                "import { getDocType, replaceEndOfLine } from \"../document/utils.js\";",
                "import getMaxContinuousCount from \"../utils/get-max-continuous-count.js\";",
                "import getMinNotPresentContinuousCount from \"../utils/get-min-not-present-continuous-count.js\";",
                "import getPreferredQuote from \"../utils/get-preferred-quote.js\";",
                "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                "import clean from \"./clean.js\";",
                "import { PUNCTUATION_REGEXP } from \"./constants.evaluate.js\";",
                "import embed from \"./embed.js\";",
                "import getVisitorKeys from \"./get-visitor-keys.js\";",
                "import { locEnd, locStart } from \"./loc.js\";",
                "import { insertPragma } from \"./pragma.js\";",
                "import { printTable } from \"./print/table.js\";",
                "import { printParagraph } from \"./print-paragraph.js\";",
                "import preprocess from \"./print-preprocess.js\";",
                "import { printSentence } from \"./print-sentence.js\";",
                "import { printWhitespace } from \"./print-whitespace.js\";",
                "import {",
                "  getFencedCodeBlockValue,",
                "  hasGitDiffFriendlyOrderedList,",
                "  INLINE_NODE_TYPES,",
                "  INLINE_NODE_WRAPPER_TYPES,",
                "  isAutolink,",
                "  splitText,",
                "} from \"./utils.js\";",
                "",
                "/**",
                " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                " */",
                "",
                "const SIBLING_NODE_TYPES = new Set([\"listItem\", \"definition\"]);",
                "",
                "function genericPrint(path, options, print) {",
                "  const { node } = path;",
                "",
                "  if (shouldRemainTheSameContent(path)) {",
                "    /** @type {Doc} */",
                "    const parts = [\"\"];",
                "    const textsNodes = splitText(",
                "      options.originalText.slice(",
                "        node.position.start.offset,",
                "        node.position.end.offset,",
                "      ),",
                "    );",
                "    for (const node of textsNodes) {",
                "      if (node.type === \"word\") {",
                "        parts.push([parts.pop(), node.value]);",
                "        continue;",
                "      }",
                "      const doc = printWhitespace(path, node.value, options.proseWrap, true);",
                "      if (getDocType(doc) === DOC_TYPE_STRING) {",
                "        parts.push([parts.pop(), doc]);",
                "        continue;",
                "      }",
                "      parts.push(doc);",
                "    }",
                "    return fill(parts);",
                "  }",
                "",
                "  switch (node.type) {",
                "    case \"front-matter\":",
                "      return options.originalText.slice(",
                "        node.position.start.offset,",
                "        node.position.end.offset,",
                "      );",
                "    case \"root\":",
                "      /* c8 ignore next 3 */",
                "      if (node.children.length === 0) {",
                "        return \"\";",
                "      }",
                "      return [printRoot(path, options, print), hardline];",
                "    case \"paragraph\":",
                "      return printParagraph(path, options, print);",
                "    case \"sentence\":",
                "      return printSentence(path, print);",
                "    case \"word\": {",
                "      let escapedValue = node.value",
                "        .replaceAll(\"*\", String.raw`\\*`) // escape all `*`",
                "        .replaceAll(",
                "          new RegExp(",
                "            [",
                "              `(^|${PUNCTUATION_REGEXP.source})(_+)`,",
                "              `(_+)(${PUNCTUATION_REGEXP.source}|$)`,",
                "            ].join(\"|\"),",
                "            \"g\",",
                "          ),",
                "          (_, text1, underscore1, underscore2, text2) =>",
                "            (underscore1",
                "              ? `${text1}${underscore1}`",
                "              : `${underscore2}${text2}`",
                "            ).replaceAll(\"_\", String.raw`\\_`),",
                "        ); // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis",
                "",
                "      const isFirstSentence = (node, name, index) =>",
                "        node.type === \"sentence\" && index === 0;",
                "      const isLastChildAutolink = (node, name, index) =>",
                "        isAutolink(node.children[index - 1]);",
                "",
                "      if (",
                "        escapedValue !== node.value &&",
                "        (path.match(undefined, isFirstSentence, isLastChildAutolink) ||",
                "          path.match(",
                "            undefined,",
                "            isFirstSentence,",
                "            (node, name, index) => node.type === \"emphasis\" && index === 0,",
                "            isLastChildAutolink,",
                "          ))",
                "      ) {",
                "        // backslash is parsed as part of autolinks, so we need to remove it",
                "        escapedValue = escapedValue.replace(/^(\\\\?[*_])+/, (prefix) =>",
                "          prefix.replaceAll(\"\\\\\", \"\"),",
                "        );",
                "      }",
                "",
                "      return escapedValue;",
                "    }",
                "    case \"whitespace\": {",
                "      const { next } = path;",
                "",
                "      const proseWrap =",
                "        // leading char that may cause different syntax",
                "        next && /^>|^(?:[*+-]|#{1,6}|\\d+[).])$/.test(next.value)",
                "          ? \"never\"",
                "          : options.proseWrap;",
                "",
                "      return printWhitespace(path, node.value, proseWrap);",
                "    }",
                "    case \"emphasis\": {",
                "      let style;",
                "      if (isAutolink(node.children[0])) {",
                "        style = options.originalText[node.position.start.offset];",
                "      } else {",
                "        const { previous, next } = path;",
                "        const hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not",
                "          (previous?.type === \"sentence\" &&",
                "            previous.children.at(-1)?.type === \"word\" &&",
                "            !previous.children.at(-1).hasTrailingPunctuation) ||",
                "          (next?.type === \"sentence\" &&",
                "            next.children[0]?.type === \"word\" &&",
                "            !next.children[0].hasLeadingPunctuation);",
                "        style =",
                "          hasPrevOrNextWord ||",
                "          path.hasAncestor((node) => node.type === \"emphasis\")",
                "            ? \"*\"",
                "            : \"_\";",
                "      }",
                "      return [style, printChildren(path, options, print), style];",
                "    }",
                "    case \"strong\":",
                "      return [\"**\", printChildren(path, options, print), \"**\"];",
                "    case \"delete\":",
                "      return [\"~~\", printChildren(path, options, print), \"~~\"];",
                "    case \"inlineCode\": {",
                "      const code =",
                "        options.proseWrap === \"preserve\"",
                "          ? node.value",
                "          : node.value.replaceAll(\"\\n\", \" \");",
                "      const backtickCount = getMinNotPresentContinuousCount(code, \"`\");",
                "      const backtickString = \"`\".repeat(backtickCount || 1);",
                "      const padding =",
                "        code.startsWith(\"`\") ||",
                "        code.endsWith(\"`\") ||",
                "        (/^[\\n ]/.test(code) && /[\\n ]$/.test(code) && /[^\\n ]/.test(code))",
                "          ? \" \"",
                "          : \"\";",
                "      return [backtickString, padding, code, padding, backtickString];",
                "    }",
                "    case \"wikiLink\": {",
                "      let contents = \"\";",
                "      if (options.proseWrap === \"preserve\") {",
                "        contents = node.value;",
                "      } else {",
                "        contents = node.value.replaceAll(/[\\t\\n]+/g, \" \");",
                "      }",
                "",
                "      return [\"[[\", contents, \"]]\"];",
                "    }",
                "    case \"link\":",
                "      switch (options.originalText[node.position.start.offset]) {",
                "        case \"<\": {",
                "          const mailto = \"mailto:\";",
                "          const url =",
                "            // <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }",
                "            node.url.startsWith(mailto) &&",
                "            options.originalText.slice(",
                "              node.position.start.offset + 1,",
                "              node.position.start.offset + 1 + mailto.length,",
                "            ) !== mailto",
                "              ? node.url.slice(mailto.length)",
                "              : node.url;",
                "          return [\"<\", url, \">\"];",
                "        }",
                "        case \"[\":",
                "          return [",
                "            \"[\",",
                "            printChildren(path, options, print),",
                "            \"](\",",
                "            printUrl(node.url, \")\"),",
                "            printTitle(node.title, options),",
                "            \")\",",
                "          ];",
                "        default:",
                "          return options.originalText.slice(",
                "            node.position.start.offset,",
                "            node.position.end.offset,",
                "          );",
                "      }",
                "    case \"image\":",
                "      return [",
                "        \"![\",",
                "        node.alt || \"\",",
                "        \"](\",",
                "        printUrl(node.url, \")\"),",
                "        printTitle(node.title, options),",
                "        \")\",",
                "      ];",
                "    case \"blockquote\":",
                "      return [\"> \", align(\"> \", printChildren(path, options, print))];",
                "    case \"heading\":",
                "      return [",
                "        \"#\".repeat(node.depth) + \" \",",
                "        printChildren(path, options, print),",
                "      ];",
                "    case \"code\": {",
                "      if (node.isIndented) {",
                "        // indented code block",
                "        const alignment = \" \".repeat(4);",
                "        return align(alignment, [",
                "          alignment,",
                "          replaceEndOfLine(node.value, hardline),",
                "        ]);",
                "      }",
                "",
                "      // fenced code block",
                "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                "      const style = styleUnit.repeat(",
                "        Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1),",
                "      );",
                "      return [",
                "        style,",
                "        node.lang || \"\",",
                "        node.meta ? \" \" + node.meta : \"\",",
                "        hardline,",
                "        replaceEndOfLine(",
                "          getFencedCodeBlockValue(node, options.originalText),",
                "          hardline,",
                "        ),",
                "        hardline,",
                "        style,",
                "      ];",
                "    }",
                "    case \"html\": {",
                "      const { parent, isLast } = path;",
                "      const value =",
                "        parent.type === \"root\" && isLast ? node.value.trimEnd() : node.value;",
                "      const isHtmlComment = /^<!--.*-->$/s.test(value);",
                "",
                "      return replaceEndOfLine(",
                "        value,",
                "        // @ts-expect-error",
                "        isHtmlComment ? hardline : markAsRoot(literalline),",
                "      );",
                "    }",
                "    case \"list\": {",
                "      const nthSiblingIndex = getNthListSiblingIndex(node, path.parent);",
                "",
                "      const isGitDiffFriendlyOrderedList = hasGitDiffFriendlyOrderedList(",
                "        node,",
                "        options,",
                "      );",
                "",
                "      return printChildren(path, options, print, {",
                "        processor(childPath) {",
                "          const prefix = getPrefix();",
                "          const childNode = childPath.node;",
                "",
                "          if (",
                "            childNode.children.length === 2 &&",
                "            childNode.children[1].type === \"html\" &&",
                "            childNode.children[0].position.start.column !==",
                "              childNode.children[1].position.start.column",
                "          ) {",
                "            return [prefix, printListItem(childPath, options, print, prefix)];",
                "          }",
                "",
                "          return [",
                "            prefix,",
                "            align(",
                "              \" \".repeat(prefix.length),",
                "              printListItem(childPath, options, print, prefix),",
                "            ),",
                "          ];",
                "",
                "          function getPrefix() {",
                "            const rawPrefix = node.ordered",
                "              ? (childPath.isFirst",
                "                  ? node.start",
                "                  : isGitDiffFriendlyOrderedList",
                "                    ? 1",
                "                    : node.start + childPath.index) +",
                "                (nthSiblingIndex % 2 === 0 ? \". \" : \") \")",
                "              : nthSiblingIndex % 2 === 0",
                "                ? \"- \"",
                "                : \"* \";",
                "",
                "            return node.isAligned ||",
                "              /* workaround for https://github.com/remarkjs/remark/issues/315 */ node.hasIndentedCodeblock",
                "              ? alignListPrefix(rawPrefix, options)",
                "              : rawPrefix;",
                "          }",
                "        },",
                "      });",
                "    }",
                "    case \"thematicBreak\": {",
                "      const { ancestors } = path;",
                "      const counter = ancestors.findIndex((node) => node.type === \"list\");",
                "      if (counter === -1) {",
                "        return \"---\";",
                "      }",
                "      const nthSiblingIndex = getNthListSiblingIndex(",
                "        ancestors[counter],",
                "        ancestors[counter + 1],",
                "      );",
                "      return nthSiblingIndex % 2 === 0 ? \"***\" : \"---\";",
                "    }",
                "    case \"linkReference\":",
                "      return [",
                "        \"[\",",
                "        printChildren(path, options, print),",
                "        \"]\",",
                "        node.referenceType === \"full\"",
                "          ? printLinkReference(node)",
                "          : node.referenceType === \"collapsed\"",
                "            ? \"[]\"",
                "            : \"\",",
                "      ];",
                "    case \"imageReference\":",
                "      switch (node.referenceType) {",
                "        case \"full\":",
                "          return [\"![\", node.alt || \"\", \"]\", printLinkReference(node)];",
                "        default:",
                "          return [",
                "            \"![\",",
                "            node.alt,",
                "            \"]\",",
                "            node.referenceType === \"collapsed\" ? \"[]\" : \"\",",
                "          ];",
                "      }",
                "    case \"definition\": {",
                "      const lineOrSpace = options.proseWrap === \"always\" ? line : \" \";",
                "      return group([",
                "        printLinkReference(node),",
                "        \":\",",
                "        indent([",
                "          lineOrSpace,",
                "          printUrl(node.url),",
                "          node.title === null",
                "            ? \"\"",
                "            : [lineOrSpace, printTitle(node.title, options, false)],",
                "        ]),",
                "      ]);",
                "    }",
                "    // `footnote` requires `.use(footnotes, {inlineNotes: true})`, we are not using this option",
                "    // https://github.com/remarkjs/remark-footnotes#optionsinlinenotes",
                "    /* c8 ignore next 2 */",
                "    case \"footnote\":",
                "      return [\"[^\", printChildren(path, options, print), \"]\"];",
                "    case \"footnoteReference\":",
                "      return printFootnoteReference(node);",
                "    case \"footnoteDefinition\": {",
                "      const shouldInlineFootnote =",
                "        node.children.length === 1 &&",
                "        node.children[0].type === \"paragraph\" &&",
                "        (options.proseWrap === \"never\" ||",
                "          (options.proseWrap === \"preserve\" &&",
                "            node.children[0].position.start.line ===",
                "              node.children[0].position.end.line));",
                "      return [",
                "        printFootnoteReference(node),",
                "        \": \",",
                "        shouldInlineFootnote",
                "          ? printChildren(path, options, print)",
                "          : group([",
                "              align(",
                "                \" \".repeat(4),",
                "                printChildren(path, options, print, {",
                "                  processor: ({ isFirst }) =>",
                "                    isFirst ? group([softline, print()]) : print(),",
                "                }),",
                "              ),",
                "            ]),",
                "      ];",
                "    }",
                "    case \"table\":",
                "      return printTable(path, options, print);",
                "    case \"tableCell\":",
                "      return printChildren(path, options, print);",
                "    case \"break\":",
                "      return /\\s/.test(options.originalText[node.position.start.offset])",
                "        ? [\"  \", markAsRoot(literalline)]",
                "        : [\"\\\\\", hardline];",
                "    case \"liquidNode\":",
                "      return replaceEndOfLine(node.value, hardline);",
                "    // MDX",
                "    // fallback to the original text if multiparser failed",
                "    // or `embeddedLanguageFormatting: \"off\"`",
                "    case \"import\":",
                "    case \"export\":",
                "    case \"jsx\":",
                "      return node.value;",
                "    case \"esComment\":",
                "      return [\"{/* \", node.value, \" */}\"];",
                "    case \"math\":",
                "      return [",
                "        \"$$\",",
                "        hardline,",
                "        node.value ? [replaceEndOfLine(node.value, hardline), hardline] : \"\",",
                "        \"$$\",",
                "      ];",
                "    case \"inlineMath\":",
                "      // remark-math trims content but we don't want to remove whitespaces",
                "      // since it's very possible that it's recognized as math accidentally",
                "      return options.originalText.slice(locStart(node), locEnd(node));",
                "",
                "    case \"tableRow\": // handled in \"table\"",
                "    case \"listItem\": // handled in \"list\"",
                "    case \"text\": // handled in other types",
                "    default:",
                "      /* c8 ignore next */",
                "      throw new UnexpectedNodeError(node, \"Markdown\");",
                "  }",
                "}",
                "",
                "function printListItem(path, options, print, listPrefix) {",
                "  const { node } = path;",
                "  const prefix = node.checked === null ? \"\" : node.checked ? \"[x] \" : \"[ ] \";",
                "  return [",
                "    prefix,",
                "    printChildren(path, options, print, {",
                "      processor({ node, isFirst }) {",
                "        if (isFirst && node.type !== \"list\") {",
                "          return align(\" \".repeat(prefix.length), print());",
                "        }",
                "",
                "        const alignment = \" \".repeat(",
                "          clamp(options.tabWidth - listPrefix.length, 0, 3), // 4+ will cause indented code block",
                "        );",
                "        return [alignment, align(alignment, print())];",
                "      },",
                "    }),",
                "  ];",
                "}",
                "",
                "function alignListPrefix(prefix, options) {",
                "  const additionalSpaces = getAdditionalSpaces();",
                "  return (",
                "    prefix +",
                "    \" \".repeat(",
                "      additionalSpaces >= 4 ? 0 : additionalSpaces, // 4+ will cause indented code block",
                "    )",
                "  );",
                "",
                "  function getAdditionalSpaces() {",
                "    const restSpaces = prefix.length % options.tabWidth;",
                "    return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;",
                "  }",
                "}",
                "",
                "function getNthListSiblingIndex(node, parentNode) {",
                "  return getNthSiblingIndex(",
                "    node,",
                "    parentNode,",
                "    (siblingNode) => siblingNode.ordered === node.ordered,",
                "  );",
                "}",
                "",
                "function getNthSiblingIndex(node, parentNode, condition) {",
                "  let index = -1;",
                "",
                "  for (const childNode of parentNode.children) {",
                "    if (childNode.type === node.type && condition(childNode)) {",
                "      index++;",
                "    } else {",
                "      index = -1;",
                "    }",
                "",
                "    if (childNode === node) {",
                "      return index;"
            ]
        },
        "2": {
            "class_name": "  (not found) ",
            "file_path": "src/language-markdown/print-whitespace.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 291
                }
            ],
            "class_code": [
                "import { hardline, line, softline } from \"../document/builders.js\";",
                "import {",
                "  KIND_CJ_LETTER,",
                "  KIND_CJK_PUNCTUATION,",
                "  KIND_K_LETTER,",
                "  KIND_NON_CJK,",
                "} from \"./utils.js\";",
                "",
                "/**",
                " * @typedef {import(\"./utils.js\").WordNode} WordNode",
                " * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue",
                " * @typedef {import(\"./utils.js\").WordKind} WordKind",
                " * @typedef {import(\"../common/ast-path.js\").default} AstPath",
                " * @typedef {\"always\" | \"never\" | \"preserve\"} ProseWrap",
                " * @typedef {{ next?: WordNode | null, previous?: WordNode | null }}",
                " * AdjacentNodes Nodes adjacent to a `whitespace` node. Are always of type",
                " * `word`.",
                " */",
                "",
                "const SINGLE_LINE_NODE_TYPES = new Set([",
                "  \"heading\",",
                "  \"tableCell\",",
                "  \"link\",",
                "  \"wikiLink\",",
                "]);",
                "",
                "/**",
                " * These characters must not immediately precede a line break.",
                " *",
                " * e.g. `\"（\"`:",
                " *",
                " * - Bad:  `\"檜原村（\\nひのはらむら）\"`",
                " * - Good: `\"檜原村\\n（ひのはらむら）\"` or",
                " *         `\"檜原村（ひ\\nのはらむら）\"`",
                " */",
                "const noBreakAfter = new Set(",
                "  \"$(£¥·'\\\"〈《「『【〔〖〝﹙﹛＄（［｛￡￥[{‵︴︵︷︹︻︽︿﹁﹃﹏〘｟«\",",
                ");",
                "",
                "/**",
                " * These characters must not immediately follow a line break.",
                " *",
                " * e.g. `\"）\"`:",
                " *",
                " * - Bad:  `\"檜原村（ひのはらむら\\n）以外には、\"`",
                " * - Good: `\"檜原村（ひのはらむ\\nら）以外には、\"` or",
                " *         `\"檜原村（ひのはらむら）\\n以外には、\"`",
                " */",
                "const noBreakBefore = new Set(",
                "  \"!%),.:;?]}¢°·'\\\"†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？］｝～–—•〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘︶︸︺︼︾﹀﹂﹗｜､』】〙〟｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠〜～‼⁇⁈⁉・゙゚\",",
                ");",
                "",
                "/**",
                " * A line break between a character from this set and CJ can be converted to a",
                " * space. Includes only ASCII punctuation marks for now.",
                " */",
                "const lineBreakBetweenTheseAndCJConvertsToSpace = new Set(",
                "  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",",
                ");",
                "",
                "/**",
                " * Determine the preferred style of spacing between Chinese or Japanese and non-CJK",
                " * characters in the parent `sentence` node.",
                " *",
                " * @param {AstPath} path",
                " * @returns {boolean} `true` if Space tends to be inserted between CJ and",
                " * non-CJK, `false` otherwise.",
                " */",
                "function isInSentenceWithCJSpaces({ parent: sentenceNode }) {",
                "  if (sentenceNode.usesCJSpaces === undefined) {",
                "    const stats = { \" \": 0, \"\": 0 };",
                "    const { children } = sentenceNode;",
                "",
                "    for (let i = 1; i < children.length - 1; ++i) {",
                "      const node = children[i];",
                "      if (",
                "        node.type === \"whitespace\" &&",
                "        (node.value === \" \" || node.value === \"\")",
                "      ) {",
                "        const previousKind = children[i - 1].kind;",
                "        const nextKind = children[i + 1].kind;",
                "        if (",
                "          (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||",
                "          (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)",
                "        ) {",
                "          ++stats[node.value];",
                "        }",
                "      }",
                "    }",
                "",
                "    // Inject a property to cache the result.",
                "    sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];",
                "  }",
                "",
                "  return sentenceNode.usesCJSpaces;",
                "}",
                "",
                "/**",
                " * Check whether the given `\"\\n\"` node can be converted to a space.",
                " *",
                " * For example, if you would like to squash English text",
                " *",
                " *     \"You might want\\nto use Prettier.\"",
                " *",
                " * into a single line, you would replace `\"\\n\"` with `\" \"`:",
                " *",
                " *     \"You might want to use Prettier.\"",
                " *",
                " * However, Chinese and Japanese don't use U+0020 Space to divide words, so line",
                " * breaks shouldn't be replaced with spaces for those languages.",
                " *",
                " * PRs are welcome to support line breaking rules for other languages.",
                " *",
                " * @param {AstPath} path",
                " * @param {boolean} isLink",
                " * @returns {boolean}",
                " */",
                "function lineBreakCanBeConvertedToSpace(path, isLink) {",
                "  if (isLink) {",
                "    return true;",
                "  }",
                "",
                "  /** @type {AdjacentNodes} */",
                "  const { previous, next } = path;",
                "",
                "  // e.g. \" \\nletter\"",
                "  if (!previous || !next) {",
                "    return true;",
                "  }",
                "",
                "  const previousKind = previous.kind;",
                "  const nextKind = next.kind;",
                "",
                "  if (",
                "    // \"\\n\" between non-CJK or Korean characters always can be converted to a",
                "    // space. Korean Hangul simulates Latin words. See",
                "    // https://github.com/prettier/prettier/issues/6516",
                "    (isNonCJKOrKoreanLetter(previousKind) &&",
                "      isNonCJKOrKoreanLetter(nextKind)) ||",
                "    // Han & Hangul: same way preferred",
                "    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||",
                "    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)",
                "  ) {",
                "    return true;",
                "  }",
                "",
                "  // Do not convert \\n to a space:",
                "  if (",
                "    // around CJK punctuation",
                "    previousKind === KIND_CJK_PUNCTUATION ||",
                "    nextKind === KIND_CJK_PUNCTUATION ||",
                "    // between CJ",
                "    (previousKind === KIND_CJ_LETTER && nextKind === KIND_CJ_LETTER)",
                "  ) {",
                "    return false;",
                "  }",
                "",
                "  // The rest of this function deals only with line breaks between CJ and",
                "  // non-CJK characters.",
                "",
                "  // Convert a line break between CJ and certain non-letter characters (e.g.",
                "  // ASCII punctuation) to a space.",
                "  //",
                "  // E.g. :::\\n句子句子句子\\n::: → ::: 句子句子句子 :::",
                "  //",
                "  // Note: line breaks like \"(\\n句子句子\\n)\" or \"句子\\n.\" are suppressed in",
                "  // `isBreakable(...)`.",
                "  if (",
                "    lineBreakBetweenTheseAndCJConvertsToSpace.has(next.value[0]) ||",
                "    lineBreakBetweenTheseAndCJConvertsToSpace.has(previous.value.at(-1))",
                "  ) {",
                "    return true;",
                "  }",
                "",
                "  // Converting a line break between CJ and non-ASCII punctuation to a space is",
                "  // undesired in many cases. PRs are welcome to fine-tune this logic.",
                "  //",
                "  // Examples where \\n must not be converted to a space:",
                "  //",
                "  // 1. \"〜\" (U+301C, belongs to Pd) in",
                "  //",
                "  //     \"ア〜\\nエの中から1つ選べ。\"",
                "  //",
                "  // 2. \"…\" (U+2026, belongs to Po) in",
                "  //",
                "  //     \"これはひどい……\\nなんと汚いコミットログなんだ……\"",
                "  if (previous.hasTrailingPunctuation || next.hasLeadingPunctuation) {",
                "    return false;",
                "  }",
                "",
                "  // If the sentence uses the style with spaces between CJ and non-CJK, \"\\n\" can",
                "  // be converted to a space.",
                "  return isInSentenceWithCJSpaces(path);",
                "}",
                "",
                "/**",
                " * @param {WordKind | undefined} kind",
                " * @returns {boolean} `true` if `kind` is defined and not CJK punctuation",
                " */",
                "function isLetter(kind) {",
                "  return (",
                "    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER",
                "  );",
                "}",
                "",
                "/**",
                " * @param {WordKind | undefined} kind",
                " * @returns {boolean} `true` if `kind` is Korean letter or non-CJK",
                " */",
                "function isNonCJKOrKoreanLetter(kind) {",
                "  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;",
                "}",
                "",
                "/**",
                " * Check whether whitespace can be printed as a line break.",
                " *",
                " * @param {AstPath} path",
                " * @param {WhitespaceValue} value",
                " * @param {ProseWrap} proseWrap",
                " * @param {boolean} isLink",
                " * @param {boolean} canBeSpace",
                " * @returns {boolean}",
                " */",
                "function isBreakable(path, value, proseWrap, isLink, canBeSpace) {",
                "  if (",
                "    proseWrap !== \"always\" ||",
                "    path.hasAncestor((node) => SINGLE_LINE_NODE_TYPES.has(node.type))",
                "  ) {",
                "    return false;",
                "  }",
                "",
                "  if (isLink) {",
                "    return value !== \"\";",
                "  }",
                "",
                "  // Spaces are always breakable",
                "  if (value === \" \") {",
                "    return true;",
                "  }",
                "",
                "  /** @type {AdjacentNodes} */",
                "  const { previous, next } = path;",
                "",
                "  // Simulates Latin words; see https://github.com/prettier/prettier/issues/6516",
                "  // [Latin][\"\"][Hangul] & vice versa => Don't break",
                "  // [Han & Kana][\"\"][Hangul], either",
                "  if (",
                "    value === \"\" &&",
                "    ((previous?.kind === KIND_K_LETTER && isLetter(next?.kind)) ||",
                "      (next?.kind === KIND_K_LETTER && isLetter(previous?.kind)))",
                "  ) {",
                "    return false;",
                "  }",
                "",
                "  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages",
                "  const violatesCJKLineBreakingRules =",
                "    !canBeSpace &&",
                "    ((next && noBreakBefore.has(next.value[0])) ||",
                "      (previous && noBreakAfter.has(previous.value.at(-1))));",
                "",
                "  if (violatesCJKLineBreakingRules) {",
                "    return false;",
                "  }",
                "",
                "  return true;",
                "}",
                "",
                "/**",
                " * @param {AstPath} path",
                " * @param {WhitespaceValue} value",
                " * @param {ProseWrap} proseWrap",
                " * @param {boolean} [isLink] Special mode of (un)wrapping that preserves the",
                " * normalized form of link labels. https://spec.commonmark.org/0.30/#matches",
                " */",
                "function printWhitespace(path, value, proseWrap, isLink) {",
                "  if (proseWrap === \"preserve\" && value === \"\\n\") {",
                "    return hardline;",
                "  }",
                "",
                "  const canBeSpace =",
                "    value === \" \" ||",
                "    (value === \"\\n\" && lineBreakCanBeConvertedToSpace(path, isLink));",
                "",
                "  if (isBreakable(path, value, proseWrap, isLink, canBeSpace)) {",
                "    return canBeSpace ? line : softline;",
                "  }",
                "",
                "  return canBeSpace ? \" \" : \"\";",
                "}",
                "",
                "export { printWhitespace };"
            ]
        }
    },
    "bug_functions": {
        "3": {
            "function_name": "printWhitespace (not found) ",
            "file_path": "src/language-markdown/print-whitespace.js",
            "function_details": [
                {
                    "name": "printWhitespace",
                    "start_line": 1,
                    "end_line": 291
                }
            ],
            "function_code": [
                "import { hardline, line, softline } from \"../document/builders.js\";",
                "import {",
                "  KIND_CJ_LETTER,",
                "  KIND_CJK_PUNCTUATION,",
                "  KIND_K_LETTER,",
                "  KIND_NON_CJK,",
                "} from \"./utils.js\";",
                "",
                "/**",
                " * @typedef {import(\"./utils.js\").WordNode} WordNode",
                " * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue",
                " * @typedef {import(\"./utils.js\").WordKind} WordKind",
                " * @typedef {import(\"../common/ast-path.js\").default} AstPath",
                " * @typedef {\"always\" | \"never\" | \"preserve\"} ProseWrap",
                " * @typedef {{ next?: WordNode | null, previous?: WordNode | null }}",
                " * AdjacentNodes Nodes adjacent to a `whitespace` node. Are always of type",
                " * `word`.",
                " */",
                "",
                "const SINGLE_LINE_NODE_TYPES = new Set([",
                "  \"heading\",",
                "  \"tableCell\",",
                "  \"link\",",
                "  \"wikiLink\",",
                "]);",
                "",
                "/**",
                " * These characters must not immediately precede a line break.",
                " *",
                " * e.g. `\"（\"`:",
                " *",
                " * - Bad:  `\"檜原村（\\nひのはらむら）\"`",
                " * - Good: `\"檜原村\\n（ひのはらむら）\"` or",
                " *         `\"檜原村（ひ\\nのはらむら）\"`",
                " */",
                "const noBreakAfter = new Set(",
                "  \"$(£¥·'\\\"〈《「『【〔〖〝﹙﹛＄（［｛￡￥[{‵︴︵︷︹︻︽︿﹁﹃﹏〘｟«\",",
                ");",
                "",
                "/**",
                " * These characters must not immediately follow a line break.",
                " *",
                " * e.g. `\"）\"`:",
                " *",
                " * - Bad:  `\"檜原村（ひのはらむら\\n）以外には、\"`",
                " * - Good: `\"檜原村（ひのはらむ\\nら）以外には、\"` or",
                " *         `\"檜原村（ひのはらむら）\\n以外には、\"`",
                " */",
                "const noBreakBefore = new Set(",
                "  \"!%),.:;?]}¢°·'\\\"†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？］｝～–—•〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘︶︸︺︼︾﹀﹂﹗｜､』】〙〟｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠〜～‼⁇⁈⁉・゙゚\",",
                ");",
                "",
                "/**",
                " * A line break between a character from this set and CJ can be converted to a",
                " * space. Includes only ASCII punctuation marks for now.",
                " */",
                "const lineBreakBetweenTheseAndCJConvertsToSpace = new Set(",
                "  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",",
                ");",
                "",
                "/**",
                " * Determine the preferred style of spacing between Chinese or Japanese and non-CJK",
                " * characters in the parent `sentence` node.",
                " *",
                " * @param {AstPath} path",
                " * @returns {boolean} `true` if Space tends to be inserted between CJ and",
                " * non-CJK, `false` otherwise.",
                " */",
                "function isInSentenceWithCJSpaces({ parent: sentenceNode }) {",
                "  if (sentenceNode.usesCJSpaces === undefined) {",
                "    const stats = { \" \": 0, \"\": 0 };",
                "    const { children } = sentenceNode;",
                "",
                "    for (let i = 1; i < children.length - 1; ++i) {",
                "      const node = children[i];",
                "      if (",
                "        node.type === \"whitespace\" &&",
                "        (node.value === \" \" || node.value === \"\")",
                "      ) {",
                "        const previousKind = children[i - 1].kind;",
                "        const nextKind = children[i + 1].kind;",
                "        if (",
                "          (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||",
                "          (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)",
                "        ) {",
                "          ++stats[node.value];",
                "        }",
                "      }",
                "    }",
                "",
                "    // Inject a property to cache the result.",
                "    sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];",
                "  }",
                "",
                "  return sentenceNode.usesCJSpaces;",
                "}",
                "",
                "/**",
                " * Check whether the given `\"\\n\"` node can be converted to a space.",
                " *",
                " * For example, if you would like to squash English text",
                " *",
                " *     \"You might want\\nto use Prettier.\"",
                " *",
                " * into a single line, you would replace `\"\\n\"` with `\" \"`:",
                " *",
                " *     \"You might want to use Prettier.\"",
                " *",
                " * However, Chinese and Japanese don't use U+0020 Space to divide words, so line",
                " * breaks shouldn't be replaced with spaces for those languages.",
                " *",
                " * PRs are welcome to support line breaking rules for other languages.",
                " *",
                " * @param {AstPath} path",
                " * @param {boolean} isLink",
                " * @returns {boolean}",
                " */",
                "function lineBreakCanBeConvertedToSpace(path, isLink) {",
                "  if (isLink) {",
                "    return true;",
                "  }",
                "",
                "  /** @type {AdjacentNodes} */",
                "  const { previous, next } = path;",
                "",
                "  // e.g. \" \\nletter\"",
                "  if (!previous || !next) {",
                "    return true;",
                "  }",
                "",
                "  const previousKind = previous.kind;",
                "  const nextKind = next.kind;",
                "",
                "  if (",
                "    // \"\\n\" between non-CJK or Korean characters always can be converted to a",
                "    // space. Korean Hangul simulates Latin words. See",
                "    // https://github.com/prettier/prettier/issues/6516",
                "    (isNonCJKOrKoreanLetter(previousKind) &&",
                "      isNonCJKOrKoreanLetter(nextKind)) ||",
                "    // Han & Hangul: same way preferred",
                "    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||",
                "    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)",
                "  ) {",
                "    return true;",
                "  }",
                "",
                "  // Do not convert \\n to a space:",
                "  if (",
                "    // around CJK punctuation",
                "    previousKind === KIND_CJK_PUNCTUATION ||",
                "    nextKind === KIND_CJK_PUNCTUATION ||",
                "    // between CJ",
                "    (previousKind === KIND_CJ_LETTER && nextKind === KIND_CJ_LETTER)",
                "  ) {",
                "    return false;",
                "  }",
                "",
                "  // The rest of this function deals only with line breaks between CJ and",
                "  // non-CJK characters.",
                "",
                "  // Convert a line break between CJ and certain non-letter characters (e.g.",
                "  // ASCII punctuation) to a space.",
                "  //",
                "  // E.g. :::\\n句子句子句子\\n::: → ::: 句子句子句子 :::",
                "  //",
                "  // Note: line breaks like \"(\\n句子句子\\n)\" or \"句子\\n.\" are suppressed in",
                "  // `isBreakable(...)`.",
                "  if (",
                "    lineBreakBetweenTheseAndCJConvertsToSpace.has(next.value[0]) ||",
                "    lineBreakBetweenTheseAndCJConvertsToSpace.has(previous.value.at(-1))",
                "  ) {",
                "    return true;",
                "  }",
                "",
                "  // Converting a line break between CJ and non-ASCII punctuation to a space is",
                "  // undesired in many cases. PRs are welcome to fine-tune this logic.",
                "  //",
                "  // Examples where \\n must not be converted to a space:",
                "  //",
                "  // 1. \"〜\" (U+301C, belongs to Pd) in",
                "  //",
                "  //     \"ア〜\\nエの中から1つ選べ。\"",
                "  //",
                "  // 2. \"…\" (U+2026, belongs to Po) in",
                "  //",
                "  //     \"これはひどい……\\nなんと汚いコミットログなんだ……\"",
                "  if (previous.hasTrailingPunctuation || next.hasLeadingPunctuation) {",
                "    return false;",
                "  }",
                "",
                "  // If the sentence uses the style with spaces between CJ and non-CJK, \"\\n\" can",
                "  // be converted to a space.",
                "  return isInSentenceWithCJSpaces(path);",
                "}",
                "",
                "/**",
                " * @param {WordKind | undefined} kind",
                " * @returns {boolean} `true` if `kind` is defined and not CJK punctuation",
                " */",
                "function isLetter(kind) {",
                "  return (",
                "    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER",
                "  );",
                "}",
                "",
                "/**",
                " * @param {WordKind | undefined} kind",
                " * @returns {boolean} `true` if `kind` is Korean letter or non-CJK",
                " */",
                "function isNonCJKOrKoreanLetter(kind) {",
                "  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;",
                "}",
                "",
                "/**",
                " * Check whether whitespace can be printed as a line break.",
                " *",
                " * @param {AstPath} path",
                " * @param {WhitespaceValue} value",
                " * @param {ProseWrap} proseWrap",
                " * @param {boolean} isLink",
                " * @param {boolean} canBeSpace",
                " * @returns {boolean}",
                " */",
                "function isBreakable(path, value, proseWrap, isLink, canBeSpace) {",
                "  if (",
                "    proseWrap !== \"always\" ||",
                "    path.hasAncestor((node) => SINGLE_LINE_NODE_TYPES.has(node.type))",
                "  ) {",
                "    return false;",
                "  }",
                "",
                "  if (isLink) {",
                "    return value !== \"\";",
                "  }",
                "",
                "  // Spaces are always breakable",
                "  if (value === \" \") {",
                "    return true;",
                "  }",
                "",
                "  /** @type {AdjacentNodes} */",
                "  const { previous, next } = path;",
                "",
                "  // Simulates Latin words; see https://github.com/prettier/prettier/issues/6516",
                "  // [Latin][\"\"][Hangul] & vice versa => Don't break",
                "  // [Han & Kana][\"\"][Hangul], either",
                "  if (",
                "    value === \"\" &&",
                "    ((previous?.kind === KIND_K_LETTER && isLetter(next?.kind)) ||",
                "      (next?.kind === KIND_K_LETTER && isLetter(previous?.kind)))",
                "  ) {",
                "    return false;",
                "  }",
                "",
                "  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages",
                "  const violatesCJKLineBreakingRules =",
                "    !canBeSpace &&",
                "    ((next && noBreakBefore.has(next.value[0])) ||",
                "      (previous && noBreakAfter.has(previous.value.at(-1))));",
                "",
                "  if (violatesCJKLineBreakingRules) {",
                "    return false;",
                "  }",
                "",
                "  return true;",
                "}",
                "",
                "/**",
                " * @param {AstPath} path",
                " * @param {WhitespaceValue} value",
                " * @param {ProseWrap} proseWrap",
                " * @param {boolean} [isLink] Special mode of (un)wrapping that preserves the",
                " * normalized form of link labels. https://spec.commonmark.org/0.30/#matches",
                " */",
                "function printWhitespace(path, value, proseWrap, isLink) {",
                "  if (proseWrap === \"preserve\" && value === \"\\n\") {",
                "    return hardline;",
                "  }",
                "",
                "  const canBeSpace =",
                "    value === \" \" ||",
                "    (value === \"\\n\" && lineBreakCanBeConvertedToSpace(path, isLink));",
                "",
                "  if (isBreakable(path, value, proseWrap, isLink, canBeSpace)) {",
                "    return canBeSpace ? line : softline;",
                "  }",
                "",
                "  return canBeSpace ? \" \" : \"\";",
                "}",
                "",
                "export { printWhitespace };"
            ]
        },
        "4": {
            "function_name": "isBreakable (not found) ",
            "file_path": "src/language-markdown/print-whitespace.js",
            "function_details": [
                {
                    "name": "isBreakable",
                    "start_line": 1,
                    "end_line": 291
                }
            ],
            "function_code": [
                "import { hardline, line, softline } from \"../document/builders.js\";",
                "import {",
                "  KIND_CJ_LETTER,",
                "  KIND_CJK_PUNCTUATION,",
                "  KIND_K_LETTER,",
                "  KIND_NON_CJK,",
                "} from \"./utils.js\";",
                "",
                "/**",
                " * @typedef {import(\"./utils.js\").WordNode} WordNode",
                " * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue",
                " * @typedef {import(\"./utils.js\").WordKind} WordKind",
                " * @typedef {import(\"../common/ast-path.js\").default} AstPath",
                " * @typedef {\"always\" | \"never\" | \"preserve\"} ProseWrap",
                " * @typedef {{ next?: WordNode | null, previous?: WordNode | null }}",
                " * AdjacentNodes Nodes adjacent to a `whitespace` node. Are always of type",
                " * `word`.",
                " */",
                "",
                "const SINGLE_LINE_NODE_TYPES = new Set([",
                "  \"heading\",",
                "  \"tableCell\",",
                "  \"link\",",
                "  \"wikiLink\",",
                "]);",
                "",
                "/**",
                " * These characters must not immediately precede a line break.",
                " *",
                " * e.g. `\"（\"`:",
                " *",
                " * - Bad:  `\"檜原村（\\nひのはらむら）\"`",
                " * - Good: `\"檜原村\\n（ひのはらむら）\"` or",
                " *         `\"檜原村（ひ\\nのはらむら）\"`",
                " */",
                "const noBreakAfter = new Set(",
                "  \"$(£¥·'\\\"〈《「『【〔〖〝﹙﹛＄（［｛￡￥[{‵︴︵︷︹︻︽︿﹁﹃﹏〘｟«\",",
                ");",
                "",
                "/**",
                " * These characters must not immediately follow a line break.",
                " *",
                " * e.g. `\"）\"`:",
                " *",
                " * - Bad:  `\"檜原村（ひのはらむら\\n）以外には、\"`",
                " * - Good: `\"檜原村（ひのはらむ\\nら）以外には、\"` or",
                " *         `\"檜原村（ひのはらむら）\\n以外には、\"`",
                " */",
                "const noBreakBefore = new Set(",
                "  \"!%),.:;?]}¢°·'\\\"†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？］｝～–—•〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘︶︸︺︼︾﹀﹂﹗｜､』】〙〟｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠〜～‼⁇⁈⁉・゙゚\",",
                ");",
                "",
                "/**",
                " * A line break between a character from this set and CJ can be converted to a",
                " * space. Includes only ASCII punctuation marks for now.",
                " */",
                "const lineBreakBetweenTheseAndCJConvertsToSpace = new Set(",
                "  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",",
                ");",
                "",
                "/**",
                " * Determine the preferred style of spacing between Chinese or Japanese and non-CJK",
                " * characters in the parent `sentence` node.",
                " *",
                " * @param {AstPath} path",
                " * @returns {boolean} `true` if Space tends to be inserted between CJ and",
                " * non-CJK, `false` otherwise.",
                " */",
                "function isInSentenceWithCJSpaces({ parent: sentenceNode }) {",
                "  if (sentenceNode.usesCJSpaces === undefined) {",
                "    const stats = { \" \": 0, \"\": 0 };",
                "    const { children } = sentenceNode;",
                "",
                "    for (let i = 1; i < children.length - 1; ++i) {",
                "      const node = children[i];",
                "      if (",
                "        node.type === \"whitespace\" &&",
                "        (node.value === \" \" || node.value === \"\")",
                "      ) {",
                "        const previousKind = children[i - 1].kind;",
                "        const nextKind = children[i + 1].kind;",
                "        if (",
                "          (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||",
                "          (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)",
                "        ) {",
                "          ++stats[node.value];",
                "        }",
                "      }",
                "    }",
                "",
                "    // Inject a property to cache the result.",
                "    sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];",
                "  }",
                "",
                "  return sentenceNode.usesCJSpaces;",
                "}",
                "",
                "/**",
                " * Check whether the given `\"\\n\"` node can be converted to a space.",
                " *",
                " * For example, if you would like to squash English text",
                " *",
                " *     \"You might want\\nto use Prettier.\"",
                " *",
                " * into a single line, you would replace `\"\\n\"` with `\" \"`:",
                " *",
                " *     \"You might want to use Prettier.\"",
                " *",
                " * However, Chinese and Japanese don't use U+0020 Space to divide words, so line",
                " * breaks shouldn't be replaced with spaces for those languages.",
                " *",
                " * PRs are welcome to support line breaking rules for other languages.",
                " *",
                " * @param {AstPath} path",
                " * @param {boolean} isLink",
                " * @returns {boolean}",
                " */",
                "function lineBreakCanBeConvertedToSpace(path, isLink) {",
                "  if (isLink) {",
                "    return true;",
                "  }",
                "",
                "  /** @type {AdjacentNodes} */",
                "  const { previous, next } = path;",
                "",
                "  // e.g. \" \\nletter\"",
                "  if (!previous || !next) {",
                "    return true;",
                "  }",
                "",
                "  const previousKind = previous.kind;",
                "  const nextKind = next.kind;",
                "",
                "  if (",
                "    // \"\\n\" between non-CJK or Korean characters always can be converted to a",
                "    // space. Korean Hangul simulates Latin words. See",
                "    // https://github.com/prettier/prettier/issues/6516",
                "    (isNonCJKOrKoreanLetter(previousKind) &&",
                "      isNonCJKOrKoreanLetter(nextKind)) ||",
                "    // Han & Hangul: same way preferred",
                "    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||",
                "    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)",
                "  ) {",
                "    return true;",
                "  }",
                "",
                "  // Do not convert \\n to a space:",
                "  if (",
                "    // around CJK punctuation",
                "    previousKind === KIND_CJK_PUNCTUATION ||",
                "    nextKind === KIND_CJK_PUNCTUATION ||",
                "    // between CJ",
                "    (previousKind === KIND_CJ_LETTER && nextKind === KIND_CJ_LETTER)",
                "  ) {",
                "    return false;",
                "  }",
                "",
                "  // The rest of this function deals only with line breaks between CJ and",
                "  // non-CJK characters.",
                "",
                "  // Convert a line break between CJ and certain non-letter characters (e.g.",
                "  // ASCII punctuation) to a space.",
                "  //",
                "  // E.g. :::\\n句子句子句子\\n::: → ::: 句子句子句子 :::",
                "  //",
                "  // Note: line breaks like \"(\\n句子句子\\n)\" or \"句子\\n.\" are suppressed in",
                "  // `isBreakable(...)`.",
                "  if (",
                "    lineBreakBetweenTheseAndCJConvertsToSpace.has(next.value[0]) ||",
                "    lineBreakBetweenTheseAndCJConvertsToSpace.has(previous.value.at(-1))",
                "  ) {",
                "    return true;",
                "  }",
                "",
                "  // Converting a line break between CJ and non-ASCII punctuation to a space is",
                "  // undesired in many cases. PRs are welcome to fine-tune this logic.",
                "  //",
                "  // Examples where \\n must not be converted to a space:",
                "  //",
                "  // 1. \"〜\" (U+301C, belongs to Pd) in",
                "  //",
                "  //     \"ア〜\\nエの中から1つ選べ。\"",
                "  //",
                "  // 2. \"…\" (U+2026, belongs to Po) in",
                "  //",
                "  //     \"これはひどい……\\nなんと汚いコミットログなんだ……\"",
                "  if (previous.hasTrailingPunctuation || next.hasLeadingPunctuation) {",
                "    return false;",
                "  }",
                "",
                "  // If the sentence uses the style with spaces between CJ and non-CJK, \"\\n\" can",
                "  // be converted to a space.",
                "  return isInSentenceWithCJSpaces(path);",
                "}",
                "",
                "/**",
                " * @param {WordKind | undefined} kind",
                " * @returns {boolean} `true` if `kind` is defined and not CJK punctuation",
                " */",
                "function isLetter(kind) {",
                "  return (",
                "    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER",
                "  );",
                "}",
                "",
                "/**",
                " * @param {WordKind | undefined} kind",
                " * @returns {boolean} `true` if `kind` is Korean letter or non-CJK",
                " */",
                "function isNonCJKOrKoreanLetter(kind) {",
                "  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;",
                "}",
                "",
                "/**",
                " * Check whether whitespace can be printed as a line break.",
                " *",
                " * @param {AstPath} path",
                " * @param {WhitespaceValue} value",
                " * @param {ProseWrap} proseWrap",
                " * @param {boolean} isLink",
                " * @param {boolean} canBeSpace",
                " * @returns {boolean}",
                " */",
                "function isBreakable(path, value, proseWrap, isLink, canBeSpace) {",
                "  if (",
                "    proseWrap !== \"always\" ||",
                "    path.hasAncestor((node) => SINGLE_LINE_NODE_TYPES.has(node.type))",
                "  ) {",
                "    return false;",
                "  }",
                "",
                "  if (isLink) {",
                "    return value !== \"\";",
                "  }",
                "",
                "  // Spaces are always breakable",
                "  if (value === \" \") {",
                "    return true;",
                "  }",
                "",
                "  /** @type {AdjacentNodes} */",
                "  const { previous, next } = path;",
                "",
                "  // Simulates Latin words; see https://github.com/prettier/prettier/issues/6516",
                "  // [Latin][\"\"][Hangul] & vice versa => Don't break",
                "  // [Han & Kana][\"\"][Hangul], either",
                "  if (",
                "    value === \"\" &&",
                "    ((previous?.kind === KIND_K_LETTER && isLetter(next?.kind)) ||",
                "      (next?.kind === KIND_K_LETTER && isLetter(previous?.kind)))",
                "  ) {",
                "    return false;",
                "  }",
                "",
                "  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages",
                "  const violatesCJKLineBreakingRules =",
                "    !canBeSpace &&",
                "    ((next && noBreakBefore.has(next.value[0])) ||",
                "      (previous && noBreakAfter.has(previous.value.at(-1))));",
                "",
                "  if (violatesCJKLineBreakingRules) {",
                "    return false;",
                "  }",
                "",
                "  return true;",
                "}",
                "",
                "/**",
                " * @param {AstPath} path",
                " * @param {WhitespaceValue} value",
                " * @param {ProseWrap} proseWrap",
                " * @param {boolean} [isLink] Special mode of (un)wrapping that preserves the",
                " * normalized form of link labels. https://spec.commonmark.org/0.30/#matches",
                " */",
                "function printWhitespace(path, value, proseWrap, isLink) {",
                "  if (proseWrap === \"preserve\" && value === \"\\n\") {",
                "    return hardline;",
                "  }",
                "",
                "  const canBeSpace =",
                "    value === \" \" ||",
                "    (value === \"\\n\" && lineBreakCanBeConvertedToSpace(path, isLink));",
                "",
                "  if (isBreakable(path, value, proseWrap, isLink, canBeSpace)) {",
                "    return canBeSpace ? line : softline;",
                "  }",
                "",
                "  return canBeSpace ? \" \" : \"\";",
                "}",
                "",
                "export { printWhitespace };"
            ]
        }
    }
}