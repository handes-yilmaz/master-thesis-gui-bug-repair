{
    "1": {
        "bug_file": "src/language-markdown/printer-markdown.js",
        "compressed": "YES",
        "line_numbers": 779,
        "compressed_line_numbers": 106,
        "compressed_bug_file_content": "import collapseWhiteSpace from \"collapse-white-space\";\n\nimport {\n\n\nimport { DOC_TYPE_STRING } from \"../document/constants.js\";\nimport { getDocType, replaceEndOfLine } from \"../document/utils.js\";\nimport getMaxContinuousCount from \"../utils/get-max-continuous-count.js\";\nimport getMinNotPresentContinuousCount from \"../utils/get-min-not-present-continuous-count.js\";\nimport getPreferredQuote from \"../utils/get-preferred-quote.js\";\nimport UnexpectedNodeError from \"../utils/unexpected-node-error.js\";\nimport clean from \"./clean.js\";\nimport { PUNCTUATION_REGEXP } from \"./constants.evaluate.js\";\nimport embed from \"./embed.js\";\nimport getVisitorKeys from \"./get-visitor-keys.js\";\nimport { locEnd, locStart } from \"./loc.js\";\nimport { insertPragma } from \"./pragma.js\";\nimport { printTable } from \"./print/table.js\";\nimport { printParagraph } from \"./print-paragraph.js\";\nimport preprocess from \"./print-preprocess.js\";\nimport { printSentence } from \"./print-sentence.js\";\nimport { printWhitespace } from \"./print-whitespace.js\";\nimport {\n\n\n/**\n * @typedef {import(\"../document/builders.js\").Doc} Doc\n */\n\n\n    /** @type {Doc} */\n\n\n      /* c8 ignore next 3 */\n\n\n        // backslash is parsed as part of autolinks, so we need to remove it\n\n\n        // leading char that may cause different syntax\n\n\n            // <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }\n\n\n        // indented code block\n\n\n      // fenced code block\n\n\n        // @ts-expect-error\n\n\n              /* workaround for https://github.com/remarkjs/remark/issues/315 */ node.hasIndentedCodeblock\n\n\n    // `footnote` requires `.use(footnotes, {inlineNotes: true})`, we are not using this option\n    // https://github.com/remarkjs/remark-footnotes#optionsinlinenotes\n    /* c8 ignore next 2 */\n\n\n    // MDX\n    // fallback to the original text if multiparser failed\n    // or `embeddedLanguageFormatting: \"off\"`\n\n\n      // remark-math trims content but we don't want to remove whitespaces\n      // since it's very possible that it's recognized as math accidentally\n\n\n      /* c8 ignore next */\n\n\n  /** @typedef {{ index: number, offset: number }} IgnorePosition */\n  /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */\n\n\n  /** @type {IgnorePosition | null} */\n\n\n        // do nothing\n\n\n/** @return {false | 'next' | 'start' | 'end'} */\n\n\n      // Check if `listItem` ends with `\\n`\n      // since it can't be empty, so we only need check the last character\n\n\n/**\n * @param {string} url\n * @param {string[] | string} [dangerousCharOrChars]\n * @returns {string}\n */\n\n\n  // title is escaped after `remark-parse` v7\n\n\n// `remark-parse` lowercase the `label` as `identifier`, we don't want do that\n// https://github.com/remarkjs/remark/blob/daddcb463af2d5b2115496c395d0571c0ff87d15/packages/remark-parse/lib/tokenize/reference.js\n\n\nexport default printer;\n"
    },
    "2": {
        "bug_file": "src/language-markdown/print-whitespace.js",
        "compressed": "NO",
        "line_numbers": 291,
        "compressed_line_numbers": 291,
        "compressed_bug_file_content": "import { hardline, line, softline } from \"../document/builders.js\";\nimport {\n  KIND_CJ_LETTER,\n  KIND_CJK_PUNCTUATION,\n  KIND_K_LETTER,\n  KIND_NON_CJK,\n} from \"./utils.js\";\n\n/**\n * @typedef {import(\"./utils.js\").WordNode} WordNode\n * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue\n * @typedef {import(\"./utils.js\").WordKind} WordKind\n * @typedef {import(\"../common/ast-path.js\").default} AstPath\n * @typedef {\"always\" | \"never\" | \"preserve\"} ProseWrap\n * @typedef {{ next?: WordNode | null, previous?: WordNode | null }}\n * AdjacentNodes Nodes adjacent to a `whitespace` node. Are always of type\n * `word`.\n */\n\nconst SINGLE_LINE_NODE_TYPES = new Set([\n  \"heading\",\n  \"tableCell\",\n  \"link\",\n  \"wikiLink\",\n]);\n\n/**\n * These characters must not immediately precede a line break.\n *\n * e.g. `\"（\"`:\n *\n * - Bad:  `\"檜原村（\\nひのはらむら）\"`\n * - Good: `\"檜原村\\n（ひのはらむら）\"` or\n *         `\"檜原村（ひ\\nのはらむら）\"`\n */\nconst noBreakAfter = new Set(\n  \"$(£¥·'\\\"〈《「『【〔〖〝﹙﹛＄（［｛￡￥[{‵︴︵︷︹︻︽︿﹁﹃﹏〘｟«\",\n);\n\n/**\n * These characters must not immediately follow a line break.\n *\n * e.g. `\"）\"`:\n *\n * - Bad:  `\"檜原村（ひのはらむら\\n）以外には、\"`\n * - Good: `\"檜原村（ひのはらむ\\nら）以外には、\"` or\n *         `\"檜原村（ひのはらむら）\\n以外には、\"`\n */\nconst noBreakBefore = new Set(\n  \"!%),.:;?]}¢°·'\\\"†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？］｝～–—•〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘︶︸︺︼︾﹀﹂﹗｜､』】〙〟｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠〜～‼⁇⁈⁉・゙゚\",\n);\n\n/**\n * A line break between a character from this set and CJ can be converted to a\n * space. Includes only ASCII punctuation marks for now.\n */\nconst lineBreakBetweenTheseAndCJConvertsToSpace = new Set(\n  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n);\n\n/**\n * Determine the preferred style of spacing between Chinese or Japanese and non-CJK\n * characters in the parent `sentence` node.\n *\n * @param {AstPath} path\n * @returns {boolean} `true` if Space tends to be inserted between CJ and\n * non-CJK, `false` otherwise.\n */\nfunction isInSentenceWithCJSpaces({ parent: sentenceNode }) {\n  if (sentenceNode.usesCJSpaces === undefined) {\n    const stats = { \" \": 0, \"\": 0 };\n    const { children } = sentenceNode;\n\n    for (let i = 1; i < children.length - 1; ++i) {\n      const node = children[i];\n      if (\n        node.type === \"whitespace\" &&\n        (node.value === \" \" || node.value === \"\")\n      ) {\n        const previousKind = children[i - 1].kind;\n        const nextKind = children[i + 1].kind;\n        if (\n          (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||\n          (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)\n        ) {\n          ++stats[node.value];\n        }\n      }\n    }\n\n    // Inject a property to cache the result.\n    sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];\n  }\n\n  return sentenceNode.usesCJSpaces;\n}\n\n/**\n * Check whether the given `\"\\n\"` node can be converted to a space.\n *\n * For example, if you would like to squash English text\n *\n *     \"You might want\\nto use Prettier.\"\n *\n * into a single line, you would replace `\"\\n\"` with `\" \"`:\n *\n *     \"You might want to use Prettier.\"\n *\n * However, Chinese and Japanese don't use U+0020 Space to divide words, so line\n * breaks shouldn't be replaced with spaces for those languages.\n *\n * PRs are welcome to support line breaking rules for other languages.\n *\n * @param {AstPath} path\n * @param {boolean} isLink\n * @returns {boolean}\n */\nfunction lineBreakCanBeConvertedToSpace(path, isLink) {\n  if (isLink) {\n    return true;\n  }\n\n  /** @type {AdjacentNodes} */\n  const { previous, next } = path;\n\n  // e.g. \" \\nletter\"\n  if (!previous || !next) {\n    return true;\n  }\n\n  const previousKind = previous.kind;\n  const nextKind = next.kind;\n\n  if (\n    // \"\\n\" between non-CJK or Korean characters always can be converted to a\n    // space. Korean Hangul simulates Latin words. See\n    // https://github.com/prettier/prettier/issues/6516\n    (isNonCJKOrKoreanLetter(previousKind) &&\n      isNonCJKOrKoreanLetter(nextKind)) ||\n    // Han & Hangul: same way preferred\n    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||\n    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)\n  ) {\n    return true;\n  }\n\n  // Do not convert \\n to a space:\n  if (\n    // around CJK punctuation\n    previousKind === KIND_CJK_PUNCTUATION ||\n    nextKind === KIND_CJK_PUNCTUATION ||\n    // between CJ\n    (previousKind === KIND_CJ_LETTER && nextKind === KIND_CJ_LETTER)\n  ) {\n    return false;\n  }\n\n  // The rest of this function deals only with line breaks between CJ and\n  // non-CJK characters.\n\n  // Convert a line break between CJ and certain non-letter characters (e.g.\n  // ASCII punctuation) to a space.\n  //\n  // E.g. :::\\n句子句子句子\\n::: → ::: 句子句子句子 :::\n  //\n  // Note: line breaks like \"(\\n句子句子\\n)\" or \"句子\\n.\" are suppressed in\n  // `isBreakable(...)`.\n  if (\n    lineBreakBetweenTheseAndCJConvertsToSpace.has(next.value[0]) ||\n    lineBreakBetweenTheseAndCJConvertsToSpace.has(previous.value.at(-1))\n  ) {\n    return true;\n  }\n\n  // Converting a line break between CJ and non-ASCII punctuation to a space is\n  // undesired in many cases. PRs are welcome to fine-tune this logic.\n  //\n  // Examples where \\n must not be converted to a space:\n  //\n  // 1. \"〜\" (U+301C, belongs to Pd) in\n  //\n  //     \"ア〜\\nエの中から1つ選べ。\"\n  //\n  // 2. \"…\" (U+2026, belongs to Po) in\n  //\n  //     \"これはひどい……\\nなんと汚いコミットログなんだ……\"\n  if (previous.hasTrailingPunctuation || next.hasLeadingPunctuation) {\n    return false;\n  }\n\n  // If the sentence uses the style with spaces between CJ and non-CJK, \"\\n\" can\n  // be converted to a space.\n  return isInSentenceWithCJSpaces(path);\n}\n\n/**\n * @param {WordKind | undefined} kind\n * @returns {boolean} `true` if `kind` is defined and not CJK punctuation\n */\nfunction isLetter(kind) {\n  return (\n    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER\n  );\n}\n\n/**\n * @param {WordKind | undefined} kind\n * @returns {boolean} `true` if `kind` is Korean letter or non-CJK\n */\nfunction isNonCJKOrKoreanLetter(kind) {\n  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;\n}\n\n/**\n * Check whether whitespace can be printed as a line break.\n *\n * @param {AstPath} path\n * @param {WhitespaceValue} value\n * @param {ProseWrap} proseWrap\n * @param {boolean} isLink\n * @param {boolean} canBeSpace\n * @returns {boolean}\n */\nfunction isBreakable(path, value, proseWrap, isLink, canBeSpace) {\n  if (\n    proseWrap !== \"always\" ||\n    path.hasAncestor((node) => SINGLE_LINE_NODE_TYPES.has(node.type))\n  ) {\n    return false;\n  }\n\n  if (isLink) {\n    return value !== \"\";\n  }\n\n  // Spaces are always breakable\n  if (value === \" \") {\n    return true;\n  }\n\n  /** @type {AdjacentNodes} */\n  const { previous, next } = path;\n\n  // Simulates Latin words; see https://github.com/prettier/prettier/issues/6516\n  // [Latin][\"\"][Hangul] & vice versa => Don't break\n  // [Han & Kana][\"\"][Hangul], either\n  if (\n    value === \"\" &&\n    ((previous?.kind === KIND_K_LETTER && isLetter(next?.kind)) ||\n      (next?.kind === KIND_K_LETTER && isLetter(previous?.kind)))\n  ) {\n    return false;\n  }\n\n  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages\n  const violatesCJKLineBreakingRules =\n    !canBeSpace &&\n    ((next && noBreakBefore.has(next.value[0])) ||\n      (previous && noBreakAfter.has(previous.value.at(-1))));\n\n  if (violatesCJKLineBreakingRules) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * @param {AstPath} path\n * @param {WhitespaceValue} value\n * @param {ProseWrap} proseWrap\n * @param {boolean} [isLink] Special mode of (un)wrapping that preserves the\n * normalized form of link labels. https://spec.commonmark.org/0.30/#matches\n */\nfunction printWhitespace(path, value, proseWrap, isLink) {\n  if (proseWrap === \"preserve\" && value === \"\\n\") {\n    return hardline;\n  }\n\n  const canBeSpace =\n    value === \" \" ||\n    (value === \"\\n\" && lineBreakCanBeConvertedToSpace(path, isLink));\n\n  if (isBreakable(path, value, proseWrap, isLink, canBeSpace)) {\n    return canBeSpace ? line : softline;\n  }\n\n  return canBeSpace ? \" \" : \"\";\n}\n\nexport { printWhitespace };"
    }
}