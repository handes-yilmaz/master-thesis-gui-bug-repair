{
    "bug_classes": {
        "1": {
            "class_name": "  (not found) 1-501",
            "file_path": "src/document/doc-printer.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const { getStringWidth } = require(\"../common/util\");",
                "const { convertEndOfLineToChars } = require(\"../common/end-of-line\");",
                "const { concat, fill, cursor } = require(\"./doc-builders\");",
                "",
                "/** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */",
                "let groupModeMap;",
                "",
                "const MODE_BREAK = 1;",
                "const MODE_FLAT = 2;",
                "",
                "function rootIndent() {",
                "  return { value: \"\", length: 0, queue: [] };",
                "}",
                "",
                "function makeIndent(ind, options) {",
                "  return generateInd(ind, { type: \"indent\" }, options);",
                "}",
                "",
                "function makeAlign(ind, n, options) {",
                "  return n === -Infinity",
                "    ? ind.root || rootIndent()",
                "    : n < 0",
                "    ? generateInd(ind, { type: \"dedent\" }, options)",
                "    : !n",
                "    ? ind",
                "    : n.type === \"root\"",
                "    ? { ...ind, root: ind }",
                "    : typeof n === \"string\"",
                "    ? generateInd(ind, { type: \"stringAlign\", n }, options)",
                "    : generateInd(ind, { type: \"numberAlign\", n }, options);",
                "}",
                "",
                "function generateInd(ind, newPart, options) {",
                "  const queue =",
                "    newPart.type === \"dedent\"",
                "      ? ind.queue.slice(0, -1)",
                "      : ind.queue.concat(newPart);",
                "",
                "  let value = \"\";",
                "  let length = 0;",
                "  let lastTabs = 0;",
                "  let lastSpaces = 0;",
                "",
                "  for (const part of queue) {",
                "    switch (part.type) {",
                "      case \"indent\":",
                "        flush();",
                "        if (options.useTabs) {",
                "          addTabs(1);",
                "        } else {",
                "          addSpaces(options.tabWidth);",
                "        }",
                "        break;",
                "      case \"stringAlign\":",
                "        flush();",
                "        value += part.n;",
                "        length += part.n.length;",
                "        break;",
                "      case \"numberAlign\":",
                "        lastTabs += 1;",
                "        lastSpaces += part.n;",
                "        break;",
                "      /* istanbul ignore next */",
                "      default:",
                "        throw new Error(`Unexpected type '${part.type}'`);",
                "    }",
                "  }",
                "",
                "  flushSpaces();",
                "",
                "  return { ...ind, value, length, queue };",
                "",
                "  function addTabs(count) {",
                "    value += \"\\t\".repeat(count);",
                "    length += options.tabWidth * count;",
                "  }",
                "",
                "  function addSpaces(count) {",
                "    value += \" \".repeat(count);",
                "    length += count;",
                "  }",
                "",
                "  function flush() {",
                "    if (options.useTabs) {",
                "      flushTabs();",
                "    } else {",
                "      flushSpaces();",
                "    }",
                "  }",
                "",
                "  function flushTabs() {",
                "    if (lastTabs > 0) {",
                "      addTabs(lastTabs);",
                "    }",
                "    resetLast();",
                "  }",
                "",
                "  function flushSpaces() {",
                "    if (lastSpaces > 0) {",
                "      addSpaces(lastSpaces);",
                "    }",
                "    resetLast();",
                "  }",
                "",
                "  function resetLast() {",
                "    lastTabs = 0;",
                "    lastSpaces = 0;",
                "  }",
                "}",
                "",
                "function trim(out) {",
                "  if (out.length === 0) {",
                "    return 0;",
                "  }",
                "",
                "  let trimCount = 0;",
                "",
                "  // Trim whitespace at the end of line",
                "  while (",
                "    out.length > 0 &&",
                "    typeof out[out.length - 1] === \"string\" &&",
                "    out[out.length - 1].match(/^[\\t ]*$/)",
                "  ) {",
                "    trimCount += out.pop().length;",
                "  }",
                "",
                "  if (out.length && typeof out[out.length - 1] === \"string\") {",
                "    const trimmed = out[out.length - 1].replace(/[\\t ]*$/, \"\");",
                "    trimCount += out[out.length - 1].length - trimmed.length;",
                "    out[out.length - 1] = trimmed;",
                "  }",
                "",
                "  return trimCount;",
                "}",
                "",
                "function fits(next, restCommands, width, options, mustBeFlat) {",
                "  let restIdx = restCommands.length;",
                "  const cmds = [next];",
                "  // `out` is only used for width counting because `trim` requires to look",
                "  // backwards for space characters.",
                "  const out = [];",
                "  while (width >= 0) {",
                "    if (cmds.length === 0) {",
                "      if (restIdx === 0) {",
                "        return true;",
                "      }",
                "      cmds.push(restCommands[restIdx - 1]);",
                "",
                "      restIdx--;",
                "",
                "      continue;",
                "    }",
                "",
                "    const [ind, mode, doc] = cmds.pop();",
                "",
                "    if (typeof doc === \"string\") {",
                "      out.push(doc);",
                "",
                "      width -= getStringWidth(doc);",
                "    } else {",
                "      switch (doc.type) {",
                "        case \"concat\":",
                "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                "            cmds.push([ind, mode, doc.parts[i]]);",
                "          }",
                "",
                "          break;",
                "        case \"indent\":",
                "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                "",
                "          break;",
                "        case \"align\":",
                "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                "",
                "          break;",
                "        case \"trim\":",
                "          width += trim(out);",
                "",
                "          break;",
                "        case \"group\":",
                "          if (mustBeFlat && doc.break) {",
                "            return false;",
                "          }",
                "          cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);",
                "",
                "          if (doc.id) {",
                "            groupModeMap[doc.id] = cmds[cmds.length - 1][1];",
                "          }",
                "          break;",
                "        case \"fill\":",
                "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                "            cmds.push([ind, mode, doc.parts[i]]);",
                "          }",
                "",
                "          break;",
                "        case \"if-break\": {",
                "          const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                "          if (groupMode === MODE_BREAK) {",
                "            if (doc.breakContents) {",
                "              cmds.push([ind, mode, doc.breakContents]);",
                "            }",
                "          }",
                "          if (groupMode === MODE_FLAT) {",
                "            if (doc.flatContents) {",
                "              cmds.push([ind, mode, doc.flatContents]);",
                "            }",
                "          }",
                "",
                "          break;",
                "        }",
                "        case \"line\":",
                "          switch (mode) {",
                "            // fallthrough",
                "            case MODE_FLAT:",
                "              if (!doc.hard) {",
                "                if (!doc.soft) {",
                "                  out.push(\" \");",
                "",
                "                  width -= 1;",
                "                }",
                "",
                "                break;",
                "              }",
                "              return true;",
                "",
                "            case MODE_BREAK:",
                "              return true;",
                "          }",
                "          break;",
                "      }",
                "    }",
                "  }",
                "  return false;",
                "}",
                "",
                "function printDocToString(doc, options) {",
                "  groupModeMap = {};",
                "",
                "  const width = options.printWidth;",
                "  const newLine = convertEndOfLineToChars(options.endOfLine);",
                "  let pos = 0;",
                "  // cmds is basically a stack. We've turned a recursive call into a",
                "  // while loop which is much faster. The while loop below adds new",
                "  // cmds to the array instead of recursively calling `print`.",
                "  const cmds = [[rootIndent(), MODE_BREAK, doc]];",
                "  const out = [];",
                "  let shouldRemeasure = false;",
                "  let lineSuffix = [];",
                "",
                "  while (cmds.length !== 0) {",
                "    const [ind, mode, doc] = cmds.pop();",
                "",
                "    if (typeof doc === \"string\") {",
                "      const formatted =",
                "        newLine !== \"\\n\" && doc.includes(\"\\n\")",
                "          ? doc.replace(/\\n/g, newLine)",
                "          : doc;",
                "      out.push(formatted);",
                "      pos += getStringWidth(formatted);",
                "    } else {",
                "      switch (doc.type) {",
                "        case \"cursor\":",
                "          out.push(cursor.placeholder);",
                "",
                "          break;",
                "        case \"concat\":",
                "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                "            cmds.push([ind, mode, doc.parts[i]]);",
                "          }",
                "",
                "          break;",
                "        case \"indent\":",
                "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                "",
                "          break;",
                "        case \"align\":",
                "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                "",
                "          break;",
                "        case \"trim\":",
                "          pos -= trim(out);",
                "",
                "          break;",
                "        case \"group\":",
                "          switch (mode) {",
                "            case MODE_FLAT:",
                "              if (!shouldRemeasure) {",
                "                cmds.push([",
                "                  ind,",
                "                  doc.break ? MODE_BREAK : MODE_FLAT,",
                "                  doc.contents,",
                "                ]);",
                "",
                "                break;",
                "              }",
                "            // fallthrough",
                "",
                "            case MODE_BREAK: {",
                "              shouldRemeasure = false;",
                "",
                "              const next = [ind, MODE_FLAT, doc.contents];",
                "              const rem = width - pos;",
                "",
                "              if (!doc.break && fits(next, cmds, rem, options)) {",
                "                cmds.push(next);",
                "              } else {",
                "                // Expanded states are a rare case where a document",
                "                // can manually provide multiple representations of",
                "                // itself. It provides an array of documents",
                "                // going from the least expanded (most flattened)",
                "                // representation first to the most expanded. If a",
                "                // group has these, we need to manually go through",
                "                // these states and find the first one that fits.",
                "                if (doc.expandedStates) {",
                "                  const mostExpanded =",
                "                    doc.expandedStates[doc.expandedStates.length - 1];",
                "",
                "                  if (doc.break) {",
                "                    cmds.push([ind, MODE_BREAK, mostExpanded]);",
                "",
                "                    break;",
                "                  } else {",
                "                    for (let i = 1; i < doc.expandedStates.length + 1; i++) {",
                "                      if (i >= doc.expandedStates.length) {",
                "                        cmds.push([ind, MODE_BREAK, mostExpanded]);",
                "",
                "                        break;",
                "                      } else {",
                "                        const state = doc.expandedStates[i];",
                "                        const cmd = [ind, MODE_FLAT, state];",
                "",
                "                        if (fits(cmd, cmds, rem, options)) {",
                "                          cmds.push(cmd);",
                "",
                "                          break;",
                "                        }",
                "                      }",
                "                    }",
                "                  }",
                "                } else {",
                "                  cmds.push([ind, MODE_BREAK, doc.contents]);",
                "                }",
                "              }",
                "",
                "              break;",
                "            }",
                "          }",
                "",
                "          if (doc.id) {",
                "            groupModeMap[doc.id] = cmds[cmds.length - 1][1];",
                "          }",
                "          break;",
                "        // Fills each line with as much code as possible before moving to a new",
                "        // line with the same indentation.",
                "        //",
                "        // Expects doc.parts to be an array of alternating content and",
                "        // whitespace. The whitespace contains the linebreaks.",
                "        //",
                "        // For example:",
                "        //   [\"I\", line, \"love\", line, \"monkeys\"]",
                "        // or",
                "        //   [{ type: group, ... }, softline, { type: group, ... }]",
                "        //",
                "        // It uses this parts structure to handle three main layout cases:",
                "        // * The first two content items fit on the same line without",
                "        //   breaking",
                "        //   -> output the first content item and the whitespace \"flat\".",
                "        // * Only the first content item fits on the line without breaking",
                "        //   -> output the first content item \"flat\" and the whitespace with",
                "        //   \"break\".",
                "        // * Neither content item fits on the line without breaking",
                "        //   -> output the first content item and the whitespace with \"break\".",
                "        case \"fill\": {",
                "          const rem = width - pos;",
                "",
                "          const { parts } = doc;",
                "          if (parts.length === 0) {",
                "            break;",
                "          }",
                "",
                "          const [content, whitespace] = parts;",
                "          const contentFlatCmd = [ind, MODE_FLAT, content];",
                "          const contentBreakCmd = [ind, MODE_BREAK, content];",
                "          const contentFits = fits(contentFlatCmd, [], rem, options, true);",
                "",
                "          if (parts.length === 1) {",
                "            if (contentFits) {",
                "              cmds.push(contentFlatCmd);",
                "            } else {",
                "              cmds.push(contentBreakCmd);",
                "            }",
                "            break;",
                "          }",
                "",
                "          const whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];",
                "          const whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];",
                "",
                "          if (parts.length === 2) {",
                "            if (contentFits) {",
                "              cmds.push(whitespaceFlatCmd);",
                "              cmds.push(contentFlatCmd);",
                "            } else {",
                "              cmds.push(whitespaceBreakCmd);",
                "              cmds.push(contentBreakCmd);",
                "            }",
                "            break;",
                "          }",
                "",
                "          // At this point we've handled the first pair (context, separator)",
                "          // and will create a new fill doc for the rest of the content.",
                "          // Ideally we wouldn't mutate the array here but copying all the",
                "          // elements to a new array would make this algorithm quadratic,",
                "          // which is unusable for large arrays (e.g. large texts in JSX).",
                "          parts.splice(0, 2);",
                "          const remainingCmd = [ind, mode, fill(parts)];",
                "",
                "          const secondContent = parts[0];",
                "",
                "          const firstAndSecondContentFlatCmd = [",
                "            ind,",
                "            MODE_FLAT,",
                "            concat([content, whitespace, secondContent]),",
                "          ];",
                "          const firstAndSecondContentFits = fits(",
                "            firstAndSecondContentFlatCmd,",
                "            [],",
                "            rem,",
                "            options,",
                "            true",
                "          );",
                "",
                "          if (firstAndSecondContentFits) {",
                "            cmds.push(remainingCmd);",
                "            cmds.push(whitespaceFlatCmd);",
                "            cmds.push(contentFlatCmd);",
                "          } else if (contentFits) {",
                "            cmds.push(remainingCmd);",
                "            cmds.push(whitespaceBreakCmd);",
                "            cmds.push(contentFlatCmd);",
                "          } else {",
                "            cmds.push(remainingCmd);",
                "            cmds.push(whitespaceBreakCmd);",
                "            cmds.push(contentBreakCmd);",
                "          }",
                "          break;",
                "        }",
                "        case \"if-break\": {",
                "          const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                "          if (groupMode === MODE_BREAK) {",
                "            if (doc.breakContents) {",
                "              cmds.push([ind, mode, doc.breakContents]);",
                "            }",
                "          }",
                "          if (groupMode === MODE_FLAT) {",
                "            if (doc.flatContents) {",
                "              cmds.push([ind, mode, doc.flatContents]);",
                "            }",
                "          }",
                "",
                "          break;",
                "        }",
                "        case \"line-suffix\":",
                "          lineSuffix.push([ind, mode, doc.contents]);",
                "          break;",
                "        case \"line-suffix-boundary\":",
                "          if (lineSuffix.length > 0) {",
                "            cmds.push([ind, mode, { type: \"line\", hard: true }]);",
                "          }",
                "          break;",
                "        case \"line\":",
                "          switch (mode) {",
                "            case MODE_FLAT:",
                "              if (!doc.hard) {",
                "                if (!doc.soft) {",
                "                  out.push(\" \");",
                "",
                "                  pos += 1;",
                "                }",
                "",
                "                break;",
                "              } else {",
                "                // This line was forced into the output even if we",
                "                // were in flattened mode, so we need to tell the next",
                "                // group that no matter what, it needs to remeasure",
                "                // because the previous measurement didn't accurately",
                "                // capture the entire expression (this is necessary",
                "                // for nested groups)",
                "                shouldRemeasure = true;",
                "              }",
                "            // fallthrough",
                "",
                "            case MODE_BREAK:",
                "              if (lineSuffix.length) {",
                "                cmds.push([ind, mode, doc]);",
                "                cmds.push(...lineSuffix.reverse());",
                "                lineSuffix = [];",
                "                break;",
                "              }",
                ""
            ]
        }
    },
    "bug_functions": {
        "2": {
            "function_name": "parse (not found) 437-937",
            "file_path": "src/language-js/printer-estree.js",
            "function_details": [
                {
                    "name": "parse",
                    "start_line": 437,
                    "end_line": 937
                }
            ],
            "function_code": [
                "      // Print @babel/parser's InterpreterDirective here so that",
                "      // leading comments on the `Program` node get printed after the hashbang.",
                "      if (n.program && n.program.interpreter) {",
                "        parts.push(",
                "          path.call(",
                "            (programPath) => programPath.call(print, \"interpreter\"),",
                "            \"program\"",
                "          )",
                "        );",
                "      }",
                "",
                "      parts.push(path.call(print, \"program\"));",
                "",
                "      return concat(parts);",
                "",
                "    case \"Program\":",
                "      // Babel 6",
                "      if (n.directives) {",
                "        path.each((childPath) => {",
                "          parts.push(print(childPath), semi, hardline);",
                "          if (",
                "            isNextLineEmpty(",
                "              options.originalText,",
                "              childPath.getValue(),",
                "              options.locEnd",
                "            )",
                "          ) {",
                "            parts.push(hardline);",
                "          }",
                "        }, \"directives\");",
                "      }",
                "",
                "      parts.push(",
                "        path.call((bodyPath) => {",
                "          return printStatementSequence(bodyPath, options, print);",
                "        }, \"body\")",
                "      );",
                "",
                "      parts.push(",
                "        comments.printDanglingComments(path, options, /* sameIndent */ true)",
                "      );",
                "",
                "      // Only force a trailing newline if there were any contents.",
                "      if (",
                "        !n.body.every(({ type }) => type === \"EmptyStatement\") ||",
                "        n.comments",
                "      ) {",
                "        parts.push(hardline);",
                "      }",
                "",
                "      return concat(parts);",
                "    // Babel extension.",
                "    case \"EmptyStatement\":",
                "      return \"\";",
                "    case \"ExpressionStatement\":",
                "      // Detect Flow and TypeScript directives",
                "      if (n.directive) {",
                "        return concat([nodeStr(n.expression, options, true), semi]);",
                "      }",
                "",
                "      if (options.parser === \"__vue_event_binding\") {",
                "        const parent = path.getParentNode();",
                "        if (",
                "          parent.type === \"Program\" &&",
                "          parent.body.length === 1 &&",
                "          parent.body[0] === n",
                "        ) {",
                "          return concat([",
                "            path.call(print, \"expression\"),",
                "            isVueEventBindingExpression(n.expression) ? \";\" : \"\",",
                "          ]);",
                "        }",
                "      }",
                "",
                "      // Do not append semicolon after the only JSX element in a program",
                "      return concat([",
                "        path.call(print, \"expression\"),",
                "        isTheOnlyJSXElementInMarkdown(options, path) ? \"\" : semi,",
                "      ]);",
                "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
                "    case \"ParenthesizedExpression\": {",
                "      const shouldHug = !n.expression.comments;",
                "      if (shouldHug) {",
                "        return concat([\"(\", path.call(print, \"expression\"), \")\"]);",
                "      }",
                "      return group(",
                "        concat([",
                "          \"(\",",
                "          indent(concat([softline, path.call(print, \"expression\")])),",
                "          softline,",
                "          \")\",",
                "        ])",
                "      );",
                "    }",
                "    case \"AssignmentExpression\":",
                "      return printAssignment(",
                "        n.left,",
                "        path.call(print, \"left\"),",
                "        concat([\" \", n.operator]),",
                "        n.right,",
                "        path.call(print, \"right\"),",
                "        options",
                "      );",
                "    case \"BinaryExpression\":",
                "    case \"LogicalExpression\":",
                "    case \"NGPipeExpression\": {",
                "      const parent = path.getParentNode();",
                "      const parentParent = path.getParentNode(1);",
                "      const isInsideParenthesis =",
                "        n !== parent.body &&",
                "        (parent.type === \"IfStatement\" ||",
                "          parent.type === \"WhileStatement\" ||",
                "          parent.type === \"SwitchStatement\" ||",
                "          parent.type === \"DoWhileStatement\");",
                "",
                "      const parts = printBinaryishExpressions(",
                "        path,",
                "        print,",
                "        options,",
                "        /* isNested */ false,",
                "        isInsideParenthesis",
                "      );",
                "",
                "      //   if (",
                "      //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft",
                "      //   ) {",
                "      //",
                "      // looks super weird, we want to break the children if the parent breaks",
                "      //",
                "      //   if (",
                "      //     this.hasPlugin(\"dynamicImports\") &&",
                "      //     this.lookahead().type === tt.parenLeft",
                "      //   ) {",
                "      if (isInsideParenthesis) {",
                "        return concat(parts);",
                "      }",
                "",
                "      // Break between the parens in",
                "      // unaries or in a member or specific call expression, i.e.",
                "      //",
                "      //   (",
                "      //     a &&",
                "      //     b &&",
                "      //     c",
                "      //   ).call()",
                "      if (",
                "        ((parent.type === \"CallExpression\" ||",
                "          parent.type === \"OptionalCallExpression\") &&",
                "          parent.callee === n) ||",
                "        parent.type === \"UnaryExpression\" ||",
                "        ((parent.type === \"MemberExpression\" ||",
                "          parent.type === \"OptionalMemberExpression\") &&",
                "          !parent.computed)",
                "      ) {",
                "        return group(",
                "          concat([indent(concat([softline, concat(parts)])), softline])",
                "        );",
                "      }",
                "",
                "      // Avoid indenting sub-expressions in some cases where the first sub-expression is already",
                "      // indented accordingly. We should indent sub-expressions where the first case isn't indented.",
                "      const shouldNotIndent =",
                "        parent.type === \"ReturnStatement\" ||",
                "        parent.type === \"ThrowStatement\" ||",
                "        (parent.type === \"JSXExpressionContainer\" &&",
                "          parentParent.type === \"JSXAttribute\") ||",
                "        (n.operator !== \"|\" && parent.type === \"JsExpressionRoot\") ||",
                "        (n.type !== \"NGPipeExpression\" &&",
                "          ((parent.type === \"NGRoot\" && options.parser === \"__ng_binding\") ||",
                "            (parent.type === \"NGMicrosyntaxExpression\" &&",
                "              parentParent.type === \"NGMicrosyntax\" &&",
                "              parentParent.body.length === 1))) ||",
                "        (n === parent.body && parent.type === \"ArrowFunctionExpression\") ||",
                "        (n !== parent.body && parent.type === \"ForStatement\") ||",
                "        (parent.type === \"ConditionalExpression\" &&",
                "          parentParent.type !== \"ReturnStatement\" &&",
                "          parentParent.type !== \"ThrowStatement\" &&",
                "          parentParent.type !== \"CallExpression\" &&",
                "          parentParent.type !== \"OptionalCallExpression\") ||",
                "        parent.type === \"TemplateLiteral\";",
                "",
                "      const shouldIndentIfInlining =",
                "        parent.type === \"AssignmentExpression\" ||",
                "        parent.type === \"VariableDeclarator\" ||",
                "        parent.type === \"ClassProperty\" ||",
                "        parent.type === \"TSAbstractClassProperty\" ||",
                "        parent.type === \"ClassPrivateProperty\" ||",
                "        parent.type === \"ObjectProperty\" ||",
                "        parent.type === \"Property\";",
                "",
                "      const samePrecedenceSubExpression =",
                "        isBinaryish(n.left) && shouldFlatten(n.operator, n.left.operator);",
                "",
                "      if (",
                "        shouldNotIndent ||",
                "        (shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression) ||",
                "        (!shouldInlineLogicalExpression(n) && shouldIndentIfInlining)",
                "      ) {",
                "        return group(concat(parts));",
                "      }",
                "",
                "      if (parts.length === 0) {",
                "        return \"\";",
                "      }",
                "",
                "      // If the right part is a JSX node, we include it in a separate group to",
                "      // prevent it breaking the whole chain, so we can print the expression like:",
                "      //",
                "      //   foo && bar && (",
                "      //     <Foo>",
                "      //       <Bar />",
                "      //     </Foo>",
                "      //   )",
                "",
                "      const hasJSX = isJSXNode(n.right);",
                "      const firstGroupIndex = parts.findIndex((part) => part.type === \"group\");",
                "      // Separate the leftmost expression, possibly with its leading comments.",
                "      const headParts = parts.slice(",
                "        0,",
                "        firstGroupIndex === -1 ? 1 : firstGroupIndex + 1",
                "      );",
                "      const rest = concat(",
                "        parts.slice(headParts.length, hasJSX ? -1 : undefined)",
                "      );",
                "",
                "      const groupId = Symbol(\"logicalChain-\" + ++uid);",
                "      const chain = group(",
                "        concat([",
                "          // Don't include the initial expression in the indentation",
                "          // level. The first item is guaranteed to be the first",
                "          // left-most expression.",
                "          ...headParts,",
                "          indent(rest),",
                "        ]),",
                "        { id: groupId }",
                "      );",
                "",
                "      if (!hasJSX) {",
                "        return chain;",
                "      }",
                "",
                "      const jsxPart = getLast(parts);",
                "      return group(",
                "        concat([chain, ifBreak(indent(jsxPart), jsxPart, { groupId })])",
                "      );",
                "    }",
                "    case \"AssignmentPattern\":",
                "      return concat([",
                "        path.call(print, \"left\"),",
                "        \" = \",",
                "        path.call(print, \"right\"),",
                "      ]);",
                "    case \"TSTypeAssertion\": {",
                "      const shouldBreakAfterCast = !(",
                "        n.expression.type === \"ArrayExpression\" ||",
                "        n.expression.type === \"ObjectExpression\"",
                "      );",
                "",
                "      const castGroup = group(",
                "        concat([",
                "          \"<\",",
                "          indent(concat([softline, path.call(print, \"typeAnnotation\")])),",
                "          softline,",
                "          \">\",",
                "        ])",
                "      );",
                "",
                "      const exprContents = concat([",
                "        ifBreak(\"(\"),",
                "        indent(concat([softline, path.call(print, \"expression\")])),",
                "        softline,",
                "        ifBreak(\")\"),",
                "      ]);",
                "",
                "      if (shouldBreakAfterCast) {",
                "        return conditionalGroup([",
                "          concat([castGroup, path.call(print, \"expression\")]),",
                "          concat([castGroup, group(exprContents, { shouldBreak: true })]),",
                "          concat([castGroup, path.call(print, \"expression\")]),",
                "        ]);",
                "      }",
                "      return group(concat([castGroup, path.call(print, \"expression\")]));",
                "    }",
                "    case \"OptionalMemberExpression\":",
                "    case \"MemberExpression\": {",
                "      const parent = path.getParentNode();",
                "      let firstNonMemberParent;",
                "      let i = 0;",
                "      do {",
                "        firstNonMemberParent = path.getParentNode(i);",
                "        i++;",
                "      } while (",
                "        firstNonMemberParent &&",
                "        (firstNonMemberParent.type === \"MemberExpression\" ||",
                "          firstNonMemberParent.type === \"OptionalMemberExpression\" ||",
                "          firstNonMemberParent.type === \"TSNonNullExpression\")",
                "      );",
                "",
                "      const shouldInline =",
                "        (firstNonMemberParent &&",
                "          (firstNonMemberParent.type === \"NewExpression\" ||",
                "            firstNonMemberParent.type === \"BindExpression\" ||",
                "            (firstNonMemberParent.type === \"VariableDeclarator\" &&",
                "              firstNonMemberParent.id.type !== \"Identifier\") ||",
                "            (firstNonMemberParent.type === \"AssignmentExpression\" &&",
                "              firstNonMemberParent.left.type !== \"Identifier\"))) ||",
                "        n.computed ||",
                "        (n.object.type === \"Identifier\" &&",
                "          n.property.type === \"Identifier\" &&",
                "          parent.type !== \"MemberExpression\" &&",
                "          parent.type !== \"OptionalMemberExpression\");",
                "",
                "      return concat([",
                "        path.call(print, \"object\"),",
                "        shouldInline",
                "          ? printMemberLookup(path, options, print)",
                "          : group(",
                "              indent(",
                "                concat([softline, printMemberLookup(path, options, print)])",
                "              )",
                "            ),",
                "      ]);",
                "    }",
                "    case \"MetaProperty\":",
                "      return concat([",
                "        path.call(print, \"meta\"),",
                "        \".\",",
                "        path.call(print, \"property\"),",
                "      ]);",
                "    case \"BindExpression\":",
                "      if (n.object) {",
                "        parts.push(path.call(print, \"object\"));",
                "      }",
                "",
                "      parts.push(",
                "        group(",
                "          indent(",
                "            concat([softline, printBindExpressionCallee(path, options, print)])",
                "          )",
                "        )",
                "      );",
                "",
                "      return concat(parts);",
                "    case \"Identifier\": {",
                "      return concat([",
                "        n.name,",
                "        printOptionalToken(path),",
                "        printTypeAnnotation(path, options, print),",
                "      ]);",
                "    }",
                "    case \"V8IntrinsicIdentifier\":",
                "      return concat([\"%\", n.name]);",
                "    case \"SpreadElement\":",
                "    case \"SpreadElementPattern\":",
                "    case \"SpreadProperty\":",
                "    case \"SpreadPropertyPattern\":",
                "    case \"RestElement\":",
                "    case \"ObjectTypeSpreadProperty\":",
                "      return concat([",
                "        \"...\",",
                "        path.call(print, \"argument\"),",
                "        printTypeAnnotation(path, options, print),",
                "      ]);",
                "    case \"FunctionDeclaration\":",
                "    case \"FunctionExpression\":",
                "      parts.push(printFunctionDeclaration(path, print, options));",
                "      if (!n.body) {",
                "        parts.push(semi);",
                "      }",
                "      return concat(parts);",
                "    case \"ArrowFunctionExpression\": {",
                "      if (n.async) {",
                "        parts.push(\"async \");",
                "      }",
                "",
                "      if (shouldPrintParamsWithoutParens(path, options)) {",
                "        parts.push(path.call(print, \"params\", 0));",
                "      } else {",
                "        parts.push(",
                "          group(",
                "            concat([",
                "              printFunctionParams(",
                "                path,",
                "                print,",
                "                options,",
                "                /* expandLast */ args &&",
                "                  (args.expandLastArg || args.expandFirstArg),",
                "                /* printTypeParams */ true",
                "              ),",
                "              printReturnType(path, print, options),",
                "            ])",
                "          )",
                "        );",
                "      }",
                "",
                "      const dangling = comments.printDanglingComments(",
                "        path,",
                "        options,",
                "        /* sameIndent */ true,",
                "        (comment) => {",
                "          const nextCharacter = getNextNonSpaceNonCommentCharacterIndex(",
                "            options.originalText,",
                "            comment,",
                "            options.locEnd",
                "          );",
                "          return (",
                "            options.originalText.slice(nextCharacter, nextCharacter + 2) ===",
                "            \"=>\"",
                "          );",
                "        }",
                "      );",
                "      if (dangling) {",
                "        parts.push(\" \", dangling);",
                "      }",
                "",
                "      parts.push(\" =>\");",
                "",
                "      const body = path.call((bodyPath) => print(bodyPath, args), \"body\");",
                "",
                "      // We want to always keep these types of nodes on the same line",
                "      // as the arrow.",
                "      if (",
                "        !hasLeadingOwnLineComment(options.originalText, n.body, options) &&",
                "        (n.body.type === \"ArrayExpression\" ||",
                "          n.body.type === \"ObjectExpression\" ||",
                "          n.body.type === \"BlockStatement\" ||",
                "          isJSXNode(n.body) ||",
                "          isTemplateOnItsOwnLine(n.body, options.originalText, options) ||",
                "          n.body.type === \"ArrowFunctionExpression\" ||",
                "          n.body.type === \"DoExpression\")",
                "      ) {",
                "        return group(concat([concat(parts), \" \", body]));",
                "      }",
                "",
                "      // We handle sequence expressions as the body of arrows specially,",
                "      // so that the required parentheses end up on their own lines.",
                "      if (n.body.type === \"SequenceExpression\") {",
                "        return group(",
                "          concat([",
                "            concat(parts),",
                "            group(",
                "              concat([\" (\", indent(concat([softline, body])), softline, \")\"])",
                "            ),",
                "          ])",
                "        );",
                "      }",
                "",
                "      // if the arrow function is expanded as last argument, we are adding a",
                "      // level of indentation and need to add a softline to align the closing )",
                "      // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)",
                "      // we should align the expression's closing } with the line with the opening {.",
                "      const shouldAddSoftLine =",
                "        ((args && args.expandLastArg) ||",
                "          path.getParentNode().type === \"JSXExpressionContainer\") &&",
                "        !(n.comments && n.comments.length);",
                "",
                "      const printTrailingComma =",
                "        args && args.expandLastArg && shouldPrintComma(options, \"all\");",
                "",
                "      // In order to avoid confusion between",
                "      // a => a ? a : a",
                "      // a <= a ? a : a",
                "      const shouldAddParens =",
                "        n.body.type === \"ConditionalExpression\" &&",
                "        !startsWithNoLookaheadToken(n.body, /* forbidFunctionAndClass */ false);",
                "",
                "      return group(",
                "        concat([",
                "          concat(parts),",
                "          group(",
                "            concat([",
                "              indent(",
                "                concat([",
                "                  line,",
                "                  shouldAddParens ? ifBreak(\"\", \"(\") : \"\",",
                "                  body,",
                "                  shouldAddParens ? ifBreak(\"\", \")\") : \"\",",
                "                ])",
                "              ),",
                "              shouldAddSoftLine",
                "                ? concat([ifBreak(printTrailingComma ? \",\" : \"\"), softline])",
                "                : \"\",",
                "            ])",
                "          ),",
                "        ])",
                "      );",
                "    }",
                "    case \"YieldExpression\":",
                "      parts.push(\"yield\");",
                "",
                "      if (n.delegate) {",
                "        parts.push(\"*\");",
                "      }",
                "      if (n.argument) {",
                "        parts.push(\" \", path.call(print, \"argument\"));",
                "      }",
                "",
                "      return concat(parts);",
                "    case \"AwaitExpression\": {",
                "      parts.push(\"await\");",
                "      if (n.argument) {"
            ]
        }
    }
}