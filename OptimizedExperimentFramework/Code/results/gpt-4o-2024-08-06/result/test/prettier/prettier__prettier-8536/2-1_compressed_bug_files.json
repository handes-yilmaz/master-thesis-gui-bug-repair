{
    "1": {
        "bug_file": "src/document/doc-printer.js",
        "compressed": "YES",
        "line_numbers": 545,
        "compressed_line_numbers": 75,
        "compressed_bug_file_content": "\n\n/** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */\n\n\n      /* istanbul ignore next */\n\n\n  // Trim whitespace at the end of line\n\n\n  // `out` is only used for width counting because `trim` requires to look\n  // backwards for space characters.\n\n\n            // fallthrough\n\n\n  // cmds is basically a stack. We've turned a recursive call into a\n  // while loop which is much faster. The while loop below adds new\n  // cmds to the array instead of recursively calling `print`.\n\n\n            // fallthrough\n\n\n                // Expanded states are a rare case where a document\n                // can manually provide multiple representations of\n                // itself. It provides an array of documents\n                // going from the least expanded (most flattened)\n                // representation first to the most expanded. If a\n                // group has these, we need to manually go through\n                // these states and find the first one that fits.\n\n\n        // Fills each line with as much code as possible before moving to a new\n        // line with the same indentation.\n        //\n        // Expects doc.parts to be an array of alternating content and\n        // whitespace. The whitespace contains the linebreaks.\n        //\n        // For example:\n        //   [\"I\", line, \"love\", line, \"monkeys\"]\n        // or\n        //   [{ type: group, ... }, softline, { type: group, ... }]\n        //\n        // It uses this parts structure to handle three main layout cases:\n        // * The first two content items fit on the same line without\n        //   breaking\n        //   -> output the first content item and the whitespace \"flat\".\n        // * Only the first content item fits on the line without breaking\n        //   -> output the first content item \"flat\" and the whitespace with\n        //   \"break\".\n        // * Neither content item fits on the line without breaking\n        //   -> output the first content item and the whitespace with \"break\".\n\n\n          // At this point we've handled the first pair (context, separator)\n          // and will create a new fill doc for the rest of the content.\n          // Ideally we wouldn't mutate the array here but copying all the\n          // elements to a new array would make this algorithm quadratic,\n          // which is unusable for large arrays (e.g. large texts in JSX).\n\n\n                // This line was forced into the output even if we\n                // were in flattened mode, so we need to tell the next\n                // group that no matter what, it needs to remeasure\n                // because the previous measurement didn't accurately\n                // capture the entire expression (this is necessary\n                // for nested groups)\n\n\n            // fallthrough\n\n\n"
    },
    "2": {
        "bug_file": "src/language-js/printer-estree.js",
        "compressed": "YES",
        "line_numbers": 5396,
        "compressed_line_numbers": 712,
        "compressed_bug_file_content": "\n\n// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\n\n\n    // their decorators are handled themselves\n\n\n    // If the parent node is an export declaration and the decorator\n    // was written before the export, the export will be responsible\n    // for printing the decorators.\n\n\n    // Only print decorators here if they were written before the export,\n    // otherwise they are printed by the node.declaration\n\n\n    // Export declarations are responsible for printing any decorators\n    // that logically apply to node.declaration.\n\n\n    // Nodes with decorators can't have parentheses, so we can avoid\n    // computing pathNeedsParens() except in this case.\n\n\n/**\n * The following is the shared logic for\n * ternary operators, namely ConditionalExpression\n * and TSConditionalType\n * @typedef {Object} OperatorOptions\n * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.\n * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.\n * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.\n * @property {string} conditionalNodeType - The type of the conditional expression node, ie \"ConditionalExpression\" or \"TSConditionalType\".\n * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg \"consequent\".\n * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg \"alternate\".\n * @property {string[]} testNodePropertyNames - The properties at which the test nodes can be found on the main node, eg \"test\".\n * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.\n * @param {Options} options - Prettier options\n * @param {Function} print - Print function to call recursively\n * @param {OperatorOptions} operatorOptions\n * @returns Doc\n */\n\n\n  // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".\n  // See tests/jsx/conditional-expression.js for more info.\n\n\n  // Find the outermost non-ConditionalExpression parent, and the outermost\n  // ConditionalExpression parent. We'll use these to determine if we should\n  // print in JSX mode.\n\n\n    // Even though they don't need parens, we wrap (almost) everything in\n    // parens when using ?: within JSX, because the parens are analogous to\n    // curly braces in an if statement.\n\n\n    // The only things we don't wrap are:\n    // * Nested conditional expressions in alternates\n    // * null\n    // * undefined\n\n\n    // normal mode\n\n\n  // We want a whole chain of ConditionalExpressions to all\n  // break if any of them break. That means we should only group around the\n  // outer-most ConditionalExpression.\n\n\n  // Break the closing paren to keep the chain right after it:\n  // (a\n  //   ? b\n  //   : c\n  // ).call()\n\n\n          /**\n           *     a\n           *       ? b\n           *       : multiline\n           *         test\n           *         node\n           *       ^^ align(2)\n           *       ? d\n           *       : e\n           */\n\n\n      // Print @babel/parser's InterpreterDirective here so that\n      // leading comments on the `Program` node get printed after the hashbang.\n\n\n      // Babel 6\n\n\n      // Only force a trailing newline if there were any contents.\n\n\n    // Babel extension.\n\n\n      // Detect Flow and TypeScript directives\n\n\n      // Do not append semicolon after the only JSX element in a program\n\n\n    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\n\n\n        /* isNested */ false,\n\n\n      //   if (\n      //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft\n      //   ) {\n      //\n      // looks super weird, we want to break the children if the parent breaks\n      //\n      //   if (\n      //     this.hasPlugin(\"dynamicImports\") &&\n      //     this.lookahead().type === tt.parenLeft\n      //   ) {\n\n\n      // Break between the parens in\n      // unaries or in a member or specific call expression, i.e.\n      //\n      //   (\n      //     a &&\n      //     b &&\n      //     c\n      //   ).call()\n\n\n      // Avoid indenting sub-expressions in some cases where the first sub-expression is already\n      // indented accordingly. We should indent sub-expressions where the first case isn't indented.\n\n\n      // If the right part is a JSX node, we include it in a separate group to\n      // prevent it breaking the whole chain, so we can print the expression like:\n      //\n      //   foo && bar && (\n      //     <Foo>\n      //       <Bar />\n      //     </Foo>\n      //   )\n\n\n      // Separate the leftmost expression, possibly with its leading comments.\n\n\n          // Don't include the initial expression in the indentation\n          // level. The first item is guaranteed to be the first\n          // left-most expression.\n\n\n                /* expandLast */ args &&\n\n                /* printTypeParams */ true\n\n\n        /* sameIndent */ true,\n\n\n      // We want to always keep these types of nodes on the same line\n      // as the arrow.\n\n\n      // We handle sequence expressions as the body of arrows specially,\n      // so that the required parentheses end up on their own lines.\n\n\n      // if the arrow function is expanded as last argument, we are adding a\n      // level of indentation and need to add a softline to align the closing )\n      // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)\n      // we should align the expression's closing } with the line with the opening {.\n\n\n      // In order to avoid confusion between\n      // a => a ? a : a\n      // a <= a ? a : a\n\n\n        // import {} from 'x'\n\n\n      // Babel 6\n\n\n        // We want to keep CommonJS- and AMD-style require calls, and AMD-style\n        // define calls, as a unit.\n        // e.g. `define([\"some/lib\", (lib) => {`\n\n\n        // Template literals as single arguments\n\n\n        // Keep test declarations on a single line\n        // e.g. `it('long name', () => {`\n\n\n      // Inline Flow annotation comments following Identifiers in Call nodes need to\n      // stay with the Identifier. For example:\n      //\n      // foo /*:: <SomeGeneric> */(bar);\n      //\n      // Here, we ensure that such comments stay between the Identifier and the Callee.\n\n\n      // We detect calls on member lookups and possibly print them in a\n      // special chain format. See `printMemberChain` for more info.\n\n\n      // We group here when the callee is itself a call expression.\n      // See `isLongCurriedCallExpression` for more info.\n\n\n      // Unfortunately, things are grouped together in the ast can be\n      // interleaved in the source code. So we need to reorder them before\n      // printing them.\n\n\n            /* sameIndent */ true\n\n\n      // If we inline the object as first argument of the parent, we don't want\n      // to create another group so that the object breaks before the return\n      // type\n\n\n    // Babel 6\n\n\n        // JavaScript allows you to have empty elements in an array which\n        // changes its length based on the number of commas. The algorithm\n        // is that if the last argument is null, we need to force insert\n        // a comma to ensure JavaScript recognizes it.\n        //   [,].length === 1\n        //   [1,].length === 1\n        //   [1,,].length === 2\n        //\n        // Note that getLast returns null if the array is empty, but\n        // we already check for an empty array just above so we are safe\n\n\n                /* sameIndent */ true\n\n\n        // For ExpressionStatements and for-loop heads, which are among\n        // the few places a SequenceExpression appears unparenthesized, we want\n        // to indent expressions after the first.\n\n\n      // babel: n.extra.raw, flow: n.bigint\n\n\n      // typescript\n\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n\n\n        // Indent first var to comply with eslint one-var rule\n\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n\n\n        /* sameLine */ true\n\n\n      // Note: esprima can't actually parse \"for each (\".\n\n\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n\n    // JSX extensions below.\n\n\n          // Unescape all quotes so we get an accurate preferred quote\n\n\n      // Don't break self-closing elements with no attributes and no comments\n\n\n      // don't break up opening elements with a single long text attribute\n\n\n        // We should break for the following cases:\n        // <div\n        //   // comment\n        //   attr=\"value\"\n        // >\n        // <div\n        //   attr=\"value\"\n        //   // comment\n        // >\n\n\n        // Simple tags (no attributes and no comment in tag name) should be\n        // kept unbroken regardless of `jsxBracketSameLine`\n\n\n          // We should print the bracket in a new line for the following cases:\n          // <div\n          //   // comment\n          // >\n          // <div\n          //   attr // comment\n          // >\n\n\n      // We should print the opening element expanded if any prop value is a\n      // string literal with newlines\n\n\n      /* istanbul ignore next */\n\n\n          /* sameIndent */ !requiresHardline\n\n\n          // For a template literal of the following form:\n          //   `someQuery {\n          //     ${call({\n          //       a,\n          //       b,\n          //     })}\n          //   }`\n          // the expression is on its own line (there is a \\n in the previous\n          // quasi literal), therefore we want to indent the JavaScript\n          // expression inside at the beginning of ${ instead of the beginning\n          // of the `.\n\n\n            // Breaks at the template element boundaries (${ and }) are preferred to breaking\n            // in the middle of a MemberExpression\n\n\n    // These types are unprintable because they serve as abstract\n    // supertypes for other (printable) types.\n\n\n      /* istanbul ignore next */\n\n    // Type Annotations for Facebook Flow, typically stripped out or\n    // transformed away before printing.\n\n\n      /* istanbul ignore next */\n\n\n      // For TypeScript the TSDeclareFunction node shares the AST\n      // structure with FunctionDeclaration\n\n\n                /* sameIndent */ true\n\n\n      // FunctionTypeAnnotation is ambiguous:\n      // declare function foo(a: B): void; OR\n      // var A: (a: B) => void;\n\n\n      // Sadly we can't put it inside of FastPath::needsColon because we are\n      // printing \":\" as part of the expression and it would put parenthesis\n      // around :(\n\n\n          /* expandArg */ false,\n          /* printTypeParams */ true\n\n\n      // The returnType is not wrapped in a TypeAnnotation, so the colon\n      // needs to be added separately.\n\n\n          // If both are objects, don't indent\n\n\n          // If no object is involved, go to the next line if it breaks\n\n\n          // If you go from object to non-object or vis-versa, then inline it\n\n\n      // single-line variation\n      // A | B | C\n\n      // multi-line variation\n      // | A\n      // | B\n      // | C\n\n\n      // If there's a leading comment, the parent is doing the indentation\n\n\n      // {\n      //   a: string\n      // } | null | void\n      // should be inlined and not be printed in the multi-line variant\n\n\n      // We want to align the children but without its comment, so it looks like\n      // | child1\n      // // comment\n      // | child2\n\n\n      // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here\n      // because we know for sure that this is a type definition.\n\n\n      // Keep comma if the file extension is .tsx and\n      // has one type parameter that isn't extend with any types.\n      // Because, otherwise formatted result will be invalid as tsx.\n\n\n    // Unhandled types below. If encountered, nodes of these types should\n    // be either left alone or desugared into AST types that are fully\n    // supported by the pretty-printer.\n\n\n      // This isn't valid semantically, but it's in the AST so we can print it.\n\n\n      // The typescript parser accepts multiple parameters here. If you're\n      // using them, it makes sense to have a trailing comma. But if you\n      // aren't, this is more like a computed property name than an array.\n      // So we leave off the trailing comma when there's just one parameter.\n\n\n            /* expandArg */ false,\n            /* printTypeParams */ true\n\n\n          /* expandArg */ false,\n          /* printTypeParams */ true\n\n\n                /* sameIndent */ true\n\n\n        // Global declaration looks like this:\n        // (declare)? global { ... }\n\n\n    // TODO: Temporary auto-generated node type. To remove when typescript-estree has proper support for private fields.\n\n\n    // These are not valid TypeScript. Printing them just for the sake of error recovery.\n\n\n        // The parameters could be here, but typescript-estree doesn't convert them anyway (throws an error).\n\n\n      /* istanbul ignore next */\n\n\n    // Just in case the AST has been modified to contain falsy\n    // \"statements,\" it's safer simply to skip them.\n    /* istanbul ignore if */\n\n\n    // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n\n\n    // in no-semi mode, prepend statement with semicolon if it might break ASI\n    // don't prepend the only JSX element in a program with semicolon\n\n\n    // flow has `Identifier` key, and babel has `PrivateName` key\n\n\n    // a -> \"a\"\n\n\n    // 'a' -> a\n\n\n  /**\n   * a    | b    | expected\n   * ${1} | ${1} | ${2}\n   * ${1} | ${2} | ${3}\n   * ${2} | ${1} | ${3}\n   */\n\n\n        /* sameIndent */ true,\n\n\n  // If the parent is a call with the first/last argument expansion and this is the\n  // params of the first/last argument, we don't want the arguments to break and instead\n  // want the whole expression to be on a new line.\n  //\n  // Good:                 Bad:\n  //   verylongcall(         verylongcall((\n  //     (a, b) => {           a,\n  //     }                     b,\n  //   })                    ) => {\n  //                         })\n\n\n  // Single object destructuring should hug\n  //\n  // function({\n  //   a,\n  //   b,\n  //   c\n  // }) {}\n\n\n  // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`\n\n\n  // Fallback default; should be unreachable\n\n\n  // prepend colon to TypeScript type annotation\n\n\n    // The return type will already add the colon, but otherwise we\n    // need to do it ourselves\n\n\n    // If the parent node has type DeclareExportDeclaration, then it\n    // will be responsible for printing the \"declare\" token. Otherwise\n    // it needs to be printed with this non-exported declaration node.\n\n\n  // for TypeParameterDeclaration typeParameters is a single node\n\n\n        // See https://github.com/prettier/prettier/pull/6467 for the context.\n\n\n      /* sameIndent */ hasOnlyBlockComments\n\n\n  // Keep old behaviour of extends in same line\n  // If there is only on extends and there are not comments\n\n\n        /* sameIndent */ true,\n\n\n// JSX Children are strange, mostly for two reasons:\n// 1. JSX reads newlines into string values, instead of skipping them like JS\n// 2. up to one whitespace between elements within a line is significant,\n//    but not between lines.\n//\n// Leading, trailing, and lone whitespace all need to\n// turn themselves into the rather ugly `{' '}` when breaking.\n//\n// We print JSX using the `fill` doc primitive.\n// This requires that we give it an array of alternating\n// content and whitespace elements.\n// To ensure this we add dummy `\"\"` content elements as needed.\n\n\n  // using `map` instead of `each` because it provides `i`\n\n\n      // Contains a non-whitespace character\n\n\n        // Starts with whitespace\n\n\n        // Ends with whitespace\n\n\n        // This was whitespace only without a new line.\n\n\n        // Keep (up to one) blank line between tags/expressions/text.\n        // Note: We don't keep blank lines between text elements.\n\n\n// JSX expands children from the inside-out, instead of the outside-in.\n// This is both to break children before attributes,\n// and to ensure that when children break, their parents do as well.\n//\n// Any element that is written without any newlines and fits on a single line\n// is left that way.\n// Not only that, any user-written-line containing multiple JSX siblings\n// should also be kept on one line if possible,\n// so each user-written-line is wrapped in its own group.\n//\n// Elements that contain newlines or don't fit on a single line (recursively)\n// are fully-split, using hardline and shouldBreak: true.\n//\n// To support that case properly, all leading and trailing spaces\n// are stripped from the list of children, and replaced with a single hardline.\n\n\n  // Convert `{\" \"}` to text nodes containing a space.\n  // This makes it easy to turn them into `jsxWhitespace` which\n  // can then print as either a space or `{\" \"}` when breaking.\n\n\n  // Record any breaks. Should never go from true to false, only false to true.\n\n\n  // We can end up we multiple whitespace elements with empty string\n  // content between them.\n  // We need to remove empty whitespace and softlines before JSX whitespace\n  // to get the correct output.\n\n\n  // Trim trailing lines (or empty strings)\n\n\n  // Trim leading lines (or empty strings)\n\n\n  // Tweak how we format children if outputting this element over multiple lines.\n  // Also detect whether we will force this element to output over multiple lines.\n\n\n    // There are a number of situations where we need to ensure we display\n    // whitespace as `{\" \"}` when outputting this element over multiple lines.\n\n\n          // Solitary whitespace\n\n\n        // Leading whitespace\n\n\n        // Trailing whitespace\n\n\n        // Whitespace after line break\n\n\n  // If there is text we use `fill` to fit as much onto each line as possible.\n  // When there is no text (just tags and expressions) we use `group`\n  // to output each on a separate line.\n\n\n// For binary expressions to be consistent, we need to group\n// subsequent operators with the same precedence level under a single\n// group. Otherwise they will be nested such that some of them break\n// onto new lines but not all. Operators with the same precedence\n// level should either all break or not. Because we group them by\n// precedence level and the AST is structured based on precedence\n// level, things are naturally broken up correctly, i.e. `&&` is\n// broken before `+`.\n\n\n  // We treat BinaryExpression and LogicalExpression nodes the same.\n\n    // Put all operators with the same precedence level in the same\n    // group. The reason we only need to do this with the `left`\n    // expression is because given an expression like `1 + 2 - 3`, it\n    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side\n    // is where the rest of the expression will exist. Binary\n    // expressions on the right side mean they have a difference\n    // precedence level and should be treated as a separate group, so\n    // print them normally. (This doesn't hold for the `**` operator,\n    // which is unique in that it is right-associative.)\n\n      // Flatten them out by recursively calling this function.\n\n\n              /* isNested */ true,\n\n\n    // If there's only a single binary expression, we want to create a group\n    // in order to avoid having a small right part like -1 be on its own line.\n\n\n    // The root comments are already printed, but we need to manually print\n    // the other ones since we don't call the normal print on BinaryExpression,\n    // only for the left and right parts\n\n\n    // Our stopping case. Simply print the node normally.\n\n\n      // do not put values on a separate line from the key in json\n\n\n        // This is a bit aggressive but captures Array<{x}>\n\n\n        // We need to prevent an edge case of a previous trailing comment\n        // printed as a `lineSuffix` which causes the comments to be\n        // interleaved. See https://github.com/prettier/prettier/issues/4412\n\n\n      // Supports `//`, `#!`, `<!--`, and `-->`\n\n\n  // If the comment has multiple lines and every line starts with a star\n  // we can fix the indentation of each line. The stars in the `/*` and\n  // `*/` delimiters are not included in the comment value, so add them\n  // back first.\n\n\n"
    },
    "3": {
        "bug_file": "src/main/parser.js",
        "compressed": "NO",
        "line_numbers": 111,
        "compressed_line_numbers": 111,
        "compressed_bug_file_content": "\"use strict\";\n\nconst path = require(\"path\");\nconst { ConfigError } = require(\"../common/errors\");\nconst jsLoc = require(\"../language-js/loc\");\n\nconst { locStart, locEnd } = jsLoc;\n\n// Use defineProperties()/getOwnPropertyDescriptor() to prevent\n// triggering the parsers getters.\nconst ownNames = Object.getOwnPropertyNames;\nconst ownDescriptor = Object.getOwnPropertyDescriptor;\nfunction getParsers(options) {\n  const parsers = {};\n  for (const plugin of options.plugins) {\n    if (!plugin.parsers) {\n      continue;\n    }\n\n    for (const name of ownNames(plugin.parsers)) {\n      Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));\n    }\n  }\n\n  return parsers;\n}\n\nfunction resolveParser(opts, parsers) {\n  parsers = parsers || getParsers(opts);\n\n  if (typeof opts.parser === \"function\") {\n    // Custom parser API always works with JavaScript.\n    return {\n      parse: opts.parser,\n      astFormat: \"estree\",\n      locStart,\n      locEnd,\n    };\n  }\n\n  if (typeof opts.parser === \"string\") {\n    if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {\n      return parsers[opts.parser];\n    }\n\n    /* istanbul ignore next */\n    if (process.env.PRETTIER_TARGET === \"universal\") {\n      throw new ConfigError(\n        `Couldn't resolve parser \"${opts.parser}\". Parsers must be explicitly added to the standalone bundle.`\n      );\n    } else {\n      try {\n        return {\n          parse: eval(\"require\")(path.resolve(process.cwd(), opts.parser)),\n          astFormat: \"estree\",\n          locStart,\n          locEnd,\n        };\n      } catch (err) {\n        /* istanbul ignore next */\n        throw new ConfigError(`Couldn't resolve parser \"${opts.parser}\"`);\n      }\n    }\n  }\n}\n\nfunction parse(text, opts) {\n  const parsers = getParsers(opts);\n\n  // Create a new object {parserName: parseFn}. Uses defineProperty() to only call\n  // the parsers getters when actually calling the parser `parse` function.\n  const parsersForCustomParserApi = Object.keys(parsers).reduce(\n    (object, parserName) =>\n      Object.defineProperty(object, parserName, {\n        enumerable: true,\n        get() {\n          return parsers[parserName].parse;\n        },\n      }),\n    {}\n  );\n\n  const parser = resolveParser(opts, parsers);\n\n  try {\n    if (parser.preprocess) {\n      text = parser.preprocess(text, opts);\n    }\n\n    return {\n      text,\n      ast: parser.parse(text, parsersForCustomParserApi, opts),\n    };\n  } catch (error) {\n    const { loc } = error;\n\n    if (loc) {\n      const codeFrame = require(\"@babel/code-frame\");\n      error.codeFrame = codeFrame.codeFrameColumns(text, loc, {\n        highlightCode: true,\n      });\n      error.message += \"\\n\" + error.codeFrame;\n      throw error;\n    }\n\n    /* istanbul ignore next */\n    throw error.stack;\n  }\n}\n\nmodule.exports = { parse, resolveParser };"
    },
    "4": {
        "bug_file": "src/index.js",
        "compressed": "NO",
        "line_numbers": 89,
        "compressed_line_numbers": 89,
        "compressed_bug_file_content": "\"use strict\";\n\nconst { version } = require(\"../package.json\");\n\nconst core = require(\"./main/core\");\nconst { getSupportInfo } = require(\"./main/support\");\nconst getFileInfo = require(\"./common/get-file-info\");\nconst sharedUtil = require(\"./common/util-shared\");\nconst plugins = require(\"./common/load-plugins\");\nconst config = require(\"./config/resolve-config\");\nconst doc = require(\"./document\");\n\nfunction _withPlugins(\n  fn,\n  optsArgIdx = 1 // Usually `opts` is the 2nd argument\n) {\n  return (...args) => {\n    const opts = args[optsArgIdx] || {};\n    args[optsArgIdx] = {\n      ...opts,\n      plugins: plugins.loadPlugins(opts.plugins, opts.pluginSearchDirs),\n    };\n    return fn(...args);\n  };\n}\n\nfunction withPlugins(fn, optsArgIdx) {\n  const resultingFn = _withPlugins(fn, optsArgIdx);\n  if (fn.sync) {\n    // @ts-ignore\n    resultingFn.sync = _withPlugins(fn.sync, optsArgIdx);\n  }\n  return resultingFn;\n}\n\nconst formatWithCursor = withPlugins(core.formatWithCursor);\n\nmodule.exports = {\n  formatWithCursor,\n\n  format(text, opts) {\n    return formatWithCursor(text, opts).formatted;\n  },\n\n  check(text, opts) {\n    const { formatted } = formatWithCursor(text, opts);\n    return formatted === text;\n  },\n\n  doc,\n\n  resolveConfig: config.resolveConfig,\n  resolveConfigFile: config.resolveConfigFile,\n  clearConfigCache() {\n    config.clearCache();\n    plugins.clearCache();\n  },\n\n  getFileInfo: /** @type {typeof getFileInfo} */ (withPlugins(getFileInfo)),\n  getSupportInfo: /** @type {typeof getSupportInfo} */ (withPlugins(\n    getSupportInfo,\n    0\n  )),\n\n  version,\n\n  util: sharedUtil,\n\n  // Internal shared\n  __internal: {\n    errors: require(\"./common/errors\"),\n    coreOptions: require(\"./main/core-options\"),\n    createIgnorer: require(\"./common/create-ignorer\"),\n    optionsModule: require(\"./main/options\"),\n    optionsNormalizer: require(\"./main/options-normalizer\"),\n    utils: {\n      arrayify: require(\"./utils/arrayify\"),\n    },\n  },\n\n  /* istanbul ignore next */\n  __debug: {\n    parse: withPlugins(core.parse),\n    formatAST: withPlugins(core.formatAST),\n    formatDoc: withPlugins(core.formatDoc),\n    printToDoc: withPlugins(core.printToDoc),\n    printDocToString: withPlugins(core.printDocToString),\n  },\n};"
    }
}