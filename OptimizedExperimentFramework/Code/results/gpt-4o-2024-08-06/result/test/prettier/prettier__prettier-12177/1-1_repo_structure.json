{
    ".codecov.yml": {},
    ".editorconfig": {},
    ".eslintignore": {},
    ".eslintrc.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "const { isCI } = require(\"ci-info\");",
            "",
            "module.exports = {",
            "  root: true,",
            "  env: {",
            "    es2021: true,",
            "    node: true,",
            "  },",
            "  reportUnusedDisableDirectives: true,",
            "  extends: [\"eslint:recommended\", \"prettier\"],",
            "  plugins: [",
            "    \"prettier-internal-rules\",",
            "    \"import\",",
            "    \"regexp\",",
            "    \"unicorn\",",
            "    \"@typescript-eslint\",",
            "  ],",
            "  settings: {",
            "    \"import/internal-regex\": \"^linguist-languages/\",",
            "  },",
            "  rules: {",
            "    \"@typescript-eslint/prefer-ts-expect-error\": \"error\",",
            "    \"arrow-body-style\": [\"error\", \"as-needed\"],",
            "    curly: \"error\",",
            "    \"dot-notation\": \"error\",",
            "    eqeqeq: \"error\",",
            "    \"no-console\": isCI ? \"error\" : \"off\",",
            "    \"no-else-return\": [",
            "      \"error\",",
            "      {",
            "        allowElseIf: false,",
            "      },",
            "    ],",
            "    \"no-implicit-coercion\": \"error\",",
            "    \"no-inner-declarations\": \"error\",",
            "    \"no-restricted-syntax\": [",
            "      \"error\",",
            "      // `!foo === bar` and `!foo !== bar`",
            "      'BinaryExpression[operator=/^[!=]==$/] > UnaryExpression.left[operator=\"!\"]',",
            "    ],",
            "    \"no-return-await\": \"error\",",
            "    \"no-unneeded-ternary\": \"error\",",
            "    \"no-useless-return\": \"error\",",
            "    \"no-unused-vars\": [",
            "      \"error\",",
            "      {",
            "        ignoreRestSiblings: true,",
            "      },",
            "    ],",
            "    \"no-var\": \"error\",",
            "    \"object-shorthand\": \"error\",",
            "    \"one-var\": [\"error\", \"never\"],",
            "    \"prefer-arrow-callback\": \"error\",",
            "    \"prefer-const\": [",
            "      \"error\",",
            "      {",
            "        destructuring: \"all\",",
            "      },",
            "    ],",
            "    \"prefer-destructuring\": [",
            "      \"error\",",
            "      {",
            "        VariableDeclarator: {",
            "          array: false,",
            "          object: true,",
            "        },",
            "        AssignmentExpression: {",
            "          array: false,",
            "          object: false,",
            "        },",
            "      },",
            "      {",
            "        enforceForRenamedProperties: false,",
            "      },",
            "    ],",
            "    \"prefer-object-spread\": \"error\",",
            "    \"prefer-rest-params\": \"error\",",
            "    \"prefer-spread\": \"error\",",
            "    \"prettier-internal-rules/jsx-identifier-case\": \"error\",",
            "    \"prettier-internal-rules/no-identifier-n\": \"error\",",
            "    quotes: [",
            "      \"error\",",
            "      \"double\",",
            "      {",
            "        avoidEscape: true,",
            "      },",
            "    ],",
            "    \"require-await\": \"error\",",
            "    strict: \"error\",",
            "    \"symbol-description\": \"error\",",
            "    yoda: [",
            "      \"error\",",
            "      \"never\",",
            "      {",
            "        exceptRange: true,",
            "      },",
            "    ],",
            "",
            "    \"import/extensions\": [\"error\", \"ignorePackages\"],",
            "    \"import/no-extraneous-dependencies\": [",
            "      \"error\",",
            "      {",
            "        devDependencies: [\"tests*/**\", \"scripts/**\"],",
            "      },",
            "    ],",
            "    \"import/order\": \"error\",",
            "    \"import/no-anonymous-default-export\": \"error\",",
            "",
            "    \"regexp/match-any\": [",
            "      \"error\",",
            "      {",
            "        allows: [\"dotAll\"],",
            "      },",
            "    ],",
            "    \"regexp/no-unused-capturing-group\": \"error\",",
            "    \"regexp/no-useless-flag\": [",
            "      \"error\",",
            "      {",
            "        strictTypes: false,",
            "      },",
            "    ],",
            "    \"regexp/no-useless-lazy\": \"error\",",
            "",
            "    \"unicorn/better-regex\": \"error\",",
            "    \"unicorn/explicit-length-check\": \"error\",",
            "    \"unicorn/new-for-builtins\": \"error\",",
            "    \"unicorn/no-array-for-each\": \"error\",",
            "    \"unicorn/no-array-push-push\": \"error\",",
            "    \"unicorn/no-new-array\": \"error\",",
            "    \"unicorn/no-useless-length-check\": \"error\",",
            "    \"unicorn/no-useless-promise-resolve-reject\": \"error\",",
            "    \"unicorn/no-useless-undefined\": \"error\",",
            "    \"unicorn/prefer-array-flat\": [",
            "      \"error\",",
            "      {",
            "        functions: [\"flat\", \"flatten\"],",
            "      },",
            "    ],",
            "    \"unicorn/prefer-array-flat-map\": \"error\",",
            "    \"unicorn/prefer-array-some\": \"error\",",
            "    \"unicorn/prefer-includes\": \"error\",",
            "    \"unicorn/prefer-json-parse-buffer\": \"error\",",
            "    \"unicorn/prefer-number-properties\": \"error\",",
            "    \"unicorn/prefer-optional-catch-binding\": \"error\",",
            "    \"unicorn/prefer-regexp-test\": \"error\",",
            "    \"unicorn/prefer-spread\": \"error\",",
            "    \"unicorn/prefer-string-slice\": \"error\",",
            "    \"unicorn/prefer-string-starts-ends-with\": \"error\",",
            "    \"unicorn/prefer-switch\": \"error\",",
            "    \"unicorn/prefer-type-error\": \"error\",",
            "  },",
            "  overrides: [",
            "    {",
            "      files: [\"scripts/**/*.js\", \"scripts/**/*.mjs\"],",
            "      rules: {",
            "        \"no-console\": \"off\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"**/*.mjs\", \"scripts/release/**/*.js\"],",
            "      parserOptions: {",
            "        sourceType: \"module\",",
            "      },",
            "      rules: {",
            "        \"unicorn/prefer-module\": \"error\",",
            "        \"unicorn/prefer-node-protocol\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [",
            "        \"tests/format/**/jsfmt.spec.js\",",
            "        \"tests/config/**/*.js\",",
            "        \"tests/integration/**/*.js\",",
            "        \"scripts/release/__tests__/**/*.spec.js\",",
            "      ],",
            "      env: {",
            "        jest: true,",
            "      },",
            "      plugins: [\"jest\"],",
            "      rules: {",
            "        \"jest/valid-expect\": [",
            "          \"error\",",
            "          {",
            "            alwaysAwait: true,",
            "          },",
            "        ],",
            "        \"jest/prefer-to-be\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"tests/integration/**/*.js\"],",
            "      rules: {",
            "        \"prettier-internal-rules/await-cli-tests\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"tests/**/*.js\"],",
            "      rules: {",
            "        strict: \"off\",",
            "        \"unicorn/prefer-array-flat\": \"off\",",
            "        \"unicorn/prefer-array-flat-map\": \"off\",",
            "      },",
            "      globals: {",
            "        run_spec: false,",
            "      },",
            "    },",
            "    {",
            "      files: [\"src/cli/*.js\"],",
            "      rules: {",
            "        \"no-restricted-modules\": [",
            "          \"error\",",
            "          {",
            "            patterns: [\"../\"],",
            "          },",
            "        ],",
            "      },",
            "    },",
            "    {",
            "      files: [\"src/cli/*/*.js\"],",
            "      rules: {",
            "        \"no-restricted-modules\": [",
            "          \"error\",",
            "          {",
            "            patterns: [\"../../\"],",
            "          },",
            "        ],",
            "      },",
            "    },",
            "    {",
            "      files: \"src/language-js/needs-parens.js\",",
            "      rules: {",
            "        \"prettier-internal-rules/better-parent-property-check-in-needs-parens\":",
            "          \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: \"src/**/*.js\",",
            "      rules: {",
            "        \"prettier-internal-rules/consistent-negative-index-access\": \"error\",",
            "        \"prettier-internal-rules/flat-ast-path-call\": \"error\",",
            "        \"prettier-internal-rules/no-conflicting-comment-check-flags\": \"error\",",
            "        \"prettier-internal-rules/no-doc-builder-concat\": \"error\",",
            "        \"prettier-internal-rules/no-empty-flat-contents-for-if-break\": \"error\",",
            "        \"prettier-internal-rules/no-unnecessary-ast-path-call\": \"error\",",
            "        \"prettier-internal-rules/prefer-ast-path-each\": \"error\",",
            "        \"prettier-internal-rules/prefer-indent-if-break\": \"error\",",
            "        \"prettier-internal-rules/prefer-is-non-empty-array\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"src/language-*/**/*.js\"],",
            "      rules: {",
            "        \"prettier-internal-rules/directly-loc-start-end\": \"error\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"src/language-js/**/*.js\"],",
            "      rules: {",
            "        \"prettier-internal-rules/no-node-comments\": [",
            "          \"error\",",
            "          {",
            "            file: \"src/language-js/utils/index.js\",",
            "            functions: [\"hasComment\", \"getComments\"],",
            "          },",
            "          \"src/language-js/pragma.js\",",
            "          \"src/language-js/parse/postprocess/*.js\",",
            "          \"src/language-js/parse/babel.js\",",
            "          \"src/language-js/parse/meriyah.js\",",
            "          \"src/language-js/parse/json.js\",",
            "        ],",
            "      },",
            "    },",
            "    {",
            "      files: [\"website/**/*\"],",
            "      env: {",
            "        browser: true,",
            "        worker: true,",
            "      },",
            "      extends: [\"plugin:react/recommended\"],",
            "      settings: {",
            "        react: {",
            "          version: \"17\",",
            "        },",
            "      },",
            "      rules: {",
            "        \"import/no-extraneous-dependencies\": \"off\",",
            "        \"react/display-name\": \"off\",",
            "        \"react/no-deprecated\": \"off\",",
            "        \"react/prop-types\": \"off\",",
            "      },",
            "    },",
            "    {",
            "      files: [\"website/playground/**/*\"],",
            "      parserOptions: {",
            "        sourceType: \"module\",",
            "      },",
            "    },",
            "  ],",
            "};"
        ]
    },
    ".git-blame-ignore-revs": {},
    ".gitattributes": {},
    ".gitignore": {},
    ".ignore": {},
    ".prettierignore": {},
    ".prettierrc": {},
    ".yarnrc": {},
    "CHANGELOG.md": {},
    "CODE_OF_CONDUCT.md": {},
    "CONTRIBUTING.md": {},
    "LICENSE": {},
    "README.md": {},
    "commands.md": {},
    "cspell.json": {},
    "index.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "module.exports = require(\"./src/index.js\");"
        ]
    },
    "jest.config.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "const path = require(\"path\");",
            "const installPrettier = require(\"./tests/config/install-prettier.js\");",
            "",
            "const PROJECT_ROOT = __dirname;",
            "const isProduction = process.env.NODE_ENV === \"production\";",
            "const ENABLE_CODE_COVERAGE = Boolean(process.env.ENABLE_CODE_COVERAGE);",
            "const TEST_STANDALONE = Boolean(process.env.TEST_STANDALONE);",
            "const INSTALL_PACKAGE = Boolean(process.env.INSTALL_PACKAGE);",
            "",
            "let PRETTIER_DIR = isProduction",
            "  ? path.join(PROJECT_ROOT, \"dist\")",
            "  : PROJECT_ROOT;",
            "if (INSTALL_PACKAGE || (isProduction && !TEST_STANDALONE)) {",
            "  PRETTIER_DIR = installPrettier(PRETTIER_DIR);",
            "}",
            "process.env.PRETTIER_DIR = PRETTIER_DIR;",
            "",
            "const testPathIgnorePatterns = [];",
            "let transform = {};",
            "if (TEST_STANDALONE) {",
            "  testPathIgnorePatterns.push(\"<rootDir>/tests/integration/\");",
            "}",
            "if (isProduction) {",
            "  // `esm` bundles need transform",
            "  transform = {",
            "    \"(?:\\\\.mjs|codeSamples\\\\.js)$\": [",
            "      \"babel-jest\",",
            "      {",
            "        presets: [",
            "          [",
            "            \"@babel/env\",",
            "            {",
            "              targets: { node: \"current\" },",
            "              exclude: [",
            "                \"transform-async-to-generator\",",
            "                \"transform-classes\",",
            "                \"proposal-async-generator-functions\",",
            "                \"transform-regenerator\",",
            "              ],",
            "            },",
            "          ],",
            "        ],",
            "      },",
            "    ],",
            "  };",
            "} else {",
            "  // Only test bundles for production",
            "  testPathIgnorePatterns.push(",
            "    \"<rootDir>/tests/integration/__tests__/bundle.js\"",
            "  );",
            "}",
            "",
            "module.exports = {",
            "  setupFiles: [\"<rootDir>/tests/config/setup.js\"],",
            "  snapshotSerializers: [",
            "    \"jest-snapshot-serializer-raw\",",
            "    \"jest-snapshot-serializer-ansi\",",
            "  ],",
            "  testRegex: \"jsfmt\\\\.spec\\\\.js$|__tests__/.*\\\\.js$\",",
            "  testPathIgnorePatterns,",
            "  collectCoverage: ENABLE_CODE_COVERAGE,",
            "  collectCoverageFrom: [\"<rootDir>/src/**/*.js\", \"<rootDir>/bin/**/*.js\"],",
            "  coveragePathIgnorePatterns: [",
            "    \"<rootDir>/src/standalone.js\",",
            "    \"<rootDir>/src/document/doc-debug.js\",",
            "  ],",
            "  coverageReporters: [\"text\", \"lcov\"],",
            "  moduleNameMapper: {",
            "    \"prettier-local\": \"<rootDir>/tests/config/require-prettier.js\",",
            "    \"prettier-standalone\": \"<rootDir>/tests/config/require-standalone.js\",",
            "  },",
            "  modulePathIgnorePatterns: [",
            "    \"<rootDir>/dist\",",
            "    \"<rootDir>/website\",",
            "    \"<rootDir>/scripts/release\",",
            "  ],",
            "  transform,",
            "  watchPlugins: [",
            "    \"jest-watch-typeahead/filename\",",
            "    \"jest-watch-typeahead/testname\",",
            "  ],",
            "};"
        ]
    },
    "netlify.toml": {},
    "package.json": {},
    "standalone.js": {
        "classes": [],
        "functions": [],
        "text": [
            "\"use strict\";",
            "",
            "module.exports = require(\"./src/standalone.js\");"
        ]
    },
    "tsconfig.json": {},
    "yarn.lock": {},
    "bin": {
        "prettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "#!/usr/bin/env node",
                "",
                "\"use strict\";",
                "",
                "module.exports = require(\"../src/cli/index.js\").run(process.argv.slice(2));"
            ]
        }
    },
    "changelog_unreleased": {
        "BLOG_POST_INTRO_TEMPLATE.md": {},
        "TEMPLATE.md": {},
        "angular": {
            ".gitkeep": {}
        },
        "api": {
            ".gitkeep": {}
        },
        "cli": {
            ".gitkeep": {}
        },
        "css": {
            ".gitkeep": {}
        },
        "flow": {
            ".gitkeep": {},
            "12009.md": {}
        },
        "graphql": {
            ".gitkeep": {},
            "11901.md": {}
        },
        "handlebars": {
            ".gitkeep": {}
        },
        "html": {
            ".gitkeep": {},
            "6644.md": {}
        },
        "javascript": {
            ".gitkeep": {},
            "11992.md": {},
            "12017.md": {},
            "12070.md": {},
            "12075.md": {},
            "12088.md": {}
        },
        "json": {
            ".gitkeep": {}
        },
        "less": {
            ".gitkeep": {}
        },
        "lwc": {
            ".gitkeep": {}
        },
        "markdown": {
            ".gitkeep": {}
        },
        "mdx": {
            ".gitkeep": {}
        },
        "scss": {
            ".gitkeep": {},
            "11920.md": {}
        },
        "typescript": {
            ".gitkeep": {}
        },
        "vue": {
            ".gitkeep": {},
            "12113.md": {}
        },
        "yaml": {
            ".gitkeep": {}
        }
    },
    "src": {
        "index.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const { version } = require(\"../package.json\");",
                "",
                "const core = require(\"./main/core.js\");",
                "const { getSupportInfo } = require(\"./main/support.js\");",
                "const getFileInfo = require(\"./common/get-file-info.js\");",
                "const sharedUtil = require(\"./common/util-shared.js\");",
                "const plugins = require(\"./common/load-plugins.js\");",
                "const config = require(\"./config/resolve-config.js\");",
                "const doc = require(\"./document/index.js\");",
                "",
                "function _withPlugins(",
                "  fn,",
                "  optsArgIdx = 1 // Usually `opts` is the 2nd argument",
                ") {",
                "  return (...args) => {",
                "    const opts = args[optsArgIdx] || {};",
                "    args[optsArgIdx] = {",
                "      ...opts,",
                "      plugins: plugins.loadPlugins(opts.plugins, opts.pluginSearchDirs),",
                "    };",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "function withPlugins(fn, optsArgIdx) {",
                "  const resultingFn = _withPlugins(fn, optsArgIdx);",
                "  if (fn.sync) {",
                "    // @ts-expect-error",
                "    resultingFn.sync = _withPlugins(fn.sync, optsArgIdx);",
                "  }",
                "  return resultingFn;",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "module.exports = {",
                "  formatWithCursor,",
                "",
                "  format(text, opts) {",
                "    return formatWithCursor(text, opts).formatted;",
                "  },",
                "",
                "  check(text, opts) {",
                "    const { formatted } = formatWithCursor(text, opts);",
                "    return formatted === text;",
                "  },",
                "",
                "  doc,",
                "",
                "  resolveConfig: config.resolveConfig,",
                "  resolveConfigFile: config.resolveConfigFile,",
                "  clearConfigCache() {",
                "    config.clearCache();",
                "    plugins.clearCache();",
                "  },",
                "",
                "  /** @type {typeof getFileInfo} */",
                "  getFileInfo: withPlugins(getFileInfo),",
                "  /** @type {typeof getSupportInfo} */",
                "  getSupportInfo: withPlugins(getSupportInfo, 0),",
                "",
                "  version,",
                "",
                "  util: sharedUtil,",
                "",
                "  // Internal shared",
                "  __internal: {",
                "    errors: require(\"./common/errors.js\"),",
                "    coreOptions: require(\"./main/core-options.js\"),",
                "    createIgnorer: require(\"./common/create-ignorer.js\"),",
                "    optionsModule: require(\"./main/options.js\"),",
                "    optionsNormalizer: require(\"./main/options-normalizer.js\"),",
                "    utils: {",
                "      arrayify: require(\"./utils/arrayify.js\"),",
                "      getLast: require(\"./utils/get-last.js\"),",
                "    },",
                "  },",
                "",
                "  /* istanbul ignore next */",
                "  __debug: {",
                "    parse: withPlugins(core.parse),",
                "    formatAST: withPlugins(core.formatAST),",
                "    formatDoc: withPlugins(core.formatDoc),",
                "    printToDoc: withPlugins(core.printToDoc),",
                "    printDocToString: withPlugins(core.printDocToString),",
                "  },",
                "};"
            ]
        },
        "languages.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "// We need to list the parsers and getters so we can load them only when necessary.",
                "module.exports = [",
                "  // JS",
                "  require(\"./language-js/index.js\"),",
                "  // CSS",
                "  require(\"./language-css/index.js\"),",
                "  // Handlebars",
                "  require(\"./language-handlebars/index.js\"),",
                "  // GraphQL",
                "  require(\"./language-graphql/index.js\"),",
                "  // Markdown",
                "  require(\"./language-markdown/index.js\"),",
                "  // HTML",
                "  require(\"./language-html/index.js\"),",
                "  // YAML",
                "  require(\"./language-yaml/index.js\"),",
                "];"
            ]
        },
        "standalone.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "const { version } = require(\"../package.json\");",
                "",
                "const core = require(\"./main/core.js\");",
                "const { getSupportInfo } = require(\"./main/support.js\");",
                "const sharedUtil = require(\"./common/util-shared.js\");",
                "const languages = require(\"./languages.js\");",
                "const doc = require(\"./document/index.js\");",
                "",
                "function withPlugins(",
                "  fn,",
                "  optsArgIdx = 1 // Usually `opts` is the 2nd argument",
                ") {",
                "  return (...args) => {",
                "    const opts = args[optsArgIdx] || {};",
                "    const plugins = opts.plugins || [];",
                "",
                "    args[optsArgIdx] = {",
                "      ...opts,",
                "      plugins: [",
                "        ...languages,",
                "        ...(Array.isArray(plugins) ? plugins : Object.values(plugins)),",
                "      ],",
                "    };",
                "",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "module.exports = {",
                "  formatWithCursor,",
                "",
                "  format(text, opts) {",
                "    return formatWithCursor(text, opts).formatted;",
                "  },",
                "",
                "  check(text, opts) {",
                "    const { formatted } = formatWithCursor(text, opts);",
                "    return formatted === text;",
                "  },",
                "",
                "  doc,",
                "",
                "  getSupportInfo: withPlugins(getSupportInfo, 0),",
                "",
                "  version,",
                "",
                "  util: sharedUtil,",
                "",
                "  __debug: {",
                "    parse: withPlugins(core.parse),",
                "    formatAST: withPlugins(core.formatAST),",
                "    formatDoc: withPlugins(core.formatDoc),",
                "    printToDoc: withPlugins(core.printToDoc),",
                "    printDocToString: withPlugins(core.printDocToString),",
                "  },",
                "};"
            ]
        },
        "cli": {
            "constant.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { outdent } = require(\"outdent\");",
                    "const { coreOptions } = require(\"./prettier-internal.js\");",
                    "",
                    "const categoryOrder = [",
                    "  coreOptions.CATEGORY_OUTPUT,",
                    "  coreOptions.CATEGORY_FORMAT,",
                    "  coreOptions.CATEGORY_CONFIG,",
                    "  coreOptions.CATEGORY_EDITOR,",
                    "  coreOptions.CATEGORY_OTHER,",
                    "];",
                    "",
                    "/**",
                    " * {",
                    " *   [optionName]: {",
                    " *     // The type of the option. For 'choice', see also `choices` below.",
                    " *     // When passing a type other than the ones listed below, the option is",
                    " *     // treated as taking any string as argument, and `--option <${type}>` will",
                    " *     // be displayed in --help.",
                    " *     type: \"boolean\" | \"choice\" | \"int\" | string;",
                    " *",
                    " *     // Default value to be passed to the minimist option `default`.",
                    " *     default?: any;",
                    " *",
                    " *     // Alias name to be passed to the minimist option `alias`.",
                    " *     alias?: string;",
                    " *",
                    " *     // For grouping options by category in --help.",
                    " *     category?: string;",
                    " *",
                    " *     // Description to be displayed in --help. If omitted, the option won't be",
                    " *     // shown at all in --help (but see also `oppositeDescription` below).",
                    " *     description?: string;",
                    " *",
                    " *     // Description for `--no-${name}` to be displayed in --help. If omitted,",
                    " *     // `--no-${name}` won't be shown.",
                    " *     oppositeDescription?: string;",
                    " *",
                    " *     // Indicate if this option is simply passed to the API.",
                    " *     // true: use camelified name as the API option name.",
                    " *     // string: use this value as the API option name.",
                    " *     forwardToApi?: boolean | string;",
                    " *",
                    " *     // Indicate that a CLI flag should be an array when forwarded to the API.",
                    " *     array?: boolean;",
                    " *",
                    " *     // Specify available choices for validation. They will also be displayed",
                    " *     // in --help as <a|b|c>.",
                    " *     // Use an object instead of a string if a choice is deprecated and should",
                    " *     // be treated as `redirect` instead, or if you'd like to add description for",
                    " *     // the choice.",
                    " *     choices?: Array<",
                    " *       | string",
                    " *       | { value: string, description?: string, deprecated?: boolean, redirect?: string }",
                    " *     >;",
                    " *",
                    " *     // If the option has a value that is an exception to the regular value",
                    " *     // constraints, indicate that value here (or use a function for more",
                    " *     // flexibility).",
                    " *     exception?: ((value: any) => boolean);",
                    " *",
                    " *     // Indicate that the option is deprecated. Use a string to add an extra",
                    " *     // message to --help for the option, for example to suggest a replacement",
                    " *     // option.",
                    " *     deprecated?: true | string;",
                    " *   }",
                    " * }",
                    " *",
                    " * Note: The options below are sorted alphabetically.",
                    " */",
                    "const options = {",
                    "  check: {",
                    "    type: \"boolean\",",
                    "    category: coreOptions.CATEGORY_OUTPUT,",
                    "    alias: \"c\",",
                    "    description: outdent`",
                    "      Check if the given files are formatted, print a human-friendly summary",
                    "      message and paths to unformatted files (see also --list-different).",
                    "    `,",
                    "  },",
                    "  color: {",
                    "    // The supports-color package (a sub sub dependency) looks directly at",
                    "    // `process.argv` for `--no-color` and such-like options. The reason it is",
                    "    // listed here is to avoid \"Ignored unknown option: --no-color\" warnings.",
                    "    // See https://github.com/chalk/supports-color/#info for more information.",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Colorize error messages.\",",
                    "    oppositeDescription: \"Do not colorize error messages.\",",
                    "  },",
                    "  config: {",
                    "    type: \"path\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).\",",
                    "    oppositeDescription: \"Do not look for a configuration file.\",",
                    "    exception: (value) => value === false,",
                    "  },",
                    "  \"config-precedence\": {",
                    "    type: \"choice\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    default: \"cli-override\",",
                    "    choices: [",
                    "      {",
                    "        value: \"cli-override\",",
                    "        description: \"CLI options take precedence over config file\",",
                    "      },",
                    "      {",
                    "        value: \"file-override\",",
                    "        description: \"Config file take precedence over CLI options\",",
                    "      },",
                    "      {",
                    "        value: \"prefer-file\",",
                    "        description: outdent`",
                    "          If a config file is found will evaluate it and ignore other CLI options.",
                    "          If no config file is found CLI options will evaluate as normal.",
                    "        `,",
                    "      },",
                    "    ],",
                    "    description:",
                    "      \"Define in which order config files and CLI options should be evaluated.\",",
                    "  },",
                    "  \"debug-benchmark\": {",
                    "    // Run the formatting benchmarks. Requires 'benchmark' module to be installed.",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-check\": {",
                    "    // Run the formatting once again on the formatted output, throw if different.",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-print-doc\": {",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-print-comments\": {",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-print-ast\": {",
                    "    type: \"boolean\",",
                    "  },",
                    "  \"debug-repeat\": {",
                    "    // Repeat the formatting a few times and measure the average duration.",
                    "    type: \"int\",",
                    "    default: 0,",
                    "  },",
                    "  editorconfig: {",
                    "    type: \"boolean\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description: \"Take .editorconfig into account when parsing configuration.\",",
                    "    oppositeDescription:",
                    "      \"Don't take .editorconfig into account when parsing configuration.\",",
                    "    default: true,",
                    "  },",
                    "  \"error-on-unmatched-pattern\": {",
                    "    type: \"boolean\",",
                    "    oppositeDescription: \"Prevent errors when pattern is unmatched.\",",
                    "  },",
                    "  \"find-config-path\": {",
                    "    type: \"path\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Find and print the path to a configuration file for the given input file.\",",
                    "  },",
                    "  \"file-info\": {",
                    "    type: \"path\",",
                    "    description: outdent`",
                    "      Extract the following info (as JSON) for a given file path. Reported fields:",
                    "      * ignored (boolean) - true if file path is filtered by --ignore-path",
                    "      * inferredParser (string | null) - name of parser inferred from file path",
                    "    `,",
                    "  },",
                    "  help: {",
                    "    type: \"flag\",",
                    "    alias: \"h\",",
                    "    description: outdent`",
                    "      Show CLI usage, or details about the given flag.",
                    "      Example: --help write",
                    "    `,",
                    "    exception: (value) => value === \"\",",
                    "  },",
                    "  \"ignore-path\": {",
                    "    type: \"path\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    default: \".prettierignore\",",
                    "    description: \"Path to a file with patterns describing files to ignore.\",",
                    "  },",
                    "  \"ignore-unknown\": {",
                    "    type: \"boolean\",",
                    "    alias: \"u\",",
                    "    description: \"Ignore unknown files.\",",
                    "  },",
                    "  \"list-different\": {",
                    "    type: \"boolean\",",
                    "    category: coreOptions.CATEGORY_OUTPUT,",
                    "    alias: \"l\",",
                    "    description:",
                    "      \"Print the names of files that are different from Prettier's formatting (see also --check).\",",
                    "  },",
                    "  loglevel: {",
                    "    type: \"choice\",",
                    "    description: \"What level of logs to report.\",",
                    "    default: \"log\",",
                    "    choices: [\"silent\", \"error\", \"warn\", \"log\", \"debug\"],",
                    "  },",
                    "  \"support-info\": {",
                    "    type: \"boolean\",",
                    "    description: \"Print support information as JSON.\",",
                    "  },",
                    "  version: {",
                    "    type: \"boolean\",",
                    "    alias: \"v\",",
                    "    description: \"Print Prettier version.\",",
                    "  },",
                    "  \"with-node-modules\": {",
                    "    type: \"boolean\",",
                    "    category: coreOptions.CATEGORY_CONFIG,",
                    "    description: \"Process files inside 'node_modules' directory.\",",
                    "  },",
                    "  write: {",
                    "    type: \"boolean\",",
                    "    alias: \"w\",",
                    "    category: coreOptions.CATEGORY_OUTPUT,",
                    "    description: \"Edit files in-place. (Beware!)\",",
                    "  },",
                    "};",
                    "",
                    "const usageSummary = outdent`",
                    "  Usage: prettier [options] [file/dir/glob ...]",
                    "",
                    "  By default, output is written to stdout.",
                    "  Stdin is read if it is piped to Prettier and no files are given.",
                    "`;",
                    "",
                    "module.exports = {",
                    "  categoryOrder,",
                    "  options,",
                    "  usageSummary,",
                    "};"
                ]
            },
            "context.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const {",
                    "  utils: { getLast },",
                    "} = require(\"./prettier-internal.js\");",
                    "const getContextOptions = require(\"./options/get-context-options.js\");",
                    "const {",
                    "  parseArgv,",
                    "  parseArgvWithoutPlugins,",
                    "} = require(\"./options/parse-cli-arguments.js\");",
                    "",
                    "/**",
                    " * @typedef {Object} Context",
                    " * @property logger",
                    " * @property {string[]} rawArguments",
                    " * @property argv",
                    " * @property {string[]} filePatterns",
                    " * @property {any[]} supportOptions",
                    " * @property detailedOptions",
                    " * @property detailedOptionMap",
                    " * @property apiDefaultOptions",
                    " * @property languages",
                    " * @property {Partial<Context>[]} stack",
                    " * @property pushContextPlugins",
                    " * @property popContextPlugins",
                    " */",
                    "",
                    "class Context {",
                    "  constructor({ rawArguments, logger }) {",
                    "    this.rawArguments = rawArguments;",
                    "    this.logger = logger;",
                    "    this.stack = [];",
                    "",
                    "    const { plugins, pluginSearchDirs } = parseArgvWithoutPlugins(",
                    "      rawArguments,",
                    "      logger,",
                    "      [\"plugin\", \"plugin-search-dir\"]",
                    "    );",
                    "",
                    "    this.pushContextPlugins(plugins, pluginSearchDirs);",
                    "",
                    "    const argv = parseArgv(rawArguments, this.detailedOptions, logger);",
                    "    this.argv = argv;",
                    "    this.filePatterns = argv._.map((file) => String(file));",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string[]} plugins",
                    "   * @param {string[]=} pluginSearchDirs",
                    "   */",
                    "  pushContextPlugins(plugins, pluginSearchDirs) {",
                    "    const options = getContextOptions(plugins, pluginSearchDirs);",
                    "    this.stack.push(options);",
                    "    Object.assign(this, options);",
                    "  }",
                    "",
                    "  popContextPlugins() {",
                    "    this.stack.pop();",
                    "    Object.assign(this, getLast(this.stack));",
                    "  }",
                    "}",
                    "",
                    "module.exports = Context;"
                ]
            },
            "expand-patterns.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const { promises: fs } = require(\"fs\");",
                    "const fastGlob = require(\"fast-glob\");",
                    "",
                    "/** @typedef {import('./context').Context} Context */",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "async function* expandPatterns(context) {",
                    "  const cwd = process.cwd();",
                    "  const seen = new Set();",
                    "  let noResults = true;",
                    "",
                    "  for await (const pathOrError of expandPatternsInternal(context)) {",
                    "    noResults = false;",
                    "    if (typeof pathOrError !== \"string\") {",
                    "      yield pathOrError;",
                    "      continue;",
                    "    }",
                    "",
                    "    const relativePath = path.relative(cwd, pathOrError);",
                    "",
                    "    // filter out duplicates",
                    "    if (seen.has(relativePath)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    seen.add(relativePath);",
                    "    yield relativePath;",
                    "  }",
                    "",
                    "  if (noResults && context.argv.errorOnUnmatchedPattern !== false) {",
                    "    // If there was no files and no other errors, let's yield a general error.",
                    "    yield {",
                    "      error: `No matching files. Patterns: ${context.filePatterns.join(\" \")}`,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "async function* expandPatternsInternal(context) {",
                    "  // Ignores files in version control systems directories and `node_modules`",
                    "  const silentlyIgnoredDirs = [\".git\", \".svn\", \".hg\"];",
                    "  if (context.argv.withNodeModules !== true) {",
                    "    silentlyIgnoredDirs.push(\"node_modules\");",
                    "  }",
                    "  const globOptions = {",
                    "    dot: true,",
                    "    ignore: silentlyIgnoredDirs.map((dir) => \"**/\" + dir),",
                    "  };",
                    "",
                    "  let supportedFilesGlob;",
                    "  const cwd = process.cwd();",
                    "",
                    "  /** @type {Array<{ type: 'file' | 'dir' | 'glob'; glob: string; input: string; }>} */",
                    "  const entries = [];",
                    "",
                    "  for (const pattern of context.filePatterns) {",
                    "    const absolutePath = path.resolve(cwd, pattern);",
                    "",
                    "    if (containsIgnoredPathSegment(absolutePath, cwd, silentlyIgnoredDirs)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const stat = await statSafe(absolutePath);",
                    "    if (stat) {",
                    "      if (stat.isFile()) {",
                    "        entries.push({",
                    "          type: \"file\",",
                    "          glob: escapePathForGlob(fixWindowsSlashes(pattern)),",
                    "          input: pattern,",
                    "        });",
                    "      } else if (stat.isDirectory()) {",
                    "        /*",
                    "        1. Remove trailing `/`, `fast-glob` can't find files for `src//*.js` pattern",
                    "        2. Cleanup dirname, when glob `src/../*.js` pattern with `fast-glob`,",
                    "          it returns files like 'src/../index.js'",
                    "        */",
                    "        const relativePath = path.relative(cwd, absolutePath) || \".\";",
                    "        entries.push({",
                    "          type: \"dir\",",
                    "          glob:",
                    "            escapePathForGlob(fixWindowsSlashes(relativePath)) +",
                    "            \"/\" +",
                    "            getSupportedFilesGlob(),",
                    "          input: pattern,",
                    "        });",
                    "      }",
                    "    } else if (pattern[0] === \"!\") {",
                    "      // convert negative patterns to `ignore` entries",
                    "      globOptions.ignore.push(fixWindowsSlashes(pattern.slice(1)));",
                    "    } else {",
                    "      entries.push({",
                    "        type: \"glob\",",
                    "        glob: fixWindowsSlashes(pattern),",
                    "        input: pattern,",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  for (const { type, glob, input } of entries) {",
                    "    let result;",
                    "",
                    "    try {",
                    "      result = await fastGlob(glob, globOptions);",
                    "    } catch ({ message }) {",
                    "      /* istanbul ignore next */",
                    "      yield { error: `${errorMessages.globError[type]}: ${input}\\n${message}` };",
                    "      /* istanbul ignore next */",
                    "      continue;",
                    "    }",
                    "",
                    "    if (result.length === 0) {",
                    "      if (context.argv.errorOnUnmatchedPattern !== false) {",
                    "        yield { error: `${errorMessages.emptyResults[type]}: \"${input}\".` };",
                    "      }",
                    "    } else {",
                    "      yield* sortPaths(result);",
                    "    }",
                    "  }",
                    "",
                    "  function getSupportedFilesGlob() {",
                    "    if (!supportedFilesGlob) {",
                    "      const extensions = context.languages.flatMap(",
                    "        (lang) => lang.extensions || []",
                    "      );",
                    "      const filenames = context.languages.flatMap(",
                    "        (lang) => lang.filenames || []",
                    "      );",
                    "      supportedFilesGlob = `**/{${[",
                    "        ...extensions.map((ext) => \"*\" + (ext[0] === \".\" ? ext : \".\" + ext)),",
                    "        ...filenames,",
                    "      ]}}`;",
                    "    }",
                    "    return supportedFilesGlob;",
                    "  }",
                    "}",
                    "",
                    "const errorMessages = {",
                    "  globError: {",
                    "    file: \"Unable to resolve file\",",
                    "    dir: \"Unable to expand directory\",",
                    "    glob: \"Unable to expand glob pattern\",",
                    "  },",
                    "  emptyResults: {",
                    "    file: \"Explicitly specified file was ignored due to negative glob patterns\",",
                    "    dir: \"No supported files were found in the directory\",",
                    "    glob: \"No files matching the pattern were found\",",
                    "  },",
                    "};",
                    "",
                    "/**",
                    " * @param {string} absolutePath",
                    " * @param {string} cwd",
                    " * @param {string[]} ignoredDirectories",
                    " */",
                    "function containsIgnoredPathSegment(absolutePath, cwd, ignoredDirectories) {",
                    "  return path",
                    "    .relative(cwd, absolutePath)",
                    "    .split(path.sep)",
                    "    .some((dir) => ignoredDirectories.includes(dir));",
                    "}",
                    "",
                    "/**",
                    " * @param {string[]} paths",
                    " */",
                    "function sortPaths(paths) {",
                    "  return paths.sort((a, b) => a.localeCompare(b));",
                    "}",
                    "",
                    "/**",
                    " * Get stats of a given path.",
                    " * @param {string} filePath The path to target file.",
                    " * @returns {Promise<import('fs').Stats | undefined>} The stats.",
                    " */",
                    "async function statSafe(filePath) {",
                    "  try {",
                    "    return await fs.stat(filePath);",
                    "  } catch (error) {",
                    "    /* istanbul ignore next */",
                    "    if (error.code !== \"ENOENT\") {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * This function should be replaced with `fastGlob.escapePath` when these issues are fixed:",
                    " * - https://github.com/mrmlnc/fast-glob/issues/261",
                    " * - https://github.com/mrmlnc/fast-glob/issues/262",
                    " * @param {string} path",
                    " */",
                    "function escapePathForGlob(path) {",
                    "  return fastGlob",
                    "    .escapePath(",
                    "      path.replace(/\\\\/g, \"\\0\") // Workaround for fast-glob#262 (part 1)",
                    "    )",
                    "    .replace(/\\\\!/g, \"@(!)\") // Workaround for fast-glob#261",
                    "    .replace(/\\0/g, \"@(\\\\\\\\)\"); // Workaround for fast-glob#262 (part 2)",
                    "}",
                    "",
                    "const isWindows = path.sep === \"\\\\\";",
                    "",
                    "/**",
                    " * Using backslashes in globs is probably not okay, but not accepting",
                    " * backslashes as path separators on Windows is even more not okay.",
                    " * https://github.com/prettier/prettier/pull/6776#discussion_r380723717",
                    " * https://github.com/mrmlnc/fast-glob#how-to-write-patterns-on-windows",
                    " * @param {string} pattern",
                    " */",
                    "function fixWindowsSlashes(pattern) {",
                    "  return isWindows ? pattern.replace(/\\\\/g, \"/\") : pattern;",
                    "}",
                    "",
                    "module.exports = {",
                    "  expandPatterns,",
                    "  fixWindowsSlashes,",
                    "};"
                ]
            },
            "file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const stringify = require(\"fast-json-stable-stringify\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index.js\");",
                    "",
                    "async function logFileInfoOrDie(context) {",
                    "  const {",
                    "    fileInfo: file,",
                    "    ignorePath,",
                    "    withNodeModules,",
                    "    plugins,",
                    "    pluginSearchDirs,",
                    "    config,",
                    "  } = context.argv;",
                    "",
                    "  const fileInfo = await prettier.getFileInfo(file, {",
                    "    ignorePath,",
                    "    withNodeModules,",
                    "    plugins,",
                    "    pluginSearchDirs,",
                    "    resolveConfig: config !== false,",
                    "  });",
                    "",
                    "  context.logger.log(prettier.format(stringify(fileInfo), { parser: \"json\" }));",
                    "}",
                    "",
                    "module.exports = logFileInfoOrDie;"
                ]
            },
            "find-config-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index.js\");",
                    "",
                    "async function logResolvedConfigPathOrDie(context) {",
                    "  const file = context.argv.findConfigPath;",
                    "  const configFile = await prettier.resolveConfigFile(file);",
                    "  if (configFile) {",
                    "    context.logger.log(path.relative(process.cwd(), configFile));",
                    "  } else {",
                    "    throw new Error(`Can not find configure file for \"${file}\"`);",
                    "  }",
                    "}",
                    "",
                    "module.exports = logResolvedConfigPathOrDie;"
                ]
            },
            "format.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { promises: fs } = require(\"fs\");",
                    "const path = require(\"path\");",
                    "",
                    "const chalk = require(\"chalk\");",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index.js\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { getStdin } = require(\"../common/third-party.js\");",
                    "",
                    "const { createIgnorer, errors } = require(\"./prettier-internal.js\");",
                    "const { expandPatterns, fixWindowsSlashes } = require(\"./expand-patterns.js\");",
                    "const getOptionsForFile = require(\"./options/get-options-for-file.js\");",
                    "const isTTY = require(\"./is-tty.js\");",
                    "",
                    "function diff(a, b) {",
                    "  // Use `diff/lib/patch/create.js` instead of `diff` to reduce bundle size",
                    "  return require(\"diff/lib/patch/create.js\").createTwoFilesPatch(",
                    "    \"\",",
                    "    \"\",",
                    "    a,",
                    "    b,",
                    "    \"\",",
                    "    \"\",",
                    "    {",
                    "      context: 2,",
                    "    }",
                    "  );",
                    "}",
                    "",
                    "function handleError(context, filename, error, printedFilename) {",
                    "  if (error instanceof errors.UndefinedParserError) {",
                    "    // Can't test on CI, `isTTY()` is always false, see ./is-tty.js",
                    "    /* istanbul ignore next */",
                    "    if ((context.argv.write || context.argv.ignoreUnknown) && printedFilename) {",
                    "      printedFilename.clear();",
                    "    }",
                    "    if (context.argv.ignoreUnknown) {",
                    "      return;",
                    "    }",
                    "    if (!context.argv.check && !context.argv.listDifferent) {",
                    "      process.exitCode = 2;",
                    "    }",
                    "    context.logger.error(error.message);",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.write) {",
                    "    // Add newline to split errors from filename line.",
                    "    process.stdout.write(\"\\n\");",
                    "  }",
                    "",
                    "  const isParseError = Boolean(error && error.loc);",
                    "  const isValidationError = /^Invalid \\S+ value\\./.test(error && error.message);",
                    "",
                    "  if (isParseError) {",
                    "    // `invalid.js: SyntaxError: Unexpected token (1:1)`.",
                    "    context.logger.error(`${filename}: ${String(error)}`);",
                    "  } else if (isValidationError || error instanceof errors.ConfigError) {",
                    "    // `Invalid printWidth value. Expected an integer, but received 0.5.`",
                    "    context.logger.error(error.message);",
                    "    // If validation fails for one file, it will fail for all of them.",
                    "    process.exit(1);",
                    "  } else if (error instanceof errors.DebugError) {",
                    "    // `invalid.js: Some debug error message`",
                    "    context.logger.error(`${filename}: ${error.message}`);",
                    "  } else {",
                    "    // `invalid.js: Error: Some unexpected error\\n[stack trace]`",
                    "    /* istanbul ignore next */",
                    "    context.logger.error(filename + \": \" + (error.stack || error));",
                    "  }",
                    "",
                    "  // Don't exit the process if one file failed",
                    "  process.exitCode = 2;",
                    "}",
                    "",
                    "function writeOutput(context, result, options) {",
                    "  // Don't use `console.log` here since it adds an extra newline at the end.",
                    "  process.stdout.write(",
                    "    context.argv.debugCheck ? result.filepath : result.formatted",
                    "  );",
                    "",
                    "  if (options && options.cursorOffset >= 0) {",
                    "    process.stderr.write(result.cursorOffset + \"\\n\");",
                    "  }",
                    "}",
                    "",
                    "function listDifferent(context, input, options, filename) {",
                    "  if (!context.argv.check && !context.argv.listDifferent) {",
                    "    return;",
                    "  }",
                    "",
                    "  try {",
                    "    if (!options.filepath && !options.parser) {",
                    "      throw new errors.UndefinedParserError(",
                    "        \"No parser and no file path given, couldn't infer a parser.\"",
                    "      );",
                    "    }",
                    "    if (!prettier.check(input, options)) {",
                    "      if (!context.argv.write) {",
                    "        context.logger.log(filename);",
                    "        process.exitCode = 1;",
                    "      }",
                    "    }",
                    "  } catch (error) {",
                    "    context.logger.error(error.message);",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function format(context, input, opt) {",
                    "  if (!opt.parser && !opt.filepath) {",
                    "    throw new errors.UndefinedParserError(",
                    "      \"No parser and no file path given, couldn't infer a parser.\"",
                    "    );",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintDoc) {",
                    "    const doc = prettier.__debug.printToDoc(input, opt);",
                    "    return { formatted: prettier.__debug.formatDoc(doc) + \"\\n\" };",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintComments) {",
                    "    return {",
                    "      formatted: prettier.format(",
                    "        JSON.stringify(prettier.formatWithCursor(input, opt).comments || []),",
                    "        { parser: \"json\" }",
                    "      ),",
                    "    };",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintAst) {",
                    "    const { ast } = prettier.__debug.parse(input, opt);",
                    "    return {",
                    "      formatted: JSON.stringify(ast),",
                    "    };",
                    "  }",
                    "",
                    "  if (context.argv.debugCheck) {",
                    "    const pp = prettier.format(input, opt);",
                    "    const pppp = prettier.format(pp, opt);",
                    "    if (pp !== pppp) {",
                    "      throw new errors.DebugError(",
                    "        \"prettier(input) !== prettier(prettier(input))\\n\" + diff(pp, pppp)",
                    "      );",
                    "    } else {",
                    "      const stringify = (obj) => JSON.stringify(obj, null, 2);",
                    "      const ast = stringify(",
                    "        prettier.__debug.parse(input, opt, /* massage */ true).ast",
                    "      );",
                    "      const past = stringify(",
                    "        prettier.__debug.parse(pp, opt, /* massage */ true).ast",
                    "      );",
                    "",
                    "      /* istanbul ignore next */",
                    "      if (ast !== past) {",
                    "        const MAX_AST_SIZE = 2097152; // 2MB",
                    "        const astDiff =",
                    "          ast.length > MAX_AST_SIZE || past.length > MAX_AST_SIZE",
                    "            ? \"AST diff too large to render\"",
                    "            : diff(ast, past);",
                    "        throw new errors.DebugError(",
                    "          \"ast(input) !== ast(prettier(input))\\n\" +",
                    "            astDiff +",
                    "            \"\\n\" +",
                    "            diff(input, pp)",
                    "        );",
                    "      }",
                    "    }",
                    "    return { formatted: pp, filepath: opt.filepath || \"(stdin)\\n\" };",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (context.argv.debugBenchmark) {",
                    "    let benchmark;",
                    "    try {",
                    "      // eslint-disable-next-line import/no-extraneous-dependencies",
                    "      benchmark = require(\"benchmark\");",
                    "    } catch {",
                    "      context.logger.debug(",
                    "        \"'--debug-benchmark' requires the 'benchmark' package to be installed.\"",
                    "      );",
                    "      process.exit(2);",
                    "    }",
                    "    context.logger.debug(",
                    "      \"'--debug-benchmark' option found, measuring formatWithCursor with 'benchmark' module.\"",
                    "    );",
                    "    const suite = new benchmark.Suite();",
                    "    suite",
                    "      .add(\"format\", () => {",
                    "        prettier.formatWithCursor(input, opt);",
                    "      })",
                    "      .on(\"cycle\", (event) => {",
                    "        const results = {",
                    "          benchmark: String(event.target),",
                    "          hz: event.target.hz,",
                    "          ms: event.target.times.cycle * 1000,",
                    "        };",
                    "        context.logger.debug(",
                    "          \"'--debug-benchmark' measurements for formatWithCursor: \" +",
                    "            JSON.stringify(results, null, 2)",
                    "        );",
                    "      })",
                    "      .run({ async: false });",
                    "  } else if (context.argv.debugRepeat > 0) {",
                    "    const repeat = context.argv.debugRepeat;",
                    "    context.logger.debug(",
                    "      \"'--debug-repeat' option found, running formatWithCursor \" +",
                    "        repeat +",
                    "        \" times.\"",
                    "    );",
                    "    let totalMs = 0;",
                    "    for (let i = 0; i < repeat; ++i) {",
                    "      // should be using `performance.now()`, but only `Date` is cross-platform enough",
                    "      const startMs = Date.now();",
                    "      prettier.formatWithCursor(input, opt);",
                    "      totalMs += Date.now() - startMs;",
                    "    }",
                    "    const averageMs = totalMs / repeat;",
                    "    const results = {",
                    "      repeat,",
                    "      hz: 1000 / averageMs,",
                    "      ms: averageMs,",
                    "    };",
                    "    context.logger.debug(",
                    "      \"'--debug-repeat' measurements for formatWithCursor: \" +",
                    "        JSON.stringify(results, null, 2)",
                    "    );",
                    "  }",
                    "",
                    "  return prettier.formatWithCursor(input, opt);",
                    "}",
                    "",
                    "async function createIgnorerFromContextOrDie(context) {",
                    "  try {",
                    "    return await createIgnorer(",
                    "      context.argv.ignorePath,",
                    "      context.argv.withNodeModules",
                    "    );",
                    "  } catch (e) {",
                    "    context.logger.error(e.message);",
                    "    process.exit(2);",
                    "  }",
                    "}",
                    "",
                    "async function formatStdin(context) {",
                    "  const filepath = context.argv.filepath",
                    "    ? path.resolve(process.cwd(), context.argv.filepath)",
                    "    : process.cwd();",
                    "",
                    "  const ignorer = await createIgnorerFromContextOrDie(context);",
                    "  // If there's an ignore-path set, the filename must be relative to the",
                    "  // ignore path, not the current working directory.",
                    "  const relativeFilepath = context.argv.ignorePath",
                    "    ? path.relative(path.dirname(context.argv.ignorePath), filepath)",
                    "    : path.relative(process.cwd(), filepath);",
                    "",
                    "  try {",
                    "    const input = await getStdin();",
                    "",
                    "    if (",
                    "      relativeFilepath &&",
                    "      ignorer.ignores(fixWindowsSlashes(relativeFilepath))",
                    "    ) {",
                    "      writeOutput(context, { formatted: input });",
                    "      return;",
                    "    }",
                    "",
                    "    const options = await getOptionsForFile(context, filepath);",
                    "",
                    "    if (listDifferent(context, input, options, \"(stdin)\")) {",
                    "      return;",
                    "    }",
                    "",
                    "    writeOutput(context, format(context, input, options), options);",
                    "  } catch (error) {",
                    "    handleError(context, relativeFilepath || \"stdin\", error);",
                    "  }",
                    "}",
                    "",
                    "async function formatFiles(context) {",
                    "  // The ignorer will be used to filter file paths after the glob is checked,",
                    "  // before any files are actually written",
                    "  const ignorer = await createIgnorerFromContextOrDie(context);",
                    "",
                    "  let numberOfUnformattedFilesFound = 0;",
                    "",
                    "  if (context.argv.check) {",
                    "    context.logger.log(\"Checking formatting...\");",
                    "  }",
                    "",
                    "  for await (const pathOrError of expandPatterns(context)) {",
                    "    if (typeof pathOrError === \"object\") {",
                    "      context.logger.error(pathOrError.error);",
                    "      // Don't exit, but set the exit code to 2",
                    "      process.exitCode = 2;",
                    "      continue;",
                    "    }",
                    "",
                    "    const filename = pathOrError;",
                    "    // If there's an ignore-path set, the filename must be relative to the",
                    "    // ignore path, not the current working directory.",
                    "    const ignoreFilename = context.argv.ignorePath",
                    "      ? path.relative(path.dirname(context.argv.ignorePath), filename)",
                    "      : filename;",
                    "",
                    "    const fileIgnored = ignorer.ignores(fixWindowsSlashes(ignoreFilename));",
                    "    if (",
                    "      fileIgnored &&",
                    "      (context.argv.debugCheck ||",
                    "        context.argv.write ||",
                    "        context.argv.check ||",
                    "        context.argv.listDifferent)",
                    "    ) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const options = {",
                    "      ...(await getOptionsForFile(context, filename)),",
                    "      filepath: filename,",
                    "    };",
                    "",
                    "    let printedFilename;",
                    "    if (isTTY()) {",
                    "      printedFilename = context.logger.log(filename, {",
                    "        newline: false,",
                    "        clearable: true,",
                    "      });",
                    "    }",
                    "",
                    "    let input;",
                    "    try {",
                    "      input = await fs.readFile(filename, \"utf8\");",
                    "    } catch (error) {",
                    "      // Add newline to split errors from filename line.",
                    "      /* istanbul ignore next */",
                    "      context.logger.log(\"\");",
                    "",
                    "      /* istanbul ignore next */",
                    "      context.logger.error(",
                    "        `Unable to read file: ${filename}\\n${error.message}`",
                    "      );",
                    "",
                    "      // Don't exit the process if one file failed",
                    "      /* istanbul ignore next */",
                    "      process.exitCode = 2;",
                    "",
                    "      /* istanbul ignore next */",
                    "      continue;",
                    "    }",
                    "",
                    "    if (fileIgnored) {",
                    "      writeOutput(context, { formatted: input }, options);",
                    "      continue;",
                    "    }",
                    "",
                    "    const start = Date.now();",
                    "",
                    "    let result;",
                    "    let output;",
                    "",
                    "    try {",
                    "      result = format(context, input, options);",
                    "      output = result.formatted;",
                    "    } catch (error) {",
                    "      handleError(context, filename, error, printedFilename);",
                    "      continue;",
                    "    }",
                    "",
                    "    const isDifferent = output !== input;",
                    "",
                    "    if (printedFilename) {",
                    "      // Remove previously printed filename to log it with duration.",
                    "      printedFilename.clear();",
                    "    }",
                    "",
                    "    if (context.argv.write) {",
                    "      // Don't write the file if it won't change in order not to invalidate",
                    "      // mtime based caches.",
                    "      if (isDifferent) {",
                    "        if (!context.argv.check && !context.argv.listDifferent) {",
                    "          context.logger.log(`${filename} ${Date.now() - start}ms`);",
                    "        }",
                    "",
                    "        try {",
                    "          await fs.writeFile(filename, output, \"utf8\");",
                    "        } catch (error) {",
                    "          /* istanbul ignore next */",
                    "          context.logger.error(",
                    "            `Unable to write file: ${filename}\\n${error.message}`",
                    "          );",
                    "",
                    "          // Don't exit the process if one file failed",
                    "          /* istanbul ignore next */",
                    "          process.exitCode = 2;",
                    "        }",
                    "      } else if (!context.argv.check && !context.argv.listDifferent) {",
                    "        context.logger.log(`${chalk.grey(filename)} ${Date.now() - start}ms`);",
                    "      }",
                    "    } else if (context.argv.debugCheck) {",
                    "      /* istanbul ignore else */",
                    "      if (result.filepath) {",
                    "        context.logger.log(result.filepath);",
                    "      } else {",
                    "        process.exitCode = 2;",
                    "      }",
                    "    } else if (!context.argv.check && !context.argv.listDifferent) {",
                    "      writeOutput(context, result, options);",
                    "    }",
                    "",
                    "    if (isDifferent) {",
                    "      if (context.argv.check) {",
                    "        context.logger.warn(filename);",
                    "      } else if (context.argv.listDifferent) {",
                    "        context.logger.log(filename);",
                    "      }",
                    "      numberOfUnformattedFilesFound += 1;",
                    "    }",
                    "  }",
                    "",
                    "  // Print check summary based on expected exit code",
                    "  if (context.argv.check) {",
                    "    if (numberOfUnformattedFilesFound === 0) {",
                    "      context.logger.log(\"All matched files use Prettier code style!\");",
                    "    } else {",
                    "      context.logger.warn(",
                    "        context.argv.write",
                    "          ? \"Code style issues fixed in the above file(s).\"",
                    "          : \"Code style issues found in the above file(s). Forgot to run Prettier?\"",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  // Ensure non-zero exitCode when using --check/list-different is not combined with --write",
                    "  if (",
                    "    (context.argv.check || context.argv.listDifferent) &&",
                    "    numberOfUnformattedFilesFound > 0 &&",
                    "    !process.exitCode &&",
                    "    !context.argv.write",
                    "  ) {",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "module.exports = { formatStdin, formatFiles };"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const packageJson = require(\"../../package.json\");",
                    "require(\"please-upgrade-node\")(packageJson);",
                    "",
                    "// eslint-disable-next-line import/order",
                    "const stringify = require(\"fast-json-stable-stringify\");",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const prettier = require(\"../index.js\");",
                    "const createLogger = require(\"./logger.js\");",
                    "const Context = require(\"./context.js\");",
                    "const { parseArgvWithoutPlugins } = require(\"./options/parse-cli-arguments.js\");",
                    "const { createDetailedUsage, createUsage } = require(\"./usage.js\");",
                    "const { formatStdin, formatFiles } = require(\"./format.js\");",
                    "const logFileInfoOrDie = require(\"./file-info.js\");",
                    "const logResolvedConfigPathOrDie = require(\"./find-config-path.js\");",
                    "",
                    "async function run(rawArguments) {",
                    "  // Create a default level logger, so we can log errors during `logLevel` parsing",
                    "  let logger = createLogger();",
                    "",
                    "  try {",
                    "    const logLevel = parseArgvWithoutPlugins(",
                    "      rawArguments,",
                    "      logger,",
                    "      \"loglevel\"",
                    "    ).loglevel;",
                    "    if (logLevel !== logger.logLevel) {",
                    "      logger = createLogger(logLevel);",
                    "    }",
                    "",
                    "    await main(rawArguments, logger);",
                    "  } catch (error) {",
                    "    logger.error(error.message);",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "async function main(rawArguments, logger) {",
                    "  const context = new Context({ rawArguments, logger });",
                    "",
                    "  logger.debug(`normalized argv: ${JSON.stringify(context.argv)}`);",
                    "",
                    "  if (context.argv.check && context.argv.listDifferent) {",
                    "    throw new Error(\"Cannot use --check and --list-different together.\");",
                    "  }",
                    "",
                    "  if (context.argv.write && context.argv.debugCheck) {",
                    "    throw new Error(\"Cannot use --write and --debug-check together.\");",
                    "  }",
                    "",
                    "  if (context.argv.findConfigPath && context.filePatterns.length > 0) {",
                    "    throw new Error(\"Cannot use --find-config-path with multiple files\");",
                    "  }",
                    "",
                    "  if (context.argv.fileInfo && context.filePatterns.length > 0) {",
                    "    throw new Error(\"Cannot use --file-info with multiple files\");",
                    "  }",
                    "",
                    "  if (context.argv.version) {",
                    "    logger.log(prettier.version);",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.help !== undefined) {",
                    "    logger.log(",
                    "      typeof context.argv.help === \"string\" && context.argv.help !== \"\"",
                    "        ? createDetailedUsage(context, context.argv.help)",
                    "        : createUsage(context)",
                    "    );",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.supportInfo) {",
                    "    logger.log(",
                    "      prettier.format(stringify(prettier.getSupportInfo()), {",
                    "        parser: \"json\",",
                    "      })",
                    "    );",
                    "    return;",
                    "  }",
                    "",
                    "  const hasFilePatterns = context.filePatterns.length > 0;",
                    "  const useStdin =",
                    "    !hasFilePatterns && (!process.stdin.isTTY || context.argv.filePath);",
                    "",
                    "  if (context.argv.findConfigPath) {",
                    "    await logResolvedConfigPathOrDie(context);",
                    "  } else if (context.argv.fileInfo) {",
                    "    await logFileInfoOrDie(context);",
                    "  } else if (useStdin) {",
                    "    await formatStdin(context);",
                    "  } else if (hasFilePatterns) {",
                    "    await formatFiles(context);",
                    "  } else {",
                    "    logger.log(createUsage(context));",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  run,",
                    "};"
                ]
            },
            "is-tty.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "const { isCI } = require(\"../common/third-party.js\");",
                    "",
                    "// Some CI pipelines incorrectly report process.stdout.isTTY status,",
                    "// which causes unwanted lines in the output. An additional check for isCI() helps.",
                    "// See https://github.com/prettier/prettier/issues/5801",
                    "module.exports = function isTTY() {",
                    "  return process.stdout.isTTY && !isCI();",
                    "};"
                ]
            },
            "logger.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const readline = require(\"readline\");",
                    "const chalk = require(\"chalk\");",
                    "const stripAnsi = require(\"strip-ansi\");",
                    "const wcwidth = require(\"wcwidth\");",
                    "",
                    "const countLines = (stream, text) => {",
                    "  const columns = stream.columns || 80;",
                    "  let lineCount = 0;",
                    "  for (const line of stripAnsi(text).split(\"\\n\")) {",
                    "    lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));",
                    "  }",
                    "  return lineCount;",
                    "};",
                    "",
                    "const clear = (stream, text) => () => {",
                    "  const lineCount = countLines(stream, text);",
                    "",
                    "  for (let line = 0; line < lineCount; line++) {",
                    "    if (line > 0) {",
                    "      readline.moveCursor(stream, 0, -1);",
                    "    }",
                    "",
                    "    readline.clearLine(stream, 0);",
                    "    readline.cursorTo(stream, 0);",
                    "  }",
                    "};",
                    "",
                    "const emptyLogResult = { clear() {} };",
                    "function createLogger(logLevel = \"log\") {",
                    "  return {",
                    "    logLevel,",
                    "    warn: createLogFunc(\"warn\", \"yellow\"),",
                    "    error: createLogFunc(\"error\", \"red\"),",
                    "    debug: createLogFunc(\"debug\", \"blue\"),",
                    "    log: createLogFunc(\"log\"),",
                    "  };",
                    "",
                    "  function createLogFunc(loggerName, color) {",
                    "    if (!shouldLog(loggerName)) {",
                    "      return () => emptyLogResult;",
                    "    }",
                    "",
                    "    const prefix = color ? `[${chalk[color](loggerName)}] ` : \"\";",
                    "    const stream = process[loggerName === \"log\" ? \"stdout\" : \"stderr\"];",
                    "",
                    "    return (message, options) => {",
                    "      options = {",
                    "        newline: true,",
                    "        clearable: false,",
                    "        ...options,",
                    "      };",
                    "      message = message.replace(/^/gm, prefix) + (options.newline ? \"\\n\" : \"\");",
                    "      stream.write(message);",
                    "",
                    "      if (options.clearable) {",
                    "        return {",
                    "          clear: clear(stream, message),",
                    "        };",
                    "      }",
                    "    };",
                    "  }",
                    "",
                    "  function shouldLog(loggerName) {",
                    "    switch (logLevel) {",
                    "      case \"silent\":",
                    "        return false;",
                    "      case \"debug\":",
                    "        if (loggerName === \"debug\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"log\":",
                    "        if (loggerName === \"log\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"warn\":",
                    "        if (loggerName === \"warn\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"error\":",
                    "        return loggerName === \"error\";",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = createLogger;"
                ]
            },
            "prettier-internal.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// eslint-disable-next-line no-restricted-modules",
                    "module.exports = require(\"../index.js\").__internal;"
                ]
            },
            "usage.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const groupBy = require(\"lodash/groupBy\");",
                    "const camelCase = require(\"camelcase\");",
                    "const constant = require(\"./constant.js\");",
                    "",
                    "const OPTION_USAGE_THRESHOLD = 25;",
                    "const CHOICE_USAGE_MARGIN = 3;",
                    "const CHOICE_USAGE_INDENTATION = 2;",
                    "",
                    "function indent(str, spaces) {",
                    "  return str.replace(/^/gm, \" \".repeat(spaces));",
                    "}",
                    "",
                    "function createDefaultValueDisplay(value) {",
                    "  return Array.isArray(value)",
                    "    ? `[${value.map(createDefaultValueDisplay).join(\", \")}]`",
                    "    : value;",
                    "}",
                    "",
                    "function getOptionDefaultValue(context, optionName) {",
                    "  // --no-option",
                    "  if (!(optionName in context.detailedOptionMap)) {",
                    "    return;",
                    "  }",
                    "",
                    "  const option = context.detailedOptionMap[optionName];",
                    "",
                    "  if (option.default !== undefined) {",
                    "    return option.default;",
                    "  }",
                    "",
                    "  const optionCamelName = camelCase(optionName);",
                    "  if (optionCamelName in context.apiDefaultOptions) {",
                    "    return context.apiDefaultOptions[optionCamelName];",
                    "  }",
                    "}",
                    "",
                    "function createOptionUsageHeader(option) {",
                    "  const name = `--${option.name}`;",
                    "  const alias = option.alias ? `-${option.alias},` : null;",
                    "  const type = createOptionUsageType(option);",
                    "  return [alias, name, type].filter(Boolean).join(\" \");",
                    "}",
                    "",
                    "function createOptionUsageRow(header, content, threshold) {",
                    "  const separator =",
                    "    header.length >= threshold",
                    "      ? `\\n${\" \".repeat(threshold)}`",
                    "      : \" \".repeat(threshold - header.length);",
                    "",
                    "  const description = content.replace(/\\n/g, `\\n${\" \".repeat(threshold)}`);",
                    "",
                    "  return `${header}${separator}${description}`;",
                    "}",
                    "",
                    "function createOptionUsageType(option) {",
                    "  switch (option.type) {",
                    "    case \"boolean\":",
                    "      return null;",
                    "    case \"choice\":",
                    "      return `<${option.choices",
                    "        .filter((choice) => !choice.deprecated && choice.since !== null)",
                    "        .map((choice) => choice.value)",
                    "        .join(\"|\")}>`;",
                    "    default:",
                    "      return `<${option.type}>`;",
                    "  }",
                    "}",
                    "",
                    "function createChoiceUsages(choices, margin, indentation) {",
                    "  const activeChoices = choices.filter(",
                    "    (choice) => !choice.deprecated && choice.since !== null",
                    "  );",
                    "  const threshold =",
                    "    Math.max(0, ...activeChoices.map((choice) => choice.value.length)) + margin;",
                    "  return activeChoices.map((choice) =>",
                    "    indent(",
                    "      createOptionUsageRow(choice.value, choice.description, threshold),",
                    "      indentation",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function createOptionUsage(context, option, threshold) {",
                    "  const header = createOptionUsageHeader(option);",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  return createOptionUsageRow(",
                    "    header,",
                    "    `${option.description}${",
                    "      optionDefaultValue === undefined",
                    "        ? \"\"",
                    "        : `\\nDefaults to ${createDefaultValueDisplay(optionDefaultValue)}.`",
                    "    }`,",
                    "    threshold",
                    "  );",
                    "}",
                    "",
                    "function getOptionsWithOpposites(options) {",
                    "  // Add --no-foo after --foo.",
                    "  const optionsWithOpposites = options.map((option) => [",
                    "    option.description ? option : null,",
                    "    option.oppositeDescription",
                    "      ? {",
                    "          ...option,",
                    "          name: `no-${option.name}`,",
                    "          type: \"boolean\",",
                    "          description: option.oppositeDescription,",
                    "        }",
                    "      : null,",
                    "  ]);",
                    "  return optionsWithOpposites.flat().filter(Boolean);",
                    "}",
                    "",
                    "function createUsage(context) {",
                    "  const options = getOptionsWithOpposites(context.detailedOptions).filter(",
                    "    // remove unnecessary option (e.g. `semi`, `color`, etc.), which is only used for --help <flag>",
                    "    (option) =>",
                    "      !(",
                    "        option.type === \"boolean\" &&",
                    "        option.oppositeDescription &&",
                    "        !option.name.startsWith(\"no-\")",
                    "      )",
                    "  );",
                    "",
                    "  const groupedOptions = groupBy(options, (option) => option.category);",
                    "",
                    "  const firstCategories = constant.categoryOrder.slice(0, -1);",
                    "  const lastCategories = constant.categoryOrder.slice(-1);",
                    "  const restCategories = Object.keys(groupedOptions).filter(",
                    "    (category) => !constant.categoryOrder.includes(category)",
                    "  );",
                    "  const allCategories = [",
                    "    ...firstCategories,",
                    "    ...restCategories,",
                    "    ...lastCategories,",
                    "  ];",
                    "",
                    "  const optionsUsage = allCategories.map((category) => {",
                    "    const categoryOptions = groupedOptions[category]",
                    "      .map((option) =>",
                    "        createOptionUsage(context, option, OPTION_USAGE_THRESHOLD)",
                    "      )",
                    "      .join(\"\\n\");",
                    "    return `${category} options:\\n\\n${indent(categoryOptions, 2)}`;",
                    "  });",
                    "",
                    "  return [constant.usageSummary, ...optionsUsage, \"\"].join(\"\\n\\n\");",
                    "}",
                    "",
                    "function createDetailedUsage(context, flag) {",
                    "  const option = getOptionsWithOpposites(context.detailedOptions).find(",
                    "    (option) => option.name === flag || option.alias === flag",
                    "  );",
                    "",
                    "  const header = createOptionUsageHeader(option);",
                    "  const description = `\\n\\n${indent(option.description, 2)}`;",
                    "",
                    "  const choices =",
                    "    option.type !== \"choice\"",
                    "      ? \"\"",
                    "      : `\\n\\nValid options:\\n\\n${createChoiceUsages(",
                    "          option.choices,",
                    "          CHOICE_USAGE_MARGIN,",
                    "          CHOICE_USAGE_INDENTATION",
                    "        ).join(\"\\n\")}`;",
                    "",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  const defaults =",
                    "    optionDefaultValue !== undefined",
                    "      ? `\\n\\nDefault: ${createDefaultValueDisplay(optionDefaultValue)}`",
                    "      : \"\";",
                    "",
                    "  const pluginDefaults =",
                    "    option.pluginDefaults && Object.keys(option.pluginDefaults).length > 0",
                    "      ? `\\nPlugin defaults:${Object.entries(option.pluginDefaults).map(",
                    "          ([key, value]) => `\\n* ${key}: ${createDefaultValueDisplay(value)}`",
                    "        )}`",
                    "      : \"\";",
                    "  return `${header}${description}${choices}${defaults}${pluginDefaults}`;",
                    "}",
                    "",
                    "module.exports = {",
                    "  createUsage,",
                    "  createDetailedUsage,",
                    "};"
                ]
            },
            "options": {
                "create-minimist-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const partition = require(\"lodash/partition\");",
                        "",
                        "module.exports = function createMinimistOptions(detailedOptions) {",
                        "  const [boolean, string] = partition(",
                        "    detailedOptions,",
                        "    ({ type }) => type === \"boolean\"",
                        "  ).map((detailedOptions) =>",
                        "    detailedOptions.flatMap(({ name, alias }) =>",
                        "      alias ? [name, alias] : [name]",
                        "    )",
                        "  );",
                        "",
                        "  const defaults = Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(",
                        "        (option) =>",
                        "          !option.deprecated &&",
                        "          (!option.forwardToApi ||",
                        "            option.name === \"plugin\" ||",
                        "            option.name === \"plugin-search-dir\") &&",
                        "          option.default !== undefined",
                        "      )",
                        "      .map((option) => [option.name, option.default])",
                        "  );",
                        "",
                        "  return {",
                        "    // we use vnopts' AliasSchema to handle aliases for better error messages",
                        "    alias: {},",
                        "    boolean,",
                        "    string,",
                        "    default: defaults,",
                        "  };",
                        "};"
                    ]
                },
                "get-context-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "// eslint-disable-next-line no-restricted-modules",
                        "const prettier = require(\"../../index.js\");",
                        "const {",
                        "  optionsModule,",
                        "  utils: { arrayify },",
                        "} = require(\"../prettier-internal.js\");",
                        "const constant = require(\"../constant.js\");",
                        "const {",
                        "  normalizeDetailedOptionMap,",
                        "  createDetailedOptionMap,",
                        "} = require(\"./option-map.js\");",
                        "",
                        "function getContextOptions(plugins, pluginSearchDirs) {",
                        "  const { options: supportOptions, languages } = prettier.getSupportInfo({",
                        "    showDeprecated: true,",
                        "    showUnreleased: true,",
                        "    showInternal: true,",
                        "    plugins,",
                        "    pluginSearchDirs,",
                        "  });",
                        "  const detailedOptionMap = normalizeDetailedOptionMap({",
                        "    ...createDetailedOptionMap(supportOptions),",
                        "    ...constant.options,",
                        "  });",
                        "",
                        "  const detailedOptions = arrayify(detailedOptionMap, \"name\");",
                        "",
                        "  const apiDefaultOptions = {",
                        "    ...optionsModule.hiddenDefaults,",
                        "    ...Object.fromEntries(",
                        "      supportOptions",
                        "        .filter(({ deprecated }) => !deprecated)",
                        "        .map((option) => [option.name, option.default])",
                        "    ),",
                        "  };",
                        "",
                        "  return {",
                        "    supportOptions,",
                        "    detailedOptions,",
                        "    detailedOptionMap,",
                        "    apiDefaultOptions,",
                        "    languages,",
                        "  };",
                        "}",
                        "",
                        "module.exports = getContextOptions;"
                    ]
                },
                "get-options-for-file.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const dashify = require(\"dashify\");",
                        "// eslint-disable-next-line no-restricted-modules",
                        "const prettier = require(\"../../index.js\");",
                        "const { optionsNormalizer } = require(\"../prettier-internal.js\");",
                        "const minimist = require(\"./minimist.js\");",
                        "const createMinimistOptions = require(\"./create-minimist-options.js\");",
                        "",
                        "function getOptions(argv, detailedOptions) {",
                        "  return Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(({ forwardToApi }) => forwardToApi)",
                        "      .map(({ forwardToApi, name }) => [forwardToApi, argv[name]])",
                        "  );",
                        "}",
                        "",
                        "function cliifyOptions(object, apiDetailedOptionMap) {",
                        "  return Object.fromEntries(",
                        "    Object.entries(object || {}).map(([key, value]) => {",
                        "      const apiOption = apiDetailedOptionMap[key];",
                        "      const cliKey = apiOption ? apiOption.name : key;",
                        "",
                        "      return [dashify(cliKey), value];",
                        "    })",
                        "  );",
                        "}",
                        "",
                        "function createApiDetailedOptionMap(detailedOptions) {",
                        "  return Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(",
                        "        (option) => option.forwardToApi && option.forwardToApi !== option.name",
                        "      )",
                        "      .map((option) => [option.forwardToApi, option])",
                        "  );",
                        "}",
                        "",
                        "function parseArgsToOptions(context, overrideDefaults) {",
                        "  const minimistOptions = createMinimistOptions(context.detailedOptions);",
                        "  const apiDetailedOptionMap = createApiDetailedOptionMap(",
                        "    context.detailedOptions",
                        "  );",
                        "  return getOptions(",
                        "    optionsNormalizer.normalizeCliOptions(",
                        "      minimist(context.rawArguments, {",
                        "        string: minimistOptions.string,",
                        "        boolean: minimistOptions.boolean,",
                        "        default: cliifyOptions(overrideDefaults, apiDetailedOptionMap),",
                        "      }),",
                        "      context.detailedOptions,",
                        "      { logger: false }",
                        "    ),",
                        "    context.detailedOptions",
                        "  );",
                        "}",
                        "",
                        "async function getOptionsOrDie(context, filePath) {",
                        "  try {",
                        "    if (context.argv.config === false) {",
                        "      context.logger.debug(",
                        "        \"'--no-config' option found, skip loading config file.\"",
                        "      );",
                        "      return null;",
                        "    }",
                        "",
                        "    context.logger.debug(",
                        "      context.argv.config",
                        "        ? `load config file from '${context.argv.config}'`",
                        "        : `resolve config from '${filePath}'`",
                        "    );",
                        "",
                        "    const options = await prettier.resolveConfig(filePath, {",
                        "      editorconfig: context.argv.editorconfig,",
                        "      config: context.argv.config,",
                        "    });",
                        "",
                        "    context.logger.debug(\"loaded options `\" + JSON.stringify(options) + \"`\");",
                        "    return options;",
                        "  } catch (error) {",
                        "    context.logger.error(",
                        "      `Invalid configuration file \\`${filePath}\\`: ` + error.message",
                        "    );",
                        "    process.exit(2);",
                        "  }",
                        "}",
                        "",
                        "function applyConfigPrecedence(context, options) {",
                        "  try {",
                        "    switch (context.argv.configPrecedence) {",
                        "      case \"cli-override\":",
                        "        return parseArgsToOptions(context, options);",
                        "      case \"file-override\":",
                        "        return { ...parseArgsToOptions(context), ...options };",
                        "      case \"prefer-file\":",
                        "        return options || parseArgsToOptions(context);",
                        "    }",
                        "  } catch (error) {",
                        "    /* istanbul ignore next */",
                        "    context.logger.error(error.toString());",
                        "",
                        "    /* istanbul ignore next */",
                        "    process.exit(2);",
                        "  }",
                        "}",
                        "",
                        "async function getOptionsForFile(context, filepath) {",
                        "  const options = await getOptionsOrDie(context, filepath);",
                        "",
                        "  const hasPlugins = options && options.plugins;",
                        "  if (hasPlugins) {",
                        "    context.pushContextPlugins(options.plugins);",
                        "  }",
                        "",
                        "  const appliedOptions = {",
                        "    filepath,",
                        "    ...applyConfigPrecedence(",
                        "      context,",
                        "      options &&",
                        "        optionsNormalizer.normalizeApiOptions(options, context.supportOptions, {",
                        "          logger: context.logger,",
                        "        })",
                        "    ),",
                        "  };",
                        "",
                        "  context.logger.debug(",
                        "    `applied config-precedence (${context.argv.configPrecedence}): ` +",
                        "      `${JSON.stringify(appliedOptions)}`",
                        "  );",
                        "",
                        "  if (hasPlugins) {",
                        "    context.popContextPlugins();",
                        "  }",
                        "",
                        "  return appliedOptions;",
                        "}",
                        "",
                        "module.exports = getOptionsForFile;"
                    ]
                },
                "minimist.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const minimist = require(\"minimist\");",
                        "",
                        "const PLACEHOLDER = null;",
                        "",
                        "/**",
                        " * unspecified boolean flag without default value is parsed as `undefined` instead of `false`",
                        " */",
                        "module.exports = function (args, options) {",
                        "  const boolean = options.boolean || [];",
                        "  const defaults = options.default || {};",
                        "",
                        "  const booleanWithoutDefault = boolean.filter((key) => !(key in defaults));",
                        "  const newDefaults = {",
                        "    ...defaults,",
                        "    ...Object.fromEntries(",
                        "      booleanWithoutDefault.map((key) => [key, PLACEHOLDER])",
                        "    ),",
                        "  };",
                        "",
                        "  const parsed = minimist(args, { ...options, default: newDefaults });",
                        "",
                        "  return Object.fromEntries(",
                        "    Object.entries(parsed).filter(([, value]) => value !== PLACEHOLDER)",
                        "  );",
                        "};"
                    ]
                },
                "option-map.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const dashify = require(\"dashify\");",
                        "const { coreOptions } = require(\"../prettier-internal.js\");",
                        "",
                        "function normalizeDetailedOption(name, option) {",
                        "  return {",
                        "    category: coreOptions.CATEGORY_OTHER,",
                        "    ...option,",
                        "    choices:",
                        "      option.choices &&",
                        "      option.choices.map((choice) => {",
                        "        const newChoice = {",
                        "          description: \"\",",
                        "          deprecated: false,",
                        "          ...(typeof choice === \"object\" ? choice : { value: choice }),",
                        "        };",
                        "        /* istanbul ignore next */",
                        "        if (newChoice.value === true) {",
                        "          newChoice.value = \"\"; // backward compatibility for original boolean option",
                        "        }",
                        "        return newChoice;",
                        "      }),",
                        "  };",
                        "}",
                        "",
                        "function normalizeDetailedOptionMap(detailedOptionMap) {",
                        "  return Object.fromEntries(",
                        "    Object.entries(detailedOptionMap)",
                        "      .sort(([leftName], [rightName]) => leftName.localeCompare(rightName))",
                        "      .map(([name, option]) => [name, normalizeDetailedOption(name, option)])",
                        "  );",
                        "}",
                        "",
                        "function createDetailedOptionMap(supportOptions) {",
                        "  return Object.fromEntries(",
                        "    supportOptions.map((option) => {",
                        "      const newOption = {",
                        "        ...option,",
                        "        name: option.cliName || dashify(option.name),",
                        "        description: option.cliDescription || option.description,",
                        "        category: option.cliCategory || coreOptions.CATEGORY_FORMAT,",
                        "        forwardToApi: option.name,",
                        "      };",
                        "",
                        "      /* istanbul ignore next */",
                        "      if (option.deprecated) {",
                        "        delete newOption.forwardToApi;",
                        "        delete newOption.description;",
                        "        delete newOption.oppositeDescription;",
                        "        newOption.deprecated = true;",
                        "      }",
                        "",
                        "      return [newOption.name, newOption];",
                        "    })",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  normalizeDetailedOptionMap,",
                        "  createDetailedOptionMap,",
                        "};"
                    ]
                },
                "parse-cli-arguments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "const pick = require(\"lodash/pick\");",
                        "const camelCase = require(\"camelcase\");",
                        "const {",
                        "  optionsNormalizer: { normalizeCliOptions },",
                        "} = require(\"../prettier-internal.js\");",
                        "const getContextOptions = require(\"./get-context-options.js\");",
                        "const minimist = require(\"./minimist.js\");",
                        "const createMinimistOptions = require(\"./create-minimist-options.js\");",
                        "",
                        "function parseArgv(rawArguments, detailedOptions, logger, keys) {",
                        "  const minimistOptions = createMinimistOptions(detailedOptions);",
                        "  let argv = minimist(rawArguments, minimistOptions);",
                        "",
                        "  if (keys) {",
                        "    detailedOptions = detailedOptions.filter((option) =>",
                        "      keys.includes(option.name)",
                        "    );",
                        "    argv = pick(argv, keys);",
                        "  }",
                        "",
                        "  const normalized = normalizeCliOptions(argv, detailedOptions, { logger });",
                        "",
                        "  return Object.fromEntries(",
                        "    Object.entries(normalized).map(([key, value]) => {",
                        "      const option = detailedOptions.find(({ name }) => name === key) || {};",
                        "      // If the flag is a prettier option, use the option name",
                        "      // `--plugin-search-dir` -> `pluginSearchDirs`",
                        "      // Otherwise use camel case for readability",
                        "      // `--ignore-unknown` -> `ignoreUnknown`",
                        "      return [option.forwardToApi || camelCase(key), value];",
                        "    })",
                        "  );",
                        "}",
                        "",
                        "const detailedOptionsWithoutPlugins = getContextOptions().detailedOptions;",
                        "function parseArgvWithoutPlugins(rawArguments, logger, keys) {",
                        "  return parseArgv(",
                        "    rawArguments,",
                        "    detailedOptionsWithoutPlugins,",
                        "    logger,",
                        "    typeof keys === \"string\" ? [keys] : keys",
                        "  );",
                        "}",
                        "",
                        "module.exports = { parseArgv, parseArgvWithoutPlugins };"
                    ]
                }
            }
        },
        "common": {
            "ast-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "",
                    "function getNodeHelper(path, count) {",
                    "  const stackIndex = getNodeStackIndexHelper(path.stack, count);",
                    "  return stackIndex === -1 ? null : path.stack[stackIndex];",
                    "}",
                    "",
                    "function getNodeStackIndexHelper(stack, count) {",
                    "  for (let i = stack.length - 1; i >= 0; i -= 2) {",
                    "    const value = stack[i];",
                    "    if (value && !Array.isArray(value) && --count < 0) {",
                    "      return i;",
                    "    }",
                    "  }",
                    "  return -1;",
                    "}",
                    "",
                    "class AstPath {",
                    "  constructor(value) {",
                    "    this.stack = [value];",
                    "  }",
                    "",
                    "  // The name of the current property is always the penultimate element of",
                    "  // this.stack, and always a String.",
                    "  getName() {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    if (length > 1) {",
                    "      return stack[length - 2];",
                    "    }",
                    "    // Since the name is always a string, null is a safe sentinel value to",
                    "    // return if we do not know the name of the (root) value.",
                    "    /* istanbul ignore next */",
                    "    return null;",
                    "  }",
                    "",
                    "  // The value of the current property is always the final element of",
                    "  // this.stack.",
                    "  getValue() {",
                    "    return getLast(this.stack);",
                    "  }",
                    "",
                    "  getNode(count = 0) {",
                    "    return getNodeHelper(this, count);",
                    "  }",
                    "",
                    "  getParentNode(count = 0) {",
                    "    return getNodeHelper(this, count + 1);",
                    "  }",
                    "",
                    "  // Temporarily push properties named by string arguments given after the",
                    "  // callback function onto this.stack, then call the callback with a",
                    "  // reference to this (modified) AstPath object. Note that the stack will",
                    "  // be restored to its original state after the callback is finished, so it",
                    "  // is probably a mistake to retain a reference to the path.",
                    "  call(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = getLast(stack);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "    const result = callback(this);",
                    "    stack.length = length;",
                    "    return result;",
                    "  }",
                    "",
                    "  callParent(callback, count = 0) {",
                    "    const stackIndex = getNodeStackIndexHelper(this.stack, count + 1);",
                    "    const parentValues = this.stack.splice(stackIndex + 1);",
                    "    const result = callback(this);",
                    "    this.stack.push(...parentValues);",
                    "    return result;",
                    "  }",
                    "",
                    "  // Similar to AstPath.prototype.call, except that the value obtained by",
                    "  // accessing this.getValue()[name1][name2]... should be array. The",
                    "  // callback will be called with a reference to this path object for each",
                    "  // element of the array.",
                    "  each(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = getLast(stack);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "",
                    "    for (let i = 0; i < value.length; ++i) {",
                    "      stack.push(i, value[i]);",
                    "      callback(this, i, value);",
                    "      stack.length -= 2;",
                    "    }",
                    "",
                    "    stack.length = length;",
                    "  }",
                    "",
                    "  // Similar to AstPath.prototype.each, except that the results of the",
                    "  // callback function invocations are stored in an array and returned at",
                    "  // the end of the iteration.",
                    "  map(callback, ...names) {",
                    "    const result = [];",
                    "    this.each((path, index, value) => {",
                    "      result[index] = callback(path, index, value);",
                    "    }, ...names);",
                    "    return result;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {() => void} callback",
                    "   * @internal Unstable API. Don't use in plugins for now.",
                    "   */",
                    "  try(callback) {",
                    "    const { stack } = this;",
                    "    const stackBackup = [...stack];",
                    "    try {",
                    "      return callback();",
                    "    } finally {",
                    "      stack.length = 0;",
                    "      stack.push(...stackBackup);",
                    "    }",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {...(",
                    "   *   | ((node: any, name: string | null, number: number | null) => boolean)",
                    "   *   | undefined",
                    "   * )} predicates",
                    "   */",
                    "  match(...predicates) {",
                    "    let stackPointer = this.stack.length - 1;",
                    "",
                    "    let name = null;",
                    "    let node = this.stack[stackPointer--];",
                    "",
                    "    for (const predicate of predicates) {",
                    "      /* istanbul ignore next */",
                    "      if (node === undefined) {",
                    "        return false;",
                    "      }",
                    "",
                    "      // skip index/array",
                    "      let number = null;",
                    "      if (typeof name === \"number\") {",
                    "        number = name;",
                    "        name = this.stack[stackPointer--];",
                    "        node = this.stack[stackPointer--];",
                    "      }",
                    "",
                    "      if (predicate && !predicate(node, name, number)) {",
                    "        return false;",
                    "      }",
                    "",
                    "      name = this.stack[stackPointer--];",
                    "      node = this.stack[stackPointer--];",
                    "    }",
                    "",
                    "    return true;",
                    "  }",
                    "",
                    "  /**",
                    "   * Traverses the ancestors of the current node heading toward the tree root",
                    "   * until it finds a node that matches the provided predicate function. Will",
                    "   * return the first matching ancestor. If no such node exists, returns undefined.",
                    "   * @param {(node: any, name: string, number: number | null) => boolean} predicate",
                    "   * @internal Unstable API. Don't use in plugins for now.",
                    "   */",
                    "  findAncestor(predicate) {",
                    "    let stackPointer = this.stack.length - 1;",
                    "",
                    "    let name = null;",
                    "    let node = this.stack[stackPointer--];",
                    "",
                    "    while (node) {",
                    "      // skip index/array",
                    "      let number = null;",
                    "      if (typeof name === \"number\") {",
                    "        number = name;",
                    "        name = this.stack[stackPointer--];",
                    "        node = this.stack[stackPointer--];",
                    "      }",
                    "",
                    "      if (name !== null && predicate(node, name, number)) {",
                    "        return node;",
                    "      }",
                    "",
                    "      name = this.stack[stackPointer--];",
                    "      node = this.stack[stackPointer--];",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = AstPath;"
                ]
            },
            "common-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const CATEGORY_COMMON = \"Common\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSpacing: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print spaces between brackets.\",",
                    "    oppositeDescription: \"Do not print spaces between brackets.\",",
                    "  },",
                    "  singleQuote: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes instead of double quotes.\",",
                    "  },",
                    "  proseWrap: {",
                    "    since: \"1.8.2\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.8.2\", value: true },",
                    "      { since: \"1.9.0\", value: \"preserve\" },",
                    "    ],",
                    "    description: \"How to wrap prose.\",",
                    "    choices: [",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"always\",",
                    "        description: \"Wrap prose if it exceeds the print width.\",",
                    "      },",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"never\",",
                    "        description: \"Do not wrap prose.\",",
                    "      },",
                    "      {",
                    "        since: \"1.9.0\",",
                    "        value: \"preserve\",",
                    "        description: \"Wrap prose as-is.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  bracketSameLine: {",
                    "    since: \"2.4.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description:",
                    "      \"Put > of opening tags on the last line instead of on a new line.\",",
                    "  },",
                    "  singleAttributePerLine: {",
                    "    since: \"2.6.0\",",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Enforce single attribute per line in HTML, Vue and JSX.\",",
                    "  },",
                    "};"
                ]
            },
            "create-ignorer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const ignore = require(\"ignore\");",
                    "const getFileContentOrNull = require(\"../utils/get-file-content-or-null.js\");",
                    "",
                    "/**",
                    " * @param {string?} ignorePath",
                    " * @param {boolean?} withNodeModules",
                    " */",
                    "async function createIgnorer(ignorePath, withNodeModules) {",
                    "  const ignoreContent = ignorePath",
                    "    ? await getFileContentOrNull(path.resolve(ignorePath))",
                    "    : null;",
                    "",
                    "  return _createIgnorer(ignoreContent, withNodeModules);",
                    "}",
                    "",
                    "/**",
                    " * @param {string?} ignorePath",
                    " * @param {boolean?} withNodeModules",
                    " */",
                    "createIgnorer.sync = function (ignorePath, withNodeModules) {",
                    "  const ignoreContent = !ignorePath",
                    "    ? null",
                    "    : getFileContentOrNull.sync(path.resolve(ignorePath));",
                    "  return _createIgnorer(ignoreContent, withNodeModules);",
                    "};",
                    "",
                    "/**",
                    " * @param {null | string} ignoreContent",
                    " * @param {boolean?} withNodeModules",
                    " */",
                    "function _createIgnorer(ignoreContent, withNodeModules) {",
                    "  const ignorer = ignore({ allowRelativePaths: true }).add(ignoreContent || \"\");",
                    "  if (!withNodeModules) {",
                    "    ignorer.add(\"node_modules\");",
                    "  }",
                    "  return ignorer;",
                    "}",
                    "",
                    "module.exports = createIgnorer;"
                ]
            },
            "end-of-line.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function guessEndOfLine(text) {",
                    "  const index = text.indexOf(\"\\r\");",
                    "  if (index >= 0) {",
                    "    return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";",
                    "  }",
                    "  return \"lf\";",
                    "}",
                    "",
                    "function convertEndOfLineToChars(value) {",
                    "  switch (value) {",
                    "    case \"cr\":",
                    "      return \"\\r\";",
                    "    case \"crlf\":",
                    "      return \"\\r\\n\";",
                    "    default:",
                    "      return \"\\n\";",
                    "  }",
                    "}",
                    "",
                    "function countEndOfLineChars(text, eol) {",
                    "  let regex;",
                    "",
                    "  switch (eol) {",
                    "    case \"\\n\":",
                    "      regex = /\\n/g;",
                    "      break;",
                    "    case \"\\r\":",
                    "      regex = /\\r/g;",
                    "      break;",
                    "    case \"\\r\\n\":",
                    "      regex = /\\r\\n/g;",
                    "      break;",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);",
                    "  }",
                    "",
                    "  const endOfLines = text.match(regex);",
                    "  return endOfLines ? endOfLines.length : 0;",
                    "}",
                    "",
                    "function normalizeEndOfLine(text) {",
                    "  return text.replace(/\\r\\n?/g, \"\\n\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "  countEndOfLineChars,",
                    "  normalizeEndOfLine,",
                    "};"
                ]
            },
            "errors.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "class ConfigError extends Error {}",
                    "class DebugError extends Error {}",
                    "class UndefinedParserError extends Error {}",
                    "class ArgExpansionBailout extends Error {}",
                    "",
                    "module.exports = {",
                    "  ConfigError,",
                    "  DebugError,",
                    "  UndefinedParserError,",
                    "  ArgExpansionBailout,",
                    "};"
                ]
            },
            "get-file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const options = require(\"../main/options.js\");",
                    "const config = require(\"../config/resolve-config.js\");",
                    "const createIgnorer = require(\"./create-ignorer.js\");",
                    "",
                    "/**",
                    " * @typedef {{ ignorePath?: string, withNodeModules?: boolean, plugins: object }} FileInfoOptions",
                    " * @typedef {{ ignored: boolean, inferredParser: string | null }} FileInfoResult",
                    " */",
                    "",
                    "/**",
                    " * @param {string} filePath",
                    " * @param {FileInfoOptions} opts",
                    " * @returns {Promise<FileInfoResult>}",
                    " *",
                    " * Please note that prettier.getFileInfo() expects opts.plugins to be an array of paths,",
                    " * not an object. A transformation from this array to an object is automatically done",
                    " * internally by the method wrapper. See withPlugins() in index.js.",
                    " */",
                    "async function getFileInfo(filePath, opts) {",
                    "  if (typeof filePath !== \"string\") {",
                    "    throw new TypeError(",
                    "      `expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``",
                    "    );",
                    "  }",
                    "",
                    "  const ignorer = await createIgnorer(opts.ignorePath, opts.withNodeModules);",
                    "  return _getFileInfo({",
                    "    ignorer,",
                    "    filePath,",
                    "    plugins: opts.plugins,",
                    "    resolveConfig: opts.resolveConfig,",
                    "    ignorePath: opts.ignorePath,",
                    "    sync: false,",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * @param {string} filePath",
                    " * @param {FileInfoOptions} opts",
                    " * @returns {FileInfoResult}",
                    " */",
                    "getFileInfo.sync = function (filePath, opts) {",
                    "  if (typeof filePath !== \"string\") {",
                    "    throw new TypeError(",
                    "      `expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``",
                    "    );",
                    "  }",
                    "",
                    "  const ignorer = createIgnorer.sync(opts.ignorePath, opts.withNodeModules);",
                    "  return _getFileInfo({",
                    "    ignorer,",
                    "    filePath,",
                    "    plugins: opts.plugins,",
                    "    resolveConfig: opts.resolveConfig,",
                    "    ignorePath: opts.ignorePath,",
                    "    sync: true,",
                    "  });",
                    "};",
                    "",
                    "function getFileParser(resolvedConfig, filePath, plugins) {",
                    "  if (resolvedConfig && resolvedConfig.parser) {",
                    "    return resolvedConfig.parser;",
                    "  }",
                    "",
                    "  const inferredParser = options.inferParser(filePath, plugins);",
                    "",
                    "  if (inferredParser) {",
                    "    return inferredParser;",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function _getFileInfo({",
                    "  ignorer,",
                    "  filePath,",
                    "  plugins,",
                    "  resolveConfig = false,",
                    "  ignorePath,",
                    "  sync = false,",
                    "}) {",
                    "  const normalizedFilePath = normalizeFilePath(filePath, ignorePath);",
                    "",
                    "  const fileInfo = {",
                    "    ignored: ignorer.ignores(normalizedFilePath),",
                    "    inferredParser: null,",
                    "  };",
                    "",
                    "  if (fileInfo.ignored) {",
                    "    return fileInfo;",
                    "  }",
                    "",
                    "  let resolvedConfig;",
                    "",
                    "  if (resolveConfig) {",
                    "    if (sync) {",
                    "      resolvedConfig = config.resolveConfig.sync(filePath);",
                    "    } else {",
                    "      return config.resolveConfig(filePath).then((resolvedConfig) => {",
                    "        fileInfo.inferredParser = getFileParser(",
                    "          resolvedConfig,",
                    "          filePath,",
                    "          plugins",
                    "        );",
                    "        return fileInfo;",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  fileInfo.inferredParser = getFileParser(resolvedConfig, filePath, plugins);",
                    "  return fileInfo;",
                    "}",
                    "",
                    "function normalizeFilePath(filePath, ignorePath) {",
                    "  return ignorePath",
                    "    ? path.relative(path.dirname(ignorePath), filePath)",
                    "    : filePath;",
                    "}",
                    "",
                    "module.exports = getFileInfo;"
                ]
            },
            "load-plugins.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\");",
                    "const path = require(\"path\");",
                    "const uniqBy = require(\"lodash/uniqBy\");",
                    "const partition = require(\"lodash/partition\");",
                    "const globby = require(\"globby\");",
                    "const mem = require(\"mem\");",
                    "const internalPlugins = require(\"../languages.js\");",
                    "const thirdParty = require(\"./third-party.js\");",
                    "const resolve = require(\"./resolve.js\");",
                    "",
                    "const memoizedLoad = mem(load, { cacheKey: JSON.stringify });",
                    "const memoizedSearch = mem(findPluginsInNodeModules);",
                    "const clearCache = () => {",
                    "  mem.clear(memoizedLoad);",
                    "  mem.clear(memoizedSearch);",
                    "};",
                    "",
                    "function load(plugins, pluginSearchDirs) {",
                    "  if (!plugins) {",
                    "    plugins = [];",
                    "  }",
                    "",
                    "  if (!pluginSearchDirs) {",
                    "    pluginSearchDirs = [];",
                    "  }",
                    "  // unless pluginSearchDirs are provided, auto-load plugins from node_modules that are parent to Prettier",
                    "  if (pluginSearchDirs.length === 0) {",
                    "    const autoLoadDir = thirdParty.findParentDir(__dirname, \"node_modules\");",
                    "    if (autoLoadDir) {",
                    "      pluginSearchDirs = [autoLoadDir];",
                    "    }",
                    "  }",
                    "",
                    "  const [externalPluginNames, externalPluginInstances] = partition(",
                    "    plugins,",
                    "    (plugin) => typeof plugin === \"string\"",
                    "  );",
                    "",
                    "  const externalManualLoadPluginInfos = externalPluginNames.map(",
                    "    (pluginName) => {",
                    "      let requirePath;",
                    "      try {",
                    "        // try local files",
                    "        requirePath = resolve(path.resolve(process.cwd(), pluginName));",
                    "      } catch {",
                    "        // try node modules",
                    "        requirePath = resolve(pluginName, { paths: [process.cwd()] });",
                    "      }",
                    "",
                    "      return {",
                    "        name: pluginName,",
                    "        requirePath,",
                    "      };",
                    "    }",
                    "  );",
                    "",
                    "  const externalAutoLoadPluginInfos = pluginSearchDirs.flatMap(",
                    "    (pluginSearchDir) => {",
                    "      const resolvedPluginSearchDir = path.resolve(",
                    "        process.cwd(),",
                    "        pluginSearchDir",
                    "      );",
                    "",
                    "      const nodeModulesDir = path.resolve(",
                    "        resolvedPluginSearchDir,",
                    "        \"node_modules\"",
                    "      );",
                    "",
                    "      // In some fringe cases (ex: files \"mounted\" as virtual directories), the",
                    "      // isDirectory(resolvedPluginSearchDir) check might be false even though",
                    "      // the node_modules actually exists.",
                    "      if (",
                    "        !isDirectory(nodeModulesDir) &&",
                    "        !isDirectory(resolvedPluginSearchDir)",
                    "      ) {",
                    "        throw new Error(",
                    "          `${pluginSearchDir} does not exist or is not a directory`",
                    "        );",
                    "      }",
                    "",
                    "      return memoizedSearch(nodeModulesDir).map((pluginName) => ({",
                    "        name: pluginName,",
                    "        requirePath: resolve(pluginName, { paths: [resolvedPluginSearchDir] }),",
                    "      }));",
                    "    }",
                    "  );",
                    "",
                    "  const externalPlugins = [",
                    "    ...uniqBy(",
                    "      [...externalManualLoadPluginInfos, ...externalAutoLoadPluginInfos],",
                    "      \"requirePath\"",
                    "    ).map((externalPluginInfo) => ({",
                    "      name: externalPluginInfo.name,",
                    "      ...require(externalPluginInfo.requirePath),",
                    "    })),",
                    "    ...externalPluginInstances,",
                    "  ];",
                    "",
                    "  return [...internalPlugins, ...externalPlugins];",
                    "}",
                    "",
                    "function findPluginsInNodeModules(nodeModulesDir) {",
                    "  const pluginPackageJsonPaths = globby.sync(",
                    "    [",
                    "      \"prettier-plugin-*/package.json\",",
                    "      \"@*/prettier-plugin-*/package.json\",",
                    "      \"@prettier/plugin-*/package.json\",",
                    "    ],",
                    "    {",
                    "      cwd: nodeModulesDir,",
                    "      expandDirectories: false,",
                    "    }",
                    "  );",
                    "  return pluginPackageJsonPaths.map(path.dirname);",
                    "}",
                    "",
                    "function isDirectory(dir) {",
                    "  try {",
                    "    return fs.statSync(dir).isDirectory();",
                    "  } catch {",
                    "    return false;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  loadPlugins: memoizedLoad,",
                    "  clearCache,",
                    "};"
                ]
            },
            "parser-create-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function createError(message, loc) {",
                    "  // Construct an error similar to the ones thrown by Babel.",
                    "  const error = new SyntaxError(",
                    "    message + \" (\" + loc.start.line + \":\" + loc.start.column + \")\"",
                    "  );",
                    "  // @ts-expect-error - TBD (...)",
                    "  error.loc = loc;",
                    "  return error;",
                    "}",
                    "",
                    "module.exports = createError;"
                ]
            },
            "resolve.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "let { resolve } = require;",
                    "",
                    "// In the VS Code and Atom extensions `require` is overridden and `require.resolve` doesn't support the 2nd argument.",
                    "if (resolve.length === 1 || process.env.PRETTIER_FALLBACK_RESOLVE) {",
                    "  // @ts-expect-error",
                    "  resolve = (id, options) => {",
                    "    let basedir;",
                    "    if (options && options.paths && options.paths.length === 1) {",
                    "      basedir = options.paths[0];",
                    "    }",
                    "",
                    "    return require(\"resolve\").sync(id, { basedir });",
                    "  };",
                    "}",
                    "",
                    "module.exports = resolve;"
                ]
            },
            "third-party.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  cosmiconfig: require(\"cosmiconfig\").cosmiconfig,",
                    "  cosmiconfigSync: require(\"cosmiconfig\").cosmiconfigSync,",
                    "  findParentDir: require(\"find-parent-dir\").sync,",
                    "  getStdin: require(\"get-stdin\"),",
                    "  isCI: () => require(\"ci-info\").isCI,",
                    "};"
                ]
            },
            "util-shared.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  getMaxContinuousCount,",
                    "  getStringWidth,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipNewline,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "  skipInlineComment,",
                    "  skipTrailingComment,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  isNextLineEmpty,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isPreviousLineEmpty,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "} = require(\"./util.js\");",
                    "",
                    "module.exports = {",
                    "  getMaxContinuousCount,",
                    "  getStringWidth,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipNewline,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "  skipInlineComment,",
                    "  skipTrailingComment,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  isNextLineEmpty,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isPreviousLineEmpty,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "};"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const escapeStringRegexp = require(\"escape-string-regexp\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const { getSupportInfo } = require(\"../main/support.js\");",
                    "const isNonEmptyArray = require(\"../utils/is-non-empty-array.js\");",
                    "const getStringWidth = require(\"../utils/get-string-width.js\");",
                    "",
                    "const getPenultimate = (arr) => arr[arr.length - 2];",
                    "",
                    "/**",
                    " * @typedef {{backwards?: boolean}} SkipOptions",
                    " */",
                    "",
                    "/**",
                    " * @param {string | RegExp} chars",
                    " * @returns {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "function skip(chars) {",
                    "  return (text, index, opts) => {",
                    "    const backwards = opts && opts.backwards;",
                    "",
                    "    // Allow `skip` functions to be threaded together without having",
                    "    // to check for failures (did someone say monads?).",
                    "    /* istanbul ignore next */",
                    "    if (index === false) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const { length } = text;",
                    "    let cursor = index;",
                    "    while (cursor >= 0 && cursor < length) {",
                    "      const c = text.charAt(cursor);",
                    "      if (chars instanceof RegExp) {",
                    "        if (!chars.test(c)) {",
                    "          return cursor;",
                    "        }",
                    "      } else if (!chars.includes(c)) {",
                    "        return cursor;",
                    "      }",
                    "",
                    "      backwards ? cursor-- : cursor++;",
                    "    }",
                    "",
                    "    if (cursor === -1 || cursor === length) {",
                    "      // If we reached the beginning or end of the file, return the",
                    "      // out-of-bounds cursor. It's up to the caller to handle this",
                    "      // correctly. We don't want to indicate `false` though if it",
                    "      // actually skipped valid characters.",
                    "      return cursor;",
                    "    }",
                    "    return false;",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "const skipWhitespace = skip(/\\s/);",
                    "/**",
                    " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "const skipSpaces = skip(\" \\t\");",
                    "/**",
                    " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "const skipToLineEnd = skip(\",; \\t\");",
                    "/**",
                    " * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}",
                    " */",
                    "const skipEverythingButNewLine = skip(/[^\\n\\r]/);",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} index",
                    " * @returns {number | false}",
                    " */",
                    "function skipInlineComment(text, index) {",
                    "  /* istanbul ignore next */",
                    "  if (index === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"*\") {",
                    "    for (let i = index + 2; i < text.length; ++i) {",
                    "      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {",
                    "        return i + 2;",
                    "      }",
                    "    }",
                    "  }",
                    "  return index;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} index",
                    " * @returns {number | false}",
                    " */",
                    "function skipTrailingComment(text, index) {",
                    "  /* istanbul ignore next */",
                    "  if (index === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(index) === \"/\" && text.charAt(index + 1) === \"/\") {",
                    "    return skipEverythingButNewLine(text, index);",
                    "  }",
                    "  return index;",
                    "}",
                    "",
                    "// This one doesn't use the above helper function because it wants to",
                    "// test \\r\\n in order and `skip` doesn't support ordering and we only",
                    "// want to skip one newline. It's simple to implement.",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} index",
                    " * @param {SkipOptions=} opts",
                    " * @returns {number | false}",
                    " */",
                    "function skipNewline(text, index, opts) {",
                    "  const backwards = opts && opts.backwards;",
                    "  if (index === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const atIndex = text.charAt(index);",
                    "  if (backwards) {",
                    "    // We already replace `\\r\\n` with `\\n` before parsing",
                    "    /* istanbul ignore next */",
                    "    if (text.charAt(index - 1) === \"\\r\" && atIndex === \"\\n\") {",
                    "      return index - 2;",
                    "    }",
                    "    if (",
                    "      atIndex === \"\\n\" ||",
                    "      atIndex === \"\\r\" ||",
                    "      atIndex === \"\\u2028\" ||",
                    "      atIndex === \"\\u2029\"",
                    "    ) {",
                    "      return index - 1;",
                    "    }",
                    "  } else {",
                    "    // We already replace `\\r\\n` with `\\n` before parsing",
                    "    /* istanbul ignore next */",
                    "    if (atIndex === \"\\r\" && text.charAt(index + 1) === \"\\n\") {",
                    "      return index + 2;",
                    "    }",
                    "    if (",
                    "      atIndex === \"\\n\" ||",
                    "      atIndex === \"\\r\" ||",
                    "      atIndex === \"\\u2028\" ||",
                    "      atIndex === \"\\u2029\"",
                    "    ) {",
                    "      return index + 1;",
                    "    }",
                    "  }",
                    "",
                    "  return index;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} index",
                    " * @param {SkipOptions=} opts",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewline(text, index, opts = {}) {",
                    "  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);",
                    "  const idx2 = skipNewline(text, idx, opts);",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} start",
                    " * @param {number} end",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewlineInRange(text, start, end) {",
                    "  for (let i = start; i < end; ++i) {",
                    "    if (text.charAt(i) === \"\\n\") {",
                    "      return true;",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "// Note: this function doesn't ignore leading comments unlike isNextLineEmpty",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locStart",
                    " */",
                    "function isPreviousLineEmpty(text, node, locStart) {",
                    "  /** @type {number | false} */",
                    "  let idx = locStart(node) - 1;",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  idx = skipNewline(text, idx, { backwards: true });",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  const idx2 = skipNewline(text, idx, { backwards: true });",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} index",
                    " * @returns {boolean}",
                    " */",
                    "function isNextLineEmptyAfterIndex(text, index) {",
                    "  /** @type {number | false} */",
                    "  let oldIdx = null;",
                    "  /** @type {number | false} */",
                    "  let idx = index;",
                    "  while (idx !== oldIdx) {",
                    "    // We need to skip all the potential trailing inline comments",
                    "    oldIdx = idx;",
                    "    idx = skipToLineEnd(text, idx);",
                    "    idx = skipInlineComment(text, idx);",
                    "    idx = skipSpaces(text, idx);",
                    "  }",
                    "  idx = skipTrailingComment(text, idx);",
                    "  idx = skipNewline(text, idx);",
                    "  return idx !== false && hasNewline(text, idx);",
                    "}",
                    "",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {boolean}",
                    " */",
                    "function isNextLineEmpty(text, node, locEnd) {",
                    "  return isNextLineEmptyAfterIndex(text, locEnd(node));",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} idx",
                    " * @returns {number | false}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {",
                    "  /** @type {number | false} */",
                    "  let oldIdx = null;",
                    "  /** @type {number | false} */",
                    "  let nextIdx = idx;",
                    "  while (nextIdx !== oldIdx) {",
                    "    oldIdx = nextIdx;",
                    "    nextIdx = skipSpaces(text, nextIdx);",
                    "    nextIdx = skipInlineComment(text, nextIdx);",
                    "    nextIdx = skipTrailingComment(text, nextIdx);",
                    "    nextIdx = skipNewline(text, nextIdx);",
                    "  }",
                    "  return nextIdx;",
                    "}",
                    "",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {number | false}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {",
                    "  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "    text,",
                    "    locEnd(node)",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {string}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacter(text, node, locEnd) {",
                    "  return text.charAt(",
                    "    // @ts-expect-error => TBD: can return false, should we define a fallback?",
                    "    getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd)",
                    "  );",
                    "}",
                    "",
                    "// Not using, but it's public utils",
                    "/* istanbul ignore next */",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} index",
                    " * @param {SkipOptions=} opts",
                    " * @returns {boolean}",
                    " */",
                    "function hasSpaces(text, index, opts = {}) {",
                    "  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);",
                    "  return idx !== index;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @param {number} tabWidth",
                    " * @param {number=} startIndex",
                    " * @returns {number}",
                    " */",
                    "function getAlignmentSize(value, tabWidth, startIndex = 0) {",
                    "  let size = 0;",
                    "  for (let i = startIndex; i < value.length; ++i) {",
                    "    if (value[i] === \"\\t\") {",
                    "      // Tabs behave in a way that they are aligned to the nearest",
                    "      // multiple of tabWidth:",
                    "      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4",
                    "      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...",
                    "      size = size + tabWidth - (size % tabWidth);",
                    "    } else {",
                    "      size++;",
                    "    }",
                    "  }",
                    "",
                    "  return size;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @param {number} tabWidth",
                    " * @returns {number}",
                    " */",
                    "function getIndentSize(value, tabWidth) {",
                    "  const lastNewlineIndex = value.lastIndexOf(\"\\n\");",
                    "  if (lastNewlineIndex === -1) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return getAlignmentSize(",
                    "    // All the leading whitespaces",
                    "    value.slice(lastNewlineIndex + 1).match(/^[\\t ]*/)[0],",
                    "    tabWidth",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @typedef {'\"' | \"'\"} Quote",
                    " */",
                    "",
                    "/**",
                    " *",
                    " * @param {string} rawContent",
                    " * @param {Quote} preferredQuote",
                    " * @returns {{ quote: Quote, regex: RegExp, escaped: string }}",
                    " */",
                    "",
                    "function getPreferredQuote(rawContent, preferredQuote) {",
                    "  /** @type {{ quote: '\"', regex: RegExp, escaped: \"&quot;\" }} */",
                    "  const double = { quote: '\"', regex: /\"/g, escaped: \"&quot;\" };",
                    "  /** @type {{ quote: \"'\", regex: RegExp, escaped: \"&apos;\" }} */",
                    "  const single = { quote: \"'\", regex: /'/g, escaped: \"&apos;\" };",
                    "",
                    "  const preferred = preferredQuote === \"'\" ? single : double;",
                    "  const alternate = preferred === single ? double : single;",
                    "",
                    "  let result = preferred;",
                    "",
                    "  // If `rawContent` contains at least one of the quote preferred for enclosing",
                    "  // the string, we might want to enclose with the alternate quote instead, to",
                    "  // minimize the number of escaped quotes.",
                    "  if (",
                    "    rawContent.includes(preferred.quote) ||",
                    "    rawContent.includes(alternate.quote)",
                    "  ) {",
                    "    const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;",
                    "    const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;",
                    "",
                    "    result = numPreferredQuotes > numAlternateQuotes ? alternate : preferred;",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function printString(raw, options) {",
                    "  // `rawContent` is the string exactly like it appeared in the input source",
                    "  // code, without its enclosing quotes.",
                    "  const rawContent = raw.slice(1, -1);",
                    "",
                    "  /** @type {Quote} */",
                    "  const enclosingQuote =",
                    "    options.parser === \"json\" ||",
                    "    (options.parser === \"json5\" &&",
                    "      options.quoteProps === \"preserve\" &&",
                    "      !options.singleQuote)",
                    "      ? '\"'",
                    "      : options.__isInHtmlAttribute",
                    "      ? \"'\"",
                    "      : getPreferredQuote(rawContent, options.singleQuote ? \"'\" : '\"').quote;",
                    "",
                    "  // It might sound unnecessary to use `makeString` even if the string already",
                    "  // is enclosed with `enclosingQuote`, but it isn't. The string could contain",
                    "  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes",
                    "  // sure that we consistently output the minimum amount of escaped quotes.",
                    "  return makeString(",
                    "    rawContent,",
                    "    enclosingQuote,",
                    "    !(",
                    "      options.parser === \"css\" ||",
                    "      options.parser === \"less\" ||",
                    "      options.parser === \"scss\" ||",
                    "      options.__embeddedInHtml",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} rawContent",
                    " * @param {Quote} enclosingQuote",
                    " * @param {boolean=} unescapeUnnecessaryEscapes",
                    " * @returns {string}",
                    " */",
                    "function makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {",
                    "  const otherQuote = enclosingQuote === '\"' ? \"'\" : '\"';",
                    "",
                    "  // Matches _any_ escape and unescaped quotes (both single and double).",
                    "  const regex = /\\\\(.)|([\"'])/gs;",
                    "",
                    "  // Escape and unescape single and double quotes as needed to be able to",
                    "  // enclose `rawContent` with `enclosingQuote`.",
                    "  const newContent = rawContent.replace(regex, (match, escaped, quote) => {",
                    "    // If we matched an escape, and the escaped character is a quote of the",
                    "    // other type than we intend to enclose the string with, there's no need for",
                    "    // it to be escaped, so return it _without_ the backslash.",
                    "    if (escaped === otherQuote) {",
                    "      return escaped;",
                    "    }",
                    "",
                    "    // If we matched an unescaped quote and it is of the _same_ type as we",
                    "    // intend to enclose the string with, it must be escaped, so return it with",
                    "    // a backslash.",
                    "    if (quote === enclosingQuote) {",
                    "      return \"\\\\\" + quote;",
                    "    }",
                    "",
                    "    if (quote) {",
                    "      return quote;",
                    "    }",
                    "",
                    "    // Unescape any unnecessarily escaped character.",
                    "    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27",
                    "    return unescapeUnnecessaryEscapes &&",
                    "      /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(escaped)",
                    "      ? escaped",
                    "      : \"\\\\\" + escaped;",
                    "  });",
                    "",
                    "  return enclosingQuote + newContent + enclosingQuote;",
                    "}",
                    "",
                    "function printNumber(rawNumber) {",
                    "  return (",
                    "    rawNumber",
                    "      .toLowerCase()",
                    "      // Remove unnecessary plus and zeroes from scientific notation.",
                    "      .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(\\d)/, \"$1$2$3\")",
                    "      // Remove unnecessary scientific notation (1e0).",
                    "      .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\")",
                    "      // Make sure numbers always start with a digit.",
                    "      .replace(/^([+-])?\\./, \"$10.\")",
                    "      // Remove extraneous trailing decimal zeroes.",
                    "      .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\")",
                    "      // Remove trailing dot.",
                    "      .replace(/\\.(?=e|$)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} str",
                    " * @param {string} target",
                    " * @returns {number}",
                    " */",
                    "function getMaxContinuousCount(str, target) {",
                    "  const results = str.match(",
                    "    new RegExp(`(${escapeStringRegexp(target)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (results === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return results.reduce(",
                    "    (maxCount, result) => Math.max(maxCount, result.length / target.length),",
                    "    0",
                    "  );",
                    "}",
                    "",
                    "function getMinNotPresentContinuousCount(str, target) {",
                    "  const matches = str.match(",
                    "    new RegExp(`(${escapeStringRegexp(target)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (matches === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  const countPresent = new Map();",
                    "  let max = 0;",
                    "",
                    "  for (const match of matches) {",
                    "    const count = match.length / target.length;",
                    "    countPresent.set(count, true);",
                    "    if (count > max) {",
                    "      max = count;",
                    "    }",
                    "  }",
                    "",
                    "  for (let i = 1; i < max; i++) {",
                    "    if (!countPresent.get(i)) {",
                    "      return i;",
                    "    }",
                    "  }",
                    "",
                    "  return max + 1;",
                    "}",
                    "",
                    "function addCommentHelper(node, comment) {",
                    "  const comments = node.comments || (node.comments = []);",
                    "  comments.push(comment);",
                    "  comment.printed = false;",
                    "  comment.nodeDescription = describeNodeForDebugging(node);",
                    "}",
                    "",
                    "function addLeadingComment(node, comment) {",
                    "  comment.leading = true;",
                    "  comment.trailing = false;",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function addDanglingComment(node, comment, marker) {",
                    "  comment.leading = false;",
                    "  comment.trailing = false;",
                    "  if (marker) {",
                    "    comment.marker = marker;",
                    "  }",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function addTrailingComment(node, comment) {",
                    "  comment.leading = false;",
                    "  comment.trailing = true;",
                    "  addCommentHelper(node, comment);",
                    "}",
                    "",
                    "function inferParserByLanguage(language, options) {",
                    "  const { languages } = getSupportInfo({ plugins: options.plugins });",
                    "  const matched =",
                    "    languages.find(({ name }) => name.toLowerCase() === language) ||",
                    "    languages.find(",
                    "      ({ aliases }) => Array.isArray(aliases) && aliases.includes(language)",
                    "    ) ||",
                    "    languages.find(",
                    "      ({ extensions }) =>",
                    "        Array.isArray(extensions) && extensions.includes(`.${language}`)",
                    "    );",
                    "  return matched && matched.parsers[0];",
                    "}",
                    "",
                    "function isFrontMatterNode(node) {",
                    "  return node && node.type === \"front-matter\";",
                    "}",
                    "",
                    "/**",
                    " * @param {string} description",
                    " * @returns {(node: any) => symbol}",
                    " */",
                    "function createGroupIdMapper(description) {",
                    "  const groupIds = new WeakMap();",
                    "  return function (node) {",
                    "    if (!groupIds.has(node)) {",
                    "      groupIds.set(node, Symbol(description));",
                    "    }",
                    "    return groupIds.get(node);",
                    "  };",
                    "}",
                    "",
                    "function describeNodeForDebugging(node) {",
                    "  const nodeType = node.type || node.kind || \"(unknown type)\";",
                    "  let nodeName = String(",
                    "    node.name ||",
                    "      (node.id && (typeof node.id === \"object\" ? node.id.name : node.id)) ||",
                    "      (node.key && (typeof node.key === \"object\" ? node.key.name : node.key)) ||",
                    "      (node.value &&",
                    "        (typeof node.value === \"object\" ? \"\" : String(node.value))) ||",
                    "      node.operator ||",
                    "      \"\"",
                    "  );",
                    "  if (nodeName.length > 20) {",
                    "    nodeName = nodeName.slice(0, 19) + \"\u2026\";",
                    "  }",
                    "  return nodeType + (nodeName ? \" \" + nodeName : \"\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  inferParserByLanguage,",
                    "  getStringWidth,",
                    "  getMaxContinuousCount,",
                    "  getMinNotPresentContinuousCount,",
                    "  getPenultimate,",
                    "  getLast,",
                    "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  getNextNonSpaceNonCommentCharacter,",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "  skipInlineComment,",
                    "  skipTrailingComment,",
                    "  skipNewline,",
                    "  isNextLineEmptyAfterIndex,",
                    "  isNextLineEmpty,",
                    "  isPreviousLineEmpty,",
                    "  hasNewline,",
                    "  hasNewlineInRange,",
                    "  hasSpaces,",
                    "  getAlignmentSize,",
                    "  getIndentSize,",
                    "  getPreferredQuote,",
                    "  printString,",
                    "  printNumber,",
                    "  makeString,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "  isFrontMatterNode,",
                    "  isNonEmptyArray,",
                    "  createGroupIdMapper,",
                    "};"
                ]
            }
        },
        "config": {
            "find-project-root.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// Simple version of `find-project-root`",
                    "// https://github.com/kirstein/find-project-root/blob/master/index.js",
                    "",
                    "const fs = require(\"fs\");",
                    "const path = require(\"path\");",
                    "",
                    "const MARKERS = [\".git\", \".hg\"];",
                    "",
                    "const markerExists = (directory) =>",
                    "  MARKERS.some((mark) => fs.existsSync(path.join(directory, mark)));",
                    "",
                    "function findProjectRoot(directory) {",
                    "  while (!markerExists(directory)) {",
                    "    const parentDirectory = path.resolve(directory, \"..\");",
                    "    if (parentDirectory === directory) {",
                    "      break;",
                    "    }",
                    "    directory = parentDirectory;",
                    "  }",
                    "",
                    "  return directory;",
                    "}",
                    "",
                    "module.exports = findProjectRoot;"
                ]
            },
            "resolve-config-editorconfig.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "",
                    "const editorconfig = require(\"editorconfig\");",
                    "const mem = require(\"mem\");",
                    "const editorConfigToPrettier = require(\"editorconfig-to-prettier\");",
                    "const findProjectRoot = require(\"./find-project-root.js\");",
                    "",
                    "const jsonStringifyMem = (fn) => mem(fn, { cacheKey: JSON.stringify });",
                    "",
                    "const maybeParse = (filePath, parse) =>",
                    "  filePath &&",
                    "  parse(filePath, {",
                    "    root: findProjectRoot(path.dirname(path.resolve(filePath))),",
                    "  });",
                    "",
                    "const editorconfigAsyncNoCache = async (filePath) =>",
                    "  editorConfigToPrettier(await maybeParse(filePath, editorconfig.parse));",
                    "const editorconfigAsyncWithCache = jsonStringifyMem(editorconfigAsyncNoCache);",
                    "",
                    "const editorconfigSyncNoCache = (filePath) =>",
                    "  editorConfigToPrettier(maybeParse(filePath, editorconfig.parseSync));",
                    "const editorconfigSyncWithCache = jsonStringifyMem(editorconfigSyncNoCache);",
                    "",
                    "function getLoadFunction(opts) {",
                    "  if (!opts.editorconfig) {",
                    "    return () => null;",
                    "  }",
                    "",
                    "  if (opts.sync) {",
                    "    return opts.cache ? editorconfigSyncWithCache : editorconfigSyncNoCache;",
                    "  }",
                    "",
                    "  return opts.cache ? editorconfigAsyncWithCache : editorconfigAsyncNoCache;",
                    "}",
                    "",
                    "function clearCache() {",
                    "  mem.clear(editorconfigSyncWithCache);",
                    "  mem.clear(editorconfigAsyncWithCache);",
                    "}",
                    "",
                    "module.exports = {",
                    "  getLoadFunction,",
                    "  clearCache,",
                    "};"
                ]
            },
            "resolve-config.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const minimatch = require(\"minimatch\");",
                    "const mem = require(\"mem\");",
                    "const thirdParty = require(\"../common/third-party.js\");",
                    "",
                    "const loadToml = require(\"../utils/load-toml.js\");",
                    "const loadJson5 = require(\"../utils/load-json5.js\");",
                    "const resolve = require(\"../common/resolve.js\");",
                    "const resolveEditorConfig = require(\"./resolve-config-editorconfig.js\");",
                    "",
                    "/**",
                    " * @typedef {import(\"cosmiconfig/dist/Explorer\").Explorer} Explorer",
                    " * @typedef {{sync: boolean; cache: boolean }} Options",
                    " */",
                    "",
                    "/**",
                    " * @type {(opts: Options) => Explorer}",
                    " */",
                    "const getExplorerMemoized = mem(",
                    "  (opts) => {",
                    "    const cosmiconfig = thirdParty[\"cosmiconfig\" + (opts.sync ? \"Sync\" : \"\")];",
                    "    const explorer = cosmiconfig(\"prettier\", {",
                    "      cache: opts.cache,",
                    "      transform: (result) => {",
                    "        if (result && result.config) {",
                    "          if (typeof result.config === \"string\") {",
                    "            const dir = path.dirname(result.filepath);",
                    "            const modulePath = resolve(result.config, { paths: [dir] });",
                    "            result.config = require(modulePath);",
                    "          }",
                    "",
                    "          if (typeof result.config !== \"object\") {",
                    "            throw new TypeError(",
                    "              \"Config is only allowed to be an object, \" +",
                    "                `but received ${typeof result.config} in \"${result.filepath}\"`",
                    "            );",
                    "          }",
                    "",
                    "          delete result.config.$schema;",
                    "        }",
                    "        return result;",
                    "      },",
                    "      searchPlaces: [",
                    "        \"package.json\",",
                    "        \".prettierrc\",",
                    "        \".prettierrc.json\",",
                    "        \".prettierrc.yaml\",",
                    "        \".prettierrc.yml\",",
                    "        \".prettierrc.json5\",",
                    "        \".prettierrc.js\",",
                    "        \".prettierrc.cjs\",",
                    "        \"prettier.config.js\",",
                    "        \"prettier.config.cjs\",",
                    "        \".prettierrc.toml\",",
                    "      ],",
                    "      loaders: {",
                    "        \".toml\": loadToml,",
                    "        \".json5\": loadJson5,",
                    "      },",
                    "    });",
                    "",
                    "    return explorer;",
                    "  },",
                    "  { cacheKey: JSON.stringify }",
                    ");",
                    "",
                    "/**",
                    " * @param {Options} opts",
                    " * @return {Explorer}",
                    " */",
                    "function getExplorer(opts) {",
                    "  // Normalize opts before passing to a memoized function",
                    "  opts = { sync: false, cache: false, ...opts };",
                    "  return getExplorerMemoized(opts);",
                    "}",
                    "",
                    "function _resolveConfig(filePath, opts, sync) {",
                    "  opts = { useCache: true, ...opts };",
                    "  const loadOpts = {",
                    "    cache: Boolean(opts.useCache),",
                    "    sync: Boolean(sync),",
                    "    editorconfig: Boolean(opts.editorconfig),",
                    "  };",
                    "  const { load, search } = getExplorer(loadOpts);",
                    "  const loadEditorConfig = resolveEditorConfig.getLoadFunction(loadOpts);",
                    "  const arr = [",
                    "    opts.config ? load(opts.config) : search(filePath),",
                    "    loadEditorConfig(filePath),",
                    "  ];",
                    "",
                    "  const unwrapAndMerge = ([result, editorConfigured]) => {",
                    "    const merged = {",
                    "      ...editorConfigured,",
                    "      ...mergeOverrides(result, filePath),",
                    "    };",
                    "",
                    "    for (const optionName of [\"plugins\", \"pluginSearchDirs\"]) {",
                    "      if (Array.isArray(merged[optionName])) {",
                    "        merged[optionName] = merged[optionName].map((value) =>",
                    "          typeof value === \"string\" && value.startsWith(\".\") // relative path",
                    "            ? path.resolve(path.dirname(result.filepath), value)",
                    "            : value",
                    "        );",
                    "      }",
                    "    }",
                    "",
                    "    if (!result && !editorConfigured) {",
                    "      return null;",
                    "    }",
                    "",
                    "    // We are not using this option",
                    "    delete merged.insertFinalNewline;",
                    "    return merged;",
                    "  };",
                    "",
                    "  if (loadOpts.sync) {",
                    "    return unwrapAndMerge(arr);",
                    "  }",
                    "",
                    "  return Promise.all(arr).then(unwrapAndMerge);",
                    "}",
                    "",
                    "const resolveConfig = (filePath, opts) => _resolveConfig(filePath, opts, false);",
                    "",
                    "resolveConfig.sync = (filePath, opts) => _resolveConfig(filePath, opts, true);",
                    "",
                    "function clearCache() {",
                    "  mem.clear(getExplorerMemoized);",
                    "  resolveEditorConfig.clearCache();",
                    "}",
                    "",
                    "async function resolveConfigFile(filePath) {",
                    "  const { search } = getExplorer({ sync: false });",
                    "  const result = await search(filePath);",
                    "  return result ? result.filepath : null;",
                    "}",
                    "",
                    "resolveConfigFile.sync = (filePath) => {",
                    "  const { search } = getExplorer({ sync: true });",
                    "  const result = search(filePath);",
                    "  return result ? result.filepath : null;",
                    "};",
                    "",
                    "function mergeOverrides(configResult, filePath) {",
                    "  const { config, filepath: configPath } = configResult || {};",
                    "  const { overrides, ...options } = config || {};",
                    "  if (filePath && overrides) {",
                    "    const relativeFilePath = path.relative(path.dirname(configPath), filePath);",
                    "    for (const override of overrides) {",
                    "      if (",
                    "        pathMatchesGlobs(",
                    "          relativeFilePath,",
                    "          override.files,",
                    "          override.excludeFiles",
                    "        )",
                    "      ) {",
                    "        Object.assign(options, override.options);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  return options;",
                    "}",
                    "",
                    "// Based on eslint: https://github.com/eslint/eslint/blob/master/lib/config/config-ops.js",
                    "function pathMatchesGlobs(filePath, patterns, excludedPatterns = []) {",
                    "  const patternList = Array.isArray(patterns) ? patterns : [patterns];",
                    "  const excludedPatternList = Array.isArray(excludedPatterns)",
                    "    ? excludedPatterns",
                    "    : [excludedPatterns];",
                    "  const opts = { matchBase: true, dot: true };",
                    "",
                    "  return (",
                    "    patternList.some((pattern) => minimatch(filePath, pattern, opts)) &&",
                    "    !excludedPatternList.some((excludedPattern) =>",
                    "      minimatch(filePath, excludedPattern, opts)",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  resolveConfig,",
                    "  resolveConfigFile,",
                    "  clearCache,",
                    "};"
                ]
            }
        },
        "document": {
            "doc-builders.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * TBD properly tagged union for Doc object type is needed here.",
                    " *",
                    " * @typedef {object} DocObject",
                    " * @property {string} type",
                    " * @property {boolean} [hard]",
                    " * @property {boolean} [literal]",
                    " *",
                    " * @typedef {Doc[]} DocArray",
                    " *",
                    " * @typedef {string | DocObject | DocArray} Doc",
                    " */",
                    "",
                    "/**",
                    " * @param {Doc} val",
                    " */",
                    "function assertDoc(val) {",
                    "  if (typeof val === \"string\") {",
                    "    return;",
                    "  }",
                    "",
                    "  if (Array.isArray(val)) {",
                    "    for (const doc of val) {",
                    "      assertDoc(doc);",
                    "    }",
                    "    return;",
                    "  }",
                    "",
                    "  if (val && typeof val.type === \"string\") {",
                    "    return;",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  throw new Error(\"Value \" + JSON.stringify(val) + \" is not a valid document\");",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} parts",
                    " * @returns Doc",
                    " */",
                    "function concat(parts) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    for (const part of parts) {",
                    "      assertDoc(part);",
                    "    }",
                    "  }",
                    "",
                    "  // We cannot do this until we change `printJSXElement` to not",
                    "  // access the internals of a document directly.",
                    "  // if(parts.length === 1) {",
                    "  //   // If it's a single document, no need to concat it.",
                    "  //   return parts[0];",
                    "  // }",
                    "  return { type: \"concat\", parts };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function indent(contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return { type: \"indent\", contents };",
                    "}",
                    "",
                    "/**",
                    " * @param {number | string} widthOrString",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function align(widthOrString, contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return { type: \"align\", contents, n: widthOrString };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function group(contents, opts = {}) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "",
                    "  return {",
                    "    type: \"group\",",
                    "    id: opts.id,",
                    "    contents,",
                    "    break: Boolean(opts.shouldBreak),",
                    "    expandedStates: opts.expandedStates,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedentToRoot(contents) {",
                    "  return align(Number.NEGATIVE_INFINITY, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function markAsRoot(contents) {",
                    "  // @ts-expect-error - TBD ???:",
                    "  return align({ type: \"root\" }, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedent(contents) {",
                    "  return align(-1, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} states",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function conditionalGroup(states, opts) {",
                    "  return group(states[0], { ...opts, expandedStates: states });",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} parts",
                    " * @returns Doc",
                    " */",
                    "function fill(parts) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    for (const part of parts) {",
                    "      assertDoc(part);",
                    "    }",
                    "  }",
                    "",
                    "  return { type: \"fill\", parts };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} [breakContents]",
                    " * @param {Doc} [flatContents]",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function ifBreak(breakContents, flatContents, opts = {}) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    if (breakContents) {",
                    "      assertDoc(breakContents);",
                    "    }",
                    "    if (flatContents) {",
                    "      assertDoc(flatContents);",
                    "    }",
                    "  }",
                    "",
                    "  return {",
                    "    type: \"if-break\",",
                    "    breakContents,",
                    "    flatContents,",
                    "    groupId: opts.groupId,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * Optimized version of `ifBreak(indent(doc), doc, { groupId: ... })`",
                    " * @param {Doc} contents",
                    " * @param {{ groupId: symbol, negate?: boolean }} opts",
                    " * @returns Doc",
                    " */",
                    "function indentIfBreak(contents, opts) {",
                    "  return {",
                    "    type: \"indent-if-break\",",
                    "    contents,",
                    "    groupId: opts.groupId,",
                    "    negate: opts.negate,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function lineSuffix(contents) {",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    assertDoc(contents);",
                    "  }",
                    "  return { type: \"line-suffix\", contents };",
                    "}",
                    "",
                    "const lineSuffixBoundary = { type: \"line-suffix-boundary\" };",
                    "const breakParent = { type: \"break-parent\" };",
                    "const trim = { type: \"trim\" };",
                    "",
                    "const hardlineWithoutBreakParent = { type: \"line\", hard: true };",
                    "const literallineWithoutBreakParent = {",
                    "  type: \"line\",",
                    "  hard: true,",
                    "  literal: true,",
                    "};",
                    "",
                    "const line = { type: \"line\" };",
                    "const softline = { type: \"line\", soft: true };",
                    "// eslint-disable-next-line prettier-internal-rules/no-doc-builder-concat",
                    "const hardline = concat([hardlineWithoutBreakParent, breakParent]);",
                    "// eslint-disable-next-line prettier-internal-rules/no-doc-builder-concat",
                    "const literalline = concat([literallineWithoutBreakParent, breakParent]);",
                    "",
                    "const cursor = { type: \"cursor\", placeholder: Symbol(\"cursor\") };",
                    "",
                    "/**",
                    " * @param {Doc} sep",
                    " * @param {Doc[]} arr",
                    " * @returns Doc",
                    " */",
                    "function join(sep, arr) {",
                    "  const res = [];",
                    "",
                    "  for (let i = 0; i < arr.length; i++) {",
                    "    if (i !== 0) {",
                    "      res.push(sep);",
                    "    }",
                    "",
                    "    res.push(arr[i]);",
                    "  }",
                    "",
                    "  // eslint-disable-next-line prettier-internal-rules/no-doc-builder-concat",
                    "  return concat(res);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} doc",
                    " * @param {number} size",
                    " * @param {number} tabWidth",
                    " */",
                    "function addAlignmentToDoc(doc, size, tabWidth) {",
                    "  let aligned = doc;",
                    "  if (size > 0) {",
                    "    // Use indent to add tabs for all the levels of tabs we need",
                    "    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {",
                    "      aligned = indent(aligned);",
                    "    }",
                    "    // Use align for all the spaces that are needed",
                    "    aligned = align(size % tabWidth, aligned);",
                    "    // size is absolute from 0 and not relative to the current",
                    "    // indentation, so we use -Infinity to reset the indentation to 0",
                    "    aligned = align(Number.NEGATIVE_INFINITY, aligned);",
                    "  }",
                    "  return aligned;",
                    "}",
                    "",
                    "function label(label, contents) {",
                    "  return { type: \"label\", label, contents };",
                    "}",
                    "",
                    "module.exports = {",
                    "  concat,",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  trim,",
                    "  indent,",
                    "  indentIfBreak,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent,",
                    "  hardlineWithoutBreakParent,",
                    "  literallineWithoutBreakParent,",
                    "  label,",
                    "};"
                ]
            },
            "doc-debug.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isConcat, getDocParts } = require(\"./doc-utils.js\");",
                    "",
                    "function flattenDoc(doc) {",
                    "  if (!doc) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (isConcat(doc)) {",
                    "    const res = [];",
                    "    for (const part of getDocParts(doc)) {",
                    "      if (isConcat(part)) {",
                    "        res.push(...flattenDoc(part).parts);",
                    "      } else {",
                    "        const flattened = flattenDoc(part);",
                    "        if (flattened !== \"\") {",
                    "          res.push(flattened);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return { type: \"concat\", parts: res };",
                    "  }",
                    "",
                    "  if (doc.type === \"if-break\") {",
                    "    return {",
                    "      ...doc,",
                    "      breakContents: flattenDoc(doc.breakContents),",
                    "      flatContents: flattenDoc(doc.flatContents),",
                    "    };",
                    "  }",
                    "",
                    "  if (doc.type === \"group\") {",
                    "    return {",
                    "      ...doc,",
                    "      contents: flattenDoc(doc.contents),",
                    "      expandedStates: doc.expandedStates && doc.expandedStates.map(flattenDoc),",
                    "    };",
                    "  }",
                    "",
                    "  if (doc.type === \"fill\") {",
                    "    return { type: \"fill\", parts: doc.parts.map(flattenDoc) };",
                    "  }",
                    "",
                    "  if (doc.contents) {",
                    "    return { ...doc, contents: flattenDoc(doc.contents) };",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function printDocToDebug(doc) {",
                    "  /** @type Record<symbol, string> */",
                    "  const printedSymbols = Object.create(null);",
                    "  /** @type Set<string> */",
                    "  const usedKeysForSymbols = new Set();",
                    "  return printDoc(flattenDoc(doc));",
                    "",
                    "  function printDoc(doc, index, parentParts) {",
                    "    if (typeof doc === \"string\") {",
                    "      return JSON.stringify(doc);",
                    "    }",
                    "",
                    "    if (isConcat(doc)) {",
                    "      const printed = getDocParts(doc).map(printDoc).filter(Boolean);",
                    "      return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;",
                    "    }",
                    "",
                    "    if (doc.type === \"line\") {",
                    "      const withBreakParent =",
                    "        Array.isArray(parentParts) &&",
                    "        parentParts[index + 1] &&",
                    "        parentParts[index + 1].type === \"break-parent\";",
                    "      if (doc.literal) {",
                    "        return withBreakParent",
                    "          ? \"literalline\"",
                    "          : \"literallineWithoutBreakParent\";",
                    "      }",
                    "      if (doc.hard) {",
                    "        return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";",
                    "      }",
                    "      if (doc.soft) {",
                    "        return \"softline\";",
                    "      }",
                    "      return \"line\";",
                    "    }",
                    "",
                    "    if (doc.type === \"break-parent\") {",
                    "      const afterHardline =",
                    "        Array.isArray(parentParts) &&",
                    "        parentParts[index - 1] &&",
                    "        parentParts[index - 1].type === \"line\" &&",
                    "        parentParts[index - 1].hard;",
                    "      return afterHardline ? undefined : \"breakParent\";",
                    "    }",
                    "",
                    "    if (doc.type === \"trim\") {",
                    "      return \"trim\";",
                    "    }",
                    "",
                    "    if (doc.type === \"indent\") {",
                    "      return \"indent(\" + printDoc(doc.contents) + \")\";",
                    "    }",
                    "",
                    "    if (doc.type === \"align\") {",
                    "      return doc.n === Number.NEGATIVE_INFINITY",
                    "        ? \"dedentToRoot(\" + printDoc(doc.contents) + \")\"",
                    "        : doc.n < 0",
                    "        ? \"dedent(\" + printDoc(doc.contents) + \")\"",
                    "        : doc.n.type === \"root\"",
                    "        ? \"markAsRoot(\" + printDoc(doc.contents) + \")\"",
                    "        : \"align(\" +",
                    "          JSON.stringify(doc.n) +",
                    "          \", \" +",
                    "          printDoc(doc.contents) +",
                    "          \")\";",
                    "    }",
                    "",
                    "    if (doc.type === \"if-break\") {",
                    "      return (",
                    "        \"ifBreak(\" +",
                    "        printDoc(doc.breakContents) +",
                    "        (doc.flatContents ? \", \" + printDoc(doc.flatContents) : \"\") +",
                    "        (doc.groupId",
                    "          ? (!doc.flatContents ? ', \"\"' : \"\") +",
                    "            `, { groupId: ${printGroupId(doc.groupId)} }`",
                    "          : \"\") +",
                    "        \")\"",
                    "      );",
                    "    }",
                    "",
                    "    if (doc.type === \"indent-if-break\") {",
                    "      const optionsParts = [];",
                    "",
                    "      if (doc.negate) {",
                    "        optionsParts.push(\"negate: true\");",
                    "      }",
                    "",
                    "      if (doc.groupId) {",
                    "        optionsParts.push(`groupId: ${printGroupId(doc.groupId)}`);",
                    "      }",
                    "",
                    "      const options =",
                    "        optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";",
                    "",
                    "      return `indentIfBreak(${printDoc(doc.contents)}${options})`;",
                    "    }",
                    "",
                    "    if (doc.type === \"group\") {",
                    "      const optionsParts = [];",
                    "",
                    "      if (doc.break && doc.break !== \"propagated\") {",
                    "        optionsParts.push(\"shouldBreak: true\");",
                    "      }",
                    "",
                    "      if (doc.id) {",
                    "        optionsParts.push(`id: ${printGroupId(doc.id)}`);",
                    "      }",
                    "",
                    "      const options =",
                    "        optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";",
                    "",
                    "      if (doc.expandedStates) {",
                    "        return `conditionalGroup([${doc.expandedStates",
                    "          .map((part) => printDoc(part))",
                    "          .join(\",\")}]${options})`;",
                    "      }",
                    "",
                    "      return `group(${printDoc(doc.contents)}${options})`;",
                    "    }",
                    "",
                    "    if (doc.type === \"fill\") {",
                    "      return `fill([${doc.parts.map((part) => printDoc(part)).join(\", \")}])`;",
                    "    }",
                    "",
                    "    if (doc.type === \"line-suffix\") {",
                    "      return \"lineSuffix(\" + printDoc(doc.contents) + \")\";",
                    "    }",
                    "",
                    "    if (doc.type === \"line-suffix-boundary\") {",
                    "      return \"lineSuffixBoundary\";",
                    "    }",
                    "",
                    "    if (doc.type === \"label\") {",
                    "      return `label(${JSON.stringify(doc.label)}, ${printDoc(doc.contents)})`;",
                    "    }",
                    "",
                    "    throw new Error(\"Unknown doc type \" + doc.type);",
                    "  }",
                    "",
                    "  function printGroupId(id) {",
                    "    if (typeof id !== \"symbol\") {",
                    "      return JSON.stringify(String(id));",
                    "    }",
                    "",
                    "    if (id in printedSymbols) {",
                    "      return printedSymbols[id];",
                    "    }",
                    "",
                    "    // TODO: use Symbol.prototype.description instead of slice once Node 10 is dropped",
                    "    const prefix = String(id).slice(7, -1) || \"symbol\";",
                    "    for (let counter = 0; ; counter++) {",
                    "      const key = prefix + (counter > 0 ? ` #${counter}` : \"\");",
                    "      if (!usedKeysForSymbols.has(key)) {",
                    "        usedKeysForSymbols.add(key);",
                    "        return (printedSymbols[id] = `Symbol.for(${JSON.stringify(key)})`);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = { printDocToDebug };"
                ]
            },
            "doc-printer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { convertEndOfLineToChars } = require(\"../common/end-of-line.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const getStringWidth = require(\"../utils/get-string-width.js\");",
                    "const { fill, cursor, indent } = require(\"./doc-builders.js\");",
                    "const { isConcat, getDocParts } = require(\"./doc-utils.js\");",
                    "",
                    "/** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */",
                    "let groupModeMap;",
                    "",
                    "const MODE_BREAK = 1;",
                    "const MODE_FLAT = 2;",
                    "",
                    "function rootIndent() {",
                    "  return { value: \"\", length: 0, queue: [] };",
                    "}",
                    "",
                    "function makeIndent(ind, options) {",
                    "  return generateInd(ind, { type: \"indent\" }, options);",
                    "}",
                    "",
                    "function makeAlign(indent, widthOrDoc, options) {",
                    "  if (widthOrDoc === Number.NEGATIVE_INFINITY) {",
                    "    return indent.root || rootIndent();",
                    "  }",
                    "",
                    "  if (widthOrDoc < 0) {",
                    "    return generateInd(indent, { type: \"dedent\" }, options);",
                    "  }",
                    "",
                    "  if (!widthOrDoc) {",
                    "    return indent;",
                    "  }",
                    "",
                    "  if (widthOrDoc.type === \"root\") {",
                    "    return { ...indent, root: indent };",
                    "  }",
                    "",
                    "  const alignType =",
                    "    typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";",
                    "",
                    "  return generateInd(indent, { type: alignType, n: widthOrDoc }, options);",
                    "}",
                    "",
                    "function generateInd(ind, newPart, options) {",
                    "  const queue =",
                    "    newPart.type === \"dedent\"",
                    "      ? ind.queue.slice(0, -1)",
                    "      : [...ind.queue, newPart];",
                    "",
                    "  let value = \"\";",
                    "  let length = 0;",
                    "  let lastTabs = 0;",
                    "  let lastSpaces = 0;",
                    "",
                    "  for (const part of queue) {",
                    "    switch (part.type) {",
                    "      case \"indent\":",
                    "        flush();",
                    "        if (options.useTabs) {",
                    "          addTabs(1);",
                    "        } else {",
                    "          addSpaces(options.tabWidth);",
                    "        }",
                    "        break;",
                    "      case \"stringAlign\":",
                    "        flush();",
                    "        value += part.n;",
                    "        length += part.n.length;",
                    "        break;",
                    "      case \"numberAlign\":",
                    "        lastTabs += 1;",
                    "        lastSpaces += part.n;",
                    "        break;",
                    "      /* istanbul ignore next */",
                    "      default:",
                    "        throw new Error(`Unexpected type '${part.type}'`);",
                    "    }",
                    "  }",
                    "",
                    "  flushSpaces();",
                    "",
                    "  return { ...ind, value, length, queue };",
                    "",
                    "  function addTabs(count) {",
                    "    value += \"\\t\".repeat(count);",
                    "    length += options.tabWidth * count;",
                    "  }",
                    "",
                    "  function addSpaces(count) {",
                    "    value += \" \".repeat(count);",
                    "    length += count;",
                    "  }",
                    "",
                    "  function flush() {",
                    "    if (options.useTabs) {",
                    "      flushTabs();",
                    "    } else {",
                    "      flushSpaces();",
                    "    }",
                    "  }",
                    "",
                    "  function flushTabs() {",
                    "    if (lastTabs > 0) {",
                    "      addTabs(lastTabs);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function flushSpaces() {",
                    "    if (lastSpaces > 0) {",
                    "      addSpaces(lastSpaces);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function resetLast() {",
                    "    lastTabs = 0;",
                    "    lastSpaces = 0;",
                    "  }",
                    "}",
                    "",
                    "function trim(out) {",
                    "  if (out.length === 0) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  let trimCount = 0;",
                    "",
                    "  // Trim whitespace at the end of line",
                    "  while (",
                    "    out.length > 0 &&",
                    "    typeof getLast(out) === \"string\" &&",
                    "    /^[\\t ]*$/.test(getLast(out))",
                    "  ) {",
                    "    trimCount += out.pop().length;",
                    "  }",
                    "",
                    "  if (out.length > 0 && typeof getLast(out) === \"string\") {",
                    "    const trimmed = getLast(out).replace(/[\\t ]*$/, \"\");",
                    "    trimCount += getLast(out).length - trimmed.length;",
                    "    out[out.length - 1] = trimmed;",
                    "  }",
                    "",
                    "  return trimCount;",
                    "}",
                    "",
                    "function fits(next, restCommands, width, options, hasLineSuffix, mustBeFlat) {",
                    "  let restIdx = restCommands.length;",
                    "  const cmds = [next];",
                    "  // `out` is only used for width counting because `trim` requires to look",
                    "  // backwards for space characters.",
                    "  const out = [];",
                    "  while (width >= 0) {",
                    "    if (cmds.length === 0) {",
                    "      if (restIdx === 0) {",
                    "        return true;",
                    "      }",
                    "      cmds.push(restCommands[restIdx - 1]);",
                    "",
                    "      restIdx--;",
                    "",
                    "      continue;",
                    "    }",
                    "",
                    "    const [ind, mode, doc] = cmds.pop();",
                    "",
                    "    if (typeof doc === \"string\") {",
                    "      out.push(doc);",
                    "",
                    "      width -= getStringWidth(doc);",
                    "    } else if (isConcat(doc)) {",
                    "      const parts = getDocParts(doc);",
                    "      for (let i = parts.length - 1; i >= 0; i--) {",
                    "        cmds.push([ind, mode, parts[i]]);",
                    "      }",
                    "    } else {",
                    "      switch (doc.type) {",
                    "        case \"indent\":",
                    "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"align\":",
                    "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"trim\":",
                    "          width += trim(out);",
                    "",
                    "          break;",
                    "        case \"group\": {",
                    "          if (mustBeFlat && doc.break) {",
                    "            return false;",
                    "          }",
                    "          const groupMode = doc.break ? MODE_BREAK : mode;",
                    "          cmds.push([",
                    "            ind,",
                    "            groupMode,",
                    "            // The most expanded state takes up the least space on the current line.",
                    "            doc.expandedStates && groupMode === MODE_BREAK",
                    "              ? getLast(doc.expandedStates)",
                    "              : doc.contents,",
                    "          ]);",
                    "",
                    "          if (doc.id) {",
                    "            groupModeMap[doc.id] = groupMode;",
                    "          }",
                    "          break;",
                    "        }",
                    "        case \"fill\":",
                    "          for (let i = doc.parts.length - 1; i >= 0; i--) {",
                    "            cmds.push([ind, mode, doc.parts[i]]);",
                    "          }",
                    "",
                    "          break;",
                    "        case \"if-break\":",
                    "        case \"indent-if-break\": {",
                    "          const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                    "          if (groupMode === MODE_BREAK) {",
                    "            const breakContents =",
                    "              doc.type === \"if-break\"",
                    "                ? doc.breakContents",
                    "                : doc.negate",
                    "                ? doc.contents",
                    "                : indent(doc.contents);",
                    "            if (breakContents) {",
                    "              cmds.push([ind, mode, breakContents]);",
                    "            }",
                    "          }",
                    "          if (groupMode === MODE_FLAT) {",
                    "            const flatContents =",
                    "              doc.type === \"if-break\"",
                    "                ? doc.flatContents",
                    "                : doc.negate",
                    "                ? indent(doc.contents)",
                    "                : doc.contents;",
                    "            if (flatContents) {",
                    "              cmds.push([ind, mode, flatContents]);",
                    "            }",
                    "          }",
                    "",
                    "          break;",
                    "        }",
                    "        case \"line\":",
                    "          switch (mode) {",
                    "            // fallthrough",
                    "            case MODE_FLAT:",
                    "              if (!doc.hard) {",
                    "                if (!doc.soft) {",
                    "                  out.push(\" \");",
                    "",
                    "                  width -= 1;",
                    "                }",
                    "",
                    "                break;",
                    "              }",
                    "              return true;",
                    "",
                    "            case MODE_BREAK:",
                    "              return true;",
                    "          }",
                    "          break;",
                    "        case \"line-suffix\":",
                    "          hasLineSuffix = true;",
                    "          break;",
                    "        case \"line-suffix-boundary\":",
                    "          if (hasLineSuffix) {",
                    "            return false;",
                    "          }",
                    "          break;",
                    "        case \"label\":",
                    "          cmds.push([ind, mode, doc.contents]);",
                    "          break;",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function printDocToString(doc, options) {",
                    "  groupModeMap = {};",
                    "",
                    "  const width = options.printWidth;",
                    "  const newLine = convertEndOfLineToChars(options.endOfLine);",
                    "  let pos = 0;",
                    "  // cmds is basically a stack. We've turned a recursive call into a",
                    "  // while loop which is much faster. The while loop below adds new",
                    "  // cmds to the array instead of recursively calling `print`.",
                    "  const cmds = [[rootIndent(), MODE_BREAK, doc]];",
                    "  const out = [];",
                    "  let shouldRemeasure = false;",
                    "  let lineSuffix = [];",
                    "",
                    "  while (cmds.length > 0) {",
                    "    const [ind, mode, doc] = cmds.pop();",
                    "",
                    "    if (typeof doc === \"string\") {",
                    "      const formatted = newLine !== \"\\n\" ? doc.replace(/\\n/g, newLine) : doc;",
                    "      out.push(formatted);",
                    "      pos += getStringWidth(formatted);",
                    "    } else if (isConcat(doc)) {",
                    "      const parts = getDocParts(doc);",
                    "      for (let i = parts.length - 1; i >= 0; i--) {",
                    "        cmds.push([ind, mode, parts[i]]);",
                    "      }",
                    "    } else {",
                    "      switch (doc.type) {",
                    "        case \"cursor\":",
                    "          out.push(cursor.placeholder);",
                    "",
                    "          break;",
                    "        case \"indent\":",
                    "          cmds.push([makeIndent(ind, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"align\":",
                    "          cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);",
                    "",
                    "          break;",
                    "        case \"trim\":",
                    "          pos -= trim(out);",
                    "",
                    "          break;",
                    "        case \"group\":",
                    "          switch (mode) {",
                    "            case MODE_FLAT:",
                    "              if (!shouldRemeasure) {",
                    "                cmds.push([",
                    "                  ind,",
                    "                  doc.break ? MODE_BREAK : MODE_FLAT,",
                    "                  doc.contents,",
                    "                ]);",
                    "",
                    "                break;",
                    "              }",
                    "            // fallthrough",
                    "",
                    "            case MODE_BREAK: {",
                    "              shouldRemeasure = false;",
                    "",
                    "              const next = [ind, MODE_FLAT, doc.contents];",
                    "              const rem = width - pos;",
                    "              const hasLineSuffix = lineSuffix.length > 0;",
                    "",
                    "              if (!doc.break && fits(next, cmds, rem, options, hasLineSuffix)) {",
                    "                cmds.push(next);",
                    "              } else {",
                    "                // Expanded states are a rare case where a document",
                    "                // can manually provide multiple representations of",
                    "                // itself. It provides an array of documents",
                    "                // going from the least expanded (most flattened)",
                    "                // representation first to the most expanded. If a",
                    "                // group has these, we need to manually go through",
                    "                // these states and find the first one that fits.",
                    "                if (doc.expandedStates) {",
                    "                  const mostExpanded = getLast(doc.expandedStates);",
                    "",
                    "                  if (doc.break) {",
                    "                    cmds.push([ind, MODE_BREAK, mostExpanded]);",
                    "",
                    "                    break;",
                    "                  } else {",
                    "                    for (let i = 1; i < doc.expandedStates.length + 1; i++) {",
                    "                      if (i >= doc.expandedStates.length) {",
                    "                        cmds.push([ind, MODE_BREAK, mostExpanded]);",
                    "",
                    "                        break;",
                    "                      } else {",
                    "                        const state = doc.expandedStates[i];",
                    "                        const cmd = [ind, MODE_FLAT, state];",
                    "",
                    "                        if (fits(cmd, cmds, rem, options, hasLineSuffix)) {",
                    "                          cmds.push(cmd);",
                    "",
                    "                          break;",
                    "                        }",
                    "                      }",
                    "                    }",
                    "                  }",
                    "                } else {",
                    "                  cmds.push([ind, MODE_BREAK, doc.contents]);",
                    "                }",
                    "              }",
                    "",
                    "              break;",
                    "            }",
                    "          }",
                    "",
                    "          if (doc.id) {",
                    "            groupModeMap[doc.id] = getLast(cmds)[1];",
                    "          }",
                    "          break;",
                    "        // Fills each line with as much code as possible before moving to a new",
                    "        // line with the same indentation.",
                    "        //",
                    "        // Expects doc.parts to be an array of alternating content and",
                    "        // whitespace. The whitespace contains the linebreaks.",
                    "        //",
                    "        // For example:",
                    "        //   [\"I\", line, \"love\", line, \"monkeys\"]",
                    "        // or",
                    "        //   [{ type: group, ... }, softline, { type: group, ... }]",
                    "        //",
                    "        // It uses this parts structure to handle three main layout cases:",
                    "        // * The first two content items fit on the same line without",
                    "        //   breaking",
                    "        //   -> output the first content item and the whitespace \"flat\".",
                    "        // * Only the first content item fits on the line without breaking",
                    "        //   -> output the first content item \"flat\" and the whitespace with",
                    "        //   \"break\".",
                    "        // * Neither content item fits on the line without breaking",
                    "        //   -> output the first content item and the whitespace with \"break\".",
                    "        case \"fill\": {",
                    "          const rem = width - pos;",
                    "",
                    "          const { parts } = doc;",
                    "          if (parts.length === 0) {",
                    "            break;",
                    "          }",
                    "",
                    "          const [content, whitespace] = parts;",
                    "          const contentFlatCmd = [ind, MODE_FLAT, content];",
                    "          const contentBreakCmd = [ind, MODE_BREAK, content];",
                    "          const contentFits = fits(",
                    "            contentFlatCmd,",
                    "            [],",
                    "            rem,",
                    "            options,",
                    "            lineSuffix.length > 0,",
                    "            true",
                    "          );",
                    "",
                    "          if (parts.length === 1) {",
                    "            if (contentFits) {",
                    "              cmds.push(contentFlatCmd);",
                    "            } else {",
                    "              cmds.push(contentBreakCmd);",
                    "            }",
                    "            break;",
                    "          }",
                    "",
                    "          const whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];",
                    "          const whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];",
                    "",
                    "          if (parts.length === 2) {",
                    "            if (contentFits) {",
                    "              cmds.push(whitespaceFlatCmd, contentFlatCmd);",
                    "            } else {",
                    "              cmds.push(whitespaceBreakCmd, contentBreakCmd);",
                    "            }",
                    "            break;",
                    "          }",
                    "",
                    "          // At this point we've handled the first pair (context, separator)",
                    "          // and will create a new fill doc for the rest of the content.",
                    "          // Ideally we wouldn't mutate the array here but copying all the",
                    "          // elements to a new array would make this algorithm quadratic,",
                    "          // which is unusable for large arrays (e.g. large texts in JSX).",
                    "          parts.splice(0, 2);",
                    "          const remainingCmd = [ind, mode, fill(parts)];",
                    "",
                    "          const secondContent = parts[0];",
                    "",
                    "          const firstAndSecondContentFlatCmd = [",
                    "            ind,",
                    "            MODE_FLAT,",
                    "            [content, whitespace, secondContent],",
                    "          ];",
                    "          const firstAndSecondContentFits = fits(",
                    "            firstAndSecondContentFlatCmd,",
                    "            [],",
                    "            rem,",
                    "            options,",
                    "            lineSuffix.length > 0,",
                    "            true",
                    "          );",
                    "",
                    "          if (firstAndSecondContentFits) {",
                    "            cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);",
                    "          } else if (contentFits) {",
                    "            cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);",
                    "          } else {",
                    "            cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);",
                    "          }",
                    "          break;",
                    "        }",
                    "        case \"if-break\":",
                    "        case \"indent-if-break\": {",
                    "          const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                    "          if (groupMode === MODE_BREAK) {",
                    "            const breakContents =",
                    "              doc.type === \"if-break\"",
                    "                ? doc.breakContents",
                    "                : doc.negate",
                    "                ? doc.contents",
                    "                : indent(doc.contents);",
                    "            if (breakContents) {",
                    "              cmds.push([ind, mode, breakContents]);",
                    "            }",
                    "          }",
                    "          if (groupMode === MODE_FLAT) {",
                    "            const flatContents =",
                    "              doc.type === \"if-break\"",
                    "                ? doc.flatContents",
                    "                : doc.negate",
                    "                ? indent(doc.contents)",
                    "                : doc.contents;",
                    "            if (flatContents) {",
                    "              cmds.push([ind, mode, flatContents]);",
                    "            }",
                    "          }",
                    "",
                    "          break;",
                    "        }",
                    "        case \"line-suffix\":",
                    "          lineSuffix.push([ind, mode, doc.contents]);",
                    "          break;",
                    "        case \"line-suffix-boundary\":",
                    "          if (lineSuffix.length > 0) {",
                    "            cmds.push([ind, mode, { type: \"line\", hard: true }]);",
                    "          }",
                    "          break;",
                    "        case \"line\":",
                    "          switch (mode) {",
                    "            case MODE_FLAT:",
                    "              if (!doc.hard) {",
                    "                if (!doc.soft) {",
                    "                  out.push(\" \");",
                    "",
                    "                  pos += 1;",
                    "                }",
                    "",
                    "                break;",
                    "              } else {",
                    "                // This line was forced into the output even if we",
                    "                // were in flattened mode, so we need to tell the next",
                    "                // group that no matter what, it needs to remeasure",
                    "                // because the previous measurement didn't accurately",
                    "                // capture the entire expression (this is necessary",
                    "                // for nested groups)",
                    "                shouldRemeasure = true;",
                    "              }",
                    "            // fallthrough",
                    "",
                    "            case MODE_BREAK:",
                    "              if (lineSuffix.length > 0) {",
                    "                cmds.push([ind, mode, doc], ...lineSuffix.reverse());",
                    "                lineSuffix = [];",
                    "                break;",
                    "              }",
                    "",
                    "              if (doc.literal) {",
                    "                if (ind.root) {",
                    "                  out.push(newLine, ind.root.value);",
                    "                  pos = ind.root.length;",
                    "                } else {",
                    "                  out.push(newLine);",
                    "                  pos = 0;",
                    "                }",
                    "              } else {",
                    "                pos -= trim(out);",
                    "                out.push(newLine + ind.value);",
                    "                pos = ind.length;",
                    "              }",
                    "              break;",
                    "          }",
                    "          break;",
                    "        case \"label\":",
                    "          cmds.push([ind, mode, doc.contents]);",
                    "          break;",
                    "        default:",
                    "      }",
                    "    }",
                    "",
                    "    // Flush remaining line-suffix contents at the end of the document, in case",
                    "    // there is no new line after the line-suffix.",
                    "    if (cmds.length === 0 && lineSuffix.length > 0) {",
                    "      cmds.push(...lineSuffix.reverse());",
                    "      lineSuffix = [];",
                    "    }",
                    "  }",
                    "",
                    "  const cursorPlaceholderIndex = out.indexOf(cursor.placeholder);",
                    "  if (cursorPlaceholderIndex !== -1) {",
                    "    const otherCursorPlaceholderIndex = out.indexOf(",
                    "      cursor.placeholder,",
                    "      cursorPlaceholderIndex + 1",
                    "    );",
                    "    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");",
                    "    const aroundCursor = out",
                    "      .slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex)",
                    "      .join(\"\");",
                    "    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");",
                    "",
                    "    return {",
                    "      formatted: beforeCursor + aroundCursor + afterCursor,",
                    "      cursorNodeStart: beforeCursor.length,",
                    "      cursorNodeText: aroundCursor,",
                    "    };",
                    "  }",
                    "",
                    "  return { formatted: out.join(\"\") };",
                    "}",
                    "",
                    "module.exports = { printDocToString };"
                ]
            },
            "doc-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const { literalline, join } = require(\"./doc-builders.js\");",
                    "",
                    "const isConcat = (doc) => Array.isArray(doc) || (doc && doc.type === \"concat\");",
                    "const getDocParts = (doc) => {",
                    "  if (Array.isArray(doc)) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (doc.type !== \"concat\" && doc.type !== \"fill\") {",
                    "    throw new Error(\"Expect doc type to be `concat` or `fill`.\");",
                    "  }",
                    "",
                    "  return doc.parts;",
                    "};",
                    "",
                    "// Using a unique object to compare by reference.",
                    "const traverseDocOnExitStackMarker = {};",
                    "",
                    "function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {",
                    "  const docsStack = [doc];",
                    "",
                    "  while (docsStack.length > 0) {",
                    "    const doc = docsStack.pop();",
                    "",
                    "    if (doc === traverseDocOnExitStackMarker) {",
                    "      onExit(docsStack.pop());",
                    "      continue;",
                    "    }",
                    "",
                    "    if (onExit) {",
                    "      docsStack.push(doc, traverseDocOnExitStackMarker);",
                    "    }",
                    "",
                    "    if (",
                    "      // Should Recurse",
                    "      !onEnter ||",
                    "      onEnter(doc) !== false",
                    "    ) {",
                    "      // When there are multiple parts to process,",
                    "      // the parts need to be pushed onto the stack in reverse order,",
                    "      // so that they are processed in the original order",
                    "      // when the stack is popped.",
                    "      if (isConcat(doc) || doc.type === \"fill\") {",
                    "        const parts = getDocParts(doc);",
                    "        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {",
                    "          docsStack.push(parts[i]);",
                    "        }",
                    "      } else if (doc.type === \"if-break\") {",
                    "        if (doc.flatContents) {",
                    "          docsStack.push(doc.flatContents);",
                    "        }",
                    "        if (doc.breakContents) {",
                    "          docsStack.push(doc.breakContents);",
                    "        }",
                    "      } else if (doc.type === \"group\" && doc.expandedStates) {",
                    "        if (shouldTraverseConditionalGroups) {",
                    "          for (let ic = doc.expandedStates.length, i = ic - 1; i >= 0; --i) {",
                    "            docsStack.push(doc.expandedStates[i]);",
                    "          }",
                    "        } else {",
                    "          docsStack.push(doc.contents);",
                    "        }",
                    "      } else if (doc.contents) {",
                    "        docsStack.push(doc.contents);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function mapDoc(doc, cb) {",
                    "  // Within a doc tree, the same subtrees can be found multiple times.",
                    "  // E.g., often this happens in conditional groups.",
                    "  // As an optimization (those subtrees can be huge) and to maintain the",
                    "  // reference structure of the tree, the mapping results are cached in",
                    "  // a map and reused.",
                    "  const mapped = new Map();",
                    "",
                    "  return rec(doc);",
                    "",
                    "  function rec(doc) {",
                    "    if (mapped.has(doc)) {",
                    "      return mapped.get(doc);",
                    "    }",
                    "    const result = process(doc);",
                    "    mapped.set(doc, result);",
                    "    return result;",
                    "  }",
                    "",
                    "  function process(doc) {",
                    "    if (Array.isArray(doc)) {",
                    "      return cb(doc.map(rec));",
                    "    }",
                    "",
                    "    if (doc.type === \"concat\" || doc.type === \"fill\") {",
                    "      const parts = doc.parts.map(rec);",
                    "      return cb({ ...doc, parts });",
                    "    }",
                    "",
                    "    if (doc.type === \"if-break\") {",
                    "      const breakContents = doc.breakContents && rec(doc.breakContents);",
                    "      const flatContents = doc.flatContents && rec(doc.flatContents);",
                    "      return cb({ ...doc, breakContents, flatContents });",
                    "    }",
                    "",
                    "    if (doc.type === \"group\" && doc.expandedStates) {",
                    "      const expandedStates = doc.expandedStates.map(rec);",
                    "      const contents = expandedStates[0];",
                    "      return cb({ ...doc, contents, expandedStates });",
                    "    }",
                    "",
                    "    if (doc.contents) {",
                    "      const contents = rec(doc.contents);",
                    "      return cb({ ...doc, contents });",
                    "    }",
                    "",
                    "    return cb(doc);",
                    "  }",
                    "}",
                    "",
                    "function findInDoc(doc, fn, defaultValue) {",
                    "  let result = defaultValue;",
                    "  let hasStopped = false;",
                    "  function findInDocOnEnterFn(doc) {",
                    "    const maybeResult = fn(doc);",
                    "    if (maybeResult !== undefined) {",
                    "      hasStopped = true;",
                    "      result = maybeResult;",
                    "    }",
                    "    if (hasStopped) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "  traverseDoc(doc, findInDocOnEnterFn);",
                    "  return result;",
                    "}",
                    "",
                    "function willBreakFn(doc) {",
                    "  if (doc.type === \"group\" && doc.break) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === \"line\" && doc.hard) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === \"break-parent\") {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function willBreak(doc) {",
                    "  return findInDoc(doc, willBreakFn, false);",
                    "}",
                    "",
                    "function breakParentGroup(groupStack) {",
                    "  if (groupStack.length > 0) {",
                    "    const parentGroup = getLast(groupStack);",
                    "    // Breaks are not propagated through conditional groups because",
                    "    // the user is expected to manually handle what breaks.",
                    "    if (!parentGroup.expandedStates && !parentGroup.break) {",
                    "      // An alternative truthy value allows to distinguish propagated group breaks",
                    "      // and not to print them as `group(..., { break: true })` in `--debug-print-doc`.",
                    "      parentGroup.break = \"propagated\";",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function propagateBreaks(doc) {",
                    "  const alreadyVisitedSet = new Set();",
                    "  const groupStack = [];",
                    "  function propagateBreaksOnEnterFn(doc) {",
                    "    if (doc.type === \"break-parent\") {",
                    "      breakParentGroup(groupStack);",
                    "    }",
                    "    if (doc.type === \"group\") {",
                    "      groupStack.push(doc);",
                    "      if (alreadyVisitedSet.has(doc)) {",
                    "        return false;",
                    "      }",
                    "      alreadyVisitedSet.add(doc);",
                    "    }",
                    "  }",
                    "  function propagateBreaksOnExitFn(doc) {",
                    "    if (doc.type === \"group\") {",
                    "      const group = groupStack.pop();",
                    "      if (group.break) {",
                    "        breakParentGroup(groupStack);",
                    "      }",
                    "    }",
                    "  }",
                    "  traverseDoc(",
                    "    doc,",
                    "    propagateBreaksOnEnterFn,",
                    "    propagateBreaksOnExitFn,",
                    "    /* shouldTraverseConditionalGroups */ true",
                    "  );",
                    "}",
                    "",
                    "function removeLinesFn(doc) {",
                    "  // Force this doc into flat mode by statically converting all",
                    "  // lines into spaces (or soft lines into nothing). Hard lines",
                    "  // should still output because there's too great of a chance",
                    "  // of breaking existing assumptions otherwise.",
                    "  if (doc.type === \"line\" && !doc.hard) {",
                    "    return doc.soft ? \"\" : \" \";",
                    "  }",
                    "",
                    "  if (doc.type === \"if-break\") {",
                    "    return doc.flatContents || \"\";",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function removeLines(doc) {",
                    "  return mapDoc(doc, removeLinesFn);",
                    "}",
                    "",
                    "const isHardline = (doc, nextDoc) =>",
                    "  doc &&",
                    "  doc.type === \"line\" &&",
                    "  doc.hard &&",
                    "  nextDoc &&",
                    "  nextDoc.type === \"break-parent\";",
                    "function stripDocTrailingHardlineFromDoc(doc) {",
                    "  if (!doc) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  if (isConcat(doc) || doc.type === \"fill\") {",
                    "    const parts = getDocParts(doc);",
                    "",
                    "    while (parts.length > 1 && isHardline(...parts.slice(-2))) {",
                    "      parts.length -= 2;",
                    "    }",
                    "",
                    "    if (parts.length > 0) {",
                    "      const lastPart = stripDocTrailingHardlineFromDoc(getLast(parts));",
                    "      parts[parts.length - 1] = lastPart;",
                    "    }",
                    "    return Array.isArray(doc) ? parts : { ...doc, parts };",
                    "  }",
                    "",
                    "  switch (doc.type) {",
                    "    case \"align\":",
                    "    case \"indent\":",
                    "    case \"indent-if-break\":",
                    "    case \"group\":",
                    "    case \"line-suffix\":",
                    "    case \"label\": {",
                    "      const contents = stripDocTrailingHardlineFromDoc(doc.contents);",
                    "      return { ...doc, contents };",
                    "    }",
                    "    case \"if-break\": {",
                    "      const breakContents = stripDocTrailingHardlineFromDoc(doc.breakContents);",
                    "      const flatContents = stripDocTrailingHardlineFromDoc(doc.flatContents);",
                    "      return { ...doc, breakContents, flatContents };",
                    "    }",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function stripTrailingHardline(doc) {",
                    "  // HACK remove ending hardline, original PR: #1984",
                    "  return stripDocTrailingHardlineFromDoc(cleanDoc(doc));",
                    "}",
                    "",
                    "function cleanDocFn(doc) {",
                    "  switch (doc.type) {",
                    "    case \"fill\":",
                    "      if (doc.parts.every((part) => part === \"\")) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case \"group\":",
                    "      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {",
                    "        return \"\";",
                    "      }",
                    "      // Remove nested only group",
                    "      if (",
                    "        doc.contents.type === \"group\" &&",
                    "        doc.contents.id === doc.id &&",
                    "        doc.contents.break === doc.break &&",
                    "        doc.contents.expandedStates === doc.expandedStates",
                    "      ) {",
                    "        return doc.contents;",
                    "      }",
                    "      break;",
                    "    case \"align\":",
                    "    case \"indent\":",
                    "    case \"indent-if-break\":",
                    "    case \"line-suffix\":",
                    "      if (!doc.contents) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case \"if-break\":",
                    "      if (!doc.flatContents && !doc.breakContents) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "  }",
                    "",
                    "  if (!isConcat(doc)) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  const parts = [];",
                    "  for (const part of getDocParts(doc)) {",
                    "    if (!part) {",
                    "      continue;",
                    "    }",
                    "    const [currentPart, ...restParts] = isConcat(part)",
                    "      ? getDocParts(part)",
                    "      : [part];",
                    "    if (typeof currentPart === \"string\" && typeof getLast(parts) === \"string\") {",
                    "      parts[parts.length - 1] += currentPart;",
                    "    } else {",
                    "      parts.push(currentPart);",
                    "    }",
                    "    parts.push(...restParts);",
                    "  }",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (parts.length === 1) {",
                    "    return parts[0];",
                    "  }",
                    "  return Array.isArray(doc) ? parts : { ...doc, parts };",
                    "}",
                    "// A safer version of `normalizeDoc`",
                    "// - `normalizeDoc` concat strings and flat \"concat\" in `fill`, while `cleanDoc` don't",
                    "// - On `concat` object, `normalizeDoc` always return object with `parts`, `cleanDoc` may return strings",
                    "// - `cleanDoc` also remove nested `group`s and empty `fill`/`align`/`indent`/`line-suffix`/`if-break` if possible",
                    "function cleanDoc(doc) {",
                    "  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));",
                    "}",
                    "",
                    "function normalizeParts(parts) {",
                    "  const newParts = [];",
                    "",
                    "  const restParts = parts.filter(Boolean);",
                    "  while (restParts.length > 0) {",
                    "    const part = restParts.shift();",
                    "",
                    "    if (!part) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (isConcat(part)) {",
                    "      restParts.unshift(...getDocParts(part));",
                    "      continue;",
                    "    }",
                    "",
                    "    if (",
                    "      newParts.length > 0 &&",
                    "      typeof getLast(newParts) === \"string\" &&",
                    "      typeof part === \"string\"",
                    "    ) {",
                    "      newParts[newParts.length - 1] += part;",
                    "      continue;",
                    "    }",
                    "",
                    "    newParts.push(part);",
                    "  }",
                    "",
                    "  return newParts;",
                    "}",
                    "",
                    "function normalizeDoc(doc) {",
                    "  return mapDoc(doc, (currentDoc) => {",
                    "    if (Array.isArray(currentDoc)) {",
                    "      return normalizeParts(currentDoc);",
                    "    }",
                    "    if (!currentDoc.parts) {",
                    "      return currentDoc;",
                    "    }",
                    "    return {",
                    "      ...currentDoc,",
                    "      parts: normalizeParts(currentDoc.parts),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "function replaceEndOfLine(doc) {",
                    "  return mapDoc(doc, (currentDoc) =>",
                    "    typeof currentDoc === \"string\" && currentDoc.includes(\"\\n\")",
                    "      ? replaceTextEndOfLine(currentDoc)",
                    "      : currentDoc",
                    "  );",
                    "}",
                    "",
                    "// This function need return array",
                    "// TODO: remove `.parts` when we remove `docBuilders.concat()`",
                    "function replaceTextEndOfLine(text, replacement = literalline) {",
                    "  return join(replacement, text.split(\"\\n\")).parts;",
                    "}",
                    "",
                    "function canBreakFn(doc) {",
                    "  if (doc.type === \"line\") {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function canBreak(doc) {",
                    "  return findInDoc(doc, canBreakFn, false);",
                    "}",
                    "",
                    "module.exports = {",
                    "  isConcat,",
                    "  getDocParts,",
                    "  willBreak,",
                    "  traverseDoc,",
                    "  findInDoc,",
                    "  mapDoc,",
                    "  propagateBreaks,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  normalizeParts,",
                    "  normalizeDoc,",
                    "  cleanDoc,",
                    "  replaceTextEndOfLine,",
                    "  replaceEndOfLine,",
                    "  canBreak,",
                    "};"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./doc-builders\").Doc} Doc",
                    " */",
                    "",
                    "module.exports = {",
                    "  builders: require(\"./doc-builders.js\"),",
                    "  printer: require(\"./doc-printer.js\"),",
                    "  utils: require(\"./doc-utils.js\"),",
                    "  debug: require(\"./doc-debug.js\"),",
                    "};"
                ]
            }
        },
        "language-css": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isFrontMatterNode } = require(\"../common/util.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"raw\", // front-matter",
                    "  \"raws\",",
                    "  \"sourceIndex\",",
                    "  \"source\",",
                    "  \"before\",",
                    "  \"after\",",
                    "  \"trailingComma\",",
                    "]);",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  if (isFrontMatterNode(ast) && ast.lang === \"yaml\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"css-comment\" &&",
                    "    parent.type === \"css-root\" &&",
                    "    parent.nodes.length > 0",
                    "  ) {",
                    "    // --insert-pragma",
                    "    // first non-front-matter comment",
                    "    if (",
                    "      parent.nodes[0] === ast ||",
                    "      (isFrontMatterNode(parent.nodes[0]) && parent.nodes[1] === ast)",
                    "    ) {",
                    "      /**",
                    "       * something",
                    "       *",
                    "       * @format",
                    "       */",
                    "      delete newObj.text;",
                    "",
                    "      // standalone pragma",
                    "      if (/^\\*\\s*@(?:format|prettier)\\s*$/.test(ast.text)) {",
                    "        return null;",
                    "      }",
                    "    }",
                    "",
                    "    // Last comment is not parsed, when omitting semicolon, #8675",
                    "    if (parent.type === \"css-root\" && getLast(parent.nodes) === ast) {",
                    "      return null;",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"value-root\") {",
                    "    delete newObj.text;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"media-query\" ||",
                    "    ast.type === \"media-query-list\" ||",
                    "    ast.type === \"media-feature-expression\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"css-rule\") {",
                    "    delete newObj.params;",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-combinator\") {",
                    "    newObj.value = newObj.value.replace(/\\s+/g, \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"media-feature\") {",
                    "    newObj.value = newObj.value.replace(/ /g, \"\");",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"value-word\" &&",
                    "      ((ast.isColor && ast.isHex) ||",
                    "        [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(",
                    "          newObj.value.replace().toLowerCase()",
                    "        ))) ||",
                    "    ast.type === \"media-feature\" ||",
                    "    ast.type === \"selector-root-invalid\" ||",
                    "    ast.type === \"selector-pseudo\"",
                    "  ) {",
                    "    newObj.value = newObj.value.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-decl\") {",
                    "    newObj.prop = newObj.prop.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-atrule\" || ast.type === \"css-import\") {",
                    "    newObj.name = newObj.name.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"value-number\") {",
                    "    newObj.unit = newObj.unit.toLowerCase();",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-feature\" ||",
                    "      ast.type === \"media-keyword\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"media-unknown\" ||",
                    "      ast.type === \"media-url\" ||",
                    "      ast.type === \"media-value\" ||",
                    "      ast.type === \"selector-attribute\" ||",
                    "      ast.type === \"selector-string\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"value-string\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = cleanCSSStrings(newObj.value);",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-attribute\") {",
                    "    newObj.attribute = newObj.attribute.trim();",
                    "",
                    "    if (newObj.namespace) {",
                    "      if (typeof newObj.namespace === \"string\") {",
                    "        newObj.namespace = newObj.namespace.trim();",
                    "",
                    "        if (newObj.namespace.length === 0) {",
                    "          newObj.namespace = true;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (newObj.value) {",
                    "      newObj.value = newObj.value.trim().replace(/^[\"']|[\"']$/g, \"\");",
                    "      delete newObj.quoted;",
                    "    }",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-value\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"value-number\" ||",
                    "      ast.type === \"selector-root-invalid\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"selector-tag\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = newObj.value.replace(",
                    "      /([\\d+.Ee-]+)([A-Za-z]*)/g,",
                    "      (match, numStr, unit) => {",
                    "        const num = Number(numStr);",
                    "        return Number.isNaN(num) ? match : num + unit.toLowerCase();",
                    "      }",
                    "    );",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-tag\") {",
                    "    const lowercasedValue = ast.value.toLowerCase();",
                    "",
                    "    if ([\"from\", \"to\"].includes(lowercasedValue)) {",
                    "      newObj.value = lowercasedValue;",
                    "    }",
                    "  }",
                    "",
                    "  // Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`",
                    "  if (ast.type === \"css-atrule\" && ast.name.toLowerCase() === \"supports\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // Workaround for SCSS nested properties",
                    "  if (ast.type === \"selector-unknown\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // Workaround for SCSS arbitrary arguments",
                    "  if (ast.type === \"value-comma_group\") {",
                    "    const index = ast.groups.findIndex(",
                    "      (node) => node.type === \"value-number\" && node.unit === \"...\"",
                    "    );",
                    "",
                    "    if (index !== -1) {",
                    "      newObj.groups[index].unit = \"\";",
                    "      newObj.groups.splice(index + 1, 0, {",
                    "        type: \"value-word\",",
                    "        value: \"...\",",
                    "        isColor: false,",
                    "        isHex: false,",
                    "      });",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "function cleanCSSStrings(value) {",
                    "  return value.replace(/'/g, '\"').replace(/\\\\([^\\dA-Fa-f])/g, \"$1\");",
                    "}",
                    "",
                    "module.exports = clean;"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const {",
                    "  builders: { hardline },",
                    "} = require(\"../document/index.js\");",
                    "const printFrontMatter = require(\"../utils/front-matter/print.js\");",
                    "",
                    "function embed(path, print, textToDoc /*, options */) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (node.type === \"front-matter\") {",
                    "    const doc = printFrontMatter(node, textToDoc);",
                    "    return doc ? [doc, hardline] : \"\";",
                    "  }",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-postcss.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/CSS.json\"), (data) => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"css\"],",
                    "    extensions: [",
                    "      ...data.extensions,",
                    "      // `WeiXin Style Sheets`(Weixin Mini Programs)",
                    "      // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                    "      \".wxss\",",
                    "    ],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/PostCSS.json\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"postcss\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/Less.json\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"less\"],",
                    "    vscodeLanguageIds: [\"less\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/SCSS.json\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"scss\"],",
                    "    vscodeLanguageIds: [\"scss\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  postcss: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const lineColumnToIndex = require(\"../utils/line-column-to-index.js\");",
                    "const { getLast, skipEverythingButNewLine } = require(\"../common/util.js\");",
                    "",
                    "function calculateLocStart(node, text) {",
                    "  // value-* nodes have this",
                    "  if (typeof node.sourceIndex === \"number\") {",
                    "    return node.sourceIndex;",
                    "  }",
                    "",
                    "  return node.source ? lineColumnToIndex(node.source.start, text) - 1 : null;",
                    "}",
                    "",
                    "function calculateLocEnd(node, text) {",
                    "  if (node.type === \"css-comment\" && node.inline) {",
                    "    return skipEverythingButNewLine(text, node.source.startOffset);",
                    "  }",
                    "  const endNode = node.nodes && getLast(node.nodes);",
                    "  if (endNode && node.source && !node.source.end) {",
                    "    node = endNode;",
                    "  }",
                    "  if (node.source && node.source.end) {",
                    "    return lineColumnToIndex(node.source.end, text);",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function calculateLoc(node, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text);",
                    "    node.source.endOffset = calculateLocEnd(node, text);",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (child.type === \"value-root\" || child.type === \"value-unknown\") {",
                    "      calculateValueNodeLoc(",
                    "        child,",
                    "        getValueRootOffset(node),",
                    "        child.text || child.value",
                    "      );",
                    "    } else {",
                    "      calculateLoc(child, text);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function calculateValueNodeLoc(node, rootOffset, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text) + rootOffset;",
                    "    node.source.endOffset = calculateLocEnd(node, text) + rootOffset;",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    calculateValueNodeLoc(child, rootOffset, text);",
                    "  }",
                    "}",
                    "",
                    "function getValueRootOffset(node) {",
                    "  let result = node.source.startOffset;",
                    "  if (typeof node.prop === \"string\") {",
                    "    result += node.prop.length;",
                    "  }",
                    "",
                    "  if (node.type === \"css-atrule\" && typeof node.name === \"string\") {",
                    "    result +=",
                    "      1 + node.name.length + node.raws.afterName.match(/^\\s*:?\\s*/)[0].length;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type !== \"css-atrule\" &&",
                    "    node.raws &&",
                    "    typeof node.raws.between === \"string\"",
                    "  ) {",
                    "    result += node.raws.between.length;",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "/**",
                    " * Workaround for a bug: quotes and asterisks in inline comments corrupt loc data of subsequent nodes.",
                    " * This function replaces the quotes and asterisks with spaces. Later, when the comments are printed,",
                    " * their content is extracted from the original text.",
                    " * - https://github.com/prettier/prettier/issues/7780",
                    " * - https://github.com/shellscape/postcss-less/issues/145",
                    " * - https://github.com/prettier/prettier/issues/8130",
                    " * @param text {string}",
                    " */",
                    "function replaceQuotesInInlineComments(text) {",
                    "  /** @typedef { 'initial' | 'single-quotes' | 'double-quotes' | 'url' | 'comment-block' | 'comment-inline' } State */",
                    "  /** @type {State} */",
                    "  let state = \"initial\";",
                    "  /** @type {State} */",
                    "  let stateToReturnFromQuotes = \"initial\";",
                    "  let inlineCommentStartIndex;",
                    "  let inlineCommentContainsQuotes = false;",
                    "  const inlineCommentsToReplace = [];",
                    "",
                    "  for (let i = 0; i < text.length; i++) {",
                    "    const c = text[i];",
                    "",
                    "    switch (state) {",
                    "      case \"initial\":",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          (c === \"u\" || c === \"U\") &&",
                    "          text.slice(i, i + 4).toLowerCase() === \"url(\"",
                    "        ) {",
                    "          state = \"url\";",
                    "          i += 3;",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"*\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-block\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"/\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-inline\";",
                    "          inlineCommentStartIndex = i - 1;",
                    "          continue;",
                    "        }",
                    "",
                    "        continue;",
                    "",
                    "      case \"single-quotes\":",
                    "        if (c === \"'\" && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"double-quotes\":",
                    "        if (c === '\"' && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"url\":",
                    "        if (c === \")\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-block\":",
                    "        if (c === \"/\" && text[i - 1] === \"*\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-inline\":",
                    "        if (c === '\"' || c === \"'\" || c === \"*\") {",
                    "          inlineCommentContainsQuotes = true;",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          if (inlineCommentContainsQuotes) {",
                    "            inlineCommentsToReplace.push([inlineCommentStartIndex, i]);",
                    "          }",
                    "          state = \"initial\";",
                    "          inlineCommentContainsQuotes = false;",
                    "        }",
                    "        continue;",
                    "    }",
                    "  }",
                    "",
                    "  for (const [start, end] of inlineCommentsToReplace) {",
                    "    text =",
                    "      text.slice(0, start) +",
                    "      text.slice(start, end).replace(/[\"'*]/g, \" \") +",
                    "      text.slice(end);",
                    "  }",
                    "",
                    "  return text;",
                    "}",
                    "",
                    "function locStart(node) {",
                    "  return node.source.startOffset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.source.endOffset;",
                    "}",
                    "",
                    "module.exports = {",
                    "  locStart,",
                    "  locEnd,",
                    "  calculateLoc,",
                    "  replaceQuotesInInlineComments,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};"
                ]
            },
            "parser-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const parseFrontMatter = require(\"../utils/front-matter/parse.js\");",
                    "const { hasPragma } = require(\"./pragma.js\");",
                    "const {",
                    "  hasSCSSInterpolation,",
                    "  hasStringOrFunction,",
                    "  isLessParser,",
                    "  isSCSS,",
                    "  isSCSSNestedPropertyNode,",
                    "  isSCSSVariable,",
                    "  stringifyNode,",
                    "  isModuleRuleName,",
                    "} = require(\"./utils.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const { calculateLoc, replaceQuotesInInlineComments } = require(\"./loc.js\");",
                    "",
                    "const getHighestAncestor = (node) => {",
                    "  while (node.parent) {",
                    "    node = node.parent;",
                    "  }",
                    "  return node;",
                    "};",
                    "",
                    "function parseValueNode(valueNode, options) {",
                    "  const { nodes } = valueNode;",
                    "  let parenGroup = {",
                    "    open: null,",
                    "    close: null,",
                    "    groups: [],",
                    "    type: \"paren_group\",",
                    "  };",
                    "  const parenGroupStack = [parenGroup];",
                    "  const rootParenGroup = parenGroup;",
                    "  let commaGroup = {",
                    "    groups: [],",
                    "    type: \"comma_group\",",
                    "  };",
                    "  const commaGroupStack = [commaGroup];",
                    "",
                    "  for (let i = 0; i < nodes.length; ++i) {",
                    "    const node = nodes[i];",
                    "",
                    "    if (",
                    "      isSCSS(options.parser, node.value) &&",
                    "      node.type === \"number\" &&",
                    "      node.unit === \"..\" &&",
                    "      getLast(node.value) === \".\"",
                    "    ) {",
                    "      // Work around postcss bug parsing `50...` as `50.` with unit `..`",
                    "      // Set the unit to `...` to \"accidentally\" have arbitrary arguments work in the same way that cases where the node already had a unit work.",
                    "      // For example, 50px... is parsed as `50` with unit `px...` already by postcss-values-parser.",
                    "      node.value = node.value.slice(0, -1);",
                    "      node.unit = \"...\";",
                    "    }",
                    "",
                    "    if (node.type === \"func\" && node.value === \"selector\") {",
                    "      node.group.groups = [",
                    "        parseSelector(",
                    "          getHighestAncestor(valueNode).text.slice(",
                    "            node.group.open.sourceIndex + 1,",
                    "            node.group.close.sourceIndex",
                    "          )",
                    "        ),",
                    "      ];",
                    "    }",
                    "",
                    "    if (node.type === \"func\" && node.value === \"url\") {",
                    "      const groups = (node.group && node.group.groups) || [];",
                    "",
                    "      // Create a view with any top-level comma groups flattened.",
                    "      let groupList = [];",
                    "      for (let i = 0; i < groups.length; i++) {",
                    "        const group = groups[i];",
                    "        if (group.type === \"comma_group\") {",
                    "          groupList = [...groupList, ...group.groups];",
                    "        } else {",
                    "          groupList.push(group);",
                    "        }",
                    "      }",
                    "",
                    "      // Stringify if the value parser can't handle the content.",
                    "      if (",
                    "        hasSCSSInterpolation(groupList) ||",
                    "        (!hasStringOrFunction(groupList) && !isSCSSVariable(groupList[0]))",
                    "      ) {",
                    "        const stringifiedContent = stringifyNode({",
                    "          groups: node.group.groups,",
                    "        });",
                    "        node.group.groups = [stringifiedContent.trim()];",
                    "      }",
                    "    }",
                    "    if (node.type === \"paren\" && node.value === \"(\") {",
                    "      parenGroup = {",
                    "        open: node,",
                    "        close: null,",
                    "        groups: [],",
                    "        type: \"paren_group\",",
                    "      };",
                    "      parenGroupStack.push(parenGroup);",
                    "",
                    "      commaGroup = {",
                    "        groups: [],",
                    "        type: \"comma_group\",",
                    "      };",
                    "      commaGroupStack.push(commaGroup);",
                    "    } else if (node.type === \"paren\" && node.value === \")\") {",
                    "      if (commaGroup.groups.length > 0) {",
                    "        parenGroup.groups.push(commaGroup);",
                    "      }",
                    "      parenGroup.close = node;",
                    "",
                    "      /* istanbul ignore next */",
                    "      if (commaGroupStack.length === 1) {",
                    "        throw new Error(\"Unbalanced parenthesis\");",
                    "      }",
                    "",
                    "      commaGroupStack.pop();",
                    "      commaGroup = getLast(commaGroupStack);",
                    "      commaGroup.groups.push(parenGroup);",
                    "",
                    "      parenGroupStack.pop();",
                    "      parenGroup = getLast(parenGroupStack);",
                    "    } else if (node.type === \"comma\") {",
                    "      parenGroup.groups.push(commaGroup);",
                    "      commaGroup = {",
                    "        groups: [],",
                    "        type: \"comma_group\",",
                    "      };",
                    "      commaGroupStack[commaGroupStack.length - 1] = commaGroup;",
                    "    } else {",
                    "      commaGroup.groups.push(node);",
                    "    }",
                    "  }",
                    "  if (commaGroup.groups.length > 0) {",
                    "    parenGroup.groups.push(commaGroup);",
                    "  }",
                    "  return rootParenGroup;",
                    "}",
                    "",
                    "function flattenGroups(node) {",
                    "  if (",
                    "    node.type === \"paren_group\" &&",
                    "    !node.open &&",
                    "    !node.close &&",
                    "    node.groups.length === 1",
                    "  ) {",
                    "    return flattenGroups(node.groups[0]);",
                    "  }",
                    "",
                    "  if (node.type === \"comma_group\" && node.groups.length === 1) {",
                    "    return flattenGroups(node.groups[0]);",
                    "  }",
                    "",
                    "  if (node.type === \"paren_group\" || node.type === \"comma_group\") {",
                    "    return { ...node, groups: node.groups.map(flattenGroups) };",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function addTypePrefix(node, prefix, skipPrefix) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      addTypePrefix(node[key], prefix, skipPrefix);",
                    "      if (key === \"type\" && typeof node[key] === \"string\") {",
                    "        if (",
                    "          !node[key].startsWith(prefix) &&",
                    "          (!skipPrefix || !skipPrefix.test(node[key]))",
                    "        ) {",
                    "          node[key] = prefix + node[key];",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function addMissingType(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "    for (const key in node) {",
                    "      addMissingType(node[key]);",
                    "    }",
                    "    if (!Array.isArray(node) && node.value && !node.type) {",
                    "      node.type = \"unknown\";",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function parseNestedValue(node, options) {",
                    "  if (node && typeof node === \"object\") {",
                    "    for (const key in node) {",
                    "      if (key !== \"parent\") {",
                    "        parseNestedValue(node[key], options);",
                    "        if (key === \"nodes\") {",
                    "          node.group = flattenGroups(parseValueNode(node, options));",
                    "          delete node[key];",
                    "        }",
                    "      }",
                    "    }",
                    "    delete node.parent;",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "function parseValue(value, options) {",
                    "  const valueParser = require(\"postcss-values-parser\");",
                    "",
                    "  let result = null;",
                    "",
                    "  try {",
                    "    result = valueParser(value, { loose: true }).parse();",
                    "  } catch {",
                    "    return {",
                    "      type: \"value-unknown\",",
                    "      value,",
                    "    };",
                    "  }",
                    "",
                    "  result.text = value;",
                    "",
                    "  const parsedResult = parseNestedValue(result, options);",
                    "",
                    "  return addTypePrefix(parsedResult, \"value-\", /^selector-/);",
                    "}",
                    "",
                    "function parseSelector(selector) {",
                    "  // If there's a comment inside of a selector, the parser tries to parse",
                    "  // the content of the comment as selectors which turns it into complete",
                    "  // garbage. Better to print the whole selector as-is and not try to parse",
                    "  // and reformat it.",
                    "  if (/\\/\\/|\\/\\*/.test(selector)) {",
                    "    return {",
                    "      type: \"selector-unknown\",",
                    "      value: selector.trim(),",
                    "    };",
                    "  }",
                    "",
                    "  const selectorParser = require(\"postcss-selector-parser\");",
                    "",
                    "  let result = null;",
                    "",
                    "  try {",
                    "    selectorParser((result_) => {",
                    "      result = result_;",
                    "    }).process(selector);",
                    "  } catch {",
                    "    // Fail silently. It's better to print it as is than to try and parse it",
                    "    // Note: A common failure is for SCSS nested properties. `background:",
                    "    // none { color: red; }` is parsed as a NestedDeclaration by",
                    "    // postcss-scss, while `background: { color: red; }` is parsed as a Rule",
                    "    // with a selector ending with a colon. See:",
                    "    // https://github.com/postcss/postcss-scss/issues/39",
                    "    return {",
                    "      type: \"selector-unknown\",",
                    "      value: selector,",
                    "    };",
                    "  }",
                    "",
                    "  return addTypePrefix(result, \"selector-\");",
                    "}",
                    "",
                    "function parseMediaQuery(params) {",
                    "  const mediaParser = require(\"postcss-media-query-parser\").default;",
                    "",
                    "  let result = null;",
                    "",
                    "  try {",
                    "    result = mediaParser(params);",
                    "  } catch {",
                    "    // Ignore bad media queries",
                    "    /* istanbul ignore next */",
                    "    return {",
                    "      type: \"selector-unknown\",",
                    "      value: params,",
                    "    };",
                    "  }",
                    "",
                    "  return addTypePrefix(addMissingType(result), \"media-\");",
                    "}",
                    "",
                    "const DEFAULT_SCSS_DIRECTIVE = /(\\s*)(!default).*$/;",
                    "const GLOBAL_SCSS_DIRECTIVE = /(\\s*)(!global).*$/;",
                    "",
                    "function parseNestedCSS(node, options) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "",
                    "    for (const key in node) {",
                    "      parseNestedCSS(node[key], options);",
                    "    }",
                    "",
                    "    if (!node.type) {",
                    "      return node;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    if (!node.raws) {",
                    "      node.raws = {};",
                    "    }",
                    "",
                    "    let selector = \"\";",
                    "",
                    "    if (typeof node.selector === \"string\") {",
                    "      selector = node.raws.selector",
                    "        ? node.raws.selector.scss",
                    "          ? node.raws.selector.scss",
                    "          : node.raws.selector.raw",
                    "        : node.selector;",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        selector += node.raws.between;",
                    "      }",
                    "",
                    "      node.raws.selector = selector;",
                    "    }",
                    "",
                    "    let value = \"\";",
                    "",
                    "    if (typeof node.value === \"string\") {",
                    "      value = node.raws.value",
                    "        ? node.raws.value.scss",
                    "          ? node.raws.value.scss",
                    "          : node.raws.value.raw",
                    "        : node.value;",
                    "",
                    "      value = value.trim();",
                    "",
                    "      node.raws.value = value;",
                    "    }",
                    "",
                    "    let params = \"\";",
                    "",
                    "    if (typeof node.params === \"string\") {",
                    "      params = node.raws.params",
                    "        ? node.raws.params.scss",
                    "          ? node.raws.params.scss",
                    "          : node.raws.params.raw",
                    "        : node.params;",
                    "",
                    "      if (node.raws.afterName && node.raws.afterName.trim().length > 0) {",
                    "        params = node.raws.afterName + params;",
                    "      }",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        params = params + node.raws.between;",
                    "      }",
                    "",
                    "      params = params.trim();",
                    "",
                    "      node.raws.params = params;",
                    "    }",
                    "",
                    "    // Ignore LESS mixin declaration",
                    "    if (selector.trim().length > 0) {",
                    "      // TODO: confirm this code is dead",
                    "      /* istanbul ignore next */",
                    "      if (selector.startsWith(\"@\") && selector.endsWith(\":\")) {",
                    "        return node;",
                    "      }",
                    "",
                    "      // TODO: confirm this code is dead",
                    "      /* istanbul ignore next */",
                    "      // Ignore LESS mixins",
                    "      if (node.mixin) {",
                    "        node.selector = parseValue(selector, options);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      // Check on SCSS nested property",
                    "      if (isSCSSNestedPropertyNode(node)) {",
                    "        node.isSCSSNesterProperty = true;",
                    "      }",
                    "",
                    "      node.selector = parseSelector(selector);",
                    "",
                    "      return node;",
                    "    }",
                    "",
                    "    if (value.length > 0) {",
                    "      const defaultSCSSDirectiveIndex = value.match(DEFAULT_SCSS_DIRECTIVE);",
                    "",
                    "      if (defaultSCSSDirectiveIndex) {",
                    "        value = value.slice(0, defaultSCSSDirectiveIndex.index);",
                    "        node.scssDefault = true;",
                    "",
                    "        if (defaultSCSSDirectiveIndex[0].trim() !== \"!default\") {",
                    "          node.raws.scssDefault = defaultSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      const globalSCSSDirectiveIndex = value.match(GLOBAL_SCSS_DIRECTIVE);",
                    "",
                    "      if (globalSCSSDirectiveIndex) {",
                    "        value = value.slice(0, globalSCSSDirectiveIndex.index);",
                    "        node.scssGlobal = true;",
                    "",
                    "        if (globalSCSSDirectiveIndex[0].trim() !== \"!global\") {",
                    "          node.raws.scssGlobal = globalSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      if (value.startsWith(\"progid:\")) {",
                    "        return {",
                    "          type: \"value-unknown\",",
                    "          value,",
                    "        };",
                    "      }",
                    "",
                    "      node.value = parseValue(value, options);",
                    "    }",
                    "",
                    "    if (",
                    "      isLessParser(options) &&",
                    "      node.type === \"css-decl\" &&",
                    "      value.startsWith(\"extend(\")",
                    "    ) {",
                    "      // extend is missing",
                    "      if (!node.extend) {",
                    "        node.extend = node.raws.between === \":\";",
                    "      }",
                    "",
                    "      // `:extend()` is parsed as value",
                    "      if (node.extend && !node.selector) {",
                    "        delete node.value;",
                    "        node.selector = parseSelector(value.slice(\"extend(\".length, -1));",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\") {",
                    "      if (isLessParser(options)) {",
                    "        // mixin",
                    "        if (node.mixin) {",
                    "          const source =",
                    "            node.raws.identifier +",
                    "            node.name +",
                    "            node.raws.afterName +",
                    "            node.raws.params;",
                    "          node.selector = parseSelector(source);",
                    "          delete node.params;",
                    "          return node;",
                    "        }",
                    "",
                    "        // function",
                    "        if (node.function) {",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      // only css support custom-selector",
                    "      if (options.parser === \"css\" && node.name === \"custom-selector\") {",
                    "        const customSelector = node.params.match(/:--\\S+\\s+/)[0].trim();",
                    "        node.customSelector = customSelector;",
                    "        node.selector = parseSelector(",
                    "          node.params.slice(customSelector.length).trim()",
                    "        );",
                    "        delete node.params;",
                    "        return node;",
                    "      }",
                    "",
                    "      if (isLessParser(options)) {",
                    "        // postcss-less doesn't recognize variables in some cases.",
                    "        // `@color: blue;` is recognized fine, but the cases below aren't:",
                    "",
                    "        // `@color:blue;`",
                    "        if (node.name.includes(\":\") && !node.params) {",
                    "          node.variable = true;",
                    "          const parts = node.name.split(\":\");",
                    "          node.name = parts[0];",
                    "          node.value = parseValue(parts.slice(1).join(\":\"), options);",
                    "        }",
                    "",
                    "        // `@color :blue;`",
                    "        if (",
                    "          ![\"page\", \"nest\", \"keyframes\"].includes(node.name) &&",
                    "          node.params &&",
                    "          node.params[0] === \":\"",
                    "        ) {",
                    "          node.variable = true;",
                    "          node.value = parseValue(node.params.slice(1), options);",
                    "          node.raws.afterName += \":\";",
                    "        }",
                    "",
                    "        // Less variable",
                    "        if (node.variable) {",
                    "          delete node.params;",
                    "          return node;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\" && params.length > 0) {",
                    "      const { name } = node;",
                    "      const lowercasedName = node.name.toLowerCase();",
                    "",
                    "      if (name === \"warn\" || name === \"error\") {",
                    "        node.params = {",
                    "          type: \"media-unknown\",",
                    "          value: params,",
                    "        };",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"extend\" || name === \"nest\") {",
                    "        node.selector = parseSelector(params);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"at-root\") {",
                    "        if (/^\\(\\s*(?:without|with)\\s*:.+\\)$/s.test(params)) {",
                    "          node.params = parseValue(params, options);",
                    "        } else {",
                    "          node.selector = parseSelector(params);",
                    "          delete node.params;",
                    "        }",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (isModuleRuleName(lowercasedName)) {",
                    "        node.import = true;",
                    "        delete node.filename;",
                    "        node.params = parseValue(params, options);",
                    "        return node;",
                    "      }",
                    "",
                    "      if (",
                    "        [",
                    "          \"namespace\",",
                    "          \"supports\",",
                    "          \"if\",",
                    "          \"else\",",
                    "          \"for\",",
                    "          \"each\",",
                    "          \"while\",",
                    "          \"debug\",",
                    "          \"mixin\",",
                    "          \"include\",",
                    "          \"function\",",
                    "          \"return\",",
                    "          \"define-mixin\",",
                    "          \"add-mixin\",",
                    "        ].includes(name)",
                    "      ) {",
                    "        // Remove unnecessary spaces in SCSS variable arguments",
                    "        // Move spaces after the `...`, so we can keep the range correct",
                    "        params = params.replace(/(\\$\\S+?)(\\s+)?\\.{3}/, \"$1...$2\");",
                    "        // Remove unnecessary spaces before SCSS control, mixin and function directives",
                    "        // Move spaces after the `(`, so we can keep the range correct",
                    "        params = params.replace(/^(?!if)(\\S+)(\\s+)\\(/, \"$1($2\");",
                    "",
                    "        node.value = parseValue(params, options);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if ([\"media\", \"custom-media\"].includes(lowercasedName)) {",
                    "        if (params.includes(\"#{\")) {",
                    "          // Workaround for media at rule with scss interpolation",
                    "          return {",
                    "            type: \"media-unknown\",",
                    "            value: params,",
                    "          };",
                    "        }",
                    "",
                    "        node.params = parseMediaQuery(params);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      node.params = params;",
                    "",
                    "      return node;",
                    "    }",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function parseWithParser(parse, text, options) {",
                    "  const parsed = parseFrontMatter(text);",
                    "  const { frontMatter } = parsed;",
                    "  text = parsed.content;",
                    "",
                    "  let result;",
                    "",
                    "  try {",
                    "    result = parse(text);",
                    "  } catch (error) {",
                    "    const { name, reason, line, column } = error;",
                    "    /* istanbul ignore next */",
                    "    if (typeof line !== \"number\") {",
                    "      throw error;",
                    "    }",
                    "    throw createError(`${name}: ${reason}`, { start: { line, column } });",
                    "  }",
                    "",
                    "  result = parseNestedCSS(addTypePrefix(result, \"css-\"), options);",
                    "",
                    "  calculateLoc(result, text);",
                    "",
                    "  if (frontMatter) {",
                    "    frontMatter.source = {",
                    "      startOffset: 0,",
                    "      endOffset: frontMatter.raw.length,",
                    "    };",
                    "    result.nodes.unshift(frontMatter);",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "// TODO: make this only work on css",
                    "function parseCss(text, parsers, options = {}) {",
                    "  const isSCSSParser = isSCSS(options.parser, text);",
                    "  const parseFunctions = isSCSSParser",
                    "    ? [parseScss, parseLess]",
                    "    : [parseLess, parseScss];",
                    "",
                    "  let error;",
                    "  for (const parse of parseFunctions) {",
                    "    try {",
                    "      return parse(text, parsers, options);",
                    "    } catch (parseError) {",
                    "      error = error || parseError;",
                    "    }",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (error) {",
                    "    throw error;",
                    "  }",
                    "}",
                    "",
                    "function parseLess(text, parsers, options = {}) {",
                    "  const lessParser = require(\"postcss-less\");",
                    "  return parseWithParser(",
                    "    // Workaround for https://github.com/shellscape/postcss-less/issues/145",
                    "    // See comments for `replaceQuotesInInlineComments` in `loc.js`.",
                    "    (text) => lessParser.parse(replaceQuotesInInlineComments(text)),",
                    "    text,",
                    "    options",
                    "  );",
                    "}",
                    "",
                    "function parseScss(text, parsers, options = {}) {",
                    "  const { parse } = require(\"postcss-scss\");",
                    "  return parseWithParser(parse, text, options);",
                    "}",
                    "",
                    "const postCssParser = {",
                    "  astFormat: \"postcss\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "// Export as a plugin so we can reuse the same bundle for UMD loading",
                    "module.exports = {",
                    "  parsers: {",
                    "    css: {",
                    "      ...postCssParser,",
                    "      parse: parseCss,",
                    "    },",
                    "    less: {",
                    "      ...postCssParser,",
                    "      parse: parseLess,",
                    "    },",
                    "    scss: {",
                    "      ...postCssParser,",
                    "      parse: parseScss,",
                    "    },",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  // TODO: switch these to just `postcss` and use `language` instead.",
                    "  get css() {",
                    "    return require(\"./parser-postcss.js\").parsers.css;",
                    "  },",
                    "  get less() {",
                    "    return require(\"./parser-postcss.js\").parsers.less;",
                    "  },",
                    "  get scss() {",
                    "    return require(\"./parser-postcss.js\").parsers.scss;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const jsPragma = require(\"../language-js/pragma.js\");",
                    "const parseFrontMatter = require(\"../utils/front-matter/parse.js\");",
                    "",
                    "function hasPragma(text) {",
                    "  return jsPragma.hasPragma(parseFrontMatter(text).content);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  const { frontMatter, content } = parseFrontMatter(text);",
                    "  return (",
                    "    (frontMatter ? frontMatter.raw + \"\\n\\n\" : \"\") +",
                    "    jsPragma.insertPragma(content)",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "printer-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const {",
                    "  printNumber,",
                    "  printString,",
                    "  hasNewline,",
                    "  isFrontMatterNode,",
                    "  isNextLineEmpty,",
                    "  isNonEmptyArray,",
                    "} = require(\"../common/util.js\");",
                    "const {",
                    "  builders: {",
                    "    join,",
                    "    line,",
                    "    hardline,",
                    "    softline,",
                    "    group,",
                    "    fill,",
                    "    indent,",
                    "    dedent,",
                    "    ifBreak,",
                    "    breakParent,",
                    "  },",
                    "  utils: { removeLines, getDocParts },",
                    "} = require(\"../document/index.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "",
                    "const {",
                    "  getAncestorNode,",
                    "  getPropOfDeclNode,",
                    "  maybeToLowerCase,",
                    "  insideValueFunctionNode,",
                    "  insideICSSRuleNode,",
                    "  insideAtRuleNode,",
                    "  insideURLFunctionInImportAtRuleNode,",
                    "  isKeyframeAtRuleKeywords,",
                    "  isWideKeywords,",
                    "  isSCSS,",
                    "  isLastNode,",
                    "  isLessParser,",
                    "  isSCSSControlDirectiveNode,",
                    "  isDetachedRulesetDeclarationNode,",
                    "  isRelationalOperatorNode,",
                    "  isEqualityOperatorNode,",
                    "  isMultiplicationNode,",
                    "  isDivisionNode,",
                    "  isAdditionNode,",
                    "  isSubtractionNode,",
                    "  isMathOperatorNode,",
                    "  isEachKeywordNode,",
                    "  isForKeywordNode,",
                    "  isURLFunctionNode,",
                    "  isIfElseKeywordNode,",
                    "  hasComposesNode,",
                    "  hasParensAroundNode,",
                    "  hasEmptyRawBefore,",
                    "  isKeyValuePairNode,",
                    "  isKeyInValuePairNode,",
                    "  isDetachedRulesetCallNode,",
                    "  isTemplatePlaceholderNode,",
                    "  isTemplatePropNode,",
                    "  isPostcssSimpleVarNode,",
                    "  isSCSSMapItemNode,",
                    "  isInlineValueCommentNode,",
                    "  isHashNode,",
                    "  isLeftCurlyBraceNode,",
                    "  isRightCurlyBraceNode,",
                    "  isWordNode,",
                    "  isColonNode,",
                    "  isMediaAndSupportsKeywords,",
                    "  isColorAdjusterFuncNode,",
                    "  lastLineHasInlineComment,",
                    "  isAtWordPlaceholderNode,",
                    "  isConfigurationNode,",
                    "  isParenGroupNode,",
                    "} = require(\"./utils.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "function shouldPrintComma(options) {",
                    "  return options.trailingComma === \"es5\" || options.trailingComma === \"all\";",
                    "}",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  /* istanbul ignore if */",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof node === \"string\") {",
                    "    return node;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return [node.raw, hardline];",
                    "    case \"css-root\": {",
                    "      const nodes = printNodeSequence(path, options, print);",
                    "      const after = node.raws.after.trim();",
                    "",
                    "      return [",
                    "        nodes,",
                    "        after ? ` ${after}` : \"\",",
                    "        getDocParts(nodes).length > 0 ? hardline : \"\",",
                    "      ];",
                    "    }",
                    "    case \"css-comment\": {",
                    "      const isInlineComment = node.inline || node.raws.inline;",
                    "",
                    "      const text = options.originalText.slice(locStart(node), locEnd(node));",
                    "",
                    "      return isInlineComment ? text.trimEnd() : text;",
                    "    }",
                    "    case \"css-rule\": {",
                    "      return [",
                    "        print(\"selector\"),",
                    "        node.important ? \" !important\" : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              node.selector &&",
                    "              node.selector.type === \"selector-unknown\" &&",
                    "              lastLineHasInlineComment(node.selector.value)",
                    "                ? line",
                    "                : \" \",",
                    "              \"{\",",
                    "              node.nodes.length > 0",
                    "                ? indent([hardline, printNodeSequence(path, options, print)])",
                    "                : \"\",",
                    "              hardline,",
                    "              \"}\",",
                    "              isDetachedRulesetDeclarationNode(node) ? \";\" : \"\",",
                    "            ]",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    case \"css-decl\": {",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      const { between: rawBetween } = node.raws;",
                    "      const trimmedBetween = rawBetween.trim();",
                    "      const isColon = trimmedBetween === \":\";",
                    "",
                    "      let value = hasComposesNode(node)",
                    "        ? removeLines(print(\"value\"))",
                    "        : print(\"value\");",
                    "",
                    "      if (!isColon && lastLineHasInlineComment(trimmedBetween)) {",
                    "        value = indent([hardline, dedent(value)]);",
                    "      }",
                    "",
                    "      return [",
                    "        node.raws.before.replace(/[\\s;]/g, \"\"),",
                    "        insideICSSRuleNode(path) ? node.prop : maybeToLowerCase(node.prop),",
                    "        trimmedBetween.startsWith(\"//\") ? \" \" : \"\",",
                    "        trimmedBetween,",
                    "        node.extend ? \"\" : \" \",",
                    "        isLessParser(options) && node.extend && node.selector",
                    "          ? [\"extend(\", print(\"selector\"), \")\"]",
                    "          : \"\",",
                    "        value,",
                    "        node.raws.important",
                    "          ? node.raws.important.replace(/\\s*!\\s*important/i, \" !important\")",
                    "          : node.important",
                    "          ? \" !important\"",
                    "          : \"\",",
                    "        node.raws.scssDefault",
                    "          ? node.raws.scssDefault.replace(/\\s*!default/i, \" !default\")",
                    "          : node.scssDefault",
                    "          ? \" !default\"",
                    "          : \"\",",
                    "        node.raws.scssGlobal",
                    "          ? node.raws.scssGlobal.replace(/\\s*!global/i, \" !global\")",
                    "          : node.scssGlobal",
                    "          ? \" !global\"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              \" {\",",
                    "              indent([softline, printNodeSequence(path, options, print)]),",
                    "              softline,",
                    "              \"}\",",
                    "            ]",
                    "          : isTemplatePropNode(node) &&",
                    "            !parentNode.raws.semicolon &&",
                    "            options.originalText[locEnd(node) - 1] !== \";\"",
                    "          ? \"\"",
                    "          : options.__isHTMLStyleAttribute && isLastNode(path, node)",
                    "          ? ifBreak(\";\")",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    case \"css-atrule\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const isTemplatePlaceholderNodeWithoutSemiColon =",
                    "        isTemplatePlaceholderNode(node) &&",
                    "        !parentNode.raws.semicolon &&",
                    "        options.originalText[locEnd(node) - 1] !== \";\";",
                    "",
                    "      if (isLessParser(options)) {",
                    "        if (node.mixin) {",
                    "          return [",
                    "            print(\"selector\"),",
                    "            node.important ? \" !important\" : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "",
                    "        if (node.function) {",
                    "          return [",
                    "            node.name,",
                    "            print(\"params\"),",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "",
                    "        if (node.variable) {",
                    "          return [",
                    "            \"@\",",
                    "            node.name,",
                    "            \": \",",
                    "            node.value ? print(\"value\") : \"\",",
                    "            node.raws.between.trim() ? node.raws.between.trim() + \" \" : \"\",",
                    "            node.nodes",
                    "              ? [",
                    "                  \"{\",",
                    "                  indent([",
                    "                    node.nodes.length > 0 ? softline : \"\",",
                    "                    printNodeSequence(path, options, print),",
                    "                  ]),",
                    "                  softline,",
                    "                  \"}\",",
                    "                ]",
                    "              : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "      }",
                    "",
                    "      return [",
                    "        \"@\",",
                    "        // If a Less file ends up being parsed with the SCSS parser, Less",
                    "        // variable declarations will be parsed as at-rules with names ending",
                    "        // with a colon, so keep the original case then.",
                    "        isDetachedRulesetCallNode(node) || node.name.endsWith(\":\")",
                    "          ? node.name",
                    "          : maybeToLowerCase(node.name),",
                    "        node.params",
                    "          ? [",
                    "              isDetachedRulesetCallNode(node)",
                    "                ? \"\"",
                    "                : isTemplatePlaceholderNode(node)",
                    "                ? node.raws.afterName === \"\"",
                    "                  ? \"\"",
                    "                  : node.name.endsWith(\":\")",
                    "                  ? \" \"",
                    "                  : /^\\s*\\n\\s*\\n/.test(node.raws.afterName)",
                    "                  ? [hardline, hardline]",
                    "                  : /^\\s*\\n/.test(node.raws.afterName)",
                    "                  ? hardline",
                    "                  : \" \"",
                    "                : \" \",",
                    "              print(\"params\"),",
                    "            ]",
                    "          : \"\",",
                    "        node.selector ? indent([\" \", print(\"selector\")]) : \"\",",
                    "        node.value",
                    "          ? group([",
                    "              \" \",",
                    "              print(\"value\"),",
                    "              isSCSSControlDirectiveNode(node)",
                    "                ? hasParensAroundNode(node)",
                    "                  ? \" \"",
                    "                  : line",
                    "                : \"\",",
                    "            ])",
                    "          : node.name === \"else\"",
                    "          ? \" \"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              isSCSSControlDirectiveNode(node)",
                    "                ? \"\"",
                    "                : (node.selector &&",
                    "                    !node.selector.nodes &&",
                    "                    typeof node.selector.value === \"string\" &&",
                    "                    lastLineHasInlineComment(node.selector.value)) ||",
                    "                  (!node.selector &&",
                    "                    typeof node.params === \"string\" &&",
                    "                    lastLineHasInlineComment(node.params))",
                    "                ? line",
                    "                : \" \",",
                    "              \"{\",",
                    "              indent([",
                    "                node.nodes.length > 0 ? softline : \"\",",
                    "                printNodeSequence(path, options, print),",
                    "              ]),",
                    "              softline,",
                    "              \"}\",",
                    "            ]",
                    "          : isTemplatePlaceholderNodeWithoutSemiColon",
                    "          ? \"\"",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    // postcss-media-query-parser",
                    "    case \"media-query-list\": {",
                    "      const parts = [];",
                    "      path.each((childPath) => {",
                    "        const node = childPath.getValue();",
                    "        if (node.type === \"media-query\" && node.value === \"\") {",
                    "          return;",
                    "        }",
                    "        parts.push(print());",
                    "      }, \"nodes\");",
                    "",
                    "      return group(indent(join(line, parts)));",
                    "    }",
                    "    case \"media-query\": {",
                    "      return [",
                    "        join(\" \", path.map(print, \"nodes\")),",
                    "        isLastNode(path, node) ? \"\" : \",\",",
                    "      ];",
                    "    }",
                    "    case \"media-type\": {",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "    }",
                    "    case \"media-feature-expression\": {",
                    "      if (!node.nodes) {",
                    "        return node.value;",
                    "      }",
                    "      return [\"(\", ...path.map(print, \"nodes\"), \")\"];",
                    "    }",
                    "    case \"media-feature\": {",
                    "      return maybeToLowerCase(",
                    "        adjustStrings(node.value.replace(/ +/g, \" \"), options)",
                    "      );",
                    "    }",
                    "    case \"media-colon\": {",
                    "      return [node.value, \" \"];",
                    "    }",
                    "    case \"media-value\": {",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "    }",
                    "    case \"media-keyword\": {",
                    "      return adjustStrings(node.value, options);",
                    "    }",
                    "    case \"media-url\": {",
                    "      return adjustStrings(",
                    "        node.value.replace(/^url\\(\\s+/gi, \"url(\").replace(/\\s+\\)$/g, \")\"),",
                    "        options",
                    "      );",
                    "    }",
                    "    case \"media-unknown\": {",
                    "      return node.value;",
                    "    }",
                    "    // postcss-selector-parser",
                    "    case \"selector-root\": {",
                    "      return group([",
                    "        insideAtRuleNode(path, \"custom-selector\")",
                    "          ? [getAncestorNode(path, \"css-atrule\").customSelector, line]",
                    "          : \"\",",
                    "        join(",
                    "          [",
                    "            \",\",",
                    "            insideAtRuleNode(path, [\"extend\", \"custom-selector\", \"nest\"])",
                    "              ? line",
                    "              : hardline,",
                    "          ],",
                    "          path.map(print, \"nodes\")",
                    "        ),",
                    "      ]);",
                    "    }",
                    "    case \"selector-selector\": {",
                    "      return group(indent(path.map(print, \"nodes\")));",
                    "    }",
                    "    case \"selector-comment\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"selector-string\": {",
                    "      return adjustStrings(node.value, options);",
                    "    }",
                    "    case \"selector-tag\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode && parentNode.nodes.indexOf(node);",
                    "      const prevNode = index && parentNode.nodes[index - 1];",
                    "",
                    "      return [",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        prevNode.type === \"selector-nesting\"",
                    "          ? node.value",
                    "          : adjustNumbers(",
                    "              isKeyframeAtRuleKeywords(path, node.value)",
                    "                ? node.value.toLowerCase()",
                    "                : node.value",
                    "            ),",
                    "      ];",
                    "    }",
                    "    case \"selector-id\": {",
                    "      return [\"#\", node.value];",
                    "    }",
                    "    case \"selector-class\": {",
                    "      return [\".\", adjustNumbers(adjustStrings(node.value, options))];",
                    "    }",
                    "    case \"selector-attribute\": {",
                    "      return [",
                    "        \"[\",",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        node.attribute.trim(),",
                    "        node.operator ? node.operator : \"\",",
                    "        node.value",
                    "          ? quoteAttributeValue(",
                    "              adjustStrings(node.value.trim(), options),",
                    "              options",
                    "            )",
                    "          : \"\",",
                    "        node.insensitive ? \" i\" : \"\",",
                    "        \"]\",",
                    "      ];",
                    "    }",
                    "    case \"selector-combinator\": {",
                    "      if (",
                    "        node.value === \"+\" ||",
                    "        node.value === \">\" ||",
                    "        node.value === \"~\" ||",
                    "        node.value === \">>>\"",
                    "      ) {",
                    "        const parentNode = path.getParentNode();",
                    "        const leading =",
                    "          parentNode.type === \"selector-selector\" &&",
                    "          parentNode.nodes[0] === node",
                    "            ? \"\"",
                    "            : line;",
                    "",
                    "        return [leading, node.value, isLastNode(path, node) ? \"\" : \" \"];",
                    "      }",
                    "",
                    "      const leading = node.value.trim().startsWith(\"(\") ? line : \"\";",
                    "      const value =",
                    "        adjustNumbers(adjustStrings(node.value.trim(), options)) || line;",
                    "",
                    "      return [leading, value];",
                    "    }",
                    "    case \"selector-universal\": {",
                    "      return [",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        node.value,",
                    "      ];",
                    "    }",
                    "    case \"selector-pseudo\": {",
                    "      return [",
                    "        maybeToLowerCase(node.value),",
                    "        isNonEmptyArray(node.nodes)",
                    "          ? [\"(\", join(\", \", path.map(print, \"nodes\")), \")\"]",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "    case \"selector-nesting\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"selector-unknown\": {",
                    "      const ruleAncestorNode = getAncestorNode(path, \"css-rule\");",
                    "",
                    "      // Nested SCSS property",
                    "      if (ruleAncestorNode && ruleAncestorNode.isSCSSNesterProperty) {",
                    "        return adjustNumbers(",
                    "          adjustStrings(maybeToLowerCase(node.value), options)",
                    "        );",
                    "      }",
                    "",
                    "      // originalText has to be used for Less, see replaceQuotesInInlineComments in loc.js",
                    "      const parentNode = path.getParentNode();",
                    "      if (parentNode.raws && parentNode.raws.selector) {",
                    "        const start = locStart(parentNode);",
                    "        const end = start + parentNode.raws.selector.length;",
                    "        return options.originalText.slice(start, end).trim();",
                    "      }",
                    "",
                    "      // Same reason above",
                    "      const grandParent = path.getParentNode(1);",
                    "      if (",
                    "        parentNode.type === \"value-paren_group\" &&",
                    "        grandParent &&",
                    "        grandParent.type === \"value-func\" &&",
                    "        grandParent.value === \"selector\"",
                    "      ) {",
                    "        const start = locStart(parentNode.open) + 1;",
                    "        const end = locEnd(parentNode.close) - 1;",
                    "        const selector = options.originalText.slice(start, end).trim();",
                    "",
                    "        return lastLineHasInlineComment(selector)",
                    "          ? [breakParent, selector]",
                    "          : selector;",
                    "      }",
                    "",
                    "      return node.value;",
                    "    }",
                    "    // postcss-values-parser",
                    "    case \"value-value\":",
                    "    case \"value-root\": {",
                    "      return print(\"group\");",
                    "    }",
                    "    case \"value-comment\": {",
                    "      return options.originalText.slice(locStart(node), locEnd(node));",
                    "    }",
                    "    case \"value-comma_group\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const parentParentNode = path.getParentNode(1);",
                    "      const declAncestorProp = getPropOfDeclNode(path);",
                    "      const isGridValue =",
                    "        declAncestorProp &&",
                    "        parentNode.type === \"value-value\" &&",
                    "        (declAncestorProp === \"grid\" ||",
                    "          declAncestorProp.startsWith(\"grid-template\"));",
                    "      const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "      const isControlDirective =",
                    "        atRuleAncestorNode && isSCSSControlDirectiveNode(atRuleAncestorNode);",
                    "      const hasInlineComment = node.groups.some((node) =>",
                    "        isInlineValueCommentNode(node)",
                    "      );",
                    "",
                    "      const printed = path.map(print, \"groups\");",
                    "      const parts = [];",
                    "      const insideURLFunction = insideValueFunctionNode(path, \"url\");",
                    "",
                    "      let insideSCSSInterpolationInString = false;",
                    "      let didBreak = false;",
                    "      for (let i = 0; i < node.groups.length; ++i) {",
                    "        parts.push(printed[i]);",
                    "",
                    "        const iPrevNode = node.groups[i - 1];",
                    "        const iNode = node.groups[i];",
                    "        const iNextNode = node.groups[i + 1];",
                    "        const iNextNextNode = node.groups[i + 2];",
                    "",
                    "        if (insideURLFunction) {",
                    "          if (",
                    "            (iNextNode && isAdditionNode(iNextNode)) ||",
                    "            isAdditionNode(iNode)",
                    "          ) {",
                    "            parts.push(\" \");",
                    "          }",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore SCSS @forward wildcard suffix",
                    "        if (",
                    "          insideAtRuleNode(path, \"forward\") &&",
                    "          iNode.type === \"value-word\" &&",
                    "          iNode.value &&",
                    "          iPrevNode !== undefined &&",
                    "          iPrevNode.type === \"value-word\" &&",
                    "          iPrevNode.value === \"as\" &&",
                    "          iNextNode.type === \"value-operator\" &&",
                    "          iNextNode.value === \"*\"",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore after latest node (i.e. before semicolon)",
                    "        if (!iNextNode) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // styled.div` background: var(--${one}); `",
                    "        if (",
                    "          iNode.type === \"value-word\" &&",
                    "          iNode.value.endsWith(\"-\") &&",
                    "          isAtWordPlaceholderNode(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore spaces before/after string interpolation (i.e. `\"#{my-fn(\"_\")}\"`)",
                    "        const isStartSCSSInterpolationInString =",
                    "          iNode.type === \"value-string\" && iNode.value.startsWith(\"#{\");",
                    "        const isEndingSCSSInterpolationInString =",
                    "          insideSCSSInterpolationInString &&",
                    "          iNextNode.type === \"value-string\" &&",
                    "          iNextNode.value.endsWith(\"}\");",
                    "",
                    "        if (",
                    "          isStartSCSSInterpolationInString ||",
                    "          isEndingSCSSInterpolationInString",
                    "        ) {",
                    "          insideSCSSInterpolationInString = !insideSCSSInterpolationInString;",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        if (insideSCSSInterpolationInString) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore colon (i.e. `:`)",
                    "        if (isColonNode(iNode) || isColonNode(iNextNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `@` in Less (i.e. `@@var;`)",
                    "        if (iNode.type === \"value-atword\" && iNode.value === \"\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `~` in Less (i.e. `content: ~\"^//* some horrible but needed css hack\";`)",
                    "        if (iNode.value === \"~\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore escape `\\`",
                    "        if (",
                    "          iNode.value &&",
                    "          iNode.value.includes(\"\\\\\") &&",
                    "          iNextNode &&",
                    "          iNextNode.type !== \"value-comment\"",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore escaped `/`",
                    "        if (",
                    "          iPrevNode &&",
                    "          iPrevNode.value &&",
                    "          iPrevNode.value.indexOf(\"\\\\\") === iPrevNode.value.length - 1 &&",
                    "          iNode.type === \"value-operator\" &&",
                    "          iNode.value === \"/\"",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `\\` (i.e. `$variable: \\@small;`)",
                    "        if (iNode.value === \"\\\\\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore `$$` (i.e. `background-color: $$(style)Color;`)",
                    "        if (isPostcssSimpleVarNode(iNode, iNextNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)",
                    "        if (",
                    "          isHashNode(iNode) ||",
                    "          isLeftCurlyBraceNode(iNode) ||",
                    "          isRightCurlyBraceNode(iNextNode) ||",
                    "          (isLeftCurlyBraceNode(iNextNode) && hasEmptyRawBefore(iNextNode)) ||",
                    "          (isRightCurlyBraceNode(iNode) && hasEmptyRawBefore(iNextNode))",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)",
                    "        if (iNode.value === \"--\" && isHashNode(iNextNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Formatting math operations",
                    "        const isMathOperator = isMathOperatorNode(iNode);",
                    "        const isNextMathOperator = isMathOperatorNode(iNextNode);",
                    "",
                    "        // Print spaces before and after math operators beside SCSS interpolation as is",
                    "        // (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)",
                    "        // (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)",
                    "        if (",
                    "          ((isMathOperator && isHashNode(iNextNode)) ||",
                    "            (isNextMathOperator && isRightCurlyBraceNode(iNode))) &&",
                    "          hasEmptyRawBefore(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // absolute paths are only parsed as one token if they are part of url(/abs/path) call",
                    "        // but if you have custom -fb-url(/abs/path/) then it is parsed as \"division /\" and rest",
                    "        // of the path. We don't want to put a space after that first division in this case.",
                    "        if (!iPrevNode && isDivisionNode(iNode)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Print spaces before and after addition and subtraction math operators as is in `calc` function",
                    "        // due to the fact that it is not valid syntax",
                    "        // (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)",
                    "        if (",
                    "          insideValueFunctionNode(path, \"calc\") &&",
                    "          (isAdditionNode(iNode) ||",
                    "            isAdditionNode(iNextNode) ||",
                    "            isSubtractionNode(iNode) ||",
                    "            isSubtractionNode(iNextNode)) &&",
                    "          hasEmptyRawBefore(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)",
                    "        // Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.",
                    "        const isColorAdjusterNode =",
                    "          (isAdditionNode(iNode) || isSubtractionNode(iNode)) &&",
                    "          i === 0 &&",
                    "          (iNextNode.type === \"value-number\" || iNextNode.isHex) &&",
                    "          parentParentNode &&",
                    "          isColorAdjusterFuncNode(parentParentNode) &&",
                    "          !hasEmptyRawBefore(iNextNode);",
                    "",
                    "        const requireSpaceBeforeOperator =",
                    "          (iNextNextNode && iNextNextNode.type === \"value-func\") ||",
                    "          (iNextNextNode && isWordNode(iNextNextNode)) ||",
                    "          iNode.type === \"value-func\" ||",
                    "          isWordNode(iNode);",
                    "        const requireSpaceAfterOperator =",
                    "          iNextNode.type === \"value-func\" ||",
                    "          isWordNode(iNextNode) ||",
                    "          (iPrevNode && iPrevNode.type === \"value-func\") ||",
                    "          (iPrevNode && isWordNode(iPrevNode));",
                    "",
                    "        // Formatting `/`, `+`, `-` sign",
                    "        if (",
                    "          !(isMultiplicationNode(iNextNode) || isMultiplicationNode(iNode)) &&",
                    "          !insideValueFunctionNode(path, \"calc\") &&",
                    "          !isColorAdjusterNode &&",
                    "          ((isDivisionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                    "            (isDivisionNode(iNode) && !requireSpaceAfterOperator) ||",
                    "            (isAdditionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                    "            (isAdditionNode(iNode) && !requireSpaceAfterOperator) ||",
                    "            isSubtractionNode(iNextNode) ||",
                    "            isSubtractionNode(iNode)) &&",
                    "          (hasEmptyRawBefore(iNextNode) ||",
                    "            (isMathOperator &&",
                    "              (!iPrevNode || (iPrevNode && isMathOperatorNode(iPrevNode)))))",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        // Add `hardline` after inline comment (i.e. `// comment\\n foo: bar;`)",
                    "        if (isInlineValueCommentNode(iNode)) {",
                    "          if (parentNode.type === \"value-paren_group\") {",
                    "            parts.push(dedent(hardline));",
                    "            continue;",
                    "          }",
                    "          parts.push(hardline);",
                    "          continue;",
                    "        }",
                    "",
                    "        // Handle keywords in SCSS control directive",
                    "        if (",
                    "          isControlDirective &&",
                    "          (isEqualityOperatorNode(iNextNode) ||",
                    "            isRelationalOperatorNode(iNextNode) ||",
                    "            isIfElseKeywordNode(iNextNode) ||",
                    "            isEachKeywordNode(iNode) ||",
                    "            isForKeywordNode(iNode))",
                    "        ) {",
                    "          parts.push(\" \");",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // At-rule `namespace` should be in one line",
                    "        if (",
                    "          atRuleAncestorNode &&",
                    "          atRuleAncestorNode.name.toLowerCase() === \"namespace\"",
                    "        ) {",
                    "          parts.push(\" \");",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // Formatting `grid` property",
                    "        if (isGridValue) {",
                    "          if (",
                    "            iNode.source &&",
                    "            iNextNode.source &&",
                    "            iNode.source.start.line !== iNextNode.source.start.line",
                    "          ) {",
                    "            parts.push(hardline);",
                    "",
                    "            didBreak = true;",
                    "          } else {",
                    "            parts.push(\" \");",
                    "          }",
                    "",
                    "          continue;",
                    "        }",
                    "",
                    "        // Add `space` before next math operation",
                    "        // Note: `grip` property have `/` delimiter and it is not math operation, so",
                    "        // `grid` property handles above",
                    "        if (isNextMathOperator) {",
                    "          parts.push(\" \");",
                    "",
                    "          continue;",
                    "        }",
                    "        // allow function(returns-list($list)...)",
                    "        if (iNextNode && iNextNode.value === \"...\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          isAtWordPlaceholderNode(iNode) &&",
                    "          isAtWordPlaceholderNode(iNextNode) &&",
                    "          locEnd(iNode) === locStart(iNextNode)",
                    "        ) {",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          isAtWordPlaceholderNode(iNode) &&",
                    "          isParenGroupNode(iNextNode) &&",
                    "          locEnd(iNode) === locStart(iNextNode.open)",
                    "        ) {",
                    "          parts.push(softline);",
                    "          continue;",
                    "        }",
                    "",
                    "        if (iNode.value === \"with\" && isParenGroupNode(iNextNode)) {",
                    "          parts.push(\" \");",
                    "          continue;",
                    "        }",
                    "",
                    "        // Be default all values go through `line`",
                    "        parts.push(line);",
                    "      }",
                    "",
                    "      if (hasInlineComment) {",
                    "        parts.push(breakParent);",
                    "      }",
                    "",
                    "      if (didBreak) {",
                    "        parts.unshift(hardline);",
                    "      }",
                    "",
                    "      if (isControlDirective) {",
                    "        return group(indent(parts));",
                    "      }",
                    "",
                    "      // Indent is not needed for import url when url is very long",
                    "      // and node has two groups",
                    "      // when type is value-comma_group",
                    "      // example @import url(\"verylongurl\") projection,tv",
                    "      if (insideURLFunctionInImportAtRuleNode(path)) {",
                    "        return group(fill(parts));",
                    "      }",
                    "",
                    "      return group(indent(fill(parts)));",
                    "    }",
                    "    case \"value-paren_group\": {",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      if (",
                    "        parentNode &&",
                    "        isURLFunctionNode(parentNode) &&",
                    "        (node.groups.length === 1 ||",
                    "          (node.groups.length > 0 &&",
                    "            node.groups[0].type === \"value-comma_group\" &&",
                    "            node.groups[0].groups.length > 0 &&",
                    "            node.groups[0].groups[0].type === \"value-word\" &&",
                    "            node.groups[0].groups[0].value.startsWith(\"data:\")))",
                    "      ) {",
                    "        return [",
                    "          node.open ? print(\"open\") : \"\",",
                    "          join(\",\", path.map(print, \"groups\")),",
                    "          node.close ? print(\"close\") : \"\",",
                    "        ];",
                    "      }",
                    "",
                    "      if (!node.open) {",
                    "        const printed = path.map(print, \"groups\");",
                    "        const res = [];",
                    "",
                    "        for (let i = 0; i < printed.length; i++) {",
                    "          if (i !== 0) {",
                    "            res.push([\",\", line]);",
                    "          }",
                    "          res.push(printed[i]);",
                    "        }",
                    "",
                    "        return group(indent(fill(res)));",
                    "      }",
                    "",
                    "      const isSCSSMapItem = isSCSSMapItemNode(path);",
                    "",
                    "      const lastItem = getLast(node.groups);",
                    "      const isLastItemComment = lastItem && lastItem.type === \"value-comment\";",
                    "      const isKey = isKeyInValuePairNode(node, parentNode);",
                    "      const isConfiguration = isConfigurationNode(node, parentNode);",
                    "",
                    "      const shouldBreak = isConfiguration || (isSCSSMapItem && !isKey);",
                    "      const shouldDedent = isConfiguration || isKey;",
                    "",
                    "      const printed = group(",
                    "        [",
                    "          node.open ? print(\"open\") : \"\",",
                    "          indent([",
                    "            softline,",
                    "            join(",
                    "              [\",\", line],",
                    "              path.map((childPath) => {",
                    "                const node = childPath.getValue();",
                    "                const printed = print();",
                    "",
                    "                // Key/Value pair in open paren already indented",
                    "                if (",
                    "                  isKeyValuePairNode(node) &&",
                    "                  node.type === \"value-comma_group\" &&",
                    "                  node.groups &&",
                    "                  node.groups[0].type !== \"value-paren_group\" &&",
                    "                  node.groups[2] &&",
                    "                  node.groups[2].type === \"value-paren_group\"",
                    "                ) {",
                    "                  const parts = getDocParts(printed.contents.contents);",
                    "                  parts[1] = group(parts[1]);",
                    "",
                    "                  return group(dedent(printed));",
                    "                }",
                    "",
                    "                return printed;",
                    "              }, \"groups\")",
                    "            ),",
                    "          ]),",
                    "          ifBreak(",
                    "            !isLastItemComment &&",
                    "              isSCSS(options.parser, options.originalText) &&",
                    "              isSCSSMapItem &&",
                    "              shouldPrintComma(options)",
                    "              ? \",\"",
                    "              : \"\"",
                    "          ),",
                    "          softline,",
                    "          node.close ? print(\"close\") : \"\",",
                    "        ],",
                    "        {",
                    "          shouldBreak,",
                    "        }",
                    "      );",
                    "",
                    "      return shouldDedent ? dedent(printed) : printed;",
                    "    }",
                    "    case \"value-func\": {",
                    "      return [",
                    "        node.value,",
                    "        insideAtRuleNode(path, \"supports\") && isMediaAndSupportsKeywords(node)",
                    "          ? \" \"",
                    "          : \"\",",
                    "        print(\"group\"),",
                    "      ];",
                    "    }",
                    "    case \"value-paren\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-number\": {",
                    "      return [printCssNumber(node.value), maybeToLowerCase(node.unit)];",
                    "    }",
                    "    case \"value-operator\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-word\": {",
                    "      if ((node.isColor && node.isHex) || isWideKeywords(node.value)) {",
                    "        return node.value.toLowerCase();",
                    "      }",
                    "",
                    "      return node.value;",
                    "    }",
                    "    case \"value-colon\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode && parentNode.groups.indexOf(node);",
                    "      const prevNode = index && parentNode.groups[index - 1];",
                    "      return [",
                    "        node.value,",
                    "        // Don't add spaces on escaped colon `:`, e.g: grid-template-rows: [row-1-00\\:00] auto;",
                    "        (prevNode &&",
                    "          typeof prevNode.value === \"string\" &&",
                    "          getLast(prevNode.value) === \"\\\\\") ||",
                    "        // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)",
                    "        insideValueFunctionNode(path, \"url\")",
                    "          ? \"\"",
                    "          : line,",
                    "      ];",
                    "    }",
                    "    // TODO: confirm this code is dead",
                    "    /* istanbul ignore next */",
                    "    case \"value-comma\": {",
                    "      return [node.value, \" \"];",
                    "    }",
                    "    case \"value-string\": {",
                    "      return printString(",
                    "        node.raws.quote + node.value + node.raws.quote,",
                    "        options",
                    "      );",
                    "    }",
                    "    case \"value-atword\": {",
                    "      return [\"@\", node.value];",
                    "    }",
                    "    case \"value-unicode-range\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"value-unknown\": {",
                    "      return node.value;",
                    "    }",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unknown postcss type ${JSON.stringify(node.type)}`);",
                    "  }",
                    "}",
                    "",
                    "function printNodeSequence(path, options, print) {",
                    "  const parts = [];",
                    "  path.each((pathChild, i, nodes) => {",
                    "    const prevNode = nodes[i - 1];",
                    "    if (",
                    "      prevNode &&",
                    "      prevNode.type === \"css-comment\" &&",
                    "      prevNode.text.trim() === \"prettier-ignore\"",
                    "    ) {",
                    "      const childNode = pathChild.getValue();",
                    "      parts.push(",
                    "        options.originalText.slice(locStart(childNode), locEnd(childNode))",
                    "      );",
                    "    } else {",
                    "      parts.push(print());",
                    "    }",
                    "",
                    "    if (i !== nodes.length - 1) {",
                    "      if (",
                    "        (nodes[i + 1].type === \"css-comment\" &&",
                    "          !hasNewline(options.originalText, locStart(nodes[i + 1]), {",
                    "            backwards: true,",
                    "          }) &&",
                    "          !isFrontMatterNode(nodes[i])) ||",
                    "        (nodes[i + 1].type === \"css-atrule\" &&",
                    "          nodes[i + 1].name === \"else\" &&",
                    "          nodes[i].type !== \"css-comment\")",
                    "      ) {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(options.__isHTMLStyleAttribute ? line : hardline);",
                    "        if (",
                    "          isNextLineEmpty(options.originalText, pathChild.getValue(), locEnd) &&",
                    "          !isFrontMatterNode(nodes[i])",
                    "        ) {",
                    "          parts.push(hardline);",
                    "        }",
                    "      }",
                    "    }",
                    "  }, \"nodes\");",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "const STRING_REGEX = /([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*\\1/gs;",
                    "const NUMBER_REGEX = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[Ee][+-]?\\d+)?/g;",
                    "const STANDARD_UNIT_REGEX = /[A-Za-z]+/g;",
                    "const WORD_PART_REGEX = /[$@]?[A-Z_a-z\\u0080-\\uFFFF][\\w\\u0080-\\uFFFF-]*/g;",
                    "const ADJUST_NUMBERS_REGEX = new RegExp(",
                    "  STRING_REGEX.source +",
                    "    \"|\" +",
                    "    `(${WORD_PART_REGEX.source})?` +",
                    "    `(${NUMBER_REGEX.source})` +",
                    "    `(${STANDARD_UNIT_REGEX.source})?`,",
                    "  \"g\"",
                    ");",
                    "",
                    "function adjustStrings(value, options) {",
                    "  return value.replace(STRING_REGEX, (match) => printString(match, options));",
                    "}",
                    "",
                    "function quoteAttributeValue(value, options) {",
                    "  const quote = options.singleQuote ? \"'\" : '\"';",
                    "  return value.includes('\"') || value.includes(\"'\")",
                    "    ? value",
                    "    : quote + value + quote;",
                    "}",
                    "",
                    "function adjustNumbers(value) {",
                    "  return value.replace(",
                    "    ADJUST_NUMBERS_REGEX,",
                    "    (match, quote, wordPart, number, unit) =>",
                    "      !wordPart && number",
                    "        ? printCssNumber(number) + maybeToLowerCase(unit || \"\")",
                    "        : match",
                    "  );",
                    "}",
                    "",
                    "function printCssNumber(rawNumber) {",
                    "  return (",
                    "    printNumber(rawNumber)",
                    "      // Remove trailing `.0`.",
                    "      .replace(/\\.0(?=$|e)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  embed,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isNonEmptyArray } = require(\"../common/util.js\");",
                    "const colorAdjusterFunctions = new Set([",
                    "  \"red\",",
                    "  \"green\",",
                    "  \"blue\",",
                    "  \"alpha\",",
                    "  \"a\",",
                    "  \"rgb\",",
                    "  \"hue\",",
                    "  \"h\",",
                    "  \"saturation\",",
                    "  \"s\",",
                    "  \"lightness\",",
                    "  \"l\",",
                    "  \"whiteness\",",
                    "  \"w\",",
                    "  \"blackness\",",
                    "  \"b\",",
                    "  \"tint\",",
                    "  \"shade\",",
                    "  \"blend\",",
                    "  \"blenda\",",
                    "  \"contrast\",",
                    "  \"hsl\",",
                    "  \"hsla\",",
                    "  \"hwb\",",
                    "  \"hwba\",",
                    "]);",
                    "const moduleRuleNames = new Set([\"import\", \"use\", \"forward\"]);",
                    "",
                    "function getAncestorCounter(path, typeOrTypes) {",
                    "  const types = Array.isArray(typeOrTypes) ? typeOrTypes : [typeOrTypes];",
                    "",
                    "  let counter = -1;",
                    "  let ancestorNode;",
                    "",
                    "  while ((ancestorNode = path.getParentNode(++counter))) {",
                    "    if (types.includes(ancestorNode.type)) {",
                    "      return counter;",
                    "    }",
                    "  }",
                    "",
                    "  return -1;",
                    "}",
                    "",
                    "function getAncestorNode(path, typeOrTypes) {",
                    "  const counter = getAncestorCounter(path, typeOrTypes);",
                    "  return counter === -1 ? null : path.getParentNode(counter);",
                    "}",
                    "",
                    "function getPropOfDeclNode(path) {",
                    "  const declAncestorNode = getAncestorNode(path, \"css-decl\");",
                    "",
                    "  return (",
                    "    declAncestorNode &&",
                    "    declAncestorNode.prop &&",
                    "    declAncestorNode.prop.toLowerCase()",
                    "  );",
                    "}",
                    "",
                    "function hasSCSSInterpolation(groupList) {",
                    "  if (isNonEmptyArray(groupList)) {",
                    "    for (let i = groupList.length - 1; i > 0; i--) {",
                    "      // If we find `#{`, return true.",
                    "      if (",
                    "        groupList[i].type === \"word\" &&",
                    "        groupList[i].value === \"{\" &&",
                    "        groupList[i - 1].type === \"word\" &&",
                    "        groupList[i - 1].value.endsWith(\"#\")",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function hasStringOrFunction(groupList) {",
                    "  if (isNonEmptyArray(groupList)) {",
                    "    for (let i = 0; i < groupList.length; i++) {",
                    "      if (groupList[i].type === \"string\" || groupList[i].type === \"func\") {",
                    "        return true;",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function isSCSS(parser, text) {",
                    "  const hasExplicitParserChoice = parser === \"less\" || parser === \"scss\";",
                    "  const IS_POSSIBLY_SCSS = /(?:\\w\\s*:\\s*[^:}]+|#){|@import[^\\n]+(?:url|,)/;",
                    "  return hasExplicitParserChoice",
                    "    ? parser === \"scss\"",
                    "    : IS_POSSIBLY_SCSS.test(text);",
                    "}",
                    "",
                    "function isSCSSVariable(node) {",
                    "  return Boolean(node && node.type === \"word\" && node.value.startsWith(\"$\"));",
                    "}",
                    "",
                    "function isWideKeywords(value) {",
                    "  return [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(",
                    "    value.toLowerCase()",
                    "  );",
                    "}",
                    "",
                    "function isKeyframeAtRuleKeywords(path, value) {",
                    "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "  return (",
                    "    atRuleAncestorNode &&",
                    "    atRuleAncestorNode.name &&",
                    "    atRuleAncestorNode.name.toLowerCase().endsWith(\"keyframes\") &&",
                    "    [\"from\", \"to\"].includes(value.toLowerCase())",
                    "  );",
                    "}",
                    "",
                    "function maybeToLowerCase(value) {",
                    "  return value.includes(\"$\") ||",
                    "    value.includes(\"@\") ||",
                    "    value.includes(\"#\") ||",
                    "    value.startsWith(\"%\") ||",
                    "    value.startsWith(\"--\") ||",
                    "    value.startsWith(\":--\") ||",
                    "    (value.includes(\"(\") && value.includes(\")\"))",
                    "    ? value",
                    "    : value.toLowerCase();",
                    "}",
                    "",
                    "function insideValueFunctionNode(path, functionName) {",
                    "  const funcAncestorNode = getAncestorNode(path, \"value-func\");",
                    "  return (",
                    "    funcAncestorNode &&",
                    "    funcAncestorNode.value &&",
                    "    funcAncestorNode.value.toLowerCase() === functionName",
                    "  );",
                    "}",
                    "",
                    "function insideICSSRuleNode(path) {",
                    "  const ruleAncestorNode = getAncestorNode(path, \"css-rule\");",
                    "",
                    "  return (",
                    "    ruleAncestorNode &&",
                    "    ruleAncestorNode.raws &&",
                    "    ruleAncestorNode.raws.selector &&",
                    "    (ruleAncestorNode.raws.selector.startsWith(\":import\") ||",
                    "      ruleAncestorNode.raws.selector.startsWith(\":export\"))",
                    "  );",
                    "}",
                    "",
                    "function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {",
                    "  const atRuleNames = Array.isArray(atRuleNameOrAtRuleNames)",
                    "    ? atRuleNameOrAtRuleNames",
                    "    : [atRuleNameOrAtRuleNames];",
                    "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "",
                    "  return (",
                    "    atRuleAncestorNode &&",
                    "    atRuleNames.includes(atRuleAncestorNode.name.toLowerCase())",
                    "  );",
                    "}",
                    "",
                    "function insideURLFunctionInImportAtRuleNode(path) {",
                    "  const node = path.getValue();",
                    "  const atRuleAncestorNode = getAncestorNode(path, \"css-atrule\");",
                    "",
                    "  return (",
                    "    atRuleAncestorNode &&",
                    "    atRuleAncestorNode.name === \"import\" &&",
                    "    node.groups[0].value === \"url\" &&",
                    "    node.groups.length === 2",
                    "  );",
                    "}",
                    "",
                    "function isURLFunctionNode(node) {",
                    "  return node.type === \"value-func\" && node.value.toLowerCase() === \"url\";",
                    "}",
                    "",
                    "function isLastNode(path, node) {",
                    "  const parentNode = path.getParentNode();",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (!parentNode) {",
                    "    return false;",
                    "  }",
                    "  const { nodes } = parentNode;",
                    "  return nodes && nodes.indexOf(node) === nodes.length - 1;",
                    "}",
                    "",
                    "function isDetachedRulesetDeclarationNode(node) {",
                    "  // If a Less file ends up being parsed with the SCSS parser, Less",
                    "  // variable declarations will be parsed as atrules with names ending",
                    "  // with a colon, so keep the original case then.",
                    "  /* istanbul ignore next */",
                    "  if (!node.selector) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return (",
                    "    (typeof node.selector === \"string\" && /^@.+:.*$/.test(node.selector)) ||",
                    "    (node.selector.value && /^@.+:.*$/.test(node.selector.value))",
                    "  );",
                    "}",
                    "",
                    "function isForKeywordNode(node) {",
                    "  return (",
                    "    node.type === \"value-word\" &&",
                    "    [\"from\", \"through\", \"end\"].includes(node.value)",
                    "  );",
                    "}",
                    "",
                    "function isIfElseKeywordNode(node) {",
                    "  return (",
                    "    node.type === \"value-word\" && [\"and\", \"or\", \"not\"].includes(node.value)",
                    "  );",
                    "}",
                    "",
                    "function isEachKeywordNode(node) {",
                    "  return node.type === \"value-word\" && node.value === \"in\";",
                    "}",
                    "",
                    "function isMultiplicationNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"*\";",
                    "}",
                    "",
                    "function isDivisionNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"/\";",
                    "}",
                    "",
                    "function isAdditionNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"+\";",
                    "}",
                    "",
                    "function isSubtractionNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"-\";",
                    "}",
                    "",
                    "function isModuloNode(node) {",
                    "  return node.type === \"value-operator\" && node.value === \"%\";",
                    "}",
                    "",
                    "function isMathOperatorNode(node) {",
                    "  return (",
                    "    isMultiplicationNode(node) ||",
                    "    isDivisionNode(node) ||",
                    "    isAdditionNode(node) ||",
                    "    isSubtractionNode(node) ||",
                    "    isModuloNode(node)",
                    "  );",
                    "}",
                    "",
                    "function isEqualityOperatorNode(node) {",
                    "  return node.type === \"value-word\" && [\"==\", \"!=\"].includes(node.value);",
                    "}",
                    "",
                    "function isRelationalOperatorNode(node) {",
                    "  return (",
                    "    node.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].includes(node.value)",
                    "  );",
                    "}",
                    "",
                    "function isSCSSControlDirectiveNode(node) {",
                    "  return (",
                    "    node.type === \"css-atrule\" &&",
                    "    [\"if\", \"else\", \"for\", \"each\", \"while\"].includes(node.name)",
                    "  );",
                    "}",
                    "",
                    "function isSCSSNestedPropertyNode(node) {",
                    "  /* istanbul ignore next */",
                    "  if (!node.selector) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return node.selector",
                    "    .replace(/\\/\\*.*?\\*\\//, \"\")",
                    "    .replace(/\\/\\/.*\\n/, \"\")",
                    "    .trim()",
                    "    .endsWith(\":\");",
                    "}",
                    "",
                    "function isDetachedRulesetCallNode(node) {",
                    "  return node.raws && node.raws.params && /^\\(\\s*\\)$/.test(node.raws.params);",
                    "}",
                    "",
                    "function isTemplatePlaceholderNode(node) {",
                    "  return node.name.startsWith(\"prettier-placeholder\");",
                    "}",
                    "",
                    "function isTemplatePropNode(node) {",
                    "  return node.prop.startsWith(\"@prettier-placeholder\");",
                    "}",
                    "",
                    "function isPostcssSimpleVarNode(currentNode, nextNode) {",
                    "  return (",
                    "    currentNode.value === \"$$\" &&",
                    "    currentNode.type === \"value-func\" &&",
                    "    nextNode &&",
                    "    nextNode.type === \"value-word\" &&",
                    "    !nextNode.raws.before",
                    "  );",
                    "}",
                    "",
                    "function hasComposesNode(node) {",
                    "  return (",
                    "    node.value &&",
                    "    node.value.type === \"value-root\" &&",
                    "    node.value.group &&",
                    "    node.value.group.type === \"value-value\" &&",
                    "    node.prop.toLowerCase() === \"composes\"",
                    "  );",
                    "}",
                    "",
                    "function hasParensAroundNode(node) {",
                    "  return (",
                    "    node.value &&",
                    "    node.value.group &&",
                    "    node.value.group.group &&",
                    "    node.value.group.group.type === \"value-paren_group\" &&",
                    "    node.value.group.group.open !== null &&",
                    "    node.value.group.group.close !== null",
                    "  );",
                    "}",
                    "",
                    "function hasEmptyRawBefore(node) {",
                    "  return node.raws && node.raws.before === \"\";",
                    "}",
                    "",
                    "function isKeyValuePairNode(node) {",
                    "  return (",
                    "    node.type === \"value-comma_group\" &&",
                    "    node.groups &&",
                    "    node.groups[1] &&",
                    "    node.groups[1].type === \"value-colon\"",
                    "  );",
                    "}",
                    "",
                    "function isKeyValuePairInParenGroupNode(node) {",
                    "  return (",
                    "    node.type === \"value-paren_group\" &&",
                    "    node.groups &&",
                    "    node.groups[0] &&",
                    "    isKeyValuePairNode(node.groups[0])",
                    "  );",
                    "}",
                    "",
                    "function isSCSSMapItemNode(path) {",
                    "  const node = path.getValue();",
                    "",
                    "  // Ignore empty item (i.e. `$key: ()`)",
                    "  if (node.groups.length === 0) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const parentParentNode = path.getParentNode(1);",
                    "",
                    "  // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)",
                    "  if (",
                    "    !isKeyValuePairInParenGroupNode(node) &&",
                    "    !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const declNode = getAncestorNode(path, \"css-decl\");",
                    "",
                    "  // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)",
                    "  if (declNode && declNode.prop && declNode.prop.startsWith(\"$\")) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)",
                    "  if (isKeyValuePairInParenGroupNode(parentParentNode)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)",
                    "  if (parentParentNode.type === \"value-func\") {",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isInlineValueCommentNode(node) {",
                    "  return node.type === \"value-comment\" && node.inline;",
                    "}",
                    "",
                    "function isHashNode(node) {",
                    "  return node.type === \"value-word\" && node.value === \"#\";",
                    "}",
                    "",
                    "function isLeftCurlyBraceNode(node) {",
                    "  return node.type === \"value-word\" && node.value === \"{\";",
                    "}",
                    "",
                    "function isRightCurlyBraceNode(node) {",
                    "  return node.type === \"value-word\" && node.value === \"}\";",
                    "}",
                    "",
                    "function isWordNode(node) {",
                    "  return [\"value-word\", \"value-atword\"].includes(node.type);",
                    "}",
                    "",
                    "function isColonNode(node) {",
                    "  return node && node.type === \"value-colon\";",
                    "}",
                    "",
                    "function isKeyInValuePairNode(node, parentNode) {",
                    "  if (!isKeyValuePairNode(parentNode)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const { groups } = parentNode;",
                    "  const index = groups.indexOf(node);",
                    "",
                    "  if (index === -1) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return isColonNode(groups[index + 1]);",
                    "}",
                    "",
                    "function isMediaAndSupportsKeywords(node) {",
                    "  return node.value && [\"not\", \"and\", \"or\"].includes(node.value.toLowerCase());",
                    "}",
                    "",
                    "function isColorAdjusterFuncNode(node) {",
                    "  if (node.type !== \"value-func\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  return colorAdjusterFunctions.has(node.value.toLowerCase());",
                    "}",
                    "",
                    "// TODO: only check `less` when we don't use `less` to parse `css`",
                    "function isLessParser(options) {",
                    "  return options.parser === \"css\" || options.parser === \"less\";",
                    "}",
                    "",
                    "function lastLineHasInlineComment(text) {",
                    "  return /\\/\\//.test(text.split(/[\\n\\r]/).pop());",
                    "}",
                    "",
                    "function stringifyNode(node) {",
                    "  if (node.groups) {",
                    "    const open = node.open && node.open.value ? node.open.value : \"\";",
                    "    const groups = node.groups.reduce(",
                    "      (previousValue, currentValue, index) =>",
                    "        previousValue +",
                    "        stringifyNode(currentValue) +",
                    "        (node.groups[0].type === \"comma_group\" &&",
                    "        index !== node.groups.length - 1",
                    "          ? \",\"",
                    "          : \"\"),",
                    "      \"\"",
                    "    );",
                    "    const close = node.close && node.close.value ? node.close.value : \"\";",
                    "",
                    "    return open + groups + close;",
                    "  }",
                    "",
                    "  const before = node.raws && node.raws.before ? node.raws.before : \"\";",
                    "  const quote = node.raws && node.raws.quote ? node.raws.quote : \"\";",
                    "  const atword = node.type === \"atword\" ? \"@\" : \"\";",
                    "  const value = node.value ? node.value : \"\";",
                    "  const unit = node.unit ? node.unit : \"\";",
                    "  const group = node.group ? stringifyNode(node.group) : \"\";",
                    "  const after = node.raws && node.raws.after ? node.raws.after : \"\";",
                    "",
                    "  return before + quote + atword + value + quote + unit + group + after;",
                    "}",
                    "",
                    "function isAtWordPlaceholderNode(node) {",
                    "  return (",
                    "    node &&",
                    "    node.type === \"value-atword\" &&",
                    "    node.value.startsWith(\"prettier-placeholder-\")",
                    "  );",
                    "}",
                    "",
                    "function isModuleRuleName(name) {",
                    "  return moduleRuleNames.has(name);",
                    "}",
                    "",
                    "function isConfigurationNode(node, parentNode) {",
                    "  if (",
                    "    !node.open ||",
                    "    node.open.value !== \"(\" ||",
                    "    !node.close ||",
                    "    node.close.value !== \")\" ||",
                    "    node.groups.some((group) => group.type !== \"value-comma_group\")",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "  if (parentNode.type === \"value-comma_group\") {",
                    "    const prevIdx = parentNode.groups.indexOf(node) - 1;",
                    "    const maybeWithNode = parentNode.groups[prevIdx];",
                    "    if (",
                    "      maybeWithNode &&",
                    "      maybeWithNode.type === \"value-word\" &&",
                    "      maybeWithNode.value === \"with\"",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function isParenGroupNode(node) {",
                    "  return (",
                    "    node.type === \"value-paren_group\" &&",
                    "    node.open &&",
                    "    node.open.value === \"(\" &&",
                    "    node.close &&",
                    "    node.close.value === \")\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  getAncestorCounter,",
                    "  getAncestorNode,",
                    "  getPropOfDeclNode,",
                    "  hasSCSSInterpolation,",
                    "  hasStringOrFunction,",
                    "  maybeToLowerCase,",
                    "  insideValueFunctionNode,",
                    "  insideICSSRuleNode,",
                    "  insideAtRuleNode,",
                    "  insideURLFunctionInImportAtRuleNode,",
                    "  isKeyframeAtRuleKeywords,",
                    "  isWideKeywords,",
                    "  isSCSS,",
                    "  isSCSSVariable,",
                    "  isLastNode,",
                    "  isLessParser,",
                    "  isSCSSControlDirectiveNode,",
                    "  isDetachedRulesetDeclarationNode,",
                    "  isRelationalOperatorNode,",
                    "  isEqualityOperatorNode,",
                    "  isMultiplicationNode,",
                    "  isDivisionNode,",
                    "  isAdditionNode,",
                    "  isSubtractionNode,",
                    "  isModuloNode,",
                    "  isMathOperatorNode,",
                    "  isEachKeywordNode,",
                    "  isForKeywordNode,",
                    "  isURLFunctionNode,",
                    "  isIfElseKeywordNode,",
                    "  hasComposesNode,",
                    "  hasParensAroundNode,",
                    "  hasEmptyRawBefore,",
                    "  isSCSSNestedPropertyNode,",
                    "  isDetachedRulesetCallNode,",
                    "  isTemplatePlaceholderNode,",
                    "  isTemplatePropNode,",
                    "  isPostcssSimpleVarNode,",
                    "  isKeyValuePairNode,",
                    "  isKeyValuePairInParenGroupNode,",
                    "  isKeyInValuePairNode,",
                    "  isSCSSMapItemNode,",
                    "  isInlineValueCommentNode,",
                    "  isHashNode,",
                    "  isLeftCurlyBraceNode,",
                    "  isRightCurlyBraceNode,",
                    "  isWordNode,",
                    "  isColonNode,",
                    "  isMediaAndSupportsKeywords,",
                    "  isColorAdjusterFuncNode,",
                    "  lastLineHasInlineComment,",
                    "  stringifyNode,",
                    "  isAtWordPlaceholderNode,",
                    "  isModuleRuleName,",
                    "  isConfigurationNode,",
                    "  isParenGroupNode,",
                    "};"
                ]
            }
        },
        "language-graphql": {
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-graphql.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/GraphQL.json\"), () => ({",
                    "    since: \"1.5.0\",",
                    "    parsers: [\"graphql\"],",
                    "    vscodeLanguageIds: [\"graphql\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  graphql: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  if (typeof node.start === \"number\") {",
                    "    return node.start;",
                    "  }",
                    "  return node.loc && node.loc.start;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  if (typeof node.end === \"number\") {",
                    "    return node.end;",
                    "  }",
                    "  return node.loc && node.loc.end;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "};"
                ]
            },
            "parser-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const tryCombinations = require(\"../utils/try-combinations.js\");",
                    "const { hasPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "function parseComments(ast) {",
                    "  const comments = [];",
                    "  const { startToken } = ast.loc;",
                    "  let { next } = startToken;",
                    "  while (next.kind !== \"<EOF>\") {",
                    "    if (next.kind === \"Comment\") {",
                    "      Object.assign(next, {",
                    "        // The Comment token's column starts _after_ the `#`,",
                    "        // but we need to make sure the node captures the `#`",
                    "        column: next.column - 1,",
                    "      });",
                    "      comments.push(next);",
                    "    }",
                    "    next = next.next;",
                    "  }",
                    "",
                    "  return comments;",
                    "}",
                    "",
                    "function removeTokens(node) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.startToken;",
                    "    delete node.endToken;",
                    "    delete node.prev;",
                    "    delete node.next;",
                    "    for (const key in node) {",
                    "      removeTokens(node[key]);",
                    "    }",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "const parseOptions = {",
                    "  allowLegacySDLImplementsInterfaces: false,",
                    "  experimentalFragmentVariables: true,",
                    "};",
                    "",
                    "function createParseError(error) {",
                    "  const { GraphQLError } = require(\"graphql/error/GraphQLError\");",
                    "  if (error instanceof GraphQLError) {",
                    "    const {",
                    "      message,",
                    "      locations: [start],",
                    "    } = error;",
                    "    return createError(message, { start });",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  return error;",
                    "}",
                    "",
                    "function parse(text /*, parsers, opts*/) {",
                    "  // Inline the require to avoid loading all the JS if we don't use it",
                    "  const { parse } = require(\"graphql/language/parser\");",
                    "  const { result: ast, error } = tryCombinations(",
                    "    () => parse(text, { ...parseOptions }),",
                    "    () =>",
                    "      parse(text, { ...parseOptions, allowLegacySDLImplementsInterfaces: true })",
                    "  );",
                    "",
                    "  if (!ast) {",
                    "    throw createParseError(error);",
                    "  }",
                    "",
                    "  ast.comments = parseComments(ast);",
                    "  removeTokens(ast);",
                    "  return ast;",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    graphql: {",
                    "      parse,",
                    "      astFormat: \"graphql\",",
                    "      hasPragma,",
                    "      locStart,",
                    "      locEnd,",
                    "    },",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  get graphql() {",
                    "    return require(\"./parser-graphql.js\").parsers.graphql;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(?:format|prettier)\\s*(?:\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"# @format\\n\\n\" + text;",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "printer-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { join, hardline, line, softline, group, indent, ifBreak },",
                    "} = require(\"../document/index.js\");",
                    "const { isNextLineEmpty, isNonEmptyArray } = require(\"../common/util.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof node === \"string\") {",
                    "    return node;",
                    "  }",
                    "",
                    "  switch (node.kind) {",
                    "    case \"Document\": {",
                    "      const parts = [];",
                    "      path.each((pathChild, index, definitions) => {",
                    "        parts.push(print());",
                    "        if (index !== definitions.length - 1) {",
                    "          parts.push(hardline);",
                    "          if (",
                    "            isNextLineEmpty(options.originalText, pathChild.getValue(), locEnd)",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }",
                    "      }, \"definitions\");",
                    "      return [...parts, hardline];",
                    "    }",
                    "    case \"OperationDefinition\": {",
                    "      const hasOperation = options.originalText[locStart(node)] !== \"{\";",
                    "      const hasName = Boolean(node.name);",
                    "      return [",
                    "        hasOperation ? node.operation : \"\",",
                    "        hasOperation && hasName ? [\" \", print(\"name\")] : \"\",",
                    "        hasOperation && !hasName && isNonEmptyArray(node.variableDefinitions)",
                    "          ? \" \"",
                    "          : \"\",",
                    "        isNonEmptyArray(node.variableDefinitions)",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  path.map(print, \"variableDefinitions\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.selectionSet ? (!hasOperation && !hasName ? \"\" : \" \") : \"\",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "    }",
                    "    case \"FragmentDefinition\": {",
                    "      return [",
                    "        \"fragment \",",
                    "        print(\"name\"),",
                    "        isNonEmptyArray(node.variableDefinitions)",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  path.map(print, \"variableDefinitions\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        \" on \",",
                    "        print(\"typeCondition\"),",
                    "        printDirectives(path, print, node),",
                    "        \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "    }",
                    "    case \"SelectionSet\": {",
                    "      return [",
                    "        \"{\",",
                    "        indent([",
                    "          hardline,",
                    "          join(",
                    "            hardline,",
                    "            path.call(",
                    "              (selectionsPath) => printSequence(selectionsPath, options, print),",
                    "              \"selections\"",
                    "            )",
                    "          ),",
                    "        ]),",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "    }",
                    "    case \"Field\": {",
                    "      return group([",
                    "        node.alias ? [print(\"alias\"), \": \"] : \"\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  path.call(",
                    "                    (argsPath) => printSequence(argsPath, options, print),",
                    "                    \"arguments\"",
                    "                  )",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.selectionSet ? \" \" : \"\",",
                    "        print(\"selectionSet\"),",
                    "      ]);",
                    "    }",
                    "    case \"Name\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"StringValue\": {",
                    "      if (node.block) {",
                    "        return [",
                    "          '\"\"\"',",
                    "          hardline,",
                    "          join(hardline, node.value.replace(/\"\"\"/g, \"\\\\$&\").split(\"\\n\")),",
                    "          hardline,",
                    "          '\"\"\"',",
                    "        ];",
                    "      }",
                    "      return [",
                    "        '\"',",
                    "        node.value.replace(/[\"\\\\]/g, \"\\\\$&\").replace(/\\n/g, \"\\\\n\"),",
                    "        '\"',",
                    "      ];",
                    "    }",
                    "    case \"IntValue\":",
                    "    case \"FloatValue\":",
                    "    case \"EnumValue\": {",
                    "      return node.value;",
                    "    }",
                    "    case \"BooleanValue\": {",
                    "      return node.value ? \"true\" : \"false\";",
                    "    }",
                    "    case \"NullValue\": {",
                    "      return \"null\";",
                    "    }",
                    "    case \"Variable\": {",
                    "      return [\"$\", print(\"name\")];",
                    "    }",
                    "    case \"ListValue\": {",
                    "      return group([",
                    "        \"[\",",
                    "        indent([",
                    "          softline,",
                    "          join([ifBreak(\"\", \", \"), softline], path.map(print, \"values\")),",
                    "        ]),",
                    "        softline,",
                    "        \"]\",",
                    "      ]);",
                    "    }",
                    "    case \"ObjectValue\": {",
                    "      return group([",
                    "        \"{\",",
                    "        options.bracketSpacing && node.fields.length > 0 ? \" \" : \"\",",
                    "        indent([",
                    "          softline,",
                    "          join([ifBreak(\"\", \", \"), softline], path.map(print, \"fields\")),",
                    "        ]),",
                    "        softline,",
                    "        ifBreak(",
                    "          \"\",",
                    "          options.bracketSpacing && node.fields.length > 0 ? \" \" : \"\"",
                    "        ),",
                    "        \"}\",",
                    "      ]);",
                    "    }",
                    "    case \"ObjectField\":",
                    "    case \"Argument\": {",
                    "      return [print(\"name\"), \": \", print(\"value\")];",
                    "    }",
                    "",
                    "    case \"Directive\": {",
                    "      return [",
                    "        \"@\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  path.call(",
                    "                    (argsPath) => printSequence(argsPath, options, print),",
                    "                    \"arguments\"",
                    "                  )",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"NamedType\": {",
                    "      return print(\"name\");",
                    "    }",
                    "",
                    "    case \"VariableDefinition\": {",
                    "      return [",
                    "        print(\"variable\"),",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        node.defaultValue ? [\" = \", print(\"defaultValue\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"ObjectTypeExtension\":",
                    "    case \"ObjectTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"ObjectTypeExtension\" ? \"extend \" : \"\",",
                    "        \"type \",",
                    "        print(\"name\"),",
                    "        node.interfaces.length > 0",
                    "          ? [\" implements \", ...printInterfaces(path, options, print)]",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.fields.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  path.call(",
                    "                    (fieldsPath) => printSequence(fieldsPath, options, print),",
                    "                    \"fields\"",
                    "                  )",
                    "                ),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"FieldDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  path.call(",
                    "                    (argsPath) => printSequence(argsPath, options, print),",
                    "                    \"arguments\"",
                    "                  )",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"DirectiveDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        \"directive \",",
                    "        \"@\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  path.call(",
                    "                    (argsPath) => printSequence(argsPath, options, print),",
                    "                    \"arguments\"",
                    "                  )",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        node.repeatable ? \" repeatable\" : \"\",",
                    "        \" on \",",
                    "        join(\" | \", path.map(print, \"locations\")),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"EnumTypeExtension\":",
                    "    case \"EnumTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"EnumTypeExtension\" ? \"extend \" : \"\",",
                    "        \"enum \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "",
                    "        node.values.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  path.call(",
                    "                    (valuesPath) => printSequence(valuesPath, options, print),",
                    "                    \"values\"",
                    "                  )",
                    "                ),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"EnumValueDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"InputValueDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? (node.description.block ? hardline : line) : \"\",",
                    "        print(\"name\"),",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        node.defaultValue ? [\" = \", print(\"defaultValue\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"InputObjectTypeExtension\":",
                    "    case \"InputObjectTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"InputObjectTypeExtension\" ? \"extend \" : \"\",",
                    "        \"input \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "        node.fields.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  path.call(",
                    "                    (fieldsPath) => printSequence(fieldsPath, options, print),",
                    "                    \"fields\"",
                    "                  )",
                    "                ),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"SchemaDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        \"schema\",",
                    "        printDirectives(path, print, node),",
                    "        \" {\",",
                    "        node.operationTypes.length > 0",
                    "          ? indent([",
                    "              hardline,",
                    "              join(",
                    "                hardline,",
                    "                path.call(",
                    "                  (opsPath) => printSequence(opsPath, options, print),",
                    "                  \"operationTypes\"",
                    "                )",
                    "              ),",
                    "            ])",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"OperationTypeDefinition\": {",
                    "      return [print(\"operation\"), \": \", print(\"type\")];",
                    "    }",
                    "",
                    "    case \"InterfaceTypeExtension\":",
                    "    case \"InterfaceTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"InterfaceTypeExtension\" ? \"extend \" : \"\",",
                    "        \"interface \",",
                    "        print(\"name\"),",
                    "        node.interfaces.length > 0",
                    "          ? [\" implements \", ...printInterfaces(path, options, print)]",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.fields.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  path.call(",
                    "                    (fieldsPath) => printSequence(fieldsPath, options, print),",
                    "                    \"fields\"",
                    "                  )",
                    "                ),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "    }",
                    "",
                    "    case \"FragmentSpread\": {",
                    "      return [\"...\", print(\"name\"), printDirectives(path, print, node)];",
                    "    }",
                    "",
                    "    case \"InlineFragment\": {",
                    "      return [",
                    "        \"...\",",
                    "        node.typeCondition ? [\" on \", print(\"typeCondition\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "        \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"UnionTypeExtension\":",
                    "    case \"UnionTypeDefinition\": {",
                    "      return group([",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        group([",
                    "          node.kind === \"UnionTypeExtension\" ? \"extend \" : \"\",",
                    "          \"union \",",
                    "          print(\"name\"),",
                    "          printDirectives(path, print, node),",
                    "          node.types.length > 0",
                    "            ? [",
                    "                \" =\",",
                    "                ifBreak(\"\", \" \"),",
                    "                indent([",
                    "                  ifBreak([line, \"  \"]),",
                    "                  join([line, \"| \"], path.map(print, \"types\")),",
                    "                ]),",
                    "              ]",
                    "            : \"\",",
                    "        ]),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"ScalarTypeExtension\":",
                    "    case \"ScalarTypeDefinition\": {",
                    "      return [",
                    "        print(\"description\"),",
                    "        node.description ? hardline : \"\",",
                    "        node.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\",",
                    "        \"scalar \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"NonNullType\": {",
                    "      return [print(\"type\"), \"!\"];",
                    "    }",
                    "",
                    "    case \"ListType\": {",
                    "      return [\"[\", print(\"type\"), \"]\"];",
                    "    }",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown graphql type: \" + JSON.stringify(node.kind));",
                    "  }",
                    "}",
                    "",
                    "function printDirectives(path, print, node) {",
                    "  if (node.directives.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const printed = join(line, path.map(print, \"directives\"));",
                    "",
                    "  if (",
                    "    node.kind === \"FragmentDefinition\" ||",
                    "    node.kind === \"OperationDefinition\"",
                    "  ) {",
                    "    return group([line, printed]);",
                    "  }",
                    "",
                    "  return [\" \", group(indent([softline, printed]))];",
                    "}",
                    "",
                    "function printSequence(sequencePath, options, print) {",
                    "  const count = sequencePath.getValue().length;",
                    "",
                    "  return sequencePath.map((path, i) => {",
                    "    const printed = print();",
                    "",
                    "    if (",
                    "      isNextLineEmpty(options.originalText, path.getValue(), locEnd) &&",
                    "      i < count - 1",
                    "    ) {",
                    "      return [printed, hardline];",
                    "    }",
                    "",
                    "    return printed;",
                    "  });",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return node.kind && node.kind !== \"Comment\";",
                    "}",
                    "",
                    "function printComment(commentPath) {",
                    "  const comment = commentPath.getValue();",
                    "  if (comment.kind === \"Comment\") {",
                    "    return \"#\" + comment.value.trimEnd();",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                    "}",
                    "",
                    "function printInterfaces(path, options, print) {",
                    "  const node = path.getNode();",
                    "  const parts = [];",
                    "  const { interfaces } = node;",
                    "  const printed = path.map((node) => print(node), \"interfaces\");",
                    "",
                    "  for (let index = 0; index < interfaces.length; index++) {",
                    "    const interfaceNode = interfaces[index];",
                    "    parts.push(printed[index]);",
                    "    const nextInterfaceNode = interfaces[index + 1];",
                    "    if (nextInterfaceNode) {",
                    "      const textBetween = options.originalText.slice(",
                    "        interfaceNode.loc.end,",
                    "        nextInterfaceNode.loc.start",
                    "      );",
                    "      const hasComment = textBetween.includes(\"#\");",
                    "      const separator = textBetween.replace(/#.*/g, \"\").trim();",
                    "",
                    "      parts.push(separator === \",\" ? \",\" : \" &\", hasComment ? line : \" \");",
                    "    }",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function clean(/*node, newNode , parent*/) {}",
                    "clean.ignoredProperties = new Set([\"loc\", \"comments\"]);",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const node = path.getValue();",
                    "  return (",
                    "    node &&",
                    "    Array.isArray(node.comments) &&",
                    "    node.comments.some((comment) => comment.value.trim() === \"prettier-ignore\")",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  insertPragma,",
                    "  printComment,",
                    "  canAttachComment,",
                    "};"
                ]
            }
        },
        "language-handlebars": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function clean(ast, newNode /*, parent*/) {",
                    "  // (Glimmer/HTML) ignore TextNode",
                    "  if (ast.type === \"TextNode\") {",
                    "    const trimmed = ast.chars.trim();",
                    "    if (!trimmed) {",
                    "      return null;",
                    "    }",
                    "    newNode.chars = trimmed.replace(/[\\t\\n\\f\\r ]+/g, \" \");",
                    "  }",
                    "",
                    "  // `class` is reformatted",
                    "  if (ast.type === \"AttrNode\" && ast.name.toLowerCase() === \"class\") {",
                    "    delete newNode.value;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = new Set([\"loc\", \"selfClosing\"]);",
                    "",
                    "module.exports = clean;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-glimmer.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/Handlebars.json\"), () => ({",
                    "    since: \"2.3.0\",",
                    "    parsers: [\"glimmer\"],",
                    "    vscodeLanguageIds: [\"handlebars\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  glimmer: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  return node.loc.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.loc.end.offset;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "parser-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { LinesAndColumns } = require(\"lines-and-columns\");",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "/* from the following template: `non-escaped mustache \\\\{{helper}}`",
                    " * glimmer parser will produce an AST missing a backslash",
                    " * so here we add it back",
                    " * */",
                    "function addBackslash(/* options*/) {",
                    "  return {",
                    "    name: \"addBackslash\",",
                    "    visitor: {",
                    "      TextNode(node) {",
                    "        node.chars = node.chars.replace(/\\\\/, \"\\\\\\\\\");",
                    "      },",
                    "    },",
                    "  };",
                    "}",
                    "",
                    "// Add `loc.{start,end}.offset`",
                    "function addOffset(text) {",
                    "  const lines = new LinesAndColumns(text);",
                    "  const calculateOffset = ({ line, column }) =>",
                    "    lines.indexForLocation({ line: line - 1, column });",
                    "  return (/* options*/) => ({",
                    "    name: \"addOffset\",",
                    "    visitor: {",
                    "      All(node) {",
                    "        const { start, end } = node.loc;",
                    "        start.offset = calculateOffset(start);",
                    "        end.offset = calculateOffset(end);",
                    "      },",
                    "    },",
                    "  });",
                    "}",
                    "",
                    "function parse(text) {",
                    "  const { preprocess: glimmer } = require(\"@glimmer/syntax\");",
                    "  let ast;",
                    "  try {",
                    "    ast = glimmer(text, {",
                    "      mode: \"codemod\",",
                    "      plugins: { ast: [addBackslash, addOffset(text)] },",
                    "    });",
                    "  } catch (error) {",
                    "    const location = getErrorLocation(error);",
                    "",
                    "    if (location) {",
                    "      throw createError(error.message, location);",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw error;",
                    "  }",
                    "",
                    "  return ast;",
                    "}",
                    "",
                    "function getErrorLocation(error) {",
                    "  const { location, hash } = error;",
                    "  if (location) {",
                    "    const { start, end } = location;",
                    "    if (typeof end.line !== \"number\") {",
                    "      return { start };",
                    "    }",
                    "    return location;",
                    "  }",
                    "",
                    "  if (hash) {",
                    "    const {",
                    "      loc: { last_line, last_column },",
                    "    } = hash;",
                    "    return { start: { line: last_line, column: last_column + 1 } };",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    glimmer: {",
                    "      parse,",
                    "      astFormat: \"glimmer\",",
                    "      locStart,",
                    "      locEnd,",
                    "    },",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  get glimmer() {",
                    "    return require(\"./parser-glimmer.js\").parsers.glimmer;",
                    "  },",
                    "};"
                ]
            },
            "printer-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: {",
                    "    dedent,",
                    "    fill,",
                    "    group,",
                    "    hardline,",
                    "    ifBreak,",
                    "    indent,",
                    "    join,",
                    "    line,",
                    "    softline,",
                    "  },",
                    "  utils: { getDocParts, replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const { getPreferredQuote, isNonEmptyArray } = require(\"../common/util.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const {",
                    "  getNextNode,",
                    "  getPreviousNode,",
                    "  hasPrettierIgnore,",
                    "  isLastNodeOfSiblings,",
                    "  isNextNodeOfSomeType,",
                    "  isNodeOfSomeType,",
                    "  isParentOfSomeType,",
                    "  isPreviousNodeOfSomeType,",
                    "  isVoid,",
                    "  isWhitespaceNode,",
                    "} = require(\"./utils.js\");",
                    "",
                    "const NEWLINES_TO_PRESERVE_MAX = 2;",
                    "",
                    "// Formatter based on @glimmerjs/syntax's built-in test formatter:",
                    "// https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts",
                    "",
                    "function print(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  /* istanbul ignore if*/",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (hasPrettierIgnore(path)) {",
                    "    return options.originalText.slice(locStart(node), locEnd(node));",
                    "  }",
                    "",
                    "  const favoriteQuote = options.singleQuote ? \"'\" : '\"';",
                    "",
                    "  switch (node.type) {",
                    "    case \"Block\":",
                    "    case \"Program\":",
                    "    case \"Template\": {",
                    "      return group(path.map(print, \"body\"));",
                    "    }",
                    "",
                    "    case \"ElementNode\": {",
                    "      const startingTag = group(printStartingTag(path, print));",
                    "",
                    "      const escapeNextElementNode =",
                    "        options.htmlWhitespaceSensitivity === \"ignore\" &&",
                    "        isNextNodeOfSomeType(path, [\"ElementNode\"])",
                    "          ? softline",
                    "          : \"\";",
                    "",
                    "      if (isVoid(node)) {",
                    "        return [startingTag, escapeNextElementNode];",
                    "      }",
                    "",
                    "      const endingTag = [\"</\", node.tag, \">\"];",
                    "",
                    "      if (node.children.length === 0) {",
                    "        return [startingTag, indent(endingTag), escapeNextElementNode];",
                    "      }",
                    "",
                    "      if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "        return [",
                    "          startingTag,",
                    "          indent(printChildren(path, options, print)),",
                    "          hardline,",
                    "          indent(endingTag),",
                    "          escapeNextElementNode,",
                    "        ];",
                    "      }",
                    "",
                    "      return [",
                    "        startingTag,",
                    "        indent(group(printChildren(path, options, print))),",
                    "        indent(endingTag),",
                    "        escapeNextElementNode,",
                    "      ];",
                    "    }",
                    "",
                    "    case \"BlockStatement\": {",
                    "      const pp = path.getParentNode(1);",
                    "",
                    "      const isElseIf =",
                    "        pp &&",
                    "        pp.inverse &&",
                    "        pp.inverse.body.length === 1 &&",
                    "        pp.inverse.body[0] === node &&",
                    "        pp.inverse.body[0].path.parts[0] === \"if\";",
                    "",
                    "      if (isElseIf) {",
                    "        return [",
                    "          printElseIfBlock(path, print),",
                    "          printProgram(path, print, options),",
                    "          printInverse(path, print, options),",
                    "        ];",
                    "      }",
                    "",
                    "      return [",
                    "        printOpenBlock(path, print),",
                    "        group([",
                    "          printProgram(path, print, options),",
                    "          printInverse(path, print, options),",
                    "          printCloseBlock(path, print, options),",
                    "        ]),",
                    "      ];",
                    "    }",
                    "",
                    "    case \"ElementModifierStatement\": {",
                    "      return group([\"{{\", printPathAndParams(path, print), \"}}\"]);",
                    "    }",
                    "",
                    "    case \"MustacheStatement\": {",
                    "      return group([",
                    "        printOpeningMustache(node),",
                    "        printPathAndParams(path, print),",
                    "        printClosingMustache(node),",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"SubExpression\": {",
                    "      return group([",
                    "        \"(\",",
                    "        printSubExpressionPathAndParams(path, print),",
                    "        softline,",
                    "        \")\",",
                    "      ]);",
                    "    }",
                    "    case \"AttrNode\": {",
                    "      const isText = node.value.type === \"TextNode\";",
                    "      const isEmptyText = isText && node.value.chars === \"\";",
                    "",
                    "      // If the text is empty and the value's loc start and end offsets are the",
                    "      // same, there is no value for this AttrNode and it should be printed",
                    "      // without the `=\"\"`. Example: `<img data-test>` -> `<img data-test>`",
                    "      if (isEmptyText && locStart(node.value) === locEnd(node.value)) {",
                    "        return node.name;",
                    "      }",
                    "",
                    "      // Let's assume quotes inside the content of text nodes are already",
                    "      // properly escaped with entities, otherwise the parse wouldn't have parsed them.",
                    "      const quote = isText",
                    "        ? getPreferredQuote(node.value.chars, favoriteQuote).quote",
                    "        : node.value.type === \"ConcatStatement\"",
                    "        ? getPreferredQuote(",
                    "            node.value.parts",
                    "              .filter((part) => part.type === \"TextNode\")",
                    "              .map((part) => part.chars)",
                    "              .join(\"\"),",
                    "            favoriteQuote",
                    "          ).quote",
                    "        : \"\";",
                    "",
                    "      const valueDoc = print(\"value\");",
                    "",
                    "      return [",
                    "        node.name,",
                    "        \"=\",",
                    "        quote,",
                    "        node.name === \"class\" && quote ? group(indent(valueDoc)) : valueDoc,",
                    "        quote,",
                    "      ];",
                    "    }",
                    "",
                    "    case \"ConcatStatement\": {",
                    "      return path.map(print, \"parts\");",
                    "    }",
                    "",
                    "    case \"Hash\": {",
                    "      return join(line, path.map(print, \"pairs\"));",
                    "    }",
                    "    case \"HashPair\": {",
                    "      return [node.key, \"=\", print(\"value\")];",
                    "    }",
                    "    case \"TextNode\": {",
                    "      /* if `{{my-component}}` (or any text containing \"{{\")",
                    "       * makes it to the TextNode, it means it was escaped,",
                    "       * so let's print it escaped, ie.; `\\{{my-component}}` */",
                    "      let text = node.chars.replace(/{{/g, \"\\\\{{\");",
                    "",
                    "      const attrName = getCurrentAttributeName(path);",
                    "",
                    "      if (attrName) {",
                    "        // TODO: format style and srcset attributes",
                    "        if (attrName === \"class\") {",
                    "          const formattedClasses = text.trim().split(/\\s+/).join(\" \");",
                    "",
                    "          let leadingSpace = false;",
                    "          let trailingSpace = false;",
                    "",
                    "          if (isParentOfSomeType(path, [\"ConcatStatement\"])) {",
                    "            if (",
                    "              isPreviousNodeOfSomeType(path, [\"MustacheStatement\"]) &&",
                    "              /^\\s/.test(text)",
                    "            ) {",
                    "              leadingSpace = true;",
                    "            }",
                    "            if (",
                    "              isNextNodeOfSomeType(path, [\"MustacheStatement\"]) &&",
                    "              /\\s$/.test(text) &&",
                    "              formattedClasses !== \"\"",
                    "            ) {",
                    "              trailingSpace = true;",
                    "            }",
                    "          }",
                    "",
                    "          return [",
                    "            leadingSpace ? line : \"\",",
                    "            formattedClasses,",
                    "            trailingSpace ? line : \"\",",
                    "          ];",
                    "        }",
                    "",
                    "        return replaceTextEndOfLine(text);",
                    "      }",
                    "",
                    "      const whitespacesOnlyRE = /^[\\t\\n\\f\\r ]*$/;",
                    "      const isWhitespaceOnly = whitespacesOnlyRE.test(text);",
                    "      const isFirstElement = !getPreviousNode(path);",
                    "      const isLastElement = !getNextNode(path);",
                    "",
                    "      if (options.htmlWhitespaceSensitivity !== \"ignore\") {",
                    "        // https://infra.spec.whatwg.org/#ascii-whitespace",
                    "        const leadingWhitespacesRE = /^[\\t\\n\\f\\r ]*/;",
                    "        const trailingWhitespacesRE = /[\\t\\n\\f\\r ]*$/;",
                    "",
                    "        // let's remove the file's final newline",
                    "        // https://github.com/ember-cli/ember-new-output/blob/1a04c67ddd02ccb35e0ff41bb5cbce34b31173ef/.editorconfig#L16",
                    "        const shouldTrimTrailingNewlines =",
                    "          isLastElement && isParentOfSomeType(path, [\"Template\"]);",
                    "        const shouldTrimLeadingNewlines =",
                    "          isFirstElement && isParentOfSomeType(path, [\"Template\"]);",
                    "",
                    "        if (isWhitespaceOnly) {",
                    "          if (shouldTrimLeadingNewlines || shouldTrimTrailingNewlines) {",
                    "            return \"\";",
                    "          }",
                    "",
                    "          let breaks = [line];",
                    "",
                    "          const newlines = countNewLines(text);",
                    "          if (newlines) {",
                    "            breaks = generateHardlines(newlines);",
                    "          }",
                    "",
                    "          if (isLastNodeOfSiblings(path)) {",
                    "            breaks = breaks.map((newline) => dedent(newline));",
                    "          }",
                    "",
                    "          return breaks;",
                    "        }",
                    "",
                    "        const [lead] = text.match(leadingWhitespacesRE);",
                    "        const [tail] = text.match(trailingWhitespacesRE);",
                    "",
                    "        let leadBreaks = [];",
                    "        if (lead) {",
                    "          leadBreaks = [line];",
                    "",
                    "          const leadingNewlines = countNewLines(lead);",
                    "          if (leadingNewlines) {",
                    "            leadBreaks = generateHardlines(leadingNewlines);",
                    "          }",
                    "",
                    "          text = text.replace(leadingWhitespacesRE, \"\");",
                    "        }",
                    "",
                    "        let trailBreaks = [];",
                    "        if (tail) {",
                    "          if (!shouldTrimTrailingNewlines) {",
                    "            trailBreaks = [line];",
                    "",
                    "            const trailingNewlines = countNewLines(tail);",
                    "            if (trailingNewlines) {",
                    "              trailBreaks = generateHardlines(trailingNewlines);",
                    "            }",
                    "",
                    "            if (isLastNodeOfSiblings(path)) {",
                    "              trailBreaks = trailBreaks.map((hardline) => dedent(hardline));",
                    "            }",
                    "          }",
                    "",
                    "          text = text.replace(trailingWhitespacesRE, \"\");",
                    "        }",
                    "",
                    "        return [...leadBreaks, fill(getTextValueParts(text)), ...trailBreaks];",
                    "      }",
                    "",
                    "      const lineBreaksCount = countNewLines(text);",
                    "",
                    "      let leadingLineBreaksCount = countLeadingNewLines(text);",
                    "      let trailingLineBreaksCount = countTrailingNewLines(text);",
                    "",
                    "      if (",
                    "        (isFirstElement || isLastElement) &&",
                    "        isWhitespaceOnly &&",
                    "        isParentOfSomeType(path, [\"Block\", \"ElementNode\", \"Template\"])",
                    "      ) {",
                    "        return \"\";",
                    "      }",
                    "",
                    "      if (isWhitespaceOnly && lineBreaksCount) {",
                    "        leadingLineBreaksCount = Math.min(",
                    "          lineBreaksCount,",
                    "          NEWLINES_TO_PRESERVE_MAX",
                    "        );",
                    "        trailingLineBreaksCount = 0;",
                    "      } else {",
                    "        if (isNextNodeOfSomeType(path, [\"BlockStatement\", \"ElementNode\"])) {",
                    "          trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);",
                    "        }",
                    "",
                    "        if (isPreviousNodeOfSomeType(path, [\"BlockStatement\", \"ElementNode\"])) {",
                    "          leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);",
                    "        }",
                    "      }",
                    "",
                    "      let leadingSpace = \"\";",
                    "      let trailingSpace = \"\";",
                    "",
                    "      if (",
                    "        trailingLineBreaksCount === 0 &&",
                    "        isNextNodeOfSomeType(path, [\"MustacheStatement\"])",
                    "      ) {",
                    "        trailingSpace = \" \";",
                    "      }",
                    "",
                    "      if (",
                    "        leadingLineBreaksCount === 0 &&",
                    "        isPreviousNodeOfSomeType(path, [\"MustacheStatement\"])",
                    "      ) {",
                    "        leadingSpace = \" \";",
                    "      }",
                    "",
                    "      if (isFirstElement) {",
                    "        leadingLineBreaksCount = 0;",
                    "        leadingSpace = \"\";",
                    "      }",
                    "",
                    "      if (isLastElement) {",
                    "        trailingLineBreaksCount = 0;",
                    "        trailingSpace = \"\";",
                    "      }",
                    "",
                    "      text = text",
                    "        .replace(/^[\\t\\n\\f\\r ]+/g, leadingSpace)",
                    "        .replace(/[\\t\\n\\f\\r ]+$/, trailingSpace);",
                    "",
                    "      return [",
                    "        ...generateHardlines(leadingLineBreaksCount),",
                    "        fill(getTextValueParts(text)),",
                    "        ...generateHardlines(trailingLineBreaksCount),",
                    "      ];",
                    "    }",
                    "    case \"MustacheCommentStatement\": {",
                    "      const start = locStart(node);",
                    "      const end = locEnd(node);",
                    "      // Starts with `{{~`",
                    "      const isLeftWhiteSpaceSensitive =",
                    "        options.originalText.charAt(start + 2) === \"~\";",
                    "      // Ends with `{{~`",
                    "      const isRightWhitespaceSensitive =",
                    "        options.originalText.charAt(end - 3) === \"~\";",
                    "",
                    "      const dashes = node.value.includes(\"}}\") ? \"--\" : \"\";",
                    "      return [",
                    "        \"{{\",",
                    "        isLeftWhiteSpaceSensitive ? \"~\" : \"\",",
                    "        \"!\",",
                    "        dashes,",
                    "        node.value,",
                    "        dashes,",
                    "        isRightWhitespaceSensitive ? \"~\" : \"\",",
                    "        \"}}\",",
                    "      ];",
                    "    }",
                    "    case \"PathExpression\": {",
                    "      return node.original;",
                    "    }",
                    "    case \"BooleanLiteral\": {",
                    "      return String(node.value);",
                    "    }",
                    "    case \"CommentStatement\": {",
                    "      return [\"<!--\", node.value, \"-->\"];",
                    "    }",
                    "    case \"StringLiteral\": {",
                    "      if (needsOppositeQuote(path)) {",
                    "        const printFavoriteQuote = !options.singleQuote ? \"'\" : '\"';",
                    "        return printStringLiteral(node.value, printFavoriteQuote);",
                    "      }",
                    "      return printStringLiteral(node.value, favoriteQuote);",
                    "    }",
                    "    case \"NumberLiteral\": {",
                    "      return String(node.value);",
                    "    }",
                    "    case \"UndefinedLiteral\": {",
                    "      return \"undefined\";",
                    "    }",
                    "    case \"NullLiteral\": {",
                    "      return \"null\";",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    default:",
                    "      throw new Error(\"unknown glimmer type: \" + JSON.stringify(node.type));",
                    "  }",
                    "}",
                    "",
                    "/* ElementNode print helpers */",
                    "",
                    "function sortByLoc(a, b) {",
                    "  return locStart(a) - locStart(b);",
                    "}",
                    "",
                    "function printStartingTag(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  const types = [\"attributes\", \"modifiers\", \"comments\"].filter((property) =>",
                    "    isNonEmptyArray(node[property])",
                    "  );",
                    "  const attributes = types.flatMap((type) => node[type]).sort(sortByLoc);",
                    "",
                    "  for (const attributeType of types) {",
                    "    path.each((attributePath) => {",
                    "      const index = attributes.indexOf(attributePath.getValue());",
                    "      attributes.splice(index, 1, [line, print()]);",
                    "    }, attributeType);",
                    "  }",
                    "",
                    "  if (isNonEmptyArray(node.blockParams)) {",
                    "    attributes.push(line, printBlockParams(node));",
                    "  }",
                    "",
                    "  return [\"<\", node.tag, indent(attributes), printStartingTagEndMarker(node)];",
                    "}",
                    "",
                    "function printChildren(path, options, print) {",
                    "  const node = path.getValue();",
                    "  const isEmpty = node.children.every((node) => isWhitespaceNode(node));",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\" && isEmpty) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return path.map((childPath, childIndex) => {",
                    "    const printedChild = print();",
                    "",
                    "    if (childIndex === 0 && options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "      return [softline, printedChild];",
                    "    }",
                    "",
                    "    return printedChild;",
                    "  }, \"children\");",
                    "}",
                    "",
                    "function printStartingTagEndMarker(node) {",
                    "  if (isVoid(node)) {",
                    "    return ifBreak([softline, \"/>\"], [\" />\", softline]);",
                    "  }",
                    "",
                    "  return ifBreak([softline, \">\"], \">\");",
                    "}",
                    "",
                    "/* MustacheStatement print helpers */",
                    "",
                    "function printOpeningMustache(node) {",
                    "  const mustache = node.escaped === false ? \"{{{\" : \"{{\";",
                    "  const strip = node.strip && node.strip.open ? \"~\" : \"\";",
                    "  return [mustache, strip];",
                    "}",
                    "",
                    "function printClosingMustache(node) {",
                    "  const mustache = node.escaped === false ? \"}}}\" : \"}}\";",
                    "  const strip = node.strip && node.strip.close ? \"~\" : \"\";",
                    "  return [strip, mustache];",
                    "}",
                    "",
                    "/* BlockStatement print helpers */",
                    "",
                    "function printOpeningBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.openStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip, \"#\"];",
                    "}",
                    "",
                    "function printOpeningBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.openStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printClosingBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.closeStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip, \"/\"];",
                    "}",
                    "",
                    "function printClosingBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.closeStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printInverseBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.inverseStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip];",
                    "}",
                    "",
                    "function printInverseBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.inverseStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printOpenBlock(path, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  const openingMustache = printOpeningBlockOpeningMustache(node);",
                    "  const closingMustache = printOpeningBlockClosingMustache(node);",
                    "",
                    "  const attributes = [printPath(path, print)];",
                    "",
                    "  const params = printParams(path, print);",
                    "  if (params) {",
                    "    attributes.push(line, params);",
                    "  }",
                    "",
                    "  if (isNonEmptyArray(node.program.blockParams)) {",
                    "    const block = printBlockParams(node.program);",
                    "    attributes.push(line, block);",
                    "  }",
                    "",
                    "  return group([",
                    "    openingMustache,",
                    "    indent(attributes),",
                    "    softline,",
                    "    closingMustache,",
                    "  ]);",
                    "}",
                    "",
                    "function printElseBlock(node, options) {",
                    "  return [",
                    "    options.htmlWhitespaceSensitivity === \"ignore\" ? hardline : \"\",",
                    "    printInverseBlockOpeningMustache(node),",
                    "    \"else\",",
                    "    printInverseBlockClosingMustache(node),",
                    "  ];",
                    "}",
                    "",
                    "function printElseIfBlock(path, print) {",
                    "  const parentNode = path.getParentNode(1);",
                    "",
                    "  return [",
                    "    printInverseBlockOpeningMustache(parentNode),",
                    "    \"else if \",",
                    "    printParams(path, print),",
                    "    printInverseBlockClosingMustache(parentNode),",
                    "  ];",
                    "}",
                    "",
                    "function printCloseBlock(path, print, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "    const escape = blockStatementHasOnlyWhitespaceInProgram(node)",
                    "      ? softline",
                    "      : hardline;",
                    "",
                    "    return [",
                    "      escape,",
                    "      printClosingBlockOpeningMustache(node),",
                    "      print(\"path\"),",
                    "      printClosingBlockClosingMustache(node),",
                    "    ];",
                    "  }",
                    "",
                    "  return [",
                    "    printClosingBlockOpeningMustache(node),",
                    "    print(\"path\"),",
                    "    printClosingBlockClosingMustache(node),",
                    "  ];",
                    "}",
                    "",
                    "function blockStatementHasOnlyWhitespaceInProgram(node) {",
                    "  return (",
                    "    isNodeOfSomeType(node, [\"BlockStatement\"]) &&",
                    "    node.program.body.every((node) => isWhitespaceNode(node))",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElseIf(node) {",
                    "  return (",
                    "    blockStatementHasElse(node) &&",
                    "    node.inverse.body.length === 1 &&",
                    "    isNodeOfSomeType(node.inverse.body[0], [\"BlockStatement\"]) &&",
                    "    node.inverse.body[0].path.parts[0] === \"if\"",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElse(node) {",
                    "  return isNodeOfSomeType(node, [\"BlockStatement\"]) && node.inverse;",
                    "}",
                    "",
                    "function printProgram(path, print, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (blockStatementHasOnlyWhitespaceInProgram(node)) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const program = print(\"program\");",
                    "",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "    return indent([hardline, program]);",
                    "  }",
                    "",
                    "  return indent(program);",
                    "}",
                    "",
                    "function printInverse(path, print, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  const inverse = print(\"inverse\");",
                    "  const printed =",
                    "    options.htmlWhitespaceSensitivity === \"ignore\"",
                    "      ? [hardline, inverse]",
                    "      : inverse;",
                    "",
                    "  if (blockStatementHasElseIf(node)) {",
                    "    return printed;",
                    "  }",
                    "",
                    "  if (blockStatementHasElse(node)) {",
                    "    return [printElseBlock(node, options), indent(printed)];",
                    "  }",
                    "",
                    "  return \"\";",
                    "}",
                    "",
                    "/* TextNode print helpers */",
                    "",
                    "function getTextValueParts(value) {",
                    "  return getDocParts(join(line, splitByHtmlWhitespace(value)));",
                    "}",
                    "",
                    "function splitByHtmlWhitespace(string) {",
                    "  return string.split(/[\\t\\n\\f\\r ]+/);",
                    "}",
                    "",
                    "function getCurrentAttributeName(path) {",
                    "  for (let depth = 0; depth < 2; depth++) {",
                    "    const parentNode = path.getParentNode(depth);",
                    "    if (parentNode && parentNode.type === \"AttrNode\") {",
                    "      return parentNode.name.toLowerCase();",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function countNewLines(string) {",
                    "  /* istanbul ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  return string.split(\"\\n\").length - 1;",
                    "}",
                    "",
                    "function countLeadingNewLines(string) {",
                    "  /* istanbul ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/^([^\\S\\n\\r]*[\\n\\r])+/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function countTrailingNewLines(string) {",
                    "  /* istanbul ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/([\\n\\r][^\\S\\n\\r]*)+$/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function generateHardlines(number = 0) {",
                    "  return Array.from({",
                    "    length: Math.min(number, NEWLINES_TO_PRESERVE_MAX),",
                    "  }).fill(hardline);",
                    "}",
                    "",
                    "/* StringLiteral print helpers */",
                    "",
                    "/** @typedef {import(\"../common/util\").Quote} Quote */",
                    "",
                    "/**",
                    " * Prints a string literal with the correct surrounding quotes based on",
                    " * `options.singleQuote` and the number of escaped quotes contained in",
                    " * the string literal. This function is the glimmer equivalent of `printString`",
                    " * in `common/util`, but has differences because of the way escaped characters",
                    " * are treated in hbs string literals.",
                    " * @param {string} stringLiteral - the string literal value",
                    " * @param {Quote} favoriteQuote - the user's preferred quote: `'` or `\"`",
                    " */",
                    "function printStringLiteral(stringLiteral, favoriteQuote) {",
                    "  const { quote, regex } = getPreferredQuote(stringLiteral, favoriteQuote);",
                    "  return [quote, stringLiteral.replace(regex, `\\\\${quote}`), quote];",
                    "}",
                    "",
                    "function needsOppositeQuote(path) {",
                    "  let index = 0;",
                    "  let parentNode = path.getParentNode(index);",
                    "  while (parentNode && isNodeOfSomeType(parentNode, [\"SubExpression\"])) {",
                    "    index++;",
                    "    parentNode = path.getParentNode(index);",
                    "  }",
                    "  if (",
                    "    parentNode &&",
                    "    isNodeOfSomeType(path.getParentNode(index + 1), [\"ConcatStatement\"]) &&",
                    "    isNodeOfSomeType(path.getParentNode(index + 2), [\"AttrNode\"])",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "/* SubExpression print helpers */",
                    "",
                    "function printSubExpressionPathAndParams(path, print) {",
                    "  const p = printPath(path, print);",
                    "  const params = printParams(path, print);",
                    "",
                    "  if (!params) {",
                    "    return p;",
                    "  }",
                    "",
                    "  return indent([p, line, group(params)]);",
                    "}",
                    "",
                    "/* misc. print helpers */",
                    "",
                    "function printPathAndParams(path, print) {",
                    "  const p = printPath(path, print);",
                    "  const params = printParams(path, print);",
                    "",
                    "  if (!params) {",
                    "    return p;",
                    "  }",
                    "",
                    "  return [indent([p, line, params]), softline];",
                    "}",
                    "",
                    "function printPath(path, print) {",
                    "  return print(\"path\");",
                    "}",
                    "",
                    "function printParams(path, print) {",
                    "  const node = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  if (node.params.length > 0) {",
                    "    const params = path.map(print, \"params\");",
                    "    parts.push(...params);",
                    "  }",
                    "",
                    "  if (node.hash && node.hash.pairs.length > 0) {",
                    "    const hash = print(\"hash\");",
                    "    parts.push(hash);",
                    "  }",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return join(line, parts);",
                    "}",
                    "",
                    "function printBlockParams(node) {",
                    "  return [\"as |\", node.blockParams.join(\" \"), \"|\"];",
                    "}",
                    "",
                    "module.exports = {",
                    "  print,",
                    "  massageAstNode: clean,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const htmlVoidElements = require(\"html-void-elements\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "",
                    "function isLastNodeOfSiblings(path) {",
                    "  const node = path.getValue();",
                    "  const parentNode = path.getParentNode(0);",
                    "",
                    "  if (",
                    "    isParentOfSomeType(path, [\"ElementNode\"]) &&",
                    "    getLast(parentNode.children) === node",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    isParentOfSomeType(path, [\"Block\"]) &&",
                    "    getLast(parentNode.body) === node",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isUppercase(string) {",
                    "  return string.toUpperCase() === string;",
                    "}",
                    "",
                    "function isGlimmerComponent(node) {",
                    "  return (",
                    "    isNodeOfSomeType(node, [\"ElementNode\"]) &&",
                    "    typeof node.tag === \"string\" &&",
                    "    node.tag[0] !== \":\" &&",
                    "    (isUppercase(node.tag[0]) || node.tag.includes(\".\"))",
                    "  );",
                    "}",
                    "",
                    "const voidTags = new Set(htmlVoidElements);",
                    "function isVoid(node) {",
                    "  return (",
                    "    (isGlimmerComponent(node) &&",
                    "      node.children.every((node) => isWhitespaceNode(node))) ||",
                    "    voidTags.has(node.tag)",
                    "  );",
                    "}",
                    "",
                    "function isWhitespaceNode(node) {",
                    "  return isNodeOfSomeType(node, [\"TextNode\"]) && !/\\S/.test(node.chars);",
                    "}",
                    "",
                    "function isNodeOfSomeType(node, types) {",
                    "  return node && types.includes(node.type);",
                    "}",
                    "",
                    "function isParentOfSomeType(path, types) {",
                    "  const parentNode = path.getParentNode(0);",
                    "  return isNodeOfSomeType(parentNode, types);",
                    "}",
                    "",
                    "function isPreviousNodeOfSomeType(path, types) {",
                    "  const previousNode = getPreviousNode(path);",
                    "  return isNodeOfSomeType(previousNode, types);",
                    "}",
                    "",
                    "function isNextNodeOfSomeType(path, types) {",
                    "  const nextNode = getNextNode(path);",
                    "  return isNodeOfSomeType(nextNode, types);",
                    "}",
                    "",
                    "function getSiblingNode(path, offset) {",
                    "  const node = path.getValue();",
                    "  const parentNode = path.getParentNode(0) || {};",
                    "  const children =",
                    "    parentNode.children || parentNode.body || parentNode.parts || [];",
                    "  const index = children.indexOf(node);",
                    "  return index !== -1 && children[index + offset];",
                    "}",
                    "",
                    "function getPreviousNode(path, lookBack = 1) {",
                    "  return getSiblingNode(path, -lookBack);",
                    "}",
                    "",
                    "function getNextNode(path) {",
                    "  return getSiblingNode(path, 1);",
                    "}",
                    "",
                    "function isPrettierIgnoreNode(node) {",
                    "  return (",
                    "    isNodeOfSomeType(node, [\"MustacheCommentStatement\"]) &&",
                    "    typeof node.value === \"string\" &&",
                    "    node.value.trim() === \"prettier-ignore\"",
                    "  );",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const node = path.getValue();",
                    "  const previousPreviousNode = getPreviousNode(path, 2);",
                    "  return (",
                    "    isPrettierIgnoreNode(node) || isPrettierIgnoreNode(previousPreviousNode)",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  getNextNode,",
                    "  getPreviousNode,",
                    "  hasPrettierIgnore,",
                    "  isLastNodeOfSiblings,",
                    "  isNextNodeOfSomeType,",
                    "  isNodeOfSomeType,",
                    "  isParentOfSomeType,",
                    "  isPreviousNodeOfSomeType,",
                    "  isVoid,",
                    "  isWhitespaceNode,",
                    "};"
                ]
            }
        },
        "language-html": {
            "ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isNonEmptyArray } = require(\"../common/util.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "",
                    "const NODES_KEYS = {",
                    "  attrs: true,",
                    "  children: true,",
                    "};",
                    "",
                    "// TODO: typechecking is problematic for this class because of this issue:",
                    "// https://github.com/microsoft/TypeScript/issues/26811",
                    "",
                    "class Node {",
                    "  constructor(props = {}) {",
                    "    for (const [key, value] of Object.entries(props)) {",
                    "      if (key in NODES_KEYS) {",
                    "        this._setNodes(key, value);",
                    "      } else {",
                    "        this[key] = value;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  _setNodes(key, nodes) {",
                    "    if (nodes !== this[key]) {",
                    "      this[key] = cloneAndUpdateNodes(nodes, this);",
                    "      if (key === \"attrs\") {",
                    "        setNonEnumerableProperty(",
                    "          this,",
                    "          \"attrMap\",",
                    "          Object.fromEntries(",
                    "            this[key].map((attr) => [attr.fullName, attr.value])",
                    "          )",
                    "        );",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  map(fn) {",
                    "    /** @type{any} */",
                    "    let newNode = null;",
                    "",
                    "    for (const NODES_KEY in NODES_KEYS) {",
                    "      const nodes = this[NODES_KEY];",
                    "      if (nodes) {",
                    "        const mappedNodes = mapNodesIfChanged(nodes, (node) => node.map(fn));",
                    "        if (newNode !== nodes) {",
                    "          if (!newNode) {",
                    "            // @ts-expect-error",
                    "            newNode = new Node({ parent: this.parent });",
                    "          }",
                    "          newNode._setNodes(NODES_KEY, mappedNodes);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (newNode) {",
                    "      for (const key in this) {",
                    "        if (!(key in NODES_KEYS)) {",
                    "          newNode[key] = this[key];",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return fn(newNode || this);",
                    "  }",
                    "",
                    "  walk(fn) {",
                    "    for (const NODES_KEY in NODES_KEYS) {",
                    "      const nodes = this[NODES_KEY];",
                    "      if (nodes) {",
                    "        for (let i = 0; i < nodes.length; i++) {",
                    "          nodes[i].walk(fn);",
                    "        }",
                    "      }",
                    "    }",
                    "    fn(this);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [target]",
                    "   * @param {Object} [node]",
                    "   */",
                    "  insertChildBefore(target, node) {",
                    "    const newNode = new Node({ ...node, parent: this });",
                    "",
                    "    // @ts-expect-error",
                    "    this.children.splice(this.children.indexOf(target), 0, newNode);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [child]",
                    "   */",
                    "  removeChild(child) {",
                    "    // @ts-expect-error",
                    "    this.children.splice(this.children.indexOf(child), 1);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [target]",
                    "   * @param {Object} [node]",
                    "   */",
                    "  replaceChild(target, node) {",
                    "    const newNode = new Node({ ...node, parent: this });",
                    "",
                    "    // @ts-expect-error",
                    "    this.children[this.children.indexOf(target)] = newNode;",
                    "  }",
                    "",
                    "  clone() {",
                    "    return new Node(this);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Array} [children]",
                    "   */",
                    "  setChildren(children) {",
                    "    this._setNodes(\"children\", children);",
                    "  }",
                    "",
                    "  get firstChild() {",
                    "    // @ts-expect-error",
                    "    return isNonEmptyArray(this.children) ? this.children[0] : null;",
                    "  }",
                    "",
                    "  get lastChild() {",
                    "    // @ts-expect-error",
                    "    return isNonEmptyArray(this.children) ? getLast(this.children) : null;",
                    "  }",
                    "",
                    "  get prev() {",
                    "    // @ts-expect-error",
                    "    if (!this.parent) {",
                    "      return null;",
                    "    }",
                    "    // @ts-expect-error",
                    "    return this.parent.children[this.parent.children.indexOf(this) - 1];",
                    "  }",
                    "",
                    "  get next() {",
                    "    // @ts-expect-error",
                    "    if (!this.parent) {",
                    "      return null;",
                    "    }",
                    "    // @ts-expect-error",
                    "    return this.parent.children[this.parent.children.indexOf(this) + 1];",
                    "  }",
                    "",
                    "  // for element and attribute",
                    "  get rawName() {",
                    "    // @ts-expect-error",
                    "    return this.hasExplicitNamespace ? this.fullName : this.name;",
                    "  }",
                    "  get fullName() {",
                    "    // @ts-expect-error",
                    "    return this.namespace ? this.namespace + \":\" + this.name : this.name;",
                    "  }",
                    "}",
                    "",
                    "function mapNodesIfChanged(nodes, fn) {",
                    "  const newNodes = nodes.map(fn);",
                    "  return newNodes.some((newNode, index) => newNode !== nodes[index])",
                    "    ? newNodes",
                    "    : nodes;",
                    "}",
                    "",
                    "function cloneAndUpdateNodes(nodes, parent) {",
                    "  const siblings = nodes.map((node) =>",
                    "    node instanceof Node ? node.clone() : new Node({ ...node, parent })",
                    "  );",
                    "",
                    "  for (const sibling of siblings) {",
                    "    sibling.parent = parent;",
                    "  }",
                    "",
                    "  return siblings;",
                    "}",
                    "",
                    "function setNonEnumerableProperty(obj, key, value) {",
                    "  Object.defineProperty(obj, key, { value, enumerable: false });",
                    "}",
                    "",
                    "module.exports = {",
                    "  Node,",
                    "};"
                ]
            },
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isFrontMatterNode } = require(\"../common/util.js\");",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"sourceSpan\",",
                    "  \"startSourceSpan\",",
                    "  \"endSourceSpan\",",
                    "  \"nameSpan\",",
                    "  \"valueSpan\",",
                    "  \"parent\",",
                    "]);",
                    "",
                    "function clean(ast, newNode) {",
                    "  if (ast.type === \"text\" || ast.type === \"comment\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // may be formatted by multiparser",
                    "  if (isFrontMatterNode(ast) || ast.type === \"yaml\" || ast.type === \"toml\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"attribute\") {",
                    "    delete newNode.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"docType\") {",
                    "    delete newNode.value;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "module.exports = clean;"
                ]
            },
            "conditional-comment.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  ParseSourceSpan,",
                    "} = require(\"angular-html-parser/lib/compiler/src/parse_util\");",
                    "",
                    "// https://css-tricks.com/how-to-create-an-ie-only-stylesheet",
                    "",
                    "const parseFunctions = [",
                    "  {",
                    "    // <!--[if ... ]> ... <![endif]-->",
                    "    regex: /^(\\[if([^\\]]*)]>)(.*?)<!\\s*\\[endif]$/s,",
                    "    parse: parseIeConditionalStartEndComment,",
                    "  },",
                    "  {",
                    "    // <!--[if ... ]><!-->",
                    "    regex: /^\\[if([^\\]]*)]><!$/,",
                    "    parse: parseIeConditionalStartComment,",
                    "  },",
                    "  {",
                    "    // <!--<![endif]-->",
                    "    regex: /^<!\\s*\\[endif]$/,",
                    "    parse: parseIeConditionalEndComment,",
                    "  },",
                    "];",
                    "",
                    "function parseIeConditionalComment(node, parseHtml) {",
                    "  if (node.value) {",
                    "    for (const { regex, parse } of parseFunctions) {",
                    "      const match = node.value.match(regex);",
                    "      if (match) {",
                    "        return parse(node, parseHtml, match);",
                    "      }",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function parseIeConditionalStartEndComment(node, parseHtml, match) {",
                    "  const [, openingTagSuffix, condition, data] = match;",
                    "  const offset = \"<!--\".length + openingTagSuffix.length;",
                    "  const contentStartSpan = node.sourceSpan.start.moveBy(offset);",
                    "  const contentEndSpan = contentStartSpan.moveBy(data.length);",
                    "  const [complete, children] = (() => {",
                    "    try {",
                    "      return [true, parseHtml(data, contentStartSpan).children];",
                    "    } catch {",
                    "      const text = {",
                    "        type: \"text\",",
                    "        value: data,",
                    "        sourceSpan: new ParseSourceSpan(contentStartSpan, contentEndSpan),",
                    "      };",
                    "      return [false, [text]];",
                    "    }",
                    "  })();",
                    "  return {",
                    "    type: \"ieConditionalComment\",",
                    "    complete,",
                    "    children,",
                    "    condition: condition.trim().replace(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "    startSourceSpan: new ParseSourceSpan(",
                    "      node.sourceSpan.start,",
                    "      contentStartSpan",
                    "    ),",
                    "    endSourceSpan: new ParseSourceSpan(contentEndSpan, node.sourceSpan.end),",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalStartComment(node, parseHtml, match) {",
                    "  const [, condition] = match;",
                    "  return {",
                    "    type: \"ieConditionalStartComment\",",
                    "    condition: condition.trim().replace(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalEndComment(node /*, parseHtml, match */) {",
                    "  return {",
                    "    type: \"ieConditionalEndComment\",",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  parseIeConditionalComment,",
                    "};"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const htmlStyles = require(\"html-styles\");",
                    "",
                    "const getCssStyleTags = (property) =>",
                    "  Object.fromEntries(",
                    "    htmlStyles",
                    "      .filter((htmlStyle) => htmlStyle.style[property])",
                    "      .flatMap((htmlStyle) =>",
                    "        htmlStyle.selectorText",
                    "          .split(\",\")",
                    "          .map((selector) => selector.trim())",
                    "          .filter((selector) => /^[\\dA-Za-z]+$/.test(selector))",
                    "          .map((tagName) => [tagName, htmlStyle.style[property]])",
                    "      )",
                    "  );",
                    "",
                    "const CSS_DISPLAY_TAGS = {",
                    "  ...getCssStyleTags(\"display\"),",
                    "",
                    "  // TODO: send PR to upstream",
                    "  button: \"inline-block\",",
                    "",
                    "  // special cases for some css display=none elements",
                    "  template: \"inline\",",
                    "  source: \"block\",",
                    "  track: \"block\",",
                    "  script: \"block\",",
                    "  param: \"block\",",
                    "",
                    "  // `noscript` is inline",
                    "  // noscript: \"inline\",",
                    "",
                    "  // there's no css display for these elements but they behave these ways",
                    "  details: \"block\",",
                    "  summary: \"block\",",
                    "  dialog: \"block\",",
                    "  meter: \"inline-block\",",
                    "  progress: \"inline-block\",",
                    "  object: \"inline-block\",",
                    "  video: \"inline-block\",",
                    "  audio: \"inline-block\",",
                    "  select: \"inline-block\",",
                    "  option: \"block\",",
                    "  optgroup: \"block\",",
                    "};",
                    "const CSS_DISPLAY_DEFAULT = \"inline\";",
                    "const CSS_WHITE_SPACE_TAGS = getCssStyleTags(\"white-space\");",
                    "const CSS_WHITE_SPACE_DEFAULT = \"normal\";",
                    "",
                    "module.exports = {",
                    "  CSS_DISPLAY_TAGS,",
                    "  CSS_DISPLAY_DEFAULT,",
                    "  CSS_WHITE_SPACE_TAGS,",
                    "  CSS_WHITE_SPACE_DEFAULT,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { breakParent, group, hardline, indent, line, fill, softline },",
                    "  utils: { mapDoc, replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const printFrontMatter = require(\"../utils/front-matter/print.js\");",
                    "const {",
                    "  printClosingTag,",
                    "  printClosingTagSuffix,",
                    "  needsToBorrowPrevClosingTagEndMarker,",
                    "  printOpeningTagPrefix,",
                    "  printOpeningTag,",
                    "} = require(\"./print/tag.js\");",
                    "const { printImgSrcset, printClassNames } = require(\"./syntax-attribute.js\");",
                    "const {",
                    "  printVueFor,",
                    "  printVueBindings,",
                    "  isVueEventBindingExpression,",
                    "} = require(\"./syntax-vue.js\");",
                    "const {",
                    "  isScriptLikeTag,",
                    "  isVueNonHtmlBlock,",
                    "  inferScriptParser,",
                    "  htmlTrimPreserveIndentation,",
                    "  dedentString,",
                    "  unescapeQuoteEntities,",
                    "  isVueSlotAttribute,",
                    "  isVueSfcBindingsAttribute,",
                    "  getTextValueParts,",
                    "} = require(\"./utils.js\");",
                    "const getNodeContent = require(\"./get-node-content.js\");",
                    "",
                    "function printEmbeddedAttributeValue(node, htmlTextToDoc, options) {",
                    "  const isKeyMatched = (patterns) =>",
                    "    new RegExp(patterns.join(\"|\")).test(node.fullName);",
                    "  const getValue = () => unescapeQuoteEntities(node.value);",
                    "",
                    "  let shouldHug = false;",
                    "",
                    "  const __onHtmlBindingRoot = (root, options) => {",
                    "    const rootNode =",
                    "      root.type === \"NGRoot\"",
                    "        ? root.node.type === \"NGMicrosyntax\" &&",
                    "          root.node.body.length === 1 &&",
                    "          root.node.body[0].type === \"NGMicrosyntaxExpression\"",
                    "          ? root.node.body[0].expression",
                    "          : root.node",
                    "        : root.type === \"JsExpressionRoot\"",
                    "        ? root.node",
                    "        : root;",
                    "    if (",
                    "      rootNode &&",
                    "      (rootNode.type === \"ObjectExpression\" ||",
                    "        rootNode.type === \"ArrayExpression\" ||",
                    "        (options.parser === \"__vue_expression\" &&",
                    "          (rootNode.type === \"TemplateLiteral\" ||",
                    "            rootNode.type === \"StringLiteral\")))",
                    "    ) {",
                    "      shouldHug = true;",
                    "    }",
                    "  };",
                    "",
                    "  const printHug = (doc) => group(doc);",
                    "  const printExpand = (doc, canHaveTrailingWhitespace = true) =>",
                    "    group([indent([softline, doc]), canHaveTrailingWhitespace ? softline : \"\"]);",
                    "  const printMaybeHug = (doc) => (shouldHug ? printHug(doc) : printExpand(doc));",
                    "",
                    "  const attributeTextToDoc = (code, opts) =>",
                    "    htmlTextToDoc(code, {",
                    "      __onHtmlBindingRoot,",
                    "      __embeddedInHtml: true,",
                    "      ...opts,",
                    "    });",
                    "",
                    "  if (",
                    "    node.fullName === \"srcset\" &&",
                    "    (node.parent.fullName === \"img\" || node.parent.fullName === \"source\")",
                    "  ) {",
                    "    return printExpand(printImgSrcset(getValue()));",
                    "  }",
                    "",
                    "  if (node.fullName === \"class\" && !options.parentParser) {",
                    "    const value = getValue();",
                    "    if (!value.includes(\"{{\")) {",
                    "      return printClassNames(value);",
                    "    }",
                    "  }",
                    "",
                    "  if (node.fullName === \"style\" && !options.parentParser) {",
                    "    const value = getValue();",
                    "    if (!value.includes(\"{{\")) {",
                    "      return printExpand(",
                    "        attributeTextToDoc(value, {",
                    "          parser: \"css\",",
                    "          __isHTMLStyleAttribute: true,",
                    "        })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (options.parser === \"vue\") {",
                    "    if (node.fullName === \"v-for\") {",
                    "      return printVueFor(getValue(), attributeTextToDoc);",
                    "    }",
                    "",
                    "    if (isVueSlotAttribute(node) || isVueSfcBindingsAttribute(node, options)) {",
                    "      return printVueBindings(getValue(), attributeTextToDoc);",
                    "    }",
                    "",
                    "    /**",
                    "     *     @click=\"jsStatement\"",
                    "     *     @click=\"jsExpression\"",
                    "     *     v-on:click=\"jsStatement\"",
                    "     *     v-on:click=\"jsExpression\"",
                    "     */",
                    "    const vueEventBindingPatterns = [\"^@\", \"^v-on:\"];",
                    "    /**",
                    "     *     :class=\"vueExpression\"",
                    "     *     v-bind:id=\"vueExpression\"",
                    "     */",
                    "    const vueExpressionBindingPatterns = [\"^:\", \"^v-bind:\"];",
                    "    /**",
                    "     *     v-if=\"jsExpression\"",
                    "     */",
                    "    const jsExpressionBindingPatterns = [\"^v-\"];",
                    "",
                    "    if (isKeyMatched(vueEventBindingPatterns)) {",
                    "      const value = getValue();",
                    "      return printMaybeHug(",
                    "        attributeTextToDoc(value, {",
                    "          parser: isVueEventBindingExpression(value)",
                    "            ? \"__js_expression\"",
                    "            : \"__vue_event_binding\",",
                    "        })",
                    "      );",
                    "    }",
                    "",
                    "    if (isKeyMatched(vueExpressionBindingPatterns)) {",
                    "      return printMaybeHug(",
                    "        attributeTextToDoc(getValue(), { parser: \"__vue_expression\" })",
                    "      );",
                    "    }",
                    "",
                    "    if (isKeyMatched(jsExpressionBindingPatterns)) {",
                    "      return printMaybeHug(",
                    "        attributeTextToDoc(getValue(), { parser: \"__js_expression\" })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (options.parser === \"angular\") {",
                    "    const ngTextToDoc = (code, opts) =>",
                    "      // angular does not allow trailing comma",
                    "      attributeTextToDoc(code, { ...opts, trailingComma: \"none\" });",
                    "",
                    "    /**",
                    "     *     *directive=\"angularDirective\"",
                    "     */",
                    "    const ngDirectiveBindingPatterns = [\"^\\\\*\"];",
                    "    /**",
                    "     *     (click)=\"angularStatement\"",
                    "     *     on-click=\"angularStatement\"",
                    "     */",
                    "    const ngStatementBindingPatterns = [\"^\\\\(.+\\\\)$\", \"^on-\"];",
                    "    /**",
                    "     *     [target]=\"angularExpression\"",
                    "     *     bind-target=\"angularExpression\"",
                    "     *     [(target)]=\"angularExpression\"",
                    "     *     bindon-target=\"angularExpression\"",
                    "     */",
                    "    const ngExpressionBindingPatterns = [",
                    "      \"^\\\\[.+\\\\]$\",",
                    "      \"^bind(on)?-\",",
                    "      // Unofficial rudimentary support for some of the most used directives of AngularJS 1.x",
                    "      \"^ng-(if|show|hide|class|style)$\",",
                    "    ];",
                    "    /**",
                    "     *     i18n=\"longDescription\"",
                    "     *     i18n-attr=\"longDescription\"",
                    "     */",
                    "    const ngI18nPatterns = [\"^i18n(-.+)?$\"];",
                    "",
                    "    if (isKeyMatched(ngStatementBindingPatterns)) {",
                    "      return printMaybeHug(ngTextToDoc(getValue(), { parser: \"__ng_action\" }));",
                    "    }",
                    "",
                    "    if (isKeyMatched(ngExpressionBindingPatterns)) {",
                    "      return printMaybeHug(ngTextToDoc(getValue(), { parser: \"__ng_binding\" }));",
                    "    }",
                    "",
                    "    if (isKeyMatched(ngI18nPatterns)) {",
                    "      const value = getValue().trim();",
                    "      return printExpand(",
                    "        fill(getTextValueParts(node, value)),",
                    "        !value.includes(\"@@\")",
                    "      );",
                    "    }",
                    "",
                    "    if (isKeyMatched(ngDirectiveBindingPatterns)) {",
                    "      return printMaybeHug(",
                    "        ngTextToDoc(getValue(), { parser: \"__ng_directive\" })",
                    "      );",
                    "    }",
                    "",
                    "    const interpolationRegex = /{{(.+?)}}/s;",
                    "    const value = getValue();",
                    "    if (interpolationRegex.test(value)) {",
                    "      const parts = [];",
                    "      for (const [index, part] of value.split(interpolationRegex).entries()) {",
                    "        if (index % 2 === 0) {",
                    "          parts.push(replaceTextEndOfLine(part));",
                    "        } else {",
                    "          try {",
                    "            parts.push(",
                    "              group([",
                    "                \"{{\",",
                    "                indent([",
                    "                  line,",
                    "                  ngTextToDoc(part, {",
                    "                    parser: \"__ng_interpolation\",",
                    "                    __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                    "                  }),",
                    "                ]),",
                    "                line,",
                    "                \"}}\",",
                    "              ])",
                    "            );",
                    "          } catch {",
                    "            parts.push(\"{{\", replaceTextEndOfLine(part), \"}}\");",
                    "          }",
                    "        }",
                    "      }",
                    "      return group(parts);",
                    "    }",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  switch (node.type) {",
                    "    case \"element\": {",
                    "      if (isScriptLikeTag(node) || node.type === \"interpolation\") {",
                    "        // Fall through to \"text\"",
                    "        return;",
                    "      }",
                    "",
                    "      if (!node.isSelfClosing && isVueNonHtmlBlock(node, options)) {",
                    "        const parser = inferScriptParser(node, options);",
                    "        if (!parser) {",
                    "          return;",
                    "        }",
                    "",
                    "        const content = getNodeContent(node, options);",
                    "        let isEmpty = /^\\s*$/.test(content);",
                    "        let doc = \"\";",
                    "        if (!isEmpty) {",
                    "          doc = textToDoc(",
                    "            htmlTrimPreserveIndentation(content),",
                    "            { parser, __embeddedInHtml: true },",
                    "            { stripTrailingHardline: true }",
                    "          );",
                    "          isEmpty = doc === \"\";",
                    "        }",
                    "",
                    "        return [",
                    "          printOpeningTagPrefix(node, options),",
                    "          group(printOpeningTag(path, options, print)),",
                    "          isEmpty ? \"\" : hardline,",
                    "          doc,",
                    "          isEmpty ? \"\" : hardline,",
                    "          printClosingTag(node, options),",
                    "          printClosingTagSuffix(node, options),",
                    "        ];",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"text\": {",
                    "      if (isScriptLikeTag(node.parent)) {",
                    "        const parser = inferScriptParser(node.parent);",
                    "        if (parser) {",
                    "          const value =",
                    "            parser === \"markdown\"",
                    "              ? dedentString(node.value.replace(/^[^\\S\\n]*\\n/, \"\"))",
                    "              : node.value;",
                    "          const textToDocOptions = { parser, __embeddedInHtml: true };",
                    "          if (options.parser === \"html\" && parser === \"babel\") {",
                    "            let sourceType = \"script\";",
                    "            const { attrMap } = node.parent;",
                    "            if (",
                    "              attrMap &&",
                    "              (attrMap.type === \"module\" ||",
                    "                (attrMap.type === \"text/babel\" &&",
                    "                  attrMap[\"data-type\"] === \"module\"))",
                    "            ) {",
                    "              sourceType = \"module\";",
                    "            }",
                    "            textToDocOptions.__babelSourceType = sourceType;",
                    "          }",
                    "          return [",
                    "            breakParent,",
                    "            printOpeningTagPrefix(node, options),",
                    "            textToDoc(value, textToDocOptions, {",
                    "              stripTrailingHardline: true,",
                    "            }),",
                    "            printClosingTagSuffix(node, options),",
                    "          ];",
                    "        }",
                    "      } else if (node.parent.type === \"interpolation\") {",
                    "        const textToDocOptions = {",
                    "          __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                    "          __embeddedInHtml: true,",
                    "        };",
                    "        if (options.parser === \"angular\") {",
                    "          textToDocOptions.parser = \"__ng_interpolation\";",
                    "          textToDocOptions.trailingComma = \"none\";",
                    "        } else if (options.parser === \"vue\") {",
                    "          textToDocOptions.parser = \"__vue_expression\";",
                    "        } else {",
                    "          textToDocOptions.parser = \"__js_expression\";",
                    "        }",
                    "        return [",
                    "          indent([",
                    "            line,",
                    "            textToDoc(node.value, textToDocOptions, {",
                    "              stripTrailingHardline: true,",
                    "            }),",
                    "          ]),",
                    "          node.parent.next &&",
                    "          needsToBorrowPrevClosingTagEndMarker(node.parent.next)",
                    "            ? \" \"",
                    "            : line,",
                    "        ];",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"attribute\": {",
                    "      if (!node.value) {",
                    "        break;",
                    "      }",
                    "",
                    "      // lit-html: html`<my-element obj=${obj}></my-element>`",
                    "      if (",
                    "        /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(",
                    "          options.originalText.slice(",
                    "            node.valueSpan.start.offset,",
                    "            node.valueSpan.end.offset",
                    "          )",
                    "        )",
                    "      ) {",
                    "        return [node.rawName, \"=\", node.value];",
                    "      }",
                    "",
                    "      // lwc: html`<my-element data-for={value}></my-element>`",
                    "      if (options.parser === \"lwc\") {",
                    "        const interpolationRegex = /^{.*}$/s;",
                    "        if (",
                    "          interpolationRegex.test(",
                    "            options.originalText.slice(",
                    "              node.valueSpan.start.offset,",
                    "              node.valueSpan.end.offset",
                    "            )",
                    "          )",
                    "        ) {",
                    "          return [node.rawName, \"=\", node.value];",
                    "        }",
                    "      }",
                    "",
                    "      const embeddedAttributeValueDoc = printEmbeddedAttributeValue(",
                    "        node,",
                    "        (code, opts) =>",
                    "          // strictly prefer single quote to avoid unnecessary html entity escape",
                    "          textToDoc(",
                    "            code,",
                    "            { __isInHtmlAttribute: true, __embeddedInHtml: true, ...opts },",
                    "            { stripTrailingHardline: true }",
                    "          ),",
                    "        options",
                    "      );",
                    "      if (embeddedAttributeValueDoc) {",
                    "        return [",
                    "          node.rawName,",
                    "          '=\"',",
                    "          group(",
                    "            mapDoc(embeddedAttributeValueDoc, (doc) =>",
                    "              typeof doc === \"string\" ? doc.replace(/\"/g, \"&quot;\") : doc",
                    "            )",
                    "          ),",
                    "          '\"',",
                    "        ];",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"front-matter\":",
                    "      return printFrontMatter(node, textToDoc);",
                    "  }",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "get-node-content.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  needsToBorrowParentClosingTagStartMarker,",
                    "  printClosingTagStartMarker,",
                    "  needsToBorrowLastChildClosingTagEndMarker,",
                    "  printClosingTagEndMarker,",
                    "  needsToBorrowParentOpeningTagEndMarker,",
                    "  printOpeningTagEndMarker,",
                    "} = require(\"./print/tag.js\");",
                    "",
                    "function getNodeContent(node, options) {",
                    "  let start = node.startSourceSpan.end.offset;",
                    "  if (",
                    "    node.firstChild &&",
                    "    needsToBorrowParentOpeningTagEndMarker(node.firstChild)",
                    "  ) {",
                    "    start -= printOpeningTagEndMarker(node).length;",
                    "  }",
                    "",
                    "  let end = node.endSourceSpan.start.offset;",
                    "  if (",
                    "    node.lastChild &&",
                    "    needsToBorrowParentClosingTagStartMarker(node.lastChild)",
                    "  ) {",
                    "    end += printClosingTagStartMarker(node, options).length;",
                    "  } else if (needsToBorrowLastChildClosingTagEndMarker(node)) {",
                    "    end -= printClosingTagEndMarker(node.lastChild, options).length;",
                    "  }",
                    "",
                    "  return options.originalText.slice(start, end);",
                    "}",
                    "",
                    "module.exports = getNodeContent;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-html.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/HTML.json\"), () => ({",
                    "    name: \"Angular\",",
                    "    since: \"1.15.0\",",
                    "    parsers: [\"angular\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [\".component.html\"],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/HTML.json\"), (data) => ({",
                    "    since: \"1.15.0\",",
                    "    parsers: [\"html\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [",
                    "      ...data.extensions,",
                    "      \".mjml\", // MJML is considered XML in Linguist but it should be formatted as HTML",
                    "    ],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/HTML.json\"), () => ({",
                    "    name: \"Lightning Web Components\",",
                    "    since: \"1.17.0\",",
                    "    parsers: [\"lwc\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/Vue.json\"), () => ({",
                    "    since: \"1.10.0\",",
                    "    parsers: [\"vue\"],",
                    "    vscodeLanguageIds: [\"vue\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  html: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  printers,",
                    "  options,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  return node.sourceSpan.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.sourceSpan.end.offset;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "const CATEGORY_HTML = \"HTML\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSameLine: commonOptions.bracketSameLine,",
                    "  htmlWhitespaceSensitivity: {",
                    "    since: \"1.15.0\",",
                    "    category: CATEGORY_HTML,",
                    "    type: \"choice\",",
                    "    default: \"css\",",
                    "    description: \"How to handle whitespaces in HTML.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"css\",",
                    "        description: \"Respect the default value of CSS display property.\",",
                    "      },",
                    "      {",
                    "        value: \"strict\",",
                    "        description: \"Whitespaces are considered sensitive.\",",
                    "      },",
                    "      {",
                    "        value: \"ignore\",",
                    "        description: \"Whitespaces are considered insensitive.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  singleAttributePerLine: commonOptions.singleAttributePerLine,",
                    "  vueIndentScriptAndStyle: {",
                    "    since: \"1.19.0\",",
                    "    category: CATEGORY_HTML,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent script and style tags in Vue files.\",",
                    "  },",
                    "};"
                ]
            },
            "parser-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  ParseSourceSpan,",
                    "  ParseLocation,",
                    "  ParseSourceFile,",
                    "} = require(\"angular-html-parser/lib/compiler/src/parse_util\");",
                    "const parseFrontMatter = require(\"../utils/front-matter/parse.js\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const { inferParserByLanguage } = require(\"../common/util.js\");",
                    "const {",
                    "  HTML_ELEMENT_ATTRIBUTES,",
                    "  HTML_TAGS,",
                    "  isUnknownNamespace,",
                    "} = require(\"./utils.js\");",
                    "const { hasPragma } = require(\"./pragma.js\");",
                    "const { Node } = require(\"./ast.js\");",
                    "const { parseIeConditionalComment } = require(\"./conditional-comment.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "/**",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast').Node} AstNode",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast').Attribute} Attribute",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast').Element} Element",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/parser').ParseTreeResult} ParserTreeResult",
                    " * @typedef {Omit<import('angular-html-parser').ParseOptions, 'canSelfClose'> & {",
                    " *   name?: 'html' | 'angular' | 'vue' | 'lwc';",
                    " *   recognizeSelfClosing?: boolean;",
                    " *   normalizeTagName?: boolean;",
                    " *   normalizeAttributeName?: boolean;",
                    " * }} ParserOptions",
                    " * @typedef {{",
                    " *   parser: 'html' | 'angular' | 'vue' | 'lwc',",
                    " *   filepath?: string",
                    " * }} Options",
                    " */",
                    "",
                    "/**",
                    " * @param {string} input",
                    " * @param {ParserOptions} parserOptions",
                    " * @param {Options} options",
                    " */",
                    "function ngHtmlParser(",
                    "  input,",
                    "  {",
                    "    recognizeSelfClosing,",
                    "    normalizeTagName,",
                    "    normalizeAttributeName,",
                    "    allowHtmComponentClosingTags,",
                    "    isTagNameCaseSensitive,",
                    "    getTagContentType,",
                    "  },",
                    "  options",
                    ") {",
                    "  const parser = require(\"angular-html-parser\");",
                    "  const {",
                    "    RecursiveVisitor,",
                    "    visitAll,",
                    "  } = require(\"angular-html-parser/lib/compiler/src/ml_parser/ast\");",
                    "  const {",
                    "    ParseSourceSpan,",
                    "  } = require(\"angular-html-parser/lib/compiler/src/parse_util\");",
                    "  const {",
                    "    getHtmlTagDefinition,",
                    "  } = require(\"angular-html-parser/lib/compiler/src/ml_parser/html_tags\");",
                    "",
                    "  let { rootNodes, errors } = parser.parse(input, {",
                    "    canSelfClose: recognizeSelfClosing,",
                    "    allowHtmComponentClosingTags,",
                    "    isTagNameCaseSensitive,",
                    "    getTagContentType,",
                    "  });",
                    "",
                    "  if (options.parser === \"vue\") {",
                    "    const isVueHtml = rootNodes.some(",
                    "      (node) =>",
                    "        (node.type === \"docType\" && node.value === \"html\") ||",
                    "        (node.type === \"element\" && node.name.toLowerCase() === \"html\")",
                    "    );",
                    "",
                    "    if (!isVueHtml) {",
                    "      const shouldParseAsHTML = (/** @type {AstNode} */ node) => {",
                    "        /* istanbul ignore next */",
                    "        if (!node) {",
                    "          return false;",
                    "        }",
                    "        if (node.type !== \"element\" || node.name !== \"template\") {",
                    "          return false;",
                    "        }",
                    "        const langAttr = node.attrs.find((attr) => attr.name === \"lang\");",
                    "        const langValue = langAttr && langAttr.value;",
                    "        return (",
                    "          !langValue || inferParserByLanguage(langValue, options) === \"html\"",
                    "        );",
                    "      };",
                    "      if (rootNodes.some(shouldParseAsHTML)) {",
                    "        /** @type {ParserTreeResult | undefined} */",
                    "        let secondParseResult;",
                    "        const doSecondParse = () =>",
                    "          parser.parse(input, {",
                    "            canSelfClose: recognizeSelfClosing,",
                    "            allowHtmComponentClosingTags,",
                    "            isTagNameCaseSensitive,",
                    "          });",
                    "        const getSecondParse = () =>",
                    "          secondParseResult || (secondParseResult = doSecondParse());",
                    "        const getSameLocationNode = (node) =>",
                    "          getSecondParse().rootNodes.find(",
                    "            ({ startSourceSpan }) =>",
                    "              startSourceSpan &&",
                    "              startSourceSpan.start.offset === node.startSourceSpan.start.offset",
                    "          );",
                    "        for (let i = 0; i < rootNodes.length; i++) {",
                    "          const node = rootNodes[i];",
                    "          const { endSourceSpan, startSourceSpan } = node;",
                    "          const isUnclosedNode = endSourceSpan === null;",
                    "          if (isUnclosedNode) {",
                    "            const result = getSecondParse();",
                    "            errors = result.errors;",
                    "            rootNodes[i] = getSameLocationNode(node) || node;",
                    "          } else if (shouldParseAsHTML(node)) {",
                    "            const result = getSecondParse();",
                    "            const startOffset = startSourceSpan.end.offset;",
                    "            const endOffset = endSourceSpan.start.offset;",
                    "            for (const error of result.errors) {",
                    "              const { offset } = error.span.start;",
                    "              /* istanbul ignore next */",
                    "              if (startOffset < offset && offset < endOffset) {",
                    "                errors = [error];",
                    "                break;",
                    "              }",
                    "            }",
                    "            rootNodes[i] = getSameLocationNode(node) || node;",
                    "          }",
                    "        }",
                    "      }",
                    "    } else {",
                    "      // If not Vue SFC, treat as html",
                    "      recognizeSelfClosing = true;",
                    "      normalizeTagName = true;",
                    "      normalizeAttributeName = true;",
                    "      allowHtmComponentClosingTags = true;",
                    "      isTagNameCaseSensitive = false;",
                    "      const htmlParseResult = parser.parse(input, {",
                    "        canSelfClose: recognizeSelfClosing,",
                    "        allowHtmComponentClosingTags,",
                    "        isTagNameCaseSensitive,",
                    "      });",
                    "",
                    "      rootNodes = htmlParseResult.rootNodes;",
                    "      errors = htmlParseResult.errors;",
                    "    }",
                    "  }",
                    "",
                    "  if (errors.length > 0) {",
                    "    const {",
                    "      msg,",
                    "      span: { start, end },",
                    "    } = errors[0];",
                    "    throw createError(msg, {",
                    "      start: { line: start.line + 1, column: start.col + 1 },",
                    "      end: { line: end.line + 1, column: end.col + 1 },",
                    "    });",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Attribute | Element} node",
                    "   */",
                    "  const restoreName = (node) => {",
                    "    const namespace = node.name.startsWith(\":\")",
                    "      ? node.name.slice(1).split(\":\")[0]",
                    "      : null;",
                    "    const rawName = node.nameSpan.toString();",
                    "    const hasExplicitNamespace =",
                    "      namespace !== null && rawName.startsWith(`${namespace}:`);",
                    "    const name = hasExplicitNamespace",
                    "      ? rawName.slice(namespace.length + 1)",
                    "      : rawName;",
                    "",
                    "    node.name = name;",
                    "    node.namespace = namespace;",
                    "    node.hasExplicitNamespace = hasExplicitNamespace;",
                    "  };",
                    "",
                    "  /**",
                    "   * @param {AstNode} node",
                    "   */",
                    "  const restoreNameAndValue = (node) => {",
                    "    switch (node.type) {",
                    "      case \"element\":",
                    "        restoreName(node);",
                    "        for (const attr of node.attrs) {",
                    "          restoreName(attr);",
                    "          if (!attr.valueSpan) {",
                    "            attr.value = null;",
                    "          } else {",
                    "            attr.value = attr.valueSpan.toString();",
                    "            if (/[\"']/.test(attr.value[0])) {",
                    "              attr.value = attr.value.slice(1, -1);",
                    "            }",
                    "          }",
                    "        }",
                    "        break;",
                    "      case \"comment\":",
                    "        node.value = node.sourceSpan",
                    "          .toString()",
                    "          .slice(\"<!--\".length, -\"-->\".length);",
                    "        break;",
                    "      case \"text\":",
                    "        node.value = node.sourceSpan.toString();",
                    "        break;",
                    "      // No default",
                    "    }",
                    "  };",
                    "",
                    "  const lowerCaseIfFn = (text, fn) => {",
                    "    const lowerCasedText = text.toLowerCase();",
                    "    return fn(lowerCasedText) ? lowerCasedText : text;",
                    "  };",
                    "  const normalizeName = (node) => {",
                    "    if (node.type === \"element\") {",
                    "      if (",
                    "        normalizeTagName &&",
                    "        (!node.namespace ||",
                    "          node.namespace === node.tagDefinition.implicitNamespacePrefix ||",
                    "          isUnknownNamespace(node))",
                    "      ) {",
                    "        node.name = lowerCaseIfFn(",
                    "          node.name,",
                    "          (lowerCasedName) => lowerCasedName in HTML_TAGS",
                    "        );",
                    "      }",
                    "",
                    "      if (normalizeAttributeName) {",
                    "        const CURRENT_HTML_ELEMENT_ATTRIBUTES =",
                    "          HTML_ELEMENT_ATTRIBUTES[node.name] || Object.create(null);",
                    "        for (const attr of node.attrs) {",
                    "          if (!attr.namespace) {",
                    "            attr.name = lowerCaseIfFn(",
                    "              attr.name,",
                    "              (lowerCasedAttrName) =>",
                    "                node.name in HTML_ELEMENT_ATTRIBUTES &&",
                    "                (lowerCasedAttrName in HTML_ELEMENT_ATTRIBUTES[\"*\"] ||",
                    "                  lowerCasedAttrName in CURRENT_HTML_ELEMENT_ATTRIBUTES)",
                    "            );",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  const fixSourceSpan = (node) => {",
                    "    if (node.sourceSpan && node.endSourceSpan) {",
                    "      node.sourceSpan = new ParseSourceSpan(",
                    "        node.sourceSpan.start,",
                    "        node.endSourceSpan.end",
                    "      );",
                    "    }",
                    "  };",
                    "",
                    "  /**",
                    "   * @param {AstNode} node",
                    "   */",
                    "  const addTagDefinition = (node) => {",
                    "    if (node.type === \"element\") {",
                    "      const tagDefinition = getHtmlTagDefinition(",
                    "        isTagNameCaseSensitive ? node.name : node.name.toLowerCase()",
                    "      );",
                    "      if (",
                    "        !node.namespace ||",
                    "        node.namespace === tagDefinition.implicitNamespacePrefix ||",
                    "        isUnknownNamespace(node)",
                    "      ) {",
                    "        node.tagDefinition = tagDefinition;",
                    "      } else {",
                    "        node.tagDefinition = getHtmlTagDefinition(\"\"); // the default one",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  visitAll(",
                    "    new (class extends RecursiveVisitor {",
                    "      visit(node) {",
                    "        restoreNameAndValue(node);",
                    "        addTagDefinition(node);",
                    "        normalizeName(node);",
                    "        fixSourceSpan(node);",
                    "      }",
                    "    })(),",
                    "    rootNodes",
                    "  );",
                    "",
                    "  return rootNodes;",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {Options} options",
                    " * @param {ParserOptions} parserOptions",
                    " * @param {boolean} shouldParseFrontMatter",
                    " */",
                    "function _parse(text, options, parserOptions, shouldParseFrontMatter = true) {",
                    "  const { frontMatter, content } = shouldParseFrontMatter",
                    "    ? parseFrontMatter(text)",
                    "    : { frontMatter: null, content: text };",
                    "",
                    "  const file = new ParseSourceFile(text, options.filepath);",
                    "  const start = new ParseLocation(file, 0, 0, 0);",
                    "  const end = start.moveBy(text.length);",
                    "  const rawAst = {",
                    "    type: \"root\",",
                    "    sourceSpan: new ParseSourceSpan(start, end),",
                    "    children: ngHtmlParser(content, parserOptions, options),",
                    "  };",
                    "",
                    "  if (frontMatter) {",
                    "    const start = new ParseLocation(file, 0, 0, 0);",
                    "    const end = start.moveBy(frontMatter.raw.length);",
                    "    frontMatter.sourceSpan = new ParseSourceSpan(start, end);",
                    "    // @ts-expect-error",
                    "    rawAst.children.unshift(frontMatter);",
                    "  }",
                    "",
                    "  const ast = new Node(rawAst);",
                    "",
                    "  const parseSubHtml = (subContent, startSpan) => {",
                    "    const { offset } = startSpan;",
                    "    const fakeContent = text.slice(0, offset).replace(/[^\\n\\r]/g, \" \");",
                    "    const realContent = subContent;",
                    "    const subAst = _parse(",
                    "      fakeContent + realContent,",
                    "      options,",
                    "      parserOptions,",
                    "      false",
                    "    );",
                    "    // @ts-expect-error",
                    "    subAst.sourceSpan = new ParseSourceSpan(",
                    "      startSpan,",
                    "      // @ts-expect-error",
                    "      getLast(subAst.children).sourceSpan.end",
                    "    );",
                    "    // @ts-expect-error",
                    "    const firstText = subAst.children[0];",
                    "    if (firstText.length === offset) {",
                    "      /* istanbul ignore next */ // @ts-expect-error",
                    "      subAst.children.shift();",
                    "    } else {",
                    "      firstText.sourceSpan = new ParseSourceSpan(",
                    "        firstText.sourceSpan.start.moveBy(offset),",
                    "        firstText.sourceSpan.end",
                    "      );",
                    "      firstText.value = firstText.value.slice(offset);",
                    "    }",
                    "    return subAst;",
                    "  };",
                    "",
                    "  ast.walk((node) => {",
                    "    if (node.type === \"comment\") {",
                    "      const ieConditionalComment = parseIeConditionalComment(",
                    "        node,",
                    "        parseSubHtml",
                    "      );",
                    "      if (ieConditionalComment) {",
                    "        node.parent.replaceChild(node, ieConditionalComment);",
                    "      }",
                    "    }",
                    "  });",
                    "",
                    "  return ast;",
                    "}",
                    "",
                    "/**",
                    " * @param {ParserOptions} parserOptions",
                    " */",
                    "function createParser({",
                    "  name,",
                    "  recognizeSelfClosing = false,",
                    "  normalizeTagName = false,",
                    "  normalizeAttributeName = false,",
                    "  allowHtmComponentClosingTags = false,",
                    "  isTagNameCaseSensitive = false,",
                    "  getTagContentType,",
                    "} = {}) {",
                    "  return {",
                    "    parse: (text, parsers, options) =>",
                    "      _parse(",
                    "        text,",
                    "        { parser: name, ...options },",
                    "        {",
                    "          recognizeSelfClosing,",
                    "          normalizeTagName,",
                    "          normalizeAttributeName,",
                    "          allowHtmComponentClosingTags,",
                    "          isTagNameCaseSensitive,",
                    "          getTagContentType,",
                    "        }",
                    "      ),",
                    "    hasPragma,",
                    "    astFormat: \"html\",",
                    "    locStart,",
                    "    locEnd,",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    html: createParser({",
                    "      name: \"html\",",
                    "      recognizeSelfClosing: true,",
                    "      normalizeTagName: true,",
                    "      normalizeAttributeName: true,",
                    "      allowHtmComponentClosingTags: true,",
                    "    }),",
                    "    angular: createParser({ name: \"angular\" }),",
                    "    vue: createParser({",
                    "      name: \"vue\",",
                    "      recognizeSelfClosing: true,",
                    "      isTagNameCaseSensitive: true,",
                    "      getTagContentType: (tagName, prefix, hasParent, attrs) => {",
                    "        if (",
                    "          tagName.toLowerCase() !== \"html\" &&",
                    "          !hasParent &&",
                    "          (tagName !== \"template\" ||",
                    "            attrs.some(",
                    "              ({ name, value }) => name === \"lang\" && value !== \"html\"",
                    "            ))",
                    "        ) {",
                    "          return require(\"angular-html-parser\").TagContentType.RAW_TEXT;",
                    "        }",
                    "      },",
                    "    }),",
                    "    lwc: createParser({ name: \"lwc\" }),",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  // HTML",
                    "  get html() {",
                    "    return require(\"./parser-html.js\").parsers.html;",
                    "  },",
                    "  // Vue",
                    "  get vue() {",
                    "    return require(\"./parser-html.js\").parsers.vue;",
                    "  },",
                    "  // Angular",
                    "  get angular() {",
                    "    return require(\"./parser-html.js\").parsers.angular;",
                    "  },",
                    "  // Lightning Web Components",
                    "  get lwc() {",
                    "    return require(\"./parser-html.js\").parsers.lwc;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*<!--\\s*@(?:format|prettier)\\s*-->/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"<!-- @format -->\\n\\n\" + text.replace(/^\\s*\\n/, \"\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  ParseSourceSpan,",
                    "} = require(\"angular-html-parser/lib/compiler/src/parse_util\");",
                    "const {",
                    "  htmlTrim,",
                    "  getLeadingAndTrailingHtmlWhitespace,",
                    "  hasHtmlWhitespace,",
                    "  canHaveInterpolation,",
                    "  getNodeCssStyleDisplay,",
                    "  isDanglingSpaceSensitiveNode,",
                    "  isIndentationSensitiveNode,",
                    "  isLeadingSpaceSensitiveNode,",
                    "  isTrailingSpaceSensitiveNode,",
                    "  isWhitespaceSensitiveNode,",
                    "} = require(\"./utils.js\");",
                    "",
                    "const PREPROCESS_PIPELINE = [",
                    "  removeIgnorableFirstLf,",
                    "  mergeIfConditionalStartEndCommentIntoElementOpeningTag,",
                    "  mergeCdataIntoText,",
                    "  extractInterpolation,",
                    "  extractWhitespaces,",
                    "  addCssDisplay,",
                    "  addIsSelfClosing,",
                    "  addHasHtmComponentClosingTag,",
                    "  addIsSpaceSensitive,",
                    "  mergeSimpleElementIntoText,",
                    "];",
                    "",
                    "function preprocess(ast, options) {",
                    "  for (const fn of PREPROCESS_PIPELINE) {",
                    "    fn(ast, options);",
                    "  }",
                    "  return ast;",
                    "}",
                    "",
                    "function removeIgnorableFirstLf(ast /*, options */) {",
                    "  ast.walk((node) => {",
                    "    if (",
                    "      node.type === \"element\" &&",
                    "      node.tagDefinition.ignoreFirstLf &&",
                    "      node.children.length > 0 &&",
                    "      node.children[0].type === \"text\" &&",
                    "      node.children[0].value[0] === \"\\n\"",
                    "    ) {",
                    "      const text = node.children[0];",
                    "      if (text.value.length === 1) {",
                    "        node.removeChild(text);",
                    "      } else {",
                    "        text.value = text.value.slice(1);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeIfConditionalStartEndCommentIntoElementOpeningTag(",
                    "  ast /*, options */",
                    ") {",
                    "  /**",
                    "   *     <!--[if ...]><!--><target><!--<![endif]-->",
                    "   */",
                    "  const isTarget = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.prev &&",
                    "    node.prev.type === \"ieConditionalStartComment\" &&",
                    "    node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset &&",
                    "    node.firstChild &&",
                    "    node.firstChild.type === \"ieConditionalEndComment\" &&",
                    "    node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (!isTarget(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const ieConditionalStartComment = child.prev;",
                    "        const ieConditionalEndComment = child.firstChild;",
                    "",
                    "        // ieConditionalStartComment",
                    "        node.removeChild(ieConditionalStartComment);",
                    "        i--; // because a node was removed",
                    "",
                    "        const startSourceSpan = new ParseSourceSpan(",
                    "          ieConditionalStartComment.sourceSpan.start,",
                    "          ieConditionalEndComment.sourceSpan.end",
                    "        );",
                    "        const sourceSpan = new ParseSourceSpan(",
                    "          startSourceSpan.start,",
                    "          child.sourceSpan.end",
                    "        );",
                    "",
                    "        child.condition = ieConditionalStartComment.condition;",
                    "        child.sourceSpan = sourceSpan;",
                    "        child.startSourceSpan = startSourceSpan;",
                    "        child.removeChild(ieConditionalEndComment);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeNodeIntoText(ast, shouldMerge, getValue) {",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "",
                    "        if (child.type !== \"text\" && !shouldMerge(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        if (child.type !== \"text\") {",
                    "          child.type = \"text\";",
                    "          child.value = getValue(child);",
                    "        }",
                    "",
                    "        const prevChild = child.prev;",
                    "        if (!prevChild || prevChild.type !== \"text\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        prevChild.value += child.value;",
                    "        prevChild.sourceSpan = new ParseSourceSpan(",
                    "          prevChild.sourceSpan.start,",
                    "          child.sourceSpan.end",
                    "        );",
                    "",
                    "        node.removeChild(child);",
                    "        i--; // because a node was removed",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeCdataIntoText(ast /*, options */) {",
                    "  return mergeNodeIntoText(",
                    "    ast,",
                    "    (node) => node.type === \"cdata\",",
                    "    (node) => `<![CDATA[${node.value}]]>`",
                    "  );",
                    "}",
                    "",
                    "function mergeSimpleElementIntoText(ast /*, options */) {",
                    "  const isSimpleElement = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.attrs.length === 0 &&",
                    "    node.children.length === 1 &&",
                    "    node.firstChild.type === \"text\" &&",
                    "    !hasHtmlWhitespace(node.children[0].value) &&",
                    "    !node.firstChild.hasLeadingSpaces &&",
                    "    !node.firstChild.hasTrailingSpaces &&",
                    "    node.isLeadingSpaceSensitive &&",
                    "    !node.hasLeadingSpaces &&",
                    "    node.isTrailingSpaceSensitive &&",
                    "    !node.hasTrailingSpaces &&",
                    "    node.prev &&",
                    "    node.prev.type === \"text\" &&",
                    "    node.next &&",
                    "    node.next.type === \"text\";",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (!isSimpleElement(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const prevChild = child.prev;",
                    "        const nextChild = child.next;",
                    "        prevChild.value +=",
                    "          `<${child.rawName}>` +",
                    "          child.firstChild.value +",
                    "          `</${child.rawName}>` +",
                    "          nextChild.value;",
                    "        prevChild.sourceSpan = new ParseSourceSpan(",
                    "          prevChild.sourceSpan.start,",
                    "          nextChild.sourceSpan.end",
                    "        );",
                    "        prevChild.isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive;",
                    "        prevChild.hasTrailingSpaces = nextChild.hasTrailingSpaces;",
                    "",
                    "        node.removeChild(child);",
                    "        i--; // because a node was removed",
                    "        node.removeChild(nextChild);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function extractInterpolation(ast, options) {",
                    "  if (options.parser === \"html\") {",
                    "    return;",
                    "  }",
                    "",
                    "  const interpolationRegex = /{{(.+?)}}/s;",
                    "  ast.walk((node) => {",
                    "    if (!canHaveInterpolation(node)) {",
                    "      return;",
                    "    }",
                    "",
                    "    for (const child of node.children) {",
                    "      if (child.type !== \"text\") {",
                    "        continue;",
                    "      }",
                    "",
                    "      let startSourceSpan = child.sourceSpan.start;",
                    "      let endSourceSpan = null;",
                    "      const components = child.value.split(interpolationRegex);",
                    "      for (",
                    "        let i = 0;",
                    "        i < components.length;",
                    "        i++, startSourceSpan = endSourceSpan",
                    "      ) {",
                    "        const value = components[i];",
                    "",
                    "        if (i % 2 === 0) {",
                    "          endSourceSpan = startSourceSpan.moveBy(value.length);",
                    "          if (value.length > 0) {",
                    "            node.insertChildBefore(child, {",
                    "              type: \"text\",",
                    "              value,",
                    "              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "            });",
                    "          }",
                    "          continue;",
                    "        }",
                    "",
                    "        endSourceSpan = startSourceSpan.moveBy(value.length + 4); // `{{` + `}}`",
                    "        node.insertChildBefore(child, {",
                    "          type: \"interpolation\",",
                    "          sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "          children:",
                    "            value.length === 0",
                    "              ? []",
                    "              : [",
                    "                  {",
                    "                    type: \"text\",",
                    "                    value,",
                    "                    sourceSpan: new ParseSourceSpan(",
                    "                      startSourceSpan.moveBy(2),",
                    "                      endSourceSpan.moveBy(-2)",
                    "                    ),",
                    "                  },",
                    "                ],",
                    "        });",
                    "      }",
                    "",
                    "      node.removeChild(child);",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * - add `hasLeadingSpaces` field",
                    " * - add `hasTrailingSpaces` field",
                    " * - add `hasDanglingSpaces` field for parent nodes",
                    " * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes",
                    " * - remove insensitive whitespaces",
                    " */",
                    "function extractWhitespaces(ast /*, options*/) {",
                    "  ast.walk((node) => {",
                    "    if (!node.children) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (",
                    "      node.children.length === 0 ||",
                    "      (node.children.length === 1 &&",
                    "        node.children[0].type === \"text\" &&",
                    "        htmlTrim(node.children[0].value).length === 0)",
                    "    ) {",
                    "      node.hasDanglingSpaces = node.children.length > 0;",
                    "      node.children = [];",
                    "      return;",
                    "    }",
                    "",
                    "    const isWhitespaceSensitive = isWhitespaceSensitiveNode(node);",
                    "    const isIndentationSensitive = isIndentationSensitiveNode(node);",
                    "",
                    "    if (!isWhitespaceSensitive) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (child.type !== \"text\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        const { leadingWhitespace, text, trailingWhitespace } =",
                    "          getLeadingAndTrailingHtmlWhitespace(child.value);",
                    "",
                    "        const prevChild = child.prev;",
                    "        const nextChild = child.next;",
                    "",
                    "        if (!text) {",
                    "          node.removeChild(child);",
                    "          i--; // because a node was removed",
                    "",
                    "          if (leadingWhitespace || trailingWhitespace) {",
                    "            if (prevChild) {",
                    "              prevChild.hasTrailingSpaces = true;",
                    "            }",
                    "            if (nextChild) {",
                    "              nextChild.hasLeadingSpaces = true;",
                    "            }",
                    "          }",
                    "        } else {",
                    "          child.value = text;",
                    "          child.sourceSpan = new ParseSourceSpan(",
                    "            child.sourceSpan.start.moveBy(leadingWhitespace.length),",
                    "            child.sourceSpan.end.moveBy(-trailingWhitespace.length)",
                    "          );",
                    "",
                    "          if (leadingWhitespace) {",
                    "            if (prevChild) {",
                    "              prevChild.hasTrailingSpaces = true;",
                    "            }",
                    "            child.hasLeadingSpaces = true;",
                    "          }",
                    "          if (trailingWhitespace) {",
                    "            child.hasTrailingSpaces = true;",
                    "            if (nextChild) {",
                    "              nextChild.hasLeadingSpaces = true;",
                    "            }",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    node.isWhitespaceSensitive = isWhitespaceSensitive;",
                    "    node.isIndentationSensitive = isIndentationSensitive;",
                    "  });",
                    "}",
                    "",
                    "function addIsSelfClosing(ast /*, options */) {",
                    "  ast.walk((node) => {",
                    "    node.isSelfClosing =",
                    "      !node.children ||",
                    "      (node.type === \"element\" &&",
                    "        (node.tagDefinition.isVoid ||",
                    "          // self-closing",
                    "          node.startSourceSpan === node.endSourceSpan));",
                    "  });",
                    "}",
                    "",
                    "function addHasHtmComponentClosingTag(ast, options) {",
                    "  ast.walk((node) => {",
                    "    if (node.type !== \"element\") {",
                    "      return;",
                    "    }",
                    "",
                    "    node.hasHtmComponentClosingTag =",
                    "      node.endSourceSpan &&",
                    "      /^<\\s*\\/\\s*\\/\\s*>$/.test(",
                    "        options.originalText.slice(",
                    "          node.endSourceSpan.start.offset,",
                    "          node.endSourceSpan.end.offset",
                    "        )",
                    "      );",
                    "  });",
                    "}",
                    "",
                    "function addCssDisplay(ast, options) {",
                    "  ast.walk((node) => {",
                    "    node.cssDisplay = getNodeCssStyleDisplay(node, options);",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * - add `isLeadingSpaceSensitive` field",
                    " * - add `isTrailingSpaceSensitive` field",
                    " * - add `isDanglingSpaceSensitive` field for parent nodes",
                    " */",
                    "function addIsSpaceSensitive(ast, options) {",
                    "  ast.walk((node) => {",
                    "    const { children } = node;",
                    "    if (!children) {",
                    "      return;",
                    "    }",
                    "    if (children.length === 0) {",
                    "      node.isDanglingSpaceSensitive = isDanglingSpaceSensitiveNode(node);",
                    "      return;",
                    "    }",
                    "    for (const child of children) {",
                    "      child.isLeadingSpaceSensitive = isLeadingSpaceSensitiveNode(",
                    "        child,",
                    "        options",
                    "      );",
                    "      child.isTrailingSpaceSensitive = isTrailingSpaceSensitiveNode(",
                    "        child,",
                    "        options",
                    "      );",
                    "    }",
                    "    for (let index = 0; index < children.length; index++) {",
                    "      const child = children[index];",
                    "      child.isLeadingSpaceSensitive =",
                    "        index === 0",
                    "          ? child.isLeadingSpaceSensitive",
                    "          : child.prev.isTrailingSpaceSensitive &&",
                    "            child.isLeadingSpaceSensitive;",
                    "      child.isTrailingSpaceSensitive =",
                    "        index === children.length - 1",
                    "          ? child.isTrailingSpaceSensitive",
                    "          : child.next.isLeadingSpaceSensitive &&",
                    "            child.isTrailingSpaceSensitive;",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * @typedef {import(\"../document\").Doc} Doc",
                    " */",
                    "",
                    "const {",
                    "  builders: { fill, group, hardline, literalline },",
                    "  utils: { cleanDoc, getDocParts, isConcat, replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const {",
                    "  countChars,",
                    "  unescapeQuoteEntities,",
                    "  getTextValueParts,",
                    "} = require(\"./utils.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const {",
                    "  printClosingTagSuffix,",
                    "  printClosingTagEnd,",
                    "  printOpeningTagPrefix,",
                    "  printOpeningTagStart,",
                    "} = require(\"./print/tag.js\");",
                    "const { printElement } = require(\"./print/element.js\");",
                    "const { printChildren } = require(\"./print/children.js\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return replaceTextEndOfLine(node.raw);",
                    "    case \"root\":",
                    "      if (options.__onHtmlRoot) {",
                    "        options.__onHtmlRoot(node);",
                    "      }",
                    "      // use original concat to not break stripTrailingHardline",
                    "      return [group(printChildren(path, options, print)), hardline];",
                    "    case \"element\":",
                    "    case \"ieConditionalComment\": {",
                    "      return printElement(path, options, print);",
                    "    }",
                    "    case \"ieConditionalStartComment\":",
                    "    case \"ieConditionalEndComment\":",
                    "      return [printOpeningTagStart(node), printClosingTagEnd(node)];",
                    "    case \"interpolation\":",
                    "      return [",
                    "        printOpeningTagStart(node, options),",
                    "        ...path.map(print, \"children\"),",
                    "        printClosingTagEnd(node, options),",
                    "      ];",
                    "    case \"text\": {",
                    "      if (node.parent.type === \"interpolation\") {",
                    "        // replace the trailing literalline with hardline for better readability",
                    "        const trailingNewlineRegex = /\\n[^\\S\\n]*$/;",
                    "        const hasTrailingNewline = trailingNewlineRegex.test(node.value);",
                    "        const value = hasTrailingNewline",
                    "          ? node.value.replace(trailingNewlineRegex, \"\")",
                    "          : node.value;",
                    "        return [",
                    "          ...replaceTextEndOfLine(value),",
                    "          hasTrailingNewline ? hardline : \"\",",
                    "        ];",
                    "      }",
                    "",
                    "      const printed = cleanDoc([",
                    "        printOpeningTagPrefix(node, options),",
                    "        ...getTextValueParts(node),",
                    "        printClosingTagSuffix(node, options),",
                    "      ]);",
                    "      if (isConcat(printed) || printed.type === \"fill\") {",
                    "        return fill(getDocParts(printed));",
                    "      }",
                    "      /* istanbul ignore next */",
                    "      return printed;",
                    "    }",
                    "    case \"docType\":",
                    "      return [",
                    "        group([",
                    "          printOpeningTagStart(node, options),",
                    "          \" \",",
                    "          node.value.replace(/^html\\b/i, \"html\").replace(/\\s+/g, \" \"),",
                    "        ]),",
                    "        printClosingTagEnd(node, options),",
                    "      ];",
                    "    case \"comment\": {",
                    "      return [",
                    "        printOpeningTagPrefix(node, options),",
                    "        ...replaceTextEndOfLine(",
                    "          options.originalText.slice(locStart(node), locEnd(node)),",
                    "          literalline",
                    "        ),",
                    "        printClosingTagSuffix(node, options),",
                    "      ];",
                    "    }",
                    "    case \"attribute\": {",
                    "      if (node.value === null) {",
                    "        return node.rawName;",
                    "      }",
                    "      const value = unescapeQuoteEntities(node.value);",
                    "      const singleQuoteCount = countChars(value, \"'\");",
                    "      const doubleQuoteCount = countChars(value, '\"');",
                    "      const quote = singleQuoteCount < doubleQuoteCount ? \"'\" : '\"';",
                    "      return [",
                    "        node.rawName,",
                    "",
                    "        \"=\",",
                    "        quote,",
                    "",
                    "        ...replaceTextEndOfLine(",
                    "          quote === '\"'",
                    "            ? value.replace(/\"/g, \"&quot;\")",
                    "            : value.replace(/'/g, \"&apos;\")",
                    "        ),",
                    "        quote,",
                    "      ];",
                    "    }",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unexpected node type ${node.type}`);",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  embed,",
                    "};"
                ]
            },
            "syntax-attribute.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const parseSrcset = require(\"parse-srcset\");",
                    "const {",
                    "  builders: { ifBreak, join, line },",
                    "} = require(\"../document/index.js\");",
                    "",
                    "function printImgSrcset(value) {",
                    "  const srcset = parseSrcset(value, {",
                    "    logger: {",
                    "      error(message) {",
                    "        throw new Error(message);",
                    "      },",
                    "    },",
                    "  });",
                    "",
                    "  const hasW = srcset.some(({ w }) => w);",
                    "  const hasH = srcset.some(({ h }) => h);",
                    "  const hasX = srcset.some(({ d }) => d);",
                    "",
                    "  if (hasW + hasH + hasX > 1) {",
                    "    throw new Error(\"Mixed descriptor in srcset is not supported\");",
                    "  }",
                    "",
                    "  const key = hasW ? \"w\" : hasH ? \"h\" : \"d\";",
                    "  const unit = hasW ? \"w\" : hasH ? \"h\" : \"x\";",
                    "",
                    "  const getMax = (values) => Math.max(...values);",
                    "",
                    "  const urls = srcset.map((src) => src.url);",
                    "  const maxUrlLength = getMax(urls.map((url) => url.length));",
                    "",
                    "  const descriptors = srcset",
                    "    .map((src) => src[key])",
                    "    .map((descriptor) => (descriptor ? descriptor.toString() : \"\"));",
                    "  const descriptorLeftLengths = descriptors.map((descriptor) => {",
                    "    const index = descriptor.indexOf(\".\");",
                    "    return index === -1 ? descriptor.length : index;",
                    "  });",
                    "  const maxDescriptorLeftLength = getMax(descriptorLeftLengths);",
                    "",
                    "  return join(",
                    "    [\",\", line],",
                    "    urls.map((url, index) => {",
                    "      const parts = [url];",
                    "",
                    "      const descriptor = descriptors[index];",
                    "      if (descriptor) {",
                    "        const urlPadding = maxUrlLength - url.length + 1;",
                    "        const descriptorPadding =",
                    "          maxDescriptorLeftLength - descriptorLeftLengths[index];",
                    "",
                    "        const alignment = \" \".repeat(urlPadding + descriptorPadding);",
                    "        parts.push(ifBreak(alignment, \" \"), descriptor + unit);",
                    "      }",
                    "",
                    "      return parts;",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function printClassNames(value) {",
                    "  return value.trim().split(/\\s+/).join(\" \");",
                    "}",
                    "",
                    "module.exports = {",
                    "  printImgSrcset,",
                    "  printClassNames,",
                    "};"
                ]
            },
            "syntax-vue.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { group },",
                    "} = require(\"../document/index.js\");",
                    "",
                    "/**",
                    " *     v-for=\"... in ...\"",
                    " *     v-for=\"... of ...\"",
                    " *     v-for=\"(..., ...) in ...\"",
                    " *     v-for=\"(..., ...) of ...\"",
                    " */",
                    "function printVueFor(value, textToDoc) {",
                    "  const { left, operator, right } = parseVueFor(value);",
                    "  return [",
                    "    group(",
                    "      textToDoc(`function _(${left}) {}`, {",
                    "        parser: \"babel\",",
                    "        __isVueForBindingLeft: true,",
                    "      })",
                    "    ),",
                    "    \" \",",
                    "    operator,",
                    "    \" \",",
                    "    textToDoc(",
                    "      right,",
                    "      { parser: \"__js_expression\" },",
                    "      { stripTrailingHardline: true }",
                    "    ),",
                    "  ];",
                    "}",
                    "",
                    "// modified from https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/parser/index.js#L370-L387",
                    "function parseVueFor(value) {",
                    "  const forAliasRE = /(.*?)\\s+(in|of)\\s+(.*)/s;",
                    "  const forIteratorRE = /,([^,\\]}]*)(?:,([^,\\]}]*))?$/;",
                    "  const stripParensRE = /^\\(|\\)$/g;",
                    "",
                    "  const inMatch = value.match(forAliasRE);",
                    "  if (!inMatch) {",
                    "    return;",
                    "  }",
                    "",
                    "  const res = {};",
                    "  res.for = inMatch[3].trim();",
                    "  if (!res.for) {",
                    "    return;",
                    "  }",
                    "",
                    "  const alias = inMatch[1].trim().replace(stripParensRE, \"\");",
                    "  const iteratorMatch = alias.match(forIteratorRE);",
                    "  if (iteratorMatch) {",
                    "    res.alias = alias.replace(forIteratorRE, \"\");",
                    "    res.iterator1 = iteratorMatch[1].trim();",
                    "    if (iteratorMatch[2]) {",
                    "      res.iterator2 = iteratorMatch[2].trim();",
                    "    }",
                    "  } else {",
                    "    res.alias = alias;",
                    "  }",
                    "",
                    "  const left = [res.alias, res.iterator1, res.iterator2];",
                    "  if (",
                    "    left.some(",
                    "      (part, index) =>",
                    "        !part && (index === 0 || left.slice(index + 1).some(Boolean))",
                    "    )",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  return {",
                    "    left: left.filter(Boolean).join(\",\"),",
                    "    operator: inMatch[2],",
                    "    right: res.for,",
                    "  };",
                    "}",
                    "",
                    "function printVueBindings(value, textToDoc) {",
                    "  return textToDoc(`function _(${value}) {}`, {",
                    "    parser: \"babel\",",
                    "    __isVueBindings: true,",
                    "  });",
                    "}",
                    "",
                    "function isVueEventBindingExpression(eventBindingValue) {",
                    "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/codegen/events.js#L3-L4",
                    "  // arrow function or anonymous function",
                    "  const fnExpRE = /^(?:[\\w$]+|\\([^)]*\\))\\s*=>|^function\\s*\\(/;",
                    "  // simple member expression chain (a, a.b, a['b'], a[\"b\"], a[0], a[b])",
                    "  const simplePathRE =",
                    "    /^[$A-Z_a-z][\\w$]*(?:\\.[$A-Z_a-z][\\w$]*|\\['[^']*']|\\[\"[^\"]*\"]|\\[\\d+]|\\[[$A-Z_a-z][\\w$]*])*$/;",
                    "",
                    "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/helpers.js#L104",
                    "  const value = eventBindingValue.trim();",
                    "",
                    "  return fnExpRE.test(value) || simplePathRE.test(value);",
                    "}",
                    "",
                    "module.exports = {",
                    "  isVueEventBindingExpression,",
                    "  printVueFor,",
                    "  printVueBindings,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * @typedef {import(\"../common/ast-path\")} AstPath",
                    " */",
                    "",
                    "const htmlTagNames = require(\"html-tag-names\");",
                    "const htmlElementAttributes = require(\"html-element-attributes\");",
                    "const {",
                    "  inferParserByLanguage,",
                    "  isFrontMatterNode,",
                    "} = require(\"../common/util.js\");",
                    "const {",
                    "  builders: { line, hardline, join },",
                    "  utils: { getDocParts, replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const {",
                    "  CSS_DISPLAY_TAGS,",
                    "  CSS_DISPLAY_DEFAULT,",
                    "  CSS_WHITE_SPACE_TAGS,",
                    "  CSS_WHITE_SPACE_DEFAULT,",
                    "} = require(\"./constants.evaluate.js\");",
                    "",
                    "const HTML_TAGS = arrayToMap(htmlTagNames);",
                    "const HTML_ELEMENT_ATTRIBUTES = mapObject(htmlElementAttributes, arrayToMap);",
                    "",
                    "// https://infra.spec.whatwg.org/#ascii-whitespace",
                    "const HTML_WHITESPACE = new Set([\"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"]);",
                    "const htmlTrimStart = (string) => string.replace(/^[\\t\\n\\f\\r ]+/, \"\");",
                    "const htmlTrimEnd = (string) => string.replace(/[\\t\\n\\f\\r ]+$/, \"\");",
                    "const htmlTrim = (string) => htmlTrimStart(htmlTrimEnd(string));",
                    "const htmlTrimLeadingBlankLines = (string) =>",
                    "  string.replace(/^[\\t\\f\\r ]*\\n/g, \"\");",
                    "const htmlTrimPreserveIndentation = (string) =>",
                    "  htmlTrimLeadingBlankLines(htmlTrimEnd(string));",
                    "const splitByHtmlWhitespace = (string) => string.split(/[\\t\\n\\f\\r ]+/);",
                    "const getLeadingHtmlWhitespace = (string) => string.match(/^[\\t\\n\\f\\r ]*/)[0];",
                    "const getLeadingAndTrailingHtmlWhitespace = (string) => {",
                    "  const [, leadingWhitespace, text, trailingWhitespace] = string.match(",
                    "    /^([\\t\\n\\f\\r ]*)(.*?)([\\t\\n\\f\\r ]*)$/s",
                    "  );",
                    "  return {",
                    "    leadingWhitespace,",
                    "    trailingWhitespace,",
                    "    text,",
                    "  };",
                    "};",
                    "const hasHtmlWhitespace = (string) => /[\\t\\n\\f\\r ]/.test(string);",
                    "",
                    "function arrayToMap(array) {",
                    "  const map = Object.create(null);",
                    "  for (const value of array) {",
                    "    map[value] = true;",
                    "  }",
                    "  return map;",
                    "}",
                    "",
                    "function mapObject(object, fn) {",
                    "  const newObject = Object.create(null);",
                    "  for (const [key, value] of Object.entries(object)) {",
                    "    newObject[key] = fn(value, key);",
                    "  }",
                    "  return newObject;",
                    "}",
                    "",
                    "function shouldPreserveContent(node, options) {",
                    "  // unterminated node in ie conditional comment",
                    "  // e.g. <!--[if lt IE 9]><html><![endif]-->",
                    "  if (",
                    "    node.type === \"ieConditionalComment\" &&",
                    "    node.lastChild &&",
                    "    !node.lastChild.isSelfClosing &&",
                    "    !node.lastChild.endSourceSpan",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // incomplete html in ie conditional comment",
                    "  // e.g. <!--[if lt IE 9]></div><![endif]-->",
                    "  if (node.type === \"ieConditionalComment\" && !node.complete) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // TODO: handle non-text children in <pre>",
                    "  if (",
                    "    isPreLikeNode(node) &&",
                    "    node.children.some(",
                    "      (child) => child.type !== \"text\" && child.type !== \"interpolation\"",
                    "    )",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    isVueNonHtmlBlock(node, options) &&",
                    "    !isScriptLikeTag(node) &&",
                    "    node.type !== \"interpolation\"",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function hasPrettierIgnore(node) {",
                    "  /* istanbul ignore next */",
                    "  if (node.type === \"attribute\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (!node.parent) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (!node.prev) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return isPrettierIgnore(node.prev);",
                    "}",
                    "",
                    "function isPrettierIgnore(node) {",
                    "  return node.type === \"comment\" && node.value.trim() === \"prettier-ignore\";",
                    "}",
                    "",
                    "/** there's no opening/closing tag or it's considered not breakable */",
                    "function isTextLikeNode(node) {",
                    "  return node.type === \"text\" || node.type === \"comment\";",
                    "}",
                    "",
                    "function isScriptLikeTag(node) {",
                    "  return (",
                    "    node.type === \"element\" &&",
                    "    (node.fullName === \"script\" ||",
                    "      node.fullName === \"style\" ||",
                    "      node.fullName === \"svg:style\" ||",
                    "      (isUnknownNamespace(node) &&",
                    "        (node.name === \"script\" || node.name === \"style\")))",
                    "  );",
                    "}",
                    "",
                    "function canHaveInterpolation(node) {",
                    "  return node.children && !isScriptLikeTag(node);",
                    "}",
                    "",
                    "function isWhitespaceSensitiveNode(node) {",
                    "  return (",
                    "    isScriptLikeTag(node) ||",
                    "    node.type === \"interpolation\" ||",
                    "    isIndentationSensitiveNode(node)",
                    "  );",
                    "}",
                    "",
                    "function isIndentationSensitiveNode(node) {",
                    "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                    "}",
                    "",
                    "function isLeadingSpaceSensitiveNode(node, options) {",
                    "  const isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();",
                    "",
                    "  if (",
                    "    isLeadingSpaceSensitive &&",
                    "    !node.prev &&",
                    "    node.parent &&",
                    "    node.parent.tagDefinition &&",
                    "    node.parent.tagDefinition.ignoreFirstLf",
                    "  ) {",
                    "    return node.type === \"interpolation\";",
                    "  }",
                    "",
                    "  return isLeadingSpaceSensitive;",
                    "",
                    "  function _isLeadingSpaceSensitiveNode() {",
                    "    if (isFrontMatterNode(node)) {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (",
                    "      (node.type === \"text\" || node.type === \"interpolation\") &&",
                    "      node.prev &&",
                    "      (node.prev.type === \"text\" || node.prev.type === \"interpolation\")",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    if (!node.parent || node.parent.cssDisplay === \"none\") {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (isPreLikeNode(node.parent)) {",
                    "      return true;",
                    "    }",
                    "",
                    "    if (",
                    "      !node.prev &&",
                    "      (node.parent.type === \"root\" ||",
                    "        (isPreLikeNode(node) && node.parent) ||",
                    "        isScriptLikeTag(node.parent) ||",
                    "        isVueCustomBlock(node.parent, options) ||",
                    "        !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (",
                    "      node.prev &&",
                    "      !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function isTrailingSpaceSensitiveNode(node, options) {",
                    "  if (isFrontMatterNode(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    (node.type === \"text\" || node.type === \"interpolation\") &&",
                    "    node.next &&",
                    "    (node.next.type === \"text\" || node.next.type === \"interpolation\")",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (!node.parent || node.parent.cssDisplay === \"none\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (isPreLikeNode(node.parent)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    !node.next &&",
                    "    (node.parent.type === \"root\" ||",
                    "      (isPreLikeNode(node) && node.parent) ||",
                    "      isScriptLikeTag(node.parent) ||",
                    "      isVueCustomBlock(node.parent, options) ||",
                    "      !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    node.next &&",
                    "    !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function isDanglingSpaceSensitiveNode(node) {",
                    "  return (",
                    "    isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) &&",
                    "    !isScriptLikeTag(node)",
                    "  );",
                    "}",
                    "",
                    "function forceNextEmptyLine(node) {",
                    "  return (",
                    "    isFrontMatterNode(node) ||",
                    "    (node.next &&",
                    "      node.sourceSpan.end &&",
                    "      node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line)",
                    "  );",
                    "}",
                    "",
                    "/** firstChild leadingSpaces and lastChild trailingSpaces */",
                    "function forceBreakContent(node) {",
                    "  return (",
                    "    forceBreakChildren(node) ||",
                    "    (node.type === \"element\" &&",
                    "      node.children.length > 0 &&",
                    "      ([\"body\", \"script\", \"style\"].includes(node.name) ||",
                    "        node.children.some((child) => hasNonTextChild(child)))) ||",
                    "    (node.firstChild &&",
                    "      node.firstChild === node.lastChild &&",
                    "      node.firstChild.type !== \"text\" &&",
                    "      hasLeadingLineBreak(node.firstChild) &&",
                    "      (!node.lastChild.isTrailingSpaceSensitive ||",
                    "        hasTrailingLineBreak(node.lastChild)))",
                    "  );",
                    "}",
                    "",
                    "/** spaces between children */",
                    "function forceBreakChildren(node) {",
                    "  return (",
                    "    node.type === \"element\" &&",
                    "    node.children.length > 0 &&",
                    "    ([\"html\", \"head\", \"ul\", \"ol\", \"select\"].includes(node.name) ||",
                    "      (node.cssDisplay.startsWith(\"table\") && node.cssDisplay !== \"table-cell\"))",
                    "  );",
                    "}",
                    "",
                    "function preferHardlineAsLeadingSpaces(node) {",
                    "  return (",
                    "    preferHardlineAsSurroundingSpaces(node) ||",
                    "    (node.prev && preferHardlineAsTrailingSpaces(node.prev)) ||",
                    "    hasSurroundingLineBreak(node)",
                    "  );",
                    "}",
                    "",
                    "function preferHardlineAsTrailingSpaces(node) {",
                    "  return (",
                    "    preferHardlineAsSurroundingSpaces(node) ||",
                    "    (node.type === \"element\" && node.fullName === \"br\") ||",
                    "    hasSurroundingLineBreak(node)",
                    "  );",
                    "}",
                    "",
                    "function hasSurroundingLineBreak(node) {",
                    "  return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);",
                    "}",
                    "",
                    "function hasLeadingLineBreak(node) {",
                    "  return (",
                    "    node.hasLeadingSpaces &&",
                    "    (node.prev",
                    "      ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line",
                    "      : node.parent.type === \"root\" ||",
                    "        node.parent.startSourceSpan.end.line < node.sourceSpan.start.line)",
                    "  );",
                    "}",
                    "",
                    "function hasTrailingLineBreak(node) {",
                    "  return (",
                    "    node.hasTrailingSpaces &&",
                    "    (node.next",
                    "      ? node.next.sourceSpan.start.line > node.sourceSpan.end.line",
                    "      : node.parent.type === \"root\" ||",
                    "        (node.parent.endSourceSpan &&",
                    "          node.parent.endSourceSpan.start.line > node.sourceSpan.end.line))",
                    "  );",
                    "}",
                    "",
                    "function preferHardlineAsSurroundingSpaces(node) {",
                    "  switch (node.type) {",
                    "    case \"ieConditionalComment\":",
                    "    case \"comment\":",
                    "    case \"directive\":",
                    "      return true;",
                    "    case \"element\":",
                    "      return [\"script\", \"select\"].includes(node.name);",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function getLastDescendant(node) {",
                    "  return node.lastChild ? getLastDescendant(node.lastChild) : node;",
                    "}",
                    "",
                    "function hasNonTextChild(node) {",
                    "  return node.children && node.children.some((child) => child.type !== \"text\");",
                    "}",
                    "",
                    "function _inferScriptParser(node) {",
                    "  const { type, lang } = node.attrMap;",
                    "  if (",
                    "    type === \"module\" ||",
                    "    type === \"text/javascript\" ||",
                    "    type === \"text/babel\" ||",
                    "    type === \"application/javascript\" ||",
                    "    lang === \"jsx\"",
                    "  ) {",
                    "    return \"babel\";",
                    "  }",
                    "",
                    "  if (type === \"application/x-typescript\" || lang === \"ts\" || lang === \"tsx\") {",
                    "    return \"typescript\";",
                    "  }",
                    "",
                    "  if (type === \"text/markdown\") {",
                    "    return \"markdown\";",
                    "  }",
                    "",
                    "  if (type === \"text/html\") {",
                    "    return \"html\";",
                    "  }",
                    "",
                    "  if (type && (type.endsWith(\"json\") || type.endsWith(\"importmap\"))) {",
                    "    return \"json\";",
                    "  }",
                    "",
                    "  if (type === \"text/x-handlebars-template\") {",
                    "    return \"glimmer\";",
                    "  }",
                    "}",
                    "",
                    "function inferStyleParser(node) {",
                    "  const { lang } = node.attrMap;",
                    "  if (!lang || lang === \"postcss\" || lang === \"css\") {",
                    "    return \"css\";",
                    "  }",
                    "",
                    "  if (lang === \"scss\") {",
                    "    return \"scss\";",
                    "  }",
                    "",
                    "  if (lang === \"less\") {",
                    "    return \"less\";",
                    "  }",
                    "}",
                    "",
                    "function inferScriptParser(node, options) {",
                    "  if (node.name === \"script\" && !node.attrMap.src) {",
                    "    if (!node.attrMap.lang && !node.attrMap.type) {",
                    "      return \"babel\";",
                    "    }",
                    "    return _inferScriptParser(node);",
                    "  }",
                    "",
                    "  if (node.name === \"style\") {",
                    "    return inferStyleParser(node);",
                    "  }",
                    "",
                    "  if (options && isVueNonHtmlBlock(node, options)) {",
                    "    return (",
                    "      _inferScriptParser(node) ||",
                    "      (!(\"src\" in node.attrMap) &&",
                    "        inferParserByLanguage(node.attrMap.lang, options))",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function isBlockLikeCssDisplay(cssDisplay) {",
                    "  return (",
                    "    cssDisplay === \"block\" ||",
                    "    cssDisplay === \"list-item\" ||",
                    "    cssDisplay.startsWith(\"table\")",
                    "  );",
                    "}",
                    "",
                    "function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                    "}",
                    "",
                    "function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                    "}",
                    "",
                    "function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay);",
                    "}",
                    "",
                    "function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay);",
                    "}",
                    "",
                    "function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {",
                    "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                    "}",
                    "",
                    "function isPreLikeNode(node) {",
                    "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                    "}",
                    "",
                    "/**",
                    " * @param {AstPath} path",
                    " * @param {(any) => boolean} predicate",
                    " */",
                    "function countParents(path, predicate) {",
                    "  let counter = 0;",
                    "  for (let i = path.stack.length - 1; i >= 0; i--) {",
                    "    const value = path.stack[i];",
                    "    if (",
                    "      value &&",
                    "      typeof value === \"object\" &&",
                    "      !Array.isArray(value) &&",
                    "      predicate(value)",
                    "    ) {",
                    "      counter++;",
                    "    }",
                    "  }",
                    "  return counter;",
                    "}",
                    "",
                    "function hasParent(node, fn) {",
                    "  let current = node;",
                    "",
                    "  while (current) {",
                    "    if (fn(current)) {",
                    "      return true;",
                    "    }",
                    "",
                    "    current = current.parent;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function getNodeCssStyleDisplay(node, options) {",
                    "  if (node.prev && node.prev.type === \"comment\") {",
                    "    // <!-- display: block -->",
                    "    const match = node.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);",
                    "    if (match) {",
                    "      return match[1];",
                    "    }",
                    "  }",
                    "",
                    "  let isInSvgForeignObject = false;",
                    "  if (node.type === \"element\" && node.namespace === \"svg\") {",
                    "    if (hasParent(node, (parent) => parent.fullName === \"svg:foreignObject\")) {",
                    "      isInSvgForeignObject = true;",
                    "    } else {",
                    "      return node.name === \"svg\" ? \"inline-block\" : \"block\";",
                    "    }",
                    "  }",
                    "",
                    "  switch (options.htmlWhitespaceSensitivity) {",
                    "    case \"strict\":",
                    "      return \"inline\";",
                    "    case \"ignore\":",
                    "      return \"block\";",
                    "    default: {",
                    "      // See https://github.com/prettier/prettier/issues/8151",
                    "      if (",
                    "        options.parser === \"vue\" &&",
                    "        node.parent &&",
                    "        node.parent.type === \"root\"",
                    "      ) {",
                    "        return \"block\";",
                    "      }",
                    "      return (",
                    "        (node.type === \"element\" &&",
                    "          (!node.namespace ||",
                    "            isInSvgForeignObject ||",
                    "            isUnknownNamespace(node)) &&",
                    "          CSS_DISPLAY_TAGS[node.name]) ||",
                    "        CSS_DISPLAY_DEFAULT",
                    "      );",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function isUnknownNamespace(node) {",
                    "  return (",
                    "    node.type === \"element\" &&",
                    "    !node.hasExplicitNamespace &&",
                    "    ![\"html\", \"svg\"].includes(node.namespace)",
                    "  );",
                    "}",
                    "",
                    "function getNodeCssStyleWhiteSpace(node) {",
                    "  return (",
                    "    (node.type === \"element\" &&",
                    "      (!node.namespace || isUnknownNamespace(node)) &&",
                    "      CSS_WHITE_SPACE_TAGS[node.name]) ||",
                    "    CSS_WHITE_SPACE_DEFAULT",
                    "  );",
                    "}",
                    "",
                    "function getMinIndentation(text) {",
                    "  let minIndentation = Number.POSITIVE_INFINITY;",
                    "",
                    "  for (const lineText of text.split(\"\\n\")) {",
                    "    if (lineText.length === 0) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (!HTML_WHITESPACE.has(lineText[0])) {",
                    "      return 0;",
                    "    }",
                    "",
                    "    const indentation = getLeadingHtmlWhitespace(lineText).length;",
                    "",
                    "    if (lineText.length === indentation) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (indentation < minIndentation) {",
                    "      minIndentation = indentation;",
                    "    }",
                    "  }",
                    "",
                    "  return minIndentation === Number.POSITIVE_INFINITY ? 0 : minIndentation;",
                    "}",
                    "",
                    "function dedentString(text, minIndent = getMinIndentation(text)) {",
                    "  return minIndent === 0",
                    "    ? text",
                    "    : text",
                    "        .split(\"\\n\")",
                    "        .map((lineText) => lineText.slice(minIndent))",
                    "        .join(\"\\n\");",
                    "}",
                    "",
                    "function countChars(text, char) {",
                    "  let counter = 0;",
                    "  for (let i = 0; i < text.length; i++) {",
                    "    if (text[i] === char) {",
                    "      counter++;",
                    "    }",
                    "  }",
                    "  return counter;",
                    "}",
                    "",
                    "function unescapeQuoteEntities(text) {",
                    "  return text.replace(/&apos;/g, \"'\").replace(/&quot;/g, '\"');",
                    "}",
                    "",
                    "// top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block",
                    "// See https://vue-loader.vuejs.org/spec.html for detail",
                    "const vueRootElementsSet = new Set([\"template\", \"style\", \"script\"]);",
                    "function isVueCustomBlock(node, options) {",
                    "  return isVueSfcBlock(node, options) && !vueRootElementsSet.has(node.fullName);",
                    "}",
                    "",
                    "function isVueSfcBlock(node, options) {",
                    "  return (",
                    "    options.parser === \"vue\" &&",
                    "    node.type === \"element\" &&",
                    "    node.parent.type === \"root\" &&",
                    "    node.fullName.toLowerCase() !== \"html\"",
                    "  );",
                    "}",
                    "",
                    "function isVueNonHtmlBlock(node, options) {",
                    "  return (",
                    "    isVueSfcBlock(node, options) &&",
                    "    (isVueCustomBlock(node, options) ||",
                    "      (node.attrMap.lang && node.attrMap.lang !== \"html\"))",
                    "  );",
                    "}",
                    "",
                    "function isVueSlotAttribute(attribute) {",
                    "  const attributeName = attribute.fullName;",
                    "  return (",
                    "    attributeName.charAt(0) === \"#\" ||",
                    "    attributeName === \"slot-scope\" ||",
                    "    attributeName === \"v-slot\" ||",
                    "    attributeName.startsWith(\"v-slot:\")",
                    "  );",
                    "}",
                    "",
                    "function isVueSfcBindingsAttribute(attribute, options) {",
                    "  const element = attribute.parent;",
                    "  if (!isVueSfcBlock(element, options)) {",
                    "    return false;",
                    "  }",
                    "  const tagName = element.fullName;",
                    "  const attributeName = attribute.fullName;",
                    "",
                    "  return (",
                    "    // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-script-setup.md",
                    "    (tagName === \"script\" && attributeName === \"setup\") ||",
                    "    // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-style-variables.md",
                    "    (tagName === \"style\" && attributeName === \"vars\")",
                    "  );",
                    "}",
                    "",
                    "function getTextValueParts(node, value = node.value) {",
                    "  return node.parent.isWhitespaceSensitive",
                    "    ? node.parent.isIndentationSensitive",
                    "      ? replaceTextEndOfLine(value)",
                    "      : replaceTextEndOfLine(",
                    "          dedentString(htmlTrimPreserveIndentation(value)),",
                    "          hardline",
                    "        )",
                    "    : getDocParts(join(line, splitByHtmlWhitespace(value)));",
                    "}",
                    "",
                    "module.exports = {",
                    "  HTML_ELEMENT_ATTRIBUTES,",
                    "  HTML_TAGS,",
                    "  htmlTrim,",
                    "  htmlTrimPreserveIndentation,",
                    "  hasHtmlWhitespace,",
                    "  getLeadingAndTrailingHtmlWhitespace,",
                    "  canHaveInterpolation,",
                    "  countChars,",
                    "  countParents,",
                    "  dedentString,",
                    "  forceBreakChildren,",
                    "  forceBreakContent,",
                    "  forceNextEmptyLine,",
                    "  getLastDescendant,",
                    "  getNodeCssStyleDisplay,",
                    "  getNodeCssStyleWhiteSpace,",
                    "  hasPrettierIgnore,",
                    "  inferScriptParser,",
                    "  isVueCustomBlock,",
                    "  isVueNonHtmlBlock,",
                    "  isVueSlotAttribute,",
                    "  isVueSfcBindingsAttribute,",
                    "  isDanglingSpaceSensitiveNode,",
                    "  isIndentationSensitiveNode,",
                    "  isLeadingSpaceSensitiveNode,",
                    "  isPreLikeNode,",
                    "  isScriptLikeTag,",
                    "  isTextLikeNode,",
                    "  isTrailingSpaceSensitiveNode,",
                    "  isWhitespaceSensitiveNode,",
                    "  isUnknownNamespace,",
                    "  preferHardlineAsLeadingSpaces,",
                    "  preferHardlineAsTrailingSpaces,",
                    "  shouldPreserveContent,",
                    "  unescapeQuoteEntities,",
                    "  getTextValueParts,",
                    "};"
                ]
            },
            "print": {
                "children.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { breakParent, group, ifBreak, line, softline, hardline },",
                        "  utils: { replaceTextEndOfLine },",
                        "} = require(\"../../document/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const {",
                        "  forceBreakChildren,",
                        "  forceNextEmptyLine,",
                        "  isTextLikeNode,",
                        "  hasPrettierIgnore,",
                        "  preferHardlineAsLeadingSpaces,",
                        "} = require(\"../utils.js\");",
                        "const {",
                        "  printOpeningTagPrefix,",
                        "  needsToBorrowNextOpeningTagStartMarker,",
                        "  printOpeningTagStartMarker,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  printClosingTagEndMarker,",
                        "  printClosingTagSuffix,",
                        "  needsToBorrowParentClosingTagStartMarker,",
                        "} = require(\"./tag.js\");",
                        "",
                        "function printChild(childPath, options, print) {",
                        "  const child = childPath.getValue();",
                        "",
                        "  if (hasPrettierIgnore(child)) {",
                        "    return [",
                        "      printOpeningTagPrefix(child, options),",
                        "      ...replaceTextEndOfLine(",
                        "        options.originalText.slice(",
                        "          locStart(child) +",
                        "            (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev)",
                        "              ? printOpeningTagStartMarker(child).length",
                        "              : 0),",
                        "          locEnd(child) -",
                        "            (child.next && needsToBorrowPrevClosingTagEndMarker(child.next)",
                        "              ? printClosingTagEndMarker(child, options).length",
                        "              : 0)",
                        "        )",
                        "      ),",
                        "      printClosingTagSuffix(child, options),",
                        "    ];",
                        "  }",
                        "",
                        "  return print();",
                        "}",
                        "",
                        "function printBetweenLine(prevNode, nextNode) {",
                        "  return isTextLikeNode(prevNode) && isTextLikeNode(nextNode)",
                        "    ? prevNode.isTrailingSpaceSensitive",
                        "      ? prevNode.hasTrailingSpaces",
                        "        ? preferHardlineAsLeadingSpaces(nextNode)",
                        "          ? hardline",
                        "          : line",
                        "        : \"\"",
                        "      : preferHardlineAsLeadingSpaces(nextNode)",
                        "      ? hardline",
                        "      : softline",
                        "    : (needsToBorrowNextOpeningTagStartMarker(prevNode) &&",
                        "        (hasPrettierIgnore(nextNode) ||",
                        "          /**",
                        "           *     123<a",
                        "           *          ~",
                        "           *       ><b>",
                        "           */",
                        "          nextNode.firstChild ||",
                        "          /**",
                        "           *     123<!--",
                        "           *            ~",
                        "           *     -->",
                        "           */",
                        "          nextNode.isSelfClosing ||",
                        "          /**",
                        "           *     123<span",
                        "           *             ~",
                        "           *       attr",
                        "           */",
                        "          (nextNode.type === \"element\" && nextNode.attrs.length > 0))) ||",
                        "      /**",
                        "       *     <img",
                        "       *       src=\"long\"",
                        "       *                 ~",
                        "       *     />123",
                        "       */",
                        "      (prevNode.type === \"element\" &&",
                        "        prevNode.isSelfClosing &&",
                        "        needsToBorrowPrevClosingTagEndMarker(nextNode))",
                        "    ? \"\"",
                        "    : !nextNode.isLeadingSpaceSensitive ||",
                        "      preferHardlineAsLeadingSpaces(nextNode) ||",
                        "      /**",
                        "       *       Want to write us a letter? Use our<a",
                        "       *         ><b><a>mailing address</a></b></a",
                        "       *                                          ~",
                        "       *       >.",
                        "       */",
                        "      (needsToBorrowPrevClosingTagEndMarker(nextNode) &&",
                        "        prevNode.lastChild &&",
                        "        needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) &&",
                        "        prevNode.lastChild.lastChild &&",
                        "        needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild))",
                        "    ? hardline",
                        "    : nextNode.hasLeadingSpaces",
                        "    ? line",
                        "    : softline;",
                        "}",
                        "",
                        "function printChildren(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (forceBreakChildren(node)) {",
                        "    return [",
                        "      breakParent,",
                        "",
                        "      ...path.map((childPath) => {",
                        "        const childNode = childPath.getValue();",
                        "        const prevBetweenLine = !childNode.prev",
                        "          ? \"\"",
                        "          : printBetweenLine(childNode.prev, childNode);",
                        "        return [",
                        "          !prevBetweenLine",
                        "            ? \"\"",
                        "            : [",
                        "                prevBetweenLine,",
                        "                forceNextEmptyLine(childNode.prev) ? hardline : \"\",",
                        "              ],",
                        "          printChild(childPath, options, print),",
                        "        ];",
                        "      }, \"children\"),",
                        "    ];",
                        "  }",
                        "",
                        "  const groupIds = node.children.map(() => Symbol(\"\"));",
                        "  return path.map((childPath, childIndex) => {",
                        "    const childNode = childPath.getValue();",
                        "",
                        "    if (isTextLikeNode(childNode)) {",
                        "      if (childNode.prev && isTextLikeNode(childNode.prev)) {",
                        "        const prevBetweenLine = printBetweenLine(childNode.prev, childNode);",
                        "        if (prevBetweenLine) {",
                        "          if (forceNextEmptyLine(childNode.prev)) {",
                        "            return [hardline, hardline, printChild(childPath, options, print)];",
                        "          }",
                        "          return [prevBetweenLine, printChild(childPath, options, print)];",
                        "        }",
                        "      }",
                        "      return printChild(childPath, options, print);",
                        "    }",
                        "",
                        "    const prevParts = [];",
                        "    const leadingParts = [];",
                        "    const trailingParts = [];",
                        "    const nextParts = [];",
                        "",
                        "    const prevBetweenLine = childNode.prev",
                        "      ? printBetweenLine(childNode.prev, childNode)",
                        "      : \"\";",
                        "",
                        "    const nextBetweenLine = childNode.next",
                        "      ? printBetweenLine(childNode, childNode.next)",
                        "      : \"\";",
                        "",
                        "    if (prevBetweenLine) {",
                        "      if (forceNextEmptyLine(childNode.prev)) {",
                        "        prevParts.push(hardline, hardline);",
                        "      } else if (prevBetweenLine === hardline) {",
                        "        prevParts.push(hardline);",
                        "      } else {",
                        "        if (isTextLikeNode(childNode.prev)) {",
                        "          leadingParts.push(prevBetweenLine);",
                        "        } else {",
                        "          leadingParts.push(",
                        "            ifBreak(\"\", softline, {",
                        "              groupId: groupIds[childIndex - 1],",
                        "            })",
                        "          );",
                        "        }",
                        "      }",
                        "    }",
                        "",
                        "    if (nextBetweenLine) {",
                        "      if (forceNextEmptyLine(childNode)) {",
                        "        if (isTextLikeNode(childNode.next)) {",
                        "          nextParts.push(hardline, hardline);",
                        "        }",
                        "      } else if (nextBetweenLine === hardline) {",
                        "        if (isTextLikeNode(childNode.next)) {",
                        "          nextParts.push(hardline);",
                        "        }",
                        "      } else {",
                        "        trailingParts.push(nextBetweenLine);",
                        "      }",
                        "    }",
                        "",
                        "    return [",
                        "      ...prevParts,",
                        "      group([",
                        "        ...leadingParts,",
                        "        group([printChild(childPath, options, print), ...trailingParts], {",
                        "          id: groupIds[childIndex],",
                        "        }),",
                        "      ]),",
                        "      ...nextParts,",
                        "    ];",
                        "  }, \"children\");",
                        "}",
                        "",
                        "module.exports = { printChildren };"
                    ]
                },
                "element.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: {",
                        "    breakParent,",
                        "    dedentToRoot,",
                        "    group,",
                        "    ifBreak,",
                        "    indentIfBreak,",
                        "    indent,",
                        "    line,",
                        "    softline,",
                        "  },",
                        "  utils: { replaceTextEndOfLine },",
                        "} = require(\"../../document/index.js\");",
                        "const getNodeContent = require(\"../get-node-content.js\");",
                        "const {",
                        "  shouldPreserveContent,",
                        "  isScriptLikeTag,",
                        "  isVueCustomBlock,",
                        "  countParents,",
                        "  forceBreakContent,",
                        "} = require(\"../utils.js\");",
                        "const {",
                        "  printOpeningTagPrefix,",
                        "  printOpeningTag,",
                        "  printClosingTagSuffix,",
                        "  printClosingTag,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  needsToBorrowLastChildClosingTagEndMarker,",
                        "} = require(\"./tag.js\");",
                        "const { printChildren } = require(\"./children.js\");",
                        "",
                        "function printElement(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (shouldPreserveContent(node, options)) {",
                        "    return [",
                        "      printOpeningTagPrefix(node, options),",
                        "      group(printOpeningTag(path, options, print)),",
                        "      ...replaceTextEndOfLine(getNodeContent(node, options)),",
                        "      ...printClosingTag(node, options),",
                        "      printClosingTagSuffix(node, options),",
                        "    ];",
                        "  }",
                        "  /**",
                        "   * do not break:",
                        "   *",
                        "   *     <div>{{",
                        "   *         ~",
                        "   *       interpolation",
                        "   *     }}</div>",
                        "   *            ~",
                        "   *",
                        "   * exception: break if the opening tag breaks",
                        "   *",
                        "   *     <div",
                        "   *       long",
                        "   *           ~",
                        "   *       >{{",
                        "   *         interpolation",
                        "   *       }}</div",
                        "   *              ~",
                        "   *     >",
                        "   */",
                        "  const shouldHugContent =",
                        "    node.children.length === 1 &&",
                        "    node.firstChild.type === \"interpolation\" &&",
                        "    node.firstChild.isLeadingSpaceSensitive &&",
                        "    !node.firstChild.hasLeadingSpaces &&",
                        "    node.lastChild.isTrailingSpaceSensitive &&",
                        "    !node.lastChild.hasTrailingSpaces;",
                        "",
                        "  const attrGroupId = Symbol(\"element-attr-group-id\");",
                        "",
                        "  const printTag = (doc) =>",
                        "    group([",
                        "      group(printOpeningTag(path, options, print), { id: attrGroupId }),",
                        "      doc,",
                        "      printClosingTag(node, options),",
                        "    ]);",
                        "",
                        "  const printChildrenDoc = (childrenDoc) => {",
                        "    if (shouldHugContent) {",
                        "      return indentIfBreak(childrenDoc, { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      (isScriptLikeTag(node) || isVueCustomBlock(node, options)) &&",
                        "      node.parent.type === \"root\" &&",
                        "      options.parser === \"vue\" &&",
                        "      !options.vueIndentScriptAndStyle",
                        "    ) {",
                        "      return childrenDoc;",
                        "    }",
                        "    return indent(childrenDoc);",
                        "  };",
                        "",
                        "  const printLineBeforeChildren = () => {",
                        "    if (shouldHugContent) {",
                        "      return ifBreak(softline, \"\", { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      node.firstChild.hasLeadingSpaces &&",
                        "      node.firstChild.isLeadingSpaceSensitive",
                        "    ) {",
                        "      return line;",
                        "    }",
                        "    if (",
                        "      node.firstChild.type === \"text\" &&",
                        "      node.isWhitespaceSensitive &&",
                        "      node.isIndentationSensitive",
                        "    ) {",
                        "      return dedentToRoot(softline);",
                        "    }",
                        "    return softline;",
                        "  };",
                        "",
                        "  const printLineAfterChildren = () => {",
                        "    const needsToBorrow = node.next",
                        "      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                        "      : needsToBorrowLastChildClosingTagEndMarker(node.parent);",
                        "    if (needsToBorrow) {",
                        "      if (",
                        "        node.lastChild.hasTrailingSpaces &&",
                        "        node.lastChild.isTrailingSpaceSensitive",
                        "      ) {",
                        "        return \" \";",
                        "      }",
                        "      return \"\";",
                        "    }",
                        "    if (shouldHugContent) {",
                        "      return ifBreak(softline, \"\", { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      node.lastChild.hasTrailingSpaces &&",
                        "      node.lastChild.isTrailingSpaceSensitive",
                        "    ) {",
                        "      return line;",
                        "    }",
                        "    if (",
                        "      (node.lastChild.type === \"comment\" ||",
                        "        (node.lastChild.type === \"text\" &&",
                        "          node.isWhitespaceSensitive &&",
                        "          node.isIndentationSensitive)) &&",
                        "      new RegExp(",
                        "        `\\\\n[\\\\t ]{${",
                        "          options.tabWidth *",
                        "          countParents(",
                        "            path,",
                        "            (node) => node.parent && node.parent.type !== \"root\"",
                        "          )",
                        "        }}$`",
                        "      ).test(node.lastChild.value)",
                        "    ) {",
                        "      return \"\";",
                        "    }",
                        "    return softline;",
                        "  };",
                        "",
                        "  if (node.children.length === 0) {",
                        "    return printTag(",
                        "      node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line : \"\"",
                        "    );",
                        "  }",
                        "",
                        "  return printTag([",
                        "    forceBreakContent(node) ? breakParent : \"\",",
                        "    printChildrenDoc([",
                        "      printLineBeforeChildren(),",
                        "      printChildren(path, options, print),",
                        "    ]),",
                        "    printLineAfterChildren(),",
                        "  ]);",
                        "}",
                        "",
                        "module.exports = { printElement };"
                    ]
                },
                "tag.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document\").Doc} Doc",
                        " */",
                        "",
                        "const assert = require(\"assert\");",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { indent, join, line, softline, hardline },",
                        "  utils: { replaceTextEndOfLine },",
                        "} = require(\"../../document/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const {",
                        "  isTextLikeNode,",
                        "  getLastDescendant,",
                        "  isPreLikeNode,",
                        "  hasPrettierIgnore,",
                        "  shouldPreserveContent,",
                        "} = require(\"../utils.js\");",
                        "",
                        "function printClosingTag(node, options) {",
                        "  return [",
                        "    node.isSelfClosing ? \"\" : printClosingTagStart(node, options),",
                        "    printClosingTagEnd(node, options),",
                        "  ];",
                        "}",
                        "",
                        "function printClosingTagStart(node, options) {",
                        "  return node.lastChild &&",
                        "    needsToBorrowParentClosingTagStartMarker(node.lastChild)",
                        "    ? \"\"",
                        "    : [",
                        "        printClosingTagPrefix(node, options),",
                        "        printClosingTagStartMarker(node, options),",
                        "      ];",
                        "}",
                        "",
                        "function printClosingTagEnd(node, options) {",
                        "  return (",
                        "    node.next",
                        "      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                        "      : needsToBorrowLastChildClosingTagEndMarker(node.parent)",
                        "  )",
                        "    ? \"\"",
                        "    : [",
                        "        printClosingTagEndMarker(node, options),",
                        "        printClosingTagSuffix(node, options),",
                        "      ];",
                        "}",
                        "",
                        "function printClosingTagPrefix(node, options) {",
                        "  return needsToBorrowLastChildClosingTagEndMarker(node)",
                        "    ? printClosingTagEndMarker(node.lastChild, options)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printClosingTagSuffix(node, options) {",
                        "  return needsToBorrowParentClosingTagStartMarker(node)",
                        "    ? printClosingTagStartMarker(node.parent, options)",
                        "    : needsToBorrowNextOpeningTagStartMarker(node)",
                        "    ? printOpeningTagStartMarker(node.next)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printClosingTagStartMarker(node, options) {",
                        "  assert(!node.isSelfClosing);",
                        "  /* istanbul ignore next */",
                        "  if (shouldNotPrintClosingTag(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "      return \"<!\";",
                        "    case \"element\":",
                        "      if (node.hasHtmComponentClosingTag) {",
                        "        return \"<//\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return `</${node.rawName}`;",
                        "  }",
                        "}",
                        "",
                        "function printClosingTagEndMarker(node, options) {",
                        "  if (shouldNotPrintClosingTag(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"ieConditionalEndComment\":",
                        "      return \"[endif]-->\";",
                        "    case \"ieConditionalStartComment\":",
                        "      return \"]><!-->\";",
                        "    case \"interpolation\":",
                        "      return \"}}\";",
                        "    case \"element\":",
                        "      if (node.isSelfClosing) {",
                        "        return \"/>\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return \">\";",
                        "  }",
                        "}",
                        "",
                        "function shouldNotPrintClosingTag(node, options) {",
                        "  return (",
                        "    !node.isSelfClosing &&",
                        "    !node.endSourceSpan &&",
                        "    (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options))",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowPrevClosingTagEndMarker(node) {",
                        "  /**",
                        "   *     <p></p",
                        "   *     >123",
                        "   *     ^",
                        "   *",
                        "   *     <p></p",
                        "   *     ><a",
                        "   *     ^",
                        "   */",
                        "  return (",
                        "    node.prev &&",
                        "    node.prev.type !== \"docType\" &&",
                        "    !isTextLikeNode(node.prev) &&",
                        "    node.isLeadingSpaceSensitive &&",
                        "    !node.hasLeadingSpaces",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowLastChildClosingTagEndMarker(node) {",
                        "  /**",
                        "   *     <p",
                        "   *       ><a></a",
                        "   *       ></p",
                        "   *       ^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    node.lastChild &&",
                        "    node.lastChild.isTrailingSpaceSensitive &&",
                        "    !node.lastChild.hasTrailingSpaces &&",
                        "    !isTextLikeNode(getLastDescendant(node.lastChild)) &&",
                        "    !isPreLikeNode(node)",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowParentClosingTagStartMarker(node) {",
                        "  /**",
                        "   *     <p>",
                        "   *       123</p",
                        "   *          ^^^",
                        "   *     >",
                        "   *",
                        "   *         123</b",
                        "   *       ></a",
                        "   *        ^^^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    !node.next &&",
                        "    !node.hasTrailingSpaces &&",
                        "    node.isTrailingSpaceSensitive &&",
                        "    isTextLikeNode(getLastDescendant(node))",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowNextOpeningTagStartMarker(node) {",
                        "  /**",
                        "   *     123<p",
                        "   *        ^^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    node.next &&",
                        "    !isTextLikeNode(node.next) &&",
                        "    isTextLikeNode(node) &&",
                        "    node.isTrailingSpaceSensitive &&",
                        "    !node.hasTrailingSpaces",
                        "  );",
                        "}",
                        "",
                        "function getPrettierIgnoreAttributeCommentData(value) {",
                        "  const match = value.trim().match(/^prettier-ignore-attribute(?:\\s+(.+))?$/s);",
                        "",
                        "  if (!match) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!match[1]) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return match[1].split(/\\s+/);",
                        "}",
                        "",
                        "function needsToBorrowParentOpeningTagEndMarker(node) {",
                        "  /**",
                        "   *     <p",
                        "   *       >123",
                        "   *       ^",
                        "   *",
                        "   *     <p",
                        "   *       ><a",
                        "   *       ^",
                        "   */",
                        "  return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;",
                        "}",
                        "",
                        "function printAttributes(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (!isNonEmptyArray(node.attrs)) {",
                        "    return node.isSelfClosing",
                        "      ? /**",
                        "         *     <br />",
                        "         *        ^",
                        "         */",
                        "        \" \"",
                        "      : \"\";",
                        "  }",
                        "",
                        "  const ignoreAttributeData =",
                        "    node.prev &&",
                        "    node.prev.type === \"comment\" &&",
                        "    getPrettierIgnoreAttributeCommentData(node.prev.value);",
                        "",
                        "  const hasPrettierIgnoreAttribute =",
                        "    typeof ignoreAttributeData === \"boolean\"",
                        "      ? () => ignoreAttributeData",
                        "      : Array.isArray(ignoreAttributeData)",
                        "      ? (attribute) => ignoreAttributeData.includes(attribute.rawName)",
                        "      : () => false;",
                        "",
                        "  const printedAttributes = path.map((attributePath) => {",
                        "    const attribute = attributePath.getValue();",
                        "    return hasPrettierIgnoreAttribute(attribute)",
                        "      ? replaceTextEndOfLine(",
                        "          options.originalText.slice(locStart(attribute), locEnd(attribute))",
                        "        )",
                        "      : print();",
                        "  }, \"attrs\");",
                        "",
                        "  const forceNotToBreakAttrContent =",
                        "    node.type === \"element\" &&",
                        "    node.fullName === \"script\" &&",
                        "    node.attrs.length === 1 &&",
                        "    node.attrs[0].fullName === \"src\" &&",
                        "    node.children.length === 0;",
                        "",
                        "  const attributeLine =",
                        "    options.singleAttributePerLine && node.attrs.length > 1 ? hardline : line;",
                        "",
                        "  /** @type {Doc[]} */",
                        "  const parts = [",
                        "    indent([",
                        "      forceNotToBreakAttrContent ? \" \" : line,",
                        "      join(attributeLine, printedAttributes),",
                        "    ]),",
                        "  ];",
                        "",
                        "  if (",
                        "    /**",
                        "     *     123<a",
                        "     *       attr",
                        "     *           ~",
                        "     *       >456",
                        "     */",
                        "    (node.firstChild &&",
                        "      needsToBorrowParentOpeningTagEndMarker(node.firstChild)) ||",
                        "    /**",
                        "     *     <span",
                        "     *       >123<meta",
                        "     *                ~",
                        "     *     /></span>",
                        "     */",
                        "    (node.isSelfClosing &&",
                        "      needsToBorrowLastChildClosingTagEndMarker(node.parent)) ||",
                        "    forceNotToBreakAttrContent",
                        "  ) {",
                        "    parts.push(node.isSelfClosing ? \" \" : \"\");",
                        "  } else {",
                        "    parts.push(",
                        "      options.bracketSameLine",
                        "        ? node.isSelfClosing",
                        "          ? \" \"",
                        "          : \"\"",
                        "        : node.isSelfClosing",
                        "        ? line",
                        "        : softline",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printOpeningTagEnd(node) {",
                        "  return node.firstChild &&",
                        "    needsToBorrowParentOpeningTagEndMarker(node.firstChild)",
                        "    ? \"\"",
                        "    : printOpeningTagEndMarker(node);",
                        "}",
                        "",
                        "function printOpeningTag(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  return [",
                        "    printOpeningTagStart(node, options),",
                        "    printAttributes(path, options, print),",
                        "    node.isSelfClosing ? \"\" : printOpeningTagEnd(node),",
                        "  ];",
                        "}",
                        "",
                        "function printOpeningTagStart(node, options) {",
                        "  return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev)",
                        "    ? \"\"",
                        "    : [printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)];",
                        "}",
                        "",
                        "function printOpeningTagPrefix(node, options) {",
                        "  return needsToBorrowParentOpeningTagEndMarker(node)",
                        "    ? printOpeningTagEndMarker(node.parent)",
                        "    : needsToBorrowPrevClosingTagEndMarker(node)",
                        "    ? printClosingTagEndMarker(node.prev, options)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printOpeningTagStartMarker(node) {",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"ieConditionalStartComment\":",
                        "      return `<!--[if ${node.condition}`;",
                        "    case \"ieConditionalEndComment\":",
                        "      return \"<!--<!\";",
                        "    case \"interpolation\":",
                        "      return \"{{\";",
                        "    case \"docType\":",
                        "      return \"<!DOCTYPE\";",
                        "    case \"element\":",
                        "      if (node.condition) {",
                        "        return `<!--[if ${node.condition}]><!--><${node.rawName}`;",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return `<${node.rawName}`;",
                        "  }",
                        "}",
                        "",
                        "function printOpeningTagEndMarker(node) {",
                        "  assert(!node.isSelfClosing);",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "      return \"]>\";",
                        "    case \"element\":",
                        "      if (node.condition) {",
                        "        return \"><!--<![endif]-->\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return \">\";",
                        "  }",
                        "}",
                        "",
                        "module.exports = {",
                        "  printClosingTag,",
                        "  printClosingTagStart,",
                        "  printClosingTagStartMarker,",
                        "  printClosingTagEndMarker,",
                        "  printClosingTagSuffix,",
                        "  printClosingTagEnd,",
                        "  needsToBorrowLastChildClosingTagEndMarker,",
                        "  needsToBorrowParentClosingTagStartMarker,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  printOpeningTag,",
                        "  printOpeningTagStart,",
                        "  printOpeningTagPrefix,",
                        "  printOpeningTagStartMarker,",
                        "  printOpeningTagEndMarker,",
                        "  needsToBorrowNextOpeningTagStartMarker,",
                        "  needsToBorrowParentOpeningTagEndMarker,",
                        "};"
                    ]
                }
            }
        },
        "language-js": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const isBlockComment = require(\"./utils/is-block-comment.js\");",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"range\",",
                    "  \"raw\",",
                    "  \"comments\",",
                    "  \"leadingComments\",",
                    "  \"trailingComments\",",
                    "  \"innerComments\",",
                    "  \"extra\",",
                    "  \"start\",",
                    "  \"end\",",
                    "  \"loc\",",
                    "  \"flags\",",
                    "  \"errors\",",
                    "  \"tokens\",",
                    "]);",
                    "",
                    "const removeTemplateElementsValue = (node) => {",
                    "  for (const templateElement of node.quasis) {",
                    "    delete templateElement.value;",
                    "  }",
                    "};",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  if (ast.type === \"Program\") {",
                    "    delete newObj.sourceType;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"BigIntLiteral\" ||",
                    "    ast.type === \"BigIntLiteralTypeAnnotation\"",
                    "  ) {",
                    "    if (newObj.value) {",
                    "      newObj.value = newObj.value.toLowerCase();",
                    "    }",
                    "  }",
                    "  if (ast.type === \"BigIntLiteral\" || ast.type === \"Literal\") {",
                    "    if (newObj.bigint) {",
                    "      newObj.bigint = newObj.bigint.toLowerCase();",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"DecimalLiteral\") {",
                    "    newObj.value = Number(newObj.value);",
                    "  }",
                    "  if (ast.type === \"Literal\" && newObj.decimal) {",
                    "    newObj.decimal = Number(newObj.decimal);",
                    "  }",
                    "",
                    "  // We remove extra `;` and add them when needed",
                    "  if (ast.type === \"EmptyStatement\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We move text around, including whitespaces and add {\" \"}",
                    "  if (ast.type === \"JSXText\") {",
                    "    return null;",
                    "  }",
                    "  if (",
                    "    ast.type === \"JSXExpressionContainer\" &&",
                    "    (ast.expression.type === \"Literal\" ||",
                    "      ast.expression.type === \"StringLiteral\") &&",
                    "    ast.expression.value === \" \"",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We change {'key': value} into {key: value}.",
                    "  // And {key: value} into {'key': value}.",
                    "  // Also for (some) number keys.",
                    "  if (",
                    "    (ast.type === \"Property\" ||",
                    "      ast.type === \"ObjectProperty\" ||",
                    "      ast.type === \"MethodDefinition\" ||",
                    "      ast.type === \"ClassProperty\" ||",
                    "      ast.type === \"ClassMethod\" ||",
                    "      ast.type === \"PropertyDefinition\" ||",
                    "      ast.type === \"TSDeclareMethod\" ||",
                    "      ast.type === \"TSPropertySignature\" ||",
                    "      ast.type === \"ObjectTypeProperty\") &&",
                    "    typeof ast.key === \"object\" &&",
                    "    ast.key &&",
                    "    (ast.key.type === \"Literal\" ||",
                    "      ast.key.type === \"NumericLiteral\" ||",
                    "      ast.key.type === \"StringLiteral\" ||",
                    "      ast.key.type === \"Identifier\")",
                    "  ) {",
                    "    delete newObj.key;",
                    "  }",
                    "",
                    "  // Remove raw and cooked values from TemplateElement when it's CSS",
                    "  // styled-jsx",
                    "  if (",
                    "    ast.type === \"JSXElement\" &&",
                    "    ast.openingElement.name.name === \"style\" &&",
                    "    ast.openingElement.attributes.some((attr) => attr.name.name === \"jsx\")",
                    "  ) {",
                    "    for (const { type, expression } of newObj.children) {",
                    "      if (",
                    "        type === \"JSXExpressionContainer\" &&",
                    "        expression.type === \"TemplateLiteral\"",
                    "      ) {",
                    "        removeTemplateElementsValue(expression);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  // CSS template literals in css prop",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.name.name === \"css\" &&",
                    "    ast.value.type === \"JSXExpressionContainer\" &&",
                    "    ast.value.expression.type === \"TemplateLiteral\"",
                    "  ) {",
                    "    removeTemplateElementsValue(newObj.value.expression);",
                    "  }",
                    "",
                    "  // We change quotes",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.value &&",
                    "    ast.value.type === \"Literal\" &&",
                    "    /[\"']|&quot;|&apos;/.test(ast.value.value)",
                    "  ) {",
                    "    newObj.value.value = newObj.value.value.replace(/[\"']|&quot;|&apos;/g, '\"');",
                    "  }",
                    "",
                    "  // Angular Components: Inline HTML template and Inline CSS styles",
                    "  const expression = ast.expression || ast.callee;",
                    "  if (",
                    "    ast.type === \"Decorator\" &&",
                    "    expression.type === \"CallExpression\" &&",
                    "    expression.callee.name === \"Component\" &&",
                    "    expression.arguments.length === 1",
                    "  ) {",
                    "    const astProps = ast.expression.arguments[0].properties;",
                    "    for (const [",
                    "      index,",
                    "      prop,",
                    "    ] of newObj.expression.arguments[0].properties.entries()) {",
                    "      switch (astProps[index].key.name) {",
                    "        case \"styles\":",
                    "          if (prop.value.type === \"ArrayExpression\") {",
                    "            removeTemplateElementsValue(prop.value.elements[0]);",
                    "          }",
                    "          break;",
                    "        case \"template\":",
                    "          if (prop.value.type === \"TemplateLiteral\") {",
                    "            removeTemplateElementsValue(prop.value);",
                    "          }",
                    "          break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  // styled-components, graphql, markdown",
                    "  if (",
                    "    ast.type === \"TaggedTemplateExpression\" &&",
                    "    (ast.tag.type === \"MemberExpression\" ||",
                    "      (ast.tag.type === \"Identifier\" &&",
                    "        (ast.tag.name === \"gql\" ||",
                    "          ast.tag.name === \"graphql\" ||",
                    "          ast.tag.name === \"css\" ||",
                    "          ast.tag.name === \"md\" ||",
                    "          ast.tag.name === \"markdown\" ||",
                    "          ast.tag.name === \"html\")) ||",
                    "      ast.tag.type === \"CallExpression\")",
                    "  ) {",
                    "    removeTemplateElementsValue(newObj.quasi);",
                    "  }",
                    "  if (ast.type === \"TemplateLiteral\") {",
                    "    // This checks for a leading comment that is exactly `/* GraphQL */`",
                    "    // In order to be in line with other implementations of this comment tag",
                    "    // we will not trim the comment value and we will expect exactly one space on",
                    "    // either side of the GraphQL string",
                    "    // Also see ./embed.js",
                    "    const hasLanguageComment =",
                    "      ast.leadingComments &&",
                    "      ast.leadingComments.some(",
                    "        (comment) =>",
                    "          isBlockComment(comment) &&",
                    "          [\"GraphQL\", \"HTML\"].some(",
                    "            (languageName) => comment.value === ` ${languageName} `",
                    "          )",
                    "      );",
                    "    if (",
                    "      hasLanguageComment ||",
                    "      (parent.type === \"CallExpression\" && parent.callee.name === \"graphql\") ||",
                    "      // TODO: check parser",
                    "      // `flow` and `typescript` don't have `leadingComments`",
                    "      !ast.leadingComments",
                    "    ) {",
                    "      removeTemplateElementsValue(newObj);",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"InterpreterDirective\") {",
                    "    newObj.value = newObj.value.trimEnd();",
                    "  }",
                    "",
                    "  // Prettier removes degenerate union and intersection types with only one member.",
                    "  if (",
                    "    (ast.type === \"TSIntersectionType\" || ast.type === \"TSUnionType\") &&",
                    "    ast.types.length === 1",
                    "  ) {",
                    "    return newObj.types[0];",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "module.exports = clean;"
                ]
            },
            "comments.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  getLast,",
                    "  hasNewline,",
                    "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                    "  getNextNonSpaceNonCommentCharacter,",
                    "  hasNewlineInRange,",
                    "  addLeadingComment,",
                    "  addTrailingComment,",
                    "  addDanglingComment,",
                    "  getNextNonSpaceNonCommentCharacterIndex,",
                    "  isNonEmptyArray,",
                    "} = require(\"../common/util.js\");",
                    "const {",
                    "  getFunctionParameters,",
                    "  isPrettierIgnoreComment,",
                    "  isJsxNode,",
                    "  hasFlowShorthandAnnotationComment,",
                    "  hasFlowAnnotationComment,",
                    "  hasIgnoreComment,",
                    "  isCallLikeExpression,",
                    "  getCallArguments,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  isObjectProperty,",
                    "  getComments,",
                    "  CommentCheckFlags,",
                    "  markerForIfWithoutBlockAndSameLineComment,",
                    "} = require(\"./utils/index.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const isBlockComment = require(\"./utils/is-block-comment.js\");",
                    "",
                    "/**",
                    " * @typedef {import(\"./types/estree\").Node} Node",
                    " * @typedef {import(\"./types/estree\").Comment} Comment",
                    " * @typedef {import(\"../common/ast-path\")} AstPath",
                    " *",
                    " * @typedef {Object} CommentContext",
                    " * @property {Comment} comment",
                    " * @property {Node} precedingNode",
                    " * @property {Node} enclosingNode",
                    " * @property {Node} followingNode",
                    " * @property {string} text",
                    " * @property {any} options",
                    " * @property {Node} ast",
                    " * @property {boolean} isLastComment",
                    " */",
                    "",
                    "/**",
                    " * @param {CommentContext} context",
                    " * @returns {boolean}",
                    " */",
                    "function handleOwnLineComment(context) {",
                    "  return [",
                    "    handleIgnoreComments,",
                    "    handleLastFunctionArgComments,",
                    "    handleMemberExpressionComments,",
                    "    handleIfStatementComments,",
                    "    handleWhileComments,",
                    "    handleTryStatementComments,",
                    "    handleClassComments,",
                    "    handleImportSpecifierComments,",
                    "    handleForComments,",
                    "    handleUnionTypeComments,",
                    "    handleOnlyComments,",
                    "    handleImportDeclarationComments,",
                    "    handleAssignmentPatternComments,",
                    "    handleMethodNameComments,",
                    "    handleLabeledStatementComments,",
                    "    handleBreakAndContinueStatementComments,",
                    "  ].some((fn) => fn(context));",
                    "}",
                    "",
                    "/**",
                    " * @param {CommentContext} context",
                    " * @returns {boolean}",
                    " */",
                    "function handleEndOfLineComment(context) {",
                    "  return [",
                    "    handleClosureTypeCastComments,",
                    "    handleLastFunctionArgComments,",
                    "    handleConditionalExpressionComments,",
                    "    handleImportSpecifierComments,",
                    "    handleIfStatementComments,",
                    "    handleWhileComments,",
                    "    handleTryStatementComments,",
                    "    handleClassComments,",
                    "    handleLabeledStatementComments,",
                    "    handleCallExpressionComments,",
                    "    handlePropertyComments,",
                    "    handleOnlyComments,",
                    "    handleTypeAliasComments,",
                    "    handleVariableDeclaratorComments,",
                    "    handleBreakAndContinueStatementComments,",
                    "  ].some((fn) => fn(context));",
                    "}",
                    "",
                    "/**",
                    " * @param {CommentContext} context",
                    " * @returns {boolean}",
                    " */",
                    "function handleRemainingComment(context) {",
                    "  return [",
                    "    handleIgnoreComments,",
                    "    handleIfStatementComments,",
                    "    handleWhileComments,",
                    "    handleObjectPropertyAssignment,",
                    "    handleCommentInEmptyParens,",
                    "    handleMethodNameComments,",
                    "    handleOnlyComments,",
                    "    handleCommentAfterArrowParams,",
                    "    handleFunctionNameComments,",
                    "    handleTSMappedTypeComments,",
                    "    handleBreakAndContinueStatementComments,",
                    "    handleTSFunctionTrailingComments,",
                    "  ].some((fn) => fn(context));",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @returns {void}",
                    " */",
                    "function addBlockStatementFirstComment(node, comment) {",
                    "  // @ts-expect-error",
                    "  const firstNonEmptyNode = (node.body || node.properties).find(",
                    "    ({ type }) => type !== \"EmptyStatement\"",
                    "  );",
                    "  if (firstNonEmptyNode) {",
                    "    addLeadingComment(firstNonEmptyNode, comment);",
                    "  } else {",
                    "    addDanglingComment(node, comment);",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @returns {void}",
                    " */",
                    "function addBlockOrNotComment(node, comment) {",
                    "  if (node.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(node, comment);",
                    "  } else {",
                    "    addLeadingComment(node, comment);",
                    "  }",
                    "}",
                    "",
                    "function handleClosureTypeCastComments({ comment, followingNode }) {",
                    "  if (followingNode && isTypeCastComment(comment)) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "// There are often comments before the else clause of if statements like",
                    "//",
                    "//   if (1) { ... }",
                    "//   // comment",
                    "//   else { ... }",
                    "//",
                    "// They are being attached as leading comments of the BlockExpression which",
                    "// is not well printed. What we want is to instead move the comment inside",
                    "// of the block and make it leadingComment of the first element of the block",
                    "// or dangling comment of the block if there is nothing inside",
                    "//",
                    "//   if (1) { ... }",
                    "//   else {",
                    "//     // comment",
                    "//     ...",
                    "//   }",
                    "function handleIfStatementComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  if (",
                    "    !enclosingNode ||",
                    "    enclosingNode.type !== \"IfStatement\" ||",
                    "    !followingNode",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // We unfortunately have no way using the AST or location of nodes to know",
                    "  // if the comment is positioned before the condition parenthesis:",
                    "  //   if (a /* comment */) {}",
                    "  // The only workaround I found is to look at the next character to see if",
                    "  // it is a ).",
                    "  const nextCharacter = getNextNonSpaceNonCommentCharacter(",
                    "    text,",
                    "    comment,",
                    "    locEnd",
                    "  );",
                    "  if (nextCharacter === \")\") {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Comments before `else`:",
                    "  // - treat as trailing comments of the consequent, if it's a BlockStatement",
                    "  // - treat as a dangling comment otherwise",
                    "  if (",
                    "    precedingNode === enclosingNode.consequent &&",
                    "    followingNode === enclosingNode.alternate",
                    "  ) {",
                    "    if (precedingNode.type === \"BlockStatement\") {",
                    "      addTrailingComment(precedingNode, comment);",
                    "    } else {",
                    "      const isSingleLineComment =",
                    "        comment.type === \"SingleLine\" ||",
                    "        comment.loc.start.line === comment.loc.end.line;",
                    "      const isSameLineComment =",
                    "        comment.loc.start.line === precedingNode.loc.start.line;",
                    "      if (isSingleLineComment && isSameLineComment) {",
                    "        // example:",
                    "        //   if (cond1) expr1; // comment A",
                    "        //   else if (cond2) expr2; // comment A",
                    "        //   else expr3;",
                    "        addDanglingComment(",
                    "          precedingNode,",
                    "          comment,",
                    "          markerForIfWithoutBlockAndSameLineComment",
                    "        );",
                    "      } else {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      }",
                    "    }",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"IfStatement\") {",
                    "    addBlockOrNotComment(followingNode.consequent, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // For comments positioned after the condition parenthesis in an if statement",
                    "  // before the consequent without brackets on, such as",
                    "  // if (a) /* comment */ true,",
                    "  // we look at the next character to see if the following node",
                    "  // is the consequent for the if statement",
                    "  if (enclosingNode.consequent === followingNode) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleWhileComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  if (",
                    "    !enclosingNode ||",
                    "    enclosingNode.type !== \"WhileStatement\" ||",
                    "    !followingNode",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // We unfortunately have no way using the AST or location of nodes to know",
                    "  // if the comment is positioned before the condition parenthesis:",
                    "  //   while (a /* comment */) {}",
                    "  // The only workaround I found is to look at the next character to see if",
                    "  // it is a ).",
                    "  const nextCharacter = getNextNonSpaceNonCommentCharacter(",
                    "    text,",
                    "    comment,",
                    "    locEnd",
                    "  );",
                    "  if (nextCharacter === \")\") {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (enclosingNode.body === followingNode) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "// Same as IfStatement but for TryStatement",
                    "function handleTryStatementComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    !enclosingNode ||",
                    "    (enclosingNode.type !== \"TryStatement\" &&",
                    "      enclosingNode.type !== \"CatchClause\") ||",
                    "    !followingNode",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (enclosingNode.type === \"CatchClause\" && precedingNode) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"BlockStatement\") {",
                    "    addBlockStatementFirstComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"TryStatement\") {",
                    "    addBlockOrNotComment(followingNode.finalizer, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (followingNode.type === \"CatchClause\") {",
                    "    addBlockOrNotComment(followingNode.body, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleMemberExpressionComments({",
                    "  comment,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    isMemberExpression(enclosingNode) &&",
                    "    followingNode &&",
                    "    followingNode.type === \"Identifier\"",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleConditionalExpressionComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  const isSameLineAsPrecedingNode =",
                    "    precedingNode &&",
                    "    !hasNewlineInRange(text, locEnd(precedingNode), locStart(comment));",
                    "",
                    "  if (",
                    "    (!precedingNode || !isSameLineAsPrecedingNode) &&",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ConditionalExpression\" ||",
                    "      enclosingNode.type === \"TSConditionalType\") &&",
                    "    followingNode",
                    "  ) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleObjectPropertyAssignment({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "}) {",
                    "  if (",
                    "    isObjectProperty(enclosingNode) &&",
                    "    enclosingNode.shorthand &&",
                    "    enclosingNode.key === precedingNode &&",
                    "    enclosingNode.value.type === \"AssignmentPattern\"",
                    "  ) {",
                    "    addTrailingComment(enclosingNode.value.left, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleClassComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ClassDeclaration\" ||",
                    "      enclosingNode.type === \"ClassExpression\" ||",
                    "      enclosingNode.type === \"DeclareClass\" ||",
                    "      enclosingNode.type === \"DeclareInterface\" ||",
                    "      enclosingNode.type === \"InterfaceDeclaration\" ||",
                    "      enclosingNode.type === \"TSInterfaceDeclaration\")",
                    "  ) {",
                    "    if (",
                    "      isNonEmptyArray(enclosingNode.decorators) &&",
                    "      !(followingNode && followingNode.type === \"Decorator\")",
                    "    ) {",
                    "      addTrailingComment(getLast(enclosingNode.decorators), comment);",
                    "      return true;",
                    "    }",
                    "",
                    "    if (enclosingNode.body && followingNode === enclosingNode.body) {",
                    "      addBlockStatementFirstComment(enclosingNode.body, comment);",
                    "      return true;",
                    "    }",
                    "",
                    "    // Don't add leading comments to `implements`, `extends`, `mixins` to",
                    "    // avoid printing the comment after the keyword.",
                    "    if (followingNode) {",
                    "      for (const prop of [\"implements\", \"extends\", \"mixins\"]) {",
                    "        if (enclosingNode[prop] && followingNode === enclosingNode[prop][0]) {",
                    "          if (",
                    "            precedingNode &&",
                    "            (precedingNode === enclosingNode.id ||",
                    "              precedingNode === enclosingNode.typeParameters ||",
                    "              precedingNode === enclosingNode.superClass)",
                    "          ) {",
                    "            addTrailingComment(precedingNode, comment);",
                    "          } else {",
                    "            addDanglingComment(enclosingNode, comment, prop);",
                    "          }",
                    "          return true;",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleMethodNameComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  text,",
                    "}) {",
                    "  // This is only needed for estree parsers (flow, typescript) to attach",
                    "  // after a method name:",
                    "  // obj = { fn /*comment*/() {} };",
                    "  if (",
                    "    enclosingNode &&",
                    "    precedingNode &&",
                    "    // \"MethodDefinition\" is handled in getCommentChildNodes",
                    "    (enclosingNode.type === \"Property\" ||",
                    "      enclosingNode.type === \"TSDeclareMethod\" ||",
                    "      enclosingNode.type === \"TSAbstractMethodDefinition\") &&",
                    "    precedingNode.type === \"Identifier\" &&",
                    "    enclosingNode.key === precedingNode &&",
                    "    // special Property case: { key: /*comment*/(value) };",
                    "    // comment should be attached to value instead of key",
                    "    getNextNonSpaceNonCommentCharacter(text, precedingNode, locEnd) !== \":\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Print comments between decorators and class methods as a trailing comment",
                    "  // on the decorator node instead of the method node",
                    "  if (",
                    "    precedingNode &&",
                    "    enclosingNode &&",
                    "    precedingNode.type === \"Decorator\" &&",
                    "    (enclosingNode.type === \"ClassMethod\" ||",
                    "      enclosingNode.type === \"ClassProperty\" ||",
                    "      enclosingNode.type === \"PropertyDefinition\" ||",
                    "      enclosingNode.type === \"TSAbstractPropertyDefinition\" ||",
                    "      enclosingNode.type === \"TSAbstractMethodDefinition\" ||",
                    "      enclosingNode.type === \"TSDeclareMethod\" ||",
                    "      enclosingNode.type === \"MethodDefinition\")",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleFunctionNameComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  text,",
                    "}) {",
                    "  if (getNextNonSpaceNonCommentCharacter(text, comment, locEnd) !== \"(\") {",
                    "    return false;",
                    "  }",
                    "  if (",
                    "    precedingNode &&",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"FunctionDeclaration\" ||",
                    "      enclosingNode.type === \"FunctionExpression\" ||",
                    "      enclosingNode.type === \"ClassMethod\" ||",
                    "      enclosingNode.type === \"MethodDefinition\" ||",
                    "      enclosingNode.type === \"ObjectMethod\")",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleCommentAfterArrowParams({ comment, enclosingNode, text }) {",
                    "  if (!(enclosingNode && enclosingNode.type === \"ArrowFunctionExpression\")) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const index = getNextNonSpaceNonCommentCharacterIndex(text, comment, locEnd);",
                    "  if (index !== false && text.slice(index, index + 2) === \"=>\") {",
                    "    addDanglingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleCommentInEmptyParens({ comment, enclosingNode, text }) {",
                    "  if (getNextNonSpaceNonCommentCharacter(text, comment, locEnd) !== \")\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Only add dangling comments to fix the case when no params are present,",
                    "  // i.e. a function without any argument.",
                    "  if (",
                    "    enclosingNode &&",
                    "    ((isRealFunctionLikeNode(enclosingNode) &&",
                    "      getFunctionParameters(enclosingNode).length === 0) ||",
                    "      (isCallLikeExpression(enclosingNode) &&",
                    "        getCallArguments(enclosingNode).length === 0))",
                    "  ) {",
                    "    addDanglingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"MethodDefinition\" ||",
                    "      enclosingNode.type === \"TSAbstractMethodDefinition\") &&",
                    "    getFunctionParameters(enclosingNode.value).length === 0",
                    "  ) {",
                    "    addDanglingComment(enclosingNode.value, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleLastFunctionArgComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  // Flow function type definitions",
                    "  if (",
                    "    precedingNode &&",
                    "    precedingNode.type === \"FunctionTypeParam\" &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"FunctionTypeAnnotation\" &&",
                    "    followingNode &&",
                    "    followingNode.type !== \"FunctionTypeParam\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  // Real functions and TypeScript function type definitions",
                    "  if (",
                    "    precedingNode &&",
                    "    (precedingNode.type === \"Identifier\" ||",
                    "      precedingNode.type === \"AssignmentPattern\") &&",
                    "    enclosingNode &&",
                    "    isRealFunctionLikeNode(enclosingNode) &&",
                    "    getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === \")\"",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"FunctionDeclaration\" &&",
                    "    followingNode &&",
                    "    followingNode.type === \"BlockStatement\"",
                    "  ) {",
                    "    const functionParamRightParenIndex = (() => {",
                    "      const parameters = getFunctionParameters(enclosingNode);",
                    "      if (parameters.length > 0) {",
                    "        return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "          text,",
                    "          locEnd(getLast(parameters))",
                    "        );",
                    "      }",
                    "      const functionParamLeftParenIndex =",
                    "        getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "          text,",
                    "          locEnd(enclosingNode.id)",
                    "        );",
                    "      return (",
                    "        functionParamLeftParenIndex !== false &&",
                    "        getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "          text,",
                    "          functionParamLeftParenIndex + 1",
                    "        )",
                    "      );",
                    "    })();",
                    "    if (locStart(comment) > functionParamRightParenIndex) {",
                    "      addBlockStatementFirstComment(followingNode, comment);",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleImportSpecifierComments({ comment, enclosingNode }) {",
                    "  if (enclosingNode && enclosingNode.type === \"ImportSpecifier\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleLabeledStatementComments({ comment, enclosingNode }) {",
                    "  if (enclosingNode && enclosingNode.type === \"LabeledStatement\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleBreakAndContinueStatementComments({ comment, enclosingNode }) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ContinueStatement\" ||",
                    "      enclosingNode.type === \"BreakStatement\") &&",
                    "    !enclosingNode.label",
                    "  ) {",
                    "    addTrailingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleCallExpressionComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "}) {",
                    "  if (",
                    "    isCallExpression(enclosingNode) &&",
                    "    precedingNode &&",
                    "    enclosingNode.callee === precedingNode &&",
                    "    enclosingNode.arguments.length > 0",
                    "  ) {",
                    "    addLeadingComment(enclosingNode.arguments[0], comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleUnionTypeComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"UnionTypeAnnotation\" ||",
                    "      enclosingNode.type === \"TSUnionType\")",
                    "  ) {",
                    "    if (isPrettierIgnoreComment(comment)) {",
                    "      followingNode.prettierIgnore = true;",
                    "      comment.unignore = true;",
                    "    }",
                    "    if (precedingNode) {",
                    "      addTrailingComment(precedingNode, comment);",
                    "      return true;",
                    "    }",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    followingNode &&",
                    "    (followingNode.type === \"UnionTypeAnnotation\" ||",
                    "      followingNode.type === \"TSUnionType\") &&",
                    "    isPrettierIgnoreComment(comment)",
                    "  ) {",
                    "    followingNode.types[0].prettierIgnore = true;",
                    "    comment.unignore = true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handlePropertyComments({ comment, enclosingNode }) {",
                    "  if (isObjectProperty(enclosingNode)) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleOnlyComments({",
                    "  comment,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  ast,",
                    "  isLastComment,",
                    "}) {",
                    "  // With Flow the enclosingNode is undefined so use the AST instead.",
                    "  if (ast && ast.body && ast.body.length === 0) {",
                    "    if (isLastComment) {",
                    "      addDanglingComment(ast, comment);",
                    "    } else {",
                    "      addLeadingComment(ast, comment);",
                    "    }",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"Program\" &&",
                    "    enclosingNode.body.length === 0 &&",
                    "    !isNonEmptyArray(enclosingNode.directives)",
                    "  ) {",
                    "    if (isLastComment) {",
                    "      addDanglingComment(enclosingNode, comment);",
                    "    } else {",
                    "      addLeadingComment(enclosingNode, comment);",
                    "    }",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    followingNode &&",
                    "    followingNode.type === \"Program\" &&",
                    "    followingNode.body.length === 0 &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"ModuleExpression\"",
                    "  ) {",
                    "    addDanglingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function handleForComments({ comment, enclosingNode }) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"ForInStatement\" ||",
                    "      enclosingNode.type === \"ForOfStatement\")",
                    "  ) {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleImportDeclarationComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  text,",
                    "}) {",
                    "  if (",
                    "    precedingNode &&",
                    "    precedingNode.type === \"ImportSpecifier\" &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"ImportDeclaration\" &&",
                    "    hasNewline(text, locEnd(comment))",
                    "  ) {",
                    "    addTrailingComment(precedingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleAssignmentPatternComments({ comment, enclosingNode }) {",
                    "  if (enclosingNode && enclosingNode.type === \"AssignmentPattern\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleTypeAliasComments({ comment, enclosingNode }) {",
                    "  if (enclosingNode && enclosingNode.type === \"TypeAlias\") {",
                    "    addLeadingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleVariableDeclaratorComments({",
                    "  comment,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"VariableDeclarator\" ||",
                    "      enclosingNode.type === \"AssignmentExpression\") &&",
                    "    followingNode &&",
                    "    (followingNode.type === \"ObjectExpression\" ||",
                    "      followingNode.type === \"ArrayExpression\" ||",
                    "      followingNode.type === \"TemplateLiteral\" ||",
                    "      followingNode.type === \"TaggedTemplateExpression\" ||",
                    "      isBlockComment(comment))",
                    "  ) {",
                    "    addLeadingComment(followingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleTSFunctionTrailingComments({",
                    "  comment,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "  text,",
                    "}) {",
                    "  if (",
                    "    !followingNode &&",
                    "    enclosingNode &&",
                    "    (enclosingNode.type === \"TSMethodSignature\" ||",
                    "      enclosingNode.type === \"TSDeclareFunction\" ||",
                    "      enclosingNode.type === \"TSAbstractMethodDefinition\") &&",
                    "    getNextNonSpaceNonCommentCharacter(text, comment, locEnd) === \";\"",
                    "  ) {",
                    "    addTrailingComment(enclosingNode, comment);",
                    "    return true;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function handleIgnoreComments({ comment, enclosingNode, followingNode }) {",
                    "  if (",
                    "    isPrettierIgnoreComment(comment) &&",
                    "    enclosingNode &&",
                    "    enclosingNode.type === \"TSMappedType\" &&",
                    "    followingNode &&",
                    "    followingNode.type === \"TSTypeParameter\" &&",
                    "    followingNode.constraint",
                    "  ) {",
                    "    enclosingNode.prettierIgnore = true;",
                    "    comment.unignore = true;",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function handleTSMappedTypeComments({",
                    "  comment,",
                    "  precedingNode,",
                    "  enclosingNode,",
                    "  followingNode,",
                    "}) {",
                    "  if (!enclosingNode || enclosingNode.type !== \"TSMappedType\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    followingNode &&",
                    "    followingNode.type === \"TSTypeParameter\" &&",
                    "    followingNode.name",
                    "  ) {",
                    "    addLeadingComment(followingNode.name, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    precedingNode &&",
                    "    precedingNode.type === \"TSTypeParameter\" &&",
                    "    precedingNode.constraint",
                    "  ) {",
                    "    addTrailingComment(precedingNode.constraint, comment);",
                    "    return true;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @returns {boolean}",
                    " */",
                    "function isRealFunctionLikeNode(node) {",
                    "  return (",
                    "    node.type === \"ArrowFunctionExpression\" ||",
                    "    node.type === \"FunctionExpression\" ||",
                    "    node.type === \"FunctionDeclaration\" ||",
                    "    node.type === \"ObjectMethod\" ||",
                    "    node.type === \"ClassMethod\" ||",
                    "    node.type === \"TSDeclareFunction\" ||",
                    "    node.type === \"TSCallSignatureDeclaration\" ||",
                    "    node.type === \"TSConstructSignatureDeclaration\" ||",
                    "    node.type === \"TSMethodSignature\" ||",
                    "    node.type === \"TSConstructorType\" ||",
                    "    node.type === \"TSFunctionType\" ||",
                    "    node.type === \"TSDeclareMethod\"",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {any} node",
                    " * @returns {Node[] | void}",
                    " */",
                    "function getCommentChildNodes(node, options) {",
                    "  // Prevent attaching comments to FunctionExpression in this case:",
                    "  //     class Foo {",
                    "  //       bar() // comment",
                    "  //       {",
                    "  //         baz();",
                    "  //       }",
                    "  //     }",
                    "  if (",
                    "    (options.parser === \"typescript\" ||",
                    "      options.parser === \"flow\" ||",
                    "      options.parser === \"espree\" ||",
                    "      options.parser === \"meriyah\" ||",
                    "      options.parser === \"__babel_estree\") &&",
                    "    node.type === \"MethodDefinition\" &&",
                    "    node.value &&",
                    "    node.value.type === \"FunctionExpression\" &&",
                    "    getFunctionParameters(node.value).length === 0 &&",
                    "    !node.value.returnType &&",
                    "    !isNonEmptyArray(node.value.typeParameters) &&",
                    "    node.value.body",
                    "  ) {",
                    "    return [...(node.decorators || []), node.key, node.value.body];",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Comment} comment",
                    " * @returns {boolean}",
                    " */",
                    "function isTypeCastComment(comment) {",
                    "  return (",
                    "    isBlockComment(comment) &&",
                    "    comment.value[0] === \"*\" &&",
                    "    // TypeScript expects the type to be enclosed in curly brackets, however",
                    "    // Closure Compiler accepts types in parens and even without any delimiters at all.",
                    "    // That's why we just search for \"@type\".",
                    "    /@type\\b/.test(comment.value)",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {AstPath} path",
                    " * @returns {boolean}",
                    " */",
                    "function willPrintOwnComments(path /*, options */) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  const hasFlowAnnotations = (node) =>",
                    "    hasFlowAnnotationComment(getComments(node, CommentCheckFlags.Leading)) ||",
                    "    hasFlowAnnotationComment(getComments(node, CommentCheckFlags.Trailing));",
                    "",
                    "  return (",
                    "    ((node &&",
                    "      (isJsxNode(node) ||",
                    "        hasFlowShorthandAnnotationComment(node) ||",
                    "        (isCallExpression(parent) && hasFlowAnnotations(node)))) ||",
                    "      (parent &&",
                    "        (parent.type === \"JSXSpreadAttribute\" ||",
                    "          parent.type === \"JSXSpreadChild\" ||",
                    "          parent.type === \"UnionTypeAnnotation\" ||",
                    "          parent.type === \"TSUnionType\" ||",
                    "          ((parent.type === \"ClassDeclaration\" ||",
                    "            parent.type === \"ClassExpression\") &&",
                    "            parent.superClass === node)))) &&",
                    "    (!hasIgnoreComment(path) ||",
                    "      parent.type === \"UnionTypeAnnotation\" ||",
                    "      parent.type === \"TSUnionType\")",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  handleOwnLineComment,",
                    "  handleEndOfLineComment,",
                    "  handleRemainingComment,",
                    "  isTypeCastComment,",
                    "  getCommentChildNodes,",
                    "  willPrintOwnComments,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  hasComment,",
                    "  CommentCheckFlags,",
                    "  isObjectProperty,",
                    "} = require(\"./utils/index.js\");",
                    "const formatMarkdown = require(\"./embed/markdown.js\");",
                    "const formatCss = require(\"./embed/css.js\");",
                    "const formatGraphql = require(\"./embed/graphql.js\");",
                    "const formatHtml = require(\"./embed/html.js\");",
                    "",
                    "function getLanguage(path) {",
                    "  if (",
                    "    isStyledJsx(path) ||",
                    "    isStyledComponents(path) ||",
                    "    isCssProp(path) ||",
                    "    isAngularComponentStyles(path)",
                    "  ) {",
                    "    return \"css\";",
                    "  }",
                    "",
                    "  if (isGraphQL(path)) {",
                    "    return \"graphql\";",
                    "  }",
                    "",
                    "  if (isHtml(path)) {",
                    "    return \"html\";",
                    "  }",
                    "",
                    "  if (isAngularComponentTemplate(path)) {",
                    "    return \"angular\";",
                    "  }",
                    "",
                    "  if (isMarkdown(path)) {",
                    "    return \"markdown\";",
                    "  }",
                    "}",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (",
                    "    node.type !== \"TemplateLiteral\" ||",
                    "    // Bail out if any of the quasis have an invalid escape sequence",
                    "    // (which would make the `cooked` value be `null`)",
                    "    hasInvalidCookedValue(node)",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  const language = getLanguage(path);",
                    "  if (!language) {",
                    "    return;",
                    "  }",
                    "",
                    "  if (language === \"markdown\") {",
                    "    return formatMarkdown(path, print, textToDoc);",
                    "  }",
                    "",
                    "  if (language === \"css\") {",
                    "    return formatCss(path, print, textToDoc);",
                    "  }",
                    "",
                    "  if (language === \"graphql\") {",
                    "    return formatGraphql(path, print, textToDoc);",
                    "  }",
                    "",
                    "  if (language === \"html\" || language === \"angular\") {",
                    "    return formatHtml(path, print, textToDoc, options, { parser: language });",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * md`...`",
                    " * markdown`...`",
                    " */",
                    "function isMarkdown(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  return (",
                    "    parent &&",
                    "    parent.type === \"TaggedTemplateExpression\" &&",
                    "    node.quasis.length === 1 &&",
                    "    parent.tag.type === \"Identifier\" &&",
                    "    (parent.tag.name === \"md\" || parent.tag.name === \"markdown\")",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * Template literal in these contexts:",
                    " * <style jsx>{`div{color:red}`}</style>",
                    " * css``",
                    " * css.global``",
                    " * css.resolve``",
                    " */",
                    "function isStyledJsx(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "  return (",
                    "    (parentParent &&",
                    "      node.quasis &&",
                    "      parent.type === \"JSXExpressionContainer\" &&",
                    "      parentParent.type === \"JSXElement\" &&",
                    "      parentParent.openingElement.name.name === \"style\" &&",
                    "      parentParent.openingElement.attributes.some(",
                    "        (attribute) => attribute.name.name === \"jsx\"",
                    "      )) ||",
                    "    (parent &&",
                    "      parent.type === \"TaggedTemplateExpression\" &&",
                    "      parent.tag.type === \"Identifier\" &&",
                    "      parent.tag.name === \"css\") ||",
                    "    (parent &&",
                    "      parent.type === \"TaggedTemplateExpression\" &&",
                    "      parent.tag.type === \"MemberExpression\" &&",
                    "      parent.tag.object.name === \"css\" &&",
                    "      (parent.tag.property.name === \"global\" ||",
                    "        parent.tag.property.name === \"resolve\"))",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * Angular Components can have:",
                    " * - Inline HTML template",
                    " * - Inline CSS styles",
                    " *",
                    " * ...which are both within template literals somewhere",
                    " * inside of the Component decorator factory.",
                    " *",
                    " * E.g.",
                    " * @Component({",
                    " *  template: `<div>...</div>`,",
                    " *  styles: [`h1 { color: blue; }`]",
                    " * })",
                    " */",
                    "function isAngularComponentStyles(path) {",
                    "  return path.match(",
                    "    (node) => node.type === \"TemplateLiteral\",",
                    "    (node, name) => node.type === \"ArrayExpression\" && name === \"elements\",",
                    "    (node, name) =>",
                    "      isObjectProperty(node) &&",
                    "      node.key.type === \"Identifier\" &&",
                    "      node.key.name === \"styles\" &&",
                    "      name === \"value\",",
                    "    ...angularComponentObjectExpressionPredicates",
                    "  );",
                    "}",
                    "function isAngularComponentTemplate(path) {",
                    "  return path.match(",
                    "    (node) => node.type === \"TemplateLiteral\",",
                    "    (node, name) =>",
                    "      isObjectProperty(node) &&",
                    "      node.key.type === \"Identifier\" &&",
                    "      node.key.name === \"template\" &&",
                    "      name === \"value\",",
                    "    ...angularComponentObjectExpressionPredicates",
                    "  );",
                    "}",
                    "const angularComponentObjectExpressionPredicates = [",
                    "  (node, name) => node.type === \"ObjectExpression\" && name === \"properties\",",
                    "  (node, name) =>",
                    "    node.type === \"CallExpression\" &&",
                    "    node.callee.type === \"Identifier\" &&",
                    "    node.callee.name === \"Component\" &&",
                    "    name === \"arguments\",",
                    "  (node, name) => node.type === \"Decorator\" && name === \"expression\",",
                    "];",
                    "",
                    "/**",
                    " * styled-components template literals",
                    " */",
                    "function isStyledComponents(path) {",
                    "  const parent = path.getParentNode();",
                    "",
                    "  if (!parent || parent.type !== \"TaggedTemplateExpression\") {",
                    "    return false;",
                    "  }",
                    "",
                    "  const tag =",
                    "    parent.tag.type === \"ParenthesizedExpression\"",
                    "      ? parent.tag.expression",
                    "      : parent.tag;",
                    "",
                    "  switch (tag.type) {",
                    "    case \"MemberExpression\":",
                    "      return (",
                    "        // styled.foo``",
                    "        isStyledIdentifier(tag.object) ||",
                    "        // Component.extend``",
                    "        isStyledExtend(tag)",
                    "      );",
                    "",
                    "    case \"CallExpression\":",
                    "      return (",
                    "        // styled(Component)``",
                    "        isStyledIdentifier(tag.callee) ||",
                    "        (tag.callee.type === \"MemberExpression\" &&",
                    "          ((tag.callee.object.type === \"MemberExpression\" &&",
                    "            // styled.foo.attrs({})``",
                    "            (isStyledIdentifier(tag.callee.object.object) ||",
                    "              // Component.extend.attrs({})``",
                    "              isStyledExtend(tag.callee.object))) ||",
                    "            // styled(Component).attrs({})``",
                    "            (tag.callee.object.type === \"CallExpression\" &&",
                    "              isStyledIdentifier(tag.callee.object.callee))))",
                    "      );",
                    "",
                    "    case \"Identifier\":",
                    "      // css``",
                    "      return tag.name === \"css\";",
                    "",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * JSX element with CSS prop",
                    " */",
                    "function isCssProp(path) {",
                    "  const parent = path.getParentNode();",
                    "  const parentParent = path.getParentNode(1);",
                    "  return (",
                    "    parentParent &&",
                    "    parent.type === \"JSXExpressionContainer\" &&",
                    "    parentParent.type === \"JSXAttribute\" &&",
                    "    parentParent.name.type === \"JSXIdentifier\" &&",
                    "    parentParent.name.name === \"css\"",
                    "  );",
                    "}",
                    "",
                    "function isStyledIdentifier(node) {",
                    "  return node.type === \"Identifier\" && node.name === \"styled\";",
                    "}",
                    "",
                    "function isStyledExtend(node) {",
                    "  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";",
                    "}",
                    "",
                    "/*",
                    " * react-relay and graphql-tag",
                    " * graphql`...`",
                    " * graphql.experimental`...`",
                    " * gql`...`",
                    " * GraphQL comment block",
                    " *",
                    " * This intentionally excludes Relay Classic tags, as Prettier does not",
                    " * support Relay Classic formatting.",
                    " */",
                    "function isGraphQL(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  return (",
                    "    hasLanguageComment(node, \"GraphQL\") ||",
                    "    (parent &&",
                    "      ((parent.type === \"TaggedTemplateExpression\" &&",
                    "        ((parent.tag.type === \"MemberExpression\" &&",
                    "          parent.tag.object.name === \"graphql\" &&",
                    "          parent.tag.property.name === \"experimental\") ||",
                    "          (parent.tag.type === \"Identifier\" &&",
                    "            (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")))) ||",
                    "        (parent.type === \"CallExpression\" &&",
                    "          parent.callee.type === \"Identifier\" &&",
                    "          parent.callee.name === \"graphql\")))",
                    "  );",
                    "}",
                    "",
                    "function hasLanguageComment(node, languageName) {",
                    "  // This checks for a leading comment that is exactly `/* GraphQL */`",
                    "  // In order to be in line with other implementations of this comment tag",
                    "  // we will not trim the comment value and we will expect exactly one space on",
                    "  // either side of the GraphQL string",
                    "  // Also see ./clean.js",
                    "  return hasComment(",
                    "    node,",
                    "    CommentCheckFlags.Block | CommentCheckFlags.Leading,",
                    "    ({ value }) => value === ` ${languageName} `",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " *     - html`...`",
                    " *     - HTML comment block",
                    " */",
                    "function isHtml(path) {",
                    "  return (",
                    "    hasLanguageComment(path.getValue(), \"HTML\") ||",
                    "    path.match(",
                    "      (node) => node.type === \"TemplateLiteral\",",
                    "      (node, name) =>",
                    "        node.type === \"TaggedTemplateExpression\" &&",
                    "        node.tag.type === \"Identifier\" &&",
                    "        node.tag.name === \"html\" &&",
                    "        name === \"quasi\"",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function hasInvalidCookedValue({ quasis }) {",
                    "  return quasis.some(({ value: { cooked } }) => cooked === null);",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const estreePrinter = require(\"./printer-estree.js\");",
                    "const estreeJsonPrinter = require(\"./printer-estree-json.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parse/parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(",
                    "    require(\"linguist-languages/data/JavaScript.json\"),",
                    "    (data) => ({",
                    "      since: \"0.0.0\",",
                    "      parsers: [",
                    "        \"babel\",",
                    "        \"espree\",",
                    "        \"meriyah\",",
                    "        \"babel-flow\",",
                    "        \"babel-ts\",",
                    "        \"flow\",",
                    "        \"typescript\",",
                    "      ],",
                    "      vscodeLanguageIds: [\"javascript\", \"mongo\"],",
                    "      interpreters: [",
                    "        ...data.interpreters,",
                    "        // https://github.com/google/zx",
                    "        \"zx\",",
                    "      ],",
                    "      extensions: [",
                    "        ...data.extensions.filter((extension) => extension !== \".jsx\"),",
                    "        // WeiXin Script (Weixin Mini Programs)",
                    "        // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                    "        \".wxs\",",
                    "      ],",
                    "    })",
                    "  ),",
                    "  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({",
                    "    name: \"Flow\",",
                    "    since: \"0.0.0\",",
                    "    parsers: [\"flow\", \"babel-flow\"],",
                    "    vscodeLanguageIds: [\"javascript\"],",
                    "    aliases: [],",
                    "    filenames: [],",
                    "    extensions: [\".js.flow\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JavaScript.json\"), () => ({",
                    "    name: \"JSX\",",
                    "    since: \"0.0.0\",",
                    "    parsers: [",
                    "      \"babel\",",
                    "      \"babel-flow\",",
                    "      \"babel-ts\",",
                    "      \"flow\",",
                    "      \"typescript\",",
                    "      \"espree\",",
                    "      \"meriyah\",",
                    "    ],",
                    "    vscodeLanguageIds: [\"javascriptreact\"],",
                    "    aliases: undefined,",
                    "    filenames: undefined,",
                    "    extensions: [\".jsx\"],",
                    "    group: \"JavaScript\",",
                    "    interpreters: undefined,",
                    "    tmScope: \"source.js.jsx\",",
                    "    aceMode: \"javascript\",",
                    "    codemirrorMode: \"jsx\",",
                    "    codemirrorMimeType: \"text/jsx\",",
                    "    color: undefined,",
                    "  })),",
                    "  createLanguage(",
                    "    require(\"linguist-languages/data/TypeScript.json\"),",
                    "    (data) => ({",
                    "      since: \"1.4.0\",",
                    "      parsers: [\"typescript\", \"babel-ts\"],",
                    "      vscodeLanguageIds: [\"typescript\"],",
                    "      extensions: [...data.extensions, \".mts\", \".cts\"],",
                    "    })",
                    "  ),",
                    "  createLanguage(require(\"linguist-languages/data/TSX.json\"), () => ({",
                    "    since: \"1.4.0\",",
                    "    parsers: [\"typescript\", \"babel-ts\"],",
                    "    vscodeLanguageIds: [\"typescriptreact\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JSON.json\"), () => ({",
                    "    name: \"JSON.stringify\",",
                    "    since: \"1.13.0\",",
                    "    parsers: [\"json-stringify\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    extensions: [], // .json file defaults to json instead of json-stringify",
                    "    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/JSON.json\"), (data) => ({",
                    "    since: \"1.5.0\",",
                    "    parsers: [\"json\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    extensions: data.extensions.filter((extension) => extension !== \".jsonl\"),",
                    "  })),",
                    "  createLanguage(",
                    "    require(\"linguist-languages/data/JSON with Comments.json\"),",
                    "    (data) => ({",
                    "      since: \"1.5.0\",",
                    "      parsers: [\"json\"],",
                    "      vscodeLanguageIds: [\"jsonc\"],",
                    "      filenames: [...data.filenames, \".eslintrc\"],",
                    "    })",
                    "  ),",
                    "  createLanguage(require(\"linguist-languages/data/JSON5.json\"), () => ({",
                    "    since: \"1.13.0\",",
                    "    parsers: [\"json5\"],",
                    "    vscodeLanguageIds: [\"json5\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  estree: estreePrinter,",
                    "  \"estree-json\": estreeJsonPrinter,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const isNonEmptyArray = require(\"../utils/is-non-empty-array.js\");",
                    "",
                    "/**",
                    " * @typedef {import(\"./types/estree\").Node} Node",
                    " */",
                    "",
                    "function locStart(node, opts) {",
                    "  const { ignoreDecorators } = opts || {};",
                    "",
                    "  // Handle nodes with decorators. They should start at the first decorator",
                    "  if (!ignoreDecorators) {",
                    "    const decorators =",
                    "      (node.declaration && node.declaration.decorators) || node.decorators;",
                    "",
                    "    if (isNonEmptyArray(decorators)) {",
                    "      return locStart(decorators[0]);",
                    "    }",
                    "  }",
                    "",
                    "  return node.range ? node.range[0] : node.start;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.range ? node.range[1] : node.end;",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLocStart(nodeA, nodeB) {",
                    "  const nodeAStart = locStart(nodeA);",
                    "  return Number.isInteger(nodeAStart) && nodeAStart === locStart(nodeB);",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLocEnd(nodeA, nodeB) {",
                    "  const nodeAEnd = locEnd(nodeA);",
                    "  return Number.isInteger(nodeAEnd) && nodeAEnd === locEnd(nodeB);",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLoc(nodeA, nodeB) {",
                    "  return hasSameLocStart(nodeA, nodeB) && hasSameLocEnd(nodeA, nodeB);",
                    "}",
                    "",
                    "module.exports = {",
                    "  locStart,",
                    "  locEnd,",
                    "  hasSameLocStart,",
                    "  hasSameLoc,",
                    "};"
                ]
            },
            "needs-parens.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const {",
                    "  getFunctionParameters,",
                    "  getLeftSidePathName,",
                    "  hasFlowShorthandAnnotationComment,",
                    "  hasNakedLeftSide,",
                    "  hasNode,",
                    "  isBitwiseOperator,",
                    "  startsWithNoLookaheadToken,",
                    "  shouldFlatten,",
                    "  getPrecedence,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  isObjectProperty,",
                    "} = require(\"./utils/index.js\");",
                    "",
                    "function needsParens(path, options) {",
                    "  const parent = path.getParentNode();",
                    "  if (!parent) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const name = path.getName();",
                    "  const node = path.getNode();",
                    "",
                    "  // to avoid unexpected `}}` in HTML interpolations",
                    "  if (",
                    "    options.__isInHtmlInterpolation &&",
                    "    !options.bracketSpacing &&",
                    "    endsWithRightBracket(node) &&",
                    "    isFollowedByRightBracket(path)",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Only statements don't need parentheses.",
                    "  if (isStatement(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    // Preserve parens if we have a Flow annotation comment, unless we're using the Flow",
                    "    // parser. The Flow parser turns Flow comments into type annotation nodes in its",
                    "    // AST, which we handle separately.",
                    "    options.parser !== \"flow\" &&",
                    "    hasFlowShorthandAnnotationComment(path.getValue())",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Identifiers never need parentheses.",
                    "  if (node.type === \"Identifier\") {",
                    "    // ...unless those identifiers are embed placeholders. They might be substituted by complex",
                    "    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):",
                    "    //     let tpl = html`<script> f((${expr}) / 2); </script>`;",
                    "    // If the inner JS formatter removes the parens, the expression might change its meaning:",
                    "    //     f((a + b) / 2)  vs  f(a + b / 2)",
                    "    if (",
                    "      node.extra &&",
                    "      node.extra.parenthesized &&",
                    "      /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    // `for (async of []);` is invalid",
                    "    if (",
                    "      name === \"left\" &&",
                    "      node.name === \"async\" &&",
                    "      parent.type === \"ForOfStatement\" &&",
                    "      !parent.await",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    return false;",
                    "  }",
                    "",
                    "  switch (parent.type) {",
                    "    case \"ParenthesizedExpression\":",
                    "      return false;",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\": {",
                    "      // Add parens around the extends clause of a class. It is needed for almost",
                    "      // all expressions.",
                    "      if (",
                    "        name === \"superClass\" &&",
                    "        (node.type === \"ArrowFunctionExpression\" ||",
                    "          node.type === \"AssignmentExpression\" ||",
                    "          node.type === \"AwaitExpression\" ||",
                    "          node.type === \"BinaryExpression\" ||",
                    "          node.type === \"ConditionalExpression\" ||",
                    "          node.type === \"LogicalExpression\" ||",
                    "          node.type === \"NewExpression\" ||",
                    "          node.type === \"ObjectExpression\" ||",
                    "          node.type === \"ParenthesizedExpression\" ||",
                    "          node.type === \"SequenceExpression\" ||",
                    "          node.type === \"TaggedTemplateExpression\" ||",
                    "          node.type === \"UnaryExpression\" ||",
                    "          node.type === \"UpdateExpression\" ||",
                    "          node.type === \"YieldExpression\" ||",
                    "          node.type === \"TSNonNullExpression\")",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"ExportDefaultDeclaration\": {",
                    "      return (",
                    "        // `export default function` or `export default class` can't be followed by",
                    "        // anything after. So an expression like `export default (function(){}).toString()`",
                    "        // needs to be followed by a parentheses",
                    "        shouldWrapFunctionForExportDefault(path, options) ||",
                    "        // `export default (foo, bar)` also needs parentheses",
                    "        node.type === \"SequenceExpression\"",
                    "      );",
                    "    }",
                    "    case \"Decorator\": {",
                    "      if (name === \"expression\") {",
                    "        let hasCallExpression = false;",
                    "        let hasMemberExpression = false;",
                    "        let current = node;",
                    "        while (current) {",
                    "          switch (current.type) {",
                    "            case \"MemberExpression\":",
                    "              hasMemberExpression = true;",
                    "              current = current.object;",
                    "              break;",
                    "            case \"CallExpression\":",
                    "              if (",
                    "                /** @(x().y) */ hasMemberExpression ||",
                    "                /** @(x().y()) */ hasCallExpression",
                    "              ) {",
                    "                return options.parser !== \"typescript\";",
                    "              }",
                    "              hasCallExpression = true;",
                    "              current = current.callee;",
                    "              break;",
                    "            case \"Identifier\":",
                    "              return false;",
                    "            case \"TaggedTemplateExpression\":",
                    "              // babel-parser cannot parse",
                    "              //   @foo`bar`",
                    "              return options.parser !== \"typescript\";",
                    "            default:",
                    "              return true;",
                    "          }",
                    "        }",
                    "        return true;",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"ExpressionStatement\": {",
                    "      if (",
                    "        startsWithNoLookaheadToken(",
                    "          node,",
                    "          /* forbidFunctionClassAndDoExpr */ true",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      break;",
                    "    }",
                    "    case \"ArrowFunctionExpression\": {",
                    "      if (",
                    "        name === \"body\" &&",
                    "        node.type !== \"SequenceExpression\" && // these have parens added anyway",
                    "        startsWithNoLookaheadToken(",
                    "          node,",
                    "          /* forbidFunctionClassAndDoExpr */ false",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"UpdateExpression\":",
                    "      if (parent.type === \"UnaryExpression\") {",
                    "        return (",
                    "          node.prefix &&",
                    "          ((node.operator === \"++\" && parent.operator === \"+\") ||",
                    "            (node.operator === \"--\" && parent.operator === \"-\"))",
                    "        );",
                    "      }",
                    "    // else fallthrough",
                    "    case \"UnaryExpression\":",
                    "      switch (parent.type) {",
                    "        case \"UnaryExpression\":",
                    "          return (",
                    "            node.operator === parent.operator &&",
                    "            (node.operator === \"+\" || node.operator === \"-\")",
                    "          );",
                    "",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"BinaryExpression\":",
                    "          return name === \"left\" && parent.operator === \"**\";",
                    "",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"BinaryExpression\": {",
                    "      if (parent.type === \"UpdateExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      // We add parentheses to any `a in b` inside `ForStatement` initializer",
                    "      // https://github.com/prettier/prettier/issues/907#issuecomment-284304321",
                    "      if (node.operator === \"in\" && isPathInForStatementInitializer(path)) {",
                    "        return true;",
                    "      }",
                    "      if (node.operator === \"|>\" && node.extra && node.extra.parenthesized) {",
                    "        const grandParent = path.getParentNode(1);",
                    "        if (",
                    "          grandParent.type === \"BinaryExpression\" &&",
                    "          grandParent.operator === \"|>\"",
                    "        ) {",
                    "          return true;",
                    "        }",
                    "      }",
                    "    }",
                    "    // fallthrough",
                    "    case \"TSTypeAssertion\":",
                    "    case \"TSAsExpression\":",
                    "    case \"LogicalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TSAsExpression\":",
                    "          // example: foo as unknown as Bar",
                    "          return node.type !== \"TSAsExpression\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return node.type === \"TSAsExpression\";",
                    "",
                    "        case \"CallExpression\":",
                    "        case \"NewExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"ClassExpression\":",
                    "        case \"ClassDeclaration\":",
                    "          return name === \"superClass\";",
                    "",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"BindExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"UpdateExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"AssignmentExpression\":",
                    "        case \"AssignmentPattern\":",
                    "          return (",
                    "            name === \"left\" &&",
                    "            (node.type === \"TSTypeAssertion\" || node.type === \"TSAsExpression\")",
                    "          );",
                    "",
                    "        case \"LogicalExpression\":",
                    "          if (node.type === \"LogicalExpression\") {",
                    "            return parent.operator !== node.operator;",
                    "          }",
                    "        // else fallthrough",
                    "",
                    "        case \"BinaryExpression\": {",
                    "          const { operator, type } = node;",
                    "          if (!operator && type !== \"TSTypeAssertion\") {",
                    "            return true;",
                    "          }",
                    "",
                    "          const precedence = getPrecedence(operator);",
                    "          const parentOperator = parent.operator;",
                    "          const parentPrecedence = getPrecedence(parentOperator);",
                    "",
                    "          if (parentPrecedence > precedence) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (name === \"right\" && parentPrecedence === precedence) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (",
                    "            parentPrecedence === precedence &&",
                    "            !shouldFlatten(parentOperator, operator)",
                    "          ) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (parentPrecedence < precedence && operator === \"%\") {",
                    "            return parentOperator === \"+\" || parentOperator === \"-\";",
                    "          }",
                    "",
                    "          // Add parenthesis when working with bitwise operators",
                    "          // It's not strictly needed but helps with code understanding",
                    "          if (isBitwiseOperator(parentOperator)) {",
                    "            return true;",
                    "          }",
                    "",
                    "          return false;",
                    "        }",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"SequenceExpression\":",
                    "      switch (parent.type) {",
                    "        case \"ReturnStatement\":",
                    "          return false;",
                    "",
                    "        case \"ForStatement\":",
                    "          // Although parentheses wouldn't hurt around sequence",
                    "          // expressions in the head of for loops, traditional style",
                    "          // dictates that e.g. i++, j++ should not be wrapped with",
                    "          // parentheses.",
                    "          return false;",
                    "",
                    "        case \"ExpressionStatement\":",
                    "          return name !== \"expression\";",
                    "",
                    "        case \"ArrowFunctionExpression\":",
                    "          // We do need parentheses, but SequenceExpressions are handled",
                    "          // specially when printing bodies of arrow functions.",
                    "          return name !== \"body\";",
                    "",
                    "        default:",
                    "          // Otherwise err on the side of overparenthesization, adding",
                    "          // explicit exceptions above if this proves overzealous.",
                    "          return true;",
                    "      }",
                    "",
                    "    case \"YieldExpression\":",
                    "      if (",
                    "        parent.type === \"UnaryExpression\" ||",
                    "        parent.type === \"AwaitExpression\" ||",
                    "        parent.type === \"TSAsExpression\" ||",
                    "        parent.type === \"TSNonNullExpression\"",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // else fallthrough",
                    "    case \"AwaitExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\";",
                    "",
                    "        case \"BinaryExpression\": {",
                    "          if (!node.argument && parent.operator === \"|>\") {",
                    "            return false;",
                    "          }",
                    "",
                    "          return true;",
                    "        }",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"TSConditionalType\":",
                    "      if (name === \"extendsType\" && parent.type === \"TSConditionalType\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSFunctionType\":",
                    "    case \"TSConstructorType\":",
                    "      if (name === \"checkType\" && parent.type === \"TSConditionalType\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSUnionType\":",
                    "    case \"TSIntersectionType\":",
                    "      if (",
                    "        (parent.type === \"TSUnionType\" ||",
                    "          parent.type === \"TSIntersectionType\") &&",
                    "        parent.types.length > 1 &&",
                    "        (!node.types || node.types.length > 1)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSInferType\":",
                    "      if (node.type === \"TSInferType\" && parent.type === \"TSRestType\") {",
                    "        return false;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSTypeOperator\":",
                    "      return (",
                    "        parent.type === \"TSArrayType\" ||",
                    "        parent.type === \"TSOptionalType\" ||",
                    "        parent.type === \"TSRestType\" ||",
                    "        (name === \"objectType\" && parent.type === \"TSIndexedAccessType\") ||",
                    "        parent.type === \"TSTypeOperator\" ||",
                    "        (parent.type === \"TSTypeAnnotation\" &&",
                    "          path.getParentNode(1).type.startsWith(\"TSJSDoc\"))",
                    "      );",
                    "",
                    "    case \"ArrayTypeAnnotation\":",
                    "      return parent.type === \"NullableTypeAnnotation\";",
                    "",
                    "    case \"IntersectionTypeAnnotation\":",
                    "    case \"UnionTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        parent.type === \"NullableTypeAnnotation\" ||",
                    "        parent.type === \"IntersectionTypeAnnotation\" ||",
                    "        parent.type === \"UnionTypeAnnotation\" ||",
                    "        (name === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\"))",
                    "      );",
                    "",
                    "    case \"NullableTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        (name === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\"))",
                    "      );",
                    "",
                    "    case \"FunctionTypeAnnotation\": {",
                    "      const ancestor =",
                    "        parent.type === \"NullableTypeAnnotation\"",
                    "          ? path.getParentNode(1)",
                    "          : parent;",
                    "",
                    "      return (",
                    "        ancestor.type === \"UnionTypeAnnotation\" ||",
                    "        ancestor.type === \"IntersectionTypeAnnotation\" ||",
                    "        ancestor.type === \"ArrayTypeAnnotation\" ||",
                    "        (name === \"objectType\" &&",
                    "          (ancestor.type === \"IndexedAccessType\" ||",
                    "            ancestor.type === \"OptionalIndexedAccessType\")) ||",
                    "        // We should check ancestor's parent to know whether the parentheses",
                    "        // are really needed, but since ??T doesn't make sense this check",
                    "        // will almost never be true.",
                    "        ancestor.type === \"NullableTypeAnnotation\" ||",
                    "        // See #5283",
                    "        (parent.type === \"FunctionTypeParam\" &&",
                    "          parent.name === null &&",
                    "          getFunctionParameters(node).some(",
                    "            (param) =>",
                    "              param.typeAnnotation &&",
                    "              param.typeAnnotation.type === \"NullableTypeAnnotation\"",
                    "          ))",
                    "      );",
                    "    }",
                    "",
                    "    case \"OptionalIndexedAccessType\":",
                    "      return name === \"objectType\" && parent.type === \"IndexedAccessType\";",
                    "",
                    "    case \"TypeofTypeAnnotation\":",
                    "      return (",
                    "        name === \"objectType\" &&",
                    "        (parent.type === \"IndexedAccessType\" ||",
                    "          parent.type === \"OptionalIndexedAccessType\")",
                    "      );",
                    "",
                    "    case \"StringLiteral\":",
                    "    case \"NumericLiteral\":",
                    "    case \"Literal\":",
                    "      if (",
                    "        typeof node.value === \"string\" &&",
                    "        parent.type === \"ExpressionStatement\" &&",
                    "        !parent.directive",
                    "      ) {",
                    "        // To avoid becoming a directive",
                    "        const grandParent = path.getParentNode(1);",
                    "",
                    "        return (",
                    "          grandParent.type === \"Program\" ||",
                    "          grandParent.type === \"BlockStatement\"",
                    "        );",
                    "      }",
                    "",
                    "      return (",
                    "        name === \"object\" &&",
                    "        parent.type === \"MemberExpression\" &&",
                    "        typeof node.value === \"number\"",
                    "      );",
                    "",
                    "    case \"AssignmentExpression\": {",
                    "      const grandParent = path.getParentNode(1);",
                    "",
                    "      if (name === \"body\" && parent.type === \"ArrowFunctionExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      if (",
                    "        name === \"key\" &&",
                    "        (parent.type === \"ClassProperty\" ||",
                    "          parent.type === \"PropertyDefinition\") &&",
                    "        parent.computed",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        (name === \"init\" || name === \"update\") &&",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"ExpressionStatement\") {",
                    "        return node.left.type === \"ObjectPattern\";",
                    "      }",
                    "",
                    "      if (name === \"key\" && parent.type === \"TSPropertySignature\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"AssignmentExpression\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        parent.type === \"SequenceExpression\" &&",
                    "        grandParent &&",
                    "        grandParent.type === \"ForStatement\" &&",
                    "        (grandParent.init === parent || grandParent.update === parent)",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        name === \"value\" &&",
                    "        parent.type === \"Property\" &&",
                    "        grandParent &&",
                    "        grandParent.type === \"ObjectPattern\" &&",
                    "        grandParent.properties.includes(parent)",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"NGChainedExpression\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      return true;",
                    "    }",
                    "    case \"ConditionalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"SpreadProperty\":",
                    "        case \"BinaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"NGPipeExpression\":",
                    "        case \"ExportDefaultDeclaration\":",
                    "        case \"AwaitExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TypeCastExpression\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\";",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"FunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.",
                    "          // Is necessary if it is `expression` of `ExpressionStatement`.",
                    "          return name === \"callee\";",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true; // This is basically a kind of IIFE.",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ArrowFunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"BinaryExpression\":",
                    "          return (",
                    "            parent.operator !== \"|>\" || (node.extra && node.extra.parenthesized)",
                    "          );",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return name === \"callee\";",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return name === \"object\";",
                    "",
                    "        case \"TSAsExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"BindExpression\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSTypeAssertion\":",
                    "          return true;",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return name === \"test\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ClassExpression\":",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "          return name === \"callee\";",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"OptionalCallExpression\": {",
                    "      const parentParent = path.getParentNode(1);",
                    "      if (",
                    "        (name === \"object\" && parent.type === \"MemberExpression\") ||",
                    "        (name === \"callee\" &&",
                    "          (parent.type === \"CallExpression\" ||",
                    "            parent.type === \"NewExpression\")) ||",
                    "        (parent.type === \"TSNonNullExpression\" &&",
                    "          parentParent.type === \"MemberExpression\" &&",
                    "          parentParent.object === parent)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "    // fallthrough",
                    "    case \"CallExpression\":",
                    "    case \"MemberExpression\":",
                    "    case \"TaggedTemplateExpression\":",
                    "    case \"TSNonNullExpression\":",
                    "      if (",
                    "        name === \"callee\" &&",
                    "        (parent.type === \"BindExpression\" || parent.type === \"NewExpression\")",
                    "      ) {",
                    "        let object = node;",
                    "        while (object) {",
                    "          switch (object.type) {",
                    "            case \"CallExpression\":",
                    "            case \"OptionalCallExpression\":",
                    "              return true;",
                    "            case \"MemberExpression\":",
                    "            case \"OptionalMemberExpression\":",
                    "            case \"BindExpression\":",
                    "              object = object.object;",
                    "              break;",
                    "            // tagged templates are basically member expressions from a grammar perspective",
                    "            // see https://tc39.github.io/ecma262/#prod-MemberExpression",
                    "            case \"TaggedTemplateExpression\":",
                    "              object = object.tag;",
                    "              break;",
                    "            case \"TSNonNullExpression\":",
                    "              object = object.expression;",
                    "              break;",
                    "            default:",
                    "              return false;",
                    "          }",
                    "        }",
                    "      }",
                    "      return false;",
                    "",
                    "    case \"BindExpression\":",
                    "      return (",
                    "        (name === \"callee\" &&",
                    "          (parent.type === \"BindExpression\" ||",
                    "            parent.type === \"NewExpression\")) ||",
                    "        (name === \"object\" && isMemberExpression(parent))",
                    "      );",
                    "    case \"NGPipeExpression\":",
                    "      if (",
                    "        parent.type === \"NGRoot\" ||",
                    "        parent.type === \"NGMicrosyntaxExpression\" ||",
                    "        (parent.type === \"ObjectProperty\" &&",
                    "          // Preserve parens for compatibility with AngularJS expressions",
                    "          !(node.extra && node.extra.parenthesized)) ||",
                    "        parent.type === \"ArrayExpression\" ||",
                    "        (isCallExpression(parent) && parent.arguments[name] === node) ||",
                    "        (name === \"right\" && parent.type === \"NGPipeExpression\") ||",
                    "        (name === \"property\" && parent.type === \"MemberExpression\") ||",
                    "        parent.type === \"AssignmentExpression\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "      return true;",
                    "    case \"JSXFragment\":",
                    "    case \"JSXElement\":",
                    "      return (",
                    "        name === \"callee\" ||",
                    "        (name === \"left\" &&",
                    "          parent.type === \"BinaryExpression\" &&",
                    "          parent.operator === \"<\") ||",
                    "        (parent.type !== \"ArrayExpression\" &&",
                    "          parent.type !== \"ArrowFunctionExpression\" &&",
                    "          parent.type !== \"AssignmentExpression\" &&",
                    "          parent.type !== \"AssignmentPattern\" &&",
                    "          parent.type !== \"BinaryExpression\" &&",
                    "          parent.type !== \"NewExpression\" &&",
                    "          parent.type !== \"ConditionalExpression\" &&",
                    "          parent.type !== \"ExpressionStatement\" &&",
                    "          parent.type !== \"JsExpressionRoot\" &&",
                    "          parent.type !== \"JSXAttribute\" &&",
                    "          parent.type !== \"JSXElement\" &&",
                    "          parent.type !== \"JSXExpressionContainer\" &&",
                    "          parent.type !== \"JSXFragment\" &&",
                    "          parent.type !== \"LogicalExpression\" &&",
                    "          !isCallExpression(parent) &&",
                    "          !isObjectProperty(parent) &&",
                    "          parent.type !== \"ReturnStatement\" &&",
                    "          parent.type !== \"ThrowStatement\" &&",
                    "          parent.type !== \"TypeCastExpression\" &&",
                    "          parent.type !== \"VariableDeclarator\" &&",
                    "          parent.type !== \"YieldExpression\")",
                    "      );",
                    "    case \"TypeAnnotation\":",
                    "      return (",
                    "        name === \"returnType\" &&",
                    "        parent.type === \"ArrowFunctionExpression\" &&",
                    "        includesFunctionTypeInObjectType(node)",
                    "      );",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isStatement(node) {",
                    "  return (",
                    "    node.type === \"BlockStatement\" ||",
                    "    node.type === \"BreakStatement\" ||",
                    "    node.type === \"ClassBody\" ||",
                    "    node.type === \"ClassDeclaration\" ||",
                    "    node.type === \"ClassMethod\" ||",
                    "    node.type === \"ClassProperty\" ||",
                    "    node.type === \"PropertyDefinition\" ||",
                    "    node.type === \"ClassPrivateProperty\" ||",
                    "    node.type === \"ContinueStatement\" ||",
                    "    node.type === \"DebuggerStatement\" ||",
                    "    node.type === \"DeclareClass\" ||",
                    "    node.type === \"DeclareExportAllDeclaration\" ||",
                    "    node.type === \"DeclareExportDeclaration\" ||",
                    "    node.type === \"DeclareFunction\" ||",
                    "    node.type === \"DeclareInterface\" ||",
                    "    node.type === \"DeclareModule\" ||",
                    "    node.type === \"DeclareModuleExports\" ||",
                    "    node.type === \"DeclareVariable\" ||",
                    "    node.type === \"DoWhileStatement\" ||",
                    "    node.type === \"EnumDeclaration\" ||",
                    "    node.type === \"ExportAllDeclaration\" ||",
                    "    node.type === \"ExportDefaultDeclaration\" ||",
                    "    node.type === \"ExportNamedDeclaration\" ||",
                    "    node.type === \"ExpressionStatement\" ||",
                    "    node.type === \"ForInStatement\" ||",
                    "    node.type === \"ForOfStatement\" ||",
                    "    node.type === \"ForStatement\" ||",
                    "    node.type === \"FunctionDeclaration\" ||",
                    "    node.type === \"IfStatement\" ||",
                    "    node.type === \"ImportDeclaration\" ||",
                    "    node.type === \"InterfaceDeclaration\" ||",
                    "    node.type === \"LabeledStatement\" ||",
                    "    node.type === \"MethodDefinition\" ||",
                    "    node.type === \"ReturnStatement\" ||",
                    "    node.type === \"SwitchStatement\" ||",
                    "    node.type === \"ThrowStatement\" ||",
                    "    node.type === \"TryStatement\" ||",
                    "    node.type === \"TSDeclareFunction\" ||",
                    "    node.type === \"TSEnumDeclaration\" ||",
                    "    node.type === \"TSImportEqualsDeclaration\" ||",
                    "    node.type === \"TSInterfaceDeclaration\" ||",
                    "    node.type === \"TSModuleDeclaration\" ||",
                    "    node.type === \"TSNamespaceExportDeclaration\" ||",
                    "    node.type === \"TypeAlias\" ||",
                    "    node.type === \"VariableDeclaration\" ||",
                    "    node.type === \"WhileStatement\" ||",
                    "    node.type === \"WithStatement\"",
                    "  );",
                    "}",
                    "",
                    "function isPathInForStatementInitializer(path) {",
                    "  let i = 0;",
                    "  let node = path.getValue();",
                    "  while (node) {",
                    "    const parent = path.getParentNode(i++);",
                    "    if (parent && parent.type === \"ForStatement\" && parent.init === node) {",
                    "      return true;",
                    "    }",
                    "    node = parent;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function includesFunctionTypeInObjectType(node) {",
                    "  return hasNode(",
                    "    node,",
                    "    (n1) =>",
                    "      (n1.type === \"ObjectTypeAnnotation\" &&",
                    "        hasNode(",
                    "          n1,",
                    "          (n2) => n2.type === \"FunctionTypeAnnotation\" || undefined",
                    "        )) ||",
                    "      undefined",
                    "  );",
                    "}",
                    "",
                    "function endsWithRightBracket(node) {",
                    "  switch (node.type) {",
                    "    case \"ObjectExpression\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "function isFollowedByRightBracket(path) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "  const name = path.getName();",
                    "  switch (parent.type) {",
                    "    case \"NGPipeExpression\":",
                    "      if (",
                    "        typeof name === \"number\" &&",
                    "        parent.arguments[name] === node &&",
                    "        parent.arguments.length - 1 === name",
                    "      ) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ObjectProperty\":",
                    "      if (name === \"value\") {",
                    "        const parentParent = path.getParentNode(1);",
                    "        return getLast(parentParent.properties) === parent;",
                    "      }",
                    "      break;",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "      if (name === \"right\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ConditionalExpression\":",
                    "      if (name === \"alternate\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"UnaryExpression\":",
                    "      if (parent.prefix) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function shouldWrapFunctionForExportDefault(path, options) {",
                    "  const node = path.getValue();",
                    "  const parent = path.getParentNode();",
                    "",
                    "  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {",
                    "    return (",
                    "      parent.type === \"ExportDefaultDeclaration\" ||",
                    "      // in some cases the function is already wrapped",
                    "      // (e.g. `export default (function() {})();`)",
                    "      // in this case we don't need to add extra parens",
                    "      !needsParens(path, options)",
                    "    );",
                    "  }",
                    "",
                    "  if (",
                    "    !hasNakedLeftSide(node) ||",
                    "    (parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return path.call(",
                    "    (childPath) => shouldWrapFunctionForExportDefault(childPath, options),",
                    "    ...getLeftSidePathName(path, node)",
                    "  );",
                    "}",
                    "",
                    "module.exports = needsParens;"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "const CATEGORY_JAVASCRIPT = \"JavaScript\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  arrowParens: {",
                    "    since: \"1.9.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.9.0\", value: \"avoid\" },",
                    "      { since: \"2.0.0\", value: \"always\" },",
                    "    ],",
                    "    description: \"Include parentheses around a sole arrow function parameter.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"always\",",
                    "        description: \"Always include parens. Example: `(x) => x`\",",
                    "      },",
                    "      {",
                    "        value: \"avoid\",",
                    "        description: \"Omit parens when possible. Example: `x => x`\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  bracketSameLine: commonOptions.bracketSameLine,",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  jsxBracketSameLine: {",
                    "    since: \"0.17.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    description: \"Put > on the last line instead of at a new line.\",",
                    "    deprecated: \"2.4.0\",",
                    "  },",
                    "  semi: {",
                    "    since: \"1.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print semicolons.\",",
                    "    oppositeDescription:",
                    "      \"Do not print semicolons, except at the beginning of lines which may need them.\",",
                    "  },",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  jsxSingleQuote: {",
                    "    since: \"1.15.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes in JSX.\",",
                    "  },",
                    "  quoteProps: {",
                    "    since: \"1.17.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"as-needed\",",
                    "    description: \"Change when properties in objects are quoted.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"as-needed\",",
                    "        description: \"Only add quotes around object properties where required.\",",
                    "      },",
                    "      {",
                    "        value: \"consistent\",",
                    "        description:",
                    "          \"If at least one property in an object requires quotes, quote all properties.\",",
                    "      },",
                    "      {",
                    "        value: \"preserve\",",
                    "        description: \"Respect the input use of quotes in object properties.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  trailingComma: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"0.0.0\", value: false },",
                    "      { since: \"0.19.0\", value: \"none\" },",
                    "      { since: \"2.0.0\", value: \"es5\" },",
                    "    ],",
                    "    description: \"Print trailing commas wherever possible when multi-line.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"es5\",",
                    "        description:",
                    "          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",",
                    "      },",
                    "      { value: \"none\", description: \"No trailing commas.\" },",
                    "      {",
                    "        value: \"all\",",
                    "        description:",
                    "          \"Trailing commas wherever possible (including function arguments).\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  singleAttributePerLine: commonOptions.singleAttributePerLine,",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { parseWithComments, strip, extract, print } = require(\"jest-docblock\");",
                    "const { normalizeEndOfLine } = require(\"../common/end-of-line.js\");",
                    "const getShebang = require(\"./utils/get-shebang.js\");",
                    "",
                    "function parseDocBlock(text) {",
                    "  const shebang = getShebang(text);",
                    "  if (shebang) {",
                    "    text = text.slice(shebang.length + 1);",
                    "  }",
                    "",
                    "  const docBlock = extract(text);",
                    "  const { pragmas, comments } = parseWithComments(docBlock);",
                    "",
                    "  return { shebang, text, pragmas, comments };",
                    "}",
                    "",
                    "function hasPragma(text) {",
                    "  const pragmas = Object.keys(parseDocBlock(text).pragmas);",
                    "  return pragmas.includes(\"prettier\") || pragmas.includes(\"format\");",
                    "}",
                    "",
                    "function insertPragma(originalText) {",
                    "  const { shebang, text, pragmas, comments } = parseDocBlock(originalText);",
                    "  const strippedText = strip(text);",
                    "",
                    "  const docBlock = print({",
                    "    pragmas: {",
                    "      format: \"\",",
                    "      ...pragmas,",
                    "    },",
                    "    comments: comments.trimStart(),",
                    "  });",
                    "",
                    "  return (",
                    "    (shebang ? `${shebang}\\n` : \"\") +",
                    "    // normalise newlines (mitigate use of os.EOL by jest-docblock)",
                    "    normalizeEndOfLine(docBlock) +",
                    "    (strippedText.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\") +",
                    "    strippedText",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function preprocess(ast, options) {",
                    "  switch (options.parser) {",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "    case \"__js_expression\":",
                    "    case \"__vue_expression\":",
                    "      return {",
                    "        ...ast,",
                    "        type: options.parser.startsWith(\"__\") ? \"JsExpressionRoot\" : \"JsonRoot\",",
                    "        node: ast,",
                    "        comments: [],",
                    "        rootMarker: options.rootMarker,",
                    "      };",
                    "    default:",
                    "      return ast;",
                    "  }",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-estree-json.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  builders: { hardline, indent, join },",
                    "} = require(\"../document/index.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "  switch (node.type) {",
                    "    case \"JsonRoot\":",
                    "      return [print(\"node\"), hardline];",
                    "    case \"ArrayExpression\": {",
                    "      if (node.elements.length === 0) {",
                    "        return \"[]\";",
                    "      }",
                    "",
                    "      const printed = path.map(",
                    "        () => (path.getValue() === null ? \"null\" : print()),",
                    "        \"elements\"",
                    "      );",
                    "",
                    "      return [",
                    "        \"[\",",
                    "        indent([hardline, join([\",\", hardline], printed)]),",
                    "        hardline,",
                    "        \"]\",",
                    "      ];",
                    "    }",
                    "    case \"ObjectExpression\":",
                    "      return node.properties.length === 0",
                    "        ? \"{}\"",
                    "        : [",
                    "            \"{\",",
                    "            indent([",
                    "              hardline,",
                    "              join([\",\", hardline], path.map(print, \"properties\")),",
                    "            ]),",
                    "            hardline,",
                    "            \"}\",",
                    "          ];",
                    "    case \"ObjectProperty\":",
                    "      return [print(\"key\"), \": \", print(\"value\")];",
                    "    case \"UnaryExpression\":",
                    "      return [node.operator === \"+\" ? \"\" : node.operator, print(\"argument\")];",
                    "    case \"NullLiteral\":",
                    "      return \"null\";",
                    "    case \"BooleanLiteral\":",
                    "      return node.value ? \"true\" : \"false\";",
                    "    case \"StringLiteral\":",
                    "    case \"NumericLiteral\":",
                    "      return JSON.stringify(node.value);",
                    "    case \"Identifier\": {",
                    "      const parent = path.getParentNode();",
                    "      if (parent && parent.type === \"ObjectProperty\" && parent.key === node) {",
                    "        return JSON.stringify(node.name);",
                    "      }",
                    "      return node.name;",
                    "    }",
                    "    case \"TemplateLiteral\":",
                    "      // There is only one `TemplateElement`",
                    "      return print([\"quasis\", 0]);",
                    "    case \"TemplateElement\":",
                    "      return JSON.stringify(node.value.cooked);",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown type: \" + JSON.stringify(node.type));",
                    "  }",
                    "}",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"start\",",
                    "  \"end\",",
                    "  \"extra\",",
                    "  \"loc\",",
                    "  \"comments\",",
                    "  \"leadingComments\",",
                    "  \"trailingComments\",",
                    "  \"innerComments\",",
                    "  \"errors\",",
                    "  \"range\",",
                    "  \"tokens\",",
                    "]);",
                    "",
                    "function clean(node, newNode /*, parent*/) {",
                    "  const { type } = node;",
                    "  // We print quoted key",
                    "  if (type === \"ObjectProperty\" && node.key.type === \"Identifier\") {",
                    "    newNode.key = { type: \"StringLiteral\", value: node.key.name };",
                    "    return;",
                    "  }",
                    "  if (type === \"UnaryExpression\" && node.operator === \"+\") {",
                    "    return newNode.argument;",
                    "  }",
                    "  // We print holes in array as `null`",
                    "  if (type === \"ArrayExpression\") {",
                    "    for (const [index, element] of node.elements.entries()) {",
                    "      if (element === null) {",
                    "        newNode.elements.splice(index, 0, { type: \"NullLiteral\" });",
                    "      }",
                    "    }",
                    "    return;",
                    "  }",
                    "  // We print `TemplateLiteral` as string",
                    "  if (type === \"TemplateLiteral\") {",
                    "    return { type: \"StringLiteral\", value: node.quasis[0].value.cooked };",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "};"
                ]
            },
            "printer-estree.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/** @typedef {import(\"../document\").Doc} Doc */",
                    "",
                    "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
                    "const { printDanglingComments } = require(\"../main/comments.js\");",
                    "const { hasNewline } = require(\"../common/util.js\");",
                    "const {",
                    "  builders: { join, line, hardline, softline, group, indent },",
                    "  utils: { replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "const handleComments = require(\"./comments.js\");",
                    "const pathNeedsParens = require(\"./needs-parens.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "const {",
                    "  hasFlowShorthandAnnotationComment,",
                    "  hasComment,",
                    "  CommentCheckFlags,",
                    "  isTheOnlyJsxElementInMarkdown,",
                    "  isLineComment,",
                    "  isNextLineEmpty,",
                    "  needsHardlineAfterDanglingComment,",
                    "  rawText,",
                    "  hasIgnoreComment,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  markerForIfWithoutBlockAndSameLineComment,",
                    "} = require(\"./utils/index.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const isBlockComment = require(\"./utils/is-block-comment.js\");",
                    "",
                    "const {",
                    "  printHtmlBinding,",
                    "  isVueEventBindingExpression,",
                    "} = require(\"./print/html-binding.js\");",
                    "const { printAngular } = require(\"./print/angular.js\");",
                    "const { printJsx, hasJsxIgnoreComment } = require(\"./print/jsx.js\");",
                    "const { printFlow } = require(\"./print/flow.js\");",
                    "const { printTypescript } = require(\"./print/typescript.js\");",
                    "const {",
                    "  printOptionalToken,",
                    "  printBindExpressionCallee,",
                    "  printTypeAnnotation,",
                    "  adjustClause,",
                    "  printRestSpread,",
                    "} = require(\"./print/misc.js\");",
                    "const {",
                    "  printImportDeclaration,",
                    "  printExportDeclaration,",
                    "  printExportAllDeclaration,",
                    "  printModuleSpecifier,",
                    "} = require(\"./print/module.js\");",
                    "const { printTernary } = require(\"./print/ternary.js\");",
                    "const { printTemplateLiteral } = require(\"./print/template-literal.js\");",
                    "const { printArray } = require(\"./print/array.js\");",
                    "const { printObject } = require(\"./print/object.js\");",
                    "const {",
                    "  printClass,",
                    "  printClassMethod,",
                    "  printClassProperty,",
                    "} = require(\"./print/class.js\");",
                    "const { printProperty } = require(\"./print/property.js\");",
                    "const {",
                    "  printFunction,",
                    "  printArrowFunction,",
                    "  printMethod,",
                    "  printReturnStatement,",
                    "  printThrowStatement,",
                    "} = require(\"./print/function.js\");",
                    "const { printCallExpression } = require(\"./print/call-expression.js\");",
                    "const {",
                    "  printVariableDeclarator,",
                    "  printAssignmentExpression,",
                    "} = require(\"./print/assignment.js\");",
                    "const { printBinaryishExpression } = require(\"./print/binaryish.js\");",
                    "const { printSwitchCaseConsequent } = require(\"./print/statement.js\");",
                    "const { printMemberExpression } = require(\"./print/member.js\");",
                    "const { printBlock, printBlockBody } = require(\"./print/block.js\");",
                    "const { printComment } = require(\"./print/comment.js\");",
                    "const { printLiteral } = require(\"./print/literal.js\");",
                    "const { printDecorators } = require(\"./print/decorators.js\");",
                    "",
                    "function genericPrint(path, options, print, args) {",
                    "  const printed = printPathNoParens(path, options, print, args);",
                    "  if (!printed) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const node = path.getValue();",
                    "  const { type } = node;",
                    "  // Their decorators are handled themselves, and they can't have parentheses",
                    "  if (",
                    "    type === \"ClassMethod\" ||",
                    "    type === \"ClassPrivateMethod\" ||",
                    "    type === \"ClassProperty\" ||",
                    "    type === \"PropertyDefinition\" ||",
                    "    type === \"TSAbstractPropertyDefinition\" ||",
                    "    type === \"ClassPrivateProperty\" ||",
                    "    type === \"MethodDefinition\" ||",
                    "    type === \"TSAbstractMethodDefinition\" ||",
                    "    type === \"TSDeclareMethod\"",
                    "  ) {",
                    "    return printed;",
                    "  }",
                    "",
                    "  const printedDecorators = printDecorators(path, options, print);",
                    "  // Nodes with decorators can't have parentheses and don't need leading semicolons",
                    "  if (printedDecorators) {",
                    "    return group([...printedDecorators, printed]);",
                    "  }",
                    "",
                    "  const needsParens = pathNeedsParens(path, options);",
                    "",
                    "  if (!needsParens) {",
                    "    return args && args.needsSemi ? [\";\", printed] : printed;",
                    "  }",
                    "",
                    "  const parts = [args && args.needsSemi ? \";(\" : \"(\", printed];",
                    "",
                    "  if (hasFlowShorthandAnnotationComment(node)) {",
                    "    const [comment] = node.trailingComments;",
                    "    parts.push(\" /*\", comment.value.trimStart(), \"*/\");",
                    "    comment.printed = true;",
                    "  }",
                    "",
                    "  parts.push(\")\");",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printPathNoParens(path, options, print, args) {",
                    "  const node = path.getValue();",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "",
                    "  if (!node) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (typeof node === \"string\") {",
                    "    return node;",
                    "  }",
                    "",
                    "  for (const printer of [",
                    "    printLiteral,",
                    "    printHtmlBinding,",
                    "    printAngular,",
                    "    printJsx,",
                    "    printFlow,",
                    "    printTypescript,",
                    "  ]) {",
                    "    const printed = printer(path, options, print);",
                    "    if (typeof printed !== \"undefined\") {",
                    "      return printed;",
                    "    }",
                    "  }",
                    "",
                    "  /** @type{Doc[]} */",
                    "  let parts = [];",
                    "",
                    "  switch (node.type) {",
                    "    case \"JsExpressionRoot\":",
                    "      return print(\"node\");",
                    "    case \"JsonRoot\":",
                    "      return [print(\"node\"), hardline];",
                    "    case \"File\":",
                    "      // Print @babel/parser's InterpreterDirective here so that",
                    "      // leading comments on the `Program` node get printed after the hashbang.",
                    "      if (node.program && node.program.interpreter) {",
                    "        parts.push(print([\"program\", \"interpreter\"]));",
                    "      }",
                    "",
                    "      parts.push(print(\"program\"));",
                    "",
                    "      return parts;",
                    "",
                    "    case \"Program\":",
                    "      return printBlockBody(path, options, print);",
                    "    // Babel extension.",
                    "    case \"EmptyStatement\":",
                    "      return \"\";",
                    "    case \"ExpressionStatement\": {",
                    "      // Detect Flow and TypeScript directives",
                    "      if (node.directive) {",
                    "        return [printDirective(node.expression, options), semi];",
                    "      }",
                    "",
                    "      if (options.parser === \"__vue_event_binding\") {",
                    "        const parent = path.getParentNode();",
                    "        if (",
                    "          parent.type === \"Program\" &&",
                    "          parent.body.length === 1 &&",
                    "          parent.body[0] === node",
                    "        ) {",
                    "          return [",
                    "            print(\"expression\"),",
                    "            isVueEventBindingExpression(node.expression) ? \";\" : \"\",",
                    "          ];",
                    "        }",
                    "      }",
                    "",
                    "      const danglingComment = printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /** sameIndent */ true,",
                    "        ({ marker }) => marker === markerForIfWithoutBlockAndSameLineComment",
                    "      );",
                    "",
                    "      // Do not append semicolon after the only JSX element in a program",
                    "      return [",
                    "        print(\"expression\"),",
                    "        isTheOnlyJsxElementInMarkdown(options, path) ? \"\" : semi,",
                    "        danglingComment ? [\" \", danglingComment] : \"\",",
                    "      ];",
                    "    }",
                    "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
                    "    case \"ParenthesizedExpression\": {",
                    "      const shouldHug =",
                    "        !hasComment(node.expression) &&",
                    "        (node.expression.type === \"ObjectExpression\" ||",
                    "          node.expression.type === \"ArrayExpression\");",
                    "      if (shouldHug) {",
                    "        return [\"(\", print(\"expression\"), \")\"];",
                    "      }",
                    "      return group([",
                    "        \"(\",",
                    "        indent([softline, print(\"expression\")]),",
                    "        softline,",
                    "        \")\",",
                    "      ]);",
                    "    }",
                    "    case \"AssignmentExpression\":",
                    "      return printAssignmentExpression(path, options, print);",
                    "    case \"VariableDeclarator\":",
                    "      return printVariableDeclarator(path, options, print);",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "      return printBinaryishExpression(path, options, print);",
                    "    case \"AssignmentPattern\":",
                    "      return [print(\"left\"), \" = \", print(\"right\")];",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"MemberExpression\": {",
                    "      return printMemberExpression(path, options, print);",
                    "    }",
                    "    case \"MetaProperty\":",
                    "      return [print(\"meta\"), \".\", print(\"property\")];",
                    "    case \"BindExpression\":",
                    "      if (node.object) {",
                    "        parts.push(print(\"object\"));",
                    "      }",
                    "",
                    "      parts.push(",
                    "        group(",
                    "          indent([softline, printBindExpressionCallee(path, options, print)])",
                    "        )",
                    "      );",
                    "",
                    "      return parts;",
                    "    case \"Identifier\": {",
                    "      return [",
                    "        node.name,",
                    "        printOptionalToken(path),",
                    "        printTypeAnnotation(path, options, print),",
                    "      ];",
                    "    }",
                    "    case \"V8IntrinsicIdentifier\":",
                    "      return [\"%\", node.name];",
                    "    case \"SpreadElement\":",
                    "    case \"SpreadElementPattern\":",
                    "    case \"SpreadProperty\":",
                    "    case \"SpreadPropertyPattern\":",
                    "    case \"RestElement\":",
                    "      return printRestSpread(path, options, print);",
                    "    case \"FunctionDeclaration\":",
                    "    case \"FunctionExpression\":",
                    "      return printFunction(path, print, options, args);",
                    "    case \"ArrowFunctionExpression\":",
                    "      return printArrowFunction(path, options, print, args);",
                    "    case \"YieldExpression\":",
                    "      parts.push(\"yield\");",
                    "",
                    "      if (node.delegate) {",
                    "        parts.push(\"*\");",
                    "      }",
                    "      if (node.argument) {",
                    "        parts.push(\" \", print(\"argument\"));",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"AwaitExpression\": {",
                    "      parts.push(\"await\");",
                    "      if (node.argument) {",
                    "        parts.push(\" \", print(\"argument\"));",
                    "        const parent = path.getParentNode();",
                    "        if (",
                    "          (isCallExpression(parent) && parent.callee === node) ||",
                    "          (isMemberExpression(parent) && parent.object === node)",
                    "        ) {",
                    "          parts = [indent([softline, ...parts]), softline];",
                    "          const parentAwaitOrBlock = path.findAncestor(",
                    "            (node) =>",
                    "              node.type === \"AwaitExpression\" || node.type === \"BlockStatement\"",
                    "          );",
                    "          if (",
                    "            !parentAwaitOrBlock ||",
                    "            parentAwaitOrBlock.type !== \"AwaitExpression\"",
                    "          ) {",
                    "            return group(parts);",
                    "          }",
                    "        }",
                    "      }",
                    "      return parts;",
                    "    }",
                    "    case \"ExportDefaultDeclaration\":",
                    "    case \"ExportNamedDeclaration\":",
                    "      return printExportDeclaration(path, options, print);",
                    "    case \"ExportAllDeclaration\":",
                    "      return printExportAllDeclaration(path, options, print);",
                    "    case \"ImportDeclaration\":",
                    "      return printImportDeclaration(path, options, print);",
                    "    case \"ImportSpecifier\":",
                    "    case \"ExportSpecifier\":",
                    "    case \"ImportNamespaceSpecifier\":",
                    "    case \"ExportNamespaceSpecifier\":",
                    "    case \"ImportDefaultSpecifier\":",
                    "    case \"ExportDefaultSpecifier\":",
                    "      return printModuleSpecifier(path, options, print);",
                    "    case \"ImportAttribute\":",
                    "      return [print(\"key\"), \": \", print(\"value\")];",
                    "    case \"Import\":",
                    "      return \"import\";",
                    "    case \"BlockStatement\":",
                    "    case \"StaticBlock\":",
                    "    case \"ClassBody\":",
                    "      return printBlock(path, options, print);",
                    "    case \"ThrowStatement\":",
                    "      return printThrowStatement(path, options, print);",
                    "    case \"ReturnStatement\":",
                    "      return printReturnStatement(path, options, print);",
                    "    case \"NewExpression\":",
                    "    case \"ImportExpression\":",
                    "    case \"OptionalCallExpression\":",
                    "    case \"CallExpression\":",
                    "      return printCallExpression(path, options, print);",
                    "",
                    "    case \"ObjectExpression\":",
                    "    case \"ObjectPattern\":",
                    "    case \"RecordExpression\":",
                    "      return printObject(path, options, print);",
                    "    // Babel 6",
                    "    case \"ObjectProperty\": // Non-standard AST node type.",
                    "    case \"Property\":",
                    "      if (node.method || node.kind === \"get\" || node.kind === \"set\") {",
                    "        return printMethod(path, options, print);",
                    "      }",
                    "      return printProperty(path, options, print);",
                    "    case \"ObjectMethod\":",
                    "      return printMethod(path, options, print);",
                    "    case \"Decorator\":",
                    "      return [\"@\", print(\"expression\")];",
                    "    case \"ArrayExpression\":",
                    "    case \"ArrayPattern\":",
                    "    case \"TupleExpression\":",
                    "      return printArray(path, options, print);",
                    "    case \"SequenceExpression\": {",
                    "      const parent = path.getParentNode(0);",
                    "      if (",
                    "        parent.type === \"ExpressionStatement\" ||",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        // For ExpressionStatements and for-loop heads, which are among",
                    "        // the few places a SequenceExpression appears unparenthesized, we want",
                    "        // to indent expressions after the first.",
                    "        const parts = [];",
                    "        path.each((expressionPath, index) => {",
                    "          if (index === 0) {",
                    "            parts.push(print());",
                    "          } else {",
                    "            parts.push(\",\", indent([line, print()]));",
                    "          }",
                    "        }, \"expressions\");",
                    "        return group(parts);",
                    "      }",
                    "      return group(join([\",\", line], path.map(print, \"expressions\")));",
                    "    }",
                    "    case \"ThisExpression\":",
                    "      return \"this\";",
                    "    case \"Super\":",
                    "      return \"super\";",
                    "    case \"Directive\":",
                    "      return [print(\"value\"), semi]; // Babel 6",
                    "    case \"DirectiveLiteral\":",
                    "      return printDirective(node, options);",
                    "    case \"UnaryExpression\":",
                    "      parts.push(node.operator);",
                    "",
                    "      if (/[a-z]$/.test(node.operator)) {",
                    "        parts.push(\" \");",
                    "      }",
                    "",
                    "      if (hasComment(node.argument)) {",
                    "        parts.push(",
                    "          group([\"(\", indent([softline, print(\"argument\")]), softline, \")\"])",
                    "        );",
                    "      } else {",
                    "        parts.push(print(\"argument\"));",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"UpdateExpression\":",
                    "      parts.push(print(\"argument\"), node.operator);",
                    "",
                    "      if (node.prefix) {",
                    "        parts.reverse();",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"ConditionalExpression\":",
                    "      return printTernary(path, options, print);",
                    "    case \"VariableDeclaration\": {",
                    "      const printed = path.map(print, \"declarations\");",
                    "",
                    "      // We generally want to terminate all variable declarations with a",
                    "      // semicolon, except when they in the () part of for loops.",
                    "      const parentNode = path.getParentNode();",
                    "",
                    "      const isParentForLoop =",
                    "        parentNode.type === \"ForStatement\" ||",
                    "        parentNode.type === \"ForInStatement\" ||",
                    "        parentNode.type === \"ForOfStatement\";",
                    "",
                    "      const hasValue = node.declarations.some((decl) => decl.init);",
                    "",
                    "      let firstVariable;",
                    "      if (printed.length === 1 && !hasComment(node.declarations[0])) {",
                    "        firstVariable = printed[0];",
                    "      } else if (printed.length > 0) {",
                    "        // Indent first var to comply with eslint one-var rule",
                    "        firstVariable = indent(printed[0]);",
                    "      }",
                    "",
                    "      parts = [",
                    "        node.declare ? \"declare \" : \"\",",
                    "        node.kind,",
                    "        firstVariable ? [\" \", firstVariable] : \"\",",
                    "        indent(",
                    "          printed",
                    "            .slice(1)",
                    "            .map((p) => [",
                    "              \",\",",
                    "              hasValue && !isParentForLoop ? hardline : line,",
                    "              p,",
                    "            ])",
                    "        ),",
                    "      ];",
                    "",
                    "      if (!(isParentForLoop && parentNode.body !== node)) {",
                    "        parts.push(semi);",
                    "      }",
                    "",
                    "      return group(parts);",
                    "    }",
                    "    case \"WithStatement\":",
                    "      return group([",
                    "        \"with (\",",
                    "        print(\"object\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "    case \"IfStatement\": {",
                    "      const con = adjustClause(node.consequent, print(\"consequent\"));",
                    "      const opening = group([",
                    "        \"if (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        con,",
                    "      ]);",
                    "",
                    "      parts.push(opening);",
                    "",
                    "      if (node.alternate) {",
                    "        const commentOnOwnLine =",
                    "          hasComment(",
                    "            node.consequent,",
                    "            CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                    "          ) || needsHardlineAfterDanglingComment(node);",
                    "        const elseOnSameLine =",
                    "          node.consequent.type === \"BlockStatement\" && !commentOnOwnLine;",
                    "        parts.push(elseOnSameLine ? \" \" : hardline);",
                    "",
                    "        if (hasComment(node, CommentCheckFlags.Dangling)) {",
                    "          parts.push(",
                    "            printDanglingComments(path, options, true),",
                    "            commentOnOwnLine ? hardline : \" \"",
                    "          );",
                    "        }",
                    "",
                    "        parts.push(",
                    "          \"else\",",
                    "          group(",
                    "            adjustClause(",
                    "              node.alternate,",
                    "              print(\"alternate\"),",
                    "              node.alternate.type === \"IfStatement\"",
                    "            )",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    case \"ForStatement\": {",
                    "      const body = adjustClause(node.body, print(\"body\"));",
                    "",
                    "      // We want to keep dangling comments above the loop to stay consistent.",
                    "      // Any comment positioned between the for statement and the parentheses",
                    "      // is going to be printed before the statement.",
                    "      const dangling = printDanglingComments(",
                    "        path,",
                    "        options,",
                    "        /* sameLine */ true",
                    "      );",
                    "      const printedComments = dangling ? [dangling, softline] : \"\";",
                    "",
                    "      if (!node.init && !node.test && !node.update) {",
                    "        return [printedComments, group([\"for (;;)\", body])];",
                    "      }",
                    "",
                    "      return [",
                    "        printedComments,",
                    "        group([",
                    "          \"for (\",",
                    "          group([",
                    "            indent([",
                    "              softline,",
                    "              print(\"init\"),",
                    "              \";\",",
                    "              line,",
                    "              print(\"test\"),",
                    "              \";\",",
                    "              line,",
                    "              print(\"update\"),",
                    "            ]),",
                    "            softline,",
                    "          ]),",
                    "          \")\",",
                    "          body,",
                    "        ]),",
                    "      ];",
                    "    }",
                    "    case \"WhileStatement\":",
                    "      return group([",
                    "        \"while (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "    case \"ForInStatement\":",
                    "      return group([",
                    "        \"for (\",",
                    "        print(\"left\"),",
                    "        \" in \",",
                    "        print(\"right\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "",
                    "    case \"ForOfStatement\":",
                    "      return group([",
                    "        \"for\",",
                    "        node.await ? \" await\" : \"\",",
                    "        \" (\",",
                    "        print(\"left\"),",
                    "        \" of \",",
                    "        print(\"right\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "",
                    "    case \"DoWhileStatement\": {",
                    "      const clause = adjustClause(node.body, print(\"body\"));",
                    "      const doBody = group([\"do\", clause]);",
                    "      parts = [doBody];",
                    "",
                    "      if (node.body.type === \"BlockStatement\") {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(hardline);",
                    "      }",
                    "      parts.push(",
                    "        \"while (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        semi",
                    "      );",
                    "",
                    "      return parts;",
                    "    }",
                    "    case \"DoExpression\":",
                    "      return [node.async ? \"async \" : \"\", \"do \", print(\"body\")];",
                    "    case \"BreakStatement\":",
                    "      parts.push(\"break\");",
                    "",
                    "      if (node.label) {",
                    "        parts.push(\" \", print(\"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return parts;",
                    "    case \"ContinueStatement\":",
                    "      parts.push(\"continue\");",
                    "",
                    "      if (node.label) {",
                    "        parts.push(\" \", print(\"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return parts;",
                    "    case \"LabeledStatement\":",
                    "      if (node.body.type === \"EmptyStatement\") {",
                    "        return [print(\"label\"), \":;\"];",
                    "      }",
                    "",
                    "      return [print(\"label\"), \": \", print(\"body\")];",
                    "    case \"TryStatement\":",
                    "      return [",
                    "        \"try \",",
                    "        print(\"block\"),",
                    "        node.handler ? [\" \", print(\"handler\")] : \"\",",
                    "        node.finalizer ? [\" finally \", print(\"finalizer\")] : \"\",",
                    "      ];",
                    "    case \"CatchClause\":",
                    "      if (node.param) {",
                    "        const parameterHasComments = hasComment(",
                    "          node.param,",
                    "          (comment) =>",
                    "            !isBlockComment(comment) ||",
                    "            (comment.leading &&",
                    "              hasNewline(options.originalText, locEnd(comment))) ||",
                    "            (comment.trailing &&",
                    "              hasNewline(options.originalText, locStart(comment), {",
                    "                backwards: true,",
                    "              }))",
                    "        );",
                    "        const param = print(\"param\");",
                    "",
                    "        return [",
                    "          \"catch \",",
                    "          parameterHasComments",
                    "            ? [\"(\", indent([softline, param]), softline, \") \"]",
                    "            : [\"(\", param, \") \"],",
                    "          print(\"body\"),",
                    "        ];",
                    "      }",
                    "",
                    "      return [\"catch \", print(\"body\")];",
                    "    // Note: ignoring n.lexical because it has no printing consequences.",
                    "    case \"SwitchStatement\":",
                    "      return [",
                    "        group([",
                    "          \"switch (\",",
                    "          indent([softline, print(\"discriminant\")]),",
                    "          softline,",
                    "          \")\",",
                    "        ]),",
                    "        \" {\",",
                    "        node.cases.length > 0",
                    "          ? indent([",
                    "              hardline,",
                    "              join(",
                    "                hardline,",
                    "                path.map((casePath, index, cases) => {",
                    "                  const caseNode = casePath.getValue();",
                    "                  return [",
                    "                    print(),",
                    "                    index !== cases.length - 1 &&",
                    "                    isNextLineEmpty(caseNode, options)",
                    "                      ? hardline",
                    "                      : \"\",",
                    "                  ];",
                    "                }, \"cases\")",
                    "              ),",
                    "            ])",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "    case \"SwitchCase\": {",
                    "      if (node.test) {",
                    "        parts.push(\"case \", print(\"test\"), \":\");",
                    "      } else {",
                    "        parts.push(\"default:\");",
                    "      }",
                    "",
                    "      const consequent = node.consequent.filter(",
                    "        (node) => node.type !== \"EmptyStatement\"",
                    "      );",
                    "",
                    "      if (consequent.length > 0) {",
                    "        const cons = printSwitchCaseConsequent(path, options, print);",
                    "",
                    "        parts.push(",
                    "          consequent.length === 1 && consequent[0].type === \"BlockStatement\"",
                    "            ? [\" \", cons]",
                    "            : indent([hardline, cons])",
                    "        );",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    // JSX extensions below.",
                    "    case \"DebuggerStatement\":",
                    "      return [\"debugger\", semi];",
                    "",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\":",
                    "      return printClass(path, options, print);",
                    "    case \"ClassMethod\":",
                    "    case \"ClassPrivateMethod\":",
                    "    case \"MethodDefinition\":",
                    "      return printClassMethod(path, options, print);",
                    "    case \"ClassProperty\":",
                    "    case \"PropertyDefinition\":",
                    "    case \"ClassPrivateProperty\":",
                    "      return printClassProperty(path, options, print);",
                    "    case \"TemplateElement\":",
                    "      return replaceTextEndOfLine(node.value.raw);",
                    "    case \"TemplateLiteral\":",
                    "      return printTemplateLiteral(path, print, options);",
                    "    case \"TaggedTemplateExpression\":",
                    "      return [print(\"tag\"), print(\"typeParameters\"), print(\"quasi\")];",
                    "    case \"PrivateIdentifier\":",
                    "      return [\"#\", print(\"name\")];",
                    "    case \"PrivateName\":",
                    "      return [\"#\", print(\"id\")];",
                    "",
                    "    case \"InterpreterDirective\":",
                    "      parts.push(\"#!\", node.value, hardline);",
                    "",
                    "      if (isNextLineEmpty(node, options)) {",
                    "        parts.push(hardline);",
                    "      }",
                    "",
                    "      return parts;",
                    "",
                    "    // For hack-style pipeline",
                    "    case \"TopicReference\":",
                    "      return \"%\";",
                    "",
                    "    case \"ArgumentPlaceholder\":",
                    "      return \"?\";",
                    "",
                    "    case \"ModuleExpression\": {",
                    "      parts.push(\"module {\");",
                    "      const printed = print(\"body\");",
                    "      if (printed) {",
                    "        parts.push(indent([hardline, printed]), hardline);",
                    "      }",
                    "      parts.push(\"}\");",
                    "      return parts;",
                    "    }",
                    "",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(\"unknown type: \" + JSON.stringify(node.type));",
                    "  }",
                    "}",
                    "",
                    "function printDirective(node, options) {",
                    "  const raw = rawText(node);",
                    "  const rawContent = raw.slice(1, -1);",
                    "",
                    "  // Check for the alternate quote, to determine if we're allowed to swap",
                    "  // the quotes on a DirectiveLiteral.",
                    "  if (rawContent.includes('\"') || rawContent.includes(\"'\")) {",
                    "    return raw;",
                    "  }",
                    "",
                    "  const enclosingQuote = options.singleQuote ? \"'\" : '\"';",
                    "",
                    "  // Directives are exact code unit sequences, which means that you can't",
                    "  // change the escape sequences they use.",
                    "  // See https://github.com/prettier/prettier/issues/1555",
                    "  // and https://tc39.github.io/ecma262/#directive-prologue",
                    "  return enclosingQuote + rawContent + enclosingQuote;",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return (",
                    "    node.type &&",
                    "    !isBlockComment(node) &&",
                    "    !isLineComment(node) &&",
                    "    node.type !== \"EmptyStatement\" &&",
                    "    node.type !== \"TemplateElement\" &&",
                    "    node.type !== \"Import\" &&",
                    "    // `babel-ts` don't have similar node for `class Foo { bar() /* bat */; }`",
                    "    node.type !== \"TSEmptyBodyFunctionExpression\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  embed,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore(path) {",
                    "    return hasIgnoreComment(path) || hasJsxIgnoreComment(path);",
                    "  },",
                    "  willPrintOwnComments: handleComments.willPrintOwnComments,",
                    "  canAttachComment,",
                    "  printComment,",
                    "  isBlockComment,",
                    "  handleComments: {",
                    "    // TODO: Make this as default behavior",
                    "    avoidAstMutation: true,",
                    "    ownLine: handleComments.handleOwnLineComment,",
                    "    endOfLine: handleComments.handleEndOfLineComment,",
                    "    remaining: handleComments.handleRemainingComment,",
                    "  },",
                    "  getCommentChildNodes: handleComments.getCommentChildNodes,",
                    "};"
                ]
            },
            "embed": {
                "css.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { indent, hardline, softline },",
                        "  utils: { mapDoc, replaceEndOfLine, cleanDoc },",
                        "} = require(\"../../document/index.js\");",
                        "const { printTemplateExpressions } = require(\"../print/template-literal.js\");",
                        "",
                        "function format(path, print, textToDoc) {",
                        "  const node = path.getValue();",
                        "",
                        "  // Get full template literal with expressions replaced by placeholders",
                        "  const rawQuasis = node.quasis.map((q) => q.value.raw);",
                        "  let placeholderID = 0;",
                        "  const text = rawQuasis.reduce(",
                        "    (prevVal, currVal, idx) =>",
                        "      idx === 0",
                        "        ? currVal",
                        "        : prevVal +",
                        "          \"@prettier-placeholder-\" +",
                        "          placeholderID++ +",
                        "          \"-id\" +",
                        "          currVal,",
                        "    \"\"",
                        "  );",
                        "  const doc = textToDoc(",
                        "    text,",
                        "    { parser: \"scss\" },",
                        "    { stripTrailingHardline: true }",
                        "  );",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  return transformCssDoc(doc, node, expressionDocs);",
                        "}",
                        "",
                        "function transformCssDoc(quasisDoc, parentNode, expressionDocs) {",
                        "  const isEmpty =",
                        "    parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();",
                        "  if (isEmpty) {",
                        "    return \"``\";",
                        "  }",
                        "",
                        "  const newDoc = replacePlaceholders(quasisDoc, expressionDocs);",
                        "  /* istanbul ignore if */",
                        "  if (!newDoc) {",
                        "    throw new Error(\"Couldn't insert all the expressions\");",
                        "  }",
                        "  return [\"`\", indent([hardline, newDoc]), softline, \"`\"];",
                        "}",
                        "",
                        "// Search all the placeholders in the quasisDoc tree",
                        "// and replace them with the expression docs one by one",
                        "// returns a new doc with all the placeholders replaced,",
                        "// or null if it couldn't replace any expression",
                        "function replacePlaceholders(quasisDoc, expressionDocs) {",
                        "  if (!isNonEmptyArray(expressionDocs)) {",
                        "    return quasisDoc;",
                        "  }",
                        "  let replaceCounter = 0;",
                        "  const newDoc = mapDoc(cleanDoc(quasisDoc), (doc) => {",
                        "    if (typeof doc !== \"string\" || !doc.includes(\"@prettier-placeholder\")) {",
                        "      return doc;",
                        "    }",
                        "    // When we have multiple placeholders in one line, like:",
                        "    // ${Child}${Child2}:not(:first-child)",
                        "    return doc.split(/@prettier-placeholder-(\\d+)-id/).map((component, idx) => {",
                        "      // The placeholder is always at odd indices",
                        "      if (idx % 2 === 0) {",
                        "        return replaceEndOfLine(component);",
                        "      }",
                        "",
                        "      // The component will always be a number at odd index",
                        "      replaceCounter++;",
                        "      return expressionDocs[component];",
                        "    });",
                        "  });",
                        "  return expressionDocs.length === replaceCounter ? newDoc : null;",
                        "}",
                        "",
                        "module.exports = format;"
                    ]
                },
                "graphql.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { indent, join, hardline },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  escapeTemplateCharacters,",
                        "  printTemplateExpressions,",
                        "} = require(\"../print/template-literal.js\");",
                        "",
                        "function format(path, print, textToDoc) {",
                        "  const node = path.getValue();",
                        "",
                        "  const numQuasis = node.quasis.length;",
                        "  if (numQuasis === 1 && node.quasis[0].value.raw.trim() === \"\") {",
                        "    return \"``\";",
                        "  }",
                        "",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  const parts = [];",
                        "",
                        "  for (let i = 0; i < numQuasis; i++) {",
                        "    const templateElement = node.quasis[i];",
                        "    const isFirst = i === 0;",
                        "    const isLast = i === numQuasis - 1;",
                        "    const text = templateElement.value.cooked;",
                        "",
                        "    const lines = text.split(\"\\n\");",
                        "    const numLines = lines.length;",
                        "    const expressionDoc = expressionDocs[i];",
                        "",
                        "    const startsWithBlankLine =",
                        "      numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";",
                        "    const endsWithBlankLine =",
                        "      numLines > 2 &&",
                        "      lines[numLines - 1].trim() === \"\" &&",
                        "      lines[numLines - 2].trim() === \"\";",
                        "",
                        "    const commentsAndWhitespaceOnly = lines.every((line) =>",
                        "      /^\\s*(?:#[^\\n\\r]*)?$/.test(line)",
                        "    );",
                        "",
                        "    // Bail out if an interpolation occurs within a comment.",
                        "    if (!isLast && /#[^\\n\\r]*$/.test(lines[numLines - 1])) {",
                        "      return null;",
                        "    }",
                        "",
                        "    let doc = null;",
                        "",
                        "    if (commentsAndWhitespaceOnly) {",
                        "      doc = printGraphqlComments(lines);",
                        "    } else {",
                        "      doc = textToDoc(",
                        "        text,",
                        "        { parser: \"graphql\" },",
                        "        { stripTrailingHardline: true }",
                        "      );",
                        "    }",
                        "",
                        "    if (doc) {",
                        "      doc = escapeTemplateCharacters(doc, false);",
                        "      if (!isFirst && startsWithBlankLine) {",
                        "        parts.push(\"\");",
                        "      }",
                        "      parts.push(doc);",
                        "      if (!isLast && endsWithBlankLine) {",
                        "        parts.push(\"\");",
                        "      }",
                        "    } else if (!isFirst && !isLast && startsWithBlankLine) {",
                        "      parts.push(\"\");",
                        "    }",
                        "",
                        "    if (expressionDoc) {",
                        "      parts.push(expressionDoc);",
                        "    }",
                        "  }",
                        "",
                        "  return [\"`\", indent([hardline, join(hardline, parts)]), hardline, \"`\"];",
                        "}",
                        "",
                        "function printGraphqlComments(lines) {",
                        "  const parts = [];",
                        "  let seenComment = false;",
                        "",
                        "  const array = lines.map((textLine) => textLine.trim());",
                        "  for (const [i, textLine] of array.entries()) {",
                        "    // Lines are either whitespace only, or a comment (with potential whitespace",
                        "    // around it). Drop whitespace-only lines.",
                        "    if (textLine === \"\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (array[i - 1] === \"\" && seenComment) {",
                        "      // If a non-first comment is preceded by a blank (whitespace only) line,",
                        "      // add in a blank line.",
                        "      parts.push([hardline, textLine]);",
                        "    } else {",
                        "      parts.push(textLine);",
                        "    }",
                        "",
                        "    seenComment = true;",
                        "  }",
                        "",
                        "  // If `lines` was whitespace only, return `null`.",
                        "  return parts.length === 0 ? null : join(hardline, parts);",
                        "}",
                        "",
                        "module.exports = format;"
                    ]
                },
                "html.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { indent, line, hardline, group },",
                        "  utils: { mapDoc },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  printTemplateExpressions,",
                        "  uncookTemplateElementValue,",
                        "} = require(\"../print/template-literal.js\");",
                        "",
                        "// The counter is needed to distinguish nested embeds.",
                        "let htmlTemplateLiteralCounter = 0;",
                        "function format(path, print, textToDoc, options, { parser }) {",
                        "  const node = path.getValue();",
                        "  const counter = htmlTemplateLiteralCounter;",
                        "  htmlTemplateLiteralCounter = (htmlTemplateLiteralCounter + 1) >>> 0;",
                        "",
                        "  const composePlaceholder = (index) =>",
                        "    `PRETTIER_HTML_PLACEHOLDER_${index}_${counter}_IN_JS`;",
                        "",
                        "  const text = node.quasis",
                        "    .map((quasi, index, quasis) =>",
                        "      index === quasis.length - 1",
                        "        ? quasi.value.cooked",
                        "        : quasi.value.cooked + composePlaceholder(index)",
                        "    )",
                        "    .join(\"\");",
                        "",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  if (expressionDocs.length === 0 && text.trim().length === 0) {",
                        "    return \"``\";",
                        "  }",
                        "",
                        "  const placeholderRegex = new RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");",
                        "  let topLevelCount = 0;",
                        "  const doc = textToDoc(",
                        "    text,",
                        "    {",
                        "      parser,",
                        "      __onHtmlRoot(root) {",
                        "        topLevelCount = root.children.length;",
                        "      },",
                        "    },",
                        "    { stripTrailingHardline: true }",
                        "  );",
                        "",
                        "  const contentDoc = mapDoc(doc, (doc) => {",
                        "    if (typeof doc !== \"string\") {",
                        "      return doc;",
                        "    }",
                        "",
                        "    const parts = [];",
                        "",
                        "    const components = doc.split(placeholderRegex);",
                        "    for (let i = 0; i < components.length; i++) {",
                        "      let component = components[i];",
                        "",
                        "      if (i % 2 === 0) {",
                        "        if (component) {",
                        "          component = uncookTemplateElementValue(component);",
                        "          if (options.__embeddedInHtml) {",
                        "            component = component.replace(/<\\/(script)\\b/gi, \"<\\\\/$1\");",
                        "          }",
                        "          parts.push(component);",
                        "        }",
                        "        continue;",
                        "      }",
                        "",
                        "      const placeholderIndex = Number(component);",
                        "      parts.push(expressionDocs[placeholderIndex]);",
                        "    }",
                        "",
                        "    return parts;",
                        "  });",
                        "",
                        "  const leadingWhitespace = /^\\s/.test(text) ? \" \" : \"\";",
                        "  const trailingWhitespace = /\\s$/.test(text) ? \" \" : \"\";",
                        "",
                        "  const linebreak =",
                        "    options.htmlWhitespaceSensitivity === \"ignore\"",
                        "      ? hardline",
                        "      : leadingWhitespace && trailingWhitespace",
                        "      ? line",
                        "      : null;",
                        "",
                        "  if (linebreak) {",
                        "    return group([\"`\", indent([linebreak, group(contentDoc)]), linebreak, \"`\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    \"`\",",
                        "    leadingWhitespace,",
                        "    topLevelCount > 1 ? indent(group(contentDoc)) : group(contentDoc),",
                        "    trailingWhitespace,",
                        "    \"`\",",
                        "  ]);",
                        "}",
                        "",
                        "module.exports = format;"
                    ]
                },
                "markdown.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { indent, softline, literalline, dedentToRoot },",
                        "} = require(\"../../document/index.js\");",
                        "const { escapeTemplateCharacters } = require(\"../print/template-literal.js\");",
                        "",
                        "function format(path, print, textToDoc) {",
                        "  const node = path.getValue();",
                        "  let text = node.quasis[0].value.raw.replace(",
                        "    /((?:\\\\\\\\)*)\\\\`/g,",
                        "    (_, backslashes) => \"\\\\\".repeat(backslashes.length / 2) + \"`\"",
                        "  );",
                        "  const indentation = getIndentation(text);",
                        "  const hasIndent = indentation !== \"\";",
                        "  if (hasIndent) {",
                        "    text = text.replace(new RegExp(`^${indentation}`, \"gm\"), \"\");",
                        "  }",
                        "  const doc = escapeTemplateCharacters(",
                        "    textToDoc(",
                        "      text,",
                        "      { parser: \"markdown\", __inJsTemplate: true },",
                        "      { stripTrailingHardline: true }",
                        "    ),",
                        "    true",
                        "  );",
                        "  return [",
                        "    \"`\",",
                        "    hasIndent ? indent([softline, doc]) : [literalline, dedentToRoot(doc)],",
                        "    softline,",
                        "    \"`\",",
                        "  ];",
                        "}",
                        "",
                        "function getIndentation(str) {",
                        "  const firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);",
                        "  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];",
                        "}",
                        "",
                        "module.exports = format;"
                    ]
                }
            },
            "parse": {
                "angular.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "",
                        "function createParser(_parse) {",
                        "  const parse = (text, parsers, options) => {",
                        "    const ngEstreeParser = require(\"angular-estree-parser\");",
                        "    const node = _parse(text, ngEstreeParser);",
                        "    return {",
                        "      type: \"NGRoot\",",
                        "      node:",
                        "        options.parser === \"__ng_action\" && node.type !== \"NGChainedExpression\"",
                        "          ? { ...node, type: \"NGChainedExpression\", expressions: [node] }",
                        "          : node,",
                        "    };",
                        "  };",
                        "  return { astFormat: \"estree\", parse, locStart, locEnd };",
                        "}",
                        "",
                        "module.exports = {",
                        "  parsers: {",
                        "    __ng_action: createParser((text, ng) => ng.parseAction(text)),",
                        "    __ng_binding: createParser((text, ng) => ng.parseBinding(text)),",
                        "    __ng_interpolation: createParser((text, ng) => ng.parseInterpolation(text)),",
                        "    __ng_directive: createParser((text, ng) => ng.parseTemplateBindings(text)),",
                        "  },",
                        "};"
                    ]
                },
                "babel.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const tryCombinations = require(\"../../utils/try-combinations.js\");",
                        "const {",
                        "  getNextNonSpaceNonCommentCharacterIndexWithStartIndex,",
                        "} = require(\"../../common/util.js\");",
                        "const getShebang = require(\"../utils/get-shebang.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const createBabelParseError = require(\"./utils/create-babel-parse-error.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "const jsonParsers = require(\"./json.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"@babel/parser\").parse | import(\"@babel/parser\").parseExpression} Parse",
                        " * @typedef {import(\"@babel/parser\").ParserOptions} ParserOptions",
                        " * @typedef {import(\"@babel/parser\").ParserPlugin} ParserPlugin",
                        " */",
                        "",
                        "/** @type {ParserOptions} */",
                        "const parseOptions = {",
                        "  sourceType: \"module\",",
                        "  allowImportExportEverywhere: true,",
                        "  allowReturnOutsideFunction: true,",
                        "  allowSuperOutsideMethod: true,",
                        "  allowUndeclaredExports: true,",
                        "  errorRecovery: true,",
                        "  createParenthesizedExpressions: true,",
                        "  plugins: [",
                        "    // When adding a plugin, please add a test in `tests/format/js/babel-plugins`,",
                        "    // To remove plugins, remove it here and run `yarn test tests/format/js/babel-plugins` to verify",
                        "    \"doExpressions\",",
                        "    \"exportDefaultFrom\",",
                        "    \"functionBind\",",
                        "    \"functionSent\",",
                        "    \"throwExpressions\",",
                        "    \"partialApplication\",",
                        "    [\"decorators\", { decoratorsBeforeExport: false }],",
                        "    \"importAssertions\",",
                        "    \"decimal\",",
                        "    \"moduleBlocks\",",
                        "    \"asyncDoExpressions\",",
                        "  ],",
                        "  tokens: true,",
                        "  ranges: true,",
                        "};",
                        "",
                        "/** @type {ParserPlugin} */",
                        "const recordAndTuplePlugin = [\"recordAndTuple\", { syntaxType: \"hash\" }];",
                        "",
                        "/** @type {ParserPlugin} */",
                        "const v8intrinsicPlugin = \"v8intrinsic\";",
                        "",
                        "/** @type {Array<ParserPlugin>} */",
                        "const pipelineOperatorPlugins = [",
                        "  [\"pipelineOperator\", { proposal: \"hack\", topicToken: \"%\" }],",
                        "  [\"pipelineOperator\", { proposal: \"minimal\" }],",
                        "  [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                        "];",
                        "const appendPlugins = (plugins, options = parseOptions) => ({",
                        "  ...options,",
                        "  plugins: [...options.plugins, ...plugins],",
                        "});",
                        "",
                        "// Similar to babel",
                        "// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67",
                        "const FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;",
                        "function isFlowFile(text, options) {",
                        "  if (options.filepath && options.filepath.endsWith(\".js.flow\")) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const shebang = getShebang(text);",
                        "  if (shebang) {",
                        "    text = text.slice(shebang.length);",
                        "  }",
                        "",
                        "  const firstNonSpaceNonCommentCharacterIndex =",
                        "    getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, 0);",
                        "",
                        "  if (firstNonSpaceNonCommentCharacterIndex !== false) {",
                        "    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);",
                        "  }",
                        "",
                        "  return FLOW_PRAGMA_REGEX.test(text);",
                        "}",
                        "",
                        "function parseWithOptions(parseMethod, text, options) {",
                        "  // Inline the require to avoid loading all the JS if we don't use it",
                        "  /** @type {Parse} */",
                        "  const parse = require(\"@babel/parser\")[parseMethod];",
                        "  const ast = parse(text, options);",
                        "  const error = ast.errors.find(",
                        "    (error) => !allowedMessageCodes.has(error.reasonCode)",
                        "  );",
                        "  if (error) {",
                        "    throw error;",
                        "  }",
                        "  return ast;",
                        "}",
                        "",
                        "function createParse(parseMethod, ...optionsCombinations) {",
                        "  return (text, parsers, opts = {}) => {",
                        "    if (",
                        "      (opts.parser === \"babel\" || opts.parser === \"__babel_estree\") &&",
                        "      isFlowFile(text, opts)",
                        "    ) {",
                        "      opts.parser = \"babel-flow\";",
                        "      return parseFlow(text, parsers, opts);",
                        "    }",
                        "",
                        "    let combinations = optionsCombinations;",
                        "    if (opts.__babelSourceType === \"script\") {",
                        "      combinations = combinations.map((options) => ({",
                        "        ...options,",
                        "        sourceType: \"script\",",
                        "      }));",
                        "    }",
                        "",
                        "    if (/#[[{]/.test(text)) {",
                        "      combinations = combinations.map((options) =>",
                        "        appendPlugins([recordAndTuplePlugin], options)",
                        "      );",
                        "    }",
                        "",
                        "    const shouldEnableV8intrinsicPlugin = /%[A-Z]/.test(text);",
                        "    if (text.includes(\"|>\")) {",
                        "      const conflictsPlugins = shouldEnableV8intrinsicPlugin",
                        "        ? [...pipelineOperatorPlugins, v8intrinsicPlugin]",
                        "        : pipelineOperatorPlugins;",
                        "      combinations = conflictsPlugins.flatMap((pipelineOperatorPlugin) =>",
                        "        combinations.map((options) =>",
                        "          appendPlugins([pipelineOperatorPlugin], options)",
                        "        )",
                        "      );",
                        "    } else if (shouldEnableV8intrinsicPlugin) {",
                        "      combinations = combinations.map((options) =>",
                        "        appendPlugins([v8intrinsicPlugin], options)",
                        "      );",
                        "    }",
                        "",
                        "    const { result: ast, error } = tryCombinations(",
                        "      ...combinations.map(",
                        "        (options) => () => parseWithOptions(parseMethod, text, options)",
                        "      )",
                        "    );",
                        "",
                        "    if (!ast) {",
                        "      throw createBabelParseError(error);",
                        "    }",
                        "",
                        "    opts.originalText = text;",
                        "    return postprocess(ast, opts);",
                        "  };",
                        "}",
                        "",
                        "const parse = createParse(\"parse\", appendPlugins([\"jsx\", \"flow\"]));",
                        "const parseFlow = createParse(",
                        "  \"parse\",",
                        "  appendPlugins([\"jsx\", [\"flow\", { all: true, enums: true }]])",
                        ");",
                        "const parseTypeScript = createParse(",
                        "  \"parse\",",
                        "  appendPlugins([\"jsx\", \"typescript\"]),",
                        "  appendPlugins([\"typescript\"])",
                        ");",
                        "const parseEstree = createParse(",
                        "  \"parse\",",
                        "  appendPlugins([\"jsx\", \"flow\", \"estree\"])",
                        ");",
                        "const parseExpression = createParse(\"parseExpression\", appendPlugins([\"jsx\"]));",
                        "",
                        "// Error codes are defined in",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/parser/error-message.js",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/typescript/index.js#L69-L153",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/flow/index.js#L51-L140",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/jsx/index.js#L23-L39",
                        "const allowedMessageCodes = new Set([",
                        "  \"StrictNumericEscape\",",
                        "  \"StrictWith\",",
                        "  \"StrictOctalLiteral\",",
                        "  \"StrictDelete\",",
                        "  \"StrictEvalArguments\",",
                        "  \"StrictEvalArgumentsBinding\",",
                        "  \"StrictFunction\",",
                        "",
                        "  \"EmptyTypeArguments\",",
                        "  \"EmptyTypeParameters\",",
                        "  \"ConstructorHasTypeParameters\",",
                        "",
                        "  \"UnsupportedParameterPropertyKind\",",
                        "  \"UnexpectedParameterModifier\",",
                        "",
                        "  \"MixedLabeledAndUnlabeledElements\",",
                        "  \"InvalidTupleMemberLabel\",",
                        "",
                        "  \"NonClassMethodPropertyHasAbstractModifer\",",
                        "  \"ReadonlyForMethodSignature\",",
                        "  \"ClassMethodHasDeclare\",",
                        "  \"ClassMethodHasReadonly\",",
                        "  \"InvalidModifierOnTypeMember\",",
                        "  \"DuplicateAccessibilityModifier\",",
                        "  \"IndexSignatureHasDeclare\",",
                        "",
                        "  \"DecoratorExportClass\",",
                        "  \"ParamDupe\",",
                        "  \"InvalidDecimal\",",
                        "  \"RestTrailingComma\",",
                        "  \"UnsupportedParameterDecorator\",",
                        "  \"UnterminatedJsxContent\",",
                        "  \"UnexpectedReservedWord\",",
                        "  \"ModuleAttributesWithDuplicateKeys\",",
                        "  \"LineTerminatorBeforeArrow\",",
                        "  \"InvalidEscapeSequenceTemplate\",",
                        "  \"NonAbstractClassHasAbstractMethod\",",
                        "  \"UnsupportedPropertyDecorator\",",
                        "  \"OptionalTypeBeforeRequired\",",
                        "  \"PatternIsOptional\",",
                        "  \"OptionalBindingPattern\",",
                        "  \"DeclareClassFieldHasInitializer\",",
                        "  \"TypeImportCannotSpecifyDefaultAndNamed\",",
                        "  \"DeclareFunctionHasImplementation\",",
                        "  \"ConstructorClassField\",",
                        "",
                        "  \"VarRedeclaration\",",
                        "  \"InvalidPrivateFieldResolution\",",
                        "  \"DuplicateExport\",",
                        "]);",
                        "",
                        "const babel = createParser(parse);",
                        "const babelExpression = createParser(parseExpression);",
                        "",
                        "// Export as a plugin so we can reuse the same bundle for UMD loading",
                        "module.exports = {",
                        "  parsers: {",
                        "    babel,",
                        "    \"babel-flow\": createParser(parseFlow),",
                        "    \"babel-ts\": createParser(parseTypeScript),",
                        "    ...jsonParsers,",
                        "    /** @internal */",
                        "    __js_expression: babelExpression,",
                        "    /** for vue filter */",
                        "    __vue_expression: babelExpression,",
                        "    /** for vue event binding to handle semicolon */",
                        "    __vue_event_binding: babel,",
                        "    /** verify that we can print this AST */",
                        "    __babel_estree: createParser(parseEstree),",
                        "  },",
                        "};"
                    ]
                },
                "espree.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const tryCombinations = require(\"../../utils/try-combinations.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const replaceHashbang = require(\"./utils/replace-hashbang.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "",
                        "/** @type {import(\"espree\").Options} */",
                        "const parseOptions = {",
                        "  ecmaVersion: \"latest\",",
                        "  range: true,",
                        "  loc: true,",
                        "  comment: true,",
                        "  tokens: true,",
                        "  sourceType: \"module\",",
                        "  ecmaFeatures: {",
                        "    jsx: true,",
                        "    globalReturn: true,",
                        "    impliedStrict: false,",
                        "  },",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, lineNumber, column } = error;",
                        "",
                        "  /* istanbul ignore next */",
                        "  if (typeof lineNumber !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, { start: { line: lineNumber, column } });",
                        "}",
                        "",
                        "function parse(originalText, parsers, options = {}) {",
                        "  const { parse } = require(\"espree\");",
                        "",
                        "  const textToParse = replaceHashbang(originalText);",
                        "  const { result: ast, error: moduleParseError } = tryCombinations(",
                        "    () => parse(textToParse, { ...parseOptions, sourceType: \"module\" }),",
                        "    () => parse(textToParse, { ...parseOptions, sourceType: \"script\" })",
                        "  );",
                        "",
                        "  if (!ast) {",
                        "    // throw the error for `module` parsing",
                        "    throw createParseError(moduleParseError);",
                        "  }",
                        "",
                        "  options.originalText = originalText;",
                        "  return postprocess(ast, options);",
                        "}",
                        "",
                        "module.exports = {",
                        "  parsers: {",
                        "    espree: createParser(parse),",
                        "  },",
                        "};"
                    ]
                },
                "flow.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const replaceHashbang = require(\"./utils/replace-hashbang.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "",
                        "// https://github.com/facebook/flow/tree/master/packages/flow-parser#options",
                        "const parseOptions = {",
                        "  // `all_comments` (boolean, default `true`) - include a list of all comments from the whole program",
                        "  // all_comments: true,",
                        "  // `comments` (boolean, default `true`) - attach comments to AST nodes (`leadingComments` and `trailingComments`)",
                        "  comments: false,",
                        "  // `enums` (boolean, default `false`) - enable parsing of Flow enums",
                        "  enums: true,",
                        "  // `esproposal_class_instance_fields` (boolean, default `false`) - enable parsing of class instance fields",
                        "  esproposal_class_instance_fields: true,",
                        "  // `esproposal_class_static_fields` (boolean, default `false`) - enable parsing of class static fields",
                        "  esproposal_class_static_fields: true,",
                        "  // `esproposal_decorators` (boolean, default `false`) - enable parsing of decorators",
                        "  esproposal_decorators: true,",
                        "  // `esproposal_export_star_as` (boolean, default `false`) - enable parsing of `export * as` syntax",
                        "  esproposal_export_star_as: true,",
                        "  // `esproposal_nullish_coalescing` (boolean, default `false`) - enable parsing of nullish coalescing (`??`)",
                        "  esproposal_nullish_coalescing: true,",
                        "  // `esproposal_optional_chaining` (boolean, default `false`) - enable parsing of optional chaining (`?.`)",
                        "  esproposal_optional_chaining: true,",
                        "  // `types` (boolean, default `true`) - enable parsing of Flow types",
                        "  // types: true,",
                        "  // `use_strict` (boolean, default `false`) - treat the file as strict, without needing a \"use strict\" directive",
                        "  // use_strict: false,",
                        "  // Not documented",
                        "  tokens: true,",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const {",
                        "    message,",
                        "    loc: { start, end },",
                        "  } = error;",
                        "",
                        "  return createError(message, {",
                        "    start: { line: start.line, column: start.column + 1 },",
                        "    end: { line: end.line, column: end.column + 1 },",
                        "  });",
                        "}",
                        "",
                        "function parse(text, parsers, options = {}) {",
                        "  // Inline the require to avoid loading all the JS if we don't use it",
                        "  const { parse } = require(\"flow-parser\");",
                        "  const ast = parse(replaceHashbang(text), parseOptions);",
                        "  const [error] = ast.errors;",
                        "  if (error) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  options.originalText = text;",
                        "  return postprocess(ast, options);",
                        "}",
                        "",
                        "// Export as a plugin so we can reuse the same bundle for UMD loading",
                        "module.exports = {",
                        "  parsers: {",
                        "    flow: createParser(parse),",
                        "  },",
                        "};"
                    ]
                },
                "json.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const createBabelParseError = require(\"./utils/create-babel-parse-error.js\");",
                        "",
                        "function createJsonParse(options = {}) {",
                        "  const { allowComments = true } = options;",
                        "",
                        "  return function parse(text /*, parsers, options*/) {",
                        "    const { parseExpression } = require(\"@babel/parser\");",
                        "    let ast;",
                        "    try {",
                        "      ast = parseExpression(text, {",
                        "        tokens: true,",
                        "        ranges: true,",
                        "      });",
                        "    } catch (error) {",
                        "      throw createBabelParseError(error);",
                        "    }",
                        "",
                        "    // @ts-expect-error",
                        "    if (!allowComments && isNonEmptyArray(ast.comments)) {",
                        "      // @ts-expect-error",
                        "      throw createJsonError(ast.comments[0], \"Comment\");",
                        "    }",
                        "",
                        "    assertJsonNode(ast);",
                        "",
                        "    return ast;",
                        "  };",
                        "}",
                        "",
                        "function createJsonError(node, description) {",
                        "  const [start, end] = [node.loc.start, node.loc.end].map(",
                        "    ({ line, column }) => ({",
                        "      line,",
                        "      column: column + 1,",
                        "    })",
                        "  );",
                        "  return createError(`${description} is not allowed in JSON.`, { start, end });",
                        "}",
                        "",
                        "function assertJsonNode(node) {",
                        "  switch (node.type) {",
                        "    case \"ArrayExpression\":",
                        "      for (const element of node.elements) {",
                        "        if (element !== null) {",
                        "          assertJsonNode(element);",
                        "        }",
                        "      }",
                        "",
                        "      return;",
                        "    case \"ObjectExpression\":",
                        "      for (const property of node.properties) {",
                        "        assertJsonNode(property);",
                        "      }",
                        "",
                        "      return;",
                        "    case \"ObjectProperty\":",
                        "      if (node.computed) {",
                        "        throw createJsonError(node.key, \"Computed key\");",
                        "      }",
                        "",
                        "      if (node.shorthand) {",
                        "        throw createJsonError(node.key, \"Shorthand property\");",
                        "      }",
                        "",
                        "      if (node.key.type !== \"Identifier\") {",
                        "        assertJsonNode(node.key);",
                        "      }",
                        "",
                        "      assertJsonNode(node.value);",
                        "",
                        "      return;",
                        "    case \"UnaryExpression\": {",
                        "      const { operator, argument } = node;",
                        "      if (operator !== \"+\" && operator !== \"-\") {",
                        "        throw createJsonError(node, `Operator '${node.operator}'`);",
                        "      }",
                        "",
                        "      if (",
                        "        argument.type === \"NumericLiteral\" ||",
                        "        (argument.type === \"Identifier\" &&",
                        "          (argument.name === \"Infinity\" || argument.name === \"NaN\"))",
                        "      ) {",
                        "        return;",
                        "      }",
                        "",
                        "      throw createJsonError(",
                        "        argument,",
                        "        `Operator '${operator}' before '${argument.type}'`",
                        "      );",
                        "    }",
                        "    case \"Identifier\":",
                        "      if (",
                        "        // JSON5 https://spec.json5.org/#numbers",
                        "        node.name !== \"Infinity\" &&",
                        "        node.name !== \"NaN\" &&",
                        "        // JSON6 https://github.com/d3x0r/JSON6",
                        "        node.name !== \"undefined\"",
                        "      ) {",
                        "        throw createJsonError(node, `Identifier '${node.name}'`);",
                        "      }",
                        "",
                        "      return;",
                        "    case \"TemplateLiteral\":",
                        "      if (isNonEmptyArray(node.expressions)) {",
                        "        throw createJsonError(",
                        "          node.expressions[0],",
                        "          \"'TemplateLiteral' with expression\"",
                        "        );",
                        "      }",
                        "",
                        "      for (const element of node.quasis) {",
                        "        assertJsonNode(element);",
                        "      }",
                        "",
                        "      return;",
                        "    case \"NullLiteral\":",
                        "    case \"BooleanLiteral\":",
                        "    case \"NumericLiteral\":",
                        "    case \"StringLiteral\":",
                        "    case \"TemplateElement\":",
                        "      return;",
                        "    default:",
                        "      throw createJsonError(node, `'${node.type}'`);",
                        "  }",
                        "}",
                        "",
                        "const parseJson = createJsonParse();",
                        "",
                        "const jsonParsers = {",
                        "  json: createParser({",
                        "    parse: parseJson,",
                        "    hasPragma() {",
                        "      return true;",
                        "    },",
                        "  }),",
                        "  json5: createParser(parseJson),",
                        "  \"json-stringify\": createParser({",
                        "    parse: createJsonParse({ allowComments: false }),",
                        "    astFormat: \"estree-json\",",
                        "  }),",
                        "};",
                        "",
                        "module.exports = jsonParsers;"
                    ]
                },
                "meriyah.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const tryCombinations = require(\"../../utils/try-combinations.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "",
                        "// https://github.com/meriyah/meriyah/blob/4676f60b6c149d7082bde2c9147f9ae2359c8075/src/parser.ts#L185",
                        "const parseOptions = {",
                        "  // Allow module code",
                        "  module: true,",
                        "  // Enable stage 3 support (ESNext)",
                        "  next: true,",
                        "  // Enable start and end offsets to each node",
                        "  ranges: true,",
                        "  // Enable web compatibility",
                        "  webcompat: true,",
                        "  // Enable line/column location information to each node",
                        "  loc: true,",
                        "  // Attach raw property to each literal and identifier node",
                        "  raw: true,",
                        "  // Enabled directives",
                        "  directives: true,",
                        "  // Allow return in the global scope",
                        "  globalReturn: true,",
                        "  // Enable implied strict mode",
                        "  impliedStrict: false,",
                        "  // Enable non-standard parenthesized expression node",
                        "  preserveParens: false,",
                        "  // Enable lexical binding and scope tracking",
                        "  lexical: false,",
                        "  // Adds a source attribute in every node\u2019s loc object when the locations option is `true`",
                        "  // source: '',",
                        "  // Distinguish Identifier from IdentifierPattern",
                        "  identifierPattern: false,",
                        "  // Enable React JSX parsing",
                        "  jsx: true,",
                        "  // Allow edge cases that deviate from the spec",
                        "  specDeviation: true,",
                        "  // Creates unique key for in ObjectPattern when key value are same",
                        "  uniqueKeyInPattern: false,",
                        "};",
                        "",
                        "function parseWithOptions(text, module) {",
                        "  const { parse } = require(\"meriyah\");",
                        "  const comments = [];",
                        "  const tokens = [];",
                        "",
                        "  /** @type {any} */",
                        "  const ast = parse(text, {",
                        "    ...parseOptions,",
                        "    module,",
                        "    onComment: comments,",
                        "    onToken: tokens,",
                        "  });",
                        "  ast.comments = comments;",
                        "  ast.tokens = tokens;",
                        "",
                        "  return ast;",
                        "}",
                        "",
                        "function createParseError(error) {",
                        "  // throw the error for `module` parsing",
                        "  const { message, line, column } = error;",
                        "",
                        "  /* istanbul ignore next */",
                        "  if (typeof line !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, { start: { line, column } });",
                        "}",
                        "",
                        "function parse(text, parsers, options = {}) {",
                        "  const { result: ast, error: moduleParseError } = tryCombinations(",
                        "    () => parseWithOptions(text, /* module */ true),",
                        "    () => parseWithOptions(text, /* module */ false)",
                        "  );",
                        "",
                        "  if (!ast) {",
                        "    // Throw the error for `module` parsing",
                        "    throw createParseError(moduleParseError);",
                        "  }",
                        "",
                        "  options.originalText = text;",
                        "  return postprocess(ast, options);",
                        "}",
                        "",
                        "module.exports = {",
                        "  parsers: {",
                        "    meriyah: createParser(parse),",
                        "  },",
                        "};"
                    ]
                },
                "parsers.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "module.exports = {",
                        "  // JS - Babel",
                        "  get babel() {",
                        "    return require(\"./babel.js\").parsers.babel;",
                        "  },",
                        "  get \"babel-flow\"() {",
                        "    return require(\"./babel.js\").parsers[\"babel-flow\"];",
                        "  },",
                        "  get \"babel-ts\"() {",
                        "    return require(\"./babel.js\").parsers[\"babel-ts\"];",
                        "  },",
                        "  get json() {",
                        "    return require(\"./babel.js\").parsers.json;",
                        "  },",
                        "  get json5() {",
                        "    return require(\"./babel.js\").parsers.json5;",
                        "  },",
                        "  get \"json-stringify\"() {",
                        "    return require(\"./babel.js\").parsers[\"json-stringify\"];",
                        "  },",
                        "  get __js_expression() {",
                        "    return require(\"./babel.js\").parsers.__js_expression;",
                        "  },",
                        "  get __vue_expression() {",
                        "    return require(\"./babel.js\").parsers.__vue_expression;",
                        "  },",
                        "  get __vue_event_binding() {",
                        "    return require(\"./babel.js\").parsers.__vue_event_binding;",
                        "  },",
                        "  // JS - Flow",
                        "  get flow() {",
                        "    return require(\"./flow.js\").parsers.flow;",
                        "  },",
                        "  // JS - TypeScript",
                        "  get typescript() {",
                        "    return require(\"./typescript.js\").parsers.typescript;",
                        "  },",
                        "  // JS - Angular Action",
                        "  get __ng_action() {",
                        "    return require(\"./angular.js\").parsers.__ng_action;",
                        "  },",
                        "  // JS - Angular Binding",
                        "  get __ng_binding() {",
                        "    return require(\"./angular.js\").parsers.__ng_binding;",
                        "  },",
                        "  // JS - Angular Interpolation",
                        "  get __ng_interpolation() {",
                        "    return require(\"./angular.js\").parsers.__ng_interpolation;",
                        "  },",
                        "  // JS - Angular Directive",
                        "  get __ng_directive() {",
                        "    return require(\"./angular.js\").parsers.__ng_directive;",
                        "  },",
                        "  // JS - espree",
                        "  get espree() {",
                        "    return require(\"./espree.js\").parsers.espree;",
                        "  },",
                        "  // JS - meriyah",
                        "  get meriyah() {",
                        "    return require(\"./meriyah.js\").parsers.meriyah;",
                        "  },",
                        "  // JS - Babel Estree",
                        "  get __babel_estree() {",
                        "    return require(\"./babel.js\").parsers.__babel_estree;",
                        "  },",
                        "};"
                    ]
                },
                "typescript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const createError = require(\"../../common/parser-create-error.js\");",
                        "const tryCombinations = require(\"../../utils/try-combinations.js\");",
                        "const createParser = require(\"./utils/create-parser.js\");",
                        "const replaceHashbang = require(\"./utils/replace-hashbang.js\");",
                        "const postprocess = require(\"./postprocess/index.js\");",
                        "",
                        "/** @type {import(\"@typescript-eslint/typescript-estree\").TSESTreeOptions} */",
                        "const parseOptions = {",
                        "  // `jest@<=26.4.2` rely on `loc`",
                        "  // https://github.com/facebook/jest/issues/10444",
                        "  loc: true,",
                        "  range: true,",
                        "  comment: true,",
                        "  jsx: true,",
                        "  tokens: true,",
                        "  loggerFn: false,",
                        "  project: [],",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, lineNumber, column } = error;",
                        "",
                        "  /* istanbul ignore next */",
                        "  if (typeof lineNumber !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, {",
                        "    start: { line: lineNumber, column: column + 1 },",
                        "  });",
                        "}",
                        "",
                        "function parse(text, parsers, options = {}) {",
                        "  const textToParse = replaceHashbang(text);",
                        "  const jsx = isProbablyJsx(text);",
                        "",
                        "  const { parseWithNodeMaps } = require(\"@typescript-eslint/typescript-estree\");",
                        "  const { result, error: firstError } = tryCombinations(",
                        "    // Try passing with our best guess first.",
                        "    () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx }),",
                        "    // But if we get it wrong, try the opposite.",
                        "    () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx: !jsx })",
                        "  );",
                        "",
                        "  if (!result) {",
                        "    // Suppose our guess is correct, throw the first error",
                        "    throw createParseError(firstError);",
                        "  }",
                        "",
                        "  options.originalText = text;",
                        "  options.tsParseResult = result;",
                        "  return postprocess(result.ast, options);",
                        "}",
                        "",
                        "/**",
                        " * Use a naive regular expression to detect JSX",
                        " */",
                        "function isProbablyJsx(text) {",
                        "  return new RegExp(",
                        "    [",
                        "      \"(?:^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string",
                        "      \"|\",",
                        "      \"(?:^[^/]{2}.*/>)\", // Contains \"/>\" on line not starting with \"//\"",
                        "    ].join(\"\"),",
                        "    \"m\"",
                        "  ).test(text);",
                        "}",
                        "",
                        "// Export as a plugin so we can reuse the same bundle for UMD loading",
                        "module.exports = {",
                        "  parsers: {",
                        "    typescript: createParser(parse),",
                        "  },",
                        "};"
                    ]
                },
                "postprocess": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const { locStart, locEnd } = require(\"../../loc.js\");",
                            "const isTsKeywordType = require(\"../../utils/is-ts-keyword-type.js\");",
                            "const isTypeCastComment = require(\"../../utils/is-type-cast-comment.js\");",
                            "const getLast = require(\"../../../utils/get-last.js\");",
                            "const visitNode = require(\"./visitNode.js\");",
                            "const { throwErrorForInvalidNodes } = require(\"./typescript.js\");",
                            "",
                            "function postprocess(ast, options) {",
                            "  if (",
                            "    options.parser === \"typescript\" &&",
                            "    // decorators or abstract properties",
                            "    /@|abstract/.test(options.originalText)",
                            "  ) {",
                            "    throwErrorForInvalidNodes(ast, options);",
                            "  }",
                            "",
                            "  // Keep Babel's non-standard ParenthesizedExpression nodes only if they have Closure-style type cast comments.",
                            "  if (",
                            "    options.parser !== \"typescript\" &&",
                            "    options.parser !== \"flow\" &&",
                            "    options.parser !== \"espree\" &&",
                            "    options.parser !== \"meriyah\"",
                            "  ) {",
                            "    const startOffsetsOfTypeCastedNodes = new Set();",
                            "",
                            "    // Comments might be attached not directly to ParenthesizedExpression but to its ancestor.",
                            "    // E.g.: /** @type {Foo} */ (foo).bar();",
                            "    // Let's use the fact that those ancestors and ParenthesizedExpression have the same start offset.",
                            "",
                            "    ast = visitNode(ast, (node) => {",
                            "      if (",
                            "        node.leadingComments &&",
                            "        node.leadingComments.some(isTypeCastComment)",
                            "      ) {",
                            "        startOffsetsOfTypeCastedNodes.add(locStart(node));",
                            "      }",
                            "    });",
                            "",
                            "    ast = visitNode(ast, (node) => {",
                            "      if (node.type === \"ParenthesizedExpression\") {",
                            "        const { expression } = node;",
                            "",
                            "        // Align range with `flow`",
                            "        if (expression.type === \"TypeCastExpression\") {",
                            "          expression.range = node.range;",
                            "          return expression;",
                            "        }",
                            "",
                            "        const start = locStart(node);",
                            "        if (!startOffsetsOfTypeCastedNodes.has(start)) {",
                            "          expression.extra = { ...expression.extra, parenthesized: true };",
                            "          return expression;",
                            "        }",
                            "      }",
                            "    });",
                            "  }",
                            "",
                            "  ast = visitNode(ast, (node) => {",
                            "    switch (node.type) {",
                            "      // Espree",
                            "      case \"ChainExpression\": {",
                            "        return transformChainExpression(node.expression);",
                            "      }",
                            "      case \"LogicalExpression\": {",
                            "        // We remove unneeded parens around same-operator LogicalExpressions",
                            "        if (isUnbalancedLogicalTree(node)) {",
                            "          return rebalanceLogicalTree(node);",
                            "        }",
                            "        break;",
                            "      }",
                            "      // fix unexpected locEnd caused by --no-semi style",
                            "      case \"VariableDeclaration\": {",
                            "        const lastDeclaration = getLast(node.declarations);",
                            "        if (lastDeclaration && lastDeclaration.init) {",
                            "          overrideLocEnd(node, lastDeclaration);",
                            "        }",
                            "        break;",
                            "      }",
                            "      // remove redundant TypeScript nodes",
                            "      case \"TSParenthesizedType\": {",
                            "        if (",
                            "          !(",
                            "            isTsKeywordType(node.typeAnnotation) ||",
                            "            node.typeAnnotation.type === \"TSThisType\"",
                            "          )",
                            "        ) {",
                            "          node.typeAnnotation.range = [locStart(node), locEnd(node)];",
                            "        }",
                            "        return node.typeAnnotation;",
                            "      }",
                            "      case \"TSTypeParameter\":",
                            "        // babel-ts",
                            "        if (typeof node.name === \"string\") {",
                            "          const start = locStart(node);",
                            "          node.name = {",
                            "            type: \"Identifier\",",
                            "            name: node.name,",
                            "            range: [start, start + node.name.length],",
                            "          };",
                            "        }",
                            "        break;",
                            "      case \"SequenceExpression\": {",
                            "        // Babel (unlike other parsers) includes spaces and comments in the range. Let's unify this.",
                            "        const lastExpression = getLast(node.expressions);",
                            "        node.range = [",
                            "          locStart(node),",
                            "          Math.min(locEnd(lastExpression), locEnd(node)),",
                            "        ];",
                            "        break;",
                            "      }",
                            "      // For hack-style pipeline",
                            "      case \"TopicReference\":",
                            "        options.__isUsingHackPipeline = true;",
                            "        break;",
                            "    }",
                            "  });",
                            "",
                            "  return ast;",
                            "",
                            "  /**",
                            "   * - `toOverrideNode` must be the last thing in `toBeOverriddenNode`",
                            "   * - do nothing if there's a semicolon on `toOverrideNode.end` (no need to fix)",
                            "   */",
                            "  function overrideLocEnd(toBeOverriddenNode, toOverrideNode) {",
                            "    if (options.originalText[locEnd(toOverrideNode)] === \";\") {",
                            "      return;",
                            "    }",
                            "    toBeOverriddenNode.range = [",
                            "      locStart(toBeOverriddenNode),",
                            "      locEnd(toOverrideNode),",
                            "    ];",
                            "  }",
                            "}",
                            "",
                            "// This is a workaround to transform `ChainExpression` from `espree`, `meriyah`,",
                            "// and `typescript` into `babel` shape AST, we should do the opposite,",
                            "// since `ChainExpression` is the standard `estree` AST for `optional chaining`",
                            "// https://github.com/estree/estree/blob/master/es2020.md",
                            "function transformChainExpression(node) {",
                            "  switch (node.type) {",
                            "    case \"CallExpression\":",
                            "      node.type = \"OptionalCallExpression\";",
                            "      node.callee = transformChainExpression(node.callee);",
                            "      break;",
                            "    case \"MemberExpression\":",
                            "      node.type = \"OptionalMemberExpression\";",
                            "      node.object = transformChainExpression(node.object);",
                            "      break;",
                            "    // typescript",
                            "    case \"TSNonNullExpression\":",
                            "      node.expression = transformChainExpression(node.expression);",
                            "      break;",
                            "    // No default",
                            "  }",
                            "  return node;",
                            "}",
                            "",
                            "function isUnbalancedLogicalTree(node) {",
                            "  return (",
                            "    node.type === \"LogicalExpression\" &&",
                            "    node.right.type === \"LogicalExpression\" &&",
                            "    node.operator === node.right.operator",
                            "  );",
                            "}",
                            "",
                            "function rebalanceLogicalTree(node) {",
                            "  if (!isUnbalancedLogicalTree(node)) {",
                            "    return node;",
                            "  }",
                            "",
                            "  return rebalanceLogicalTree({",
                            "    type: \"LogicalExpression\",",
                            "    operator: node.operator,",
                            "    left: rebalanceLogicalTree({",
                            "      type: \"LogicalExpression\",",
                            "      operator: node.operator,",
                            "      left: node.left,",
                            "      right: node.right.left,",
                            "      range: [locStart(node.left), locEnd(node.right.left)],",
                            "    }),",
                            "    right: node.right.right,",
                            "    range: [locStart(node), locEnd(node)],",
                            "  });",
                            "}",
                            "",
                            "module.exports = postprocess;"
                        ]
                    },
                    "typescript.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const createError = require(\"../../../common/parser-create-error.js\");",
                            "const visitNode = require(\"./visitNode.js\");",
                            "",
                            "function throwSyntaxError(node, message) {",
                            "  const { start, end } = node.loc;",
                            "  throw createError(message, {",
                            "    start: { line: start.line, column: start.column + 1 },",
                            "    end: { line: end.line, column: end.column + 1 },",
                            "  });",
                            "}",
                            "",
                            "// Invalid decorators are removed since `@typescript-eslint/typescript-estree` v4",
                            "// https://github.com/typescript-eslint/typescript-eslint/pull/2375",
                            "function throwErrorForInvalidDecorator(",
                            "  tsNode,",
                            "  esTreeNode,",
                            "  tsNodeToESTreeNodeMap",
                            ") {",
                            "  const tsDecorators = tsNode.decorators;",
                            "  if (!Array.isArray(tsDecorators)) {",
                            "    return;",
                            "  }",
                            "  const esTreeDecorators = esTreeNode.decorators;",
                            "  if (",
                            "    !Array.isArray(esTreeDecorators) ||",
                            "    esTreeDecorators.length !== tsDecorators.length ||",
                            "    tsDecorators.some((tsDecorator) => {",
                            "      const esTreeDecorator = tsNodeToESTreeNodeMap.get(tsDecorator);",
                            "      return !esTreeDecorator || !esTreeDecorators.includes(esTreeDecorator);",
                            "    })",
                            "  ) {",
                            "    throwSyntaxError(",
                            "      esTreeNode,",
                            "      \"Leading decorators must be attached to a class declaration\"",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "// Values of abstract property is removed since `@typescript-eslint/typescript-estree` v5",
                            "// https://github.com/typescript-eslint/typescript-eslint/releases/tag/v5.0.0",
                            "function throwErrorForInvalidAbstractProperty(tsNode, esTreeNode) {",
                            "  const SYNTAX_KIND_PROPERTY_DEFINITION = 166;",
                            "  const SYNTAX_KIND_ABSTRACT_KEYWORD = 126;",
                            "  if (",
                            "    tsNode.kind !== SYNTAX_KIND_PROPERTY_DEFINITION ||",
                            "    (tsNode.modifiers &&",
                            "      !tsNode.modifiers.some(",
                            "        (modifier) => modifier.kind === SYNTAX_KIND_ABSTRACT_KEYWORD",
                            "      ))",
                            "  ) {",
                            "    return;",
                            "  }",
                            "  if (tsNode.initializer && esTreeNode.value === null) {",
                            "    throwSyntaxError(",
                            "      esTreeNode,",
                            "      \"Abstract property cannot have an initializer\"",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "function throwErrorForInvalidNodes(ast, options) {",
                            "  const { esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap } =",
                            "    options.tsParseResult;",
                            "",
                            "  visitNode(ast, (node) => {",
                            "    const tsNode = esTreeNodeToTSNodeMap.get(node);",
                            "    if (!tsNode) {",
                            "      return;",
                            "    }",
                            "    const esTreeNode = tsNodeToESTreeNodeMap.get(tsNode);",
                            "    if (esTreeNode !== node) {",
                            "      return;",
                            "    }",
                            "    throwErrorForInvalidDecorator(tsNode, esTreeNode, tsNodeToESTreeNodeMap);",
                            "    throwErrorForInvalidAbstractProperty(tsNode, esTreeNode);",
                            "  });",
                            "}",
                            "",
                            "module.exports = { throwErrorForInvalidNodes };"
                        ]
                    },
                    "visitNode.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "function visitNode(node, fn) {",
                            "  if (Array.isArray(node)) {",
                            "    // As of Node.js 16 using raw for loop over Array.entries provides a",
                            "    // measurable difference in performance. Array.entries returns an iterator",
                            "    // of arrays.",
                            "    for (let i = 0; i < node.length; i++) {",
                            "      node[i] = visitNode(node[i], fn);",
                            "    }",
                            "    return node;",
                            "  }",
                            "  if (node && typeof node === \"object\" && typeof node.type === \"string\") {",
                            "    // As of Node.js 16 this is benchmarked to be faster over Object.entries.",
                            "    // Object.entries returns an array of arrays. There are multiple ways to",
                            "    // iterate over objects but the Object.keys combined with a for loop",
                            "    // benchmarks well.",
                            "    const keys = Object.keys(node);",
                            "    for (let i = 0; i < keys.length; i++) {",
                            "      node[keys[i]] = visitNode(node[keys[i]], fn);",
                            "    }",
                            "    return fn(node) || node;",
                            "  }",
                            "  return node;",
                            "}",
                            "",
                            "module.exports = visitNode;"
                        ]
                    }
                },
                "utils": {
                    "create-babel-parse-error.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const createError = require(\"../../../common/parser-create-error.js\");",
                            "",
                            "function createBabelParseError(error) {",
                            "  // babel error prints (l:c) with cols that are zero indexed",
                            "  // so we need our custom error",
                            "  const { message, loc } = error;",
                            "",
                            "  return createError(message.replace(/ \\(.*\\)/, \"\"), {",
                            "    start: {",
                            "      line: loc ? loc.line : 0,",
                            "      column: loc ? loc.column + 1 : 0,",
                            "    },",
                            "  });",
                            "}",
                            "",
                            "module.exports = createBabelParseError;"
                        ]
                    },
                    "create-parser.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const { hasPragma } = require(\"../../pragma.js\");",
                            "const { locStart, locEnd } = require(\"../../loc.js\");",
                            "",
                            "function createParser(options) {",
                            "  options = typeof options === \"function\" ? { parse: options } : options;",
                            "",
                            "  return {",
                            "    astFormat: \"estree\",",
                            "    hasPragma,",
                            "    locStart,",
                            "    locEnd,",
                            "    ...options,",
                            "  };",
                            "}",
                            "",
                            "module.exports = createParser;"
                        ]
                    },
                    "replace-hashbang.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "// Replace `#!` with `//` so `typescript`, `flow`, and `espree` can parse it as line comment",
                            "// Inspired by ESLint parse function https://github.com/eslint/eslint/blob/9d6063add931f0803cae1676d5df307baf114360/lib/linter/linter.js#L635",
                            "function replaceHashbang(text) {",
                            "  if (text.charAt(0) === \"#\" && text.charAt(1) === \"!\") {",
                            "    return \"//\" + text.slice(2);",
                            "  }",
                            "",
                            "  return text;",
                            "}",
                            "",
                            "module.exports = replaceHashbang;"
                        ]
                    }
                }
            },
            "print": {
                "angular.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { join, line, group },",
                        "} = require(\"../../document/index.js\");",
                        "const { hasNode, hasComment, getComments } = require(\"../utils/index.js\");",
                        "const { printBinaryishExpression } = require(\"./binaryish.js\");",
                        "",
                        "/** @typedef {import(\"../../common/ast-path\")} AstPath */",
                        "",
                        "function printAngular(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  // Angular nodes always starts with `NG`",
                        "  if (!node.type.startsWith(\"NG\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"NGRoot\":",
                        "      return [",
                        "        print(\"node\"),",
                        "        !hasComment(node.node)",
                        "          ? \"\"",
                        "          : \" //\" + getComments(node.node)[0].value.trimEnd(),",
                        "      ];",
                        "    case \"NGPipeExpression\":",
                        "      return printBinaryishExpression(path, options, print);",
                        "    case \"NGChainedExpression\":",
                        "      return group(",
                        "        join(",
                        "          [\";\", line],",
                        "          path.map(",
                        "            (childPath) =>",
                        "              hasNgSideEffect(childPath) ? print() : [\"(\", print(), \")\"],",
                        "            \"expressions\"",
                        "          )",
                        "        )",
                        "      );",
                        "    case \"NGEmptyExpression\":",
                        "      return \"\";",
                        "    case \"NGQuotedExpression\":",
                        "      return [node.prefix, \": \", node.value.trim()];",
                        "    case \"NGMicrosyntax\":",
                        "      return path.map(",
                        "        (childPath, index) => [",
                        "          index === 0",
                        "            ? \"\"",
                        "            : isNgForOf(childPath.getValue(), index, node)",
                        "            ? \" \"",
                        "            : [\";\", line],",
                        "          print(),",
                        "        ],",
                        "        \"body\"",
                        "      );",
                        "    case \"NGMicrosyntaxKey\":",
                        "      return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(node.name)",
                        "        ? node.name",
                        "        : JSON.stringify(node.name);",
                        "    case \"NGMicrosyntaxExpression\":",
                        "      return [",
                        "        print(\"expression\"),",
                        "        node.alias === null ? \"\" : [\" as \", print(\"alias\")],",
                        "      ];",
                        "    case \"NGMicrosyntaxKeyedExpression\": {",
                        "      const index = path.getName();",
                        "      const parentNode = path.getParentNode();",
                        "      const shouldNotPrintColon =",
                        "        isNgForOf(node, index, parentNode) ||",
                        "        (((index === 1 &&",
                        "          (node.key.name === \"then\" || node.key.name === \"else\")) ||",
                        "          (index === 2 &&",
                        "            node.key.name === \"else\" &&",
                        "            parentNode.body[index - 1].type ===",
                        "              \"NGMicrosyntaxKeyedExpression\" &&",
                        "            parentNode.body[index - 1].key.name === \"then\")) &&",
                        "          parentNode.body[0].type === \"NGMicrosyntaxExpression\");",
                        "      return [",
                        "        print(\"key\"),",
                        "        shouldNotPrintColon ? \" \" : \": \",",
                        "        print(\"expression\"),",
                        "      ];",
                        "    }",
                        "    case \"NGMicrosyntaxLet\":",
                        "      return [",
                        "        \"let \",",
                        "        print(\"key\"),",
                        "        node.value === null ? \"\" : [\" = \", print(\"value\")],",
                        "      ];",
                        "    case \"NGMicrosyntaxAs\":",
                        "      return [print(\"key\"), \" as \", print(\"alias\")];",
                        "    default:",
                        "      /* istanbul ignore next */",
                        "      throw new Error(",
                        "        `Unknown Angular node type: ${JSON.stringify(node.type)}.`",
                        "      );",
                        "  }",
                        "}",
                        "",
                        "function isNgForOf(node, index, parentNode) {",
                        "  return (",
                        "    node.type === \"NGMicrosyntaxKeyedExpression\" &&",
                        "    node.key.name === \"of\" &&",
                        "    index === 1 &&",
                        "    parentNode.body[0].type === \"NGMicrosyntaxLet\" &&",
                        "    parentNode.body[0].value === null",
                        "  );",
                        "}",
                        "",
                        "/** identify if an angular expression seems to have side effects */",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function hasNgSideEffect(path) {",
                        "  return hasNode(path.getValue(), (node) => {",
                        "    switch (node.type) {",
                        "      case undefined:",
                        "        return false;",
                        "      case \"CallExpression\":",
                        "      case \"OptionalCallExpression\":",
                        "      case \"AssignmentExpression\":",
                        "        return true;",
                        "    }",
                        "  });",
                        "}",
                        "",
                        "module.exports = { printAngular };"
                    ]
                },
                "array.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { line, softline, hardline, group, indent, ifBreak, fill },",
                        "} = require(\"../../document/index.js\");",
                        "const { getLast, hasNewline } = require(\"../../common/util.js\");",
                        "const {",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "  isNumericLiteral,",
                        "  isSignedNumericLiteral,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart } = require(\"../loc.js\");",
                        "",
                        "const { printOptionalToken, printTypeAnnotation } = require(\"./misc.js\");",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "function printArray(path, options, print) {",
                        "  const node = path.getValue();",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  const openBracket = node.type === \"TupleExpression\" ? \"#[\" : \"[\";",
                        "  const closeBracket = \"]\";",
                        "  if (node.elements.length === 0) {",
                        "    if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      parts.push(openBracket, closeBracket);",
                        "    } else {",
                        "      parts.push(",
                        "        group([",
                        "          openBracket,",
                        "          printDanglingComments(path, options),",
                        "          softline,",
                        "          closeBracket,",
                        "        ])",
                        "      );",
                        "    }",
                        "  } else {",
                        "    const lastElem = getLast(node.elements);",
                        "    const canHaveTrailingComma = !(lastElem && lastElem.type === \"RestElement\");",
                        "",
                        "    // JavaScript allows you to have empty elements in an array which",
                        "    // changes its length based on the number of commas. The algorithm",
                        "    // is that if the last argument is null, we need to force insert",
                        "    // a comma to ensure JavaScript recognizes it.",
                        "    //   [,].length === 1",
                        "    //   [1,].length === 1",
                        "    //   [1,,].length === 2",
                        "    //",
                        "    // Note that getLast returns null if the array is empty, but",
                        "    // we already check for an empty array just above so we are safe",
                        "    const needsForcedTrailingComma = lastElem === null;",
                        "",
                        "    const groupId = Symbol(\"array\");",
                        "",
                        "    const shouldBreak =",
                        "      !options.__inJestEach &&",
                        "      node.elements.length > 1 &&",
                        "      node.elements.every((element, i, elements) => {",
                        "        const elementType = element && element.type;",
                        "        if (",
                        "          elementType !== \"ArrayExpression\" &&",
                        "          elementType !== \"ObjectExpression\"",
                        "        ) {",
                        "          return false;",
                        "        }",
                        "",
                        "        const nextElement = elements[i + 1];",
                        "        if (nextElement && elementType !== nextElement.type) {",
                        "          return false;",
                        "        }",
                        "",
                        "        const itemsKey =",
                        "          elementType === \"ArrayExpression\" ? \"elements\" : \"properties\";",
                        "",
                        "        return element[itemsKey] && element[itemsKey].length > 1;",
                        "      });",
                        "",
                        "    const shouldUseConciseFormatting = isConciselyPrintedArray(node, options);",
                        "",
                        "    const trailingComma = !canHaveTrailingComma",
                        "      ? \"\"",
                        "      : needsForcedTrailingComma",
                        "      ? \",\"",
                        "      : !shouldPrintComma(options)",
                        "      ? \"\"",
                        "      : shouldUseConciseFormatting",
                        "      ? ifBreak(\",\", \"\", { groupId })",
                        "      : ifBreak(\",\");",
                        "",
                        "    parts.push(",
                        "      group(",
                        "        [",
                        "          openBracket,",
                        "          indent([",
                        "            softline,",
                        "            shouldUseConciseFormatting",
                        "              ? printArrayItemsConcisely(path, options, print, trailingComma)",
                        "              : [",
                        "                  printArrayItems(path, options, \"elements\", print),",
                        "                  trailingComma,",
                        "                ],",
                        "            printDanglingComments(path, options, /* sameIndent */ true),",
                        "          ]),",
                        "          softline,",
                        "          closeBracket,",
                        "        ],",
                        "        { shouldBreak, id: groupId }",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printOptionalToken(path),",
                        "    printTypeAnnotation(path, options, print)",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function isConciselyPrintedArray(node, options) {",
                        "  return (",
                        "    node.elements.length > 1 &&",
                        "    node.elements.every(",
                        "      (element) =>",
                        "        element &&",
                        "        (isNumericLiteral(element) ||",
                        "          (isSignedNumericLiteral(element) && !hasComment(element.argument))) &&",
                        "        !hasComment(",
                        "          element,",
                        "          CommentCheckFlags.Trailing | CommentCheckFlags.Line,",
                        "          (comment) =>",
                        "            !hasNewline(options.originalText, locStart(comment), {",
                        "              backwards: true,",
                        "            })",
                        "        )",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function printArrayItems(path, options, printPath, print) {",
                        "  const printedElements = [];",
                        "  let separatorParts = [];",
                        "",
                        "  path.each((childPath) => {",
                        "    printedElements.push(separatorParts, group(print()));",
                        "",
                        "    separatorParts = [\",\", line];",
                        "    if (",
                        "      childPath.getValue() &&",
                        "      isNextLineEmpty(childPath.getValue(), options)",
                        "    ) {",
                        "      separatorParts.push(softline);",
                        "    }",
                        "  }, printPath);",
                        "",
                        "  return printedElements;",
                        "}",
                        "",
                        "function printArrayItemsConcisely(path, options, print, trailingComma) {",
                        "  const parts = [];",
                        "",
                        "  path.each((childPath, i, elements) => {",
                        "    const isLast = i === elements.length - 1;",
                        "",
                        "    parts.push([print(), isLast ? trailingComma : \",\"]);",
                        "",
                        "    if (!isLast) {",
                        "      parts.push(",
                        "        isNextLineEmpty(childPath.getValue(), options)",
                        "          ? [hardline, hardline]",
                        "          : hasComment(",
                        "              elements[i + 1],",
                        "              CommentCheckFlags.Leading | CommentCheckFlags.Line",
                        "            )",
                        "          ? hardline",
                        "          : line",
                        "      );",
                        "    }",
                        "  }, \"elements\");",
                        "",
                        "  return fill(parts);",
                        "}",
                        "",
                        "module.exports = { printArray, printArrayItems, isConciselyPrintedArray };"
                    ]
                },
                "assignment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray, getStringWidth } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { line, group, indent, indentIfBreak },",
                        "  utils: { cleanDoc, willBreak, canBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasLeadingOwnLineComment,",
                        "  isBinaryish,",
                        "  isStringLiteral,",
                        "  isLiteral,",
                        "  isNumericLiteral,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  getCallArguments,",
                        "  rawText,",
                        "  hasComment,",
                        "  isSignedNumericLiteral,",
                        "  isObjectProperty,",
                        "} = require(\"../utils/index.js\");",
                        "const { shouldInlineLogicalExpression } = require(\"./binaryish.js\");",
                        "const { printCallExpression } = require(\"./call-expression.js\");",
                        "",
                        "function printAssignment(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  leftDoc,",
                        "  operator,",
                        "  rightPropertyName",
                        ") {",
                        "  const layout = chooseLayout(path, options, print, leftDoc, rightPropertyName);",
                        "",
                        "  const rightDoc = print(rightPropertyName, { assignmentLayout: layout });",
                        "",
                        "  switch (layout) {",
                        "    // First break after operator, then the sides are broken independently on their own lines",
                        "    case \"break-after-operator\":",
                        "      return group([group(leftDoc), operator, group(indent([line, rightDoc]))]);",
                        "",
                        "    // First break right-hand side, then left-hand side",
                        "    case \"never-break-after-operator\":",
                        "      return group([group(leftDoc), operator, \" \", rightDoc]);",
                        "",
                        "    // First break right-hand side, then after operator",
                        "    case \"fluid\": {",
                        "      const groupId = Symbol(\"assignment\");",
                        "      return group([",
                        "        group(leftDoc),",
                        "        operator,",
                        "        group(indent(line), { id: groupId }),",
                        "        indentIfBreak(rightDoc, { groupId }),",
                        "      ]);",
                        "    }",
                        "",
                        "    case \"break-lhs\":",
                        "      return group([leftDoc, operator, \" \", group(rightDoc)]);",
                        "",
                        "    // Parts of assignment chains aren't wrapped in groups.",
                        "    // Once one of them breaks, the chain breaks too.",
                        "    case \"chain\":",
                        "      return [group(leftDoc), operator, line, rightDoc];",
                        "",
                        "    case \"chain-tail\":",
                        "      return [group(leftDoc), operator, indent([line, rightDoc])];",
                        "",
                        "    case \"chain-tail-arrow-chain\":",
                        "      return [group(leftDoc), operator, rightDoc];",
                        "",
                        "    case \"only-left\":",
                        "      return leftDoc;",
                        "  }",
                        "}",
                        "",
                        "function printAssignmentExpression(path, options, print) {",
                        "  const node = path.getValue();",
                        "  return printAssignment(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    print(\"left\"),",
                        "    [\" \", node.operator],",
                        "    \"right\"",
                        "  );",
                        "}",
                        "",
                        "function printVariableDeclarator(path, options, print) {",
                        "  return printAssignment(path, options, print, print(\"id\"), \" =\", \"init\");",
                        "}",
                        "",
                        "function chooseLayout(path, options, print, leftDoc, rightPropertyName) {",
                        "  const node = path.getValue();",
                        "  const rightNode = node[rightPropertyName];",
                        "",
                        "  if (!rightNode) {",
                        "    return \"only-left\";",
                        "  }",
                        "",
                        "  // Short assignment chains (only 2 segments) are NOT formatted as chains.",
                        "  //   1) a = b = c; (expression statements)",
                        "  //   2) var/let/const a = b = c;",
                        "",
                        "  const isTail = !isAssignment(rightNode);",
                        "  const shouldUseChainFormatting = path.match(",
                        "    isAssignment,",
                        "    isAssignmentOrVariableDeclarator,",
                        "    (node) =>",
                        "      !isTail ||",
                        "      (node.type !== \"ExpressionStatement\" &&",
                        "        node.type !== \"VariableDeclaration\")",
                        "  );",
                        "  if (shouldUseChainFormatting) {",
                        "    return !isTail",
                        "      ? \"chain\"",
                        "      : rightNode.type === \"ArrowFunctionExpression\" &&",
                        "        rightNode.body.type === \"ArrowFunctionExpression\"",
                        "      ? \"chain-tail-arrow-chain\"",
                        "      : \"chain-tail\";",
                        "  }",
                        "  const isHeadOfLongChain = !isTail && isAssignment(rightNode.right);",
                        "",
                        "  if (",
                        "    isHeadOfLongChain ||",
                        "    hasLeadingOwnLineComment(options.originalText, rightNode)",
                        "  ) {",
                        "    return \"break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    (rightNode.type === \"CallExpression\" &&",
                        "      rightNode.callee.name === \"require\") ||",
                        "    // do not put values on a separate line from the key in json",
                        "    options.parser === \"json5\" ||",
                        "    options.parser === \"json\"",
                        "  ) {",
                        "    return \"never-break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    isComplexDestructuring(node) ||",
                        "    isComplexTypeAliasParams(node) ||",
                        "    hasComplexTypeAnnotation(node) ||",
                        "    (isArrowFunctionVariableDeclarator(node) && canBreak(leftDoc))",
                        "  ) {",
                        "    return \"break-lhs\";",
                        "  }",
                        "",
                        "  // wrapping object properties with very short keys usually doesn't add much value",
                        "  const hasShortKey = isObjectPropertyWithShortKey(node, leftDoc, options);",
                        "",
                        "  if (",
                        "    path.call(",
                        "      () => shouldBreakAfterOperator(path, options, print, hasShortKey),",
                        "      rightPropertyName",
                        "    )",
                        "  ) {",
                        "    return \"break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    hasShortKey ||",
                        "    rightNode.type === \"TemplateLiteral\" ||",
                        "    rightNode.type === \"TaggedTemplateExpression\" ||",
                        "    rightNode.type === \"BooleanLiteral\" ||",
                        "    isNumericLiteral(rightNode) ||",
                        "    rightNode.type === \"ClassExpression\"",
                        "  ) {",
                        "    return \"never-break-after-operator\";",
                        "  }",
                        "",
                        "  return \"fluid\";",
                        "}",
                        "",
                        "function shouldBreakAfterOperator(path, options, print, hasShortKey) {",
                        "  const rightNode = path.getValue();",
                        "",
                        "  if (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (rightNode.type) {",
                        "    case \"StringLiteralTypeAnnotation\":",
                        "    case \"SequenceExpression\":",
                        "      return true;",
                        "    case \"ConditionalExpression\": {",
                        "      const { test } = rightNode;",
                        "      return isBinaryish(test) && !shouldInlineLogicalExpression(test);",
                        "    }",
                        "    case \"ClassExpression\":",
                        "      return isNonEmptyArray(rightNode.decorators);",
                        "  }",
                        "",
                        "  if (hasShortKey) {",
                        "    return false;",
                        "  }",
                        "",
                        "  let node = rightNode;",
                        "  const propertiesForPath = [];",
                        "  for (;;) {",
                        "    if (node.type === \"UnaryExpression\") {",
                        "      node = node.argument;",
                        "      propertiesForPath.push(\"argument\");",
                        "    } else if (node.type === \"TSNonNullExpression\") {",
                        "      node = node.expression;",
                        "      propertiesForPath.push(\"expression\");",
                        "    } else {",
                        "      break;",
                        "    }",
                        "  }",
                        "  if (",
                        "    isStringLiteral(node) ||",
                        "    path.call(",
                        "      () => isPoorlyBreakableMemberOrCallChain(path, options, print),",
                        "      ...propertiesForPath",
                        "    )",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "// prefer to break destructuring assignment",
                        "// if it includes default values or non-shorthand properties",
                        "function isComplexDestructuring(node) {",
                        "  if (isAssignmentOrVariableDeclarator(node)) {",
                        "    const leftNode = node.left || node.id;",
                        "    return (",
                        "      leftNode.type === \"ObjectPattern\" &&",
                        "      leftNode.properties.length > 2 &&",
                        "      leftNode.properties.some(",
                        "        (property) =>",
                        "          isObjectProperty(property) &&",
                        "          (!property.shorthand ||",
                        "            (property.value && property.value.type === \"AssignmentPattern\"))",
                        "      )",
                        "    );",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function isAssignment(node) {",
                        "  return node.type === \"AssignmentExpression\";",
                        "}",
                        "",
                        "function isAssignmentOrVariableDeclarator(node) {",
                        "  return isAssignment(node) || node.type === \"VariableDeclarator\";",
                        "}",
                        "",
                        "function isComplexTypeAliasParams(node) {",
                        "  const typeParams = getTypeParametersFromTypeAlias(node);",
                        "  if (isNonEmptyArray(typeParams)) {",
                        "    const constraintPropertyName =",
                        "      node.type === \"TSTypeAliasDeclaration\" ? \"constraint\" : \"bound\";",
                        "    if (",
                        "      typeParams.length > 1 &&",
                        "      typeParams.some((param) => param[constraintPropertyName] || param.default)",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function getTypeParametersFromTypeAlias(node) {",
                        "  if (isTypeAlias(node) && node.typeParameters && node.typeParameters.params) {",
                        "    return node.typeParameters.params;",
                        "  }",
                        "  return null;",
                        "}",
                        "",
                        "function isTypeAlias(node) {",
                        "  return node.type === \"TSTypeAliasDeclaration\" || node.type === \"TypeAlias\";",
                        "}",
                        "",
                        "function hasComplexTypeAnnotation(node) {",
                        "  if (node.type !== \"VariableDeclarator\") {",
                        "    return false;",
                        "  }",
                        "  const { typeAnnotation } = node.id;",
                        "  if (!typeAnnotation || !typeAnnotation.typeAnnotation) {",
                        "    return false;",
                        "  }",
                        "  const typeParams = getTypeParametersFromTypeReference(",
                        "    typeAnnotation.typeAnnotation",
                        "  );",
                        "  return (",
                        "    isNonEmptyArray(typeParams) &&",
                        "    typeParams.length > 1 &&",
                        "    typeParams.some(",
                        "      (param) =>",
                        "        isNonEmptyArray(getTypeParametersFromTypeReference(param)) ||",
                        "        param.type === \"TSConditionalType\"",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function isArrowFunctionVariableDeclarator(node) {",
                        "  return (",
                        "    node.type === \"VariableDeclarator\" &&",
                        "    node.init &&",
                        "    node.init.type === \"ArrowFunctionExpression\"",
                        "  );",
                        "}",
                        "",
                        "function getTypeParametersFromTypeReference(node) {",
                        "  if (",
                        "    isTypeReference(node) &&",
                        "    node.typeParameters &&",
                        "    node.typeParameters.params",
                        "  ) {",
                        "    return node.typeParameters.params;",
                        "  }",
                        "  return null;",
                        "}",
                        "",
                        "function isTypeReference(node) {",
                        "  return (",
                        "    node.type === \"TSTypeReference\" || node.type === \"GenericTypeAnnotation\"",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * A chain with no calls at all or whose calls are all without arguments or with lone short arguments,",
                        " * excluding chains printed by `printMemberChain`",
                        " */",
                        "function isPoorlyBreakableMemberOrCallChain(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  deep = false",
                        ") {",
                        "  const node = path.getValue();",
                        "  const goDeeper = () =>",
                        "    isPoorlyBreakableMemberOrCallChain(path, options, print, true);",
                        "",
                        "  if (node.type === \"TSNonNullExpression\") {",
                        "    return path.call(goDeeper, \"expression\");",
                        "  }",
                        "",
                        "  if (isCallExpression(node)) {",
                        "    /** @type {any} TODO */",
                        "    const doc = printCallExpression(path, options, print);",
                        "    if (doc.label === \"member-chain\") {",
                        "      return false;",
                        "    }",
                        "",
                        "    const args = getCallArguments(node);",
                        "    const isPoorlyBreakableCall =",
                        "      args.length === 0 ||",
                        "      (args.length === 1 && isLoneShortArgument(args[0], options));",
                        "    if (!isPoorlyBreakableCall) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (isCallExpressionWithComplexTypeArguments(node, print)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return path.call(goDeeper, \"callee\");",
                        "  }",
                        "",
                        "  if (isMemberExpression(node)) {",
                        "    return path.call(goDeeper, \"object\");",
                        "  }",
                        "",
                        "  return deep && (node.type === \"Identifier\" || node.type === \"ThisExpression\");",
                        "}",
                        "",
                        "const LONE_SHORT_ARGUMENT_THRESHOLD_RATE = 0.25;",
                        "",
                        "function isLoneShortArgument(node, { printWidth }) {",
                        "  if (hasComment(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const threshold = printWidth * LONE_SHORT_ARGUMENT_THRESHOLD_RATE;",
                        "",
                        "  if (",
                        "    node.type === \"ThisExpression\" ||",
                        "    (node.type === \"Identifier\" && node.name.length <= threshold) ||",
                        "    (isSignedNumericLiteral(node) && !hasComment(node.argument))",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const regexpPattern =",
                        "    (node.type === \"Literal\" && \"regex\" in node && node.regex.pattern) ||",
                        "    (node.type === \"RegExpLiteral\" && node.pattern);",
                        "",
                        "  if (regexpPattern) {",
                        "    return regexpPattern.length <= threshold;",
                        "  }",
                        "",
                        "  if (isStringLiteral(node)) {",
                        "    return rawText(node).length <= threshold;",
                        "  }",
                        "",
                        "  if (node.type === \"TemplateLiteral\") {",
                        "    return (",
                        "      node.expressions.length === 0 &&",
                        "      node.quasis[0].value.raw.length <= threshold &&",
                        "      !node.quasis[0].value.raw.includes(\"\\n\")",
                        "    );",
                        "  }",
                        "",
                        "  return isLiteral(node);",
                        "}",
                        "",
                        "function isObjectPropertyWithShortKey(node, keyDoc, options) {",
                        "  if (!isObjectProperty(node)) {",
                        "    return false;",
                        "  }",
                        "  // TODO: for performance, it might make sense to use a more lightweight",
                        "  // version of cleanDoc, such that it would stop once it detects that",
                        "  // the doc can't be reduced to a string.",
                        "  keyDoc = cleanDoc(keyDoc);",
                        "  const MIN_OVERLAP_FOR_BREAK = 3;",
                        "  //   \u2193\u2193 - insufficient overlap for a line break",
                        "  // key1: longValue1,",
                        "  //   \u2193\u2193\u2193\u2193\u2193\u2193 - overlap is long enough to break",
                        "  // key2abcd:",
                        "  //   longValue2",
                        "  return (",
                        "    typeof keyDoc === \"string\" &&",
                        "    getStringWidth(keyDoc) < options.tabWidth + MIN_OVERLAP_FOR_BREAK",
                        "  );",
                        "}",
                        "",
                        "function isCallExpressionWithComplexTypeArguments(node, print) {",
                        "  const typeArgs = getTypeArgumentsFromCallExpression(node);",
                        "  if (isNonEmptyArray(typeArgs)) {",
                        "    if (typeArgs.length > 1) {",
                        "      return true;",
                        "    }",
                        "    if (typeArgs.length === 1) {",
                        "      const firstArg = typeArgs[0];",
                        "      if (",
                        "        firstArg.type === \"TSUnionType\" ||",
                        "        firstArg.type === \"UnionTypeAnnotation\" ||",
                        "        firstArg.type === \"TSIntersectionType\" ||",
                        "        firstArg.type === \"IntersectionTypeAnnotation\"",
                        "      ) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "    const typeArgsKeyName = node.typeParameters",
                        "      ? \"typeParameters\"",
                        "      : \"typeArguments\";",
                        "    if (willBreak(print(typeArgsKeyName))) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function getTypeArgumentsFromCallExpression(node) {",
                        "  return (",
                        "    (node.typeParameters && node.typeParameters.params) ||",
                        "    (node.typeArguments && node.typeArguments.params)",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  printVariableDeclarator,",
                        "  printAssignmentExpression,",
                        "  printAssignment,",
                        "  isArrowFunctionVariableDeclarator,",
                        "};"
                    ]
                },
                "binaryish.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printComments } = require(\"../../main/comments.js\");",
                        "const { getLast } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: {",
                        "    join,",
                        "    line,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    align,",
                        "    ifBreak,",
                        "    indentIfBreak,",
                        "  },",
                        "  utils: { cleanDoc, getDocParts, isConcat },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasLeadingOwnLineComment,",
                        "  isBinaryish,",
                        "  isJsxNode,",
                        "  shouldFlatten,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isObjectProperty,",
                        "  isEnabledHackPipeline,",
                        "} = require(\"../utils/index.js\");",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "let uid = 0;",
                        "function printBinaryishExpression(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parent = path.getParentNode();",
                        "  const parentParent = path.getParentNode(1);",
                        "  const isInsideParenthesis =",
                        "    node !== parent.body &&",
                        "    (parent.type === \"IfStatement\" ||",
                        "      parent.type === \"WhileStatement\" ||",
                        "      parent.type === \"SwitchStatement\" ||",
                        "      parent.type === \"DoWhileStatement\");",
                        "  const isHackPipeline =",
                        "    isEnabledHackPipeline(options) && node.operator === \"|>\";",
                        "",
                        "  const parts = printBinaryishExpressions(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    /* isNested */ false,",
                        "    isInsideParenthesis",
                        "  );",
                        "",
                        "  //   if (",
                        "  //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft",
                        "  //   ) {",
                        "  //",
                        "  // looks super weird, we want to break the children if the parent breaks",
                        "  //",
                        "  //   if (",
                        "  //     this.hasPlugin(\"dynamicImports\") &&",
                        "  //     this.lookahead().type === tt.parenLeft",
                        "  //   ) {",
                        "  if (isInsideParenthesis) {",
                        "    return parts;",
                        "  }",
                        "",
                        "  if (isHackPipeline) {",
                        "    return group(parts);",
                        "  }",
                        "",
                        "  // Break between the parens in",
                        "  // unaries or in a member or specific call expression, i.e.",
                        "  //",
                        "  //   (",
                        "  //     a &&",
                        "  //     b &&",
                        "  //     c",
                        "  //   ).call()",
                        "  if (",
                        "    (isCallExpression(parent) && parent.callee === node) ||",
                        "    parent.type === \"UnaryExpression\" ||",
                        "    (isMemberExpression(parent) && !parent.computed)",
                        "  ) {",
                        "    return group([indent([softline, ...parts]), softline]);",
                        "  }",
                        "",
                        "  // Avoid indenting sub-expressions in some cases where the first sub-expression is already",
                        "  // indented accordingly. We should indent sub-expressions where the first case isn't indented.",
                        "  const shouldNotIndent =",
                        "    parent.type === \"ReturnStatement\" ||",
                        "    parent.type === \"ThrowStatement\" ||",
                        "    (parent.type === \"JSXExpressionContainer\" &&",
                        "      parentParent.type === \"JSXAttribute\") ||",
                        "    (node.operator !== \"|\" && parent.type === \"JsExpressionRoot\") ||",
                        "    (node.type !== \"NGPipeExpression\" &&",
                        "      ((parent.type === \"NGRoot\" && options.parser === \"__ng_binding\") ||",
                        "        (parent.type === \"NGMicrosyntaxExpression\" &&",
                        "          parentParent.type === \"NGMicrosyntax\" &&",
                        "          parentParent.body.length === 1))) ||",
                        "    (node === parent.body && parent.type === \"ArrowFunctionExpression\") ||",
                        "    (node !== parent.body && parent.type === \"ForStatement\") ||",
                        "    (parent.type === \"ConditionalExpression\" &&",
                        "      parentParent.type !== \"ReturnStatement\" &&",
                        "      parentParent.type !== \"ThrowStatement\" &&",
                        "      !isCallExpression(parentParent)) ||",
                        "    parent.type === \"TemplateLiteral\";",
                        "",
                        "  const shouldIndentIfInlining =",
                        "    parent.type === \"AssignmentExpression\" ||",
                        "    parent.type === \"VariableDeclarator\" ||",
                        "    parent.type === \"ClassProperty\" ||",
                        "    parent.type === \"PropertyDefinition\" ||",
                        "    parent.type === \"TSAbstractPropertyDefinition\" ||",
                        "    parent.type === \"ClassPrivateProperty\" ||",
                        "    isObjectProperty(parent);",
                        "",
                        "  const samePrecedenceSubExpression =",
                        "    isBinaryish(node.left) && shouldFlatten(node.operator, node.left.operator);",
                        "",
                        "  if (",
                        "    shouldNotIndent ||",
                        "    (shouldInlineLogicalExpression(node) && !samePrecedenceSubExpression) ||",
                        "    (!shouldInlineLogicalExpression(node) && shouldIndentIfInlining)",
                        "  ) {",
                        "    return group(parts);",
                        "  }",
                        "",
                        "  if (parts.length === 0) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // If the right part is a JSX node, we include it in a separate group to",
                        "  // prevent it breaking the whole chain, so we can print the expression like:",
                        "  //",
                        "  //   foo && bar && (",
                        "  //     <Foo>",
                        "  //       <Bar />",
                        "  //     </Foo>",
                        "  //   )",
                        "",
                        "  const hasJsx = isJsxNode(node.right);",
                        "",
                        "  const firstGroupIndex = parts.findIndex(",
                        "    (part) =>",
                        "      typeof part !== \"string\" && !Array.isArray(part) && part.type === \"group\"",
                        "  );",
                        "",
                        "  // Separate the leftmost expression, possibly with its leading comments.",
                        "  const headParts = parts.slice(",
                        "    0,",
                        "    firstGroupIndex === -1 ? 1 : firstGroupIndex + 1",
                        "  );",
                        "",
                        "  const rest = parts.slice(headParts.length, hasJsx ? -1 : undefined);",
                        "",
                        "  const groupId = Symbol(\"logicalChain-\" + ++uid);",
                        "",
                        "  const chain = group(",
                        "    [",
                        "      // Don't include the initial expression in the indentation",
                        "      // level. The first item is guaranteed to be the first",
                        "      // left-most expression.",
                        "      ...headParts,",
                        "      indent(rest),",
                        "    ],",
                        "    { id: groupId }",
                        "  );",
                        "",
                        "  if (!hasJsx) {",
                        "    return chain;",
                        "  }",
                        "",
                        "  const jsxPart = getLast(parts);",
                        "  return group([chain, indentIfBreak(jsxPart, { groupId })]);",
                        "}",
                        "",
                        "// For binary expressions to be consistent, we need to group",
                        "// subsequent operators with the same precedence level under a single",
                        "// group. Otherwise they will be nested such that some of them break",
                        "// onto new lines but not all. Operators with the same precedence",
                        "// level should either all break or not. Because we group them by",
                        "// precedence level and the AST is structured based on precedence",
                        "// level, things are naturally broken up correctly, i.e. `&&` is",
                        "// broken before `+`.",
                        "function printBinaryishExpressions(",
                        "  path,",
                        "  print,",
                        "  options,",
                        "  isNested,",
                        "  isInsideParenthesis",
                        ") {",
                        "  const node = path.getValue();",
                        "",
                        "  // Simply print the node normally.",
                        "  if (!isBinaryish(node)) {",
                        "    return [group(print())];",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  let parts = [];",
                        "",
                        "  // We treat BinaryExpression and LogicalExpression nodes the same.",
                        "",
                        "  // Put all operators with the same precedence level in the same",
                        "  // group. The reason we only need to do this with the `left`",
                        "  // expression is because given an expression like `1 + 2 - 3`, it",
                        "  // is always parsed like `((1 + 2) - 3)`, meaning the `left` side",
                        "  // is where the rest of the expression will exist. Binary",
                        "  // expressions on the right side mean they have a difference",
                        "  // precedence level and should be treated as a separate group, so",
                        "  // print them normally. (This doesn't hold for the `**` operator,",
                        "  // which is unique in that it is right-associative.)",
                        "  if (shouldFlatten(node.operator, node.left.operator)) {",
                        "    // Flatten them out by recursively calling this function.",
                        "    parts = path.call(",
                        "      (left) =>",
                        "        printBinaryishExpressions(",
                        "          left,",
                        "          print,",
                        "          options,",
                        "          /* isNested */ true,",
                        "          isInsideParenthesis",
                        "        ),",
                        "      \"left\"",
                        "    );",
                        "  } else {",
                        "    parts.push(group(print(\"left\")));",
                        "  }",
                        "",
                        "  const shouldInline = shouldInlineLogicalExpression(node);",
                        "  const lineBeforeOperator =",
                        "    (node.operator === \"|>\" ||",
                        "      node.type === \"NGPipeExpression\" ||",
                        "      (node.operator === \"|\" && options.parser === \"__vue_expression\")) &&",
                        "    !hasLeadingOwnLineComment(options.originalText, node.right);",
                        "",
                        "  const operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;",
                        "  const rightSuffix =",
                        "    node.type === \"NGPipeExpression\" && node.arguments.length > 0",
                        "      ? group(",
                        "          indent([",
                        "            softline,",
                        "            \": \",",
                        "            join(",
                        "              [softline, \":\", ifBreak(\" \")],",
                        "              path.map(print, \"arguments\").map((arg) => align(2, group(arg)))",
                        "            ),",
                        "          ])",
                        "        )",
                        "      : \"\";",
                        "",
                        "  /** @type {Doc} */",
                        "  let right;",
                        "  if (shouldInline) {",
                        "    right = [operator, \" \", print(\"right\"), rightSuffix];",
                        "  } else {",
                        "    const isHackPipeline = isEnabledHackPipeline(options) && operator === \"|>\";",
                        "    const rightContent = isHackPipeline",
                        "      ? path.call(",
                        "          (left) =>",
                        "            printBinaryishExpressions(",
                        "              left,",
                        "              print,",
                        "              options,",
                        "              /* isNested */ true,",
                        "              isInsideParenthesis",
                        "            ),",
                        "          \"right\"",
                        "        )",
                        "      : print(\"right\");",
                        "    right = [",
                        "      lineBeforeOperator ? line : \"\",",
                        "      operator,",
                        "      lineBeforeOperator ? \" \" : line,",
                        "      rightContent,",
                        "      rightSuffix,",
                        "    ];",
                        "  }",
                        "",
                        "  // If there's only a single binary expression, we want to create a group",
                        "  // in order to avoid having a small right part like -1 be on its own line.",
                        "  const parent = path.getParentNode();",
                        "  const shouldBreak = hasComment(",
                        "    node.left,",
                        "    CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "  );",
                        "  const shouldGroup =",
                        "    shouldBreak ||",
                        "    (!(isInsideParenthesis && node.type === \"LogicalExpression\") &&",
                        "      parent.type !== node.type &&",
                        "      node.left.type !== node.type &&",
                        "      node.right.type !== node.type);",
                        "",
                        "  parts.push(",
                        "    lineBeforeOperator ? \"\" : \" \",",
                        "    shouldGroup ? group(right, { shouldBreak }) : right",
                        "  );",
                        "",
                        "  // The root comments are already printed, but we need to manually print",
                        "  // the other ones since we don't call the normal print on BinaryExpression,",
                        "  // only for the left and right parts",
                        "  if (isNested && hasComment(node)) {",
                        "    const printed = cleanDoc(printComments(path, parts, options));",
                        "    /* istanbul ignore else */",
                        "    if (isConcat(printed) || printed.type === \"fill\") {",
                        "      return getDocParts(printed);",
                        "    }",
                        "",
                        "    return [printed];",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldInlineLogicalExpression(node) {",
                        "  if (node.type !== \"LogicalExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    node.right.type === \"ObjectExpression\" &&",
                        "    node.right.properties.length > 0",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.right.type === \"ArrayExpression\" && node.right.elements.length > 0) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (isJsxNode(node.right)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "module.exports = { printBinaryishExpression, shouldInlineLogicalExpression };"
                    ]
                },
                "block.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { hardline, indent },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { printHardlineAfterHeritage } = require(\"./class.js\");",
                        "",
                        "const { printBody } = require(\"./statement.js\");",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "function printBlock(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  if (node.type === \"StaticBlock\") {",
                        "    parts.push(\"static \");",
                        "  }",
                        "",
                        "  if (node.type === \"ClassBody\" && isNonEmptyArray(node.body)) {",
                        "    const parent = path.getParentNode();",
                        "    parts.push(printHardlineAfterHeritage(parent));",
                        "  }",
                        "",
                        "  parts.push(\"{\");",
                        "  const printed = printBlockBody(path, options, print);",
                        "  if (printed) {",
                        "    parts.push(indent([hardline, printed]), hardline);",
                        "  } else {",
                        "    const parent = path.getParentNode();",
                        "    const parentParent = path.getParentNode(1);",
                        "    if (",
                        "      !(",
                        "        parent.type === \"ArrowFunctionExpression\" ||",
                        "        parent.type === \"FunctionExpression\" ||",
                        "        parent.type === \"FunctionDeclaration\" ||",
                        "        parent.type === \"ObjectMethod\" ||",
                        "        parent.type === \"ClassMethod\" ||",
                        "        parent.type === \"ClassPrivateMethod\" ||",
                        "        parent.type === \"ForStatement\" ||",
                        "        parent.type === \"WhileStatement\" ||",
                        "        parent.type === \"DoWhileStatement\" ||",
                        "        parent.type === \"DoExpression\" ||",
                        "        (parent.type === \"CatchClause\" && !parentParent.finalizer) ||",
                        "        parent.type === \"TSModuleDeclaration\" ||",
                        "        parent.type === \"TSDeclareFunction\" ||",
                        "        node.type === \"StaticBlock\" ||",
                        "        node.type === \"ClassBody\"",
                        "      )",
                        "    ) {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  parts.push(\"}\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printBlockBody(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  const nodeHasDirectives = isNonEmptyArray(node.directives);",
                        "  const nodeHasBody = node.body.some((node) => node.type !== \"EmptyStatement\");",
                        "  const nodeHasComment = hasComment(node, CommentCheckFlags.Dangling);",
                        "",
                        "  if (!nodeHasDirectives && !nodeHasBody && !nodeHasComment) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const parts = [];",
                        "  // Babel 6",
                        "  if (nodeHasDirectives) {",
                        "    path.each((childPath, index, directives) => {",
                        "      parts.push(print());",
                        "      if (index < directives.length - 1 || nodeHasBody || nodeHasComment) {",
                        "        parts.push(hardline);",
                        "        if (isNextLineEmpty(childPath.getValue(), options)) {",
                        "          parts.push(hardline);",
                        "        }",
                        "      }",
                        "    }, \"directives\");",
                        "  }",
                        "",
                        "  if (nodeHasBody) {",
                        "    parts.push(printBody(path, options, print));",
                        "  }",
                        "",
                        "  if (nodeHasComment) {",
                        "    parts.push(printDanglingComments(path, options, /* sameIndent */ true));",
                        "  }",
                        "",
                        "  if (node.type === \"Program\") {",
                        "    const parent = path.getParentNode();",
                        "    if (!parent || parent.type !== \"ModuleExpression\") {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "module.exports = { printBlock, printBlockBody };"
                    ]
                },
                "call-arguments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const { getLast, getPenultimate } = require(\"../../common/util.js\");",
                        "const {",
                        "  getFunctionParameters,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isFunctionCompositionArgs,",
                        "  isJsxNode,",
                        "  isLongCurriedCallExpression,",
                        "  shouldPrintComma,",
                        "  getCallArguments,",
                        "  iterateCallArgumentsPath,",
                        "  isNextLineEmpty,",
                        "  isCallExpression,",
                        "  isStringLiteral,",
                        "  isObjectProperty,",
                        "} = require(\"../utils/index.js\");",
                        "",
                        "const {",
                        "  builders: {",
                        "    line,",
                        "    hardline,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    ifBreak,",
                        "    breakParent,",
                        "  },",
                        "  utils: { willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "const { ArgExpansionBailout } = require(\"../../common/errors.js\");",
                        "const { isConciselyPrintedArray } = require(\"./array.js\");",
                        "",
                        "function printCallArguments(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const isDynamicImport = node.type === \"ImportExpression\";",
                        "",
                        "  const args = getCallArguments(node);",
                        "  if (args.length === 0) {",
                        "    return [",
                        "      \"(\",",
                        "      printDanglingComments(path, options, /* sameIndent */ true),",
                        "      \")\",",
                        "    ];",
                        "  }",
                        "",
                        "  // useEffect(() => { ... }, [foo, bar, baz])",
                        "  if (isReactHookCallWithDepsArray(args)) {",
                        "    return [\"(\", print([\"arguments\", 0]), \", \", print([\"arguments\", 1]), \")\"];",
                        "  }",
                        "",
                        "  let anyArgEmptyLine = false;",
                        "  let hasEmptyLineFollowingFirstArg = false;",
                        "  const lastArgIndex = args.length - 1;",
                        "  const printedArguments = [];",
                        "  iterateCallArgumentsPath(path, (argPath, index) => {",
                        "    const arg = argPath.getNode();",
                        "    const parts = [print()];",
                        "",
                        "    if (index === lastArgIndex) {",
                        "      // do nothing",
                        "    } else if (isNextLineEmpty(arg, options)) {",
                        "      if (index === 0) {",
                        "        hasEmptyLineFollowingFirstArg = true;",
                        "      }",
                        "",
                        "      anyArgEmptyLine = true;",
                        "      parts.push(\",\", hardline, hardline);",
                        "    } else {",
                        "      parts.push(\",\", line);",
                        "    }",
                        "",
                        "    printedArguments.push(parts);",
                        "  });",
                        "",
                        "  const maybeTrailingComma =",
                        "    // Dynamic imports cannot have trailing commas",
                        "    !(isDynamicImport || (node.callee && node.callee.type === \"Import\")) &&",
                        "    shouldPrintComma(options, \"all\")",
                        "      ? \",\"",
                        "      : \"\";",
                        "",
                        "  function allArgsBrokenOut() {",
                        "    return group(",
                        "      [\"(\", indent([line, ...printedArguments]), maybeTrailingComma, line, \")\"],",
                        "      { shouldBreak: true }",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    anyArgEmptyLine ||",
                        "    (path.getParentNode().type !== \"Decorator\" &&",
                        "      isFunctionCompositionArgs(args))",
                        "  ) {",
                        "    return allArgsBrokenOut();",
                        "  }",
                        "",
                        "  const shouldGroupFirst = shouldGroupFirstArg(args);",
                        "  const shouldGroupLast = shouldGroupLastArg(args, options);",
                        "  if (shouldGroupFirst || shouldGroupLast) {",
                        "    if (",
                        "      shouldGroupFirst",
                        "        ? printedArguments.slice(1).some(willBreak)",
                        "        : printedArguments.slice(0, -1).some(willBreak)",
                        "    ) {",
                        "      return allArgsBrokenOut();",
                        "    }",
                        "",
                        "    // We want to print the last argument with a special flag",
                        "    let printedExpanded = [];",
                        "",
                        "    try {",
                        "      path.try(() => {",
                        "        iterateCallArgumentsPath(path, (argPath, i) => {",
                        "          if (shouldGroupFirst && i === 0) {",
                        "            printedExpanded = [",
                        "              [",
                        "                print([], { expandFirstArg: true }),",
                        "                printedArguments.length > 1 ? \",\" : \"\",",
                        "                hasEmptyLineFollowingFirstArg ? hardline : line,",
                        "                hasEmptyLineFollowingFirstArg ? hardline : \"\",",
                        "              ],",
                        "              ...printedArguments.slice(1),",
                        "            ];",
                        "          }",
                        "          if (shouldGroupLast && i === lastArgIndex) {",
                        "            printedExpanded = [",
                        "              ...printedArguments.slice(0, -1),",
                        "              print([], { expandLastArg: true }),",
                        "            ];",
                        "          }",
                        "        });",
                        "      });",
                        "    } catch (caught) {",
                        "      if (caught instanceof ArgExpansionBailout) {",
                        "        return allArgsBrokenOut();",
                        "      }",
                        "      /* istanbul ignore next */",
                        "      throw caught;",
                        "    }",
                        "",
                        "    return [",
                        "      printedArguments.some(willBreak) ? breakParent : \"\",",
                        "      conditionalGroup([",
                        "        [\"(\", ...printedExpanded, \")\"],",
                        "        shouldGroupFirst",
                        "          ? [",
                        "              \"(\",",
                        "              group(printedExpanded[0], { shouldBreak: true }),",
                        "              ...printedExpanded.slice(1),",
                        "              \")\",",
                        "            ]",
                        "          : [",
                        "              \"(\",",
                        "              ...printedArguments.slice(0, -1),",
                        "              group(getLast(printedExpanded), { shouldBreak: true }),",
                        "              \")\",",
                        "            ],",
                        "        allArgsBrokenOut(),",
                        "      ]),",
                        "    ];",
                        "  }",
                        "",
                        "  const contents = [",
                        "    \"(\",",
                        "    indent([softline, ...printedArguments]),",
                        "    ifBreak(maybeTrailingComma),",
                        "    softline,",
                        "    \")\",",
                        "  ];",
                        "  if (isLongCurriedCallExpression(path)) {",
                        "    // By not wrapping the arguments in a group, the printer prioritizes",
                        "    // breaking up these arguments rather than the args of the parent call.",
                        "    return contents;",
                        "  }",
                        "",
                        "  return group(contents, {",
                        "    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine,",
                        "  });",
                        "}",
                        "",
                        "function couldGroupArg(arg, arrowChainRecursion = false) {",
                        "  return (",
                        "    (arg.type === \"ObjectExpression\" &&",
                        "      (arg.properties.length > 0 || hasComment(arg))) ||",
                        "    (arg.type === \"ArrayExpression\" &&",
                        "      (arg.elements.length > 0 || hasComment(arg))) ||",
                        "    (arg.type === \"TSTypeAssertion\" && couldGroupArg(arg.expression)) ||",
                        "    (arg.type === \"TSAsExpression\" && couldGroupArg(arg.expression)) ||",
                        "    arg.type === \"FunctionExpression\" ||",
                        "    (arg.type === \"ArrowFunctionExpression\" &&",
                        "      // we want to avoid breaking inside composite return types but not simple keywords",
                        "      // https://github.com/prettier/prettier/issues/4070",
                        "      // export class Thing implements OtherThing {",
                        "      //   do: (type: Type) => Provider<Prop> = memoize(",
                        "      //     (type: ObjectType): Provider<Opts> => {}",
                        "      //   );",
                        "      // }",
                        "      // https://github.com/prettier/prettier/issues/6099",
                        "      // app.get(\"/\", (req, res): void => {",
                        "      //   res.send(\"Hello World!\");",
                        "      // });",
                        "      (!arg.returnType ||",
                        "        !arg.returnType.typeAnnotation ||",
                        "        arg.returnType.typeAnnotation.type !== \"TSTypeReference\" ||",
                        "        // https://github.com/prettier/prettier/issues/7542",
                        "        isNonEmptyBlockStatement(arg.body)) &&",
                        "      (arg.body.type === \"BlockStatement\" ||",
                        "        (arg.body.type === \"ArrowFunctionExpression\" &&",
                        "          couldGroupArg(arg.body, true)) ||",
                        "        arg.body.type === \"ObjectExpression\" ||",
                        "        arg.body.type === \"ArrayExpression\" ||",
                        "        (!arrowChainRecursion &&",
                        "          (isCallExpression(arg.body) ||",
                        "            arg.body.type === \"ConditionalExpression\")) ||",
                        "        isJsxNode(arg.body))) ||",
                        "    arg.type === \"DoExpression\" ||",
                        "    arg.type === \"ModuleExpression\"",
                        "  );",
                        "}",
                        "",
                        "function shouldGroupLastArg(args, options) {",
                        "  const lastArg = getLast(args);",
                        "  const penultimateArg = getPenultimate(args);",
                        "  return (",
                        "    !hasComment(lastArg, CommentCheckFlags.Leading) &&",
                        "    !hasComment(lastArg, CommentCheckFlags.Trailing) &&",
                        "    couldGroupArg(lastArg) &&",
                        "    // If the last two arguments are of the same type,",
                        "    // disable last element expansion.",
                        "    (!penultimateArg || penultimateArg.type !== lastArg.type) &&",
                        "    // useMemo(() => func(), [foo, bar, baz])",
                        "    (args.length !== 2 ||",
                        "      penultimateArg.type !== \"ArrowFunctionExpression\" ||",
                        "      lastArg.type !== \"ArrayExpression\") &&",
                        "    !(",
                        "      args.length > 1 &&",
                        "      lastArg.type === \"ArrayExpression\" &&",
                        "      isConciselyPrintedArray(lastArg, options)",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function shouldGroupFirstArg(args) {",
                        "  if (args.length !== 2) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const [firstArg, secondArg] = args;",
                        "",
                        "  if (",
                        "    firstArg.type === \"ModuleExpression\" &&",
                        "    isTypeModuleObjectExpression(secondArg)",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return (",
                        "    !hasComment(firstArg) &&",
                        "    (firstArg.type === \"FunctionExpression\" ||",
                        "      (firstArg.type === \"ArrowFunctionExpression\" &&",
                        "        firstArg.body.type === \"BlockStatement\")) &&",
                        "    secondArg.type !== \"FunctionExpression\" &&",
                        "    secondArg.type !== \"ArrowFunctionExpression\" &&",
                        "    secondArg.type !== \"ConditionalExpression\" &&",
                        "    !couldGroupArg(secondArg)",
                        "  );",
                        "}",
                        "",
                        "function isReactHookCallWithDepsArray(args) {",
                        "  return (",
                        "    args.length === 2 &&",
                        "    args[0].type === \"ArrowFunctionExpression\" &&",
                        "    getFunctionParameters(args[0]).length === 0 &&",
                        "    args[0].body.type === \"BlockStatement\" &&",
                        "    args[1].type === \"ArrayExpression\" &&",
                        "    !args.some((arg) => hasComment(arg))",
                        "  );",
                        "}",
                        "",
                        "function isNonEmptyBlockStatement(node) {",
                        "  return (",
                        "    node.type === \"BlockStatement\" &&",
                        "    (node.body.some((node) => node.type !== \"EmptyStatement\") ||",
                        "      hasComment(node, CommentCheckFlags.Dangling))",
                        "  );",
                        "}",
                        "",
                        "// { type: \"module\" }",
                        "function isTypeModuleObjectExpression(node) {",
                        "  return (",
                        "    node.type === \"ObjectExpression\" &&",
                        "    node.properties.length === 1 &&",
                        "    isObjectProperty(node.properties[0]) &&",
                        "    node.properties[0].key.type === \"Identifier\" &&",
                        "    node.properties[0].key.name === \"type\" &&",
                        "    isStringLiteral(node.properties[0].value) &&",
                        "    node.properties[0].value.value === \"module\"",
                        "  );",
                        "}",
                        "",
                        "module.exports = printCallArguments;"
                    ]
                },
                "call-expression.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { join, group },",
                        "} = require(\"../../document/index.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const {",
                        "  getCallArguments,",
                        "  hasFlowAnnotationComment,",
                        "  isCallExpression,",
                        "  isMemberish,",
                        "  isStringLiteral,",
                        "  isTemplateOnItsOwnLine,",
                        "  isTestCall,",
                        "  iterateCallArgumentsPath,",
                        "} = require(\"../utils/index.js\");",
                        "const printMemberChain = require(\"./member-chain.js\");",
                        "const printCallArguments = require(\"./call-arguments.js\");",
                        "const {",
                        "  printOptionalToken,",
                        "  printFunctionTypeParameters,",
                        "} = require(\"./misc.js\");",
                        "",
                        "function printCallExpression(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parentNode = path.getParentNode();",
                        "  const isNew = node.type === \"NewExpression\";",
                        "  const isDynamicImport = node.type === \"ImportExpression\";",
                        "",
                        "  const optional = printOptionalToken(path);",
                        "  const args = getCallArguments(node);",
                        "  if (",
                        "    // Dangling comments are not handled, all these special cases should have arguments #9668",
                        "    args.length > 0 &&",
                        "    // We want to keep CommonJS- and AMD-style require calls, and AMD-style",
                        "    // define calls, as a unit.",
                        "    // e.g. `define([\"some/lib\"], (lib) => {`",
                        "    ((!isDynamicImport && !isNew && isCommonsJsOrAmdCall(node, parentNode)) ||",
                        "      // Template literals as single arguments",
                        "      (args.length === 1 &&",
                        "        isTemplateOnItsOwnLine(args[0], options.originalText)) ||",
                        "      // Keep test declarations on a single line",
                        "      // e.g. `it('long name', () => {`",
                        "      (!isNew && isTestCall(node, parentNode)))",
                        "  ) {",
                        "    const printed = [];",
                        "    iterateCallArgumentsPath(path, () => {",
                        "      printed.push(print());",
                        "    });",
                        "    return [",
                        "      isNew ? \"new \" : \"\",",
                        "      print(\"callee\"),",
                        "      optional,",
                        "      printFunctionTypeParameters(path, options, print),",
                        "      \"(\",",
                        "      join(\", \", printed),",
                        "      \")\",",
                        "    ];",
                        "  }",
                        "",
                        "  // Inline Flow annotation comments following Identifiers in Call nodes need to",
                        "  // stay with the Identifier. For example:",
                        "  //",
                        "  // foo /*:: <SomeGeneric> */(bar);",
                        "  //",
                        "  // Here, we ensure that such comments stay between the Identifier and the Callee.",
                        "  const isIdentifierWithFlowAnnotation =",
                        "    (options.parser === \"babel\" || options.parser === \"babel-flow\") &&",
                        "    node.callee &&",
                        "    node.callee.type === \"Identifier\" &&",
                        "    hasFlowAnnotationComment(node.callee.trailingComments);",
                        "  if (isIdentifierWithFlowAnnotation) {",
                        "    node.callee.trailingComments[0].printed = true;",
                        "  }",
                        "",
                        "  // We detect calls on member lookups and possibly print them in a",
                        "  // special chain format. See `printMemberChain` for more info.",
                        "  if (",
                        "    !isDynamicImport &&",
                        "    !isNew &&",
                        "    isMemberish(node.callee) &&",
                        "    !path.call((path) => pathNeedsParens(path, options), \"callee\")",
                        "  ) {",
                        "    return printMemberChain(path, options, print);",
                        "  }",
                        "",
                        "  const contents = [",
                        "    isNew ? \"new \" : \"\",",
                        "    isDynamicImport ? \"import\" : print(\"callee\"),",
                        "    optional,",
                        "    isIdentifierWithFlowAnnotation",
                        "      ? `/*:: ${node.callee.trailingComments[0].value.slice(2).trim()} */`",
                        "      : \"\",",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    printCallArguments(path, options, print),",
                        "  ];",
                        "",
                        "  // We group here when the callee is itself a call expression.",
                        "  // See `isLongCurriedCallExpression` for more info.",
                        "  if (isDynamicImport || isCallExpression(node.callee)) {",
                        "    return group(contents);",
                        "  }",
                        "",
                        "  return contents;",
                        "}",
                        "",
                        "function isCommonsJsOrAmdCall(node, parentNode) {",
                        "  if (node.callee.type !== \"Identifier\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (node.callee.name === \"require\") {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.callee.name === \"define\") {",
                        "    const args = getCallArguments(node);",
                        "    return (",
                        "      parentNode.type === \"ExpressionStatement\" &&",
                        "      (args.length === 1 ||",
                        "        (args.length === 2 && args[0].type === \"ArrayExpression\") ||",
                        "        (args.length === 3 &&",
                        "          isStringLiteral(args[0]) &&",
                        "          args[1].type === \"ArrayExpression\"))",
                        "    );",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "module.exports = { printCallExpression };"
                    ]
                },
                "class.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  isNonEmptyArray,",
                        "  createGroupIdMapper,",
                        "} = require(\"../../common/util.js\");",
                        "const {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "} = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { join, line, hardline, softline, group, indent, ifBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const { hasComment, CommentCheckFlags } = require(\"../utils/index.js\");",
                        "const { getTypeParametersGroupId } = require(\"./type-parameters.js\");",
                        "const { printMethod } = require(\"./function.js\");",
                        "const { printOptionalToken, printTypeAnnotation } = require(\"./misc.js\");",
                        "const { printPropertyKey } = require(\"./property.js\");",
                        "const { printAssignment } = require(\"./assignment.js\");",
                        "const { printClassMemberDecorators } = require(\"./decorators.js\");",
                        "",
                        "function printClass(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "",
                        "  if (node.abstract) {",
                        "    parts.push(\"abstract \");",
                        "  }",
                        "",
                        "  parts.push(\"class\");",
                        "",
                        "  // Keep old behaviour of extends in same line",
                        "  // If there is only on extends and there are not comments",
                        "  const groupMode =",
                        "    (node.id && hasComment(node.id, CommentCheckFlags.Trailing)) ||",
                        "    (node.superClass && hasComment(node.superClass)) ||",
                        "    isNonEmptyArray(node.extends) || // DeclareClass",
                        "    isNonEmptyArray(node.mixins) ||",
                        "    isNonEmptyArray(node.implements);",
                        "",
                        "  const partsGroup = [];",
                        "  const extendsParts = [];",
                        "",
                        "  if (node.id) {",
                        "    partsGroup.push(\" \", print(\"id\"));",
                        "  }",
                        "",
                        "  partsGroup.push(print(\"typeParameters\"));",
                        "",
                        "  if (node.superClass) {",
                        "    const printed = [",
                        "      \"extends \",",
                        "      printSuperClass(path, options, print),",
                        "      print(\"superTypeParameters\"),",
                        "    ];",
                        "    const printedWithComments = path.call(",
                        "      (superClass) => printComments(superClass, printed, options),",
                        "      \"superClass\"",
                        "    );",
                        "    if (groupMode) {",
                        "      extendsParts.push(line, group(printedWithComments));",
                        "    } else {",
                        "      extendsParts.push(\" \", printedWithComments);",
                        "    }",
                        "  } else {",
                        "    extendsParts.push(printList(path, options, print, \"extends\"));",
                        "  }",
                        "",
                        "  extendsParts.push(",
                        "    printList(path, options, print, \"mixins\"),",
                        "    printList(path, options, print, \"implements\")",
                        "  );",
                        "",
                        "  if (groupMode) {",
                        "    let printedPartsGroup;",
                        "    if (shouldIndentOnlyHeritageClauses(node)) {",
                        "      printedPartsGroup = [...partsGroup, indent(extendsParts)];",
                        "    } else {",
                        "      printedPartsGroup = indent([...partsGroup, extendsParts]);",
                        "    }",
                        "    parts.push(group(printedPartsGroup, { id: getHeritageGroupId(node) }));",
                        "  } else {",
                        "    parts.push(...partsGroup, ...extendsParts);",
                        "  }",
                        "",
                        "  parts.push(\" \", print(\"body\"));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "const getHeritageGroupId = createGroupIdMapper(\"heritageGroup\");",
                        "",
                        "function printHardlineAfterHeritage(node) {",
                        "  return ifBreak(hardline, \"\", { groupId: getHeritageGroupId(node) });",
                        "}",
                        "",
                        "function hasMultipleHeritage(node) {",
                        "  return (",
                        "    [\"superClass\", \"extends\", \"mixins\", \"implements\"].filter((key) =>",
                        "      Boolean(node[key])",
                        "    ).length > 1",
                        "  );",
                        "}",
                        "",
                        "function shouldIndentOnlyHeritageClauses(node) {",
                        "  return (",
                        "    node.typeParameters &&",
                        "    !hasComment(",
                        "      node.typeParameters,",
                        "      CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "    ) &&",
                        "    !hasMultipleHeritage(node)",
                        "  );",
                        "}",
                        "",
                        "function printList(path, options, print, listName) {",
                        "  const node = path.getValue();",
                        "  if (!isNonEmptyArray(node[listName])) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const printedLeadingComments = printDanglingComments(",
                        "    path,",
                        "    options,",
                        "    /* sameIndent */ true,",
                        "    ({ marker }) => marker === listName",
                        "  );",
                        "  return [",
                        "    shouldIndentOnlyHeritageClauses(node)",
                        "      ? ifBreak(\" \", line, {",
                        "          groupId: getTypeParametersGroupId(node.typeParameters),",
                        "        })",
                        "      : line,",
                        "    printedLeadingComments,",
                        "    printedLeadingComments && hardline,",
                        "    listName,",
                        "    group(indent([line, join([\",\", line], path.map(print, listName))])),",
                        "  ];",
                        "}",
                        "",
                        "function printSuperClass(path, options, print) {",
                        "  const printed = print(\"superClass\");",
                        "  const parent = path.getParentNode();",
                        "  if (parent.type === \"AssignmentExpression\") {",
                        "    return group(",
                        "      ifBreak([\"(\", indent([softline, printed]), softline, \")\"], printed)",
                        "    );",
                        "  }",
                        "  return printed;",
                        "}",
                        "",
                        "function printClassMethod(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  if (isNonEmptyArray(node.decorators)) {",
                        "    parts.push(printClassMemberDecorators(path, options, print));",
                        "  }",
                        "  if (node.accessibility) {",
                        "    parts.push(node.accessibility + \" \");",
                        "  }",
                        "  // \"readonly\" and \"declare\" are supported by only \"babel-ts\"",
                        "  // https://github.com/prettier/prettier/issues/9760",
                        "  if (node.readonly) {",
                        "    parts.push(\"readonly \");",
                        "  }",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "",
                        "  if (node.static) {",
                        "    parts.push(\"static \");",
                        "  }",
                        "  if (node.type === \"TSAbstractMethodDefinition\" || node.abstract) {",
                        "    parts.push(\"abstract \");",
                        "  }",
                        "  if (node.override) {",
                        "    parts.push(\"override \");",
                        "  }",
                        "",
                        "  parts.push(printMethod(path, options, print));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printClassProperty(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "",
                        "  if (isNonEmptyArray(node.decorators)) {",
                        "    parts.push(printClassMemberDecorators(path, options, print));",
                        "  }",
                        "  if (node.accessibility) {",
                        "    parts.push(node.accessibility + \" \");",
                        "  }",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "  if (node.static) {",
                        "    parts.push(\"static \");",
                        "  }",
                        "  if (node.type === \"TSAbstractPropertyDefinition\" || node.abstract) {",
                        "    parts.push(\"abstract \");",
                        "  }",
                        "  if (node.override) {",
                        "    parts.push(\"override \");",
                        "  }",
                        "  if (node.readonly) {",
                        "    parts.push(\"readonly \");",
                        "  }",
                        "  if (node.variance) {",
                        "    parts.push(print(\"variance\"));",
                        "  }",
                        "  parts.push(",
                        "    printPropertyKey(path, options, print),",
                        "    printOptionalToken(path),",
                        "    printTypeAnnotation(path, options, print)",
                        "  );",
                        "",
                        "  return [printAssignment(path, options, print, parts, \" =\", \"value\"), semi];",
                        "}",
                        "",
                        "module.exports = {",
                        "  printClass,",
                        "  printClassMethod,",
                        "  printClassProperty,",
                        "  printHardlineAfterHeritage,",
                        "};"
                    ]
                },
                "comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { hasNewline } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { join, hardline },",
                        "  utils: { replaceTextEndOfLine },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "const { isLineComment } = require(\"../utils/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const isBlockComment = require(\"../utils/is-block-comment.js\");",
                        "",
                        "function printComment(commentPath, options) {",
                        "  const comment = commentPath.getValue();",
                        "",
                        "  if (isLineComment(comment)) {",
                        "    // Supports `//`, `#!`, `<!--`, and `-->`",
                        "    return options.originalText",
                        "      .slice(locStart(comment), locEnd(comment))",
                        "      .trimEnd();",
                        "  }",
                        "",
                        "  if (isBlockComment(comment)) {",
                        "    if (isIndentableBlockComment(comment)) {",
                        "      const printed = printIndentableBlockComment(comment);",
                        "      // We need to prevent an edge case of a previous trailing comment",
                        "      // printed as a `lineSuffix` which causes the comments to be",
                        "      // interleaved. See https://github.com/prettier/prettier/issues/4412",
                        "      if (",
                        "        comment.trailing &&",
                        "        !hasNewline(options.originalText, locStart(comment), {",
                        "          backwards: true,",
                        "        })",
                        "      ) {",
                        "        return [hardline, printed];",
                        "      }",
                        "      return printed;",
                        "    }",
                        "",
                        "    const commentEnd = locEnd(comment);",
                        "    const isInsideFlowComment =",
                        "      options.originalText.slice(commentEnd - 3, commentEnd) === \"*-/\";",
                        "    return [",
                        "      \"/*\",",
                        "      replaceTextEndOfLine(comment.value),",
                        "      isInsideFlowComment ? \"*-/\" : \"*/\",",
                        "    ];",
                        "  }",
                        "",
                        "  /* istanbul ignore next */",
                        "  throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                        "}",
                        "",
                        "function isIndentableBlockComment(comment) {",
                        "  // If the comment has multiple lines and every line starts with a star",
                        "  // we can fix the indentation of each line. The stars in the `/*` and",
                        "  // `*/` delimiters are not included in the comment value, so add them",
                        "  // back first.",
                        "  const lines = `*${comment.value}*`.split(\"\\n\");",
                        "  return lines.length > 1 && lines.every((line) => line.trim()[0] === \"*\");",
                        "}",
                        "",
                        "function printIndentableBlockComment(comment) {",
                        "  const lines = comment.value.split(\"\\n\");",
                        "",
                        "  return [",
                        "    \"/*\",",
                        "    join(",
                        "      hardline,",
                        "      lines.map((line, index) =>",
                        "        index === 0",
                        "          ? line.trimEnd()",
                        "          : \" \" + (index < lines.length - 1 ? line.trim() : line.trimStart())",
                        "      )",
                        "    ),",
                        "    \"*/\",",
                        "  ];",
                        "}",
                        "",
                        "module.exports = { printComment };"
                    ]
                },
                "decorators.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray, hasNewline } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { line, hardline, join, breakParent, group },",
                        "} = require(\"../../document/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const { getParentExportDeclaration } = require(\"../utils/index.js\");",
                        "",
                        "function printClassMemberDecorators(path, options, print) {",
                        "  const node = path.getValue();",
                        "  return group([",
                        "    join(line, path.map(print, \"decorators\")),",
                        "    hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line,",
                        "  ]);",
                        "}",
                        "",
                        "function printDecoratorsBeforeExport(path, options, print) {",
                        "  // Export declarations are responsible for printing any decorators",
                        "  // that logically apply to node.declaration.",
                        "  return [",
                        "    join(hardline, path.map(print, \"declaration\", \"decorators\")),",
                        "    hardline,",
                        "  ];",
                        "}",
                        "",
                        "function printDecorators(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const { decorators } = node;",
                        "",
                        "  if (",
                        "    !isNonEmptyArray(decorators) ||",
                        "    // If the parent node is an export declaration and the decorator",
                        "    // was written before the export, the export will be responsible",
                        "    // for printing the decorators.",
                        "    hasDecoratorsBeforeExport(path.getParentNode())",
                        "  ) {",
                        "    return;",
                        "  }",
                        "",
                        "  const shouldBreak =",
                        "    node.type === \"ClassExpression\" ||",
                        "    node.type === \"ClassDeclaration\" ||",
                        "    hasNewlineBetweenOrAfterDecorators(node, options);",
                        "",
                        "  return [",
                        "    getParentExportDeclaration(path)",
                        "      ? hardline",
                        "      : shouldBreak",
                        "      ? breakParent",
                        "      : \"\",",
                        "    join(line, path.map(print, \"decorators\")),",
                        "    line,",
                        "  ];",
                        "}",
                        "",
                        "function hasNewlineBetweenOrAfterDecorators(node, options) {",
                        "  return node.decorators.some((decorator) =>",
                        "    hasNewline(options.originalText, locEnd(decorator))",
                        "  );",
                        "}",
                        "",
                        "function hasDecoratorsBeforeExport(node) {",
                        "  if (",
                        "    node.type !== \"ExportDefaultDeclaration\" &&",
                        "    node.type !== \"ExportNamedDeclaration\" &&",
                        "    node.type !== \"DeclareExportDeclaration\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const decorators = node.declaration && node.declaration.decorators;",
                        "",
                        "  return (",
                        "    isNonEmptyArray(decorators) &&",
                        "    locStart(node, { ignoreDecorators: true }) > locStart(decorators[0])",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  printDecorators,",
                        "  printClassMemberDecorators,",
                        "  printDecoratorsBeforeExport,",
                        "  hasDecoratorsBeforeExport,",
                        "};"
                    ]
                },
                "flow.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "const assert = require(\"assert\");",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const { printString, printNumber } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { hardline, softline, group, indent },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  getParentExportDeclaration,",
                        "  isFunctionNotation,",
                        "  isGetterOrSetter,",
                        "  rawText,",
                        "  shouldPrintComma,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const { printClass } = require(\"./class.js\");",
                        "const {",
                        "  printOpaqueType,",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printTupleType,",
                        "  printIndexedAccessType,",
                        "} = require(\"./type-annotation.js\");",
                        "const { printInterface } = require(\"./interface.js\");",
                        "const {",
                        "  printTypeParameter,",
                        "  printTypeParameters,",
                        "} = require(\"./type-parameters.js\");",
                        "const {",
                        "  printExportDeclaration,",
                        "  printExportAllDeclaration,",
                        "} = require(\"./module.js\");",
                        "const { printArrayItems } = require(\"./array.js\");",
                        "const { printObject } = require(\"./object.js\");",
                        "const { printPropertyKey } = require(\"./property.js\");",
                        "const {",
                        "  printOptionalToken,",
                        "  printTypeAnnotation,",
                        "  printRestSpread,",
                        "} = require(\"./misc.js\");",
                        "",
                        "function printFlow(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "  switch (node.type) {",
                        "    case \"DeclareClass\":",
                        "      return printFlowDeclaration(path, printClass(path, options, print));",
                        "    case \"DeclareFunction\":",
                        "      return printFlowDeclaration(path, [",
                        "        \"function \",",
                        "        print(\"id\"),",
                        "        node.predicate ? \" \" : \"\",",
                        "        print(\"predicate\"),",
                        "        semi,",
                        "      ]);",
                        "    case \"DeclareModule\":",
                        "      return printFlowDeclaration(path, [",
                        "        \"module \",",
                        "        print(\"id\"),",
                        "        \" \",",
                        "        print(\"body\"),",
                        "      ]);",
                        "    case \"DeclareModuleExports\":",
                        "      return printFlowDeclaration(path, [",
                        "        \"module.exports\",",
                        "        \": \",",
                        "        print(\"typeAnnotation\"),",
                        "        semi,",
                        "      ]);",
                        "    case \"DeclareVariable\":",
                        "      return printFlowDeclaration(path, [\"var \", print(\"id\"), semi]);",
                        "    case \"DeclareOpaqueType\":",
                        "      return printFlowDeclaration(path, printOpaqueType(path, options, print));",
                        "    case \"DeclareInterface\":",
                        "      return printFlowDeclaration(path, printInterface(path, options, print));",
                        "    case \"DeclareTypeAlias\":",
                        "      return printFlowDeclaration(path, printTypeAlias(path, options, print));",
                        "    case \"DeclareExportDeclaration\":",
                        "      return printFlowDeclaration(",
                        "        path,",
                        "        printExportDeclaration(path, options, print)",
                        "      );",
                        "    case \"DeclareExportAllDeclaration\":",
                        "      return printFlowDeclaration(",
                        "        path,",
                        "        printExportAllDeclaration(path, options, print)",
                        "      );",
                        "    case \"OpaqueType\":",
                        "      return printOpaqueType(path, options, print);",
                        "    case \"TypeAlias\":",
                        "      return printTypeAlias(path, options, print);",
                        "    case \"IntersectionTypeAnnotation\":",
                        "      return printIntersectionType(path, options, print);",
                        "    case \"UnionTypeAnnotation\":",
                        "      return printUnionType(path, options, print);",
                        "    case \"FunctionTypeAnnotation\":",
                        "      return printFunctionType(path, options, print);",
                        "    case \"TupleTypeAnnotation\":",
                        "      return printTupleType(path, options, print);",
                        "    case \"GenericTypeAnnotation\":",
                        "      return [",
                        "        print(\"id\"),",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"IndexedAccessType\":",
                        "    case \"OptionalIndexedAccessType\":",
                        "      return printIndexedAccessType(path, options, print);",
                        "    // Type Annotations for Facebook Flow, typically stripped out or",
                        "    // transformed away before printing.",
                        "    case \"TypeAnnotation\":",
                        "      return print(\"typeAnnotation\");",
                        "    case \"TypeParameter\":",
                        "      return printTypeParameter(path, options, print);",
                        "    case \"TypeofTypeAnnotation\":",
                        "      return [\"typeof \", print(\"argument\")];",
                        "    case \"ExistsTypeAnnotation\":",
                        "      return \"*\";",
                        "    case \"EmptyTypeAnnotation\":",
                        "      return \"empty\";",
                        "    case \"MixedTypeAnnotation\":",
                        "      return \"mixed\";",
                        "    case \"ArrayTypeAnnotation\":",
                        "      return [print(\"elementType\"), \"[]\"];",
                        "    case \"BooleanLiteralTypeAnnotation\":",
                        "      return String(node.value);",
                        "    case \"EnumDeclaration\":",
                        "      return [\"enum \", print(\"id\"), \" \", print(\"body\")];",
                        "    case \"EnumBooleanBody\":",
                        "    case \"EnumNumberBody\":",
                        "    case \"EnumStringBody\":",
                        "    case \"EnumSymbolBody\": {",
                        "      if (node.type === \"EnumSymbolBody\" || node.explicitType) {",
                        "        let type = null;",
                        "        switch (node.type) {",
                        "          case \"EnumBooleanBody\":",
                        "            type = \"boolean\";",
                        "            break;",
                        "          case \"EnumNumberBody\":",
                        "            type = \"number\";",
                        "            break;",
                        "          case \"EnumStringBody\":",
                        "            type = \"string\";",
                        "            break;",
                        "          case \"EnumSymbolBody\":",
                        "            type = \"symbol\";",
                        "            break;",
                        "        }",
                        "        parts.push(\"of \", type, \" \");",
                        "      }",
                        "      if (node.members.length === 0 && !node.hasUnknownMembers) {",
                        "        parts.push(",
                        "          group([\"{\", printDanglingComments(path, options), softline, \"}\"])",
                        "        );",
                        "      } else {",
                        "        const members =",
                        "          node.members.length > 0",
                        "            ? [",
                        "                hardline,",
                        "                printArrayItems(path, options, \"members\", print),",
                        "                node.hasUnknownMembers || shouldPrintComma(options) ? \",\" : \"\",",
                        "              ]",
                        "            : [];",
                        "",
                        "        parts.push(",
                        "          group([",
                        "            \"{\",",
                        "            indent([",
                        "              ...members,",
                        "              ...(node.hasUnknownMembers ? [hardline, \"...\"] : []),",
                        "            ]),",
                        "            printDanglingComments(path, options, /* sameIndent */ true),",
                        "            hardline,",
                        "            \"}\",",
                        "          ])",
                        "        );",
                        "      }",
                        "      return parts;",
                        "    }",
                        "    case \"EnumBooleanMember\":",
                        "    case \"EnumNumberMember\":",
                        "    case \"EnumStringMember\":",
                        "      return [",
                        "        print(\"id\"),",
                        "        \" = \",",
                        "        typeof node.init === \"object\" ? print(\"init\") : String(node.init),",
                        "      ];",
                        "    case \"EnumDefaultedMember\":",
                        "      return print(\"id\");",
                        "    case \"FunctionTypeParam\": {",
                        "      const name = node.name",
                        "        ? print(\"name\")",
                        "        : path.getParentNode().this === node",
                        "        ? \"this\"",
                        "        : \"\";",
                        "      return [",
                        "        name,",
                        "        printOptionalToken(path),",
                        "        name ? \": \" : \"\",",
                        "        print(\"typeAnnotation\"),",
                        "      ];",
                        "    }",
                        "",
                        "    case \"InterfaceDeclaration\":",
                        "    case \"InterfaceTypeAnnotation\":",
                        "      return printInterface(path, options, print);",
                        "    case \"ClassImplements\":",
                        "    case \"InterfaceExtends\":",
                        "      return [print(\"id\"), print(\"typeParameters\")];",
                        "    case \"NullableTypeAnnotation\":",
                        "      return [\"?\", print(\"typeAnnotation\")];",
                        "    case \"Variance\": {",
                        "      const { kind } = node;",
                        "      assert.ok(kind === \"plus\" || kind === \"minus\");",
                        "      return kind === \"plus\" ? \"+\" : \"-\";",
                        "    }",
                        "    case \"ObjectTypeCallProperty\":",
                        "      if (node.static) {",
                        "        parts.push(\"static \");",
                        "      }",
                        "",
                        "      parts.push(print(\"value\"));",
                        "",
                        "      return parts;",
                        "    case \"ObjectTypeIndexer\": {",
                        "      return [",
                        "        node.static ? \"static \" : \"\",",
                        "        node.variance ? print(\"variance\") : \"\",",
                        "        \"[\",",
                        "        print(\"id\"),",
                        "        node.id ? \": \" : \"\",",
                        "        print(\"key\"),",
                        "        \"]: \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    }",
                        "    case \"ObjectTypeProperty\": {",
                        "      let modifier = \"\";",
                        "",
                        "      if (node.proto) {",
                        "        modifier = \"proto \";",
                        "      } else if (node.static) {",
                        "        modifier = \"static \";",
                        "      }",
                        "",
                        "      return [",
                        "        modifier,",
                        "        isGetterOrSetter(node) ? node.kind + \" \" : \"\",",
                        "        node.variance ? print(\"variance\") : \"\",",
                        "        printPropertyKey(path, options, print),",
                        "        printOptionalToken(path),",
                        "        isFunctionNotation(node) ? \"\" : \": \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    }",
                        "    case \"ObjectTypeAnnotation\":",
                        "      return printObject(path, options, print);",
                        "    case \"ObjectTypeInternalSlot\":",
                        "      return [",
                        "        node.static ? \"static \" : \"\",",
                        "        \"[[\",",
                        "        print(\"id\"),",
                        "        \"]]\",",
                        "        printOptionalToken(path),",
                        "        node.method ? \"\" : \": \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    // Same as `RestElement`",
                        "    case \"ObjectTypeSpreadProperty\":",
                        "      return printRestSpread(path, options, print);",
                        "    case \"QualifiedTypeofIdentifier\":",
                        "    case \"QualifiedTypeIdentifier\":",
                        "      return [print(\"qualification\"), \".\", print(\"id\")];",
                        "    case \"StringLiteralTypeAnnotation\":",
                        "      return printString(rawText(node), options);",
                        "    case \"NumberLiteralTypeAnnotation\":",
                        "      assert.strictEqual(typeof node.value, \"number\");",
                        "    // fall through",
                        "    case \"BigIntLiteralTypeAnnotation\":",
                        "      if (node.extra) {",
                        "        return printNumber(node.extra.raw);",
                        "      }",
                        "      return printNumber(node.raw);",
                        "    case \"TypeCastExpression\": {",
                        "      return [",
                        "        \"(\",",
                        "        print(\"expression\"),",
                        "        printTypeAnnotation(path, options, print),",
                        "        \")\",",
                        "      ];",
                        "    }",
                        "",
                        "    case \"TypeParameterDeclaration\":",
                        "    case \"TypeParameterInstantiation\": {",
                        "      const printed = printTypeParameters(path, options, print, \"params\");",
                        "",
                        "      if (options.parser === \"flow\") {",
                        "        const start = locStart(node);",
                        "        const end = locEnd(node);",
                        "        const commentStartIndex = options.originalText.lastIndexOf(\"/*\", start);",
                        "        const commentEndIndex = options.originalText.indexOf(\"*/\", end);",
                        "        if (commentStartIndex !== -1 && commentEndIndex !== -1) {",
                        "          const comment = options.originalText",
                        "            .slice(commentStartIndex + 2, commentEndIndex)",
                        "            .trim();",
                        "          if (",
                        "            comment.startsWith(\"::\") &&",
                        "            !comment.includes(\"/*\") &&",
                        "            !comment.includes(\"*/\")",
                        "          ) {",
                        "            return [\"/*:: \", printed, \" */\"];",
                        "          }",
                        "        }",
                        "      }",
                        "",
                        "      return printed;",
                        "    }",
                        "",
                        "    case \"InferredPredicate\":",
                        "      return \"%checks\";",
                        "    // Unhandled types below. If encountered, nodes of these types should",
                        "    // be either left alone or desugared into AST types that are fully",
                        "    // supported by the pretty-printer.",
                        "    case \"DeclaredPredicate\":",
                        "      return [\"%checks(\", print(\"value\"), \")\"];",
                        "    case \"AnyTypeAnnotation\":",
                        "      return \"any\";",
                        "    case \"BooleanTypeAnnotation\":",
                        "      return \"boolean\";",
                        "    case \"BigIntTypeAnnotation\":",
                        "      return \"bigint\";",
                        "    case \"NullLiteralTypeAnnotation\":",
                        "      return \"null\";",
                        "    case \"NumberTypeAnnotation\":",
                        "      return \"number\";",
                        "    case \"SymbolTypeAnnotation\":",
                        "      return \"symbol\";",
                        "    case \"StringTypeAnnotation\":",
                        "      return \"string\";",
                        "    case \"VoidTypeAnnotation\":",
                        "      return \"void\";",
                        "    case \"ThisTypeAnnotation\":",
                        "      return \"this\";",
                        "    // These types are unprintable because they serve as abstract",
                        "    // supertypes for other (printable) types.",
                        "    case \"Node\":",
                        "    case \"Printable\":",
                        "    case \"SourceLocation\":",
                        "    case \"Position\":",
                        "    case \"Statement\":",
                        "    case \"Function\":",
                        "    case \"Pattern\":",
                        "    case \"Expression\":",
                        "    case \"Declaration\":",
                        "    case \"Specifier\":",
                        "    case \"NamedSpecifier\":",
                        "    case \"Comment\":",
                        "    case \"MemberTypeAnnotation\": // Flow",
                        "    case \"Type\":",
                        "      /* istanbul ignore next */",
                        "      throw new Error(\"unprintable type: \" + JSON.stringify(node.type));",
                        "  }",
                        "}",
                        "",
                        "function printFlowDeclaration(path, printed) {",
                        "  const parentExportDecl = getParentExportDeclaration(path);",
                        "",
                        "  if (parentExportDecl) {",
                        "    assert.strictEqual(parentExportDecl.type, \"DeclareExportDeclaration\");",
                        "    return printed;",
                        "  }",
                        "",
                        "  // If the parent node has type DeclareExportDeclaration, then it",
                        "  // will be responsible for printing the \"declare\" token. Otherwise",
                        "  // it needs to be printed with this non-exported declaration node.",
                        "  return [\"declare \", printed];",
                        "}",
                        "",
                        "module.exports = { printFlow };"
                    ]
                },
                "function-parameters.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { getNextNonSpaceNonCommentCharacter } = require(\"../../common/util.js\");",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { line, hardline, softline, group, indent, ifBreak },",
                        "  utils: { removeLines, willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  getFunctionParameters,",
                        "  iterateFunctionParametersPath,",
                        "  isSimpleType,",
                        "  isTestCall,",
                        "  isTypeAnnotationAFunction,",
                        "  isObjectType,",
                        "  isObjectTypePropertyAFunction,",
                        "  hasRestParameter,",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { locEnd } = require(\"../loc.js\");",
                        "const { ArgExpansionBailout } = require(\"../../common/errors.js\");",
                        "const { printFunctionTypeParameters } = require(\"./misc.js\");",
                        "",
                        "function printFunctionParameters(",
                        "  path,",
                        "  print,",
                        "  options,",
                        "  expandArg,",
                        "  printTypeParams",
                        ") {",
                        "  const functionNode = path.getValue();",
                        "  const parameters = getFunctionParameters(functionNode);",
                        "  const typeParams = printTypeParams",
                        "    ? printFunctionTypeParameters(path, options, print)",
                        "    : \"\";",
                        "",
                        "  if (parameters.length === 0) {",
                        "    return [",
                        "      typeParams,",
                        "      \"(\",",
                        "      printDanglingComments(",
                        "        path,",
                        "        options,",
                        "        /* sameIndent */ true,",
                        "        (comment) =>",
                        "          getNextNonSpaceNonCommentCharacter(",
                        "            options.originalText,",
                        "            comment,",
                        "            locEnd",
                        "          ) === \")\"",
                        "      ),",
                        "      \")\",",
                        "    ];",
                        "  }",
                        "",
                        "  const parent = path.getParentNode();",
                        "  const isParametersInTestCall = isTestCall(parent);",
                        "  const shouldHugParameters = shouldHugFunctionParameters(functionNode);",
                        "  const printed = [];",
                        "  iterateFunctionParametersPath(path, (parameterPath, index) => {",
                        "    const isLastParameter = index === parameters.length - 1;",
                        "    if (isLastParameter && functionNode.rest) {",
                        "      printed.push(\"...\");",
                        "    }",
                        "    printed.push(print());",
                        "    if (isLastParameter) {",
                        "      return;",
                        "    }",
                        "    printed.push(\",\");",
                        "    if (isParametersInTestCall || shouldHugParameters) {",
                        "      printed.push(\" \");",
                        "    } else if (isNextLineEmpty(parameters[index], options)) {",
                        "      printed.push(hardline, hardline);",
                        "    } else {",
                        "      printed.push(line);",
                        "    }",
                        "  });",
                        "",
                        "  // If the parent is a call with the first/last argument expansion and this is the",
                        "  // params of the first/last argument, we don't want the arguments to break and instead",
                        "  // want the whole expression to be on a new line.",
                        "  //",
                        "  // Good:                 Bad:",
                        "  //   verylongcall(         verylongcall((",
                        "  //     (a, b) => {           a,",
                        "  //     }                     b,",
                        "  //   )                     ) => {",
                        "  //                         })",
                        "  if (expandArg) {",
                        "    if (willBreak(typeParams) || willBreak(printed)) {",
                        "      // Removing lines in this case leads to broken or ugly output",
                        "      throw new ArgExpansionBailout();",
                        "    }",
                        "    return group([removeLines(typeParams), \"(\", removeLines(printed), \")\"]);",
                        "  }",
                        "",
                        "  // Single object destructuring should hug",
                        "  //",
                        "  // function({",
                        "  //   a,",
                        "  //   b,",
                        "  //   c",
                        "  // }) {}",
                        "  const hasNotParameterDecorator = parameters.every((node) => !node.decorators);",
                        "  if (shouldHugParameters && hasNotParameterDecorator) {",
                        "    return [typeParams, \"(\", ...printed, \")\"];",
                        "  }",
                        "",
                        "  // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`",
                        "  if (isParametersInTestCall) {",
                        "    return [typeParams, \"(\", ...printed, \")\"];",
                        "  }",
                        "",
                        "  const isFlowShorthandWithOneArg =",
                        "    (isObjectTypePropertyAFunction(parent) ||",
                        "      isTypeAnnotationAFunction(parent) ||",
                        "      parent.type === \"TypeAlias\" ||",
                        "      parent.type === \"UnionTypeAnnotation\" ||",
                        "      parent.type === \"TSUnionType\" ||",
                        "      parent.type === \"IntersectionTypeAnnotation\" ||",
                        "      (parent.type === \"FunctionTypeAnnotation\" &&",
                        "        parent.returnType === functionNode)) &&",
                        "    parameters.length === 1 &&",
                        "    parameters[0].name === null &&",
                        "    // `type q = (this: string) => void;`",
                        "    functionNode.this !== parameters[0] &&",
                        "    parameters[0].typeAnnotation &&",
                        "    functionNode.typeParameters === null &&",
                        "    isSimpleType(parameters[0].typeAnnotation) &&",
                        "    !functionNode.rest;",
                        "",
                        "  if (isFlowShorthandWithOneArg) {",
                        "    if (options.arrowParens === \"always\") {",
                        "      return [\"(\", ...printed, \")\"];",
                        "    }",
                        "    return printed;",
                        "  }",
                        "",
                        "  return [",
                        "    typeParams,",
                        "    \"(\",",
                        "    indent([softline, ...printed]),",
                        "    ifBreak(",
                        "      !hasRestParameter(functionNode) && shouldPrintComma(options, \"all\")",
                        "        ? \",\"",
                        "        : \"\"",
                        "    ),",
                        "    softline,",
                        "    \")\",",
                        "  ];",
                        "}",
                        "",
                        "function shouldHugFunctionParameters(node) {",
                        "  if (!node) {",
                        "    return false;",
                        "  }",
                        "  const parameters = getFunctionParameters(node);",
                        "  if (parameters.length !== 1) {",
                        "    return false;",
                        "  }",
                        "  const [parameter] = parameters;",
                        "  return (",
                        "    !hasComment(parameter) &&",
                        "    (parameter.type === \"ObjectPattern\" ||",
                        "      parameter.type === \"ArrayPattern\" ||",
                        "      (parameter.type === \"Identifier\" &&",
                        "        parameter.typeAnnotation &&",
                        "        (parameter.typeAnnotation.type === \"TypeAnnotation\" ||",
                        "          parameter.typeAnnotation.type === \"TSTypeAnnotation\") &&",
                        "        isObjectType(parameter.typeAnnotation.typeAnnotation)) ||",
                        "      (parameter.type === \"FunctionTypeParam\" &&",
                        "        isObjectType(parameter.typeAnnotation)) ||",
                        "      (parameter.type === \"AssignmentPattern\" &&",
                        "        (parameter.left.type === \"ObjectPattern\" ||",
                        "          parameter.left.type === \"ArrayPattern\") &&",
                        "        (parameter.right.type === \"Identifier\" ||",
                        "          (parameter.right.type === \"ObjectExpression\" &&",
                        "            parameter.right.properties.length === 0) ||",
                        "          (parameter.right.type === \"ArrayExpression\" &&",
                        "            parameter.right.elements.length === 0))))",
                        "  );",
                        "}",
                        "",
                        "function getReturnTypeNode(functionNode) {",
                        "  let returnTypeNode;",
                        "  if (functionNode.returnType) {",
                        "    returnTypeNode = functionNode.returnType;",
                        "    if (returnTypeNode.typeAnnotation) {",
                        "      returnTypeNode = returnTypeNode.typeAnnotation;",
                        "    }",
                        "  } else if (functionNode.typeAnnotation) {",
                        "    returnTypeNode = functionNode.typeAnnotation;",
                        "  }",
                        "  return returnTypeNode;",
                        "}",
                        "",
                        "// When parameters are grouped, the return type annotation breaks first.",
                        "function shouldGroupFunctionParameters(functionNode, returnTypeDoc) {",
                        "  const returnTypeNode = getReturnTypeNode(functionNode);",
                        "  if (!returnTypeNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const typeParameters =",
                        "    functionNode.typeParameters && functionNode.typeParameters.params;",
                        "  if (typeParameters) {",
                        "    if (typeParameters.length > 1) {",
                        "      return false;",
                        "    }",
                        "    if (typeParameters.length === 1) {",
                        "      const typeParameter = typeParameters[0];",
                        "      if (typeParameter.constraint || typeParameter.default) {",
                        "        return false;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return (",
                        "    getFunctionParameters(functionNode).length === 1 &&",
                        "    (isObjectType(returnTypeNode) || willBreak(returnTypeDoc))",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  printFunctionParameters,",
                        "  shouldHugFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "};"
                    ]
                },
                "function.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/** @typedef {import(\"../../document/doc-builders\").Doc} Doc */",
                        "",
                        "const assert = require(\"assert\");",
                        "const {",
                        "  printDanglingComments,",
                        "  printCommentsSeparately,",
                        "} = require(\"../../main/comments.js\");",
                        "const getLast = require(\"../../utils/get-last.js\");",
                        "const {",
                        "  getNextNonSpaceNonCommentCharacterIndex,",
                        "} = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: {",
                        "    line,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    ifBreak,",
                        "    hardline,",
                        "    join,",
                        "    indentIfBreak,",
                        "  },",
                        "  utils: { removeLines, willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const { ArgExpansionBailout } = require(\"../../common/errors.js\");",
                        "const {",
                        "  getFunctionParameters,",
                        "  hasLeadingOwnLineComment,",
                        "  isFlowAnnotationComment,",
                        "  isJsxNode,",
                        "  isTemplateOnItsOwnLine,",
                        "  shouldPrintComma,",
                        "  startsWithNoLookaheadToken,",
                        "  isBinaryish,",
                        "  isLineComment,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  isCallLikeExpression,",
                        "  isCallExpression,",
                        "  getCallArguments,",
                        "  hasNakedLeftSide,",
                        "  getLeftSide,",
                        "} = require(\"../utils/index.js\");",
                        "const { locEnd } = require(\"../loc.js\");",
                        "const {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} = require(\"./function-parameters.js\");",
                        "const { printPropertyKey } = require(\"./property.js\");",
                        "const { printFunctionTypeParameters } = require(\"./misc.js\");",
                        "",
                        "function printFunction(path, print, options, args) {",
                        "  const node = path.getValue();",
                        "",
                        "  let expandArg = false;",
                        "  if (",
                        "    (node.type === \"FunctionDeclaration\" ||",
                        "      node.type === \"FunctionExpression\") &&",
                        "    args &&",
                        "    args.expandLastArg",
                        "  ) {",
                        "    const parent = path.getParentNode();",
                        "    if (isCallExpression(parent) && getCallArguments(parent).length > 1) {",
                        "      expandArg = true;",
                        "    }",
                        "  }",
                        "",
                        "  const parts = [];",
                        "",
                        "  // For TypeScript the TSDeclareFunction node shares the AST",
                        "  // structure with FunctionDeclaration",
                        "  if (node.type === \"TSDeclareFunction\" && node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "",
                        "  if (node.async) {",
                        "    parts.push(\"async \");",
                        "  }",
                        "",
                        "  if (node.generator) {",
                        "    parts.push(\"function* \");",
                        "  } else {",
                        "    parts.push(\"function \");",
                        "  }",
                        "",
                        "  if (node.id) {",
                        "    parts.push(print(\"id\"));",
                        "  }",
                        "",
                        "  const parametersDoc = printFunctionParameters(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    expandArg",
                        "  );",
                        "  const returnTypeDoc = printReturnType(path, print, options);",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "",
                        "  parts.push(",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    group([",
                        "      shouldGroupParameters ? group(parametersDoc) : parametersDoc,",
                        "      returnTypeDoc,",
                        "    ]),",
                        "    node.body ? \" \" : \"\",",
                        "    print(\"body\")",
                        "  );",
                        "",
                        "  if (options.semi && (node.declare || !node.body)) {",
                        "    parts.push(\";\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printMethod(path, options, print) {",
                        "  const node = path.getNode();",
                        "  const { kind } = node;",
                        "  const value = node.value || node;",
                        "  const parts = [];",
                        "",
                        "  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {",
                        "    if (value.async) {",
                        "      parts.push(\"async \");",
                        "    }",
                        "  } else {",
                        "    assert.ok(kind === \"get\" || kind === \"set\");",
                        "",
                        "    parts.push(kind, \" \");",
                        "  }",
                        "",
                        "  // A `getter`/`setter` can't be a generator, but it's recoverable",
                        "  if (value.generator) {",
                        "    parts.push(\"*\");",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printPropertyKey(path, options, print),",
                        "    node.optional || node.key.optional ? \"?\" : \"\"",
                        "  );",
                        "",
                        "  if (node === value) {",
                        "    parts.push(printMethodInternal(path, options, print));",
                        "  } else if (value.type === \"FunctionExpression\") {",
                        "    parts.push(",
                        "      path.call((path) => printMethodInternal(path, options, print), \"value\")",
                        "    );",
                        "  } else {",
                        "    parts.push(print(\"value\"));",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printMethodInternal(path, options, print) {",
                        "  const node = path.getNode();",
                        "  const parametersDoc = printFunctionParameters(path, print, options);",
                        "  const returnTypeDoc = printReturnType(path, print, options);",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "  const parts = [",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    group([",
                        "      shouldGroupParameters ? group(parametersDoc) : parametersDoc,",
                        "      returnTypeDoc,",
                        "    ]),",
                        "  ];",
                        "",
                        "  if (node.body) {",
                        "    parts.push(\" \", print(\"body\"));",
                        "  } else {",
                        "    parts.push(options.semi ? \";\" : \"\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrowFunctionSignature(path, options, print, args) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  if (node.async) {",
                        "    parts.push(\"async \");",
                        "  }",
                        "",
                        "  if (shouldPrintParamsWithoutParens(path, options)) {",
                        "    parts.push(print([\"params\", 0]));",
                        "  } else {",
                        "    const expandArg = args && (args.expandLastArg || args.expandFirstArg);",
                        "    let returnTypeDoc = printReturnType(path, print, options);",
                        "    if (expandArg) {",
                        "      if (willBreak(returnTypeDoc)) {",
                        "        throw new ArgExpansionBailout();",
                        "      }",
                        "      returnTypeDoc = group(removeLines(returnTypeDoc));",
                        "    }",
                        "    parts.push(",
                        "      group([",
                        "        printFunctionParameters(",
                        "          path,",
                        "          print,",
                        "          options,",
                        "          expandArg,",
                        "          /* printTypeParams */ true",
                        "        ),",
                        "        returnTypeDoc,",
                        "      ])",
                        "    );",
                        "  }",
                        "",
                        "  const dangling = printDanglingComments(",
                        "    path,",
                        "    options,",
                        "    /* sameIndent */ true,",
                        "    (comment) => {",
                        "      const nextCharacter = getNextNonSpaceNonCommentCharacterIndex(",
                        "        options.originalText,",
                        "        comment,",
                        "        locEnd",
                        "      );",
                        "      return (",
                        "        nextCharacter !== false &&",
                        "        options.originalText.slice(nextCharacter, nextCharacter + 2) === \"=>\"",
                        "      );",
                        "    }",
                        "  );",
                        "  if (dangling) {",
                        "    parts.push(\" \", dangling);",
                        "  }",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrowChain(",
                        "  path,",
                        "  args,",
                        "  signatures,",
                        "  shouldBreak,",
                        "  bodyDoc,",
                        "  tailNode",
                        ") {",
                        "  const name = path.getName();",
                        "  const parent = path.getParentNode();",
                        "  const isCallee = isCallLikeExpression(parent) && name === \"callee\";",
                        "  const isAssignmentRhs = Boolean(args && args.assignmentLayout);",
                        "  const shouldPutBodyOnSeparateLine =",
                        "    tailNode.body.type !== \"BlockStatement\" &&",
                        "    tailNode.body.type !== \"ObjectExpression\" &&",
                        "    tailNode.body.type !== \"SequenceExpression\";",
                        "  const shouldBreakBeforeChain =",
                        "    (isCallee && shouldPutBodyOnSeparateLine) ||",
                        "    (args && args.assignmentLayout === \"chain-tail-arrow-chain\");",
                        "",
                        "  const groupId = Symbol(\"arrow-chain\");",
                        "",
                        "  // We handle sequence expressions as the body of arrows specially,",
                        "  // so that the required parentheses end up on their own lines.",
                        "  if (tailNode.body.type === \"SequenceExpression\") {",
                        "    bodyDoc = group([\"(\", indent([softline, bodyDoc]), softline, \")\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    group(",
                        "      indent([",
                        "        isCallee || isAssignmentRhs ? softline : \"\",",
                        "        group(join([\" =>\", line], signatures), { shouldBreak }),",
                        "      ]),",
                        "      { id: groupId, shouldBreak: shouldBreakBeforeChain }",
                        "    ),",
                        "    \" =>\",",
                        "    indentIfBreak(",
                        "      shouldPutBodyOnSeparateLine ? indent([line, bodyDoc]) : [\" \", bodyDoc],",
                        "      { groupId }",
                        "    ),",
                        "    isCallee ? ifBreak(softline, \"\", { groupId }) : \"\",",
                        "  ]);",
                        "}",
                        "",
                        "function printArrowFunction(path, options, print, args) {",
                        "  let node = path.getValue();",
                        "  /** @type {Doc[]} */",
                        "  const signatures = [];",
                        "  const body = [];",
                        "  let chainShouldBreak = false;",
                        "",
                        "  (function rec() {",
                        "    const doc = printArrowFunctionSignature(path, options, print, args);",
                        "    if (signatures.length === 0) {",
                        "      signatures.push(doc);",
                        "    } else {",
                        "      const { leading, trailing } = printCommentsSeparately(path, options);",
                        "      signatures.push([leading, doc]);",
                        "      body.unshift(trailing);",
                        "    }",
                        "",
                        "    chainShouldBreak =",
                        "      chainShouldBreak ||",
                        "      // Always break the chain if:",
                        "      (node.returnType && getFunctionParameters(node).length > 0) ||",
                        "      node.typeParameters ||",
                        "      getFunctionParameters(node).some((param) => param.type !== \"Identifier\");",
                        "",
                        "    if (",
                        "      node.body.type !== \"ArrowFunctionExpression\" ||",
                        "      (args && args.expandLastArg)",
                        "    ) {",
                        "      body.unshift(print(\"body\", args));",
                        "    } else {",
                        "      node = node.body;",
                        "      path.call(rec, \"body\");",
                        "    }",
                        "  })();",
                        "",
                        "  if (signatures.length > 1) {",
                        "    return printArrowChain(",
                        "      path,",
                        "      args,",
                        "      signatures,",
                        "      chainShouldBreak,",
                        "      body,",
                        "      node",
                        "    );",
                        "  }",
                        "",
                        "  const parts = signatures;",
                        "  parts.push(\" =>\");",
                        "",
                        "  // We want to always keep these types of nodes on the same line",
                        "  // as the arrow.",
                        "  if (",
                        "    !hasLeadingOwnLineComment(options.originalText, node.body) &&",
                        "    (node.body.type === \"ArrayExpression\" ||",
                        "      node.body.type === \"ObjectExpression\" ||",
                        "      node.body.type === \"BlockStatement\" ||",
                        "      isJsxNode(node.body) ||",
                        "      isTemplateOnItsOwnLine(node.body, options.originalText) ||",
                        "      node.body.type === \"ArrowFunctionExpression\" ||",
                        "      node.body.type === \"DoExpression\")",
                        "  ) {",
                        "    return group([...parts, \" \", body]);",
                        "  }",
                        "",
                        "  // We handle sequence expressions as the body of arrows specially,",
                        "  // so that the required parentheses end up on their own lines.",
                        "  if (node.body.type === \"SequenceExpression\") {",
                        "    return group([",
                        "      ...parts,",
                        "      group([\" (\", indent([softline, body]), softline, \")\"]),",
                        "    ]);",
                        "  }",
                        "",
                        "  // if the arrow function is expanded as last argument, we are adding a",
                        "  // level of indentation and need to add a softline to align the closing )",
                        "  // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)",
                        "  // we should align the expression's closing } with the line with the opening {.",
                        "  const shouldAddSoftLine =",
                        "    ((args && args.expandLastArg) ||",
                        "      path.getParentNode().type === \"JSXExpressionContainer\") &&",
                        "    !hasComment(node);",
                        "",
                        "  const printTrailingComma =",
                        "    args && args.expandLastArg && shouldPrintComma(options, \"all\");",
                        "",
                        "  // In order to avoid confusion between",
                        "  // a => a ? a : a",
                        "  // a <= a ? a : a",
                        "  const shouldAddParens =",
                        "    node.body.type === \"ConditionalExpression\" &&",
                        "    !startsWithNoLookaheadToken(node.body, /* forbidFunctionAndClass */ false);",
                        "",
                        "  return group([",
                        "    ...parts,",
                        "    group([",
                        "      indent([",
                        "        line,",
                        "        shouldAddParens ? ifBreak(\"\", \"(\") : \"\",",
                        "        body,",
                        "        shouldAddParens ? ifBreak(\"\", \")\") : \"\",",
                        "      ]),",
                        "      shouldAddSoftLine",
                        "        ? [ifBreak(printTrailingComma ? \",\" : \"\"), softline]",
                        "        : \"\",",
                        "    ]),",
                        "  ]);",
                        "}",
                        "",
                        "function canPrintParamsWithoutParens(node) {",
                        "  const parameters = getFunctionParameters(node);",
                        "  return (",
                        "    parameters.length === 1 &&",
                        "    !node.typeParameters &&",
                        "    !hasComment(node, CommentCheckFlags.Dangling) &&",
                        "    parameters[0].type === \"Identifier\" &&",
                        "    !parameters[0].typeAnnotation &&",
                        "    !hasComment(parameters[0]) &&",
                        "    !parameters[0].optional &&",
                        "    !node.predicate &&",
                        "    !node.returnType",
                        "  );",
                        "}",
                        "",
                        "function shouldPrintParamsWithoutParens(path, options) {",
                        "  if (options.arrowParens === \"always\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (options.arrowParens === \"avoid\") {",
                        "    const node = path.getValue();",
                        "    return canPrintParamsWithoutParens(node);",
                        "  }",
                        "",
                        "  // Fallback default; should be unreachable",
                        "  /* istanbul ignore next */",
                        "  return false;",
                        "}",
                        "",
                        "/** @returns {Doc} */",
                        "function printReturnType(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const returnType = print(\"returnType\");",
                        "",
                        "  if (",
                        "    node.returnType &&",
                        "    isFlowAnnotationComment(options.originalText, node.returnType)",
                        "  ) {",
                        "    return [\" /*: \", returnType, \" */\"];",
                        "  }",
                        "",
                        "  const parts = [returnType];",
                        "",
                        "  // prepend colon to TypeScript type annotation",
                        "  if (node.returnType && node.returnType.typeAnnotation) {",
                        "    parts.unshift(\": \");",
                        "  }",
                        "",
                        "  if (node.predicate) {",
                        "    // The return type will already add the colon, but otherwise we",
                        "    // need to do it ourselves",
                        "    parts.push(node.returnType ? \" \" : \": \", print(\"predicate\"));",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "// `ReturnStatement` and `ThrowStatement`",
                        "function printReturnOrThrowArgument(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const parts = [];",
                        "",
                        "  if (node.argument) {",
                        "    if (returnArgumentHasLeadingComment(options, node.argument)) {",
                        "      parts.push([\" (\", indent([hardline, print(\"argument\")]), hardline, \")\"]);",
                        "    } else if (",
                        "      isBinaryish(node.argument) ||",
                        "      node.argument.type === \"SequenceExpression\"",
                        "    ) {",
                        "      parts.push(",
                        "        group([",
                        "          ifBreak(\" (\", \" \"),",
                        "          indent([softline, print(\"argument\")]),",
                        "          softline,",
                        "          ifBreak(\")\"),",
                        "        ])",
                        "      );",
                        "    } else {",
                        "      parts.push(\" \", print(\"argument\"));",
                        "    }",
                        "  }",
                        "",
                        "  const comments = getComments(node);",
                        "  const lastComment = getLast(comments);",
                        "  const isLastCommentLine = lastComment && isLineComment(lastComment);",
                        "",
                        "  if (isLastCommentLine) {",
                        "    parts.push(semi);",
                        "  }",
                        "",
                        "  if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    parts.push(",
                        "      \" \",",
                        "      printDanglingComments(path, options, /* sameIndent */ true)",
                        "    );",
                        "  }",
                        "",
                        "  if (!isLastCommentLine) {",
                        "    parts.push(semi);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printReturnStatement(path, options, print) {",
                        "  return [\"return\", printReturnOrThrowArgument(path, options, print)];",
                        "}",
                        "",
                        "function printThrowStatement(path, options, print) {",
                        "  return [\"throw\", printReturnOrThrowArgument(path, options, print)];",
                        "}",
                        "",
                        "// This recurses the return argument, looking for the first token",
                        "// (the leftmost leaf node) and, if it (or its parents) has any",
                        "// leadingComments, returns true (so it can be wrapped in parens).",
                        "function returnArgumentHasLeadingComment(options, argument) {",
                        "  if (hasLeadingOwnLineComment(options.originalText, argument)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (hasNakedLeftSide(argument)) {",
                        "    let leftMost = argument;",
                        "    let newLeftMost;",
                        "    while ((newLeftMost = getLeftSide(leftMost))) {",
                        "      leftMost = newLeftMost;",
                        "",
                        "      if (hasLeadingOwnLineComment(options.originalText, leftMost)) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printFunction,",
                        "  printArrowFunction,",
                        "  printMethod,",
                        "  printReturnStatement,",
                        "  printThrowStatement,",
                        "  printMethodInternal,",
                        "  shouldPrintParamsWithoutParens,",
                        "};"
                    ]
                },
                "html-binding.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { join, line, group, softline, indent },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "function printHtmlBinding(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (options.__onHtmlBindingRoot && path.getName() === null) {",
                        "    options.__onHtmlBindingRoot(node, options);",
                        "  }",
                        "",
                        "  if (node.type !== \"File\") {",
                        "    return;",
                        "  }",
                        "",
                        "  if (options.__isVueForBindingLeft) {",
                        "    return path.call(",
                        "      (functionDeclarationPath) => {",
                        "        const printed = join(",
                        "          [\",\", line],",
                        "          functionDeclarationPath.map(print, \"params\")",
                        "        );",
                        "",
                        "        const { params } = functionDeclarationPath.getValue();",
                        "        if (params.length === 1) {",
                        "          return printed;",
                        "        }",
                        "",
                        "        return [\"(\", indent([softline, group(printed)]), softline, \")\"];",
                        "      },",
                        "      \"program\",",
                        "      \"body\",",
                        "      0",
                        "    );",
                        "  }",
                        "",
                        "  if (options.__isVueBindings) {",
                        "    return path.call(",
                        "      (functionDeclarationPath) =>",
                        "        join([\",\", line], functionDeclarationPath.map(print, \"params\")),",
                        "      \"program\",",
                        "      \"body\",",
                        "      0",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "// based on https://github.com/prettier/prettier/blob/main/src/language-html/syntax-vue.js isVueEventBindingExpression()",
                        "function isVueEventBindingExpression(node) {",
                        "  switch (node.type) {",
                        "    case \"MemberExpression\":",
                        "      switch (node.property.type) {",
                        "        case \"Identifier\":",
                        "        case \"NumericLiteral\":",
                        "        case \"StringLiteral\":",
                        "          return isVueEventBindingExpression(node.object);",
                        "      }",
                        "      return false;",
                        "    case \"Identifier\":",
                        "      return true;",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "module.exports = {",
                        "  isVueEventBindingExpression,",
                        "  printHtmlBinding,",
                        "};"
                    ]
                },
                "interface.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { join, line, group, indent, ifBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasComment,",
                        "  identity,",
                        "  CommentCheckFlags,",
                        "} = require(\"../utils/index.js\");",
                        "const { getTypeParametersGroupId } = require(\"./type-parameters.js\");",
                        "const { printTypeScriptModifiers } = require(\"./misc.js\");",
                        "",
                        "function printInterface(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "",
                        "  if (node.type === \"TSInterfaceDeclaration\") {",
                        "    parts.push(",
                        "      node.abstract ? \"abstract \" : \"\",",
                        "      printTypeScriptModifiers(path, options, print)",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(\"interface\");",
                        "",
                        "  const partsGroup = [];",
                        "  const extendsParts = [];",
                        "",
                        "  if (node.type !== \"InterfaceTypeAnnotation\") {",
                        "    partsGroup.push(\" \", print(\"id\"), print(\"typeParameters\"));",
                        "  }",
                        "",
                        "  const shouldIndentOnlyHeritageClauses =",
                        "    node.typeParameters &&",
                        "    !hasComment(",
                        "      node.typeParameters,",
                        "      CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "    );",
                        "",
                        "  if (isNonEmptyArray(node.extends)) {",
                        "    extendsParts.push(",
                        "      shouldIndentOnlyHeritageClauses",
                        "        ? ifBreak(\" \", line, {",
                        "            groupId: getTypeParametersGroupId(node.typeParameters),",
                        "          })",
                        "        : line,",
                        "      \"extends \",",
                        "      (node.extends.length === 1 ? identity : indent)(",
                        "        join([\",\", line], path.map(print, \"extends\"))",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    (node.id && hasComment(node.id, CommentCheckFlags.Trailing)) ||",
                        "    isNonEmptyArray(node.extends)",
                        "  ) {",
                        "    if (shouldIndentOnlyHeritageClauses) {",
                        "      parts.push(group([...partsGroup, indent(extendsParts)]));",
                        "    } else {",
                        "      parts.push(group(indent([...partsGroup, ...extendsParts])));",
                        "    }",
                        "  } else {",
                        "    parts.push(...partsGroup, ...extendsParts);",
                        "  }",
                        "",
                        "  parts.push(\" \", print(\"body\"));",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "module.exports = { printInterface };"
                    ]
                },
                "jsx.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "} = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: {",
                        "    line,",
                        "    hardline,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    fill,",
                        "    ifBreak,",
                        "    lineSuffixBoundary,",
                        "    join,",
                        "  },",
                        "  utils: { willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "const { getLast, getPreferredQuote } = require(\"../../common/util.js\");",
                        "const {",
                        "  isJsxNode,",
                        "  rawText,",
                        "  isLiteral,",
                        "  isCallExpression,",
                        "  isStringLiteral,",
                        "  isBinaryish,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  hasNodeIgnoreComment,",
                        "} = require(\"../utils/index.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const { willPrintOwnComments } = require(\"../comments.js\");",
                        "",
                        "const isEmptyStringOrAnyLine = (doc) =>",
                        "  doc === \"\" || doc === line || doc === hardline || doc === softline;",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path\")} AstPath",
                        " * @typedef {import(\"../types/estree\").Node} Node",
                        " * @typedef {import(\"../types/estree\").JSXElement} JSXElement",
                        " */",
                        "",
                        "// JSX expands children from the inside-out, instead of the outside-in.",
                        "// This is both to break children before attributes,",
                        "// and to ensure that when children break, their parents do as well.",
                        "//",
                        "// Any element that is written without any newlines and fits on a single line",
                        "// is left that way.",
                        "// Not only that, any user-written-line containing multiple JSX siblings",
                        "// should also be kept on one line if possible,",
                        "// so each user-written-line is wrapped in its own group.",
                        "//",
                        "// Elements that contain newlines or don't fit on a single line (recursively)",
                        "// are fully-split, using hardline and shouldBreak: true.",
                        "//",
                        "// To support that case properly, all leading and trailing spaces",
                        "// are stripped from the list of children, and replaced with a single hardline.",
                        "function printJsxElementInternal(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (node.type === \"JSXElement\" && isEmptyJsxElement(node)) {",
                        "    return [print(\"openingElement\"), print(\"closingElement\")];",
                        "  }",
                        "",
                        "  const openingLines =",
                        "    node.type === \"JSXElement\"",
                        "      ? print(\"openingElement\")",
                        "      : print(\"openingFragment\");",
                        "  const closingLines =",
                        "    node.type === \"JSXElement\"",
                        "      ? print(\"closingElement\")",
                        "      : print(\"closingFragment\");",
                        "",
                        "  if (",
                        "    node.children.length === 1 &&",
                        "    node.children[0].type === \"JSXExpressionContainer\" &&",
                        "    (node.children[0].expression.type === \"TemplateLiteral\" ||",
                        "      node.children[0].expression.type === \"TaggedTemplateExpression\")",
                        "  ) {",
                        "    return [openingLines, ...path.map(print, \"children\"), closingLines];",
                        "  }",
                        "",
                        "  // Convert `{\" \"}` to text nodes containing a space.",
                        "  // This makes it easy to turn them into `jsxWhitespace` which",
                        "  // can then print as either a space or `{\" \"}` when breaking.",
                        "  node.children = node.children.map((child) => {",
                        "    if (isJsxWhitespaceExpression(child)) {",
                        "      return {",
                        "        type: \"JSXText\",",
                        "        value: \" \",",
                        "        raw: \" \",",
                        "      };",
                        "    }",
                        "    return child;",
                        "  });",
                        "",
                        "  const containsTag = node.children.some(isJsxNode);",
                        "  const containsMultipleExpressions =",
                        "    node.children.filter((child) => child.type === \"JSXExpressionContainer\")",
                        "      .length > 1;",
                        "  const containsMultipleAttributes =",
                        "    node.type === \"JSXElement\" && node.openingElement.attributes.length > 1;",
                        "",
                        "  // Record any breaks. Should never go from true to false, only false to true.",
                        "  let forcedBreak =",
                        "    willBreak(openingLines) ||",
                        "    containsTag ||",
                        "    containsMultipleAttributes ||",
                        "    containsMultipleExpressions;",
                        "",
                        "  const isMdxBlock = path.getParentNode().rootMarker === \"mdx\";",
                        "",
                        "  const rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';",
                        "  const jsxWhitespace = isMdxBlock",
                        "    ? \" \"",
                        "    : ifBreak([rawJsxWhitespace, softline], \" \");",
                        "",
                        "  const isFacebookTranslationTag =",
                        "    node.openingElement &&",
                        "    node.openingElement.name &&",
                        "    node.openingElement.name.name === \"fbt\";",
                        "",
                        "  const children = printJsxChildren(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    jsxWhitespace,",
                        "    isFacebookTranslationTag",
                        "  );",
                        "",
                        "  const containsText = node.children.some((child) =>",
                        "    isMeaningfulJsxText(child)",
                        "  );",
                        "",
                        "  // We can end up we multiple whitespace elements with empty string",
                        "  // content between them.",
                        "  // We need to remove empty whitespace and softlines before JSX whitespace",
                        "  // to get the correct output.",
                        "  for (let i = children.length - 2; i >= 0; i--) {",
                        "    const isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";",
                        "    const isPairOfHardlines =",
                        "      children[i] === hardline &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === hardline;",
                        "    const isLineFollowedByJsxWhitespace =",
                        "      (children[i] === softline || children[i] === hardline) &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === jsxWhitespace;",
                        "    const isJsxWhitespaceFollowedByLine =",
                        "      children[i] === jsxWhitespace &&",
                        "      children[i + 1] === \"\" &&",
                        "      (children[i + 2] === softline || children[i + 2] === hardline);",
                        "    const isDoubleJsxWhitespace =",
                        "      children[i] === jsxWhitespace &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === jsxWhitespace;",
                        "    const isPairOfHardOrSoftLines =",
                        "      (children[i] === softline &&",
                        "        children[i + 1] === \"\" &&",
                        "        children[i + 2] === hardline) ||",
                        "      (children[i] === hardline &&",
                        "        children[i + 1] === \"\" &&",
                        "        children[i + 2] === softline);",
                        "",
                        "    if (",
                        "      (isPairOfHardlines && containsText) ||",
                        "      isPairOfEmptyStrings ||",
                        "      isLineFollowedByJsxWhitespace ||",
                        "      isDoubleJsxWhitespace ||",
                        "      isPairOfHardOrSoftLines",
                        "    ) {",
                        "      children.splice(i, 2);",
                        "    } else if (isJsxWhitespaceFollowedByLine) {",
                        "      children.splice(i + 1, 2);",
                        "    }",
                        "  }",
                        "",
                        "  // Trim trailing lines (or empty strings)",
                        "  while (children.length > 0 && isEmptyStringOrAnyLine(getLast(children))) {",
                        "    children.pop();",
                        "  }",
                        "",
                        "  // Trim leading lines (or empty strings)",
                        "  while (",
                        "    children.length > 1 &&",
                        "    isEmptyStringOrAnyLine(children[0]) &&",
                        "    isEmptyStringOrAnyLine(children[1])",
                        "  ) {",
                        "    children.shift();",
                        "    children.shift();",
                        "  }",
                        "",
                        "  // Tweak how we format children if outputting this element over multiple lines.",
                        "  // Also detect whether we will force this element to output over multiple lines.",
                        "  const multilineChildren = [];",
                        "  for (const [i, child] of children.entries()) {",
                        "    // There are a number of situations where we need to ensure we display",
                        "    // whitespace as `{\" \"}` when outputting this element over multiple lines.",
                        "    if (child === jsxWhitespace) {",
                        "      if (i === 1 && children[i - 1] === \"\") {",
                        "        if (children.length === 2) {",
                        "          // Solitary whitespace",
                        "          multilineChildren.push(rawJsxWhitespace);",
                        "          continue;",
                        "        }",
                        "        // Leading whitespace",
                        "        multilineChildren.push([rawJsxWhitespace, hardline]);",
                        "        continue;",
                        "      } else if (i === children.length - 1) {",
                        "        // Trailing whitespace",
                        "        multilineChildren.push(rawJsxWhitespace);",
                        "        continue;",
                        "      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {",
                        "        // Whitespace after line break",
                        "        multilineChildren.push(rawJsxWhitespace);",
                        "        continue;",
                        "      }",
                        "    }",
                        "",
                        "    multilineChildren.push(child);",
                        "",
                        "    if (willBreak(child)) {",
                        "      forcedBreak = true;",
                        "    }",
                        "  }",
                        "",
                        "  // If there is text we use `fill` to fit as much onto each line as possible.",
                        "  // When there is no text (just tags and expressions) we use `group`",
                        "  // to output each on a separate line.",
                        "  const content = containsText",
                        "    ? fill(multilineChildren)",
                        "    : group(multilineChildren, { shouldBreak: true });",
                        "",
                        "  if (isMdxBlock) {",
                        "    return content;",
                        "  }",
                        "",
                        "  const multiLineElem = group([",
                        "    openingLines,",
                        "    indent([hardline, content]),",
                        "    hardline,",
                        "    closingLines,",
                        "  ]);",
                        "",
                        "  if (forcedBreak) {",
                        "    return multiLineElem;",
                        "  }",
                        "",
                        "  return conditionalGroup([",
                        "    group([openingLines, ...children, closingLines]),",
                        "    multiLineElem,",
                        "  ]);",
                        "}",
                        "",
                        "// JSX Children are strange, mostly for two reasons:",
                        "// 1. JSX reads newlines into string values, instead of skipping them like JS",
                        "// 2. up to one whitespace between elements within a line is significant,",
                        "//    but not between lines.",
                        "//",
                        "// Leading, trailing, and lone whitespace all need to",
                        "// turn themselves into the rather ugly `{' '}` when breaking.",
                        "//",
                        "// We print JSX using the `fill` doc primitive.",
                        "// This requires that we give it an array of alternating",
                        "// content and whitespace elements.",
                        "// To ensure this we add dummy `\"\"` content elements as needed.",
                        "function printJsxChildren(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  jsxWhitespace,",
                        "  isFacebookTranslationTag",
                        ") {",
                        "  const parts = [];",
                        "  path.each((childPath, i, children) => {",
                        "    const child = childPath.getValue();",
                        "    if (isLiteral(child)) {",
                        "      const text = rawText(child);",
                        "",
                        "      // Contains a non-whitespace character",
                        "      if (isMeaningfulJsxText(child)) {",
                        "        const words = text.split(matchJsxWhitespaceRegex);",
                        "",
                        "        // Starts with whitespace",
                        "        if (words[0] === \"\") {",
                        "          parts.push(\"\");",
                        "          words.shift();",
                        "          if (/\\n/.test(words[0])) {",
                        "            const next = children[i + 1];",
                        "            parts.push(",
                        "              separatorWithWhitespace(",
                        "                isFacebookTranslationTag,",
                        "                words[1],",
                        "                child,",
                        "                next",
                        "              )",
                        "            );",
                        "          } else {",
                        "            parts.push(jsxWhitespace);",
                        "          }",
                        "          words.shift();",
                        "        }",
                        "",
                        "        let endWhitespace;",
                        "        // Ends with whitespace",
                        "        if (getLast(words) === \"\") {",
                        "          words.pop();",
                        "          endWhitespace = words.pop();",
                        "        }",
                        "",
                        "        // This was whitespace only without a new line.",
                        "        if (words.length === 0) {",
                        "          return;",
                        "        }",
                        "",
                        "        for (const [i, word] of words.entries()) {",
                        "          if (i % 2 === 1) {",
                        "            parts.push(line);",
                        "          } else {",
                        "            parts.push(word);",
                        "          }",
                        "        }",
                        "",
                        "        if (endWhitespace !== undefined) {",
                        "          if (/\\n/.test(endWhitespace)) {",
                        "            const next = children[i + 1];",
                        "            parts.push(",
                        "              separatorWithWhitespace(",
                        "                isFacebookTranslationTag,",
                        "                getLast(parts),",
                        "                child,",
                        "                next",
                        "              )",
                        "            );",
                        "          } else {",
                        "            parts.push(jsxWhitespace);",
                        "          }",
                        "        } else {",
                        "          const next = children[i + 1];",
                        "          parts.push(",
                        "            separatorNoWhitespace(",
                        "              isFacebookTranslationTag,",
                        "              getLast(parts),",
                        "              child,",
                        "              next",
                        "            )",
                        "          );",
                        "        }",
                        "      } else if (/\\n/.test(text)) {",
                        "        // Keep (up to one) blank line between tags/expressions/text.",
                        "        // Note: We don't keep blank lines between text elements.",
                        "        if (text.match(/\\n/g).length > 1) {",
                        "          parts.push(\"\", hardline);",
                        "        }",
                        "      } else {",
                        "        parts.push(\"\", jsxWhitespace);",
                        "      }",
                        "    } else {",
                        "      const printedChild = print();",
                        "      parts.push(printedChild);",
                        "",
                        "      const next = children[i + 1];",
                        "      const directlyFollowedByMeaningfulText =",
                        "        next && isMeaningfulJsxText(next);",
                        "      if (directlyFollowedByMeaningfulText) {",
                        "        const firstWord = trimJsxWhitespace(rawText(next)).split(",
                        "          matchJsxWhitespaceRegex",
                        "        )[0];",
                        "        parts.push(",
                        "          separatorNoWhitespace(",
                        "            isFacebookTranslationTag,",
                        "            firstWord,",
                        "            child,",
                        "            next",
                        "          )",
                        "        );",
                        "      } else {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, \"children\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function separatorNoWhitespace(",
                        "  isFacebookTranslationTag,",
                        "  child,",
                        "  childNode,",
                        "  nextNode",
                        ") {",
                        "  if (isFacebookTranslationTag) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  if (",
                        "    (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                        "    (nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement)",
                        "  ) {",
                        "    return child.length === 1 ? softline : hardline;",
                        "  }",
                        "",
                        "  return softline;",
                        "}",
                        "",
                        "function separatorWithWhitespace(",
                        "  isFacebookTranslationTag,",
                        "  child,",
                        "  childNode,",
                        "  nextNode",
                        ") {",
                        "  if (isFacebookTranslationTag) {",
                        "    return hardline;",
                        "  }",
                        "",
                        "  if (child.length === 1) {",
                        "    return (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                        "      (nextNode && nextNode.type === \"JSXElement\" && !nextNode.closingElement)",
                        "      ? hardline",
                        "      : softline;",
                        "  }",
                        "",
                        "  return hardline;",
                        "}",
                        "",
                        "function maybeWrapJsxElementInParens(path, elem, options) {",
                        "  const parent = path.getParentNode();",
                        "  /* istanbul ignore next */",
                        "  if (!parent) {",
                        "    return elem;",
                        "  }",
                        "",
                        "  const NO_WRAP_PARENTS = {",
                        "    ArrayExpression: true,",
                        "    JSXAttribute: true,",
                        "    JSXElement: true,",
                        "    JSXExpressionContainer: true,",
                        "    JSXFragment: true,",
                        "    ExpressionStatement: true,",
                        "    CallExpression: true,",
                        "    OptionalCallExpression: true,",
                        "    ConditionalExpression: true,",
                        "    JsExpressionRoot: true,",
                        "  };",
                        "  if (NO_WRAP_PARENTS[parent.type]) {",
                        "    return elem;",
                        "  }",
                        "",
                        "  const shouldBreak = path.match(",
                        "    undefined,",
                        "    (node) => node.type === \"ArrowFunctionExpression\",",
                        "    isCallExpression,",
                        "    (node) => node.type === \"JSXExpressionContainer\"",
                        "  );",
                        "",
                        "  const needsParens = pathNeedsParens(path, options);",
                        "",
                        "  return group(",
                        "    [",
                        "      needsParens ? \"\" : ifBreak(\"(\"),",
                        "      indent([softline, elem]),",
                        "      softline,",
                        "      needsParens ? \"\" : ifBreak(\")\"),",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "function printJsxAttribute(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  parts.push(print(\"name\"));",
                        "",
                        "  if (node.value) {",
                        "    let res;",
                        "    if (isStringLiteral(node.value)) {",
                        "      const raw = rawText(node.value);",
                        "      // Remove enclosing quotes and unescape",
                        "      // all quotes so we get an accurate preferred quote",
                        "      let final = raw",
                        "        .slice(1, -1)",
                        "        .replace(/&apos;/g, \"'\")",
                        "        .replace(/&quot;/g, '\"');",
                        "      const { escaped, quote, regex } = getPreferredQuote(",
                        "        final,",
                        "        options.jsxSingleQuote ? \"'\" : '\"'",
                        "      );",
                        "      final = final.replace(regex, escaped);",
                        "      res = [quote, final, quote];",
                        "    } else {",
                        "      res = print(\"value\");",
                        "    }",
                        "    parts.push(\"=\", res);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJsxExpressionContainer(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  const shouldInline = (node, parent) =>",
                        "    node.type === \"JSXEmptyExpression\" ||",
                        "    (!hasComment(node) &&",
                        "      (node.type === \"ArrayExpression\" ||",
                        "        node.type === \"ObjectExpression\" ||",
                        "        node.type === \"ArrowFunctionExpression\" ||",
                        "        (node.type === \"AwaitExpression\" &&",
                        "          (shouldInline(node.argument, node) ||",
                        "            node.argument.type === \"JSXElement\")) ||",
                        "        isCallExpression(node) ||",
                        "        node.type === \"FunctionExpression\" ||",
                        "        node.type === \"TemplateLiteral\" ||",
                        "        node.type === \"TaggedTemplateExpression\" ||",
                        "        node.type === \"DoExpression\" ||",
                        "        (isJsxNode(parent) &&",
                        "          (node.type === \"ConditionalExpression\" || isBinaryish(node)))));",
                        "",
                        "  if (shouldInline(node.expression, path.getParentNode(0))) {",
                        "    return group([\"{\", print(\"expression\"), lineSuffixBoundary, \"}\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    \"{\",",
                        "    indent([softline, print(\"expression\")]),",
                        "    softline,",
                        "    lineSuffixBoundary,",
                        "    \"}\",",
                        "  ]);",
                        "}",
                        "",
                        "function printJsxOpeningElement(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  const nameHasComments =",
                        "    (node.name && hasComment(node.name)) ||",
                        "    (node.typeParameters && hasComment(node.typeParameters));",
                        "",
                        "  // Don't break self-closing elements with no attributes and no comments",
                        "  if (node.selfClosing && node.attributes.length === 0 && !nameHasComments) {",
                        "    return [\"<\", print(\"name\"), print(\"typeParameters\"), \" />\"];",
                        "  }",
                        "",
                        "  // don't break up opening elements with a single long text attribute",
                        "  if (",
                        "    node.attributes &&",
                        "    node.attributes.length === 1 &&",
                        "    node.attributes[0].value &&",
                        "    isStringLiteral(node.attributes[0].value) &&",
                        "    !node.attributes[0].value.value.includes(\"\\n\") &&",
                        "    // We should break for the following cases:",
                        "    // <div",
                        "    //   // comment",
                        "    //   attr=\"value\"",
                        "    // >",
                        "    // <div",
                        "    //   attr=\"value\"",
                        "    //   // comment",
                        "    // >",
                        "    !nameHasComments &&",
                        "    !hasComment(node.attributes[0])",
                        "  ) {",
                        "    return group([",
                        "      \"<\",",
                        "      print(\"name\"),",
                        "      print(\"typeParameters\"),",
                        "      \" \",",
                        "      ...path.map(print, \"attributes\"),",
                        "      node.selfClosing ? \" />\" : \">\",",
                        "    ]);",
                        "  }",
                        "",
                        "  const lastAttrHasTrailingComments =",
                        "    node.attributes.length > 0 &&",
                        "    hasComment(getLast(node.attributes), CommentCheckFlags.Trailing);",
                        "",
                        "  const bracketSameLine =",
                        "    // Simple tags (no attributes and no comment in tag name) should be",
                        "    // kept unbroken regardless of `bracketSameLine`.",
                        "    // jsxBracketSameLine is deprecated in favour of bracketSameLine,",
                        "    // but is still needed for backwards compatibility.",
                        "    (node.attributes.length === 0 && !nameHasComments) ||",
                        "    ((options.bracketSameLine || options.jsxBracketSameLine) &&",
                        "      // We should print the bracket in a new line for the following cases:",
                        "      // <div",
                        "      //   // comment",
                        "      // >",
                        "      // <div",
                        "      //   attr // comment",
                        "      // >",
                        "      (!nameHasComments || node.attributes.length > 0) &&",
                        "      !lastAttrHasTrailingComments);",
                        "",
                        "  // We should print the opening element expanded if any prop value is a",
                        "  // string literal with newlines",
                        "  const shouldBreak =",
                        "    node.attributes &&",
                        "    node.attributes.some(",
                        "      (attr) =>",
                        "        attr.value &&",
                        "        isStringLiteral(attr.value) &&",
                        "        attr.value.value.includes(\"\\n\")",
                        "    );",
                        "",
                        "  const attributeLine =",
                        "    options.singleAttributePerLine && node.attributes.length > 1",
                        "      ? hardline",
                        "      : line;",
                        "",
                        "  return group(",
                        "    [",
                        "      \"<\",",
                        "      print(\"name\"),",
                        "      print(\"typeParameters\"),",
                        "      indent(path.map(() => [attributeLine, print()], \"attributes\")),",
                        "      node.selfClosing ? line : bracketSameLine ? \">\" : softline,",
                        "      node.selfClosing ? \"/>\" : bracketSameLine ? \"\" : \">\",",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "function printJsxClosingElement(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "",
                        "  parts.push(\"</\");",
                        "",
                        "  const printed = print(\"name\");",
                        "  if (",
                        "    hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Line)",
                        "  ) {",
                        "    parts.push(indent([hardline, printed]), hardline);",
                        "  } else if (",
                        "    hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Block)",
                        "  ) {",
                        "    parts.push(\" \", printed);",
                        "  } else {",
                        "    parts.push(printed);",
                        "  }",
                        "",
                        "  parts.push(\">\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJsxOpeningClosingFragment(path, options /*, print*/) {",
                        "  const node = path.getValue();",
                        "  const nodeHasComment = hasComment(node);",
                        "  const hasOwnLineComment = hasComment(node, CommentCheckFlags.Line);",
                        "  const isOpeningFragment = node.type === \"JSXOpeningFragment\";",
                        "  return [",
                        "    isOpeningFragment ? \"<\" : \"</\",",
                        "    indent([",
                        "      hasOwnLineComment",
                        "        ? hardline",
                        "        : nodeHasComment && !isOpeningFragment",
                        "        ? \" \"",
                        "        : \"\",",
                        "      printDanglingComments(path, options, true),",
                        "    ]),",
                        "    hasOwnLineComment ? hardline : \"\",",
                        "    \">\",",
                        "  ];",
                        "}",
                        "",
                        "function printJsxElement(path, options, print) {",
                        "  const elem = printComments(",
                        "    path,",
                        "    printJsxElementInternal(path, options, print),",
                        "    options",
                        "  );",
                        "  return maybeWrapJsxElementInParens(path, elem, options);",
                        "}",
                        "",
                        "function printJsxEmptyExpression(path, options /*, print*/) {",
                        "  const node = path.getValue();",
                        "  const requiresHardline = hasComment(node, CommentCheckFlags.Line);",
                        "",
                        "  return [",
                        "    printDanglingComments(path, options, /* sameIndent */ !requiresHardline),",
                        "    requiresHardline ? hardline : \"\",",
                        "  ];",
                        "}",
                        "",
                        "// `JSXSpreadAttribute` and `JSXSpreadChild`",
                        "function printJsxSpreadAttribute(path, options, print) {",
                        "  const node = path.getValue();",
                        "  return [",
                        "    \"{\",",
                        "    path.call(",
                        "      (p) => {",
                        "        const printed = [\"...\", print()];",
                        "        const node = p.getValue();",
                        "        if (!hasComment(node) || !willPrintOwnComments(p)) {",
                        "          return printed;",
                        "        }",
                        "        return [",
                        "          indent([softline, printComments(p, printed, options)]),",
                        "          softline,",
                        "        ];",
                        "      },",
                        "      node.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"",
                        "    ),",
                        "    \"}\",",
                        "  ];",
                        "}",
                        "",
                        "function printJsx(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  // JSX nodes always starts with `JSX`",
                        "  if (!node.type.startsWith(\"JSX\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"JSXAttribute\":",
                        "      return printJsxAttribute(path, options, print);",
                        "    case \"JSXIdentifier\":",
                        "      return String(node.name);",
                        "    case \"JSXNamespacedName\":",
                        "      return join(\":\", [print(\"namespace\"), print(\"name\")]);",
                        "    case \"JSXMemberExpression\":",
                        "      return join(\".\", [print(\"object\"), print(\"property\")]);",
                        "    case \"JSXSpreadAttribute\":",
                        "      return printJsxSpreadAttribute(path, options, print);",
                        "    case \"JSXSpreadChild\": {",
                        "      // Same as `printJsxSpreadAttribute`",
                        "      const printJsxSpreadChild = printJsxSpreadAttribute;",
                        "      return printJsxSpreadChild(path, options, print);",
                        "    }",
                        "    case \"JSXExpressionContainer\":",
                        "      return printJsxExpressionContainer(path, options, print);",
                        "    case \"JSXFragment\":",
                        "    case \"JSXElement\":",
                        "      return printJsxElement(path, options, print);",
                        "    case \"JSXOpeningElement\":",
                        "      return printJsxOpeningElement(path, options, print);",
                        "    case \"JSXClosingElement\":",
                        "      return printJsxClosingElement(path, options, print);",
                        "    case \"JSXOpeningFragment\":",
                        "    case \"JSXClosingFragment\":",
                        "      return printJsxOpeningClosingFragment(path, options /*, print*/);",
                        "    case \"JSXEmptyExpression\":",
                        "      return printJsxEmptyExpression(path, options /*, print*/);",
                        "    case \"JSXText\":",
                        "      /* istanbul ignore next */",
                        "      throw new Error(\"JSXTest should be handled by JSXElement\");",
                        "    default:",
                        "      /* istanbul ignore next */",
                        "      throw new Error(`Unknown JSX node type: ${JSON.stringify(node.type)}.`);",
                        "  }",
                        "}",
                        "",
                        "// Only space, newline, carriage return, and tab are treated as whitespace",
                        "// inside JSX.",
                        "const jsxWhitespaceChars = \" \\n\\r\\t\";",
                        "const matchJsxWhitespaceRegex = new RegExp(\"([\" + jsxWhitespaceChars + \"]+)\");",
                        "const containsNonJsxWhitespaceRegex = new RegExp(",
                        "  \"[^\" + jsxWhitespaceChars + \"]\"",
                        ");",
                        "const trimJsxWhitespace = (text) =>",
                        "  text.replace(",
                        "    new RegExp(",
                        "      \"(?:^\" +",
                        "        matchJsxWhitespaceRegex.source +",
                        "        \"|\" +",
                        "        matchJsxWhitespaceRegex.source +",
                        "        \"$)\"",
                        "    ),",
                        "    \"\"",
                        "  );",
                        "",
                        "/**",
                        " * @param {JSXElement} node",
                        " * @returns {boolean}",
                        " */",
                        "function isEmptyJsxElement(node) {",
                        "  if (node.children.length === 0) {",
                        "    return true;",
                        "  }",
                        "  if (node.children.length > 1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // if there is one text child and does not contain any meaningful text",
                        "  // we can treat the element as empty.",
                        "  const child = node.children[0];",
                        "  return isLiteral(child) && !isMeaningfulJsxText(child);",
                        "}",
                        "",
                        "// Meaningful if it contains non-whitespace characters,",
                        "// or it contains whitespace without a new line.",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isMeaningfulJsxText(node) {",
                        "  return (",
                        "    isLiteral(node) &&",
                        "    (containsNonJsxWhitespaceRegex.test(rawText(node)) ||",
                        "      !/\\n/.test(rawText(node)))",
                        "  );",
                        "}",
                        "",
                        "// Detect an expression node representing `{\" \"}`",
                        "function isJsxWhitespaceExpression(node) {",
                        "  return (",
                        "    node.type === \"JSXExpressionContainer\" &&",
                        "    isLiteral(node.expression) &&",
                        "    node.expression.value === \" \" &&",
                        "    !hasComment(node.expression)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function hasJsxIgnoreComment(path) {",
                        "  const node = path.getValue();",
                        "  const parent = path.getParentNode();",
                        "  if (!parent || !node || !isJsxNode(node) || !isJsxNode(parent)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // Lookup the previous sibling, ignoring any empty JSXText elements",
                        "  const index = parent.children.indexOf(node);",
                        "  let prevSibling = null;",
                        "  for (let i = index; i > 0; i--) {",
                        "    const candidate = parent.children[i - 1];",
                        "    if (candidate.type === \"JSXText\" && !isMeaningfulJsxText(candidate)) {",
                        "      continue;",
                        "    }",
                        "    prevSibling = candidate;",
                        "    break;",
                        "  }",
                        "",
                        "  return (",
                        "    prevSibling &&",
                        "    prevSibling.type === \"JSXExpressionContainer\" &&",
                        "    prevSibling.expression.type === \"JSXEmptyExpression\" &&",
                        "    hasNodeIgnoreComment(prevSibling.expression)",
                        "  );",
                        "}",
                        "",
                        "module.exports = {",
                        "  hasJsxIgnoreComment,",
                        "  printJsx,",
                        "};"
                    ]
                },
                "literal.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "const { printString, printNumber } = require(\"../../common/util.js\");",
                        "",
                        "function printLiteral(path, options /*, print*/) {",
                        "  const node = path.getNode();",
                        "",
                        "  switch (node.type) {",
                        "    case \"RegExpLiteral\": // Babel 6 Literal split",
                        "      return printRegex(node);",
                        "    case \"BigIntLiteral\":",
                        "      // babel: node.extra.raw, flow: node.bigint",
                        "      return printBigInt(node.bigint || node.extra.raw);",
                        "    case \"NumericLiteral\": // Babel 6 Literal split",
                        "      return printNumber(node.extra.raw);",
                        "    case \"StringLiteral\": // Babel 6 Literal split",
                        "      return printString(node.extra.raw, options);",
                        "    case \"NullLiteral\": // Babel 6 Literal split",
                        "      return \"null\";",
                        "    case \"BooleanLiteral\": // Babel 6 Literal split",
                        "      return String(node.value);",
                        "    case \"DecimalLiteral\":",
                        "      return printNumber(node.value) + \"m\";",
                        "    case \"Literal\": {",
                        "      if (node.regex) {",
                        "        return printRegex(node.regex);",
                        "      }",
                        "",
                        "      if (node.bigint) {",
                        "        return printBigInt(node.raw);",
                        "      }",
                        "",
                        "      if (node.decimal) {",
                        "        return printNumber(node.decimal) + \"m\";",
                        "      }",
                        "",
                        "      const { value } = node;",
                        "",
                        "      if (typeof value === \"number\") {",
                        "        return printNumber(node.raw);",
                        "      }",
                        "",
                        "      if (typeof value === \"string\") {",
                        "        return printString(node.raw, options);",
                        "      }",
                        "",
                        "      return String(value);",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "function printBigInt(raw) {",
                        "  return raw.toLowerCase();",
                        "}",
                        "",
                        "function printRegex({ pattern, flags }) {",
                        "  flags = [...flags].sort().join(\"\");",
                        "  return `/${pattern}/${flags}`;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printLiteral,",
                        "};"
                    ]
                },
                "member-chain.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  getLast,",
                        "  isNextLineEmptyAfterIndex,",
                        "  getNextNonSpaceNonCommentCharacterIndex,",
                        "} = require(\"../../common/util.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const {",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isFunctionOrArrowExpression,",
                        "  isLongCurriedCallExpression,",
                        "  isMemberish,",
                        "  isNumericLiteral,",
                        "  isSimpleCallArgument,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { locEnd } = require(\"../loc.js\");",
                        "",
                        "const {",
                        "  builders: {",
                        "    join,",
                        "    hardline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    breakParent,",
                        "    label,",
                        "  },",
                        "  utils: { willBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const printCallArguments = require(\"./call-arguments.js\");",
                        "const { printMemberLookup } = require(\"./member.js\");",
                        "const {",
                        "  printOptionalToken,",
                        "  printFunctionTypeParameters,",
                        "  printBindExpressionCallee,",
                        "} = require(\"./misc.js\");",
                        "",
                        "// We detect calls on member expressions specially to format a",
                        "// common pattern better. The pattern we are looking for is this:",
                        "//",
                        "// arr",
                        "//   .map(x => x + 1)",
                        "//   .filter(x => x > 10)",
                        "//   .some(x => x % 2)",
                        "//",
                        "// The way it is structured in the AST is via a nested sequence of",
                        "// MemberExpression and CallExpression. We need to traverse the AST",
                        "// and make groups out of it to print it in the desired way.",
                        "function printMemberChain(path, options, print) {",
                        "  const parent = path.getParentNode();",
                        "  const isExpressionStatement =",
                        "    !parent || parent.type === \"ExpressionStatement\";",
                        "",
                        "  // The first phase is to linearize the AST by traversing it down.",
                        "  //",
                        "  //   a().b()",
                        "  // has the following AST structure:",
                        "  //   CallExpression(MemberExpression(CallExpression(Identifier)))",
                        "  // and we transform it into",
                        "  //   [Identifier, CallExpression, MemberExpression, CallExpression]",
                        "  const printedNodes = [];",
                        "",
                        "  // Here we try to retain one typed empty line after each call expression or",
                        "  // the first group whether it is in parentheses or not",
                        "  function shouldInsertEmptyLineAfter(node) {",
                        "    const { originalText } = options;",
                        "    const nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(",
                        "      originalText,",
                        "      node,",
                        "      locEnd",
                        "    );",
                        "    const nextChar = originalText.charAt(nextCharIndex);",
                        "",
                        "    // if it is cut off by a parenthesis, we only account for one typed empty",
                        "    // line after that parenthesis",
                        "    if (nextChar === \")\") {",
                        "      return (",
                        "        nextCharIndex !== false &&",
                        "        isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1)",
                        "      );",
                        "    }",
                        "",
                        "    return isNextLineEmpty(node, options);",
                        "  }",
                        "",
                        "  function rec(path) {",
                        "    const node = path.getValue();",
                        "    if (",
                        "      isCallExpression(node) &&",
                        "      (isMemberish(node.callee) || isCallExpression(node.callee))",
                        "    ) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: [",
                        "          printComments(",
                        "            path,",
                        "            [",
                        "              printOptionalToken(path),",
                        "              printFunctionTypeParameters(path, options, print),",
                        "              printCallArguments(path, options, print),",
                        "            ],",
                        "            options",
                        "          ),",
                        "          shouldInsertEmptyLineAfter(node) ? hardline : \"\",",
                        "        ],",
                        "      });",
                        "      path.call((callee) => rec(callee), \"callee\");",
                        "    } else if (isMemberish(node)) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        needsParens: pathNeedsParens(path, options),",
                        "        printed: printComments(",
                        "          path,",
                        "          isMemberExpression(node)",
                        "            ? printMemberLookup(path, options, print)",
                        "            : printBindExpressionCallee(path, options, print),",
                        "          options",
                        "        ),",
                        "      });",
                        "      path.call((object) => rec(object), \"object\");",
                        "    } else if (node.type === \"TSNonNullExpression\") {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: printComments(path, \"!\", options),",
                        "      });",
                        "      path.call((expression) => rec(expression), \"expression\");",
                        "    } else {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: print(),",
                        "      });",
                        "    }",
                        "  }",
                        "  // Note: the comments of the root node have already been printed, so we",
                        "  // need to extract this first call without printing them as they would",
                        "  // if handled inside of the recursive call.",
                        "  const node = path.getValue();",
                        "  printedNodes.unshift({",
                        "    node,",
                        "    printed: [",
                        "      printOptionalToken(path),",
                        "      printFunctionTypeParameters(path, options, print),",
                        "      printCallArguments(path, options, print),",
                        "    ],",
                        "  });",
                        "",
                        "  if (node.callee) {",
                        "    path.call((callee) => rec(callee), \"callee\");",
                        "  }",
                        "",
                        "  // Once we have a linear list of printed nodes, we want to create groups out",
                        "  // of it.",
                        "  //",
                        "  //   a().b.c().d().e",
                        "  // will be grouped as",
                        "  //   [",
                        "  //     [Identifier, CallExpression],",
                        "  //     [MemberExpression, MemberExpression, CallExpression],",
                        "  //     [MemberExpression, CallExpression],",
                        "  //     [MemberExpression],",
                        "  //   ]",
                        "  // so that we can print it as",
                        "  //   a()",
                        "  //     .b.c()",
                        "  //     .d()",
                        "  //     .e",
                        "",
                        "  // The first group is the first node followed by",
                        "  //   - as many CallExpression as possible",
                        "  //       < fn()()() >.something()",
                        "  //   - as many array accessors as possible",
                        "  //       < fn()[0][1][2] >.something()",
                        "  //   - then, as many MemberExpression as possible but the last one",
                        "  //       < this.items >.something()",
                        "  const groups = [];",
                        "  let currentGroup = [printedNodes[0]];",
                        "  let i = 1;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (",
                        "      printedNodes[i].node.type === \"TSNonNullExpression\" ||",
                        "      isCallExpression(printedNodes[i].node) ||",
                        "      (isMemberExpression(printedNodes[i].node) &&",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property))",
                        "    ) {",
                        "      currentGroup.push(printedNodes[i]);",
                        "    } else {",
                        "      break;",
                        "    }",
                        "  }",
                        "  if (!isCallExpression(printedNodes[0].node)) {",
                        "    for (; i + 1 < printedNodes.length; ++i) {",
                        "      if (",
                        "        isMemberish(printedNodes[i].node) &&",
                        "        isMemberish(printedNodes[i + 1].node)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "      } else {",
                        "        break;",
                        "      }",
                        "    }",
                        "  }",
                        "  groups.push(currentGroup);",
                        "  currentGroup = [];",
                        "",
                        "  // Then, each following group is a sequence of MemberExpression followed by",
                        "  // a sequence of CallExpression. To compute it, we keep adding things to the",
                        "  // group until we has seen a CallExpression in the past and reach a",
                        "  // MemberExpression",
                        "  let hasSeenCallExpression = false;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {",
                        "      // [0] should be appended at the end of the group instead of the",
                        "      // beginning of the next one",
                        "      if (",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "        continue;",
                        "      }",
                        "",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "",
                        "    if (",
                        "      isCallExpression(printedNodes[i].node) ||",
                        "      printedNodes[i].node.type === \"ImportExpression\"",
                        "    ) {",
                        "      hasSeenCallExpression = true;",
                        "    }",
                        "    currentGroup.push(printedNodes[i]);",
                        "",
                        "    if (hasComment(printedNodes[i].node, CommentCheckFlags.Trailing)) {",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "  }",
                        "  if (currentGroup.length > 0) {",
                        "    groups.push(currentGroup);",
                        "  }",
                        "",
                        "  // There are cases like Object.keys(), Observable.of(), _.values() where",
                        "  // they are the subject of all the chained calls and therefore should",
                        "  // be kept on the same line:",
                        "  //",
                        "  //   Object.keys(items)",
                        "  //     .filter(x => x)",
                        "  //     .map(x => x)",
                        "  //",
                        "  // In order to detect those cases, we use an heuristic: if the first",
                        "  // node is an identifier with the name starting with a capital",
                        "  // letter or just a sequence of _$. The rationale is that they are",
                        "  // likely to be factories.",
                        "  function isFactory(name) {",
                        "    return /^[A-Z]|^[$_]+$/.test(name);",
                        "  }",
                        "",
                        "  // In case the Identifier is shorter than tab width, we can keep the",
                        "  // first call in a single line, if it's an ExpressionStatement.",
                        "  //",
                        "  //   d3.scaleLinear()",
                        "  //     .domain([0, 100])",
                        "  //     .range([0, width]);",
                        "  //",
                        "  function isShort(name) {",
                        "    return name.length <= options.tabWidth;",
                        "  }",
                        "",
                        "  function shouldNotWrap(groups) {",
                        "    const hasComputed = groups[1].length > 0 && groups[1][0].node.computed;",
                        "",
                        "    if (groups[0].length === 1) {",
                        "      const firstNode = groups[0][0].node;",
                        "      return (",
                        "        firstNode.type === \"ThisExpression\" ||",
                        "        (firstNode.type === \"Identifier\" &&",
                        "          (isFactory(firstNode.name) ||",
                        "            (isExpressionStatement && isShort(firstNode.name)) ||",
                        "            hasComputed))",
                        "      );",
                        "    }",
                        "",
                        "    const lastNode = getLast(groups[0]).node;",
                        "    return (",
                        "      isMemberExpression(lastNode) &&",
                        "      lastNode.property.type === \"Identifier\" &&",
                        "      (isFactory(lastNode.property.name) || hasComputed)",
                        "    );",
                        "  }",
                        "",
                        "  const shouldMerge =",
                        "    groups.length >= 2 &&",
                        "    !hasComment(groups[1][0].node) &&",
                        "    shouldNotWrap(groups);",
                        "",
                        "  function printGroup(printedGroup) {",
                        "    const printed = printedGroup.map((tuple) => tuple.printed);",
                        "    // Checks if the last node (i.e. the parent node) needs parens and print",
                        "    // accordingly",
                        "    if (printedGroup.length > 0 && getLast(printedGroup).needsParens) {",
                        "      return [\"(\", ...printed, \")\"];",
                        "    }",
                        "    return printed;",
                        "  }",
                        "",
                        "  function printIndentedGroup(groups) {",
                        "    /* istanbul ignore next */",
                        "    if (groups.length === 0) {",
                        "      return \"\";",
                        "    }",
                        "    return indent(group([hardline, join(hardline, groups.map(printGroup))]));",
                        "  }",
                        "",
                        "  const printedGroups = groups.map(printGroup);",
                        "  const oneLine = printedGroups;",
                        "",
                        "  const cutoff = shouldMerge ? 3 : 2;",
                        "  const flatGroups = groups.flat();",
                        "",
                        "  const nodeHasComment =",
                        "    flatGroups",
                        "      .slice(1, -1)",
                        "      .some((node) => hasComment(node.node, CommentCheckFlags.Leading)) ||",
                        "    flatGroups",
                        "      .slice(0, -1)",
                        "      .some((node) => hasComment(node.node, CommentCheckFlags.Trailing)) ||",
                        "    (groups[cutoff] &&",
                        "      hasComment(groups[cutoff][0].node, CommentCheckFlags.Leading));",
                        "",
                        "  // If we only have a single `.`, we shouldn't do anything fancy and just",
                        "  // render everything concatenated together.",
                        "  if (groups.length <= cutoff && !nodeHasComment) {",
                        "    if (isLongCurriedCallExpression(path)) {",
                        "      return oneLine;",
                        "    }",
                        "    return group(oneLine);",
                        "  }",
                        "",
                        "  // Find out the last node in the first group and check if it has an",
                        "  // empty line after",
                        "  const lastNodeBeforeIndent = getLast(groups[shouldMerge ? 1 : 0]).node;",
                        "  const shouldHaveEmptyLineBeforeIndent =",
                        "    !isCallExpression(lastNodeBeforeIndent) &&",
                        "    shouldInsertEmptyLineAfter(lastNodeBeforeIndent);",
                        "",
                        "  const expanded = [",
                        "    printGroup(groups[0]),",
                        "    shouldMerge ? groups.slice(1, 2).map(printGroup) : \"\",",
                        "    shouldHaveEmptyLineBeforeIndent ? hardline : \"\",",
                        "    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1)),",
                        "  ];",
                        "",
                        "  const callExpressions = printedNodes",
                        "    .map(({ node }) => node)",
                        "    .filter(isCallExpression);",
                        "",
                        "  function lastGroupWillBreakAndOtherCallsHaveFunctionArguments() {",
                        "    const lastGroupNode = getLast(getLast(groups)).node;",
                        "    const lastGroupDoc = getLast(printedGroups);",
                        "    return (",
                        "      isCallExpression(lastGroupNode) &&",
                        "      willBreak(lastGroupDoc) &&",
                        "      callExpressions",
                        "        .slice(0, -1)",
                        "        .some((node) => node.arguments.some(isFunctionOrArrowExpression))",
                        "    );",
                        "  }",
                        "",
                        "  let result;",
                        "",
                        "  // We don't want to print in one line if at least one of these conditions occurs:",
                        "  //  * the chain has comments,",
                        "  //  * the chain is an expression statement and all the arguments are literal-like (\"fluent configuration\" pattern),",
                        "  //  * the chain is longer than 2 calls and has non-trivial arguments or more than 2 arguments in any call but the first one,",
                        "  //  * any group but the last one has a hard line,",
                        "  //  * the last call's arguments have a hard line and other calls have non-trivial arguments.",
                        "  if (",
                        "    nodeHasComment ||",
                        "    (callExpressions.length > 2 &&",
                        "      callExpressions.some(",
                        "        (expr) => !expr.arguments.every((arg) => isSimpleCallArgument(arg, 0))",
                        "      )) ||",
                        "    printedGroups.slice(0, -1).some(willBreak) ||",
                        "    lastGroupWillBreakAndOtherCallsHaveFunctionArguments()",
                        "  ) {",
                        "    result = group(expanded);",
                        "  } else {",
                        "    result = [",
                        "      // We only need to check `oneLine` because if `expanded` is chosen",
                        "      // that means that the parent group has already been broken",
                        "      // naturally",
                        "      willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\",",
                        "      conditionalGroup([oneLine, expanded]),",
                        "    ];",
                        "  }",
                        "",
                        "  return label(\"member-chain\", result);",
                        "}",
                        "",
                        "module.exports = printMemberChain;"
                    ]
                },
                "member.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { softline, group, indent, label },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  isNumericLiteral,",
                        "  isMemberExpression,",
                        "  isCallExpression,",
                        "} = require(\"../utils/index.js\");",
                        "const { printOptionalToken } = require(\"./misc.js\");",
                        "",
                        "function printMemberExpression(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  const parent = path.getParentNode();",
                        "  let firstNonMemberParent;",
                        "  let i = 0;",
                        "  do {",
                        "    firstNonMemberParent = path.getParentNode(i);",
                        "    i++;",
                        "  } while (",
                        "    firstNonMemberParent &&",
                        "    (isMemberExpression(firstNonMemberParent) ||",
                        "      firstNonMemberParent.type === \"TSNonNullExpression\")",
                        "  );",
                        "",
                        "  const objectDoc = print(\"object\");",
                        "  const lookupDoc = printMemberLookup(path, options, print);",
                        "",
                        "  const shouldInline =",
                        "    (firstNonMemberParent &&",
                        "      (firstNonMemberParent.type === \"NewExpression\" ||",
                        "        firstNonMemberParent.type === \"BindExpression\" ||",
                        "        (firstNonMemberParent.type === \"AssignmentExpression\" &&",
                        "          firstNonMemberParent.left.type !== \"Identifier\"))) ||",
                        "    node.computed ||",
                        "    (node.object.type === \"Identifier\" &&",
                        "      node.property.type === \"Identifier\" &&",
                        "      !isMemberExpression(parent)) ||",
                        "    ((parent.type === \"AssignmentExpression\" ||",
                        "      parent.type === \"VariableDeclarator\") &&",
                        "      ((isCallExpression(node.object) && node.object.arguments.length > 0) ||",
                        "        (node.object.type === \"TSNonNullExpression\" &&",
                        "          isCallExpression(node.object.expression) &&",
                        "          node.object.expression.arguments.length > 0) ||",
                        "        objectDoc.label === \"member-chain\"));",
                        "",
                        "  return label(objectDoc.label === \"member-chain\" ? \"member-chain\" : \"member\", [",
                        "    objectDoc,",
                        "    shouldInline ? lookupDoc : group(indent([softline, lookupDoc])),",
                        "  ]);",
                        "}",
                        "",
                        "function printMemberLookup(path, options, print) {",
                        "  const property = print(\"property\");",
                        "  const node = path.getValue();",
                        "  const optional = printOptionalToken(path);",
                        "",
                        "  if (!node.computed) {",
                        "    return [optional, \".\", property];",
                        "  }",
                        "",
                        "  if (!node.property || isNumericLiteral(node.property)) {",
                        "    return [optional, \"[\", property, \"]\"];",
                        "  }",
                        "",
                        "  return group([optional, \"[\", indent([softline, property]), softline, \"]\"]);",
                        "}",
                        "",
                        "module.exports = { printMemberExpression, printMemberLookup };"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { indent, join, line },",
                        "} = require(\"../../document/index.js\");",
                        "const { isFlowAnnotationComment } = require(\"../utils/index.js\");",
                        "",
                        "function printOptionalToken(path) {",
                        "  const node = path.getValue();",
                        "  if (",
                        "    !node.optional ||",
                        "    // It's an optional computed method parsed by typescript-estree.",
                        "    // \"?\" is printed in `printMethod`.",
                        "    (node.type === \"Identifier\" && node === path.getParentNode().key)",
                        "  ) {",
                        "    return \"\";",
                        "  }",
                        "  if (",
                        "    node.type === \"OptionalCallExpression\" ||",
                        "    (node.type === \"OptionalMemberExpression\" && node.computed)",
                        "  ) {",
                        "    return \"?.\";",
                        "  }",
                        "  return \"?\";",
                        "}",
                        "",
                        "function printFunctionTypeParameters(path, options, print) {",
                        "  const fun = path.getValue();",
                        "  if (fun.typeArguments) {",
                        "    return print(\"typeArguments\");",
                        "  }",
                        "  if (fun.typeParameters) {",
                        "    return print(\"typeParameters\");",
                        "  }",
                        "  return \"\";",
                        "}",
                        "",
                        "function printTypeAnnotation(path, options, print) {",
                        "  const node = path.getValue();",
                        "  if (!node.typeAnnotation) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const parentNode = path.getParentNode();",
                        "  const isDefinite =",
                        "    node.definite ||",
                        "    (parentNode &&",
                        "      parentNode.type === \"VariableDeclarator\" &&",
                        "      parentNode.definite);",
                        "",
                        "  const isFunctionDeclarationIdentifier =",
                        "    parentNode.type === \"DeclareFunction\" && parentNode.id === node;",
                        "",
                        "  if (isFlowAnnotationComment(options.originalText, node.typeAnnotation)) {",
                        "    return [\" /*: \", print(\"typeAnnotation\"), \" */\"];",
                        "  }",
                        "",
                        "  return [",
                        "    isFunctionDeclarationIdentifier ? \"\" : isDefinite ? \"!: \" : \": \",",
                        "    print(\"typeAnnotation\"),",
                        "  ];",
                        "}",
                        "",
                        "function printBindExpressionCallee(path, options, print) {",
                        "  return [\"::\", print(\"callee\")];",
                        "}",
                        "",
                        "function printTypeScriptModifiers(path, options, print) {",
                        "  const node = path.getValue();",
                        "  if (!isNonEmptyArray(node.modifiers)) {",
                        "    return \"\";",
                        "  }",
                        "  return [join(\" \", path.map(print, \"modifiers\")), \" \"];",
                        "}",
                        "",
                        "function adjustClause(node, clause, forceSpace) {",
                        "  if (node.type === \"EmptyStatement\") {",
                        "    return \";\";",
                        "  }",
                        "",
                        "  if (node.type === \"BlockStatement\" || forceSpace) {",
                        "    return [\" \", clause];",
                        "  }",
                        "",
                        "  return indent([line, clause]);",
                        "}",
                        "",
                        "function printRestSpread(path, options, print) {",
                        "  return [\"...\", print(\"argument\"), printTypeAnnotation(path, options, print)];",
                        "}",
                        "",
                        "module.exports = {",
                        "  printOptionalToken,",
                        "  printFunctionTypeParameters,",
                        "  printBindExpressionCallee,",
                        "  printTypeScriptModifiers,",
                        "  printTypeAnnotation,",
                        "  printRestSpread,",
                        "  adjustClause,",
                        "};"
                    ]
                },
                "module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { softline, group, indent, join, line, ifBreak, hardline },",
                        "} = require(\"../../document/index.js\");",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "",
                        "const {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  shouldPrintComma,",
                        "  needsHardlineAfterDanglingComment,",
                        "  isStringLiteral,",
                        "  rawText,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart, hasSameLoc } = require(\"../loc.js\");",
                        "const {",
                        "  hasDecoratorsBeforeExport,",
                        "  printDecoratorsBeforeExport,",
                        "} = require(\"./decorators.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document\").Doc} Doc",
                        " */",
                        "",
                        "function printImportDeclaration(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  const { importKind } = node;",
                        "",
                        "  parts.push(\"import\");",
                        "",
                        "  if (importKind && importKind !== \"value\") {",
                        "    parts.push(\" \", importKind);",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printModuleSpecifiers(path, options, print),",
                        "    printModuleSource(path, options, print),",
                        "    printImportAssertions(path, options, print),",
                        "    semi",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printExportDeclaration(path, options, print) {",
                        "  const node = path.getValue();",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  // Only print decorators here if they were written before the export,",
                        "  // otherwise they are printed by the node.declaration",
                        "  if (hasDecoratorsBeforeExport(node)) {",
                        "    parts.push(printDecoratorsBeforeExport(path, options, print));",
                        "  }",
                        "",
                        "  const { type, exportKind, declaration } = node;",
                        "",
                        "  parts.push(\"export\");",
                        "",
                        "  const isDefaultExport = node.default || type === \"ExportDefaultDeclaration\";",
                        "  if (isDefaultExport) {",
                        "    parts.push(\" default\");",
                        "  }",
                        "",
                        "  if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    parts.push(",
                        "      \" \",",
                        "      printDanglingComments(path, options, /* sameIndent */ true)",
                        "    );",
                        "",
                        "    if (needsHardlineAfterDanglingComment(node)) {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  if (declaration) {",
                        "    parts.push(\" \", print(\"declaration\"));",
                        "  } else {",
                        "    parts.push(",
                        "      exportKind === \"type\" ? \" type\" : \"\",",
                        "      printModuleSpecifiers(path, options, print),",
                        "      printModuleSource(path, options, print),",
                        "      printImportAssertions(path, options, print)",
                        "    );",
                        "  }",
                        "",
                        "  if (shouldExportDeclarationPrintSemi(node, options)) {",
                        "    parts.push(\";\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printExportAllDeclaration(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  const { exportKind, exported } = node;",
                        "",
                        "  parts.push(\"export\");",
                        "",
                        "  if (exportKind === \"type\") {",
                        "    parts.push(\" type\");",
                        "  }",
                        "",
                        "  parts.push(\" *\");",
                        "",
                        "  if (exported) {",
                        "    parts.push(\" as \", print(\"exported\"));",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printModuleSource(path, options, print),",
                        "    printImportAssertions(path, options, print),",
                        "    semi",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldExportDeclarationPrintSemi(node, options) {",
                        "  if (!options.semi) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const { type, declaration } = node;",
                        "  const isDefaultExport = node.default || type === \"ExportDefaultDeclaration\";",
                        "  if (!declaration) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const { type: declarationType } = declaration;",
                        "  if (",
                        "    isDefaultExport &&",
                        "    declarationType !== \"ClassDeclaration\" &&",
                        "    declarationType !== \"FunctionDeclaration\" &&",
                        "    declarationType !== \"TSInterfaceDeclaration\" &&",
                        "    declarationType !== \"DeclareClass\" &&",
                        "    declarationType !== \"DeclareFunction\" &&",
                        "    declarationType !== \"TSDeclareFunction\" &&",
                        "    declarationType !== \"EnumDeclaration\"",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function printModuleSource(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (!node.source) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "  if (!shouldNotPrintSpecifiers(node, options)) {",
                        "    parts.push(\" from\");",
                        "  }",
                        "  parts.push(\" \", print(\"source\"));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printModuleSpecifiers(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (shouldNotPrintSpecifiers(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [\" \"];",
                        "",
                        "  if (isNonEmptyArray(node.specifiers)) {",
                        "    const standaloneSpecifiers = [];",
                        "    const groupedSpecifiers = [];",
                        "",
                        "    path.each(() => {",
                        "      const specifierType = path.getValue().type;",
                        "      if (",
                        "        specifierType === \"ExportNamespaceSpecifier\" ||",
                        "        specifierType === \"ExportDefaultSpecifier\" ||",
                        "        specifierType === \"ImportNamespaceSpecifier\" ||",
                        "        specifierType === \"ImportDefaultSpecifier\"",
                        "      ) {",
                        "        standaloneSpecifiers.push(print());",
                        "      } else if (",
                        "        specifierType === \"ExportSpecifier\" ||",
                        "        specifierType === \"ImportSpecifier\"",
                        "      ) {",
                        "        groupedSpecifiers.push(print());",
                        "      } else {",
                        "        /* istanbul ignore next */",
                        "        throw new Error(",
                        "          `Unknown specifier type ${JSON.stringify(specifierType)}`",
                        "        );",
                        "      }",
                        "    }, \"specifiers\");",
                        "",
                        "    parts.push(join(\", \", standaloneSpecifiers));",
                        "",
                        "    if (groupedSpecifiers.length > 0) {",
                        "      if (standaloneSpecifiers.length > 0) {",
                        "        parts.push(\", \");",
                        "      }",
                        "",
                        "      const canBreak =",
                        "        groupedSpecifiers.length > 1 ||",
                        "        standaloneSpecifiers.length > 0 ||",
                        "        node.specifiers.some((node) => hasComment(node));",
                        "",
                        "      if (canBreak) {",
                        "        parts.push(",
                        "          group([",
                        "            \"{\",",
                        "            indent([",
                        "              options.bracketSpacing ? line : softline,",
                        "              join([\",\", line], groupedSpecifiers),",
                        "            ]),",
                        "            ifBreak(shouldPrintComma(options) ? \",\" : \"\"),",
                        "            options.bracketSpacing ? line : softline,",
                        "            \"}\",",
                        "          ])",
                        "        );",
                        "      } else {",
                        "        parts.push([",
                        "          \"{\",",
                        "          options.bracketSpacing ? \" \" : \"\",",
                        "          ...groupedSpecifiers,",
                        "          options.bracketSpacing ? \" \" : \"\",",
                        "          \"}\",",
                        "        ]);",
                        "      }",
                        "    }",
                        "  } else {",
                        "    parts.push(\"{}\");",
                        "  }",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldNotPrintSpecifiers(node, options) {",
                        "  const { type, importKind, source, specifiers } = node;",
                        "",
                        "  if (",
                        "    type !== \"ImportDeclaration\" ||",
                        "    isNonEmptyArray(specifiers) ||",
                        "    importKind === \"type\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // TODO: check tokens",
                        "  return !/{\\s*}/.test(",
                        "    options.originalText.slice(locStart(node), locStart(source))",
                        "  );",
                        "}",
                        "",
                        "function printImportAssertions(path, options, print) {",
                        "  const node = path.getNode();",
                        "  if (isNonEmptyArray(node.assertions)) {",
                        "    return [",
                        "      \" assert {\",",
                        "      options.bracketSpacing ? \" \" : \"\",",
                        "      join(\", \", path.map(print, \"assertions\")),",
                        "      options.bracketSpacing ? \" \" : \"\",",
                        "      \"}\",",
                        "    ];",
                        "  }",
                        "  return \"\";",
                        "}",
                        "",
                        "function printModuleSpecifier(path, options, print) {",
                        "  const node = path.getNode();",
                        "",
                        "  const { type } = node;",
                        "",
                        "  /** @type {Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  /** @type {\"type\" | \"typeof\" | \"value\"} */",
                        "  const kind = type === \"ImportSpecifier\" ? node.importKind : node.exportKind;",
                        "",
                        "  if (kind && kind !== \"value\") {",
                        "    parts.push(kind, \" \");",
                        "  }",
                        "",
                        "  const isImport = type.startsWith(\"Import\");",
                        "  const leftSideProperty = isImport ? \"imported\" : \"local\";",
                        "  const rightSideProperty = isImport ? \"local\" : \"exported\";",
                        "  const leftSideNode = node[leftSideProperty];",
                        "  const rightSideNode = node[rightSideProperty];",
                        "  let left = \"\";",
                        "  let right = \"\";",
                        "  if (",
                        "    type === \"ExportNamespaceSpecifier\" ||",
                        "    type === \"ImportNamespaceSpecifier\"",
                        "  ) {",
                        "    left = \"*\";",
                        "  } else if (leftSideNode) {",
                        "    left = print(leftSideProperty);",
                        "  }",
                        "",
                        "  if (rightSideNode && !isShorthandSpecifier(node)) {",
                        "    right = print(rightSideProperty);",
                        "  }",
                        "",
                        "  parts.push(left, left && right ? \" as \" : \"\", right);",
                        "  return parts;",
                        "}",
                        "",
                        "function isShorthandSpecifier(specifier) {",
                        "  if (",
                        "    specifier.type !== \"ImportSpecifier\" &&",
                        "    specifier.type !== \"ExportSpecifier\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const {",
                        "    local,",
                        "    [specifier.type === \"ImportSpecifier\" ? \"imported\" : \"exported\"]:",
                        "      importedOrExported,",
                        "  } = specifier;",
                        "",
                        "  if (",
                        "    local.type !== importedOrExported.type ||",
                        "    !hasSameLoc(local, importedOrExported)",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isStringLiteral(local)) {",
                        "    return (",
                        "      local.value === importedOrExported.value &&",
                        "      rawText(local) === rawText(importedOrExported)",
                        "    );",
                        "  }",
                        "",
                        "  switch (local.type) {",
                        "    case \"Identifier\":",
                        "      return local.name === importedOrExported.name;",
                        "    default:",
                        "      /* istanbul ignore next */",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "module.exports = {",
                        "  printImportDeclaration,",
                        "  printExportDeclaration,",
                        "  printExportAllDeclaration,",
                        "  printModuleSpecifier,",
                        "};"
                    ]
                },
                "object.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { line, softline, group, indent, ifBreak, hardline },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  getLast,",
                        "  hasNewlineInRange,",
                        "  hasNewline,",
                        "  isNonEmptyArray,",
                        "} = require(\"../../common/util.js\");",
                        "const {",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "",
                        "const { printOptionalToken, printTypeAnnotation } = require(\"./misc.js\");",
                        "const { shouldHugFunctionParameters } = require(\"./function-parameters.js\");",
                        "const { shouldHugType } = require(\"./type-annotation.js\");",
                        "const { printHardlineAfterHeritage } = require(\"./class.js\");",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "function printObject(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const node = path.getValue();",
                        "",
                        "  let propertiesField;",
                        "",
                        "  if (node.type === \"TSTypeLiteral\") {",
                        "    propertiesField = \"members\";",
                        "  } else if (node.type === \"TSInterfaceBody\") {",
                        "    propertiesField = \"body\";",
                        "  } else {",
                        "    propertiesField = \"properties\";",
                        "  }",
                        "",
                        "  const isTypeAnnotation = node.type === \"ObjectTypeAnnotation\";",
                        "  const fields = [propertiesField];",
                        "  if (isTypeAnnotation) {",
                        "    fields.push(\"indexers\", \"callProperties\", \"internalSlots\");",
                        "  }",
                        "",
                        "  const firstProperty = fields",
                        "    .map((field) => node[field][0])",
                        "    .sort((a, b) => locStart(a) - locStart(b))[0];",
                        "",
                        "  const parent = path.getParentNode(0);",
                        "  const isFlowInterfaceLikeBody =",
                        "    isTypeAnnotation &&",
                        "    parent &&",
                        "    (parent.type === \"InterfaceDeclaration\" ||",
                        "      parent.type === \"DeclareInterface\" ||",
                        "      parent.type === \"DeclareClass\") &&",
                        "    path.getName() === \"body\";",
                        "  const shouldBreak =",
                        "    node.type === \"TSInterfaceBody\" ||",
                        "    isFlowInterfaceLikeBody ||",
                        "    (node.type === \"ObjectPattern\" &&",
                        "      parent.type !== \"FunctionDeclaration\" &&",
                        "      parent.type !== \"FunctionExpression\" &&",
                        "      parent.type !== \"ArrowFunctionExpression\" &&",
                        "      parent.type !== \"ObjectMethod\" &&",
                        "      parent.type !== \"ClassMethod\" &&",
                        "      parent.type !== \"ClassPrivateMethod\" &&",
                        "      parent.type !== \"AssignmentPattern\" &&",
                        "      parent.type !== \"CatchClause\" &&",
                        "      node.properties.some(",
                        "        (property) =>",
                        "          property.value &&",
                        "          (property.value.type === \"ObjectPattern\" ||",
                        "            property.value.type === \"ArrayPattern\")",
                        "      )) ||",
                        "    (node.type !== \"ObjectPattern\" &&",
                        "      firstProperty &&",
                        "      hasNewlineInRange(",
                        "        options.originalText,",
                        "        locStart(node),",
                        "        locStart(firstProperty)",
                        "      ));",
                        "",
                        "  const separator = isFlowInterfaceLikeBody",
                        "    ? \";\"",
                        "    : node.type === \"TSInterfaceBody\" || node.type === \"TSTypeLiteral\"",
                        "    ? ifBreak(semi, \";\")",
                        "    : \",\";",
                        "  const leftBrace =",
                        "    node.type === \"RecordExpression\" ? \"#{\" : node.exact ? \"{|\" : \"{\";",
                        "  const rightBrace = node.exact ? \"|}\" : \"}\";",
                        "",
                        "  // Unfortunately, things are grouped together in the ast can be",
                        "  // interleaved in the source code. So we need to reorder them before",
                        "  // printing them.",
                        "  const propsAndLoc = [];",
                        "  for (const field of fields) {",
                        "    path.each((childPath) => {",
                        "      const node = childPath.getValue();",
                        "      propsAndLoc.push({",
                        "        node,",
                        "        printed: print(),",
                        "        loc: locStart(node),",
                        "      });",
                        "    }, field);",
                        "  }",
                        "",
                        "  if (fields.length > 1) {",
                        "    propsAndLoc.sort((a, b) => a.loc - b.loc);",
                        "  }",
                        "",
                        "  /** @type {Doc[]} */",
                        "  let separatorParts = [];",
                        "  const props = propsAndLoc.map((prop) => {",
                        "    const result = [...separatorParts, group(prop.printed)];",
                        "    separatorParts = [separator, line];",
                        "    if (",
                        "      (prop.node.type === \"TSPropertySignature\" ||",
                        "        prop.node.type === \"TSMethodSignature\" ||",
                        "        prop.node.type === \"TSConstructSignatureDeclaration\") &&",
                        "      hasComment(prop.node, CommentCheckFlags.PrettierIgnore)",
                        "    ) {",
                        "      separatorParts.shift();",
                        "    }",
                        "    if (isNextLineEmpty(prop.node, options)) {",
                        "      separatorParts.push(hardline);",
                        "    }",
                        "    return result;",
                        "  });",
                        "",
                        "  if (node.inexact) {",
                        "    let printed;",
                        "    if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      const hasLineComments = hasComment(node, CommentCheckFlags.Line);",
                        "      const printedDanglingComments = printDanglingComments(",
                        "        path,",
                        "        options,",
                        "        /* sameIndent */ true",
                        "      );",
                        "      printed = [",
                        "        printedDanglingComments,",
                        "        hasLineComments ||",
                        "        hasNewline(options.originalText, locEnd(getLast(getComments(node))))",
                        "          ? hardline",
                        "          : line,",
                        "        \"...\",",
                        "      ];",
                        "    } else {",
                        "      printed = [\"...\"];",
                        "    }",
                        "    props.push([...separatorParts, ...printed]);",
                        "  }",
                        "",
                        "  const lastElem = getLast(node[propertiesField]);",
                        "",
                        "  const canHaveTrailingSeparator = !(",
                        "    node.inexact ||",
                        "    (lastElem && lastElem.type === \"RestElement\") ||",
                        "    (lastElem &&",
                        "      (lastElem.type === \"TSPropertySignature\" ||",
                        "        lastElem.type === \"TSCallSignatureDeclaration\" ||",
                        "        lastElem.type === \"TSMethodSignature\" ||",
                        "        lastElem.type === \"TSConstructSignatureDeclaration\") &&",
                        "      hasComment(lastElem, CommentCheckFlags.PrettierIgnore))",
                        "  );",
                        "",
                        "  let content;",
                        "  if (props.length === 0) {",
                        "    if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      return [leftBrace, rightBrace, printTypeAnnotation(path, options, print)];",
                        "    }",
                        "",
                        "    content = group([",
                        "      leftBrace,",
                        "      printDanglingComments(path, options),",
                        "      softline,",
                        "      rightBrace,",
                        "      printOptionalToken(path),",
                        "      printTypeAnnotation(path, options, print),",
                        "    ]);",
                        "  } else {",
                        "    content = [",
                        "      isFlowInterfaceLikeBody && isNonEmptyArray(node.properties)",
                        "        ? printHardlineAfterHeritage(parent)",
                        "        : \"\",",
                        "      leftBrace,",
                        "      indent([options.bracketSpacing ? line : softline, ...props]),",
                        "      ifBreak(",
                        "        canHaveTrailingSeparator &&",
                        "          (separator !== \",\" || shouldPrintComma(options))",
                        "          ? separator",
                        "          : \"\"",
                        "      ),",
                        "      options.bracketSpacing ? line : softline,",
                        "      rightBrace,",
                        "      printOptionalToken(path),",
                        "      printTypeAnnotation(path, options, print),",
                        "    ];",
                        "  }",
                        "",
                        "  // If we inline the object as first argument of the parent, we don't want",
                        "  // to create another group so that the object breaks before the return",
                        "  // type",
                        "  if (",
                        "    path.match(",
                        "      (node) => node.type === \"ObjectPattern\" && !node.decorators,",
                        "      (node, name, number) =>",
                        "        shouldHugFunctionParameters(node) &&",
                        "        (name === \"params\" ||",
                        "          name === \"parameters\" ||",
                        "          name === \"this\" ||",
                        "          name === \"rest\") &&",
                        "        number === 0",
                        "    ) ||",
                        "    path.match(",
                        "      shouldHugType,",
                        "      (node, name) => name === \"typeAnnotation\",",
                        "      (node, name) => name === \"typeAnnotation\",",
                        "      (node, name, number) =>",
                        "        shouldHugFunctionParameters(node) &&",
                        "        (name === \"params\" ||",
                        "          name === \"parameters\" ||",
                        "          name === \"this\" ||",
                        "          name === \"rest\") &&",
                        "        number === 0",
                        "    ) ||",
                        "    // Assignment printing logic (printAssignment) is responsible",
                        "    // for adding a group if needed",
                        "    (!shouldBreak &&",
                        "      path.match(",
                        "        (node) => node.type === \"ObjectPattern\",",
                        "        (node) =>",
                        "          node.type === \"AssignmentExpression\" ||",
                        "          node.type === \"VariableDeclarator\"",
                        "      ))",
                        "  ) {",
                        "    return content;",
                        "  }",
                        "",
                        "  return group(content, { shouldBreak });",
                        "}",
                        "",
                        "module.exports = { printObject };"
                    ]
                },
                "property.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printComments } = require(\"../../main/comments.js\");",
                        "const { printString, printNumber } = require(\"../../common/util.js\");",
                        "const {",
                        "  isNumericLiteral,",
                        "  isSimpleNumber,",
                        "  isStringLiteral,",
                        "  isStringPropSafeToUnquote,",
                        "  rawText,",
                        "} = require(\"../utils/index.js\");",
                        "const { printAssignment } = require(\"./assignment.js\");",
                        "",
                        "const needsQuoteProps = new WeakMap();",
                        "",
                        "function printPropertyKey(path, options, print) {",
                        "  const node = path.getNode();",
                        "",
                        "  if (node.computed) {",
                        "    return [\"[\", print(\"key\"), \"]\"];",
                        "  }",
                        "",
                        "  const parent = path.getParentNode();",
                        "  const { key } = node;",
                        "",
                        "  // flow has `Identifier` key, other parsers use `PrivateIdentifier` (ESTree) or `PrivateName`",
                        "  if (node.type === \"ClassPrivateProperty\" && key.type === \"Identifier\") {",
                        "    return [\"#\", print(\"key\")];",
                        "  }",
                        "",
                        "  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {",
                        "    const objectHasStringProp = (",
                        "      parent.properties ||",
                        "      parent.body ||",
                        "      parent.members",
                        "    ).some(",
                        "      (prop) =>",
                        "        !prop.computed &&",
                        "        prop.key &&",
                        "        isStringLiteral(prop.key) &&",
                        "        !isStringPropSafeToUnquote(prop, options)",
                        "    );",
                        "    needsQuoteProps.set(parent, objectHasStringProp);",
                        "  }",
                        "",
                        "  if (",
                        "    (key.type === \"Identifier\" ||",
                        "      (isNumericLiteral(key) &&",
                        "        isSimpleNumber(printNumber(rawText(key))) &&",
                        "        // Avoid converting 999999999999999999999 to 1e+21, 0.99999999999999999 to 1 and 1.0 to 1.",
                        "        String(key.value) === printNumber(rawText(key)) &&",
                        "        // Quoting number keys is safe in JS and Flow, but not in TypeScript (as",
                        "        // mentioned in `isStringPropSafeToUnquote`).",
                        "        !(options.parser === \"typescript\" || options.parser === \"babel-ts\"))) &&",
                        "    (options.parser === \"json\" ||",
                        "      (options.quoteProps === \"consistent\" && needsQuoteProps.get(parent)))",
                        "  ) {",
                        "    // a -> \"a\"",
                        "    // 1 -> \"1\"",
                        "    // 1.5 -> \"1.5\"",
                        "    const prop = printString(",
                        "      JSON.stringify(",
                        "        key.type === \"Identifier\" ? key.name : key.value.toString()",
                        "      ),",
                        "      options",
                        "    );",
                        "    return path.call((keyPath) => printComments(keyPath, prop, options), \"key\");",
                        "  }",
                        "",
                        "  if (",
                        "    isStringPropSafeToUnquote(node, options) &&",
                        "    (options.quoteProps === \"as-needed\" ||",
                        "      (options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent)))",
                        "  ) {",
                        "    // 'a' -> a",
                        "    // '1' -> 1",
                        "    // '1.5' -> 1.5",
                        "    return path.call(",
                        "      (keyPath) =>",
                        "        printComments(",
                        "          keyPath,",
                        "          /^\\d/.test(key.value) ? printNumber(key.value) : key.value,",
                        "          options",
                        "        ),",
                        "      \"key\"",
                        "    );",
                        "  }",
                        "",
                        "  return print(\"key\");",
                        "}",
                        "",
                        "function printProperty(path, options, print) {",
                        "  const node = path.getValue();",
                        "  if (node.shorthand) {",
                        "    return print(\"value\");",
                        "  }",
                        "",
                        "  return printAssignment(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    printPropertyKey(path, options, print),",
                        "    \":\",",
                        "    \"value\"",
                        "  );",
                        "}",
                        "",
                        "module.exports = { printProperty, printPropertyKey };"
                    ]
                },
                "statement.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { hardline },",
                        "} = require(\"../../document/index.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const {",
                        "  getLeftSidePathName,",
                        "  hasNakedLeftSide,",
                        "  isJsxNode,",
                        "  isTheOnlyJsxElementInMarkdown,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} = require(\"../utils/index.js\");",
                        "const { shouldPrintParamsWithoutParens } = require(\"./function.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path\")} AstPath",
                        " */",
                        "",
                        "function printStatementSequence(path, options, print, property) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  const isClassBody = node.type === \"ClassBody\";",
                        "  const lastStatement = getLastStatement(node[property]);",
                        "",
                        "  path.each((path, index, statements) => {",
                        "    const node = path.getValue();",
                        "",
                        "    // Skip printing EmptyStatement nodes to avoid leaving stray",
                        "    // semicolons lying around.",
                        "    if (node.type === \"EmptyStatement\") {",
                        "      return;",
                        "    }",
                        "",
                        "    const printed = print();",
                        "",
                        "    // in no-semi mode, prepend statement with semicolon if it might break ASI",
                        "    // don't prepend the only JSX element in a program with semicolon",
                        "    if (",
                        "      !options.semi &&",
                        "      !isClassBody &&",
                        "      !isTheOnlyJsxElementInMarkdown(options, path) &&",
                        "      statementNeedsASIProtection(path, options)",
                        "    ) {",
                        "      if (hasComment(node, CommentCheckFlags.Leading)) {",
                        "        parts.push(print([], { needsSemi: true }));",
                        "      } else {",
                        "        parts.push(\";\", printed);",
                        "      }",
                        "    } else {",
                        "      parts.push(printed);",
                        "    }",
                        "",
                        "    if (",
                        "      !options.semi &&",
                        "      isClassBody &&",
                        "      isClassProperty(node) &&",
                        "      // `ClassBody` don't allow `EmptyStatement`,",
                        "      // so we can use `statements` to get next node",
                        "      shouldPrintSemicolonAfterClassProperty(node, statements[index + 1])",
                        "    ) {",
                        "      parts.push(\";\");",
                        "    }",
                        "",
                        "    if (node !== lastStatement) {",
                        "      parts.push(hardline);",
                        "",
                        "      if (isNextLineEmpty(node, options)) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, property);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function getLastStatement(statements) {",
                        "  for (let i = statements.length - 1; i >= 0; i--) {",
                        "    const statement = statements[i];",
                        "    if (statement.type !== \"EmptyStatement\") {",
                        "      return statement;",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "function statementNeedsASIProtection(path, options) {",
                        "  const node = path.getNode();",
                        "",
                        "  if (node.type !== \"ExpressionStatement\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  return path.call(",
                        "    (childPath) => expressionNeedsASIProtection(childPath, options),",
                        "    \"expression\"",
                        "  );",
                        "}",
                        "",
                        "function expressionNeedsASIProtection(path, options) {",
                        "  const node = path.getValue();",
                        "  switch (node.type) {",
                        "    case \"ParenthesizedExpression\":",
                        "    case \"TypeCastExpression\":",
                        "    case \"ArrayExpression\":",
                        "    case \"ArrayPattern\":",
                        "    case \"TemplateLiteral\":",
                        "    case \"TemplateElement\":",
                        "    case \"RegExpLiteral\":",
                        "      return true;",
                        "    case \"ArrowFunctionExpression\": {",
                        "      if (!shouldPrintParamsWithoutParens(path, options)) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    case \"UnaryExpression\": {",
                        "      const { prefix, operator } = node;",
                        "      if (prefix && (operator === \"+\" || operator === \"-\")) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    case \"BindExpression\": {",
                        "      if (!node.object) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    case \"Literal\": {",
                        "      if (node.regex) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    default: {",
                        "      if (isJsxNode(node)) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  if (pathNeedsParens(path, options)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!hasNakedLeftSide(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return path.call(",
                        "    (childPath) => expressionNeedsASIProtection(childPath, options),",
                        "    ...getLeftSidePathName(path, node)",
                        "  );",
                        "}",
                        "",
                        "function printBody(path, options, print) {",
                        "  return printStatementSequence(path, options, print, \"body\");",
                        "}",
                        "",
                        "function printSwitchCaseConsequent(path, options, print) {",
                        "  return printStatementSequence(path, options, print, \"consequent\");",
                        "}",
                        "",
                        "const isClassProperty = ({ type }) =>",
                        "  type === \"ClassProperty\" ||",
                        "  type === \"PropertyDefinition\" ||",
                        "  type === \"ClassPrivateProperty\";",
                        "/**",
                        " * @returns {boolean}",
                        " */",
                        "function shouldPrintSemicolonAfterClassProperty(node, nextNode) {",
                        "  const name = node.key && node.key.name;",
                        "  // this isn't actually possible yet with most parsers available today",
                        "  // so isn't properly tested yet.",
                        "  if (",
                        "    (name === \"static\" || name === \"get\" || name === \"set\") &&",
                        "    !node.value &&",
                        "    !node.typeAnnotation",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!nextNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    nextNode.static ||",
                        "    nextNode.accessibility // TypeScript",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!nextNode.computed) {",
                        "    const name = nextNode.key && nextNode.key.name;",
                        "    if (name === \"in\" || name === \"instanceof\") {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  // Flow variance sigil +/- requires semi if there's no",
                        "  // \"declare\" or \"static\" keyword before it.",
                        "  if (",
                        "    isClassProperty(nextNode) &&",
                        "    nextNode.variance &&",
                        "    !nextNode.static &&",
                        "    !nextNode.declare",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (nextNode.type) {",
                        "    case \"ClassProperty\":",
                        "    case \"PropertyDefinition\":",
                        "    case \"TSAbstractPropertyDefinition\":",
                        "      return nextNode.computed;",
                        "    case \"MethodDefinition\": // Flow",
                        "    case \"TSAbstractMethodDefinition\": // TypeScript",
                        "    case \"ClassMethod\":",
                        "    case \"ClassPrivateMethod\": {",
                        "      // Babel",
                        "      const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;",
                        "      if (isAsync || nextNode.kind === \"get\" || nextNode.kind === \"set\") {",
                        "        return false;",
                        "      }",
                        "",
                        "      const isGenerator = nextNode.value",
                        "        ? nextNode.value.generator",
                        "        : nextNode.generator;",
                        "      if (nextNode.computed || isGenerator) {",
                        "        return true;",
                        "      }",
                        "",
                        "      return false;",
                        "    }",
                        "",
                        "    case \"TSIndexSignature\":",
                        "      return true;",
                        "  }",
                        "",
                        "  /* istanbul ignore next */",
                        "  return false;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printBody,",
                        "  printSwitchCaseConsequent,",
                        "};"
                    ]
                },
                "template-literal.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const getLast = require(\"../../utils/get-last.js\");",
                        "const { getStringWidth, getIndentSize } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: {",
                        "    join,",
                        "    hardline,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    align,",
                        "    lineSuffixBoundary,",
                        "    addAlignmentToDoc,",
                        "  },",
                        "  printer: { printDocToString },",
                        "  utils: { mapDoc },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  isBinaryish,",
                        "  isJestEachTemplateLiteral,",
                        "  isSimpleTemplateLiteral,",
                        "  hasComment,",
                        "  isMemberExpression,",
                        "} = require(\"../utils/index.js\");",
                        "",
                        "function printTemplateLiteral(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const isTemplateLiteral = node.type === \"TemplateLiteral\";",
                        "",
                        "  if (",
                        "    isTemplateLiteral &&",
                        "    isJestEachTemplateLiteral(node, path.getParentNode())",
                        "  ) {",
                        "    const printed = printJestEachTemplateLiteral(path, options, print);",
                        "    if (printed) {",
                        "      return printed;",
                        "    }",
                        "  }",
                        "  let expressionsKey = \"expressions\";",
                        "  if (node.type === \"TSTemplateLiteralType\") {",
                        "    expressionsKey = \"types\";",
                        "  }",
                        "  const parts = [];",
                        "",
                        "  let expressions = path.map(print, expressionsKey);",
                        "  const isSimple = isSimpleTemplateLiteral(node);",
                        "",
                        "  if (isSimple) {",
                        "    expressions = expressions.map(",
                        "      (doc) =>",
                        "        printDocToString(doc, {",
                        "          ...options,",
                        "          printWidth: Number.POSITIVE_INFINITY,",
                        "        }).formatted",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(lineSuffixBoundary, \"`\");",
                        "",
                        "  path.each((childPath) => {",
                        "    const i = childPath.getName();",
                        "",
                        "    parts.push(print());",
                        "",
                        "    if (i < expressions.length) {",
                        "      // For a template literal of the following form:",
                        "      //   `someQuery {",
                        "      //     ${call({",
                        "      //       a,",
                        "      //       b,",
                        "      //     })}",
                        "      //   }`",
                        "      // the expression is on its own line (there is a \\n in the previous",
                        "      // quasi literal), therefore we want to indent the JavaScript",
                        "      // expression inside at the beginning of ${ instead of the beginning",
                        "      // of the `.",
                        "      const { tabWidth } = options;",
                        "      const quasi = childPath.getValue();",
                        "      const indentSize = getIndentSize(quasi.value.raw, tabWidth);",
                        "",
                        "      let printed = expressions[i];",
                        "",
                        "      if (!isSimple) {",
                        "        const expression = node[expressionsKey][i];",
                        "        // Breaks at the template element boundaries (${ and }) are preferred to breaking",
                        "        // in the middle of a MemberExpression",
                        "        if (",
                        "          hasComment(expression) ||",
                        "          isMemberExpression(expression) ||",
                        "          expression.type === \"ConditionalExpression\" ||",
                        "          expression.type === \"SequenceExpression\" ||",
                        "          expression.type === \"TSAsExpression\" ||",
                        "          isBinaryish(expression)",
                        "        ) {",
                        "          printed = [indent([softline, printed]), softline];",
                        "        }",
                        "      }",
                        "",
                        "      const aligned =",
                        "        indentSize === 0 && quasi.value.raw.endsWith(\"\\n\")",
                        "          ? align(Number.NEGATIVE_INFINITY, printed)",
                        "          : addAlignmentToDoc(printed, indentSize, tabWidth);",
                        "",
                        "      parts.push(group([\"${\", aligned, lineSuffixBoundary, \"}\"]));",
                        "    }",
                        "  }, \"quasis\");",
                        "",
                        "  parts.push(\"`\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJestEachTemplateLiteral(path, options, print) {",
                        "  /**",
                        "   * a    | b    | expected",
                        "   * ${1} | ${1} | ${2}",
                        "   * ${1} | ${2} | ${3}",
                        "   * ${2} | ${1} | ${3}",
                        "   */",
                        "  const node = path.getNode();",
                        "  const headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);",
                        "  if (",
                        "    headerNames.length > 1 ||",
                        "    headerNames.some((headerName) => headerName.length > 0)",
                        "  ) {",
                        "    options.__inJestEach = true;",
                        "    const expressions = path.map(print, \"expressions\");",
                        "    options.__inJestEach = false;",
                        "    const parts = [];",
                        "    const stringifiedExpressions = expressions.map(",
                        "      (doc) =>",
                        "        \"${\" +",
                        "        printDocToString(doc, {",
                        "          ...options,",
                        "          printWidth: Number.POSITIVE_INFINITY,",
                        "          endOfLine: \"lf\",",
                        "        }).formatted +",
                        "        \"}\"",
                        "    );",
                        "",
                        "    const tableBody = [{ hasLineBreak: false, cells: [] }];",
                        "    for (let i = 1; i < node.quasis.length; i++) {",
                        "      const row = getLast(tableBody);",
                        "      const correspondingExpression = stringifiedExpressions[i - 1];",
                        "",
                        "      row.cells.push(correspondingExpression);",
                        "      if (correspondingExpression.includes(\"\\n\")) {",
                        "        row.hasLineBreak = true;",
                        "      }",
                        "",
                        "      if (node.quasis[i].value.raw.includes(\"\\n\")) {",
                        "        tableBody.push({ hasLineBreak: false, cells: [] });",
                        "      }",
                        "    }",
                        "",
                        "    const maxColumnCount = Math.max(",
                        "      headerNames.length,",
                        "      ...tableBody.map((row) => row.cells.length)",
                        "    );",
                        "",
                        "    const maxColumnWidths = Array.from({ length: maxColumnCount }).fill(0);",
                        "    const table = [",
                        "      { cells: headerNames },",
                        "      ...tableBody.filter((row) => row.cells.length > 0),",
                        "    ];",
                        "    for (const { cells } of table.filter((row) => !row.hasLineBreak)) {",
                        "      for (const [index, cell] of cells.entries()) {",
                        "        maxColumnWidths[index] = Math.max(",
                        "          maxColumnWidths[index],",
                        "          getStringWidth(cell)",
                        "        );",
                        "      }",
                        "    }",
                        "",
                        "    parts.push(",
                        "      lineSuffixBoundary,",
                        "      \"`\",",
                        "      indent([",
                        "        hardline,",
                        "        join(",
                        "          hardline,",
                        "          table.map((row) =>",
                        "            join(",
                        "              \" | \",",
                        "              row.cells.map((cell, index) =>",
                        "                row.hasLineBreak",
                        "                  ? cell",
                        "                  : cell +",
                        "                    \" \".repeat(maxColumnWidths[index] - getStringWidth(cell))",
                        "              )",
                        "            )",
                        "          )",
                        "        ),",
                        "      ]),",
                        "      hardline,",
                        "      \"`\"",
                        "    );",
                        "    return parts;",
                        "  }",
                        "}",
                        "",
                        "function printTemplateExpression(path, print) {",
                        "  const node = path.getValue();",
                        "  let printed = print();",
                        "  if (hasComment(node)) {",
                        "    printed = group([indent([softline, printed]), softline]);",
                        "  }",
                        "  return [\"${\", printed, lineSuffixBoundary, \"}\"];",
                        "}",
                        "",
                        "function printTemplateExpressions(path, print) {",
                        "  return path.map(",
                        "    (path) => printTemplateExpression(path, print),",
                        "    \"expressions\"",
                        "  );",
                        "}",
                        "",
                        "function escapeTemplateCharacters(doc, raw) {",
                        "  return mapDoc(doc, (currentDoc) => {",
                        "    if (typeof currentDoc === \"string\") {",
                        "      return raw",
                        "        ? currentDoc.replace(/(\\\\*)`/g, \"$1$1\\\\`\")",
                        "        : uncookTemplateElementValue(currentDoc);",
                        "    }",
                        "",
                        "    return currentDoc;",
                        "  });",
                        "}",
                        "",
                        "function uncookTemplateElementValue(cookedValue) {",
                        "  return cookedValue.replace(/([\\\\`]|\\${)/g, \"\\\\$1\");",
                        "}",
                        "",
                        "module.exports = {",
                        "  printTemplateLiteral,",
                        "  printTemplateExpressions,",
                        "  escapeTemplateCharacters,",
                        "  uncookTemplateElementValue,",
                        "};"
                    ]
                },
                "ternary.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { hasNewlineInRange } = require(\"../../common/util.js\");",
                        "const {",
                        "  isJsxNode,",
                        "  getComments,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "} = require(\"../utils/index.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "const isBlockComment = require(\"../utils/is-block-comment.js\");",
                        "const {",
                        "  builders: {",
                        "    line,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    align,",
                        "    ifBreak,",
                        "    dedent,",
                        "    breakParent,",
                        "  },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path\")} AstPath",
                        " *",
                        " * @typedef {any} Options - Prettier options (TBD ...)",
                        " */",
                        "",
                        "// If we have nested conditional expressions, we want to print them in JSX mode",
                        "// if there's at least one JSXElement somewhere in the tree.",
                        "//",
                        "// A conditional expression chain like this should be printed in normal mode,",
                        "// because there aren't JSXElements anywhere in it:",
                        "//",
                        "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";",
                        "//",
                        "// But a conditional expression chain like this should be printed in JSX mode,",
                        "// because there is a JSXElement in the last ConditionalExpression:",
                        "//",
                        "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;",
                        "//",
                        "// This type of ConditionalExpression chain is structured like this in the AST:",
                        "//",
                        "// ConditionalExpression {",
                        "//   test: ...,",
                        "//   consequent: ...,",
                        "//   alternate: ConditionalExpression {",
                        "//     test: ...,",
                        "//     consequent: ...,",
                        "//     alternate: ConditionalExpression {",
                        "//       test: ...,",
                        "//       consequent: ...,",
                        "//       alternate: ...,",
                        "//     }",
                        "//   }",
                        "// }",
                        "function conditionalExpressionChainContainsJsx(node) {",
                        "  // Given this code:",
                        "  //",
                        "  // // Using a ConditionalExpression as the consequent is uncommon, but should",
                        "  // // be handled.",
                        "  // A ? B : C ? D : E ? F ? G : H : I",
                        "  //",
                        "  // which has this AST:",
                        "  //",
                        "  // ConditionalExpression {",
                        "  //   test: Identifier(A),",
                        "  //   consequent: Identifier(B),",
                        "  //   alternate: ConditionalExpression {",
                        "  //     test: Identifier(C),",
                        "  //     consequent: Identifier(D),",
                        "  //     alternate: ConditionalExpression {",
                        "  //       test: Identifier(E),",
                        "  //       consequent: ConditionalExpression {",
                        "  //         test: Identifier(F),",
                        "  //         consequent: Identifier(G),",
                        "  //         alternate: Identifier(H),",
                        "  //       },",
                        "  //       alternate: Identifier(I),",
                        "  //     }",
                        "  //   }",
                        "  // }",
                        "  //",
                        "  // We don't care about whether each node was the test, consequent, or alternate",
                        "  // We are only checking if there's any JSXElements inside.",
                        "  const conditionalExpressions = [node];",
                        "  for (let index = 0; index < conditionalExpressions.length; index++) {",
                        "    const conditionalExpression = conditionalExpressions[index];",
                        "    for (const property of [\"test\", \"consequent\", \"alternate\"]) {",
                        "      const node = conditionalExpression[property];",
                        "",
                        "      if (isJsxNode(node)) {",
                        "        return true;",
                        "      }",
                        "",
                        "      if (node.type === \"ConditionalExpression\") {",
                        "        conditionalExpressions.push(node);",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function printTernaryTest(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const isConditionalExpression = node.type === \"ConditionalExpression\";",
                        "  const alternateNodePropertyName = isConditionalExpression",
                        "    ? \"alternate\"",
                        "    : \"falseType\";",
                        "",
                        "  const parent = path.getParentNode();",
                        "",
                        "  const printed = isConditionalExpression",
                        "    ? print(\"test\")",
                        "    : [print(\"checkType\"), \" \", \"extends\", \" \", print(\"extendsType\")];",
                        "  /**",
                        "   *     a",
                        "   *       ? b",
                        "   *       : multiline",
                        "   *         test",
                        "   *         node",
                        "   *       ^^ align(2)",
                        "   *       ? d",
                        "   *       : e",
                        "   */",
                        "  if (parent.type === node.type && parent[alternateNodePropertyName] === node) {",
                        "    return align(2, printed);",
                        "  }",
                        "  return printed;",
                        "}",
                        "",
                        "const ancestorNameMap = new Map([",
                        "  [\"AssignmentExpression\", \"right\"],",
                        "  [\"VariableDeclarator\", \"init\"],",
                        "  [\"ReturnStatement\", \"argument\"],",
                        "  [\"ThrowStatement\", \"argument\"],",
                        "  [\"UnaryExpression\", \"argument\"],",
                        "  [\"YieldExpression\", \"argument\"],",
                        "]);",
                        "function shouldExtraIndentForConditionalExpression(path) {",
                        "  const node = path.getValue();",
                        "  if (node.type !== \"ConditionalExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  let parent;",
                        "  let child = node;",
                        "  for (let ancestorCount = 0; !parent; ancestorCount++) {",
                        "    const node = path.getParentNode(ancestorCount);",
                        "",
                        "    if (",
                        "      (isCallExpression(node) && node.callee === child) ||",
                        "      (isMemberExpression(node) && node.object === child) ||",
                        "      (node.type === \"TSNonNullExpression\" && node.expression === child)",
                        "    ) {",
                        "      child = node;",
                        "      continue;",
                        "    }",
                        "",
                        "    // Reached chain root",
                        "",
                        "    if (",
                        "      (node.type === \"NewExpression\" && node.callee === child) ||",
                        "      (node.type === \"TSAsExpression\" && node.expression === child)",
                        "    ) {",
                        "      parent = path.getParentNode(ancestorCount + 1);",
                        "      child = node;",
                        "    } else {",
                        "      parent = node;",
                        "    }",
                        "  }",
                        "",
                        "  // Do not add indent to direct `ConditionalExpression`",
                        "  if (child === node) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return parent[ancestorNameMap.get(parent.type)] === child;",
                        "}",
                        "",
                        "/**",
                        " * The following is the shared logic for",
                        " * ternary operators, namely ConditionalExpression",
                        " * and TSConditionalType",
                        " * @param {AstPath} path - The path to the ConditionalExpression/TSConditionalType node.",
                        " * @param {Options} options - Prettier options",
                        " * @param {Function} print - Print function to call recursively",
                        " * @returns {Doc}",
                        " */",
                        "function printTernary(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const isConditionalExpression = node.type === \"ConditionalExpression\";",
                        "  const consequentNodePropertyName = isConditionalExpression",
                        "    ? \"consequent\"",
                        "    : \"trueType\";",
                        "  const alternateNodePropertyName = isConditionalExpression",
                        "    ? \"alternate\"",
                        "    : \"falseType\";",
                        "  const testNodePropertyNames = isConditionalExpression",
                        "    ? [\"test\"]",
                        "    : [\"checkType\", \"extendsType\"];",
                        "  const consequentNode = node[consequentNodePropertyName];",
                        "  const alternateNode = node[alternateNodePropertyName];",
                        "  const parts = [];",
                        "",
                        "  // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".",
                        "  // See `tests/format/jsx/conditional-expression.js` for more info.",
                        "  let jsxMode = false;",
                        "  const parent = path.getParentNode();",
                        "  const isParentTest =",
                        "    parent.type === node.type &&",
                        "    testNodePropertyNames.some((prop) => parent[prop] === node);",
                        "  let forceNoIndent = parent.type === node.type && !isParentTest;",
                        "",
                        "  // Find the outermost non-ConditionalExpression parent, and the outermost",
                        "  // ConditionalExpression parent. We'll use these to determine if we should",
                        "  // print in JSX mode.",
                        "  let currentParent;",
                        "  let previousParent;",
                        "  let i = 0;",
                        "  do {",
                        "    previousParent = currentParent || node;",
                        "    currentParent = path.getParentNode(i);",
                        "    i++;",
                        "  } while (",
                        "    currentParent &&",
                        "    currentParent.type === node.type &&",
                        "    testNodePropertyNames.every(",
                        "      (prop) => currentParent[prop] !== previousParent",
                        "    )",
                        "  );",
                        "  const firstNonConditionalParent = currentParent || parent;",
                        "  const lastConditionalParent = previousParent;",
                        "",
                        "  if (",
                        "    isConditionalExpression &&",
                        "    (isJsxNode(node[testNodePropertyNames[0]]) ||",
                        "      isJsxNode(consequentNode) ||",
                        "      isJsxNode(alternateNode) ||",
                        "      conditionalExpressionChainContainsJsx(lastConditionalParent))",
                        "  ) {",
                        "    jsxMode = true;",
                        "    forceNoIndent = true;",
                        "",
                        "    // Even though they don't need parens, we wrap (almost) everything in",
                        "    // parens when using ?: within JSX, because the parens are analogous to",
                        "    // curly braces in an if statement.",
                        "    const wrap = (doc) => [",
                        "      ifBreak(\"(\"),",
                        "      indent([softline, doc]),",
                        "      softline,",
                        "      ifBreak(\")\"),",
                        "    ];",
                        "",
                        "    // The only things we don't wrap are:",
                        "    // * Nested conditional expressions in alternates",
                        "    // * null",
                        "    // * undefined",
                        "    const isNil = (node) =>",
                        "      node.type === \"NullLiteral\" ||",
                        "      (node.type === \"Literal\" && node.value === null) ||",
                        "      (node.type === \"Identifier\" && node.name === \"undefined\");",
                        "",
                        "    parts.push(",
                        "      \" ? \",",
                        "      isNil(consequentNode)",
                        "        ? print(consequentNodePropertyName)",
                        "        : wrap(print(consequentNodePropertyName)),",
                        "      \" : \",",
                        "      alternateNode.type === node.type || isNil(alternateNode)",
                        "        ? print(alternateNodePropertyName)",
                        "        : wrap(print(alternateNodePropertyName))",
                        "    );",
                        "  } else {",
                        "    // normal mode",
                        "    const part = [",
                        "      line,",
                        "      \"? \",",
                        "      consequentNode.type === node.type ? ifBreak(\"\", \"(\") : \"\",",
                        "      align(2, print(consequentNodePropertyName)),",
                        "      consequentNode.type === node.type ? ifBreak(\"\", \")\") : \"\",",
                        "      line,",
                        "      \": \",",
                        "      alternateNode.type === node.type",
                        "        ? print(alternateNodePropertyName)",
                        "        : align(2, print(alternateNodePropertyName)),",
                        "    ];",
                        "    parts.push(",
                        "      parent.type !== node.type ||",
                        "        parent[alternateNodePropertyName] === node ||",
                        "        isParentTest",
                        "        ? part",
                        "        : options.useTabs",
                        "        ? dedent(indent(part))",
                        "        : align(Math.max(0, options.tabWidth - 2), part)",
                        "    );",
                        "  }",
                        "",
                        "  // We want a whole chain of ConditionalExpressions to all",
                        "  // break if any of them break. That means we should only group around the",
                        "  // outer-most ConditionalExpression.",
                        "  const comments = [",
                        "    ...testNodePropertyNames.map((propertyName) =>",
                        "      getComments(node[propertyName])",
                        "    ),",
                        "    getComments(consequentNode),",
                        "    getComments(alternateNode),",
                        "  ].flat();",
                        "  const shouldBreak = comments.some(",
                        "    (comment) =>",
                        "      isBlockComment(comment) &&",
                        "      hasNewlineInRange(",
                        "        options.originalText,",
                        "        locStart(comment),",
                        "        locEnd(comment)",
                        "      )",
                        "  );",
                        "  const maybeGroup = (doc) =>",
                        "    parent === firstNonConditionalParent",
                        "      ? group(doc, { shouldBreak })",
                        "      : shouldBreak",
                        "      ? [doc, breakParent]",
                        "      : doc;",
                        "",
                        "  // Break the closing paren to keep the chain right after it:",
                        "  // (a",
                        "  //   ? b",
                        "  //   : c",
                        "  // ).call()",
                        "  const breakClosingParen =",
                        "    !jsxMode &&",
                        "    (isMemberExpression(parent) ||",
                        "      (parent.type === \"NGPipeExpression\" && parent.left === node)) &&",
                        "    !parent.computed;",
                        "",
                        "  const shouldExtraIndent = shouldExtraIndentForConditionalExpression(path);",
                        "",
                        "  const result = maybeGroup([",
                        "    printTernaryTest(path, options, print),",
                        "    forceNoIndent ? parts : indent(parts),",
                        "    isConditionalExpression && breakClosingParen && !shouldExtraIndent",
                        "      ? softline",
                        "      : \"\",",
                        "  ]);",
                        "",
                        "  return isParentTest || shouldExtraIndent",
                        "    ? group([indent([softline, result]), softline])",
                        "    : result;",
                        "}",
                        "",
                        "module.exports = { printTernary };"
                    ]
                },
                "type-annotation.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "} = require(\"../../main/comments.js\");",
                        "const { getLast, isNonEmptyArray } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: { group, join, line, softline, indent, align, ifBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const pathNeedsParens = require(\"../needs-parens.js\");",
                        "const { locStart } = require(\"../loc.js\");",
                        "const {",
                        "  isSimpleType,",
                        "  isObjectType,",
                        "  hasLeadingOwnLineComment,",
                        "  isObjectTypePropertyAFunction,",
                        "  shouldPrintComma,",
                        "} = require(\"../utils/index.js\");",
                        "const { printAssignment } = require(\"./assignment.js\");",
                        "const {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} = require(\"./function-parameters.js\");",
                        "const { printArrayItems } = require(\"./array.js\");",
                        "",
                        "function shouldHugType(node) {",
                        "  if (isSimpleType(node) || isObjectType(node)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {",
                        "    const voidCount = node.types.filter(",
                        "      (node) =>",
                        "        node.type === \"VoidTypeAnnotation\" ||",
                        "        node.type === \"TSVoidKeyword\" ||",
                        "        node.type === \"NullLiteralTypeAnnotation\" ||",
                        "        node.type === \"TSNullKeyword\"",
                        "    ).length;",
                        "",
                        "    const hasObject = node.types.some(",
                        "      (node) =>",
                        "        node.type === \"ObjectTypeAnnotation\" ||",
                        "        node.type === \"TSTypeLiteral\" ||",
                        "        // This is a bit aggressive but captures Array<{x}>",
                        "        node.type === \"GenericTypeAnnotation\" ||",
                        "        node.type === \"TSTypeReference\"",
                        "    );",
                        "",
                        "    if (node.types.length - 1 === voidCount && hasObject) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function printOpaqueType(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  parts.push(\"opaque type \", print(\"id\"), print(\"typeParameters\"));",
                        "",
                        "  if (node.supertype) {",
                        "    parts.push(\": \", print(\"supertype\"));",
                        "  }",
                        "",
                        "  if (node.impltype) {",
                        "    parts.push(\" = \", print(\"impltype\"));",
                        "  }",
                        "",
                        "  parts.push(semi);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printTypeAlias(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  if (node.declare) {",
                        "    parts.push(\"declare \");",
                        "  }",
                        "  parts.push(\"type \", print(\"id\"), print(\"typeParameters\"));",
                        "  const rightPropertyName =",
                        "    node.type === \"TSTypeAliasDeclaration\" ? \"typeAnnotation\" : \"right\";",
                        "  return [",
                        "    printAssignment(path, options, print, parts, \" =\", rightPropertyName),",
                        "    semi,",
                        "  ];",
                        "}",
                        "",
                        "// `TSIntersectionType` and `IntersectionTypeAnnotation`",
                        "function printIntersectionType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const types = path.map(print, \"types\");",
                        "  const result = [];",
                        "  let wasIndented = false;",
                        "  for (let i = 0; i < types.length; ++i) {",
                        "    if (i === 0) {",
                        "      result.push(types[i]);",
                        "    } else if (isObjectType(node.types[i - 1]) && isObjectType(node.types[i])) {",
                        "      // If both are objects, don't indent",
                        "      result.push([\" & \", wasIndented ? indent(types[i]) : types[i]]);",
                        "    } else if (",
                        "      !isObjectType(node.types[i - 1]) &&",
                        "      !isObjectType(node.types[i])",
                        "    ) {",
                        "      // If no object is involved, go to the next line if it breaks",
                        "      result.push(indent([\" &\", line, types[i]]));",
                        "    } else {",
                        "      // If you go from object to non-object or vis-versa, then inline it",
                        "      if (i > 1) {",
                        "        wasIndented = true;",
                        "      }",
                        "      result.push(\" & \", i > 1 ? indent(types[i]) : types[i]);",
                        "    }",
                        "  }",
                        "  return group(result);",
                        "}",
                        "",
                        "// `TSUnionType` and `UnionTypeAnnotation`",
                        "function printUnionType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  // single-line variation",
                        "  // A | B | C",
                        "",
                        "  // multi-line variation",
                        "  // | A",
                        "  // | B",
                        "  // | C",
                        "",
                        "  const parent = path.getParentNode();",
                        "",
                        "  // If there's a leading comment, the parent is doing the indentation",
                        "  const shouldIndent =",
                        "    parent.type !== \"TypeParameterInstantiation\" &&",
                        "    parent.type !== \"TSTypeParameterInstantiation\" &&",
                        "    parent.type !== \"GenericTypeAnnotation\" &&",
                        "    parent.type !== \"TSTypeReference\" &&",
                        "    parent.type !== \"TSTypeAssertion\" &&",
                        "    parent.type !== \"TupleTypeAnnotation\" &&",
                        "    parent.type !== \"TSTupleType\" &&",
                        "    !(",
                        "      parent.type === \"FunctionTypeParam\" &&",
                        "      !parent.name &&",
                        "      path.getParentNode(1).this !== parent",
                        "    ) &&",
                        "    !(",
                        "      (parent.type === \"TypeAlias\" ||",
                        "        parent.type === \"VariableDeclarator\" ||",
                        "        parent.type === \"TSTypeAliasDeclaration\") &&",
                        "      hasLeadingOwnLineComment(options.originalText, node)",
                        "    );",
                        "",
                        "  // {",
                        "  //   a: string",
                        "  // } | null | void",
                        "  // should be inlined and not be printed in the multi-line variant",
                        "  const shouldHug = shouldHugType(node);",
                        "",
                        "  // We want to align the children but without its comment, so it looks like",
                        "  // | child1",
                        "  // // comment",
                        "  // | child2",
                        "  const printed = path.map((typePath) => {",
                        "    let printedType = print();",
                        "    if (!shouldHug) {",
                        "      printedType = align(2, printedType);",
                        "    }",
                        "    return printComments(typePath, printedType, options);",
                        "  }, \"types\");",
                        "",
                        "  if (shouldHug) {",
                        "    return join(\" | \", printed);",
                        "  }",
                        "",
                        "  const shouldAddStartLine =",
                        "    shouldIndent && !hasLeadingOwnLineComment(options.originalText, node);",
                        "",
                        "  const code = [",
                        "    ifBreak([shouldAddStartLine ? line : \"\", \"| \"]),",
                        "    join([line, \"| \"], printed),",
                        "  ];",
                        "",
                        "  if (pathNeedsParens(path, options)) {",
                        "    return group([indent(code), softline]);",
                        "  }",
                        "",
                        "  if (",
                        "    (parent.type === \"TupleTypeAnnotation\" && parent.types.length > 1) ||",
                        "    (parent.type === \"TSTupleType\" && parent.elementTypes.length > 1)",
                        "  ) {",
                        "    return group([",
                        "      indent([ifBreak([\"(\", softline]), code]),",
                        "      softline,",
                        "      ifBreak(\")\"),",
                        "    ]);",
                        "  }",
                        "",
                        "  return group(shouldIndent ? indent(code) : code);",
                        "}",
                        "",
                        "// `TSFunctionType` and `FunctionTypeAnnotation`",
                        "function printFunctionType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  // FunctionTypeAnnotation is ambiguous:",
                        "  // declare function foo(a: B): void; OR",
                        "  // var A: (a: B) => void;",
                        "  const parent = path.getParentNode(0);",
                        "  const parentParent = path.getParentNode(1);",
                        "  const parentParentParent = path.getParentNode(2);",
                        "  let isArrowFunctionTypeAnnotation =",
                        "    node.type === \"TSFunctionType\" ||",
                        "    !(",
                        "      ((parent.type === \"ObjectTypeProperty\" ||",
                        "        parent.type === \"ObjectTypeInternalSlot\") &&",
                        "        !parent.variance &&",
                        "        !parent.optional &&",
                        "        locStart(parent) === locStart(node)) ||",
                        "      parent.type === \"ObjectTypeCallProperty\" ||",
                        "      (parentParentParent && parentParentParent.type === \"DeclareFunction\")",
                        "    );",
                        "",
                        "  let needsColon =",
                        "    isArrowFunctionTypeAnnotation &&",
                        "    (parent.type === \"TypeAnnotation\" || parent.type === \"TSTypeAnnotation\");",
                        "",
                        "  // Sadly we can't put it inside of AstPath::needsColon because we are",
                        "  // printing \":\" as part of the expression and it would put parenthesis",
                        "  // around :(",
                        "  const needsParens =",
                        "    needsColon &&",
                        "    isArrowFunctionTypeAnnotation &&",
                        "    (parent.type === \"TypeAnnotation\" || parent.type === \"TSTypeAnnotation\") &&",
                        "    parentParent.type === \"ArrowFunctionExpression\";",
                        "",
                        "  if (isObjectTypePropertyAFunction(parent)) {",
                        "    isArrowFunctionTypeAnnotation = true;",
                        "    needsColon = true;",
                        "  }",
                        "",
                        "  if (needsParens) {",
                        "    parts.push(\"(\");",
                        "  }",
                        "",
                        "  const parametersDoc = printFunctionParameters(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    /* expandArg */ false,",
                        "    /* printTypeParams */ true",
                        "  );",
                        "",
                        "  // The returnType is not wrapped in a TypeAnnotation, so the colon",
                        "  // needs to be added separately.",
                        "  const returnTypeDoc =",
                        "    node.returnType || node.predicate || node.typeAnnotation",
                        "      ? [",
                        "          isArrowFunctionTypeAnnotation ? \" => \" : \": \",",
                        "          print(\"returnType\"),",
                        "          print(\"predicate\"),",
                        "          print(\"typeAnnotation\"),",
                        "        ]",
                        "      : \"\";",
                        "",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "",
                        "  parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);",
                        "",
                        "  if (returnTypeDoc) {",
                        "    parts.push(returnTypeDoc);",
                        "  }",
                        "",
                        "  if (needsParens) {",
                        "    parts.push(\")\");",
                        "  }",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "// `TSTupleType` and `TupleTypeAnnotation`",
                        "function printTupleType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const typesField = node.type === \"TSTupleType\" ? \"elementTypes\" : \"types\";",
                        "  const types = node[typesField];",
                        "  const isNonEmptyTuple = isNonEmptyArray(types);",
                        "  const hasRest = isNonEmptyTuple && getLast(types).type === \"TSRestType\";",
                        "  const bracketsDelimiterLine = isNonEmptyTuple ? softline : \"\";",
                        "  return group([",
                        "    \"[\",",
                        "    indent([",
                        "      bracketsDelimiterLine,",
                        "      printArrayItems(path, options, typesField, print),",
                        "    ]),",
                        "    ifBreak(",
                        "      isNonEmptyTuple && shouldPrintComma(options, \"all\") && !hasRest ? \",\" : \"\"",
                        "    ),",
                        "    printDanglingComments(path, options, /* sameIndent */ true),",
                        "    bracketsDelimiterLine,",
                        "    \"]\",",
                        "  ]);",
                        "}",
                        "",
                        "// `TSIndexedAccessType`, `IndexedAccessType`, and `OptionalIndexedAccessType`",
                        "function printIndexedAccessType(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const leftDelimiter =",
                        "    node.type === \"OptionalIndexedAccessType\" && node.optional ? \"?.[\" : \"[\";",
                        "  return [print(\"objectType\"), leftDelimiter, print(\"indexType\"), \"]\"];",
                        "}",
                        "",
                        "module.exports = {",
                        "  printOpaqueType,",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printTupleType,",
                        "  printIndexedAccessType,",
                        "  shouldHugType,",
                        "};"
                    ]
                },
                "type-parameters.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const {",
                        "  builders: { join, line, hardline, softline, group, indent, ifBreak },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  isTestCall,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isTSXFile,",
                        "  shouldPrintComma,",
                        "  getFunctionParameters,",
                        "  isObjectType,",
                        "} = require(\"../utils/index.js\");",
                        "const { createGroupIdMapper } = require(\"../../common/util.js\");",
                        "const { shouldHugType } = require(\"./type-annotation.js\");",
                        "const { isArrowFunctionVariableDeclarator } = require(\"./assignment.js\");",
                        "",
                        "const getTypeParametersGroupId = createGroupIdMapper(\"typeParameters\");",
                        "",
                        "function printTypeParameters(path, options, print, paramsKey) {",
                        "  const node = path.getValue();",
                        "",
                        "  if (!node[paramsKey]) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // for TypeParameterDeclaration typeParameters is a single node",
                        "  if (!Array.isArray(node[paramsKey])) {",
                        "    return print(paramsKey);",
                        "  }",
                        "",
                        "  const grandparent = path.getNode(2);",
                        "  const isParameterInTestCall = grandparent && isTestCall(grandparent);",
                        "",
                        "  const isArrowFunctionVariable = path.match(",
                        "    (node) =>",
                        "      !(node[paramsKey].length === 1 && isObjectType(node[paramsKey][0])),",
                        "    undefined,",
                        "    (node, name) => name === \"typeAnnotation\",",
                        "    (node) => node.type === \"Identifier\",",
                        "    isArrowFunctionVariableDeclarator",
                        "  );",
                        "",
                        "  const shouldInline =",
                        "    !isArrowFunctionVariable &&",
                        "    (isParameterInTestCall ||",
                        "      node[paramsKey].length === 0 ||",
                        "      (node[paramsKey].length === 1 &&",
                        "        (node[paramsKey][0].type === \"NullableTypeAnnotation\" ||",
                        "          shouldHugType(node[paramsKey][0]))));",
                        "",
                        "  if (shouldInline) {",
                        "    return [",
                        "      \"<\",",
                        "      join(\", \", path.map(print, paramsKey)),",
                        "      printDanglingCommentsForInline(path, options),",
                        "      \">\",",
                        "    ];",
                        "  }",
                        "",
                        "  // Keep comma if the file extension is .tsx and",
                        "  // has one type parameter that isn't extend with any types.",
                        "  // Because, otherwise formatted result will be invalid as tsx.",
                        "  const trailingComma =",
                        "    node.type === \"TSTypeParameterInstantiation\" // https://github.com/microsoft/TypeScript/issues/21984",
                        "      ? \"\"",
                        "      : getFunctionParameters(node).length === 1 &&",
                        "        isTSXFile(options) &&",
                        "        !node[paramsKey][0].constraint &&",
                        "        path.getParentNode().type === \"ArrowFunctionExpression\"",
                        "      ? \",\"",
                        "      : shouldPrintComma(options, \"all\")",
                        "      ? ifBreak(\",\")",
                        "      : \"\";",
                        "",
                        "  return group(",
                        "    [",
                        "      \"<\",",
                        "      indent([softline, join([\",\", line], path.map(print, paramsKey))]),",
                        "      trailingComma,",
                        "      softline,",
                        "      \">\",",
                        "    ],",
                        "    { id: getTypeParametersGroupId(node) }",
                        "  );",
                        "}",
                        "",
                        "function printDanglingCommentsForInline(path, options) {",
                        "  const node = path.getValue();",
                        "  if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    return \"\";",
                        "  }",
                        "  const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);",
                        "  const printed = printDanglingComments(",
                        "    path,",
                        "    options,",
                        "    /* sameIndent */ hasOnlyBlockComments",
                        "  );",
                        "  if (hasOnlyBlockComments) {",
                        "    return printed;",
                        "  }",
                        "  return [printed, hardline];",
                        "}",
                        "",
                        "function printTypeParameter(path, options, print) {",
                        "  const node = path.getValue();",
                        "  const parts = [];",
                        "  const parent = path.getParentNode();",
                        "  if (parent.type === \"TSMappedType\") {",
                        "    parts.push(\"[\", print(\"name\"));",
                        "    if (node.constraint) {",
                        "      parts.push(\" in \", print(\"constraint\"));",
                        "    }",
                        "    if (parent.nameType) {",
                        "      parts.push(",
                        "        \" as \",",
                        "        path.callParent(() => print(\"nameType\"))",
                        "      );",
                        "    }",
                        "    parts.push(\"]\");",
                        "    return parts;",
                        "  }",
                        "",
                        "  if (node.variance) {",
                        "    parts.push(print(\"variance\"));",
                        "  }",
                        "",
                        "  parts.push(print(\"name\"));",
                        "",
                        "  if (node.bound) {",
                        "    parts.push(\": \", print(\"bound\"));",
                        "  }",
                        "",
                        "  if (node.constraint) {",
                        "    parts.push(\" extends \", print(\"constraint\"));",
                        "  }",
                        "",
                        "  if (node.default) {",
                        "    parts.push(\" = \", print(\"default\"));",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printTypeParameter,",
                        "  printTypeParameters,",
                        "  getTypeParametersGroupId,",
                        "};"
                    ]
                },
                "typescript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const { printDanglingComments } = require(\"../../main/comments.js\");",
                        "const { hasNewlineInRange } = require(\"../../common/util.js\");",
                        "const {",
                        "  builders: {",
                        "    join,",
                        "    line,",
                        "    hardline,",
                        "    softline,",
                        "    group,",
                        "    indent,",
                        "    conditionalGroup,",
                        "    ifBreak,",
                        "  },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  isLiteral,",
                        "  getTypeScriptMappedTypeModifier,",
                        "  shouldPrintComma,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "} = require(\"../utils/index.js\");",
                        "const isTsKeywordType = require(\"../utils/is-ts-keyword-type.js\");",
                        "const { locStart, locEnd } = require(\"../loc.js\");",
                        "",
                        "const { printOptionalToken, printTypeScriptModifiers } = require(\"./misc.js\");",
                        "const { printTernary } = require(\"./ternary.js\");",
                        "const {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} = require(\"./function-parameters.js\");",
                        "const { printTemplateLiteral } = require(\"./template-literal.js\");",
                        "const { printArrayItems } = require(\"./array.js\");",
                        "const { printObject } = require(\"./object.js\");",
                        "const { printClassProperty, printClassMethod } = require(\"./class.js\");",
                        "const {",
                        "  printTypeParameter,",
                        "  printTypeParameters,",
                        "} = require(\"./type-parameters.js\");",
                        "const { printPropertyKey } = require(\"./property.js\");",
                        "const { printFunction, printMethodInternal } = require(\"./function.js\");",
                        "const { printInterface } = require(\"./interface.js\");",
                        "const { printBlock } = require(\"./block.js\");",
                        "const {",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printTupleType,",
                        "  printIndexedAccessType,",
                        "} = require(\"./type-annotation.js\");",
                        "",
                        "function printTypescript(path, options, print) {",
                        "  const node = path.getValue();",
                        "",
                        "  // TypeScript nodes always starts with `TS`",
                        "  if (!node.type.startsWith(\"TS\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (isTsKeywordType(node)) {",
                        "    return node.type.slice(2, -7).toLowerCase();",
                        "  }",
                        "",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const parts = [];",
                        "",
                        "  switch (node.type) {",
                        "    case \"TSThisType\":",
                        "      return \"this\";",
                        "    case \"TSTypeAssertion\": {",
                        "      const shouldBreakAfterCast = !(",
                        "        node.expression.type === \"ArrayExpression\" ||",
                        "        node.expression.type === \"ObjectExpression\"",
                        "      );",
                        "",
                        "      const castGroup = group([",
                        "        \"<\",",
                        "        indent([softline, print(\"typeAnnotation\")]),",
                        "        softline,",
                        "        \">\",",
                        "      ]);",
                        "",
                        "      const exprContents = [",
                        "        ifBreak(\"(\"),",
                        "        indent([softline, print(\"expression\")]),",
                        "        softline,",
                        "        ifBreak(\")\"),",
                        "      ];",
                        "",
                        "      if (shouldBreakAfterCast) {",
                        "        return conditionalGroup([",
                        "          [castGroup, print(\"expression\")],",
                        "          [castGroup, group(exprContents, { shouldBreak: true })],",
                        "          [castGroup, print(\"expression\")],",
                        "        ]);",
                        "      }",
                        "      return group([castGroup, print(\"expression\")]);",
                        "    }",
                        "    case \"TSDeclareFunction\":",
                        "      return printFunction(path, print, options);",
                        "    case \"TSExportAssignment\":",
                        "      return [\"export = \", print(\"expression\"), semi];",
                        "    case \"TSModuleBlock\":",
                        "      return printBlock(path, options, print);",
                        "    case \"TSInterfaceBody\":",
                        "    case \"TSTypeLiteral\":",
                        "      return printObject(path, options, print);",
                        "    case \"TSTypeAliasDeclaration\":",
                        "      return printTypeAlias(path, options, print);",
                        "    case \"TSQualifiedName\":",
                        "      return join(\".\", [print(\"left\"), print(\"right\")]);",
                        "    case \"TSAbstractMethodDefinition\":",
                        "    case \"TSDeclareMethod\":",
                        "      return printClassMethod(path, options, print);",
                        "    case \"TSAbstractPropertyDefinition\":",
                        "      return printClassProperty(path, options, print);",
                        "    case \"TSInterfaceHeritage\":",
                        "    case \"TSExpressionWithTypeArguments\": // Babel AST",
                        "      parts.push(print(\"expression\"));",
                        "",
                        "      if (node.typeParameters) {",
                        "        parts.push(print(\"typeParameters\"));",
                        "      }",
                        "",
                        "      return parts;",
                        "    case \"TSTemplateLiteralType\":",
                        "      return printTemplateLiteral(path, print, options);",
                        "    case \"TSNamedTupleMember\":",
                        "      return [",
                        "        print(\"label\"),",
                        "        node.optional ? \"?\" : \"\",",
                        "        \": \",",
                        "        print(\"elementType\"),",
                        "      ];",
                        "    case \"TSRestType\":",
                        "      return [\"...\", print(\"typeAnnotation\")];",
                        "    case \"TSOptionalType\":",
                        "      return [print(\"typeAnnotation\"), \"?\"];",
                        "    case \"TSInterfaceDeclaration\":",
                        "      return printInterface(path, options, print);",
                        "    case \"TSClassImplements\":",
                        "      return [print(\"expression\"), print(\"typeParameters\")];",
                        "    case \"TSTypeParameterDeclaration\":",
                        "    case \"TSTypeParameterInstantiation\":",
                        "      return printTypeParameters(path, options, print, \"params\");",
                        "    case \"TSTypeParameter\":",
                        "      return printTypeParameter(path, options, print);",
                        "    case \"TSAsExpression\": {",
                        "      parts.push(print(\"expression\"), \" as \", print(\"typeAnnotation\"));",
                        "      const parent = path.getParentNode();",
                        "      if (",
                        "        (isCallExpression(parent) && parent.callee === node) ||",
                        "        (isMemberExpression(parent) && parent.object === node)",
                        "      ) {",
                        "        return group([indent([softline, ...parts]), softline]);",
                        "      }",
                        "      return parts;",
                        "    }",
                        "    case \"TSArrayType\":",
                        "      return [print(\"elementType\"), \"[]\"];",
                        "    case \"TSPropertySignature\": {",
                        "      if (node.readonly) {",
                        "        parts.push(\"readonly \");",
                        "      }",
                        "",
                        "      parts.push(",
                        "        printPropertyKey(path, options, print),",
                        "        printOptionalToken(path)",
                        "      );",
                        "",
                        "      if (node.typeAnnotation) {",
                        "        parts.push(\": \", print(\"typeAnnotation\"));",
                        "      }",
                        "",
                        "      // This isn't valid semantically, but it's in the AST so we can print it.",
                        "      if (node.initializer) {",
                        "        parts.push(\" = \", print(\"initializer\"));",
                        "      }",
                        "",
                        "      return parts;",
                        "    }",
                        "    case \"TSParameterProperty\":",
                        "      if (node.accessibility) {",
                        "        parts.push(node.accessibility + \" \");",
                        "      }",
                        "      if (node.export) {",
                        "        parts.push(\"export \");",
                        "      }",
                        "      if (node.static) {",
                        "        parts.push(\"static \");",
                        "      }",
                        "      if (node.override) {",
                        "        parts.push(\"override \");",
                        "      }",
                        "      if (node.readonly) {",
                        "        parts.push(\"readonly \");",
                        "      }",
                        "",
                        "      parts.push(print(\"parameter\"));",
                        "",
                        "      return parts;",
                        "    case \"TSTypeQuery\":",
                        "      return [\"typeof \", print(\"exprName\")];",
                        "    case \"TSIndexSignature\": {",
                        "      const parent = path.getParentNode();",
                        "",
                        "      // The typescript parser accepts multiple parameters here. If you're",
                        "      // using them, it makes sense to have a trailing comma. But if you",
                        "      // aren't, this is more like a computed property name than an array.",
                        "      // So we leave off the trailing comma when there's just one parameter.",
                        "      const trailingComma =",
                        "        node.parameters.length > 1",
                        "          ? ifBreak(shouldPrintComma(options) ? \",\" : \"\")",
                        "          : \"\";",
                        "",
                        "      const parametersGroup = group([",
                        "        indent([",
                        "          softline,",
                        "          join([\", \", softline], path.map(print, \"parameters\")),",
                        "        ]),",
                        "        trailingComma,",
                        "        softline,",
                        "      ]);",
                        "",
                        "      return [",
                        "        node.export ? \"export \" : \"\",",
                        "        node.accessibility ? [node.accessibility, \" \"] : \"\",",
                        "        node.static ? \"static \" : \"\",",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        node.declare ? \"declare \" : \"\",",
                        "        \"[\",",
                        "        node.parameters ? parametersGroup : \"\",",
                        "        node.typeAnnotation ? \"]: \" : \"]\",",
                        "        node.typeAnnotation ? print(\"typeAnnotation\") : \"\",",
                        "        parent.type === \"ClassBody\" ? semi : \"\",",
                        "      ];",
                        "    }",
                        "    case \"TSTypePredicate\":",
                        "      return [",
                        "        node.asserts ? \"asserts \" : \"\",",
                        "        print(\"parameterName\"),",
                        "        node.typeAnnotation ? [\" is \", print(\"typeAnnotation\")] : \"\",",
                        "      ];",
                        "    case \"TSNonNullExpression\":",
                        "      return [print(\"expression\"), \"!\"];",
                        "    case \"TSImportType\":",
                        "      return [",
                        "        !node.isTypeOf ? \"\" : \"typeof \",",
                        "        \"import(\",",
                        "        print(node.parameter ? \"parameter\" : \"argument\"),",
                        "        \")\",",
                        "        !node.qualifier ? \"\" : [\".\", print(\"qualifier\")],",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"TSLiteralType\":",
                        "      return print(\"literal\");",
                        "    case \"TSIndexedAccessType\":",
                        "      return printIndexedAccessType(path, options, print);",
                        "    case \"TSConstructSignatureDeclaration\":",
                        "    case \"TSCallSignatureDeclaration\":",
                        "    case \"TSConstructorType\": {",
                        "      if (node.type === \"TSConstructorType\" && node.abstract) {",
                        "        parts.push(\"abstract \");",
                        "      }",
                        "      if (node.type !== \"TSCallSignatureDeclaration\") {",
                        "        parts.push(\"new \");",
                        "      }",
                        "",
                        "      parts.push(",
                        "        group(",
                        "          printFunctionParameters(",
                        "            path,",
                        "            print,",
                        "            options,",
                        "            /* expandArg */ false,",
                        "            /* printTypeParams */ true",
                        "          )",
                        "        )",
                        "      );",
                        "",
                        "      if (node.returnType || node.typeAnnotation) {",
                        "        const isType = node.type === \"TSConstructorType\";",
                        "        parts.push(",
                        "          isType ? \" => \" : \": \",",
                        "          print(\"returnType\"),",
                        "          print(\"typeAnnotation\")",
                        "        );",
                        "      }",
                        "      return parts;",
                        "    }",
                        "    case \"TSTypeOperator\":",
                        "      return [node.operator, \" \", print(\"typeAnnotation\")];",
                        "    case \"TSMappedType\": {",
                        "      const shouldBreak = hasNewlineInRange(",
                        "        options.originalText,",
                        "        locStart(node),",
                        "        locEnd(node)",
                        "      );",
                        "      return group(",
                        "        [",
                        "          \"{\",",
                        "          indent([",
                        "            options.bracketSpacing ? line : softline,",
                        "            node.readonly",
                        "              ? [",
                        "                  getTypeScriptMappedTypeModifier(node.readonly, \"readonly\"),",
                        "                  \" \",",
                        "                ]",
                        "              : \"\",",
                        "            printTypeScriptModifiers(path, options, print),",
                        "            print(\"typeParameter\"),",
                        "            node.optional",
                        "              ? getTypeScriptMappedTypeModifier(node.optional, \"?\")",
                        "              : \"\",",
                        "            node.typeAnnotation ? \": \" : \"\",",
                        "            print(\"typeAnnotation\"),",
                        "            ifBreak(semi),",
                        "          ]),",
                        "          printDanglingComments(path, options, /* sameIndent */ true),",
                        "          options.bracketSpacing ? line : softline,",
                        "          \"}\",",
                        "        ],",
                        "        { shouldBreak }",
                        "      );",
                        "    }",
                        "    case \"TSMethodSignature\": {",
                        "      const kind = node.kind && node.kind !== \"method\" ? `${node.kind} ` : \"\";",
                        "      parts.push(",
                        "        node.accessibility ? [node.accessibility, \" \"] : \"\",",
                        "        kind,",
                        "        node.export ? \"export \" : \"\",",
                        "        node.static ? \"static \" : \"\",",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        // \"abstract\" and \"declare\" are supported by only \"babel-ts\"",
                        "        // https://github.com/prettier/prettier/issues/9760",
                        "        node.abstract ? \"abstract \" : \"\",",
                        "        node.declare ? \"declare \" : \"\",",
                        "        node.computed ? \"[\" : \"\",",
                        "        print(\"key\"),",
                        "        node.computed ? \"]\" : \"\",",
                        "        printOptionalToken(path)",
                        "      );",
                        "",
                        "      const parametersDoc = printFunctionParameters(",
                        "        path,",
                        "        print,",
                        "        options,",
                        "        /* expandArg */ false,",
                        "        /* printTypeParams */ true",
                        "      );",
                        "",
                        "      const returnTypePropertyName = node.returnType",
                        "        ? \"returnType\"",
                        "        : \"typeAnnotation\";",
                        "      const returnTypeNode = node[returnTypePropertyName];",
                        "      const returnTypeDoc = returnTypeNode ? print(returnTypePropertyName) : \"\";",
                        "      const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "        node,",
                        "        returnTypeDoc",
                        "      );",
                        "",
                        "      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);",
                        "",
                        "      if (returnTypeNode) {",
                        "        parts.push(\": \", group(returnTypeDoc));",
                        "      }",
                        "",
                        "      return group(parts);",
                        "    }",
                        "    case \"TSNamespaceExportDeclaration\":",
                        "      parts.push(\"export as namespace \", print(\"id\"));",
                        "",
                        "      if (options.semi) {",
                        "        parts.push(\";\");",
                        "      }",
                        "",
                        "      return group(parts);",
                        "    case \"TSEnumDeclaration\":",
                        "      if (node.declare) {",
                        "        parts.push(\"declare \");",
                        "      }",
                        "",
                        "      if (node.modifiers) {",
                        "        parts.push(printTypeScriptModifiers(path, options, print));",
                        "      }",
                        "      if (node.const) {",
                        "        parts.push(\"const \");",
                        "      }",
                        "",
                        "      parts.push(\"enum \", print(\"id\"), \" \");",
                        "",
                        "      if (node.members.length === 0) {",
                        "        parts.push(",
                        "          group([\"{\", printDanglingComments(path, options), softline, \"}\"])",
                        "        );",
                        "      } else {",
                        "        parts.push(",
                        "          group([",
                        "            \"{\",",
                        "            indent([",
                        "              hardline,",
                        "              printArrayItems(path, options, \"members\", print),",
                        "              shouldPrintComma(options, \"es5\") ? \",\" : \"\",",
                        "            ]),",
                        "            printDanglingComments(path, options, /* sameIndent */ true),",
                        "            hardline,",
                        "            \"}\",",
                        "          ])",
                        "        );",
                        "      }",
                        "",
                        "      return parts;",
                        "    case \"TSEnumMember\":",
                        "      parts.push(print(\"id\"));",
                        "      if (node.initializer) {",
                        "        parts.push(\" = \", print(\"initializer\"));",
                        "      }",
                        "      return parts;",
                        "    case \"TSImportEqualsDeclaration\":",
                        "      if (node.isExport) {",
                        "        parts.push(\"export \");",
                        "      }",
                        "",
                        "      parts.push(\"import \");",
                        "",
                        "      if (node.importKind && node.importKind !== \"value\") {",
                        "        parts.push(node.importKind, \" \");",
                        "      }",
                        "",
                        "      parts.push(print(\"id\"), \" = \", print(\"moduleReference\"));",
                        "",
                        "      if (options.semi) {",
                        "        parts.push(\";\");",
                        "      }",
                        "",
                        "      return group(parts);",
                        "    case \"TSExternalModuleReference\":",
                        "      return [\"require(\", print(\"expression\"), \")\"];",
                        "    case \"TSModuleDeclaration\": {",
                        "      const parent = path.getParentNode();",
                        "      const isExternalModule = isLiteral(node.id);",
                        "      const parentIsDeclaration = parent.type === \"TSModuleDeclaration\";",
                        "      const bodyIsDeclaration =",
                        "        node.body && node.body.type === \"TSModuleDeclaration\";",
                        "",
                        "      if (parentIsDeclaration) {",
                        "        parts.push(\".\");",
                        "      } else {",
                        "        if (node.declare) {",
                        "          parts.push(\"declare \");",
                        "        }",
                        "        parts.push(printTypeScriptModifiers(path, options, print));",
                        "",
                        "        const textBetweenNodeAndItsId = options.originalText.slice(",
                        "          locStart(node),",
                        "          locStart(node.id)",
                        "        );",
                        "",
                        "        // Global declaration looks like this:",
                        "        // (declare)? global { ... }",
                        "        const isGlobalDeclaration =",
                        "          node.id.type === \"Identifier\" &&",
                        "          node.id.name === \"global\" &&",
                        "          !/namespace|module/.test(textBetweenNodeAndItsId);",
                        "",
                        "        if (!isGlobalDeclaration) {",
                        "          parts.push(",
                        "            isExternalModule ||",
                        "              /(?:^|\\s)module(?:\\s|$)/.test(textBetweenNodeAndItsId)",
                        "              ? \"module \"",
                        "              : \"namespace \"",
                        "          );",
                        "        }",
                        "      }",
                        "",
                        "      parts.push(print(\"id\"));",
                        "",
                        "      if (bodyIsDeclaration) {",
                        "        parts.push(print(\"body\"));",
                        "      } else if (node.body) {",
                        "        parts.push(\" \", group(print(\"body\")));",
                        "      } else {",
                        "        parts.push(semi);",
                        "      }",
                        "",
                        "      return parts;",
                        "    }",
                        "",
                        "    case \"TSConditionalType\":",
                        "      return printTernary(path, options, print);",
                        "",
                        "    case \"TSInferType\":",
                        "      return [\"infer\", \" \", print(\"typeParameter\")];",
                        "    case \"TSIntersectionType\":",
                        "      return printIntersectionType(path, options, print);",
                        "    case \"TSUnionType\":",
                        "      return printUnionType(path, options, print);",
                        "    case \"TSFunctionType\":",
                        "      return printFunctionType(path, options, print);",
                        "    case \"TSTupleType\":",
                        "      return printTupleType(path, options, print);",
                        "    case \"TSTypeReference\":",
                        "      return [",
                        "        print(\"typeName\"),",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"TSTypeAnnotation\":",
                        "      return print(\"typeAnnotation\");",
                        "    case \"TSEmptyBodyFunctionExpression\":",
                        "      return printMethodInternal(path, options, print);",
                        "",
                        "    // These are not valid TypeScript. Printing them just for the sake of error recovery.",
                        "    case \"TSJSDocAllType\":",
                        "      return \"*\";",
                        "    case \"TSJSDocUnknownType\":",
                        "      return \"?\";",
                        "    case \"TSJSDocNullableType\":",
                        "      return [\"?\", print(\"typeAnnotation\")];",
                        "    case \"TSJSDocNonNullableType\":",
                        "      return [\"!\", print(\"typeAnnotation\")];",
                        "    default:",
                        "      /* istanbul ignore next */",
                        "      throw new Error(",
                        "        `Unknown TypeScript node type: ${JSON.stringify(node.type)}.`",
                        "      );",
                        "  }",
                        "}",
                        "",
                        "module.exports = { printTypescript };"
                    ]
                }
            },
            "types": {
                "estree.d.ts": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as ESTree from \"estree\";",
                        "import * as Babel from \"@babel/types\";",
                        "import { TSESTree } from \"@typescript-eslint/typescript-estree\";",
                        "import { ESTree as Meriyah } from \"meriyah\";",
                        "import * as NGTree from \"angular-estree-parser/lib/types\";",
                        "",
                        "type AdditionalFields = {",
                        "  extra?: {",
                        "    parenthesized?: boolean;",
                        "    raw?: string;",
                        "  };",
                        "  comments?: Comment[];",
                        "  trailingComments?: ReadonlyArray<Comment> | Comment[];",
                        "  leadingComments?: ReadonlyArray<Comment> | Comment[];",
                        "};",
                        "",
                        "export type Comment = (",
                        "  | ESTree.Comment",
                        "  | Babel.Comment",
                        "  | TSESTree.Comment",
                        "  | Meriyah.Comment",
                        ") & {",
                        "  printed?: boolean;",
                        "  trailing?: boolean;",
                        "  leading?: boolean;",
                        "};",
                        "",
                        "export type Node = (ESTree.Node | Babel.Node | TSESTree.Node | NGTree.NGNode) &",
                        "  AdditionalFields;",
                        "",
                        "export type TemplateLiteral = (",
                        "  | ESTree.TemplateLiteral",
                        "  | Babel.TemplateLiteral",
                        "  | TSESTree.TemplateLiteral",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type CallExpression = (",
                        "  | ESTree.CallExpression",
                        "  | Babel.CallExpression",
                        "  | TSESTree.CallExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type OptionalCallExpression = Babel.OptionalCallExpression &",
                        "  AdditionalFields;",
                        "",
                        "export type MemberExpression = (",
                        "  | ESTree.MemberExpression",
                        "  | Babel.MemberExpression",
                        "  | TSESTree.MemberExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type OptionalMemberExpression = Babel.OptionalMemberExpression &",
                        "  AdditionalFields;",
                        "",
                        "export type Expression = (",
                        "  | ESTree.Expression",
                        "  | Babel.Expression",
                        "  | TSESTree.Expression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type BindExpression = Babel.BindExpression & AdditionalFields;",
                        "",
                        "export type Property = (ESTree.Property | Babel.Property | TSESTree.Property) &",
                        "  AdditionalFields;",
                        "",
                        "export type ClassPrivateProperty = Babel.ClassPrivateProperty &",
                        "  AdditionalFields;",
                        "",
                        "export type ObjectTypeProperty = Babel.ObjectTypeProperty & AdditionalFields;",
                        "",
                        "export type JSXElement = (Babel.JSXElement | TSESTree.JSXElement) &",
                        "  AdditionalFields;",
                        "",
                        "export type TaggedTemplateExpression = (",
                        "  | ESTree.TaggedTemplateExpression",
                        "  | Babel.TaggedTemplateExpression",
                        "  | TSESTree.TaggedTemplateExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type Literal = (ESTree.Literal | Babel.Literal | TSESTree.Literal) &",
                        "  AdditionalFields;",
                        "",
                        "export { ESTree, Babel, TSESTree, NGTree };"
                    ]
                }
            },
            "utils": {
                "get-shebang.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function getShebang(text) {",
                        "  if (!text.startsWith(\"#!\")) {",
                        "    return \"\";",
                        "  }",
                        "  const index = text.indexOf(\"\\n\");",
                        "  if (index === -1) {",
                        "    return text;",
                        "  }",
                        "  return text.slice(0, index);",
                        "}",
                        "",
                        "module.exports = getShebang;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const isIdentifierName = require(\"esutils\").keyword.isIdentifierNameES5;",
                        "const {",
                        "  getLast,",
                        "  hasNewline,",
                        "  skipWhitespace,",
                        "  isNonEmptyArray,",
                        "  isNextLineEmptyAfterIndex,",
                        "  getStringWidth,",
                        "} = require(\"../../common/util.js\");",
                        "const { locStart, locEnd, hasSameLocStart } = require(\"../loc.js\");",
                        "const isBlockComment = require(\"./is-block-comment.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree\").Node} Node",
                        " * @typedef {import(\"../types/estree\").TemplateLiteral} TemplateLiteral",
                        " * @typedef {import(\"../types/estree\").Comment} Comment",
                        " * @typedef {import(\"../types/estree\").MemberExpression} MemberExpression",
                        " * @typedef {import(\"../types/estree\").OptionalMemberExpression} OptionalMemberExpression",
                        " * @typedef {import(\"../types/estree\").CallExpression} CallExpression",
                        " * @typedef {import(\"../types/estree\").OptionalCallExpression} OptionalCallExpression",
                        " * @typedef {import(\"../types/estree\").Expression} Expression",
                        " * @typedef {import(\"../types/estree\").Property} Property",
                        " * @typedef {import(\"../types/estree\").ObjectTypeProperty} ObjectTypeProperty",
                        " * @typedef {import(\"../types/estree\").TaggedTemplateExpression} TaggedTemplateExpression",
                        " * @typedef {import(\"../types/estree\").Literal} Literal",
                        " *",
                        " * @typedef {import(\"../../common/ast-path\")} AstPath",
                        " */",
                        "",
                        "// We match any whitespace except line terminators because",
                        "// Flow annotation comments cannot be split across lines. For example:",
                        "//",
                        "// (this /*",
                        "// : any */).foo = 5;",
                        "//",
                        "// is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so",
                        "// removing the newline would create a type annotation that the user did not intend",
                        "// to create.",
                        "const NON_LINE_TERMINATING_WHITE_SPACE = \"(?:(?=.)\\\\s)\";",
                        "const FLOW_SHORTHAND_ANNOTATION = new RegExp(",
                        "  `^${NON_LINE_TERMINATING_WHITE_SPACE}*:`",
                        ");",
                        "const FLOW_ANNOTATION = new RegExp(`^${NON_LINE_TERMINATING_WHITE_SPACE}*::`);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasFlowShorthandAnnotationComment(node) {",
                        "  // https://flow.org/en/docs/types/comments/",
                        "  // Syntax example: const r = new (window.Request /*: Class<Request> */)(\"\");",
                        "",
                        "  return (",
                        "    node.extra &&",
                        "    node.extra.parenthesized &&",
                        "    isNonEmptyArray(node.trailingComments) &&",
                        "    isBlockComment(node.trailingComments[0]) &&",
                        "    FLOW_SHORTHAND_ANNOTATION.test(node.trailingComments[0].value)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Comment[]} comments",
                        " * @returns {boolean}",
                        " */",
                        "function hasFlowAnnotationComment(comments) {",
                        "  return (",
                        "    isNonEmptyArray(comments) &&",
                        "    isBlockComment(comments[0]) &&",
                        "    FLOW_ANNOTATION.test(comments[0].value)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {(Node) => boolean} fn",
                        " * @returns {boolean}",
                        " */",
                        "function hasNode(node, fn) {",
                        "  if (!node || typeof node !== \"object\") {",
                        "    return false;",
                        "  }",
                        "  if (Array.isArray(node)) {",
                        "    return node.some((value) => hasNode(value, fn));",
                        "  }",
                        "  const result = fn(node);",
                        "  return typeof result === \"boolean\"",
                        "    ? result",
                        "    : Object.values(node).some((value) => hasNode(value, fn));",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasNakedLeftSide(node) {",
                        "  return (",
                        "    node.type === \"AssignmentExpression\" ||",
                        "    node.type === \"BinaryExpression\" ||",
                        "    node.type === \"LogicalExpression\" ||",
                        "    node.type === \"NGPipeExpression\" ||",
                        "    node.type === \"ConditionalExpression\" ||",
                        "    isCallExpression(node) ||",
                        "    isMemberExpression(node) ||",
                        "    node.type === \"SequenceExpression\" ||",
                        "    node.type === \"TaggedTemplateExpression\" ||",
                        "    node.type === \"BindExpression\" ||",
                        "    (node.type === \"UpdateExpression\" && !node.prefix) ||",
                        "    node.type === \"TSAsExpression\" ||",
                        "    node.type === \"TSNonNullExpression\"",
                        "  );",
                        "}",
                        "",
                        "function getLeftSide(node) {",
                        "  if (node.expressions) {",
                        "    return node.expressions[0];",
                        "  }",
                        "  return (",
                        "    node.left ||",
                        "    node.test ||",
                        "    node.callee ||",
                        "    node.object ||",
                        "    node.tag ||",
                        "    node.argument ||",
                        "    node.expression",
                        "  );",
                        "}",
                        "",
                        "function getLeftSidePathName(path, node) {",
                        "  if (node.expressions) {",
                        "    return [\"expressions\", 0];",
                        "  }",
                        "  if (node.left) {",
                        "    return [\"left\"];",
                        "  }",
                        "  if (node.test) {",
                        "    return [\"test\"];",
                        "  }",
                        "  if (node.object) {",
                        "    return [\"object\"];",
                        "  }",
                        "  if (node.callee) {",
                        "    return [\"callee\"];",
                        "  }",
                        "  if (node.tag) {",
                        "    return [\"tag\"];",
                        "  }",
                        "  if (node.argument) {",
                        "    return [\"argument\"];",
                        "  }",
                        "  if (node.expression) {",
                        "    return [\"expression\"];",
                        "  }",
                        "  throw new Error(\"Unexpected node has no left side.\");",
                        "}",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "function isLineComment(comment) {",
                        "  return (",
                        "    comment.type === \"Line\" ||",
                        "    comment.type === \"CommentLine\" ||",
                        "    // `meriyah` has `SingleLine`, `HashbangComment`, `HTMLOpen`, and `HTMLClose`",
                        "    comment.type === \"SingleLine\" ||",
                        "    comment.type === \"HashbangComment\" ||",
                        "    comment.type === \"HTMLOpen\" ||",
                        "    comment.type === \"HTMLClose\"",
                        "  );",
                        "}",
                        "",
                        "const exportDeclarationTypes = new Set([",
                        "  \"ExportDefaultDeclaration\",",
                        "  \"ExportDefaultSpecifier\",",
                        "  \"DeclareExportDeclaration\",",
                        "  \"ExportNamedDeclaration\",",
                        "  \"ExportAllDeclaration\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isExportDeclaration(node) {",
                        "  return node && exportDeclarationTypes.has(node.type);",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {Node | null}",
                        " */",
                        "function getParentExportDeclaration(path) {",
                        "  const parentNode = path.getParentNode();",
                        "  if (path.getName() === \"declaration\" && isExportDeclaration(parentNode)) {",
                        "    return parentNode;",
                        "  }",
                        "",
                        "  return null;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isLiteral(node) {",
                        "  return (",
                        "    node.type === \"BooleanLiteral\" ||",
                        "    node.type === \"DirectiveLiteral\" ||",
                        "    node.type === \"Literal\" ||",
                        "    node.type === \"NullLiteral\" ||",
                        "    node.type === \"NumericLiteral\" ||",
                        "    node.type === \"BigIntLiteral\" ||",
                        "    node.type === \"DecimalLiteral\" ||",
                        "    node.type === \"RegExpLiteral\" ||",
                        "    node.type === \"StringLiteral\" ||",
                        "    node.type === \"TemplateLiteral\" ||",
                        "    node.type === \"TSTypeLiteral\" ||",
                        "    node.type === \"JSXText\"",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isNumericLiteral(node) {",
                        "  return (",
                        "    node.type === \"NumericLiteral\" ||",
                        "    (node.type === \"Literal\" && typeof node.value === \"number\")",
                        "  );",
                        "}",
                        "",
                        "function isSignedNumericLiteral(node) {",
                        "  return (",
                        "    node.type === \"UnaryExpression\" &&",
                        "    (node.operator === \"+\" || node.operator === \"-\") &&",
                        "    isNumericLiteral(node.argument)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isStringLiteral(node) {",
                        "  return (",
                        "    node.type === \"StringLiteral\" ||",
                        "    (node.type === \"Literal\" && typeof node.value === \"string\")",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isObjectType(node) {",
                        "  return (",
                        "    node.type === \"ObjectTypeAnnotation\" ||",
                        "    node.type === \"TSTypeLiteral\" ||",
                        "    node.type === \"TSMappedType\"",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isFunctionOrArrowExpression(node) {",
                        "  return (",
                        "    node.type === \"FunctionExpression\" ||",
                        "    node.type === \"ArrowFunctionExpression\"",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isFunctionOrArrowExpressionWithBody(node) {",
                        "  return (",
                        "    node.type === \"FunctionExpression\" ||",
                        "    (node.type === \"ArrowFunctionExpression\" &&",
                        "      node.body.type === \"BlockStatement\")",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isTemplateLiteral(node) {",
                        "  return node.type === \"TemplateLiteral\";",
                        "}",
                        "",
                        "/**",
                        " * Note: `inject` is used in AngularJS 1.x, `async` and `fakeAsync` in",
                        " * Angular 2+, although `async` is deprecated and replaced by `waitForAsync`",
                        " * since Angular 12.",
                        " *",
                        " * example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-",
                        " *",
                        " * @param {CallExpression} node",
                        " * @returns {boolean}",
                        " */",
                        "function isAngularTestWrapper(node) {",
                        "  return (",
                        "    isCallExpression(node) &&",
                        "    node.callee.type === \"Identifier\" &&",
                        "    [\"async\", \"inject\", \"fakeAsync\", \"waitForAsync\"].includes(node.callee.name)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isJsxNode(node) {",
                        "  return node.type === \"JSXElement\" || node.type === \"JSXFragment\";",
                        "}",
                        "",
                        "function isTheOnlyJsxElementInMarkdown(options, path) {",
                        "  if (options.parentParser !== \"markdown\" && options.parentParser !== \"mdx\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  const node = path.getNode();",
                        "",
                        "  if (!node.expression || !isJsxNode(node.expression)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const parent = path.getParentNode();",
                        "",
                        "  return parent.type === \"Program\" && parent.body.length === 1;",
                        "}",
                        "",
                        "function isGetterOrSetter(node) {",
                        "  return node.kind === \"get\" || node.kind === \"set\";",
                        "}",
                        "",
                        "// TODO: This is a bad hack and we need a better way to distinguish between",
                        "// arrow functions and otherwise",
                        "function isFunctionNotation(node) {",
                        "  return isGetterOrSetter(node) || hasSameLocStart(node, node.value);",
                        "}",
                        "",
                        "// Hack to differentiate between the following two which have the same ast",
                        "// type T = { method: () => void };",
                        "// type T = { method(): void };",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isObjectTypePropertyAFunction(node) {",
                        "  return (",
                        "    (node.type === \"ObjectTypeProperty\" ||",
                        "      node.type === \"ObjectTypeInternalSlot\") &&",
                        "    node.value.type === \"FunctionTypeAnnotation\" &&",
                        "    !node.static &&",
                        "    !isFunctionNotation(node)",
                        "  );",
                        "}",
                        "",
                        "// Hack to differentiate between the following two which have the same ast",
                        "// declare function f(a): void;",
                        "// var f: (a) => void;",
                        "function isTypeAnnotationAFunction(node) {",
                        "  return (",
                        "    (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") &&",
                        "    node.typeAnnotation.type === \"FunctionTypeAnnotation\" &&",
                        "    !node.static &&",
                        "    !hasSameLocStart(node, node.typeAnnotation)",
                        "  );",
                        "}",
                        "",
                        "const binaryishNodeTypes = new Set([",
                        "  \"BinaryExpression\",",
                        "  \"LogicalExpression\",",
                        "  \"NGPipeExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isBinaryish(node) {",
                        "  return binaryishNodeTypes.has(node.type);",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isMemberish(node) {",
                        "  return (",
                        "    isMemberExpression(node) ||",
                        "    (node.type === \"BindExpression\" && Boolean(node.object))",
                        "  );",
                        "}",
                        "",
                        "const simpleTypeAnnotations = new Set([",
                        "  // `any`",
                        "  \"AnyTypeAnnotation\",",
                        "  \"TSAnyKeyword\",",
                        "  // `null`",
                        "  \"NullLiteralTypeAnnotation\",",
                        "  \"TSNullKeyword\",",
                        "  // `this`",
                        "  \"ThisTypeAnnotation\",",
                        "  \"TSThisType\",",
                        "  // `number`",
                        "  \"NumberTypeAnnotation\",",
                        "  \"TSNumberKeyword\",",
                        "  // `void`",
                        "  \"VoidTypeAnnotation\",",
                        "  \"TSVoidKeyword\",",
                        "  // `boolean`",
                        "  \"BooleanTypeAnnotation\",",
                        "  \"TSBooleanKeyword\",",
                        "  // `bigint`",
                        "  \"BigIntTypeAnnotation\",",
                        "  \"TSBigIntKeyword\",",
                        "  // `symbol`",
                        "  \"SymbolTypeAnnotation\",",
                        "  \"TSSymbolKeyword\",",
                        "  // `string`",
                        "  \"StringTypeAnnotation\",",
                        "  \"TSStringKeyword\",",
                        "  // literals",
                        "  \"BooleanLiteralTypeAnnotation\",",
                        "  \"StringLiteralTypeAnnotation\",",
                        "  \"BigIntLiteralTypeAnnotation\",",
                        "  \"NumberLiteralTypeAnnotation\",",
                        "  \"TSLiteralType\",",
                        "  \"TSTemplateLiteralType\",",
                        "  // flow only, `empty`, `mixed`",
                        "  \"EmptyTypeAnnotation\",",
                        "  \"MixedTypeAnnotation\",",
                        "  // typescript only, `never`, `object`, `undefined`, `unknown`",
                        "  \"TSNeverKeyword\",",
                        "  \"TSObjectKeyword\",",
                        "  \"TSUndefinedKeyword\",",
                        "  \"TSUnknownKeyword\",",
                        "]);",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleType(node) {",
                        "  if (!node) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    (node.type === \"GenericTypeAnnotation\" ||",
                        "      node.type === \"TSTypeReference\") &&",
                        "    !node.typeParameters",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (simpleTypeAnnotations.has(node.type)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "const unitTestRe = /^(?:skip|[fx]?(?:it|describe|test))$/;",
                        "",
                        "/**",
                        " * @param {{callee: MemberExpression | OptionalMemberExpression}} node",
                        " * @returns {boolean}",
                        " */",
                        "function isSkipOrOnlyBlock(node) {",
                        "  return (",
                        "    isMemberExpression(node.callee) &&",
                        "    node.callee.object.type === \"Identifier\" &&",
                        "    node.callee.property.type === \"Identifier\" &&",
                        "    unitTestRe.test(node.callee.object.name) &&",
                        "    (node.callee.property.name === \"only\" ||",
                        "      node.callee.property.name === \"skip\")",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {CallExpression} node",
                        " * @returns {boolean}",
                        " */",
                        "function isUnitTestSetUp(node) {",
                        "  const unitTestSetUpRe = /^(?:before|after)(?:Each|All)$/;",
                        "  return (",
                        "    node.callee.type === \"Identifier\" &&",
                        "    unitTestSetUpRe.test(node.callee.name) &&",
                        "    node.arguments.length === 1",
                        "  );",
                        "}",
                        "",
                        "// eg; `describe(\"some string\", (done) => {})`",
                        "function isTestCall(node, parent) {",
                        "  if (node.type !== \"CallExpression\") {",
                        "    return false;",
                        "  }",
                        "  if (node.arguments.length === 1) {",
                        "    if (isAngularTestWrapper(node) && parent && isTestCall(parent)) {",
                        "      return isFunctionOrArrowExpression(node.arguments[0]);",
                        "    }",
                        "",
                        "    if (isUnitTestSetUp(node)) {",
                        "      return isAngularTestWrapper(node.arguments[0]);",
                        "    }",
                        "  } else if (node.arguments.length === 2 || node.arguments.length === 3) {",
                        "    if (",
                        "      ((node.callee.type === \"Identifier\" &&",
                        "        unitTestRe.test(node.callee.name)) ||",
                        "        isSkipOrOnlyBlock(node)) &&",
                        "      (isTemplateLiteral(node.arguments[0]) ||",
                        "        isStringLiteral(node.arguments[0]))",
                        "    ) {",
                        "      // it(\"name\", () => { ... }, 2500)",
                        "      if (node.arguments[2] && !isNumericLiteral(node.arguments[2])) {",
                        "        return false;",
                        "      }",
                        "      return (",
                        "        (node.arguments.length === 2",
                        "          ? isFunctionOrArrowExpression(node.arguments[1])",
                        "          : isFunctionOrArrowExpressionWithBody(node.arguments[1]) &&",
                        "            getFunctionParameters(node.arguments[1]).length <= 1) ||",
                        "        isAngularTestWrapper(node.arguments[1])",
                        "      );",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isCallExpression(node) {",
                        "  return (",
                        "    node &&",
                        "    (node.type === \"CallExpression\" || node.type === \"OptionalCallExpression\")",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isMemberExpression(node) {",
                        "  return (",
                        "    node &&",
                        "    (node.type === \"MemberExpression\" ||",
                        "      node.type === \"OptionalMemberExpression\")",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " *",
                        " * @param {any} node",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleTemplateLiteral(node) {",
                        "  let expressionsKey = \"expressions\";",
                        "  if (node.type === \"TSTemplateLiteralType\") {",
                        "    expressionsKey = \"types\";",
                        "  }",
                        "  const expressions = node[expressionsKey];",
                        "",
                        "  if (expressions.length === 0) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return expressions.every((expr) => {",
                        "    // Disallow comments since printDocToString can't print them here",
                        "    if (hasComment(expr)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    // Allow `x` and `this`",
                        "    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {",
                        "      return true;",
                        "    }",
                        "",
                        "    // Allow `a.b.c`, `a.b[c]`, and `this.x.y`",
                        "    if (isMemberExpression(expr)) {",
                        "      let head = expr;",
                        "      while (isMemberExpression(head)) {",
                        "        if (",
                        "          head.property.type !== \"Identifier\" &&",
                        "          head.property.type !== \"Literal\" &&",
                        "          head.property.type !== \"StringLiteral\" &&",
                        "          head.property.type !== \"NumericLiteral\"",
                        "        ) {",
                        "          return false;",
                        "        }",
                        "        head = head.object;",
                        "        if (hasComment(head)) {",
                        "          return false;",
                        "        }",
                        "      }",
                        "",
                        "      if (head.type === \"Identifier\" || head.type === \"ThisExpression\") {",
                        "        return true;",
                        "      }",
                        "",
                        "      return false;",
                        "    }",
                        "",
                        "    return false;",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {string} tokenNode",
                        " * @param {string} keyword",
                        " * @returns {string}",
                        " */",
                        "function getTypeScriptMappedTypeModifier(tokenNode, keyword) {",
                        "  if (tokenNode === \"+\") {",
                        "    return \"+\" + keyword;",
                        "  }",
                        "",
                        "  if (tokenNode === \"-\") {",
                        "    return \"-\" + keyword;",
                        "  }",
                        "",
                        "  return keyword;",
                        "}",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {Node} typeAnnotation",
                        " * @returns {boolean}",
                        " */",
                        "function isFlowAnnotationComment(text, typeAnnotation) {",
                        "  const start = locStart(typeAnnotation);",
                        "  const end = skipWhitespace(text, locEnd(typeAnnotation));",
                        "  return (",
                        "    end !== false &&",
                        "    text.slice(start, start + 2) === \"/*\" &&",
                        "    text.slice(end, end + 2) === \"*/\"",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasLeadingOwnLineComment(text, node) {",
                        "  if (isJsxNode(node)) {",
                        "    return hasNodeIgnoreComment(node);",
                        "  }",
                        "",
                        "  return hasComment(node, CommentCheckFlags.Leading, (comment) =>",
                        "    hasNewline(text, locEnd(comment))",
                        "  );",
                        "}",
                        "",
                        "// Note: Quoting/unquoting numbers in TypeScript is not safe.",
                        "//",
                        "// let a = { 1: 1, 2: 2 }",
                        "// let b = { '1': 1, '2': 2 }",
                        "//",
                        "// declare let aa: keyof typeof a;",
                        "// declare let bb: keyof typeof b;",
                        "//",
                        "// aa = bb;",
                        "// ^^",
                        "// Type '\"1\" | \"2\"' is not assignable to type '1 | 2'.",
                        "//   Type '\"1\"' is not assignable to type '1 | 2'.(2322)",
                        "//",
                        "// And in Flow, you get:",
                        "//",
                        "// const x = {",
                        "//   0: 1",
                        "//   ^ Non-string literal property keys not supported. [unsupported-syntax]",
                        "// }",
                        "//",
                        "// Angular does not support unquoted numbers in expressions.",
                        "//",
                        "// So we play it safe and only unquote numbers for the JavaScript parsers.",
                        "// (Vue supports unquoted numbers in expressions, but let\u2019s keep it simple.)",
                        "//",
                        "// Identifiers can be unquoted in more circumstances, though.",
                        "function isStringPropSafeToUnquote(node, options) {",
                        "  return (",
                        "    options.parser !== \"json\" &&",
                        "    isStringLiteral(node.key) &&",
                        "    rawText(node.key).slice(1, -1) === node.key.value &&",
                        "    ((isIdentifierName(node.key.value) &&",
                        "      // With `--strictPropertyInitialization`, TS treats properties with quoted names differently than unquoted ones.",
                        "      // See https://github.com/microsoft/TypeScript/pull/20075",
                        "      !(",
                        "        (options.parser === \"babel-ts\" && node.type === \"ClassProperty\") ||",
                        "        (options.parser === \"typescript\" && node.type === \"PropertyDefinition\")",
                        "      )) ||",
                        "      (isSimpleNumber(node.key.value) &&",
                        "        String(Number(node.key.value)) === node.key.value &&",
                        "        (options.parser === \"babel\" ||",
                        "          options.parser === \"espree\" ||",
                        "          options.parser === \"meriyah\" ||",
                        "          options.parser === \"__babel_estree\")))",
                        "  );",
                        "}",
                        "",
                        "// Matches \u201csimple\u201d numbers like `123` and `2.5` but not `1_000`, `1e+100` or `0b10`.",
                        "function isSimpleNumber(numberString) {",
                        "  return /^(?:\\d+|\\d+\\.\\d+)$/.test(numberString);",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {Node} parentNode",
                        " * @returns {boolean}",
                        " */",
                        "function isJestEachTemplateLiteral(node, parentNode) {",
                        "  /**",
                        "   * describe.each`table`(name, fn)",
                        "   * describe.only.each`table`(name, fn)",
                        "   * describe.skip.each`table`(name, fn)",
                        "   * test.each`table`(name, fn)",
                        "   * test.only.each`table`(name, fn)",
                        "   * test.skip.each`table`(name, fn)",
                        "   *",
                        "   * Ref: https://github.com/facebook/jest/pull/6102",
                        "   */",
                        "  const jestEachTriggerRegex = /^[fx]?(?:describe|it|test)$/;",
                        "  return (",
                        "    parentNode.type === \"TaggedTemplateExpression\" &&",
                        "    parentNode.quasi === node &&",
                        "    parentNode.tag.type === \"MemberExpression\" &&",
                        "    parentNode.tag.property.type === \"Identifier\" &&",
                        "    parentNode.tag.property.name === \"each\" &&",
                        "    ((parentNode.tag.object.type === \"Identifier\" &&",
                        "      jestEachTriggerRegex.test(parentNode.tag.object.name)) ||",
                        "      (parentNode.tag.object.type === \"MemberExpression\" &&",
                        "        parentNode.tag.object.property.type === \"Identifier\" &&",
                        "        (parentNode.tag.object.property.name === \"only\" ||",
                        "          parentNode.tag.object.property.name === \"skip\") &&",
                        "        parentNode.tag.object.object.type === \"Identifier\" &&",
                        "        jestEachTriggerRegex.test(parentNode.tag.object.object.name)))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {TemplateLiteral} template",
                        " * @returns {boolean}",
                        " */",
                        "function templateLiteralHasNewLines(template) {",
                        "  return template.quasis.some((quasi) => quasi.value.raw.includes(\"\\n\"));",
                        "}",
                        "",
                        "/**",
                        " * @param {TemplateLiteral | TaggedTemplateExpression} node",
                        " * @param {string} text",
                        " * @returns {boolean}",
                        " */",
                        "function isTemplateOnItsOwnLine(node, text) {",
                        "  return (",
                        "    ((node.type === \"TemplateLiteral\" && templateLiteralHasNewLines(node)) ||",
                        "      (node.type === \"TaggedTemplateExpression\" &&",
                        "        templateLiteralHasNewLines(node.quasi))) &&",
                        "    !hasNewline(text, locStart(node), { backwards: true })",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function needsHardlineAfterDanglingComment(node) {",
                        "  if (!hasComment(node)) {",
                        "    return false;",
                        "  }",
                        "  const lastDanglingComment = getLast(",
                        "    getComments(node, CommentCheckFlags.Dangling)",
                        "  );",
                        "  return lastDanglingComment && !isBlockComment(lastDanglingComment);",
                        "}",
                        "",
                        "// Logic to check for args with multiple anonymous functions. For instance,",
                        "// the following call should be split on multiple lines for readability:",
                        "// source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))",
                        "function isFunctionCompositionArgs(args) {",
                        "  if (args.length <= 1) {",
                        "    return false;",
                        "  }",
                        "  let count = 0;",
                        "  for (const arg of args) {",
                        "    if (isFunctionOrArrowExpression(arg)) {",
                        "      count += 1;",
                        "      if (count > 1) {",
                        "        return true;",
                        "      }",
                        "    } else if (isCallExpression(arg)) {",
                        "      for (const childArg of arg.arguments) {",
                        "        if (isFunctionOrArrowExpression(childArg)) {",
                        "          return true;",
                        "        }",
                        "      }",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "// Logic to determine if a call is a \u201clong curried function call\u201d.",
                        "// See https://github.com/prettier/prettier/issues/1420.",
                        "//",
                        "// `connect(a, b, c)(d)`",
                        "// In the above call expression, the second call is the parent node and the",
                        "// first call is the current node.",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function isLongCurriedCallExpression(path) {",
                        "  const node = path.getValue();",
                        "  const parent = path.getParentNode();",
                        "  return (",
                        "    isCallExpression(node) &&",
                        "    isCallExpression(parent) &&",
                        "    parent.callee === node &&",
                        "    node.arguments.length > parent.arguments.length &&",
                        "    parent.arguments.length > 0",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {any} node",
                        " * @param {number} depth",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleCallArgument(node, depth) {",
                        "  if (depth >= 2) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const isChildSimple = (child) => isSimpleCallArgument(child, depth + 1);",
                        "",
                        "  const regexpPattern =",
                        "    (node.type === \"Literal\" && \"regex\" in node && node.regex.pattern) ||",
                        "    (node.type === \"RegExpLiteral\" && node.pattern);",
                        "",
                        "  if (regexpPattern && getStringWidth(regexpPattern) > 5) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    node.type === \"Literal\" ||",
                        "    node.type === \"BigIntLiteral\" ||",
                        "    node.type === \"DecimalLiteral\" ||",
                        "    node.type === \"BooleanLiteral\" ||",
                        "    node.type === \"NullLiteral\" ||",
                        "    node.type === \"NumericLiteral\" ||",
                        "    node.type === \"RegExpLiteral\" ||",
                        "    node.type === \"StringLiteral\" ||",
                        "    node.type === \"Identifier\" ||",
                        "    node.type === \"ThisExpression\" ||",
                        "    node.type === \"Super\" ||",
                        "    node.type === \"PrivateName\" ||",
                        "    node.type === \"PrivateIdentifier\" ||",
                        "    node.type === \"ArgumentPlaceholder\" ||",
                        "    node.type === \"Import\"",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.type === \"TemplateLiteral\") {",
                        "    return (",
                        "      node.quasis.every((element) => !element.value.raw.includes(\"\\n\")) &&",
                        "      node.expressions.every(isChildSimple)",
                        "    );",
                        "  }",
                        "",
                        "  if (node.type === \"ObjectExpression\") {",
                        "    return node.properties.every(",
                        "      (p) => !p.computed && (p.shorthand || (p.value && isChildSimple(p.value)))",
                        "    );",
                        "  }",
                        "",
                        "  if (node.type === \"ArrayExpression\") {",
                        "    return node.elements.every((x) => x === null || isChildSimple(x));",
                        "  }",
                        "",
                        "  if (isCallLikeExpression(node)) {",
                        "    return (",
                        "      (node.type === \"ImportExpression\" ||",
                        "        isSimpleCallArgument(node.callee, depth)) &&",
                        "      getCallArguments(node).every(isChildSimple)",
                        "    );",
                        "  }",
                        "",
                        "  if (isMemberExpression(node)) {",
                        "    return (",
                        "      isSimpleCallArgument(node.object, depth) &&",
                        "      isSimpleCallArgument(node.property, depth)",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    node.type === \"UnaryExpression\" &&",
                        "    (node.operator === \"!\" || node.operator === \"-\")",
                        "  ) {",
                        "    return isSimpleCallArgument(node.argument, depth);",
                        "  }",
                        "",
                        "  if (node.type === \"TSNonNullExpression\") {",
                        "    return isSimpleCallArgument(node.expression, depth);",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function rawText(node) {",
                        "  return node.extra ? node.extra.raw : node.raw;",
                        "}",
                        "",
                        "function identity(x) {",
                        "  return x;",
                        "}",
                        "",
                        "function isTSXFile(options) {",
                        "  return options.filepath && /\\.tsx$/i.test(options.filepath);",
                        "}",
                        "",
                        "/**",
                        " * @param {any} options",
                        " * @param {(\"es5\" | \"all\")} [level]",
                        " * @returns {boolean}",
                        " */",
                        "function shouldPrintComma(options, level = \"es5\") {",
                        "  return (",
                        "    (options.trailingComma === \"es5\" && level === \"es5\") ||",
                        "    (options.trailingComma === \"all\" && (level === \"all\" || level === \"es5\"))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr",
                        " * holds) `function`, `class`, or `do {}`. Will be overzealous if there's",
                        " * already necessary grouping parentheses.",
                        " *",
                        " * @param {Node} node",
                        " * @param {boolean} forbidFunctionClassAndDoExpr",
                        " * @returns {boolean}",
                        " */",
                        "function startsWithNoLookaheadToken(node, forbidFunctionClassAndDoExpr) {",
                        "  node = getLeftMost(node);",
                        "  switch (node.type) {",
                        "    case \"FunctionExpression\":",
                        "    case \"ClassExpression\":",
                        "    case \"DoExpression\":",
                        "      return forbidFunctionClassAndDoExpr;",
                        "    case \"ObjectExpression\":",
                        "      return true;",
                        "    case \"MemberExpression\":",
                        "    case \"OptionalMemberExpression\":",
                        "      return startsWithNoLookaheadToken(",
                        "        node.object,",
                        "        forbidFunctionClassAndDoExpr",
                        "      );",
                        "    case \"TaggedTemplateExpression\":",
                        "      if (node.tag.type === \"FunctionExpression\") {",
                        "        // IIFEs are always already parenthesized",
                        "        return false;",
                        "      }",
                        "      return startsWithNoLookaheadToken(node.tag, forbidFunctionClassAndDoExpr);",
                        "    case \"CallExpression\":",
                        "    case \"OptionalCallExpression\":",
                        "      if (node.callee.type === \"FunctionExpression\") {",
                        "        // IIFEs are always already parenthesized",
                        "        return false;",
                        "      }",
                        "      return startsWithNoLookaheadToken(",
                        "        node.callee,",
                        "        forbidFunctionClassAndDoExpr",
                        "      );",
                        "    case \"ConditionalExpression\":",
                        "      return startsWithNoLookaheadToken(",
                        "        node.test,",
                        "        forbidFunctionClassAndDoExpr",
                        "      );",
                        "    case \"UpdateExpression\":",
                        "      return (",
                        "        !node.prefix &&",
                        "        startsWithNoLookaheadToken(node.argument, forbidFunctionClassAndDoExpr)",
                        "      );",
                        "    case \"BindExpression\":",
                        "      return (",
                        "        node.object &&",
                        "        startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr)",
                        "      );",
                        "    case \"SequenceExpression\":",
                        "      return startsWithNoLookaheadToken(",
                        "        node.expressions[0],",
                        "        forbidFunctionClassAndDoExpr",
                        "      );",
                        "    case \"TSAsExpression\":",
                        "    case \"TSNonNullExpression\":",
                        "      return startsWithNoLookaheadToken(",
                        "        node.expression,",
                        "        forbidFunctionClassAndDoExpr",
                        "      );",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "const equalityOperators = {",
                        "  \"==\": true,",
                        "  \"!=\": true,",
                        "  \"===\": true,",
                        "  \"!==\": true,",
                        "};",
                        "const multiplicativeOperators = {",
                        "  \"*\": true,",
                        "  \"/\": true,",
                        "  \"%\": true,",
                        "};",
                        "const bitshiftOperators = {",
                        "  \">>\": true,",
                        "  \">>>\": true,",
                        "  \"<<\": true,",
                        "};",
                        "",
                        "function shouldFlatten(parentOp, nodeOp) {",
                        "  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // ** is right-associative",
                        "  // x ** y ** z --> x ** (y ** z)",
                        "  if (parentOp === \"**\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x == y == z --> (x == y) == z",
                        "  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x * y % z --> (x * y) % z",
                        "  if (",
                        "    (nodeOp === \"%\" && multiplicativeOperators[parentOp]) ||",
                        "    (parentOp === \"%\" && multiplicativeOperators[nodeOp])",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x * y / z --> (x * y) / z",
                        "  // x / y * z --> (x / y) * z",
                        "  if (",
                        "    nodeOp !== parentOp &&",
                        "    multiplicativeOperators[nodeOp] &&",
                        "    multiplicativeOperators[parentOp]",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x << y << z --> (x << y) << z",
                        "  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "const PRECEDENCE = {};",
                        "for (const [i, tier] of [",
                        "  [\"|>\"],",
                        "  [\"??\"],",
                        "  [\"||\"],",
                        "  [\"&&\"],",
                        "  [\"|\"],",
                        "  [\"^\"],",
                        "  [\"&\"],",
                        "  [\"==\", \"===\", \"!=\", \"!==\"],",
                        "  [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],",
                        "  [\">>\", \"<<\", \">>>\"],",
                        "  [\"+\", \"-\"],",
                        "  [\"*\", \"/\", \"%\"],",
                        "  [\"**\"],",
                        "].entries()) {",
                        "  for (const op of tier) {",
                        "    PRECEDENCE[op] = i;",
                        "  }",
                        "}",
                        "",
                        "function getPrecedence(op) {",
                        "  return PRECEDENCE[op];",
                        "}",
                        "",
                        "function getLeftMost(node) {",
                        "  while (node.left) {",
                        "    node = node.left;",
                        "  }",
                        "  return node;",
                        "}",
                        "",
                        "function isBitwiseOperator(operator) {",
                        "  return (",
                        "    Boolean(bitshiftOperators[operator]) ||",
                        "    operator === \"|\" ||",
                        "    operator === \"^\" ||",
                        "    operator === \"&\"",
                        "  );",
                        "}",
                        "",
                        "function hasRestParameter(node) {",
                        "  if (node.rest) {",
                        "    return true;",
                        "  }",
                        "  const parameters = getFunctionParameters(node);",
                        "  return parameters.length > 0 && getLast(parameters).type === \"RestElement\";",
                        "}",
                        "",
                        "const functionParametersCache = new WeakMap();",
                        "function getFunctionParameters(node) {",
                        "  if (functionParametersCache.has(node)) {",
                        "    return functionParametersCache.get(node);",
                        "  }",
                        "  const parameters = [];",
                        "  if (node.this) {",
                        "    parameters.push(node.this);",
                        "  }",
                        "  // `params` vs `parameters` - see https://github.com/babel/babel/issues/9231",
                        "  if (Array.isArray(node.parameters)) {",
                        "    parameters.push(...node.parameters);",
                        "  } else if (Array.isArray(node.params)) {",
                        "    parameters.push(...node.params);",
                        "  }",
                        "  if (node.rest) {",
                        "    parameters.push(node.rest);",
                        "  }",
                        "  functionParametersCache.set(node, parameters);",
                        "  return parameters;",
                        "}",
                        "",
                        "function iterateFunctionParametersPath(path, iteratee) {",
                        "  const node = path.getValue();",
                        "  let index = 0;",
                        "  const callback = (childPath) => iteratee(childPath, index++);",
                        "  if (node.this) {",
                        "    path.call(callback, \"this\");",
                        "  }",
                        "  if (Array.isArray(node.parameters)) {",
                        "    path.each(callback, \"parameters\");",
                        "  } else if (Array.isArray(node.params)) {",
                        "    path.each(callback, \"params\");",
                        "  }",
                        "  if (node.rest) {",
                        "    path.call(callback, \"rest\");",
                        "  }",
                        "}",
                        "",
                        "const callArgumentsCache = new WeakMap();",
                        "function getCallArguments(node) {",
                        "  if (callArgumentsCache.has(node)) {",
                        "    return callArgumentsCache.get(node);",
                        "  }",
                        "",
                        "  let args = node.arguments;",
                        "  if (node.type === \"ImportExpression\") {",
                        "    args = [node.source];",
                        "",
                        "    if (node.attributes) {",
                        "      args.push(node.attributes);",
                        "    }",
                        "  }",
                        "",
                        "  callArgumentsCache.set(node, args);",
                        "  return args;",
                        "}",
                        "",
                        "function iterateCallArgumentsPath(path, iteratee) {",
                        "  const node = path.getValue();",
                        "  if (node.type === \"ImportExpression\") {",
                        "    path.call((sourcePath) => iteratee(sourcePath, 0), \"source\");",
                        "",
                        "    if (node.attributes) {",
                        "      path.call((sourcePath) => iteratee(sourcePath, 1), \"attributes\");",
                        "    }",
                        "  } else {",
                        "    path.each(iteratee, \"arguments\");",
                        "  }",
                        "}",
                        "",
                        "function isPrettierIgnoreComment(comment) {",
                        "  return comment.value.trim() === \"prettier-ignore\" && !comment.unignore;",
                        "}",
                        "",
                        "function hasNodeIgnoreComment(node) {",
                        "  return (",
                        "    node &&",
                        "    (node.prettierIgnore || hasComment(node, CommentCheckFlags.PrettierIgnore))",
                        "  );",
                        "}",
                        "",
                        "function hasIgnoreComment(path) {",
                        "  const node = path.getValue();",
                        "  return hasNodeIgnoreComment(node);",
                        "}",
                        "",
                        "const CommentCheckFlags = {",
                        "  /** Check comment is a leading comment */",
                        "  Leading: 1 << 1,",
                        "  /** Check comment is a trailing comment */",
                        "  Trailing: 1 << 2,",
                        "  /** Check comment is a dangling comment */",
                        "  Dangling: 1 << 3,",
                        "  /** Check comment is a block comment */",
                        "  Block: 1 << 4,",
                        "  /** Check comment is a line comment */",
                        "  Line: 1 << 5,",
                        "  /** Check comment is a `prettier-ignore` comment */",
                        "  PrettierIgnore: 1 << 6,",
                        "  /** Check comment is the first attached comment */",
                        "  First: 1 << 7,",
                        "  /** Check comment is the last attached comment */",
                        "  Last: 1 << 8,",
                        "};",
                        "",
                        "const getCommentTestFunction = (flags, fn) => {",
                        "  if (typeof flags === \"function\") {",
                        "    fn = flags;",
                        "    flags = 0;",
                        "  }",
                        "  if (flags || fn) {",
                        "    return (comment, index, comments) =>",
                        "      !(",
                        "        (flags & CommentCheckFlags.Leading && !comment.leading) ||",
                        "        (flags & CommentCheckFlags.Trailing && !comment.trailing) ||",
                        "        (flags & CommentCheckFlags.Dangling &&",
                        "          (comment.leading || comment.trailing)) ||",
                        "        (flags & CommentCheckFlags.Block && !isBlockComment(comment)) ||",
                        "        (flags & CommentCheckFlags.Line && !isLineComment(comment)) ||",
                        "        (flags & CommentCheckFlags.First && index !== 0) ||",
                        "        (flags & CommentCheckFlags.Last && index !== comments.length - 1) ||",
                        "        (flags & CommentCheckFlags.PrettierIgnore &&",
                        "          !isPrettierIgnoreComment(comment)) ||",
                        "        (fn && !fn(comment))",
                        "      );",
                        "  }",
                        "};",
                        "/**",
                        " * @param {Node} node",
                        " * @param {number | function} [flags]",
                        " * @param {function} [fn]",
                        " * @returns {boolean}",
                        " */",
                        "function hasComment(node, flags, fn) {",
                        "  if (!node || !isNonEmptyArray(node.comments)) {",
                        "    return false;",
                        "  }",
                        "  const test = getCommentTestFunction(flags, fn);",
                        "  return test ? node.comments.some(test) : true;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {number | function} [flags]",
                        " * @param {function} [fn]",
                        " * @returns {Comment[]}",
                        " */",
                        "function getComments(node, flags, fn) {",
                        "  if (!node || !Array.isArray(node.comments)) {",
                        "    return [];",
                        "  }",
                        "  const test = getCommentTestFunction(flags, fn);",
                        "  return test ? node.comments.filter(test) : node.comments;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isNextLineEmpty = (node, { originalText }) =>",
                        "  isNextLineEmptyAfterIndex(originalText, locEnd(node));",
                        "",
                        "function isCallLikeExpression(node) {",
                        "  return (",
                        "    isCallExpression(node) ||",
                        "    node.type === \"NewExpression\" ||",
                        "    node.type === \"ImportExpression\"",
                        "  );",
                        "}",
                        "",
                        "function isObjectProperty(node) {",
                        "  return (",
                        "    node &&",
                        "    (node.type === \"ObjectProperty\" ||",
                        "      (node.type === \"Property\" && !node.method && node.kind === \"init\"))",
                        "  );",
                        "}",
                        "",
                        "function isEnabledHackPipeline(options) {",
                        "  return Boolean(options.__isUsingHackPipeline);",
                        "}",
                        "",
                        "/**",
                        " * This is used as a marker for dangling comments.",
                        " */",
                        "const markerForIfWithoutBlockAndSameLineComment = Symbol(",
                        "  \"ifWithoutBlockAndSameLineComment\"",
                        ");",
                        "",
                        "module.exports = {",
                        "  getFunctionParameters,",
                        "  iterateFunctionParametersPath,",
                        "  getCallArguments,",
                        "  iterateCallArgumentsPath,",
                        "  hasRestParameter,",
                        "  getLeftSide,",
                        "  getLeftSidePathName,",
                        "  getParentExportDeclaration,",
                        "  getTypeScriptMappedTypeModifier,",
                        "  hasFlowAnnotationComment,",
                        "  hasFlowShorthandAnnotationComment,",
                        "  hasLeadingOwnLineComment,",
                        "  hasNakedLeftSide,",
                        "  hasNode,",
                        "  hasIgnoreComment,",
                        "  hasNodeIgnoreComment,",
                        "  identity,",
                        "  isBinaryish,",
                        "  isCallLikeExpression,",
                        "  isEnabledHackPipeline,",
                        "  isLineComment,",
                        "  isPrettierIgnoreComment,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isExportDeclaration,",
                        "  isFlowAnnotationComment,",
                        "  isFunctionCompositionArgs,",
                        "  isFunctionNotation,",
                        "  isFunctionOrArrowExpression,",
                        "  isGetterOrSetter,",
                        "  isJestEachTemplateLiteral,",
                        "  isJsxNode,",
                        "  isLiteral,",
                        "  isLongCurriedCallExpression,",
                        "  isSimpleCallArgument,",
                        "  isMemberish,",
                        "  isNumericLiteral,",
                        "  isSignedNumericLiteral,",
                        "  isObjectProperty,",
                        "  isObjectType,",
                        "  isObjectTypePropertyAFunction,",
                        "  isSimpleType,",
                        "  isSimpleNumber,",
                        "  isSimpleTemplateLiteral,",
                        "  isStringLiteral,",
                        "  isStringPropSafeToUnquote,",
                        "  isTemplateOnItsOwnLine,",
                        "  isTestCall,",
                        "  isTheOnlyJsxElementInMarkdown,",
                        "  isTSXFile,",
                        "  isTypeAnnotationAFunction,",
                        "  isNextLineEmpty,",
                        "  needsHardlineAfterDanglingComment,",
                        "  rawText,",
                        "  shouldPrintComma,",
                        "  isBitwiseOperator,",
                        "  shouldFlatten,",
                        "  startsWithNoLookaheadToken,",
                        "  getPrecedence,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  markerForIfWithoutBlockAndSameLineComment,",
                        "};"
                    ]
                },
                "is-block-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree\").Comment} Comment",
                        " */",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "function isBlockComment(comment) {",
                        "  return (",
                        "    comment.type === \"Block\" ||",
                        "    comment.type === \"CommentBlock\" ||",
                        "    // `meriyah`",
                        "    comment.type === \"MultiLine\"",
                        "  );",
                        "}",
                        "",
                        "module.exports = isBlockComment;"
                    ]
                },
                "is-ts-keyword-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "/**",
                        " * @returns {boolean}",
                        " */",
                        "function isTsKeywordType({ type }) {",
                        "  return type.startsWith(\"TS\") && type.endsWith(\"Keyword\");",
                        "}",
                        "",
                        "module.exports = isTsKeywordType;"
                    ]
                },
                "is-type-cast-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const isBlockComment = require(\"./is-block-comment.js\");",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree\").Comment} Comment",
                        " */",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "function isTypeCastComment(comment) {",
                        "  return (",
                        "    isBlockComment(comment) &&",
                        "    comment.value[0] === \"*\" &&",
                        "    // TypeScript expects the type to be enclosed in curly brackets, however",
                        "    // Closure Compiler accepts types in parens and even without any delimiters at all.",
                        "    // That's why we just search for \"@type\".",
                        "    /@type\\b/.test(comment.value)",
                        "  );",
                        "}",
                        "",
                        "module.exports = isTypeCastComment;"
                    ]
                }
            }
        },
        "language-markdown": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { isFrontMatterNode } = require(\"../common/util.js\");",
                    "const { startWithPragma } = require(\"./pragma.js\");",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"position\",",
                    "  \"raw\", // front-matter",
                    "]);",
                    "function clean(ast, newObj, parent) {",
                    "  // for codeblock",
                    "  if (",
                    "    ast.type === \"front-matter\" ||",
                    "    ast.type === \"code\" ||",
                    "    ast.type === \"yaml\" ||",
                    "    ast.type === \"import\" ||",
                    "    ast.type === \"export\" ||",
                    "    ast.type === \"jsx\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"list\") {",
                    "    delete newObj.isAligned;",
                    "  }",
                    "",
                    "  if (ast.type === \"list\" || ast.type === \"listItem\") {",
                    "    delete newObj.spread;",
                    "    delete newObj.loose;",
                    "  }",
                    "",
                    "  // texts can be splitted or merged",
                    "  if (ast.type === \"text\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"inlineCode\") {",
                    "    newObj.value = ast.value.replace(/[\\t\\n ]+/g, \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"wikiLink\") {",
                    "    newObj.value = ast.value.trim().replace(/[\\t\\n]+/g, \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"definition\" || ast.type === \"linkReference\") {",
                    "    newObj.label = ast.label",
                    "      .trim()",
                    "      .replace(/[\\t\\n ]+/g, \" \")",
                    "      .toLowerCase();",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"definition\" ||",
                    "      ast.type === \"link\" ||",
                    "      ast.type === \"image\") &&",
                    "    ast.title",
                    "  ) {",
                    "    newObj.title = ast.title.replace(/\\\\([\"')])/g, \"$1\");",
                    "  }",
                    "",
                    "  // for insert pragma",
                    "  if (",
                    "    parent &&",
                    "    parent.type === \"root\" &&",
                    "    parent.children.length > 0 &&",
                    "    (parent.children[0] === ast ||",
                    "      (isFrontMatterNode(parent.children[0]) && parent.children[1] === ast)) &&",
                    "    ast.type === \"html\" &&",
                    "    startWithPragma(ast.value)",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "module.exports = clean;"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const cjkRegex = require(\"cjk-regex\");",
                    "const regexpUtil = require(\"regexp-util\");",
                    "const unicodeRegex = require(\"unicode-regex\");",
                    "",
                    "const cjkPattern = `(?:${cjkRegex()",
                    "  .union(",
                    "    unicodeRegex({",
                    "      Script_Extensions: [\"Han\", \"Katakana\", \"Hiragana\", \"Hangul\", \"Bopomofo\"],",
                    "      General_Category: [",
                    "        \"Other_Letter\",",
                    "        \"Letter_Number\",",
                    "        \"Other_Symbol\",",
                    "        \"Modifier_Letter\",",
                    "        \"Modifier_Symbol\",",
                    "        \"Nonspacing_Mark\",",
                    "      ],",
                    "    })",
                    "  )",
                    "  .toString()})(?:${unicodeRegex({",
                    "  Block: [\"Variation_Selectors\", \"Variation_Selectors_Supplement\"],",
                    "}).toString()})?`;",
                    "",
                    "const kPattern = unicodeRegex({ Script: [\"Hangul\"] })",
                    "  .union(unicodeRegex({ Script_Extensions: [\"Hangul\"] }))",
                    "  .toString();",
                    "",
                    "// http://spec.commonmark.org/0.25/#ascii-punctuation-character",
                    "const asciiPunctuationCharset =",
                    "  /* prettier-ignore */ regexpUtil.charset(",
                    "  \"!\", '\"', \"#\",  \"$\", \"%\", \"&\", \"'\", \"(\", \")\", \"*\",",
                    "  \"+\", \",\", \"-\",  \".\", \"/\", \":\", \";\", \"<\", \"=\", \">\",",
                    "  \"?\", \"@\", \"[\", \"\\\\\", \"]\", \"^\", \"_\", \"`\", \"{\", \"|\",",
                    "  \"}\", \"~\"",
                    ");",
                    "",
                    "// http://spec.commonmark.org/0.25/#punctuation-character",
                    "const punctuationCharset = unicodeRegex({",
                    "  // http://unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values",
                    "  General_Category: [",
                    "    /* Pc */ \"Connector_Punctuation\",",
                    "    /* Pd */ \"Dash_Punctuation\",",
                    "    /* Pe */ \"Close_Punctuation\",",
                    "    /* Pf */ \"Final_Punctuation\",",
                    "    /* Pi */ \"Initial_Punctuation\",",
                    "    /* Po */ \"Other_Punctuation\",",
                    "    /* Ps */ \"Open_Punctuation\",",
                    "  ],",
                    "}).union(asciiPunctuationCharset);",
                    "",
                    "const punctuationPattern = punctuationCharset.toString();",
                    "",
                    "module.exports = {",
                    "  cjkPattern,",
                    "  kPattern,",
                    "  punctuationPattern,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  inferParserByLanguage,",
                    "  getMaxContinuousCount,",
                    "} = require(\"../common/util.js\");",
                    "const {",
                    "  builders: { hardline, markAsRoot },",
                    "  utils: { replaceEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const printFrontMatter = require(\"../utils/front-matter/print.js\");",
                    "const { getFencedCodeBlockValue } = require(\"./utils.js\");",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (node.type === \"code\" && node.lang !== null) {",
                    "    const parser = inferParserByLanguage(node.lang, options);",
                    "    if (parser) {",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "      );",
                    "      const newOptions = { parser };",
                    "      if (node.lang === \"tsx\") {",
                    "        newOptions.filepath = \"dummy.tsx\";",
                    "      }",
                    "      const doc = textToDoc(",
                    "        getFencedCodeBlockValue(node, options.originalText),",
                    "        newOptions,",
                    "        { stripTrailingHardline: true }",
                    "      );",
                    "      return markAsRoot([",
                    "        style,",
                    "        node.lang,",
                    "        node.meta ? \" \" + node.meta : \"\",",
                    "        hardline,",
                    "        replaceEndOfLine(doc),",
                    "        hardline,",
                    "        style,",
                    "      ]);",
                    "    }",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return printFrontMatter(node, textToDoc);",
                    "",
                    "    // MDX",
                    "    case \"importExport\":",
                    "      return [",
                    "        textToDoc(",
                    "          node.value,",
                    "          { parser: \"babel\" },",
                    "          { stripTrailingHardline: true }",
                    "        ),",
                    "        hardline,",
                    "      ];",
                    "    case \"jsx\":",
                    "      return textToDoc(",
                    "        `<$>${node.value}</$>`,",
                    "        {",
                    "          parser: \"__js_expression\",",
                    "          rootMarker: \"mdx\",",
                    "        },",
                    "        { stripTrailingHardline: true }",
                    "      );",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-markdown.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/Markdown.json\"), (data) => ({",
                    "    since: \"1.8.0\",",
                    "    parsers: [\"markdown\"],",
                    "    vscodeLanguageIds: [\"markdown\"],",
                    "    filenames: [...data.filenames, \"README\"],",
                    "    extensions: data.extensions.filter((extension) => extension !== \".mdx\"),",
                    "  })),",
                    "  createLanguage(require(\"linguist-languages/data/Markdown.json\"), () => ({",
                    "    name: \"MDX\",",
                    "    since: \"1.15.0\",",
                    "    parsers: [\"mdx\"],",
                    "    vscodeLanguageIds: [\"mdx\"],",
                    "    filenames: [],",
                    "    extensions: [\".mdx\"],",
                    "  })),",
                    "];",
                    "",
                    "const printers = {",
                    "  mdast: printer,",
                    "};",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  options,",
                    "  printers,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  return node.position.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.position.end.offset;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "mdx.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * modified from https://github.com/mdx-js/mdx/blob/master/packages/mdx",
                    " *",
                    " * The MIT License (MIT)",
                    " *",
                    " * Copyright (c) 2017-2018 Compositor and Zeit, Inc.",
                    " *",
                    " * Permission is hereby granted, free of charge, to any person obtaining a copy",
                    " * of this software and associated documentation files (the \"Software\"), to deal",
                    " * in the Software without restriction, including without limitation the rights",
                    " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
                    " * copies of the Software, and to permit persons to whom the Software is",
                    " * furnished to do so, subject to the following conditions:",
                    " * The above copyright notice and this permission notice shall be included in",
                    " * all copies or substantial portions of the Software.",
                    " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
                    " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
                    " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
                    " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
                    " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
                    " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
                    " * THE SOFTWARE.",
                    " */",
                    "",
                    "const IMPORT_REGEX = /^import\\s/;",
                    "const EXPORT_REGEX = /^export\\s/;",
                    "const BLOCKS_REGEX = \"[a-z][a-z0-9]*(\\\\.[a-z][a-z0-9]*)*|\";",
                    "const COMMENT_REGEX = /<!---->|<!---?[^>-](?:-?[^-])*-->/;",
                    "const ES_COMMENT_REGEX = /^{\\s*\\/\\*(.*)\\*\\/\\s*}/;",
                    "const EMPTY_NEWLINE = \"\\n\\n\";",
                    "",
                    "const isImport = (text) => IMPORT_REGEX.test(text);",
                    "const isExport = (text) => EXPORT_REGEX.test(text);",
                    "",
                    "const tokenizeEsSyntax = (eat, value) => {",
                    "  const index = value.indexOf(EMPTY_NEWLINE);",
                    "  const subvalue = value.slice(0, index);",
                    "",
                    "  if (isExport(subvalue) || isImport(subvalue)) {",
                    "    return eat(subvalue)({",
                    "      type: isExport(subvalue) ? \"export\" : \"import\",",
                    "      value: subvalue,",
                    "    });",
                    "  }",
                    "};",
                    "",
                    "const tokenizeEsComment = (eat, value) => {",
                    "  const match = ES_COMMENT_REGEX.exec(value);",
                    "",
                    "  if (match) {",
                    "    return eat(match[0])({",
                    "      type: \"esComment\",",
                    "      value: match[1].trim(),",
                    "    });",
                    "  }",
                    "};",
                    "",
                    "/* istanbul ignore next */",
                    "tokenizeEsSyntax.locator = (value /*, fromIndex*/) =>",
                    "  isExport(value) || isImport(value) ? -1 : 1;",
                    "",
                    "tokenizeEsComment.locator = (value, fromIndex) => value.indexOf(\"{\", fromIndex);",
                    "",
                    "function esSyntax() {",
                    "  const { Parser } = this;",
                    "  const { blockTokenizers, blockMethods, inlineTokenizers, inlineMethods } =",
                    "    Parser.prototype;",
                    "",
                    "  blockTokenizers.esSyntax = tokenizeEsSyntax;",
                    "  inlineTokenizers.esComment = tokenizeEsComment;",
                    "",
                    "  blockMethods.splice(blockMethods.indexOf(\"paragraph\"), 0, \"esSyntax\");",
                    "  inlineMethods.splice(inlineMethods.indexOf(\"text\"), 0, \"esComment\");",
                    "}",
                    "",
                    "module.exports = {",
                    "  esSyntax,",
                    "  BLOCKS_REGEX,",
                    "  COMMENT_REGEX,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  proseWrap: commonOptions.proseWrap,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};"
                ]
            },
            "parser-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const remarkParse = require(\"remark-parse\");",
                    "const unified = require(\"unified\");",
                    "const remarkMath = require(\"remark-math\");",
                    "const footnotes = require(\"remark-footnotes\");",
                    "const pragma = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const mdx = require(\"./mdx.js\");",
                    "const htmlToJsx = require(\"./unified-plugins/html-to-jsx.js\");",
                    "const frontMatter = require(\"./unified-plugins/front-matter.js\");",
                    "const liquid = require(\"./unified-plugins/liquid.js\");",
                    "const wikiLink = require(\"./unified-plugins/wiki-link.js\");",
                    "const looseItems = require(\"./unified-plugins/loose-items.js\");",
                    "",
                    "/**",
                    " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                    " *",
                    " * 1. restore unescaped character (Text)",
                    " * 2. merge continuous Texts",
                    " * 3. replace whitespaces in InlineCode#value with one whitespace",
                    " *    reference: http://spec.commonmark.org/0.25/#example-605",
                    " * 4. split Text into Sentence",
                    " *",
                    " * interface Word { value: string }",
                    " * interface Whitespace { value: string }",
                    " * interface Sentence { children: Array<Word | Whitespace> }",
                    " * interface InlineCode { children: Array<Sentence> }",
                    " */",
                    "function createParse({ isMDX }) {",
                    "  return (text) => {",
                    "    const processor = unified()",
                    "      .use(remarkParse, {",
                    "        commonmark: true,",
                    "        ...(isMDX && { blocks: [mdx.BLOCKS_REGEX] }),",
                    "      })",
                    "      .use(footnotes)",
                    "      .use(frontMatter)",
                    "      .use(remarkMath)",
                    "      .use(isMDX ? mdx.esSyntax : identity)",
                    "      .use(liquid)",
                    "      .use(isMDX ? htmlToJsx : identity)",
                    "      .use(wikiLink)",
                    "      .use(looseItems);",
                    "    return processor.runSync(processor.parse(text));",
                    "  };",
                    "}",
                    "",
                    "function identity(x) {",
                    "  return x;",
                    "}",
                    "",
                    "const baseParser = {",
                    "  astFormat: \"mdast\",",
                    "  hasPragma: pragma.hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "const markdownParser = { ...baseParser, parse: createParse({ isMDX: false }) };",
                    "",
                    "const mdxParser = { ...baseParser, parse: createParse({ isMDX: true }) };",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    remark: markdownParser,",
                    "    markdown: markdownParser,",
                    "    mdx: mdxParser,",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  /* istanbul ignore next */",
                    "  get remark() {",
                    "    return require(\"./parser-markdown.js\").parsers.remark;",
                    "  },",
                    "  get markdown() {",
                    "    return require(\"./parser-markdown.js\").parsers.remark;",
                    "  },",
                    "  get mdx() {",
                    "    return require(\"./parser-markdown.js\").parsers.mdx;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const parseFrontMatter = require(\"../utils/front-matter/parse.js\");",
                    "",
                    "const pragmas = [\"format\", \"prettier\"];",
                    "",
                    "function startWithPragma(text) {",
                    "  const pragma = `@(${pragmas.join(\"|\")})`;",
                    "  const regex = new RegExp(",
                    "    [",
                    "      `<!--\\\\s*${pragma}\\\\s*-->`,",
                    "      `{\\\\s*\\\\/\\\\*\\\\s*${pragma}\\\\s*\\\\*\\\\/\\\\s*}`,",
                    "      `<!--.*\\r?\\n[\\\\s\\\\S]*(^|\\n)[^\\\\S\\n]*${pragma}[^\\\\S\\n]*($|\\n)[\\\\s\\\\S]*\\n.*-->`,",
                    "    ].join(\"|\"),",
                    "    \"m\"",
                    "  );",
                    "  const matched = text.match(regex);",
                    "  return matched && matched.index === 0;",
                    "}",
                    "",
                    "module.exports = {",
                    "  startWithPragma,",
                    "  hasPragma: (text) =>",
                    "    startWithPragma(parseFrontMatter(text).content.trimStart()),",
                    "  insertPragma: (text) => {",
                    "    const extracted = parseFrontMatter(text);",
                    "    const pragma = `<!-- @${pragmas[0]} -->`;",
                    "    return extracted.frontMatter",
                    "      ? `${extracted.frontMatter.raw}\\n\\n${pragma}\\n\\n${extracted.content}`",
                    "      : `${pragma}\\n\\n${extracted.content}`;",
                    "  },",
                    "};"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "const { getOrderedListItemInfo, mapAst, splitText } = require(\"./utils.js\");",
                    "",
                    "// 0x0 ~ 0x10ffff",
                    "const isSingleCharRegex = /^.$/su;",
                    "",
                    "function preprocess(ast, options) {",
                    "  ast = restoreUnescapedCharacter(ast, options);",
                    "  ast = mergeContinuousTexts(ast);",
                    "  ast = transformInlineCode(ast);",
                    "  ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);",
                    "  ast = markAlignedList(ast, options);",
                    "  ast = splitTextIntoSentences(ast, options);",
                    "  ast = transformImportExport(ast);",
                    "  ast = mergeContinuousImportExport(ast);",
                    "  return ast;",
                    "}",
                    "",
                    "function transformImportExport(ast) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (node.type !== \"import\" && node.type !== \"export\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    return { ...node, type: \"importExport\" };",
                    "  });",
                    "}",
                    "",
                    "function transformInlineCode(ast) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (node.type !== \"inlineCode\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    return { ...node, value: node.value.replace(/\\s+/g, \" \") };",
                    "  });",
                    "}",
                    "",
                    "function restoreUnescapedCharacter(ast, options) {",
                    "  return mapAst(ast, (node) =>",
                    "    node.type !== \"text\" ||",
                    "    node.value === \"*\" ||",
                    "    node.value === \"_\" || // handle these cases in printer",
                    "    !isSingleCharRegex.test(node.value) ||",
                    "    node.position.end.offset - node.position.start.offset === node.value.length",
                    "      ? node",
                    "      : {",
                    "          ...node,",
                    "          value: options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          ),",
                    "        }",
                    "  );",
                    "}",
                    "",
                    "function mergeContinuousImportExport(ast) {",
                    "  return mergeChildren(",
                    "    ast,",
                    "    (prevNode, node) =>",
                    "      prevNode.type === \"importExport\" && node.type === \"importExport\",",
                    "    (prevNode, node) => ({",
                    "      type: \"importExport\",",
                    "      value: prevNode.value + \"\\n\\n\" + node.value,",
                    "      position: {",
                    "        start: prevNode.position.start,",
                    "        end: node.position.end,",
                    "      },",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function mergeChildren(ast, shouldMerge, mergeNode) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (!node.children) {",
                    "      return node;",
                    "    }",
                    "    const children = node.children.reduce((current, child) => {",
                    "      const lastChild = getLast(current);",
                    "      if (lastChild && shouldMerge(lastChild, child)) {",
                    "        current.splice(-1, 1, mergeNode(lastChild, child));",
                    "      } else {",
                    "        current.push(child);",
                    "      }",
                    "      return current;",
                    "    }, []);",
                    "    return { ...node, children };",
                    "  });",
                    "}",
                    "",
                    "function mergeContinuousTexts(ast) {",
                    "  return mergeChildren(",
                    "    ast,",
                    "    (prevNode, node) => prevNode.type === \"text\" && node.type === \"text\",",
                    "    (prevNode, node) => ({",
                    "      type: \"text\",",
                    "      value: prevNode.value + node.value,",
                    "      position: {",
                    "        start: prevNode.position.start,",
                    "        end: node.position.end,",
                    "      },",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function splitTextIntoSentences(ast, options) {",
                    "  return mapAst(ast, (node, index, [parentNode]) => {",
                    "    if (node.type !== \"text\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    let { value } = node;",
                    "",
                    "    if (parentNode.type === \"paragraph\") {",
                    "      if (index === 0) {",
                    "        value = value.trimStart();",
                    "      }",
                    "      if (index === parentNode.children.length - 1) {",
                    "        value = value.trimEnd();",
                    "      }",
                    "    }",
                    "",
                    "    return {",
                    "      type: \"sentence\",",
                    "      position: node.position,",
                    "      children: splitText(value, options),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "function transformIndentedCodeblockAndMarkItsParentList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"code\") {",
                    "      // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it",
                    "      const isIndented = /^\\n?(?: {4,}|\\t)/.test(",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        )",
                    "      );",
                    "",
                    "      node.isIndented = isIndented;",
                    "",
                    "      if (isIndented) {",
                    "        for (let i = 0; i < parentStack.length; i++) {",
                    "          const parent = parentStack[i];",
                    "",
                    "          // no need to check checked items",
                    "          if (parent.hasIndentedCodeblock) {",
                    "            break;",
                    "          }",
                    "",
                    "          if (parent.type === \"list\") {",
                    "            parent.hasIndentedCodeblock = true;",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function markAlignedList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"list\" && node.children.length > 0) {",
                    "      // if one of its parents is not aligned, it's not possible to be aligned in sub-lists",
                    "      for (let i = 0; i < parentStack.length; i++) {",
                    "        const parent = parentStack[i];",
                    "        if (parent.type === \"list\" && !parent.isAligned) {",
                    "          node.isAligned = false;",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      node.isAligned = isAligned(node);",
                    "    }",
                    "",
                    "    return node;",
                    "  });",
                    "",
                    "  function getListItemStart(listItem) {",
                    "    return listItem.children.length === 0",
                    "      ? -1",
                    "      : listItem.children[0].position.start.column - 1;",
                    "  }",
                    "",
                    "  function isAligned(list) {",
                    "    if (!list.ordered) {",
                    "      /**",
                    "       * - 123",
                    "       * - 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const [firstItem, secondItem] = list.children;",
                    "",
                    "    const firstInfo = getOrderedListItemInfo(firstItem, options.originalText);",
                    "",
                    "    if (firstInfo.leadingSpaces.length > 1) {",
                    "      /**",
                    "       * 1.   123",
                    "       *",
                    "       * 1.   123",
                    "       * 1. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const firstStart = getListItemStart(firstItem);",
                    "",
                    "    if (firstStart === -1) {",
                    "      /**",
                    "       * 1.",
                    "       *",
                    "       * 1.",
                    "       * 1.",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (list.children.length === 1) {",
                    "      /**",
                    "       * aligned:",
                    "       *",
                    "       * 11. 123",
                    "       *",
                    "       * not aligned:",
                    "       *",
                    "       * 1. 123",
                    "       */",
                    "      return firstStart % options.tabWidth === 0;",
                    "    }",
                    "",
                    "    const secondStart = getListItemStart(secondItem);",
                    "",
                    "    if (firstStart !== secondStart) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 1. 123",
                    "       *",
                    "       * 1. 123",
                    "       * 11. 123",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (firstStart % options.tabWidth === 0) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 12. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    /**",
                    "     * aligned:",
                    "     *",
                    "     * 11. 123",
                    "     * 1.  123",
                    "     *",
                    "     * not aligned:",
                    "     *",
                    "     * 1. 123",
                    "     * 2. 123",
                    "     */",
                    "    const secondInfo = getOrderedListItemInfo(secondItem, options.originalText);",
                    "    return secondInfo.leadingSpaces.length > 1;",
                    "  }",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  getLast,",
                    "  getMinNotPresentContinuousCount,",
                    "  getMaxContinuousCount,",
                    "  getStringWidth,",
                    "  isNonEmptyArray,",
                    "} = require(\"../common/util.js\");",
                    "const {",
                    "  builders: {",
                    "    breakParent,",
                    "    join,",
                    "    line,",
                    "    literalline,",
                    "    markAsRoot,",
                    "    hardline,",
                    "    softline,",
                    "    ifBreak,",
                    "    fill,",
                    "    align,",
                    "    indent,",
                    "    group,",
                    "    hardlineWithoutBreakParent,",
                    "  },",
                    "  utils: { normalizeDoc, replaceTextEndOfLine },",
                    "  printer: { printDocToString },",
                    "} = require(\"../document/index.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const { insertPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "const clean = require(\"./clean.js\");",
                    "const {",
                    "  getFencedCodeBlockValue,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "  isAutolink,",
                    "} = require(\"./utils.js\");",
                    "",
                    "/**",
                    " * @typedef {import(\"../document\").Doc} Doc",
                    " */",
                    "",
                    "const TRAILING_HARDLINE_NODES = new Set([\"importExport\"]);",
                    "const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\", \"wikiLink\"];",
                    "const SIBLING_NODE_TYPES = new Set([",
                    "  \"listItem\",",
                    "  \"definition\",",
                    "  \"footnoteDefinition\",",
                    "]);",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (shouldRemainTheSameContent(path)) {",
                    "    return splitText(",
                    "      options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      ),",
                    "      options",
                    "    ).map((node) =>",
                    "      node.type === \"word\"",
                    "        ? node.value",
                    "        : node.value === \"\"",
                    "        ? \"\"",
                    "        : printLine(path, node.value, options)",
                    "    );",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"root\":",
                    "      if (node.children.length === 0) {",
                    "        return \"\";",
                    "      }",
                    "      return [",
                    "        normalizeDoc(printRoot(path, options, print)),",
                    "        !TRAILING_HARDLINE_NODES.has(getLastDescendantNode(node).type)",
                    "          ? hardline",
                    "          : \"\",",
                    "      ];",
                    "    case \"paragraph\":",
                    "      return printChildren(path, options, print, {",
                    "        postprocessor: fill,",
                    "      });",
                    "    case \"sentence\":",
                    "      return printChildren(path, options, print);",
                    "    case \"word\": {",
                    "      let escapedValue = node.value",
                    "        .replace(/\\*/g, \"\\\\$&\") // escape all `*`",
                    "        .replace(",
                    "          new RegExp(",
                    "            [",
                    "              `(^|${punctuationPattern})(_+)`,",
                    "              `(_+)(${punctuationPattern}|$)`,",
                    "            ].join(\"|\"),",
                    "            \"g\"",
                    "          ),",
                    "          (_, text1, underscore1, underscore2, text2) =>",
                    "            (underscore1",
                    "              ? `${text1}${underscore1}`",
                    "              : `${underscore2}${text2}`",
                    "            ).replace(/_/g, \"\\\\_\")",
                    "        ); // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis",
                    "",
                    "      const isFirstSentence = (node, name, index) =>",
                    "        node.type === \"sentence\" && index === 0;",
                    "      const isLastChildAutolink = (node, name, index) =>",
                    "        isAutolink(node.children[index - 1]);",
                    "",
                    "      if (",
                    "        escapedValue !== node.value &&",
                    "        (path.match(undefined, isFirstSentence, isLastChildAutolink) ||",
                    "          path.match(",
                    "            undefined,",
                    "            isFirstSentence,",
                    "            (node, name, index) => node.type === \"emphasis\" && index === 0,",
                    "            isLastChildAutolink",
                    "          ))",
                    "      ) {",
                    "        // backslash is parsed as part of autolinks, so we need to remove it",
                    "        escapedValue = escapedValue.replace(/^(\\\\?[*_])+/, (prefix) =>",
                    "          prefix.replace(/\\\\/g, \"\")",
                    "        );",
                    "      }",
                    "",
                    "      return escapedValue;",
                    "    }",
                    "    case \"whitespace\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const index = parentNode.children.indexOf(node);",
                    "      const nextNode = parentNode.children[index + 1];",
                    "",
                    "      const proseWrap =",
                    "        // leading char that may cause different syntax",
                    "        nextNode && /^>|^(?:[*+-]|#{1,6}|\\d+[).])$/.test(nextNode.value)",
                    "          ? \"never\"",
                    "          : options.proseWrap;",
                    "",
                    "      return printLine(path, node.value, { proseWrap });",
                    "    }",
                    "    case \"emphasis\": {",
                    "      let style;",
                    "      if (isAutolink(node.children[0])) {",
                    "        style = options.originalText[node.position.start.offset];",
                    "      } else {",
                    "        const parentNode = path.getParentNode();",
                    "        const index = parentNode.children.indexOf(node);",
                    "        const prevNode = parentNode.children[index - 1];",
                    "        const nextNode = parentNode.children[index + 1];",
                    "        const hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not",
                    "          (prevNode &&",
                    "            prevNode.type === \"sentence\" &&",
                    "            prevNode.children.length > 0 &&",
                    "            getLast(prevNode.children).type === \"word\" &&",
                    "            !getLast(prevNode.children).hasTrailingPunctuation) ||",
                    "          (nextNode &&",
                    "            nextNode.type === \"sentence\" &&",
                    "            nextNode.children.length > 0 &&",
                    "            nextNode.children[0].type === \"word\" &&",
                    "            !nextNode.children[0].hasLeadingPunctuation);",
                    "        style =",
                    "          hasPrevOrNextWord || getAncestorNode(path, \"emphasis\") ? \"*\" : \"_\";",
                    "      }",
                    "      return [style, printChildren(path, options, print), style];",
                    "    }",
                    "    case \"strong\":",
                    "      return [\"**\", printChildren(path, options, print), \"**\"];",
                    "    case \"delete\":",
                    "      return [\"~~\", printChildren(path, options, print), \"~~\"];",
                    "    case \"inlineCode\": {",
                    "      const backtickCount = getMinNotPresentContinuousCount(node.value, \"`\");",
                    "      const style = \"`\".repeat(backtickCount || 1);",
                    "      const gap = backtickCount && !/^\\s/.test(node.value) ? \" \" : \"\";",
                    "      return [style, gap, node.value, gap, style];",
                    "    }",
                    "    case \"wikiLink\": {",
                    "      let contents = \"\";",
                    "      if (options.proseWrap === \"preserve\") {",
                    "        contents = node.value;",
                    "      } else {",
                    "        contents = node.value.replace(/[\\t\\n]+/g, \" \");",
                    "      }",
                    "",
                    "      return [\"[[\", contents, \"]]\"];",
                    "    }",
                    "    case \"link\":",
                    "      switch (options.originalText[node.position.start.offset]) {",
                    "        case \"<\": {",
                    "          const mailto = \"mailto:\";",
                    "          const url =",
                    "            // <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }",
                    "            node.url.startsWith(mailto) &&",
                    "            options.originalText.slice(",
                    "              node.position.start.offset + 1,",
                    "              node.position.start.offset + 1 + mailto.length",
                    "            ) !== mailto",
                    "              ? node.url.slice(mailto.length)",
                    "              : node.url;",
                    "          return [\"<\", url, \">\"];",
                    "        }",
                    "        case \"[\":",
                    "          return [",
                    "            \"[\",",
                    "            printChildren(path, options, print),",
                    "            \"](\",",
                    "            printUrl(node.url, \")\"),",
                    "            printTitle(node.title, options),",
                    "            \")\",",
                    "          ];",
                    "        default:",
                    "          return options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          );",
                    "      }",
                    "    case \"image\":",
                    "      return [",
                    "        \"![\",",
                    "        node.alt || \"\",",
                    "        \"](\",",
                    "        printUrl(node.url, \")\"),",
                    "        printTitle(node.title, options),",
                    "        \")\",",
                    "      ];",
                    "    case \"blockquote\":",
                    "      return [\"> \", align(\"> \", printChildren(path, options, print))];",
                    "    case \"heading\":",
                    "      return [",
                    "        \"#\".repeat(node.depth) + \" \",",
                    "        printChildren(path, options, print),",
                    "      ];",
                    "    case \"code\": {",
                    "      if (node.isIndented) {",
                    "        // indented code block",
                    "        const alignment = \" \".repeat(4);",
                    "        return align(alignment, [",
                    "          alignment,",
                    "          ...replaceTextEndOfLine(node.value, hardline),",
                    "        ]);",
                    "      }",
                    "",
                    "      // fenced code block",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "      );",
                    "      return [",
                    "        style,",
                    "        node.lang || \"\",",
                    "        node.meta ? \" \" + node.meta : \"\",",
                    "        hardline,",
                    "",
                    "        ...replaceTextEndOfLine(",
                    "          getFencedCodeBlockValue(node, options.originalText),",
                    "          hardline",
                    "        ),",
                    "        hardline,",
                    "        style,",
                    "      ];",
                    "    }",
                    "    case \"html\": {",
                    "      const parentNode = path.getParentNode();",
                    "      const value =",
                    "        parentNode.type === \"root\" && getLast(parentNode.children) === node",
                    "          ? node.value.trimEnd()",
                    "          : node.value;",
                    "      const isHtmlComment = /^<!--.*-->$/s.test(value);",
                    "",
                    "      return replaceTextEndOfLine(",
                    "        value,",
                    "        // @ts-expect-error",
                    "        isHtmlComment ? hardline : markAsRoot(literalline)",
                    "      );",
                    "    }",
                    "    case \"list\": {",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        node,",
                    "        path.getParentNode()",
                    "      );",
                    "",
                    "      const isGitDiffFriendlyOrderedList = hasGitDiffFriendlyOrderedList(",
                    "        node,",
                    "        options",
                    "      );",
                    "",
                    "      return printChildren(path, options, print, {",
                    "        processor: (childPath, index) => {",
                    "          const prefix = getPrefix();",
                    "          const childNode = childPath.getValue();",
                    "",
                    "          if (",
                    "            childNode.children.length === 2 &&",
                    "            childNode.children[1].type === \"html\" &&",
                    "            childNode.children[0].position.start.column !==",
                    "              childNode.children[1].position.start.column",
                    "          ) {",
                    "            return [prefix, printListItem(childPath, options, print, prefix)];",
                    "          }",
                    "",
                    "          return [",
                    "            prefix,",
                    "            align(",
                    "              \" \".repeat(prefix.length),",
                    "              printListItem(childPath, options, print, prefix)",
                    "            ),",
                    "          ];",
                    "",
                    "          function getPrefix() {",
                    "            const rawPrefix = node.ordered",
                    "              ? (index === 0",
                    "                  ? node.start",
                    "                  : isGitDiffFriendlyOrderedList",
                    "                  ? 1",
                    "                  : node.start + index) +",
                    "                (nthSiblingIndex % 2 === 0 ? \". \" : \") \")",
                    "              : nthSiblingIndex % 2 === 0",
                    "              ? \"- \"",
                    "              : \"* \";",
                    "",
                    "            return node.isAligned ||",
                    "              /* workaround for https://github.com/remarkjs/remark/issues/315 */ node.hasIndentedCodeblock",
                    "              ? alignListPrefix(rawPrefix, options)",
                    "              : rawPrefix;",
                    "          }",
                    "        },",
                    "      });",
                    "    }",
                    "    case \"thematicBreak\": {",
                    "      const counter = getAncestorCounter(path, \"list\");",
                    "      if (counter === -1) {",
                    "        return \"---\";",
                    "      }",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        path.getParentNode(counter),",
                    "        path.getParentNode(counter + 1)",
                    "      );",
                    "      return nthSiblingIndex % 2 === 0 ? \"***\" : \"---\";",
                    "    }",
                    "    case \"linkReference\":",
                    "      return [",
                    "        \"[\",",
                    "        printChildren(path, options, print),",
                    "        \"]\",",
                    "        node.referenceType === \"full\"",
                    "          ? [\"[\", node.identifier, \"]\"]",
                    "          : node.referenceType === \"collapsed\"",
                    "          ? \"[]\"",
                    "          : \"\",",
                    "      ];",
                    "    case \"imageReference\":",
                    "      switch (node.referenceType) {",
                    "        case \"full\":",
                    "          return [\"![\", node.alt || \"\", \"][\", node.identifier, \"]\"];",
                    "        default:",
                    "          return [",
                    "            \"![\",",
                    "            node.alt,",
                    "            \"]\",",
                    "            node.referenceType === \"collapsed\" ? \"[]\" : \"\",",
                    "          ];",
                    "      }",
                    "    case \"definition\": {",
                    "      const lineOrSpace = options.proseWrap === \"always\" ? line : \" \";",
                    "      return group([",
                    "        \"[\",",
                    "        node.identifier,",
                    "        \"]:\",",
                    "        indent([",
                    "          lineOrSpace,",
                    "          printUrl(node.url),",
                    "          node.title === null",
                    "            ? \"\"",
                    "            : [lineOrSpace, printTitle(node.title, options, false)],",
                    "        ]),",
                    "      ]);",
                    "    }",
                    "    // `footnote` requires `.use(footnotes, {inlineNotes: true})`, we are not using this option",
                    "    // https://github.com/remarkjs/remark-footnotes#optionsinlinenotes",
                    "    /* istanbul ignore next */",
                    "    case \"footnote\":",
                    "      return [\"[^\", printChildren(path, options, print), \"]\"];",
                    "    case \"footnoteReference\":",
                    "      return [\"[^\", node.identifier, \"]\"];",
                    "    case \"footnoteDefinition\": {",
                    "      const nextNode = path.getParentNode().children[path.getName() + 1];",
                    "      const shouldInlineFootnote =",
                    "        node.children.length === 1 &&",
                    "        node.children[0].type === \"paragraph\" &&",
                    "        (options.proseWrap === \"never\" ||",
                    "          (options.proseWrap === \"preserve\" &&",
                    "            node.children[0].position.start.line ===",
                    "              node.children[0].position.end.line));",
                    "      return [",
                    "        \"[^\",",
                    "        node.identifier,",
                    "        \"]: \",",
                    "        shouldInlineFootnote",
                    "          ? printChildren(path, options, print)",
                    "          : group([",
                    "              align(",
                    "                \" \".repeat(4),",
                    "                printChildren(path, options, print, {",
                    "                  processor: (childPath, index) =>",
                    "                    index === 0 ? group([softline, print()]) : print(),",
                    "                })",
                    "              ),",
                    "              nextNode && nextNode.type === \"footnoteDefinition\"",
                    "                ? softline",
                    "                : \"\",",
                    "            ]),",
                    "      ];",
                    "    }",
                    "    case \"table\":",
                    "      return printTable(path, options, print);",
                    "    case \"tableCell\":",
                    "      return printChildren(path, options, print);",
                    "    case \"break\":",
                    "      return /\\s/.test(options.originalText[node.position.start.offset])",
                    "        ? [\"  \", markAsRoot(literalline)]",
                    "        : [\"\\\\\", hardline];",
                    "    case \"liquidNode\":",
                    "      return replaceTextEndOfLine(node.value, hardline);",
                    "    // MDX",
                    "    // fallback to the original text if multiparser failed",
                    "    // or `embeddedLanguageFormatting: \"off\"`",
                    "    case \"importExport\":",
                    "      return [node.value, hardline];",
                    "    case \"esComment\":",
                    "      return [\"{/* \", node.value, \" */}\"];",
                    "    case \"jsx\":",
                    "      return node.value;",
                    "    case \"math\":",
                    "      return [",
                    "        \"$$\",",
                    "        hardline,",
                    "        node.value",
                    "          ? [...replaceTextEndOfLine(node.value, hardline), hardline]",
                    "          : \"\",",
                    "        \"$$\",",
                    "      ];",
                    "    case \"inlineMath\": {",
                    "      // remark-math trims content but we don't want to remove whitespaces",
                    "      // since it's very possible that it's recognized as math accidentally",
                    "      return options.originalText.slice(locStart(node), locEnd(node));",
                    "    }",
                    "",
                    "    case \"tableRow\": // handled in \"table\"",
                    "    case \"listItem\": // handled in \"list\"",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unknown markdown type ${JSON.stringify(node.type)}`);",
                    "  }",
                    "}",
                    "",
                    "function printListItem(path, options, print, listPrefix) {",
                    "  const node = path.getValue();",
                    "  const prefix = node.checked === null ? \"\" : node.checked ? \"[x] \" : \"[ ] \";",
                    "  return [",
                    "    prefix,",
                    "    printChildren(path, options, print, {",
                    "      processor: (childPath, index) => {",
                    "        if (index === 0 && childPath.getValue().type !== \"list\") {",
                    "          return align(\" \".repeat(prefix.length), print());",
                    "        }",
                    "",
                    "        const alignment = \" \".repeat(",
                    "          clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block",
                    "        );",
                    "        return [alignment, align(alignment, print())];",
                    "      },",
                    "    }),",
                    "  ];",
                    "}",
                    "",
                    "function alignListPrefix(prefix, options) {",
                    "  const additionalSpaces = getAdditionalSpaces();",
                    "  return (",
                    "    prefix +",
                    "    \" \".repeat(",
                    "      additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block",
                    "    )",
                    "  );",
                    "",
                    "  function getAdditionalSpaces() {",
                    "    const restSpaces = prefix.length % options.tabWidth;",
                    "    return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;",
                    "  }",
                    "}",
                    "",
                    "function getNthListSiblingIndex(node, parentNode) {",
                    "  return getNthSiblingIndex(",
                    "    node,",
                    "    parentNode,",
                    "    (siblingNode) => siblingNode.ordered === node.ordered",
                    "  );",
                    "}",
                    "",
                    "function getNthSiblingIndex(node, parentNode, condition) {",
                    "  let index = -1;",
                    "",
                    "  for (const childNode of parentNode.children) {",
                    "    if (childNode.type === node.type && condition(childNode)) {",
                    "      index++;",
                    "    } else {",
                    "      index = -1;",
                    "    }",
                    "",
                    "    if (childNode === node) {",
                    "      return index;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getAncestorCounter(path, typeOrTypes) {",
                    "  const types = Array.isArray(typeOrTypes) ? typeOrTypes : [typeOrTypes];",
                    "",
                    "  let counter = -1;",
                    "  let ancestorNode;",
                    "",
                    "  while ((ancestorNode = path.getParentNode(++counter))) {",
                    "    if (types.includes(ancestorNode.type)) {",
                    "      return counter;",
                    "    }",
                    "  }",
                    "",
                    "  return -1;",
                    "}",
                    "",
                    "function getAncestorNode(path, typeOrTypes) {",
                    "  const counter = getAncestorCounter(path, typeOrTypes);",
                    "  return counter === -1 ? null : path.getParentNode(counter);",
                    "}",
                    "",
                    "function printLine(path, value, options) {",
                    "  if (options.proseWrap === \"preserve\" && value === \"\\n\") {",
                    "    return hardline;",
                    "  }",
                    "",
                    "  const isBreakable =",
                    "    options.proseWrap === \"always\" &&",
                    "    !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);",
                    "  return value !== \"\"",
                    "    ? isBreakable",
                    "      ? line",
                    "      : \" \"",
                    "    : isBreakable",
                    "    ? softline",
                    "    : \"\";",
                    "}",
                    "",
                    "function printTable(path, options, print) {",
                    "  const node = path.getValue();",
                    "",
                    "  const columnMaxWidths = [];",
                    "  // { [rowIndex: number]: { [columnIndex: number]: {text: string, width: number} } }",
                    "  const contents = path.map(",
                    "    (rowPath) =>",
                    "      rowPath.map((cellPath, columnIndex) => {",
                    "        const text = printDocToString(print(), options).formatted;",
                    "        const width = getStringWidth(text);",
                    "        columnMaxWidths[columnIndex] = Math.max(",
                    "          columnMaxWidths[columnIndex] || 3, // minimum width = 3 (---, :--, :-:, --:)",
                    "          width",
                    "        );",
                    "        return { text, width };",
                    "      }, \"children\"),",
                    "    \"children\"",
                    "  );",
                    "",
                    "  const alignedTable = printTableContents(/* isCompact */ false);",
                    "  if (options.proseWrap !== \"never\") {",
                    "    return [breakParent, alignedTable];",
                    "  }",
                    "",
                    "  // Only if the --prose-wrap never is set and it exceeds the print width.",
                    "  const compactTable = printTableContents(/* isCompact */ true);",
                    "  return [breakParent, group(ifBreak(compactTable, alignedTable))];",
                    "",
                    "  function printTableContents(isCompact) {",
                    "    /** @type{Doc[]} */",
                    "    const parts = [printRow(contents[0], isCompact), printAlign(isCompact)];",
                    "    if (contents.length > 1) {",
                    "      parts.push(",
                    "        join(",
                    "          hardlineWithoutBreakParent,",
                    "          contents",
                    "            .slice(1)",
                    "            .map((rowContents) => printRow(rowContents, isCompact))",
                    "        )",
                    "      );",
                    "    }",
                    "    return join(hardlineWithoutBreakParent, parts);",
                    "  }",
                    "",
                    "  function printAlign(isCompact) {",
                    "    const align = columnMaxWidths.map((width, index) => {",
                    "      const align = node.align[index];",
                    "      const first = align === \"center\" || align === \"left\" ? \":\" : \"-\";",
                    "      const last = align === \"center\" || align === \"right\" ? \":\" : \"-\";",
                    "      const middle = isCompact ? \"-\" : \"-\".repeat(width - 2);",
                    "      return `${first}${middle}${last}`;",
                    "    });",
                    "",
                    "    return `| ${align.join(\" | \")} |`;",
                    "  }",
                    "",
                    "  function printRow(rowContents, isCompact) {",
                    "    const columns = rowContents.map(({ text, width }, columnIndex) => {",
                    "      if (isCompact) {",
                    "        return text;",
                    "      }",
                    "      const spaces = columnMaxWidths[columnIndex] - width;",
                    "      const align = node.align[columnIndex];",
                    "      let before = 0;",
                    "      if (align === \"right\") {",
                    "        before = spaces;",
                    "      } else if (align === \"center\") {",
                    "        before = Math.floor(spaces / 2);",
                    "      }",
                    "      const after = spaces - before;",
                    "      return `${\" \".repeat(before)}${text}${\" \".repeat(after)}`;",
                    "    });",
                    "",
                    "    return `| ${columns.join(\" | \")} |`;",
                    "  }",
                    "}",
                    "",
                    "function printRoot(path, options, print) {",
                    "  /** @typedef {{ index: number, offset: number }} IgnorePosition */",
                    "  /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */",
                    "  const ignoreRanges = [];",
                    "",
                    "  /** @type {IgnorePosition | null} */",
                    "  let ignoreStart = null;",
                    "",
                    "  const { children } = path.getValue();",
                    "  for (const [index, childNode] of children.entries()) {",
                    "    switch (isPrettierIgnore(childNode)) {",
                    "      case \"start\":",
                    "        if (ignoreStart === null) {",
                    "          ignoreStart = { index, offset: childNode.position.end.offset };",
                    "        }",
                    "        break;",
                    "      case \"end\":",
                    "        if (ignoreStart !== null) {",
                    "          ignoreRanges.push({",
                    "            start: ignoreStart,",
                    "            end: { index, offset: childNode.position.start.offset },",
                    "          });",
                    "          ignoreStart = null;",
                    "        }",
                    "        break;",
                    "      default:",
                    "        // do nothing",
                    "        break;",
                    "    }",
                    "  }",
                    "",
                    "  return printChildren(path, options, print, {",
                    "    processor: (childPath, index) => {",
                    "      if (ignoreRanges.length > 0) {",
                    "        const ignoreRange = ignoreRanges[0];",
                    "",
                    "        if (index === ignoreRange.start.index) {",
                    "          return [",
                    "            children[ignoreRange.start.index].value,",
                    "            options.originalText.slice(",
                    "              ignoreRange.start.offset,",
                    "              ignoreRange.end.offset",
                    "            ),",
                    "            children[ignoreRange.end.index].value,",
                    "          ];",
                    "        }",
                    "",
                    "        if (ignoreRange.start.index < index && index < ignoreRange.end.index) {",
                    "          return false;",
                    "        }",
                    "",
                    "        if (index === ignoreRange.end.index) {",
                    "          ignoreRanges.shift();",
                    "          return false;",
                    "        }",
                    "      }",
                    "",
                    "      return print();",
                    "    },",
                    "  });",
                    "}",
                    "",
                    "function printChildren(path, options, print, events = {}) {",
                    "  const { postprocessor } = events;",
                    "  const processor = events.processor || (() => print());",
                    "",
                    "  const node = path.getValue();",
                    "  const parts = [];",
                    "",
                    "  let lastChildNode;",
                    "",
                    "  path.each((childPath, index) => {",
                    "    const childNode = childPath.getValue();",
                    "",
                    "    const result = processor(childPath, index);",
                    "    if (result !== false) {",
                    "      const data = {",
                    "        parts,",
                    "        prevNode: lastChildNode,",
                    "        parentNode: node,",
                    "        options,",
                    "      };",
                    "",
                    "      if (shouldPrePrintHardline(childNode, data)) {",
                    "        parts.push(hardline);",
                    "",
                    "        // Can't find a case to pass `shouldPrePrintTripleHardline`",
                    "        /* istanbul ignore next */",
                    "        if (lastChildNode && TRAILING_HARDLINE_NODES.has(lastChildNode.type)) {",
                    "          if (shouldPrePrintTripleHardline(childNode, data)) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        } else {",
                    "          if (",
                    "            shouldPrePrintDoubleHardline(childNode, data) ||",
                    "            shouldPrePrintTripleHardline(childNode, data)",
                    "          ) {",
                    "            parts.push(hardline);",
                    "          }",
                    "",
                    "          if (shouldPrePrintTripleHardline(childNode, data)) {",
                    "            parts.push(hardline);",
                    "          }",
                    "        }",
                    "      }",
                    "",
                    "      parts.push(result);",
                    "",
                    "      lastChildNode = childNode;",
                    "    }",
                    "  }, \"children\");",
                    "",
                    "  return postprocessor ? postprocessor(parts) : parts;",
                    "}",
                    "",
                    "function getLastDescendantNode(node) {",
                    "  let current = node;",
                    "  while (isNonEmptyArray(current.children)) {",
                    "    current = getLast(current.children);",
                    "  }",
                    "  return current;",
                    "}",
                    "",
                    "/** @return {false | 'next' | 'start' | 'end'} */",
                    "function isPrettierIgnore(node) {",
                    "  let match;",
                    "",
                    "  if (node.type === \"html\") {",
                    "    match = node.value.match(/^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/);",
                    "  } else {",
                    "    let comment;",
                    "",
                    "    if (node.type === \"esComment\") {",
                    "      comment = node;",
                    "    } else if (",
                    "      node.type === \"paragraph\" &&",
                    "      node.children.length === 1 &&",
                    "      node.children[0].type === \"esComment\"",
                    "    ) {",
                    "      comment = node.children[0];",
                    "    }",
                    "",
                    "    if (comment) {",
                    "      match = comment.value.match(/^prettier-ignore(?:-(start|end))?$/);",
                    "    }",
                    "  }",
                    "",
                    "  return match ? (match[1] ? match[1] : \"next\") : false;",
                    "}",
                    "",
                    "function shouldPrePrintHardline(node, data) {",
                    "  const isFirstNode = data.parts.length === 0;",
                    "  const isInlineNode = INLINE_NODE_TYPES.includes(node.type);",
                    "",
                    "  const isInlineHTML =",
                    "    node.type === \"html\" &&",
                    "    INLINE_NODE_WRAPPER_TYPES.includes(data.parentNode.type);",
                    "",
                    "  return !isFirstNode && !isInlineNode && !isInlineHTML;",
                    "}",
                    "",
                    "function shouldPrePrintDoubleHardline(node, data) {",
                    "  const isSequence = (data.prevNode && data.prevNode.type) === node.type;",
                    "  const isSiblingNode = isSequence && SIBLING_NODE_TYPES.has(node.type);",
                    "",
                    "  const isInTightListItem =",
                    "    data.parentNode.type === \"listItem\" && !data.parentNode.loose;",
                    "",
                    "  const isPrevNodeLooseListItem =",
                    "    data.prevNode && data.prevNode.type === \"listItem\" && data.prevNode.loose;",
                    "",
                    "  const isPrevNodePrettierIgnore = isPrettierIgnore(data.prevNode) === \"next\";",
                    "",
                    "  const isBlockHtmlWithoutBlankLineBetweenPrevHtml =",
                    "    node.type === \"html\" &&",
                    "    data.prevNode &&",
                    "    data.prevNode.type === \"html\" &&",
                    "    data.prevNode.position.end.line + 1 === node.position.start.line;",
                    "",
                    "  const isHtmlDirectAfterListItem =",
                    "    node.type === \"html\" &&",
                    "    data.parentNode.type === \"listItem\" &&",
                    "    data.prevNode &&",
                    "    data.prevNode.type === \"paragraph\" &&",
                    "    data.prevNode.position.end.line + 1 === node.position.start.line;",
                    "",
                    "  return (",
                    "    isPrevNodeLooseListItem ||",
                    "    !(",
                    "      isSiblingNode ||",
                    "      isInTightListItem ||",
                    "      isPrevNodePrettierIgnore ||",
                    "      isBlockHtmlWithoutBlankLineBetweenPrevHtml ||",
                    "      isHtmlDirectAfterListItem",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function shouldPrePrintTripleHardline(node, data) {",
                    "  const isPrevNodeList = data.prevNode && data.prevNode.type === \"list\";",
                    "  const isIndentedCode = node.type === \"code\" && node.isIndented;",
                    "",
                    "  return isPrevNodeList && isIndentedCode;",
                    "}",
                    "",
                    "function shouldRemainTheSameContent(path) {",
                    "  const ancestorNode = getAncestorNode(path, [",
                    "    \"linkReference\",",
                    "    \"imageReference\",",
                    "  ]);",
                    "",
                    "  return (",
                    "    ancestorNode &&",
                    "    (ancestorNode.type !== \"linkReference\" ||",
                    "      ancestorNode.referenceType !== \"full\")",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} url",
                    " * @param {string[] | string} [dangerousCharOrChars]",
                    " * @returns {string}",
                    " */",
                    "function printUrl(url, dangerousCharOrChars = []) {",
                    "  const dangerousChars = [",
                    "    \" \",",
                    "    ...(Array.isArray(dangerousCharOrChars)",
                    "      ? dangerousCharOrChars",
                    "      : [dangerousCharOrChars]),",
                    "  ];",
                    "  return new RegExp(dangerousChars.map((x) => `\\\\${x}`).join(\"|\")).test(url)",
                    "    ? `<${url}>`",
                    "    : url;",
                    "}",
                    "",
                    "function printTitle(title, options, printSpace = true) {",
                    "  if (!title) {",
                    "    return \"\";",
                    "  }",
                    "  if (printSpace) {",
                    "    return \" \" + printTitle(title, options, false);",
                    "  }",
                    "",
                    "  // title is escaped after `remark-parse` v7",
                    "  title = title.replace(/\\\\([\"')])/g, \"$1\");",
                    "",
                    "  if (title.includes('\"') && title.includes(\"'\") && !title.includes(\")\")) {",
                    "    return `(${title})`; // avoid escaped quotes",
                    "  }",
                    "  // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split",
                    "  const singleCount = title.split(\"'\").length - 1;",
                    "  const doubleCount = title.split('\"').length - 1;",
                    "  const quote =",
                    "    singleCount > doubleCount",
                    "      ? '\"'",
                    "      : doubleCount > singleCount",
                    "      ? \"'\"",
                    "      : options.singleQuote",
                    "      ? \"'\"",
                    "      : '\"';",
                    "  title = title.replace(/\\\\/, \"\\\\\\\\\");",
                    "  title = title.replace(new RegExp(`(${quote})`, \"g\"), \"\\\\$1\");",
                    "  return `${quote}${title}${quote}`;",
                    "}",
                    "",
                    "function clamp(value, min, max) {",
                    "  return value < min ? min : value > max ? max : value;",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const index = Number(path.getName());",
                    "",
                    "  if (index === 0) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const prevNode = path.getParentNode().children[index - 1];",
                    "  return isPrettierIgnore(prevNode) === \"next\";",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  embed,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { getLast } = require(\"../common/util.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "const {",
                    "  cjkPattern,",
                    "  kPattern,",
                    "  punctuationPattern,",
                    "} = require(\"./constants.evaluate.js\");",
                    "",
                    "const INLINE_NODE_TYPES = [",
                    "  \"liquidNode\",",
                    "  \"inlineCode\",",
                    "  \"emphasis\",",
                    "  \"esComment\",",
                    "  \"strong\",",
                    "  \"delete\",",
                    "  \"wikiLink\",",
                    "  \"link\",",
                    "  \"linkReference\",",
                    "  \"image\",",
                    "  \"imageReference\",",
                    "  \"footnote\",",
                    "  \"footnoteReference\",",
                    "  \"sentence\",",
                    "  \"whitespace\",",
                    "  \"word\",",
                    "  \"break\",",
                    "  \"inlineMath\",",
                    "];",
                    "",
                    "const INLINE_NODE_WRAPPER_TYPES = [",
                    "  ...INLINE_NODE_TYPES,",
                    "  \"tableCell\",",
                    "  \"paragraph\",",
                    "  \"heading\",",
                    "];",
                    "",
                    "const kRegex = new RegExp(kPattern);",
                    "const punctuationRegex = new RegExp(punctuationPattern);",
                    "",
                    "/**",
                    " * split text into whitespaces and words",
                    " * @param {string} text",
                    " */",
                    "function splitText(text, options) {",
                    "  const KIND_NON_CJK = \"non-cjk\";",
                    "  const KIND_CJ_LETTER = \"cj-letter\";",
                    "  const KIND_K_LETTER = \"k-letter\";",
                    "  const KIND_CJK_PUNCTUATION = \"cjk-punctuation\";",
                    "",
                    "  /** @type {Array<{ type: \"whitespace\", value: \" \" | \"\\n\" | \"\" } | { type: \"word\", value: string }>} */",
                    "  const nodes = [];",
                    "",
                    "  const tokens = (",
                    "    options.proseWrap === \"preserve\"",
                    "      ? text",
                    "      : text.replace(",
                    "          new RegExp(`(${cjkPattern})\\n(${cjkPattern})`, \"g\"),",
                    "          \"$1$2\"",
                    "        )",
                    "  ).split(/([\\t\\n ]+)/);",
                    "  for (const [index, token] of tokens.entries()) {",
                    "    // whitespace",
                    "    if (index % 2 === 1) {",
                    "      nodes.push({",
                    "        type: \"whitespace\",",
                    "        value: /\\n/.test(token) ? \"\\n\" : \" \",",
                    "      });",
                    "      continue;",
                    "    }",
                    "",
                    "    // word separated by whitespace",
                    "",
                    "    if ((index === 0 || index === tokens.length - 1) && token === \"\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    const innerTokens = token.split(new RegExp(`(${cjkPattern})`));",
                    "    for (const [innerIndex, innerToken] of innerTokens.entries()) {",
                    "      if (",
                    "        (innerIndex === 0 || innerIndex === innerTokens.length - 1) &&",
                    "        innerToken === \"\"",
                    "      ) {",
                    "        continue;",
                    "      }",
                    "",
                    "      // non-CJK word",
                    "      if (innerIndex % 2 === 0) {",
                    "        if (innerToken !== \"\") {",
                    "          appendNode({",
                    "            type: \"word\",",
                    "            value: innerToken,",
                    "            kind: KIND_NON_CJK,",
                    "            hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),",
                    "            hasTrailingPunctuation: punctuationRegex.test(getLast(innerToken)),",
                    "          });",
                    "        }",
                    "        continue;",
                    "      }",
                    "",
                    "      // CJK character",
                    "      appendNode(",
                    "        punctuationRegex.test(innerToken)",
                    "          ? {",
                    "              type: \"word\",",
                    "              value: innerToken,",
                    "              kind: KIND_CJK_PUNCTUATION,",
                    "              hasLeadingPunctuation: true,",
                    "              hasTrailingPunctuation: true,",
                    "            }",
                    "          : {",
                    "              type: \"word\",",
                    "              value: innerToken,",
                    "              kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,",
                    "              hasLeadingPunctuation: false,",
                    "              hasTrailingPunctuation: false,",
                    "            }",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return nodes;",
                    "",
                    "  function appendNode(node) {",
                    "    const lastNode = getLast(nodes);",
                    "    if (lastNode && lastNode.type === \"word\") {",
                    "      if (",
                    "        (lastNode.kind === KIND_NON_CJK &&",
                    "          node.kind === KIND_CJ_LETTER &&",
                    "          !lastNode.hasTrailingPunctuation) ||",
                    "        (lastNode.kind === KIND_CJ_LETTER &&",
                    "          node.kind === KIND_NON_CJK &&",
                    "          !node.hasLeadingPunctuation)",
                    "      ) {",
                    "        nodes.push({ type: \"whitespace\", value: \" \" });",
                    "      } else if (",
                    "        !isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) &&",
                    "        // disallow leading/trailing full-width whitespace",
                    "        ![lastNode.value, node.value].some((value) => /\\u3000/.test(value))",
                    "      ) {",
                    "        nodes.push({ type: \"whitespace\", value: \"\" });",
                    "      }",
                    "    }",
                    "    nodes.push(node);",
                    "",
                    "    function isBetween(kind1, kind2) {",
                    "      return (",
                    "        (lastNode.kind === kind1 && node.kind === kind2) ||",
                    "        (lastNode.kind === kind2 && node.kind === kind1)",
                    "      );",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getOrderedListItemInfo(orderListItem, originalText) {",
                    "  const [, numberText, marker, leadingSpaces] = originalText",
                    "    .slice(",
                    "      orderListItem.position.start.offset,",
                    "      orderListItem.position.end.offset",
                    "    )",
                    "    .match(/^\\s*(\\d+)(\\.|\\))(\\s*)/);",
                    "",
                    "  return { numberText, marker, leadingSpaces };",
                    "}",
                    "",
                    "function hasGitDiffFriendlyOrderedList(node, options) {",
                    "  if (!node.ordered) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (node.children.length < 2) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const firstNumber = Number(",
                    "    getOrderedListItemInfo(node.children[0], options.originalText).numberText",
                    "  );",
                    "",
                    "  const secondNumber = Number(",
                    "    getOrderedListItemInfo(node.children[1], options.originalText).numberText",
                    "  );",
                    "",
                    "  if (firstNumber === 0 && node.children.length > 2) {",
                    "    const thirdNumber = Number(",
                    "      getOrderedListItemInfo(node.children[2], options.originalText).numberText",
                    "    );",
                    "",
                    "    return secondNumber === 1 && thirdNumber === 1;",
                    "  }",
                    "",
                    "  return secondNumber === 1;",
                    "}",
                    "",
                    "// The final new line should not include in value",
                    "// https://github.com/remarkjs/remark/issues/512",
                    "function getFencedCodeBlockValue(node, originalText) {",
                    "  const { value } = node;",
                    "  if (",
                    "    node.position.end.offset === originalText.length &&",
                    "    value.endsWith(\"\\n\") &&",
                    "    // Code block has no end mark",
                    "    originalText.endsWith(\"\\n\")",
                    "  ) {",
                    "    return value.slice(0, -1);",
                    "  }",
                    "  return value;",
                    "}",
                    "",
                    "function mapAst(ast, handler) {",
                    "  return (function preorder(node, index, parentStack) {",
                    "    const newNode = { ...handler(node, index, parentStack) };",
                    "    if (newNode.children) {",
                    "      newNode.children = newNode.children.map((child, index) =>",
                    "        preorder(child, index, [newNode, ...parentStack])",
                    "      );",
                    "    }",
                    "",
                    "    return newNode;",
                    "  })(ast, null, []);",
                    "}",
                    "",
                    "function isAutolink(node) {",
                    "  if (!node || node.type !== \"link\" || node.children.length !== 1) {",
                    "    return false;",
                    "  }",
                    "  const child = node.children[0];",
                    "  return (",
                    "    child &&",
                    "    locStart(node) === locStart(child) &&",
                    "    locEnd(node) === locEnd(child)",
                    "  );",
                    "}",
                    "",
                    "module.exports = {",
                    "  mapAst,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  getFencedCodeBlockValue,",
                    "  getOrderedListItemInfo,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "  isAutolink,",
                    "};"
                ]
            },
            "unified-plugins": {
                "front-matter.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const parseFrontMatter = require(\"../../utils/front-matter/parse.js\");",
                        "",
                        "function frontMatter() {",
                        "  const proto = this.Parser.prototype;",
                        "  proto.blockMethods = [\"frontMatter\", ...proto.blockMethods];",
                        "  proto.blockTokenizers.frontMatter = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const parsed = parseFrontMatter(value);",
                        "",
                        "    if (parsed.frontMatter) {",
                        "      return eat(parsed.frontMatter.raw)(parsed.frontMatter);",
                        "    }",
                        "  }",
                        "  tokenizer.onlyAtStart = true;",
                        "}",
                        "",
                        "module.exports = frontMatter;"
                    ]
                },
                "html-to-jsx.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const mdx = require(\"../mdx.js\");",
                        "const { mapAst, INLINE_NODE_WRAPPER_TYPES } = require(\"../utils.js\");",
                        "",
                        "function htmlToJsx() {",
                        "  return (ast) =>",
                        "    mapAst(ast, (node, _index, [parent]) => {",
                        "      if (",
                        "        node.type !== \"html\" ||",
                        "        // Keep HTML-style comments (legacy MDX)",
                        "        mdx.COMMENT_REGEX.test(node.value) ||",
                        "        INLINE_NODE_WRAPPER_TYPES.includes(parent.type)",
                        "      ) {",
                        "        return node;",
                        "      }",
                        "      return { ...node, type: \"jsx\" };",
                        "    });",
                        "}",
                        "",
                        "module.exports = htmlToJsx;"
                    ]
                },
                "liquid.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function liquid() {",
                        "  const proto = this.Parser.prototype;",
                        "  const methods = proto.inlineMethods;",
                        "  methods.splice(methods.indexOf(\"text\"), 0, \"liquid\");",
                        "  proto.inlineTokenizers.liquid = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const match = value.match(/^({%.*?%}|{{.*?}})/s);",
                        "",
                        "    if (match) {",
                        "      return eat(match[0])({",
                        "        type: \"liquidNode\",",
                        "        value: match[0],",
                        "      });",
                        "    }",
                        "  }",
                        "  tokenizer.locator = function (value, fromIndex) {",
                        "    return value.indexOf(\"{\", fromIndex);",
                        "  };",
                        "}",
                        "",
                        "module.exports = liquid;"
                    ]
                },
                "loose-items.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function looseItems() {",
                        "  const proto = this.Parser.prototype;",
                        "  const originalList = proto.blockTokenizers.list;",
                        "",
                        "  function fixListNodes(value, node, parent) {",
                        "    if (node.type === \"listItem\") {",
                        "      node.loose = node.spread || value.charAt(value.length - 1) === \"\\n\";",
                        "      if (node.loose) {",
                        "        parent.loose = true;",
                        "      }",
                        "    }",
                        "    return node;",
                        "  }",
                        "",
                        "  proto.blockTokenizers.list = function list(realEat, value, silent) {",
                        "    function eat(subvalue) {",
                        "      const realAdd = realEat(subvalue);",
                        "",
                        "      function add(node, parent) {",
                        "        return realAdd(fixListNodes(subvalue, node, parent), parent);",
                        "      }",
                        "      add.reset = function (node, parent) {",
                        "        return realAdd.reset(fixListNodes(subvalue, node, parent), parent);",
                        "      };",
                        "",
                        "      return add;",
                        "    }",
                        "    eat.now = realEat.now;",
                        "    return originalList.call(this, eat, value, silent);",
                        "  };",
                        "}",
                        "",
                        "module.exports = looseItems;"
                    ]
                },
                "wiki-link.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "function wikiLink() {",
                        "  const entityType = \"wikiLink\";",
                        "  const wikiLinkRegex = /^\\[\\[(?<linkContents>.+?)]]/s;",
                        "  const proto = this.Parser.prototype;",
                        "  const methods = proto.inlineMethods;",
                        "  methods.splice(methods.indexOf(\"link\"), 0, entityType);",
                        "  proto.inlineTokenizers.wikiLink = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const match = wikiLinkRegex.exec(value);",
                        "",
                        "    if (match) {",
                        "      const linkContents = match.groups.linkContents.trim();",
                        "",
                        "      return eat(match[0])({",
                        "        type: entityType,",
                        "        value: linkContents,",
                        "      });",
                        "    }",
                        "  }",
                        "",
                        "  tokenizer.locator = function (value, fromIndex) {",
                        "    return value.indexOf(\"[\", fromIndex);",
                        "  };",
                        "}",
                        "",
                        "module.exports = wikiLink;"
                    ]
                }
            }
        },
        "language-yaml": {
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function embed(path, print, textToDoc, options) {",
                    "  const node = path.getValue();",
                    "",
                    "  // Try to format `.prettierrc` and `.stylelintrc` as `json` first",
                    "  if (",
                    "    node.type === \"root\" &&",
                    "    options.filepath &&",
                    "    /(?:[/\\\\]|^)\\.(?:prettier|stylelint)rc$/.test(options.filepath)",
                    "  ) {",
                    "    return textToDoc(options.originalText, { ...options, parser: \"json\" });",
                    "  }",
                    "}",
                    "",
                    "module.exports = embed;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createLanguage = require(\"../utils/create-language.js\");",
                    "const printer = require(\"./printer-yaml.js\");",
                    "const options = require(\"./options.js\");",
                    "const parsers = require(\"./parsers.js\");",
                    "",
                    "const languages = [",
                    "  createLanguage(require(\"linguist-languages/data/YAML.json\"), (data) => ({",
                    "    since: \"1.14.0\",",
                    "    parsers: [\"yaml\"],",
                    "    vscodeLanguageIds: [\"yaml\", \"ansible\", \"home-assistant\"],",
                    "    // yarn.lock is not YAML: https://github.com/yarnpkg/yarn/issues/5629",
                    "    filenames: [",
                    "      ...data.filenames.filter((filename) => filename !== \"yarn.lock\"),",
                    "      \".prettierrc\",",
                    "      \".stylelintrc\",",
                    "    ],",
                    "  })),",
                    "];",
                    "",
                    "module.exports = {",
                    "  languages,",
                    "  printers: { yaml: printer },",
                    "  options,",
                    "  parsers,",
                    "};"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function locStart(node) {",
                    "  return node.position.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.position.end.offset;",
                    "}",
                    "",
                    "module.exports = { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const commonOptions = require(\"../common/common-options.js\");",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.js",
                    "module.exports = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  proseWrap: commonOptions.proseWrap,",
                    "};"
                ]
            },
            "parser-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const createError = require(\"../common/parser-create-error.js\");",
                    "const { hasPragma } = require(\"./pragma.js\");",
                    "const { locStart, locEnd } = require(\"./loc.js\");",
                    "",
                    "function parse(text) {",
                    "  const { parse } = require(\"yaml-unist-parser\");",
                    "",
                    "  try {",
                    "    const root = parse(text);",
                    "",
                    "    /**",
                    "     * suppress `comment not printed` error",
                    "     *",
                    "     * comments are handled in printer-yaml.js without using `printComment`",
                    "     * so that it'll always throw errors even if we printed it correctly",
                    "     */",
                    "    delete root.comments;",
                    "",
                    "    return root;",
                    "  } catch (error) {",
                    "    if (error && error.position) {",
                    "      throw createError(error.message, error.position);",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw error;",
                    "  }",
                    "}",
                    "",
                    "const parser = {",
                    "  astFormat: \"yaml\",",
                    "  parse,",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "module.exports = {",
                    "  parsers: {",
                    "    yaml: parser,",
                    "  },",
                    "};"
                ]
            },
            "parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = {",
                    "  get yaml() {",
                    "    return require(\"./parser-yaml.js\").parsers.yaml;",
                    "  },",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function isPragma(text) {",
                    "  return /^\\s*@(?:prettier|format)\\s*$/.test(text);",
                    "}",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(?:prettier|format)\\s*?(?:\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return `# @format\\n\\n${text}`;",
                    "}",
                    "",
                    "module.exports = {",
                    "  isPragma,",
                    "  hasPragma,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "const { defineShortcut, mapNode } = require(\"./utils.js\");",
                    "",
                    "function preprocess(ast) {",
                    "  return mapNode(ast, defineShortcuts);",
                    "}",
                    "",
                    "function defineShortcuts(node) {",
                    "  switch (node.type) {",
                    "    case \"document\":",
                    "      defineShortcut(node, \"head\", () => node.children[0]);",
                    "      defineShortcut(node, \"body\", () => node.children[1]);",
                    "      break;",
                    "    case \"documentBody\":",
                    "    case \"sequenceItem\":",
                    "    case \"flowSequenceItem\":",
                    "    case \"mappingKey\":",
                    "    case \"mappingValue\":",
                    "      defineShortcut(node, \"content\", () => node.children[0]);",
                    "      break;",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\":",
                    "      defineShortcut(node, \"key\", () => node.children[0]);",
                    "      defineShortcut(node, \"value\", () => node.children[1]);",
                    "      break;",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "module.exports = preprocess;"
                ]
            },
            "printer-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/** @typedef {import(\"../document\").Doc} Doc */",
                    "",
                    "const {",
                    "  builders: {",
                    "    breakParent,",
                    "    fill,",
                    "    group,",
                    "    hardline,",
                    "    join,",
                    "    line,",
                    "    lineSuffix,",
                    "    literalline,",
                    "  },",
                    "  utils: { getDocParts, replaceTextEndOfLine },",
                    "} = require(\"../document/index.js\");",
                    "const { isPreviousLineEmpty } = require(\"../common/util.js\");",
                    "const { insertPragma, isPragma } = require(\"./pragma.js\");",
                    "const { locStart } = require(\"./loc.js\");",
                    "const embed = require(\"./embed.js\");",
                    "const {",
                    "  getFlowScalarLineContents,",
                    "  getLastDescendantNode,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "  hasPrettierIgnore,",
                    "  isLastDescendantNode,",
                    "  isNode,",
                    "  isInlineNode,",
                    "} = require(\"./utils.js\");",
                    "const preprocess = require(\"./print-preprocess.js\");",
                    "const {",
                    "  alignWithSpaces,",
                    "  printNextEmptyLine,",
                    "  shouldPrintEndComments,",
                    "} = require(\"./print/misc.js\");",
                    "const {",
                    "  printFlowMapping,",
                    "  printFlowSequence,",
                    "} = require(\"./print/flow-mapping-sequence.js\");",
                    "const printMappingItem = require(\"./print/mapping-item.js\");",
                    "const printBlock = require(\"./print/block.js\");",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const node = path.getValue();",
                    "  /** @type {Doc[]} */",
                    "  const parts = [];",
                    "",
                    "  if (node.type !== \"mappingValue\" && hasLeadingComments(node)) {",
                    "    parts.push([join(hardline, path.map(print, \"leadingComments\")), hardline]);",
                    "  }",
                    "",
                    "  const { tag, anchor } = node;",
                    "  if (tag) {",
                    "    parts.push(print(\"tag\"));",
                    "  }",
                    "  if (tag && anchor) {",
                    "    parts.push(\" \");",
                    "  }",
                    "  if (anchor) {",
                    "    parts.push(print(\"anchor\"));",
                    "  }",
                    "",
                    "  /** @type {Doc} */",
                    "  let nextEmptyLine = \"\";",
                    "",
                    "  if (",
                    "    isNode(node, [",
                    "      \"mapping\",",
                    "      \"sequence\",",
                    "      \"comment\",",
                    "      \"directive\",",
                    "      \"mappingItem\",",
                    "      \"sequenceItem\",",
                    "    ]) &&",
                    "    !isLastDescendantNode(path)",
                    "  ) {",
                    "    nextEmptyLine = printNextEmptyLine(path, options.originalText);",
                    "  }",
                    "",
                    "  if (tag || anchor) {",
                    "    if (isNode(node, [\"sequence\", \"mapping\"]) && !hasMiddleComments(node)) {",
                    "      parts.push(hardline);",
                    "    } else {",
                    "      parts.push(\" \");",
                    "    }",
                    "  }",
                    "",
                    "  if (hasMiddleComments(node)) {",
                    "    parts.push([",
                    "      node.middleComments.length === 1 ? \"\" : hardline,",
                    "      join(hardline, path.map(print, \"middleComments\")),",
                    "      hardline,",
                    "    ]);",
                    "  }",
                    "",
                    "  const parentNode = path.getParentNode();",
                    "  if (hasPrettierIgnore(path)) {",
                    "    parts.push(",
                    "      replaceTextEndOfLine(",
                    "        options.originalText",
                    "          .slice(node.position.start.offset, node.position.end.offset)",
                    "          .trimEnd(),",
                    "        literalline",
                    "      )",
                    "    );",
                    "  } else {",
                    "    parts.push(group(printNode(node, parentNode, path, options, print)));",
                    "  }",
                    "",
                    "  if (hasTrailingComment(node) && !isNode(node, [\"document\", \"documentHead\"])) {",
                    "    parts.push(",
                    "      lineSuffix([",
                    "        node.type === \"mappingValue\" && !node.content ? \"\" : \" \",",
                    "        parentNode.type === \"mappingKey\" &&",
                    "        path.getParentNode(2).type === \"mapping\" &&",
                    "        isInlineNode(node)",
                    "          ? \"\"",
                    "          : breakParent,",
                    "        print(\"trailingComment\"),",
                    "      ])",
                    "    );",
                    "  }",
                    "",
                    "  if (shouldPrintEndComments(node)) {",
                    "    parts.push(",
                    "      alignWithSpaces(node.type === \"sequenceItem\" ? 2 : 0, [",
                    "        hardline,",
                    "        join(",
                    "          hardline,",
                    "          path.map(",
                    "            (path) => [",
                    "              isPreviousLineEmpty(",
                    "                options.originalText,",
                    "                path.getValue(),",
                    "                locStart",
                    "              )",
                    "                ? hardline",
                    "                : \"\",",
                    "              print(),",
                    "            ],",
                    "            \"endComments\"",
                    "          )",
                    "        ),",
                    "      ])",
                    "    );",
                    "  }",
                    "  parts.push(nextEmptyLine);",
                    "  return parts;",
                    "}",
                    "",
                    "function printNode(node, parentNode, path, options, print) {",
                    "  switch (node.type) {",
                    "    case \"root\": {",
                    "      const { children } = node;",
                    "      const parts = [];",
                    "      path.each((childPath, index) => {",
                    "        const document = children[index];",
                    "        const nextDocument = children[index + 1];",
                    "        if (index !== 0) {",
                    "          parts.push(hardline);",
                    "        }",
                    "        parts.push(print());",
                    "        if (shouldPrintDocumentEndMarker(document, nextDocument)) {",
                    "          parts.push(hardline, \"...\");",
                    "          if (hasTrailingComment(document)) {",
                    "            parts.push(\" \", print(\"trailingComment\"));",
                    "          }",
                    "        } else if (nextDocument && !hasTrailingComment(nextDocument.head)) {",
                    "          parts.push(hardline, \"---\");",
                    "        }",
                    "      }, \"children\");",
                    "",
                    "      const lastDescendantNode = getLastDescendantNode(node);",
                    "      if (",
                    "        !isNode(lastDescendantNode, [\"blockLiteral\", \"blockFolded\"]) ||",
                    "        lastDescendantNode.chomping !== \"keep\"",
                    "      ) {",
                    "        parts.push(hardline);",
                    "      }",
                    "      return parts;",
                    "    }",
                    "    case \"document\": {",
                    "      const nextDocument = parentNode.children[path.getName() + 1];",
                    "      const parts = [];",
                    "      if (",
                    "        shouldPrintDocumentHeadEndMarker(",
                    "          node,",
                    "          nextDocument,",
                    "          parentNode,",
                    "          options",
                    "        ) === \"head\"",
                    "      ) {",
                    "        if (node.head.children.length > 0 || node.head.endComments.length > 0) {",
                    "          parts.push(print(\"head\"));",
                    "        }",
                    "",
                    "        if (hasTrailingComment(node.head)) {",
                    "          parts.push([\"---\", \" \", print([\"head\", \"trailingComment\"])]);",
                    "        } else {",
                    "          parts.push(\"---\");",
                    "        }",
                    "      }",
                    "",
                    "      if (shouldPrintDocumentBody(node)) {",
                    "        parts.push(print(\"body\"));",
                    "      }",
                    "",
                    "      return join(hardline, parts);",
                    "    }",
                    "    case \"documentHead\":",
                    "      return join(hardline, [",
                    "        ...path.map(print, \"children\"),",
                    "        ...path.map(print, \"endComments\"),",
                    "      ]);",
                    "    case \"documentBody\": {",
                    "      const { children, endComments } = node;",
                    "      /** @type {Doc} */",
                    "      let separator = \"\";",
                    "      if (children.length > 0 && endComments.length > 0) {",
                    "        const lastDescendantNode = getLastDescendantNode(node);",
                    "        // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)",
                    "        if (isNode(lastDescendantNode, [\"blockFolded\", \"blockLiteral\"])) {",
                    "          // an extra newline for better readability",
                    "          if (lastDescendantNode.chomping !== \"keep\") {",
                    "            separator = [hardline, hardline];",
                    "          }",
                    "        } else {",
                    "          separator = hardline;",
                    "        }",
                    "      }",
                    "",
                    "      return [",
                    "        join(hardline, path.map(print, \"children\")),",
                    "        separator,",
                    "        join(hardline, path.map(print, \"endComments\")),",
                    "      ];",
                    "    }",
                    "    case \"directive\":",
                    "      return [\"%\", join(\" \", [node.name, ...node.parameters])];",
                    "    case \"comment\":",
                    "      return [\"#\", node.value];",
                    "    case \"alias\":",
                    "      return [\"*\", node.value];",
                    "    case \"tag\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"anchor\":",
                    "      return [\"&\", node.value];",
                    "    case \"plain\":",
                    "      return printFlowScalarContent(",
                    "        node.type,",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        ),",
                    "        options",
                    "      );",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\": {",
                    "      const singleQuote = \"'\";",
                    "      const doubleQuote = '\"';",
                    "",
                    "      const raw = options.originalText.slice(",
                    "        node.position.start.offset + 1,",
                    "        node.position.end.offset - 1",
                    "      );",
                    "",
                    "      if (",
                    "        (node.type === \"quoteSingle\" && raw.includes(\"\\\\\")) ||",
                    "        (node.type === \"quoteDouble\" && /\\\\[^\"]/.test(raw))",
                    "      ) {",
                    "        // only quoteDouble can use escape chars",
                    "        // and quoteSingle do not need to escape backslashes",
                    "        const originalQuote =",
                    "          node.type === \"quoteDouble\" ? doubleQuote : singleQuote;",
                    "        return [",
                    "          originalQuote,",
                    "          printFlowScalarContent(node.type, raw, options),",
                    "          originalQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      if (raw.includes(doubleQuote)) {",
                    "        return [",
                    "          singleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteDouble\"",
                    "              ? raw",
                    "                  // double quote needs to be escaped by backslash in quoteDouble",
                    "                  .replace(/\\\\\"/g, doubleQuote)",
                    "                  .replace(/'/g, singleQuote.repeat(2))",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          singleQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      if (raw.includes(singleQuote)) {",
                    "        return [",
                    "          doubleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteSingle\"",
                    "              ? // single quote needs to be escaped by 2 single quotes in quoteSingle",
                    "                raw.replace(/''/g, singleQuote)",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          doubleQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      const quote = options.singleQuote ? singleQuote : doubleQuote;",
                    "      return [quote, printFlowScalarContent(node.type, raw, options), quote];",
                    "    }",
                    "    case \"blockFolded\":",
                    "    case \"blockLiteral\": {",
                    "      return printBlock(path, print, options);",
                    "    }",
                    "    case \"mapping\":",
                    "    case \"sequence\":",
                    "      return join(hardline, path.map(print, \"children\"));",
                    "    case \"sequenceItem\":",
                    "      return [\"- \", alignWithSpaces(2, !node.content ? \"\" : print(\"content\"))];",
                    "    case \"mappingKey\":",
                    "    case \"mappingValue\":",
                    "      return !node.content ? \"\" : print(\"content\");",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\": {",
                    "      return printMappingItem(node, parentNode, path, print, options);",
                    "    }",
                    "    case \"flowMapping\":",
                    "      return printFlowMapping(path, print, options);",
                    "    case \"flowSequence\":",
                    "      return printFlowSequence(path, print, options);",
                    "    case \"flowSequenceItem\":",
                    "      return print(\"content\");",
                    "    // istanbul ignore next",
                    "    default:",
                    "      throw new Error(`Unexpected node type ${node.type}`);",
                    "  }",
                    "}",
                    "",
                    "function shouldPrintDocumentBody(document) {",
                    "  return document.body.children.length > 0 || hasEndComments(document.body);",
                    "}",
                    "",
                    "function shouldPrintDocumentEndMarker(document, nextDocument) {",
                    "  return (",
                    "    /**",
                    "     *... # trailingComment",
                    "     */",
                    "    hasTrailingComment(document) ||",
                    "    (nextDocument &&",
                    "      /**",
                    "       * ...",
                    "       * %DIRECTIVE",
                    "       * ---",
                    "       */",
                    "      (nextDocument.head.children.length > 0 ||",
                    "        /**",
                    "         * ...",
                    "         * # endComment",
                    "         * ---",
                    "         */",
                    "        hasEndComments(nextDocument.head)))",
                    "  );",
                    "}",
                    "",
                    "function shouldPrintDocumentHeadEndMarker(",
                    "  document,",
                    "  nextDocument,",
                    "  root,",
                    "  options",
                    ") {",
                    "  if (",
                    "    /**",
                    "     * ---",
                    "     * preserve the first document head end marker",
                    "     */",
                    "    (root.children[0] === document &&",
                    "      /---(?:\\s|$)/.test(",
                    "        options.originalText.slice(locStart(document), locStart(document) + 4)",
                    "      )) ||",
                    "    /**",
                    "     * %DIRECTIVE",
                    "     * ---",
                    "     */",
                    "    document.head.children.length > 0 ||",
                    "    /**",
                    "     * # end comment",
                    "     * ---",
                    "     */",
                    "    hasEndComments(document.head) ||",
                    "    /**",
                    "     * --- # trailing comment",
                    "     */",
                    "    hasTrailingComment(document.head)",
                    "  ) {",
                    "    return \"head\";",
                    "  }",
                    "",
                    "  if (shouldPrintDocumentEndMarker(document, nextDocument)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return nextDocument ? \"root\" : false;",
                    "}",
                    "",
                    "function printFlowScalarContent(nodeType, content, options) {",
                    "  const lineContents = getFlowScalarLineContents(nodeType, content, options);",
                    "  return join(",
                    "    hardline,",
                    "    lineContents.map((lineContentWords) =>",
                    "      fill(getDocParts(join(line, lineContentWords)))",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function clean(node, newNode /*, parent */) {",
                    "  if (isNode(newNode)) {",
                    "    delete newNode.position;",
                    "    switch (newNode.type) {",
                    "      case \"comment\":",
                    "        // insert pragma",
                    "        if (isPragma(newNode.value)) {",
                    "          return null;",
                    "        }",
                    "        break;",
                    "      case \"quoteDouble\":",
                    "      case \"quoteSingle\":",
                    "        newNode.type = \"quote\";",
                    "        break;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  preprocess,",
                    "  embed,",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  insertPragma,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { getLast, isNonEmptyArray } = require(\"../common/util.js\");",
                    "",
                    "function getAncestorCount(path, filter) {",
                    "  let counter = 0;",
                    "  const pathStackLength = path.stack.length - 1;",
                    "  for (let i = 0; i < pathStackLength; i++) {",
                    "    const value = path.stack[i];",
                    "    if (isNode(value) && filter(value)) {",
                    "      counter++;",
                    "    }",
                    "  }",
                    "  return counter;",
                    "}",
                    "",
                    "/**",
                    " * @param {any} value",
                    " * @param {string[]=} types",
                    " */",
                    "function isNode(value, types) {",
                    "  return (",
                    "    value &&",
                    "    typeof value.type === \"string\" &&",
                    "    (!types || types.includes(value.type))",
                    "  );",
                    "}",
                    "",
                    "function mapNode(node, callback, parent) {",
                    "  return callback(",
                    "    \"children\" in node",
                    "      ? {",
                    "          ...node,",
                    "          children: node.children.map((childNode) =>",
                    "            mapNode(childNode, callback, node)",
                    "          ),",
                    "        }",
                    "      : node,",
                    "    parent",
                    "  );",
                    "}",
                    "",
                    "function defineShortcut(x, key, getter) {",
                    "  Object.defineProperty(x, key, {",
                    "    get: getter,",
                    "    enumerable: false,",
                    "  });",
                    "}",
                    "",
                    "function isNextLineEmpty(node, text) {",
                    "  let newlineCount = 0;",
                    "  const textLength = text.length;",
                    "  for (let i = node.position.end.offset - 1; i < textLength; i++) {",
                    "    const char = text[i];",
                    "",
                    "    if (char === \"\\n\") {",
                    "      newlineCount++;",
                    "    }",
                    "",
                    "    if (newlineCount === 1 && /\\S/.test(char)) {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (newlineCount === 2) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isLastDescendantNode(path) {",
                    "  const node = path.getValue();",
                    "",
                    "  switch (node.type) {",
                    "    case \"tag\":",
                    "    case \"anchor\":",
                    "    case \"comment\":",
                    "      return false;",
                    "  }",
                    "",
                    "  const pathStackLength = path.stack.length;",
                    "",
                    "  for (let i = 1; i < pathStackLength; i++) {",
                    "    const item = path.stack[i];",
                    "    const parentItem = path.stack[i - 1];",
                    "",
                    "    if (",
                    "      Array.isArray(parentItem) &&",
                    "      typeof item === \"number\" &&",
                    "      item !== parentItem.length - 1",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function getLastDescendantNode(node) {",
                    "  return isNonEmptyArray(node.children)",
                    "    ? getLastDescendantNode(getLast(node.children))",
                    "    : node;",
                    "}",
                    "",
                    "function isPrettierIgnore(comment) {",
                    "  return comment.value.trim() === \"prettier-ignore\";",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const node = path.getValue();",
                    "",
                    "  if (node.type === \"documentBody\") {",
                    "    const document = path.getParentNode();",
                    "    return (",
                    "      hasEndComments(document.head) &&",
                    "      isPrettierIgnore(getLast(document.head.endComments))",
                    "    );",
                    "  }",
                    "",
                    "  return (",
                    "    hasLeadingComments(node) && isPrettierIgnore(getLast(node.leadingComments))",
                    "  );",
                    "}",
                    "",
                    "function isEmptyNode(node) {",
                    "  return !isNonEmptyArray(node.children) && !hasComments(node);",
                    "}",
                    "",
                    "function hasComments(node) {",
                    "  return (",
                    "    hasLeadingComments(node) ||",
                    "    hasMiddleComments(node) ||",
                    "    hasIndicatorComment(node) ||",
                    "    hasTrailingComment(node) ||",
                    "    hasEndComments(node)",
                    "  );",
                    "}",
                    "",
                    "function hasLeadingComments(node) {",
                    "  return node && isNonEmptyArray(node.leadingComments);",
                    "}",
                    "",
                    "function hasMiddleComments(node) {",
                    "  return node && isNonEmptyArray(node.middleComments);",
                    "}",
                    "",
                    "function hasIndicatorComment(node) {",
                    "  return node && node.indicatorComment;",
                    "}",
                    "",
                    "function hasTrailingComment(node) {",
                    "  return node && node.trailingComment;",
                    "}",
                    "",
                    "function hasEndComments(node) {",
                    "  return node && isNonEmptyArray(node.endComments);",
                    "}",
                    "",
                    "/**",
                    " * \" a   b c   d e   f \" -> [\" a   b\", \"c   d\", \"e   f \"]",
                    " */",
                    "function splitWithSingleSpace(text) {",
                    "  const parts = [];",
                    "",
                    "  let lastPart;",
                    "  for (const part of text.split(/( +)/)) {",
                    "    /* istanbul ignore else */",
                    "    if (part !== \" \") {",
                    "      if (lastPart === \" \") {",
                    "        parts.push(part);",
                    "      } else {",
                    "        parts.push((parts.pop() || \"\") + part);",
                    "      }",
                    "    } else if (lastPart === undefined) {",
                    "      parts.unshift(\"\");",
                    "    }",
                    "",
                    "    lastPart = part;",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (lastPart === \" \") {",
                    "    parts.push((parts.pop() || \"\") + \" \");",
                    "  }",
                    "",
                    "  if (parts[0] === \"\") {",
                    "    parts.shift();",
                    "    parts.unshift(\" \" + (parts.shift() || \"\"));",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function getFlowScalarLineContents(nodeType, content, options) {",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent, index, lineContents) =>",
                    "      index === 0 && index === lineContents.length - 1",
                    "        ? lineContent",
                    "        : index !== 0 && index !== lineContents.length - 1",
                    "        ? lineContent.trim()",
                    "        : index === 0",
                    "        ? lineContent.trimEnd()",
                    "        : lineContent.trimStart()",
                    "    );",
                    "",
                    "  if (options.proseWrap === \"preserve\") {",
                    "    return rawLineContents.map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : [lineContent]",
                    "    );",
                    "  }",
                    "",
                    "  return rawLineContents",
                    "    .map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "    )",
                    "    .reduce(",
                    "      (reduced, lineContentWords, index) =>",
                    "        index !== 0 &&",
                    "        rawLineContents[index - 1].length > 0 &&",
                    "        lineContentWords.length > 0 &&",
                    "        !(",
                    "          // trailing backslash in quoteDouble should be preserved",
                    "          (",
                    "            nodeType === \"quoteDouble\" &&",
                    "            getLast(getLast(reduced)).endsWith(\"\\\\\")",
                    "          )",
                    "        )",
                    "          ? [",
                    "              ...reduced.slice(0, -1),",
                    "              [...getLast(reduced), ...lineContentWords],",
                    "            ]",
                    "          : [...reduced, lineContentWords],",
                    "      []",
                    "    )",
                    "    .map((lineContentWords) =>",
                    "      options.proseWrap === \"never\"",
                    "        ? [lineContentWords.join(\" \")]",
                    "        : lineContentWords",
                    "    );",
                    "}",
                    "",
                    "function getBlockValueLineContents(",
                    "  node,",
                    "  { parentIndent, isLastDescendant, options }",
                    ") {",
                    "  const content =",
                    "    node.position.start.line === node.position.end.line",
                    "      ? \"\"",
                    "      : options.originalText",
                    "          .slice(node.position.start.offset, node.position.end.offset)",
                    "          // exclude open line `>` or `|`",
                    "          .match(/^[^\\n]*\\n(.*)$/s)[1];",
                    "",
                    "  const leadingSpaceCount =",
                    "    node.indent === null",
                    "      ? ((match) => (match ? match[1].length : Number.POSITIVE_INFINITY))(",
                    "          content.match(/^( *)\\S/m)",
                    "        )",
                    "      : node.indent - 1 + parentIndent;",
                    "",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent) => lineContent.slice(leadingSpaceCount));",
                    "",
                    "  if (options.proseWrap === \"preserve\" || node.type === \"blockLiteral\") {",
                    "    return removeUnnecessaryTrailingNewlines(",
                    "      rawLineContents.map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : [lineContent]",
                    "      )",
                    "    );",
                    "  }",
                    "",
                    "  return removeUnnecessaryTrailingNewlines(",
                    "    rawLineContents",
                    "      .map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "      )",
                    "      .reduce(",
                    "        (reduced, lineContentWords, index) =>",
                    "          index !== 0 &&",
                    "          rawLineContents[index - 1].length > 0 &&",
                    "          lineContentWords.length > 0 &&",
                    "          !/^\\s/.test(lineContentWords[0]) &&",
                    "          !/^\\s|\\s$/.test(getLast(reduced))",
                    "            ? [",
                    "                ...reduced.slice(0, -1),",
                    "                [...getLast(reduced), ...lineContentWords],",
                    "              ]",
                    "            : [...reduced, lineContentWords],",
                    "        []",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        lineContentWords.reduce(",
                    "          (reduced, word) =>",
                    "            // disallow trailing spaces",
                    "            reduced.length > 0 && /\\s$/.test(getLast(reduced))",
                    "              ? [...reduced.slice(0, -1), getLast(reduced) + \" \" + word]",
                    "              : [...reduced, word],",
                    "          []",
                    "        )",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        options.proseWrap === \"never\"",
                    "          ? [lineContentWords.join(\" \")]",
                    "          : lineContentWords",
                    "      )",
                    "  );",
                    "",
                    "  function removeUnnecessaryTrailingNewlines(lineContents) {",
                    "    if (node.chomping === \"keep\") {",
                    "      return getLast(lineContents).length === 0",
                    "        ? lineContents.slice(0, -1)",
                    "        : lineContents;",
                    "    }",
                    "",
                    "    let trailingNewlineCount = 0;",
                    "    for (let i = lineContents.length - 1; i >= 0; i--) {",
                    "      if (lineContents[i].length === 0) {",
                    "        trailingNewlineCount++;",
                    "      } else {",
                    "        break;",
                    "      }",
                    "    }",
                    "",
                    "    return trailingNewlineCount === 0",
                    "      ? lineContents",
                    "      : trailingNewlineCount >= 2 && !isLastDescendant",
                    "      ? // next empty line",
                    "        lineContents.slice(0, -(trailingNewlineCount - 1))",
                    "      : lineContents.slice(0, -trailingNewlineCount);",
                    "  }",
                    "}",
                    "",
                    "function isInlineNode(node) {",
                    "  /* istanbul ignore next */",
                    "  if (!node) {",
                    "    return true;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"plain\":",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\":",
                    "    case \"alias\":",
                    "    case \"flowMapping\":",
                    "    case \"flowSequence\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  getLast,",
                    "  getAncestorCount,",
                    "  isNode,",
                    "  isEmptyNode,",
                    "  isInlineNode,",
                    "  mapNode,",
                    "  defineShortcut,",
                    "  isNextLineEmpty,",
                    "  isLastDescendantNode,",
                    "  getBlockValueLineContents,",
                    "  getFlowScalarLineContents,",
                    "  getLastDescendantNode,",
                    "  hasPrettierIgnore,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasIndicatorComment,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "};"
                ]
            },
            "print": {
                "block.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "const {",
                        "  builders: {",
                        "    dedent,",
                        "    dedentToRoot,",
                        "    fill,",
                        "    hardline,",
                        "    join,",
                        "    line,",
                        "    literalline,",
                        "    markAsRoot,",
                        "  },",
                        "  utils: { getDocParts },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  getAncestorCount,",
                        "  getBlockValueLineContents,",
                        "  hasIndicatorComment,",
                        "  isLastDescendantNode,",
                        "  isNode,",
                        "} = require(\"../utils.js\");",
                        "const { alignWithSpaces } = require(\"./misc.js\");",
                        "",
                        "function printBlock(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const parentIndent = getAncestorCount(path, (ancestorNode) =>",
                        "    isNode(ancestorNode, [\"sequence\", \"mapping\"])",
                        "  );",
                        "  const isLastDescendant = isLastDescendantNode(path);",
                        "  /** @type {Doc[]} */",
                        "  const parts = [node.type === \"blockFolded\" ? \">\" : \"|\"];",
                        "  if (node.indent !== null) {",
                        "    parts.push(node.indent.toString());",
                        "  }",
                        "",
                        "  if (node.chomping !== \"clip\") {",
                        "    parts.push(node.chomping === \"keep\" ? \"+\" : \"-\");",
                        "  }",
                        "",
                        "  if (hasIndicatorComment(node)) {",
                        "    parts.push(\" \", print(\"indicatorComment\"));",
                        "  }",
                        "",
                        "  const lineContents = getBlockValueLineContents(node, {",
                        "    parentIndent,",
                        "    isLastDescendant,",
                        "    options,",
                        "  });",
                        "  /** @type {Doc[]} */",
                        "  const contentsParts = [];",
                        "  for (const [index, lineWords] of lineContents.entries()) {",
                        "    if (index === 0) {",
                        "      contentsParts.push(hardline);",
                        "    }",
                        "    contentsParts.push(fill(getDocParts(join(line, lineWords))));",
                        "    if (index !== lineContents.length - 1) {",
                        "      contentsParts.push(",
                        "        lineWords.length === 0 ? hardline : markAsRoot(literalline)",
                        "      );",
                        "    } else if (node.chomping === \"keep\" && isLastDescendant) {",
                        "      contentsParts.push(",
                        "        dedentToRoot(lineWords.length === 0 ? hardline : literalline)",
                        "      );",
                        "    }",
                        "  }",
                        "  if (node.indent === null) {",
                        "    parts.push(dedent(alignWithSpaces(options.tabWidth, contentsParts)));",
                        "  } else {",
                        "    parts.push(",
                        "      dedentToRoot(",
                        "        alignWithSpaces(node.indent - 1 + parentIndent, contentsParts)",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "module.exports = printBlock;"
                    ]
                },
                "flow-mapping-sequence.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { ifBreak, line, softline, hardline, join },",
                        "} = require(\"../../document/index.js\");",
                        "const { isEmptyNode, getLast, hasEndComments } = require(\"../utils.js\");",
                        "const { printNextEmptyLine, alignWithSpaces } = require(\"./misc.js\");",
                        "",
                        "function printFlowMapping(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const isMapping = node.type === \"flowMapping\";",
                        "  const openMarker = isMapping ? \"{\" : \"[\";",
                        "  const closeMarker = isMapping ? \"}\" : \"]\";",
                        "",
                        "  /** @type {softline | line} */",
                        "  let bracketSpacing = softline;",
                        "  if (isMapping && node.children.length > 0 && options.bracketSpacing) {",
                        "    bracketSpacing = line;",
                        "  }",
                        "  const lastItem = getLast(node.children);",
                        "  const isLastItemEmptyMappingItem =",
                        "    lastItem &&",
                        "    lastItem.type === \"flowMappingItem\" &&",
                        "    isEmptyNode(lastItem.key) &&",
                        "    isEmptyNode(lastItem.value);",
                        "",
                        "  return [",
                        "    openMarker,",
                        "    alignWithSpaces(options.tabWidth, [",
                        "      bracketSpacing,",
                        "      printChildren(path, print, options),",
                        "      options.trailingComma === \"none\" ? \"\" : ifBreak(\",\"),",
                        "      hasEndComments(node)",
                        "        ? [hardline, join(hardline, path.map(print, \"endComments\"))]",
                        "        : \"\",",
                        "    ]),",
                        "    isLastItemEmptyMappingItem ? \"\" : bracketSpacing,",
                        "    closeMarker,",
                        "  ];",
                        "}",
                        "",
                        "function printChildren(path, print, options) {",
                        "  const node = path.getValue();",
                        "  const parts = path.map(",
                        "    (childPath, index) => [",
                        "      print(),",
                        "      index === node.children.length - 1",
                        "        ? \"\"",
                        "        : [",
                        "            \",\",",
                        "            line,",
                        "            node.children[index].position.start.line !==",
                        "            node.children[index + 1].position.start.line",
                        "              ? printNextEmptyLine(childPath, options.originalText)",
                        "              : \"\",",
                        "          ],",
                        "    ],",
                        "    \"children\"",
                        "  );",
                        "  return parts;",
                        "}",
                        "",
                        "module.exports = {",
                        "  printFlowMapping,",
                        "  // Alias",
                        "  printFlowSequence: printFlowMapping,",
                        "};"
                    ]
                },
                "mapping-item.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/** @typedef {import(\"../../document\").Doc} Doc */",
                        "",
                        "const {",
                        "  builders: { conditionalGroup, group, hardline, ifBreak, join, line },",
                        "} = require(\"../../document/index.js\");",
                        "const {",
                        "  hasLeadingComments,",
                        "  hasMiddleComments,",
                        "  hasTrailingComment,",
                        "  hasEndComments,",
                        "  isNode,",
                        "  isEmptyNode,",
                        "  isInlineNode,",
                        "} = require(\"../utils.js\");",
                        "const { alignWithSpaces } = require(\"./misc.js\");",
                        "",
                        "function printMappingItem(node, parentNode, path, print, options) {",
                        "  const { key, value } = node;",
                        "",
                        "  const isEmptyMappingKey = isEmptyNode(key);",
                        "  const isEmptyMappingValue = isEmptyNode(value);",
                        "",
                        "  if (isEmptyMappingKey && isEmptyMappingValue) {",
                        "    return \": \";",
                        "  }",
                        "",
                        "  const printedKey = print(\"key\");",
                        "  const spaceBeforeColon = needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\";",
                        "",
                        "  if (isEmptyMappingValue) {",
                        "    if (node.type === \"flowMappingItem\" && parentNode.type === \"flowMapping\") {",
                        "      return printedKey;",
                        "    }",
                        "",
                        "    if (",
                        "      node.type === \"mappingItem\" &&",
                        "      isAbsolutelyPrintedAsSingleLineNode(key.content, options) &&",
                        "      !hasTrailingComment(key.content) &&",
                        "      (!parentNode.tag || parentNode.tag.value !== \"tag:yaml.org,2002:set\")",
                        "    ) {",
                        "      return [printedKey, spaceBeforeColon, \":\"];",
                        "    }",
                        "",
                        "    return [\"? \", alignWithSpaces(2, printedKey)];",
                        "  }",
                        "",
                        "  const printedValue = print(\"value\");",
                        "  if (isEmptyMappingKey) {",
                        "    return [\": \", alignWithSpaces(2, printedValue)];",
                        "  }",
                        "",
                        "  // force explicit Key",
                        "  if (hasLeadingComments(value) || !isInlineNode(key.content)) {",
                        "    return [",
                        "      \"? \",",
                        "      alignWithSpaces(2, printedKey),",
                        "      hardline,",
                        "      join(",
                        "        \"\",",
                        "        path",
                        "          .map(print, \"value\", \"leadingComments\")",
                        "          .map((comment) => [comment, hardline])",
                        "      ),",
                        "      \": \",",
                        "      alignWithSpaces(2, printedValue),",
                        "    ];",
                        "  }",
                        "",
                        "  // force singleline",
                        "  if (",
                        "    isSingleLineNode(key.content) &&",
                        "    !hasLeadingComments(key.content) &&",
                        "    !hasMiddleComments(key.content) &&",
                        "    !hasTrailingComment(key.content) &&",
                        "    !hasEndComments(key) &&",
                        "    !hasLeadingComments(value.content) &&",
                        "    !hasMiddleComments(value.content) &&",
                        "    !hasEndComments(value) &&",
                        "    isAbsolutelyPrintedAsSingleLineNode(value.content, options)",
                        "  ) {",
                        "    return [printedKey, spaceBeforeColon, \": \", printedValue];",
                        "  }",
                        "",
                        "  const groupId = Symbol(\"mappingKey\");",
                        "  const groupedKey = group([",
                        "    ifBreak(\"? \"),",
                        "    group(alignWithSpaces(2, printedKey), { id: groupId }),",
                        "  ]);",
                        "",
                        "  // Construct both explicit and implicit mapping values.",
                        "  const explicitMappingValue = [",
                        "    hardline,",
                        "    \": \",",
                        "    alignWithSpaces(2, printedValue),",
                        "  ];",
                        "  /** @type {Doc[]} */",
                        "  // In the implicit case, it's convenient to treat everything from the key's colon",
                        "  // as part of the mapping value",
                        "  const implicitMappingValueParts = [spaceBeforeColon, \":\"];",
                        "  if (",
                        "    hasLeadingComments(value.content) ||",
                        "    (hasEndComments(value) &&",
                        "      value.content &&",
                        "      !isNode(value.content, [\"mapping\", \"sequence\"])) ||",
                        "    (parentNode.type === \"mapping\" &&",
                        "      hasTrailingComment(key.content) &&",
                        "      isInlineNode(value.content)) ||",
                        "    (isNode(value.content, [\"mapping\", \"sequence\"]) &&",
                        "      value.content.tag === null &&",
                        "      value.content.anchor === null)",
                        "  ) {",
                        "    implicitMappingValueParts.push(hardline);",
                        "  } else if (value.content) {",
                        "    implicitMappingValueParts.push(line);",
                        "  }",
                        "  implicitMappingValueParts.push(printedValue);",
                        "  const implicitMappingValue = alignWithSpaces(",
                        "    options.tabWidth,",
                        "    implicitMappingValueParts",
                        "  );",
                        "",
                        "  // If a key is definitely single-line, forcibly use implicit style to avoid edge cases (very long",
                        "  // keys) that would otherwise trigger explicit style as if it was multiline.",
                        "  // In those cases, explicit style makes the line even longer and causes confusion.",
                        "  if (",
                        "    isAbsolutelyPrintedAsSingleLineNode(key.content, options) &&",
                        "    !hasLeadingComments(key.content) &&",
                        "    !hasMiddleComments(key.content) &&",
                        "    !hasEndComments(key)",
                        "  ) {",
                        "    return conditionalGroup([[printedKey, implicitMappingValue]]);",
                        "  }",
                        "",
                        "  // Use explicit mapping syntax if the key breaks, implicit otherwise",
                        "  return conditionalGroup([",
                        "    [",
                        "      groupedKey,",
                        "      ifBreak(explicitMappingValue, implicitMappingValue, { groupId }),",
                        "    ],",
                        "  ]);",
                        "}",
                        "",
                        "function isAbsolutelyPrintedAsSingleLineNode(node, options) {",
                        "  if (!node) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"plain\":",
                        "    case \"quoteSingle\":",
                        "    case \"quoteDouble\":",
                        "      break;",
                        "    case \"alias\":",
                        "      return true;",
                        "",
                        "    default:",
                        "      return false;",
                        "  }",
                        "",
                        "  if (options.proseWrap === \"preserve\") {",
                        "    return node.position.start.line === node.position.end.line;",
                        "  }",
                        "",
                        "  if (",
                        "    // backslash-newline",
                        "    /\\\\$/m.test(",
                        "      options.originalText.slice(",
                        "        node.position.start.offset,",
                        "        node.position.end.offset",
                        "      )",
                        "    )",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  switch (options.proseWrap) {",
                        "    case \"never\":",
                        "      return !node.value.includes(\"\\n\");",
                        "    case \"always\":",
                        "      return !/[\\n ]/.test(node.value);",
                        "    // istanbul ignore next",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "function needsSpaceInFrontOfMappingValue(node) {",
                        "  return node.key.content && node.key.content.type === \"alias\";",
                        "}",
                        "",
                        "function isSingleLineNode(node) {",
                        "  /* istanbul ignore next */",
                        "  if (!node) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"plain\":",
                        "    case \"quoteDouble\":",
                        "    case \"quoteSingle\":",
                        "      return node.position.start.line === node.position.end.line;",
                        "    case \"alias\":",
                        "      return true;",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "module.exports = printMappingItem;"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { softline, align },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "const { hasEndComments, isNextLineEmpty, isNode } = require(\"../utils.js\");",
                        "",
                        "const printedEmptyLineCache = new WeakMap();",
                        "function printNextEmptyLine(path, originalText) {",
                        "  const node = path.getValue();",
                        "  const root = path.stack[0];",
                        "",
                        "  let isNextEmptyLinePrintedSet;",
                        "  if (printedEmptyLineCache.has(root)) {",
                        "    isNextEmptyLinePrintedSet = printedEmptyLineCache.get(root);",
                        "  } else {",
                        "    isNextEmptyLinePrintedSet = new Set();",
                        "    printedEmptyLineCache.set(root, isNextEmptyLinePrintedSet);",
                        "  }",
                        "",
                        "  if (!isNextEmptyLinePrintedSet.has(node.position.end.line)) {",
                        "    isNextEmptyLinePrintedSet.add(node.position.end.line);",
                        "    if (",
                        "      isNextLineEmpty(node, originalText) &&",
                        "      !shouldPrintEndComments(path.getParentNode())",
                        "    ) {",
                        "      return softline;",
                        "    }",
                        "  }",
                        "",
                        "  return \"\";",
                        "}",
                        "",
                        "function shouldPrintEndComments(node) {",
                        "  return (",
                        "    hasEndComments(node) &&",
                        "    !isNode(node, [",
                        "      \"documentHead\",",
                        "      \"documentBody\",",
                        "      \"flowMapping\",",
                        "      \"flowSequence\",",
                        "    ])",
                        "  );",
                        "}",
                        "",
                        "function alignWithSpaces(width, doc) {",
                        "  return align(\" \".repeat(width), doc);",
                        "}",
                        "",
                        "module.exports = {",
                        "  alignWithSpaces,",
                        "  shouldPrintEndComments,",
                        "  printNextEmptyLine,",
                        "};"
                    ]
                }
            }
        },
        "main": {
            "ast-to-doc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const AstPath = require(\"../common/ast-path.js\");",
                    "const {",
                    "  builders: { hardline, addAlignmentToDoc },",
                    "  utils: { propagateBreaks },",
                    "} = require(\"../document/index.js\");",
                    "const { printComments } = require(\"./comments.js\");",
                    "const multiparser = require(\"./multiparser.js\");",
                    "",
                    "/**",
                    " * Takes an abstract syntax tree (AST) and recursively converts it to a",
                    " * document (series of printing primitives).",
                    " *",
                    " * This is done by descending down the AST recursively. The recursion",
                    " * involves two functions that call each other:",
                    " *",
                    " * 1. mainPrint(), which is defined as an inner function here.",
                    " *    It basically takes care of node caching.",
                    " * 2. callPluginPrintFunction(), which checks for some options, and",
                    " *    ultimately calls the print() function provided by the plugin.",
                    " *",
                    " * The plugin function will call mainPrint() again for child nodes",
                    " * of the current node. mainPrint() will do its housekeeping, then call",
                    " * the plugin function again, and so on.",
                    " *",
                    " * All the while, these functions pass a \"path\" variable around, which",
                    " * is a stack-like data structure (AstPath) that maintains the current",
                    " * state of the recursion. It is called \"path\", because it represents",
                    " * the path to the current node through the Abstract Syntax Tree.",
                    " */",
                    "function printAstToDoc(ast, options, alignmentSize = 0) {",
                    "  const { printer } = options;",
                    "",
                    "  if (printer.preprocess) {",
                    "    ast = printer.preprocess(ast, options);",
                    "  }",
                    "",
                    "  const cache = new Map();",
                    "  const path = new AstPath(ast);",
                    "",
                    "  let doc = mainPrint();",
                    "",
                    "  if (alignmentSize > 0) {",
                    "    // Add a hardline to make the indents take effect",
                    "    // It should be removed in index.js format()",
                    "    doc = addAlignmentToDoc([hardline, doc], alignmentSize, options.tabWidth);",
                    "  }",
                    "",
                    "  propagateBreaks(doc);",
                    "",
                    "  return doc;",
                    "",
                    "  function mainPrint(selector, args) {",
                    "    if (selector === undefined || selector === path) {",
                    "      return mainPrintInternal(args);",
                    "    }",
                    "",
                    "    if (Array.isArray(selector)) {",
                    "      return path.call(() => mainPrintInternal(args), ...selector);",
                    "    }",
                    "",
                    "    return path.call(() => mainPrintInternal(args), selector);",
                    "  }",
                    "",
                    "  function mainPrintInternal(args) {",
                    "    const value = path.getValue();",
                    "",
                    "    const shouldCache =",
                    "      value && typeof value === \"object\" && args === undefined;",
                    "",
                    "    if (shouldCache && cache.has(value)) {",
                    "      return cache.get(value);",
                    "    }",
                    "",
                    "    const doc = callPluginPrintFunction(path, options, mainPrint, args);",
                    "",
                    "    if (shouldCache) {",
                    "      cache.set(value, doc);",
                    "    }",
                    "",
                    "    return doc;",
                    "  }",
                    "}",
                    "",
                    "function printPrettierIgnoredNode(node, options) {",
                    "  const {",
                    "    originalText,",
                    "    [Symbol.for(\"comments\")]: comments,",
                    "    locStart,",
                    "    locEnd,",
                    "  } = options;",
                    "",
                    "  const start = locStart(node);",
                    "  const end = locEnd(node);",
                    "  const printedComments = new Set();",
                    "",
                    "  for (const comment of comments) {",
                    "    if (locStart(comment) >= start && locEnd(comment) <= end) {",
                    "      comment.printed = true;",
                    "      printedComments.add(comment);",
                    "    }",
                    "  }",
                    "",
                    "  return { doc: originalText.slice(start, end), printedComments };",
                    "}",
                    "",
                    "function callPluginPrintFunction(path, options, printPath, args) {",
                    "  const node = path.getValue();",
                    "  const { printer } = options;",
                    "",
                    "  let doc;",
                    "  let printedComments;",
                    "",
                    "  // Escape hatch",
                    "  if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {",
                    "    ({ doc, printedComments } = printPrettierIgnoredNode(node, options));",
                    "  } else {",
                    "    if (node) {",
                    "      try {",
                    "        // Potentially switch to a different parser",
                    "        doc = multiparser.printSubtree(path, printPath, options, printAstToDoc);",
                    "      } catch (error) {",
                    "        /* istanbul ignore if */",
                    "        if (process.env.PRETTIER_DEBUG) {",
                    "          throw error;",
                    "        }",
                    "        // Continue with current parser",
                    "      }",
                    "    }",
                    "",
                    "    if (!doc) {",
                    "      doc = printer.print(path, options, printPath, args);",
                    "    }",
                    "  }",
                    "",
                    "  // We let JSXElement print its comments itself because it adds () around",
                    "  // UnionTypeAnnotation has to align the child without the comments",
                    "  if (",
                    "    !printer.willPrintOwnComments ||",
                    "    !printer.willPrintOwnComments(path, options)",
                    "  ) {",
                    "    // printComments will call the plugin print function and check for",
                    "    // comments to print",
                    "    doc = printComments(path, doc, options, printedComments);",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "module.exports = printAstToDoc;"
                ]
            },
            "comments.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "",
                    "const {",
                    "  builders: { line, hardline, breakParent, indent, lineSuffix, join, cursor },",
                    "} = require(\"../document/index.js\");",
                    "",
                    "const {",
                    "  hasNewline,",
                    "  skipNewline,",
                    "  skipSpaces,",
                    "  isPreviousLineEmpty,",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "} = require(\"../common/util.js\");",
                    "",
                    "const childNodesCache = new WeakMap();",
                    "function getSortedChildNodes(node, options, resultArray) {",
                    "  if (!node) {",
                    "    return;",
                    "  }",
                    "  const { printer, locStart, locEnd } = options;",
                    "",
                    "  if (resultArray) {",
                    "    if (printer.canAttachComment && printer.canAttachComment(node)) {",
                    "      // This reverse insertion sort almost always takes constant",
                    "      // time because we almost always (maybe always?) append the",
                    "      // nodes in order anyway.",
                    "      let i;",
                    "      for (i = resultArray.length - 1; i >= 0; --i) {",
                    "        if (",
                    "          locStart(resultArray[i]) <= locStart(node) &&",
                    "          locEnd(resultArray[i]) <= locEnd(node)",
                    "        ) {",
                    "          break;",
                    "        }",
                    "      }",
                    "      resultArray.splice(i + 1, 0, node);",
                    "      return;",
                    "    }",
                    "  } else if (childNodesCache.has(node)) {",
                    "    return childNodesCache.get(node);",
                    "  }",
                    "",
                    "  const childNodes =",
                    "    (printer.getCommentChildNodes &&",
                    "      printer.getCommentChildNodes(node, options)) ||",
                    "    (typeof node === \"object\" &&",
                    "      Object.entries(node)",
                    "        .filter(",
                    "          ([key]) =>",
                    "            key !== \"enclosingNode\" &&",
                    "            key !== \"precedingNode\" &&",
                    "            key !== \"followingNode\" &&",
                    "            key !== \"tokens\" &&",
                    "            key !== \"comments\" &&",
                    "            key !== \"parent\"",
                    "        )",
                    "        .map(([, value]) => value));",
                    "",
                    "  if (!childNodes) {",
                    "    return;",
                    "  }",
                    "",
                    "  if (!resultArray) {",
                    "    resultArray = [];",
                    "    childNodesCache.set(node, resultArray);",
                    "  }",
                    "",
                    "  for (const childNode of childNodes) {",
                    "    getSortedChildNodes(childNode, options, resultArray);",
                    "  }",
                    "",
                    "  return resultArray;",
                    "}",
                    "",
                    "// As efficiently as possible, decorate the comment object with",
                    "// .precedingNode, .enclosingNode, and/or .followingNode properties, at",
                    "// least one of which is guaranteed to be defined.",
                    "function decorateComment(node, comment, options, enclosingNode) {",
                    "  const { locStart, locEnd } = options;",
                    "  const commentStart = locStart(comment);",
                    "  const commentEnd = locEnd(comment);",
                    "",
                    "  const childNodes = getSortedChildNodes(node, options);",
                    "  let precedingNode;",
                    "  let followingNode;",
                    "  // Time to dust off the old binary search robes and wizard hat.",
                    "  let left = 0;",
                    "  let right = childNodes.length;",
                    "  while (left < right) {",
                    "    const middle = (left + right) >> 1;",
                    "    const child = childNodes[middle];",
                    "    const start = locStart(child);",
                    "    const end = locEnd(child);",
                    "",
                    "    // The comment is completely contained by this child node.",
                    "    if (start <= commentStart && commentEnd <= end) {",
                    "      // Abandon the binary search at this level.",
                    "      return decorateComment(child, comment, options, child);",
                    "    }",
                    "",
                    "    if (end <= commentStart) {",
                    "      // This child node falls completely before the comment.",
                    "      // Because we will never consider this node or any nodes",
                    "      // before it again, this node must be the closest preceding",
                    "      // node we have encountered so far.",
                    "      precedingNode = child;",
                    "      left = middle + 1;",
                    "      continue;",
                    "    }",
                    "",
                    "    if (commentEnd <= start) {",
                    "      // This child node falls completely after the comment.",
                    "      // Because we will never consider this node or any nodes after",
                    "      // it again, this node must be the closest following node we",
                    "      // have encountered so far.",
                    "      followingNode = child;",
                    "      right = middle;",
                    "      continue;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw new Error(\"Comment location overlaps with node location\");",
                    "  }",
                    "",
                    "  // We don't want comments inside of different expressions inside of the same",
                    "  // template literal to move to another expression.",
                    "  if (enclosingNode && enclosingNode.type === \"TemplateLiteral\") {",
                    "    const { quasis } = enclosingNode;",
                    "    const commentIndex = findExpressionIndexForComment(",
                    "      quasis,",
                    "      comment,",
                    "      options",
                    "    );",
                    "",
                    "    if (",
                    "      precedingNode &&",
                    "      findExpressionIndexForComment(quasis, precedingNode, options) !==",
                    "        commentIndex",
                    "    ) {",
                    "      precedingNode = null;",
                    "    }",
                    "    if (",
                    "      followingNode &&",
                    "      findExpressionIndexForComment(quasis, followingNode, options) !==",
                    "        commentIndex",
                    "    ) {",
                    "      followingNode = null;",
                    "    }",
                    "  }",
                    "",
                    "  return { enclosingNode, precedingNode, followingNode };",
                    "}",
                    "",
                    "const returnFalse = () => false;",
                    "function attach(comments, ast, text, options) {",
                    "  if (!Array.isArray(comments)) {",
                    "    return;",
                    "  }",
                    "",
                    "  const tiesToBreak = [];",
                    "  const {",
                    "    locStart,",
                    "    locEnd,",
                    "    printer: { handleComments = {} },",
                    "  } = options;",
                    "  // TODO: Make this as default behavior",
                    "  const {",
                    "    avoidAstMutation,",
                    "    ownLine: handleOwnLineComment = returnFalse,",
                    "    endOfLine: handleEndOfLineComment = returnFalse,",
                    "    remaining: handleRemainingComment = returnFalse,",
                    "  } = handleComments;",
                    "",
                    "  const decoratedComments = comments.map((comment, index) => ({",
                    "    ...decorateComment(ast, comment, options),",
                    "    comment,",
                    "    text,",
                    "    options,",
                    "    ast,",
                    "    isLastComment: comments.length - 1 === index,",
                    "  }));",
                    "",
                    "  for (const [index, context] of decoratedComments.entries()) {",
                    "    const {",
                    "      comment,",
                    "      precedingNode,",
                    "      enclosingNode,",
                    "      followingNode,",
                    "      text,",
                    "      options,",
                    "      ast,",
                    "      isLastComment,",
                    "    } = context;",
                    "",
                    "    if (",
                    "      options.parser === \"json\" ||",
                    "      options.parser === \"json5\" ||",
                    "      options.parser === \"__js_expression\" ||",
                    "      options.parser === \"__vue_expression\"",
                    "    ) {",
                    "      if (locStart(comment) - locStart(ast) <= 0) {",
                    "        addLeadingComment(ast, comment);",
                    "        continue;",
                    "      }",
                    "      if (locEnd(comment) - locEnd(ast) >= 0) {",
                    "        addTrailingComment(ast, comment);",
                    "        continue;",
                    "      }",
                    "    }",
                    "",
                    "    let args;",
                    "    if (avoidAstMutation) {",
                    "      args = [context];",
                    "    } else {",
                    "      comment.enclosingNode = enclosingNode;",
                    "      comment.precedingNode = precedingNode;",
                    "      comment.followingNode = followingNode;",
                    "      args = [comment, text, options, ast, isLastComment];",
                    "    }",
                    "",
                    "    if (isOwnLineComment(text, options, decoratedComments, index)) {",
                    "      comment.placement = \"ownLine\";",
                    "      // If a comment exists on its own line, prefer a leading comment.",
                    "      // We also need to check if it's the first line of the file.",
                    "      if (handleOwnLineComment(...args)) {",
                    "        // We're good",
                    "      } else if (followingNode) {",
                    "        // Always a leading comment.",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (precedingNode) {",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    } else if (isEndOfLineComment(text, options, decoratedComments, index)) {",
                    "      comment.placement = \"endOfLine\";",
                    "      if (handleEndOfLineComment(...args)) {",
                    "        // We're good",
                    "      } else if (precedingNode) {",
                    "        // There is content before this comment on the same line, but",
                    "        // none after it, so prefer a trailing comment of the previous node.",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (followingNode) {",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    } else {",
                    "      comment.placement = \"remaining\";",
                    "      if (handleRemainingComment(...args)) {",
                    "        // We're good",
                    "      } else if (precedingNode && followingNode) {",
                    "        // Otherwise, text exists both before and after the comment on",
                    "        // the same line. If there is both a preceding and following",
                    "        // node, use a tie-breaking algorithm to determine if it should",
                    "        // be attached to the next or previous node. In the last case,",
                    "        // simply attach the right node;",
                    "        const tieCount = tiesToBreak.length;",
                    "        if (tieCount > 0) {",
                    "          const lastTie = tiesToBreak[tieCount - 1];",
                    "          if (lastTie.followingNode !== followingNode) {",
                    "            breakTies(tiesToBreak, text, options);",
                    "          }",
                    "        }",
                    "        tiesToBreak.push(context);",
                    "      } else if (precedingNode) {",
                    "        addTrailingComment(precedingNode, comment);",
                    "      } else if (followingNode) {",
                    "        addLeadingComment(followingNode, comment);",
                    "      } else if (enclosingNode) {",
                    "        addDanglingComment(enclosingNode, comment);",
                    "      } else {",
                    "        // There are no nodes, let's attach it to the root of the ast",
                    "        /* istanbul ignore next */",
                    "        addDanglingComment(ast, comment);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  breakTies(tiesToBreak, text, options);",
                    "",
                    "  if (!avoidAstMutation) {",
                    "    for (const comment of comments) {",
                    "      // These node references were useful for breaking ties, but we",
                    "      // don't need them anymore, and they create cycles in the AST that",
                    "      // may lead to infinite recursion if we don't delete them here.",
                    "      delete comment.precedingNode;",
                    "      delete comment.enclosingNode;",
                    "      delete comment.followingNode;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "const isAllEmptyAndNoLineBreak = (text) => !/[\\S\\n\\u2028\\u2029]/.test(text);",
                    "function isOwnLineComment(text, options, decoratedComments, commentIndex) {",
                    "  const { comment, precedingNode } = decoratedComments[commentIndex];",
                    "  const { locStart, locEnd } = options;",
                    "  let start = locStart(comment);",
                    "",
                    "  if (precedingNode) {",
                    "    // Find first comment on the same line",
                    "    for (let index = commentIndex - 1; index >= 0; index--) {",
                    "      const { comment, precedingNode: currentCommentPrecedingNode } =",
                    "        decoratedComments[index];",
                    "      if (",
                    "        currentCommentPrecedingNode !== precedingNode ||",
                    "        !isAllEmptyAndNoLineBreak(text.slice(locEnd(comment), start))",
                    "      ) {",
                    "        break;",
                    "      }",
                    "      start = locStart(comment);",
                    "    }",
                    "  }",
                    "",
                    "  return hasNewline(text, start, { backwards: true });",
                    "}",
                    "",
                    "function isEndOfLineComment(text, options, decoratedComments, commentIndex) {",
                    "  const { comment, followingNode } = decoratedComments[commentIndex];",
                    "  const { locStart, locEnd } = options;",
                    "  let end = locEnd(comment);",
                    "",
                    "  if (followingNode) {",
                    "    // Find last comment on the same line",
                    "    for (",
                    "      let index = commentIndex + 1;",
                    "      index < decoratedComments.length;",
                    "      index++",
                    "    ) {",
                    "      const { comment, followingNode: currentCommentFollowingNode } =",
                    "        decoratedComments[index];",
                    "      if (",
                    "        currentCommentFollowingNode !== followingNode ||",
                    "        !isAllEmptyAndNoLineBreak(text.slice(end, locStart(comment)))",
                    "      ) {",
                    "        break;",
                    "      }",
                    "      end = locEnd(comment);",
                    "    }",
                    "  }",
                    "",
                    "  return hasNewline(text, end);",
                    "}",
                    "",
                    "function breakTies(tiesToBreak, text, options) {",
                    "  const tieCount = tiesToBreak.length;",
                    "  if (tieCount === 0) {",
                    "    return;",
                    "  }",
                    "  const { precedingNode, followingNode, enclosingNode } = tiesToBreak[0];",
                    "",
                    "  const gapRegExp =",
                    "    (options.printer.getGapRegex &&",
                    "      options.printer.getGapRegex(enclosingNode)) ||",
                    "    /^[\\s(]*$/;",
                    "",
                    "  let gapEndPos = options.locStart(followingNode);",
                    "",
                    "  // Iterate backwards through tiesToBreak, examining the gaps",
                    "  // between the tied comments. In order to qualify as leading, a",
                    "  // comment must be separated from followingNode by an unbroken series of",
                    "  // gaps (or other comments). Gaps should only contain whitespace or open",
                    "  // parentheses.",
                    "  let indexOfFirstLeadingComment;",
                    "  for (",
                    "    indexOfFirstLeadingComment = tieCount;",
                    "    indexOfFirstLeadingComment > 0;",
                    "    --indexOfFirstLeadingComment",
                    "  ) {",
                    "    const {",
                    "      comment,",
                    "      precedingNode: currentCommentPrecedingNode,",
                    "      followingNode: currentCommentFollowingNode,",
                    "    } = tiesToBreak[indexOfFirstLeadingComment - 1];",
                    "    assert.strictEqual(currentCommentPrecedingNode, precedingNode);",
                    "    assert.strictEqual(currentCommentFollowingNode, followingNode);",
                    "",
                    "    const gap = text.slice(options.locEnd(comment), gapEndPos);",
                    "",
                    "    if (gapRegExp.test(gap)) {",
                    "      gapEndPos = options.locStart(comment);",
                    "    } else {",
                    "      // The gap string contained something other than whitespace or open",
                    "      // parentheses.",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  for (const [i, { comment }] of tiesToBreak.entries()) {",
                    "    if (i < indexOfFirstLeadingComment) {",
                    "      addTrailingComment(precedingNode, comment);",
                    "    } else {",
                    "      addLeadingComment(followingNode, comment);",
                    "    }",
                    "  }",
                    "",
                    "  for (const node of [precedingNode, followingNode]) {",
                    "    if (node.comments && node.comments.length > 1) {",
                    "      node.comments.sort((a, b) => options.locStart(a) - options.locStart(b));",
                    "    }",
                    "  }",
                    "",
                    "  tiesToBreak.length = 0;",
                    "}",
                    "",
                    "function printComment(path, options) {",
                    "  const comment = path.getValue();",
                    "  comment.printed = true;",
                    "  return options.printer.printComment(path, options);",
                    "}",
                    "",
                    "function findExpressionIndexForComment(quasis, comment, options) {",
                    "  const startPos = options.locStart(comment) - 1;",
                    "",
                    "  for (let i = 1; i < quasis.length; ++i) {",
                    "    if (startPos < options.locStart(quasis[i])) {",
                    "      return i - 1;",
                    "    }",
                    "  }",
                    "",
                    "  // We haven't found it, it probably means that some of the locations are off.",
                    "  // Let's just return the first one.",
                    "  /* istanbul ignore next */",
                    "  return 0;",
                    "}",
                    "",
                    "function printLeadingComment(path, options) {",
                    "  const comment = path.getValue();",
                    "  const parts = [printComment(path, options)];",
                    "",
                    "  const { printer, originalText, locStart, locEnd } = options;",
                    "  const isBlock = printer.isBlockComment && printer.isBlockComment(comment);",
                    "",
                    "  // Leading block comments should see if they need to stay on the",
                    "  // same line or not.",
                    "  if (isBlock) {",
                    "    const lineBreak = hasNewline(originalText, locEnd(comment))",
                    "      ? hasNewline(originalText, locStart(comment), {",
                    "          backwards: true,",
                    "        })",
                    "        ? hardline",
                    "        : line",
                    "      : \" \";",
                    "",
                    "    parts.push(lineBreak);",
                    "  } else {",
                    "    parts.push(hardline);",
                    "  }",
                    "",
                    "  const index = skipNewline(",
                    "    originalText,",
                    "    skipSpaces(originalText, locEnd(comment))",
                    "  );",
                    "",
                    "  if (index !== false && hasNewline(originalText, index)) {",
                    "    parts.push(hardline);",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printTrailingComment(path, options) {",
                    "  const comment = path.getValue();",
                    "  const printed = printComment(path, options);",
                    "",
                    "  const { printer, originalText, locStart } = options;",
                    "  const isBlock = printer.isBlockComment && printer.isBlockComment(comment);",
                    "",
                    "  if (hasNewline(originalText, locStart(comment), { backwards: true })) {",
                    "    // This allows comments at the end of nested structures:",
                    "    // {",
                    "    //   x: 1,",
                    "    //   y: 2",
                    "    //   // A comment",
                    "    // }",
                    "    // Those kinds of comments are almost always leading comments, but",
                    "    // here it doesn't go \"outside\" the block and turns it into a",
                    "    // trailing comment for `2`. We can simulate the above by checking",
                    "    // if this a comment on its own line; normal trailing comments are",
                    "    // always at the end of another expression.",
                    "",
                    "    const isLineBeforeEmpty = isPreviousLineEmpty(",
                    "      originalText,",
                    "      comment,",
                    "      locStart",
                    "    );",
                    "",
                    "    return lineSuffix([hardline, isLineBeforeEmpty ? hardline : \"\", printed]);",
                    "  }",
                    "",
                    "  let parts = [\" \", printed];",
                    "",
                    "  // Trailing block comments never need a newline",
                    "  if (!isBlock) {",
                    "    parts = [lineSuffix(parts), breakParent];",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printDanglingComments(path, options, sameIndent, filter) {",
                    "  const parts = [];",
                    "  const node = path.getValue();",
                    "",
                    "  if (!node || !node.comments) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  path.each(() => {",
                    "    const comment = path.getValue();",
                    "    if (!comment.leading && !comment.trailing && (!filter || filter(comment))) {",
                    "      parts.push(printComment(path, options));",
                    "    }",
                    "  }, \"comments\");",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (sameIndent) {",
                    "    return join(hardline, parts);",
                    "  }",
                    "  return indent([hardline, join(hardline, parts)]);",
                    "}",
                    "",
                    "function printCommentsSeparately(path, options, ignored) {",
                    "  const value = path.getValue();",
                    "  if (!value) {",
                    "    return {};",
                    "  }",
                    "",
                    "  let comments = value.comments || [];",
                    "  if (ignored) {",
                    "    comments = comments.filter((comment) => !ignored.has(comment));",
                    "  }",
                    "  const isCursorNode = value === options.cursorNode;",
                    "",
                    "  if (comments.length === 0) {",
                    "    const maybeCursor = isCursorNode ? cursor : \"\";",
                    "    return { leading: maybeCursor, trailing: maybeCursor };",
                    "  }",
                    "",
                    "  const leadingParts = [];",
                    "  const trailingParts = [];",
                    "  path.each(() => {",
                    "    const comment = path.getValue();",
                    "    if (ignored && ignored.has(comment)) {",
                    "      return;",
                    "    }",
                    "",
                    "    const { leading, trailing } = comment;",
                    "    if (leading) {",
                    "      leadingParts.push(printLeadingComment(path, options));",
                    "    } else if (trailing) {",
                    "      trailingParts.push(printTrailingComment(path, options));",
                    "    }",
                    "  }, \"comments\");",
                    "",
                    "  if (isCursorNode) {",
                    "    leadingParts.unshift(cursor);",
                    "    trailingParts.push(cursor);",
                    "  }",
                    "",
                    "  return { leading: leadingParts, trailing: trailingParts };",
                    "}",
                    "",
                    "function printComments(path, doc, options, ignored) {",
                    "  const { leading, trailing } = printCommentsSeparately(path, options, ignored);",
                    "  if (!leading && !trailing) {",
                    "    return doc;",
                    "  }",
                    "  return [leading, doc, trailing];",
                    "}",
                    "",
                    "function ensureAllCommentsPrinted(astComments) {",
                    "  if (!astComments) {",
                    "    return;",
                    "  }",
                    "",
                    "  for (const comment of astComments) {",
                    "    if (!comment.printed) {",
                    "      throw new Error(",
                    "        'Comment \"' +",
                    "          comment.value.trim() +",
                    "          '\" was not printed. Please report this error!'",
                    "      );",
                    "    }",
                    "    delete comment.printed;",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  attach,",
                    "  printComments,",
                    "  printCommentsSeparately,",
                    "  printDanglingComments,",
                    "  getSortedChildNodes,",
                    "  ensureAllCommentsPrinted,",
                    "};"
                ]
            },
            "core-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { outdent } = require(\"outdent\");",
                    "",
                    "const CATEGORY_CONFIG = \"Config\";",
                    "const CATEGORY_EDITOR = \"Editor\";",
                    "const CATEGORY_FORMAT = \"Format\";",
                    "const CATEGORY_OTHER = \"Other\";",
                    "const CATEGORY_OUTPUT = \"Output\";",
                    "const CATEGORY_GLOBAL = \"Global\";",
                    "const CATEGORY_SPECIAL = \"Special\";",
                    "",
                    "/**",
                    " * @typedef {Object} OptionInfo",
                    " * @property {string} [since] - available since version",
                    " * @property {string} category",
                    " * @property {'int' | 'boolean' | 'choice' | 'path'} type",
                    " * @property {boolean} [array] - indicate it's an array of the specified type",
                    " * @property {OptionValueInfo} [default]",
                    " * @property {OptionRangeInfo} [range] - for type int",
                    " * @property {string} description",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionRedirectInfo} [redirect] - redirect deprecated option",
                    " * @property {(value: any) => boolean} [exception]",
                    " * @property {OptionChoiceInfo[]} [choices] - for type choice",
                    " * @property {string} [cliName]",
                    " * @property {string} [cliCategory]",
                    " * @property {string} [cliDescription]",
                    " *",
                    " * @typedef {number | boolean | string} OptionValue",
                    " * @typedef {OptionValue | [{ value: OptionValue[] }] | Array<{ since: string, value: OptionValue}>} OptionValueInfo",
                    " *",
                    " * @typedef {Object} OptionRedirectInfo",
                    " * @property {string} option",
                    " * @property {OptionValue} value",
                    " *",
                    " * @typedef {Object} OptionRangeInfo",
                    " * @property {number} start - recommended range start",
                    " * @property {number} end - recommended range end",
                    " * @property {number} step - recommended range step",
                    " *",
                    " * @typedef {Object} OptionChoiceInfo",
                    " * @property {boolean | string} value - boolean for the option that is originally boolean type",
                    " * @property {string} description",
                    " * @property {string} [since] - undefined if available since the first version of the option",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionValueInfo} [redirect] - redirect deprecated value",
                    " */",
                    "",
                    "/** @type {{ [name: string]: OptionInfo }} */",
                    "const options = {",
                    "  cursorOffset: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: -1,",
                    "    range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Print (to stderr) where a cursor at the given position would move to after formatting.",
                    "      This option cannot be used with --range-start and --range-end.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  endOfLine: {",
                    "    since: \"1.15.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"1.15.0\", value: \"auto\" },",
                    "      { since: \"2.0.0\", value: \"lf\" },",
                    "    ],",
                    "    description: \"Which end of line characters to apply.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"lf\",",
                    "        description:",
                    "          \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\",",
                    "      },",
                    "      {",
                    "        value: \"crlf\",",
                    "        description:",
                    "          \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\",",
                    "      },",
                    "      {",
                    "        value: \"cr\",",
                    "        description: \"Carriage Return character only (\\\\r), used very rarely\",",
                    "      },",
                    "      {",
                    "        value: \"auto\",",
                    "        description: outdent`",
                    "          Maintain existing",
                    "          (mixed values within one file are normalised by looking at what's used after the first line)",
                    "        `,",
                    "      },",
                    "    ],",
                    "  },",
                    "  filepath: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"path\",",
                    "    description:",
                    "      \"Specify the input filepath. This will be used to do parser inference.\",",
                    "    cliName: \"stdin-filepath\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "    cliDescription: \"Path to the file to pretend that stdin comes from.\",",
                    "  },",
                    "  insertPragma: {",
                    "    since: \"1.8.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Insert @format pragma into file's first docblock comment.\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  parser: {",
                    "    since: \"0.0.10\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: [",
                    "      { since: \"0.0.10\", value: \"babylon\" },",
                    "      { since: \"1.13.0\", value: undefined },",
                    "    ],",
                    "    description: \"Which parser to use.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"function\",",
                    "    choices: [",
                    "      { value: \"flow\", description: \"Flow\" },",
                    "      { value: \"babel\", since: \"1.16.0\", description: \"JavaScript\" },",
                    "      { value: \"babel-flow\", since: \"1.16.0\", description: \"Flow\" },",
                    "      { value: \"babel-ts\", since: \"2.0.0\", description: \"TypeScript\" },",
                    "      { value: \"typescript\", since: \"1.4.0\", description: \"TypeScript\" },",
                    "      { value: \"espree\", since: \"2.2.0\", description: \"JavaScript\" },",
                    "      { value: \"meriyah\", since: \"2.2.0\", description: \"JavaScript\" },",
                    "      { value: \"css\", since: \"1.7.1\", description: \"CSS\" },",
                    "      { value: \"less\", since: \"1.7.1\", description: \"Less\" },",
                    "      { value: \"scss\", since: \"1.7.1\", description: \"SCSS\" },",
                    "      { value: \"json\", since: \"1.5.0\", description: \"JSON\" },",
                    "      { value: \"json5\", since: \"1.13.0\", description: \"JSON5\" },",
                    "      {",
                    "        value: \"json-stringify\",",
                    "        since: \"1.13.0\",",
                    "        description: \"JSON.stringify\",",
                    "      },",
                    "      { value: \"graphql\", since: \"1.5.0\", description: \"GraphQL\" },",
                    "      { value: \"markdown\", since: \"1.8.0\", description: \"Markdown\" },",
                    "      { value: \"mdx\", since: \"1.15.0\", description: \"MDX\" },",
                    "      { value: \"vue\", since: \"1.10.0\", description: \"Vue\" },",
                    "      { value: \"yaml\", since: \"1.14.0\", description: \"YAML\" },",
                    "      { value: \"glimmer\", since: \"2.3.0\", description: \"Ember / Handlebars\" },",
                    "      { value: \"html\", since: \"1.15.0\", description: \"HTML\" },",
                    "      { value: \"angular\", since: \"1.15.0\", description: \"Angular\" },",
                    "      {",
                    "        value: \"lwc\",",
                    "        since: \"1.17.0\",",
                    "        description: \"Lightning Web Components\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  plugins: {",
                    "    since: \"1.10.0\",",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description:",
                    "      \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  pluginSearchDirs: {",
                    "    since: \"1.13.0\",",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description: outdent`",
                    "      Custom directory that contains prettier plugins in node_modules subdirectory.",
                    "      Overrides default behavior when plugins are searched relatively to the location of Prettier.",
                    "      Multiple values are accepted.",
                    "    `,",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin-search-dir\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  printWidth: {",
                    "    since: \"0.0.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"int\",",
                    "    default: 80,",
                    "    description: \"The line length where Prettier will try wrap.\",",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "  },",
                    "  rangeEnd: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: Number.POSITIVE_INFINITY,",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Format code ending at a given character offset (exclusive).",
                    "      The range will extend forwards to the end of the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  rangeStart: {",
                    "    since: \"1.4.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: 0,",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Format code starting at a given character offset.",
                    "      The range will extend backwards to the start of the first line containing the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  requirePragma: {",
                    "    since: \"1.7.0\",",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: outdent`",
                    "      Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                    "      in order for it to be formatted.",
                    "    `,",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  tabWidth: {",
                    "    type: \"int\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    default: 2,",
                    "    description: \"Number of spaces per indentation level.\",",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "  },",
                    "  useTabs: {",
                    "    since: \"1.0.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent with tabs instead of spaces.\",",
                    "  },",
                    "  embeddedLanguageFormatting: {",
                    "    since: \"2.1.0\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: [{ since: \"2.1.0\", value: \"auto\" }],",
                    "    description:",
                    "      \"Control how Prettier formats quoted code embedded in the file.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"auto\",",
                    "        description:",
                    "          \"Format embedded code if Prettier can automatically identify it.\",",
                    "      },",
                    "      {",
                    "        value: \"off\",",
                    "        description: \"Never automatically format embedded code.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "};",
                    "",
                    "module.exports = {",
                    "  CATEGORY_CONFIG,",
                    "  CATEGORY_EDITOR,",
                    "  CATEGORY_FORMAT,",
                    "  CATEGORY_OTHER,",
                    "  CATEGORY_OUTPUT,",
                    "  CATEGORY_GLOBAL,",
                    "  CATEGORY_SPECIAL,",
                    "  options,",
                    "};"
                ]
            },
            "core.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// Use `diff/lib/diff/array.js` instead of `diff` to reduce bundle size",
                    "const { diffArrays } = require(\"diff/lib/diff/array.js\");",
                    "",
                    "const {",
                    "  printer: { printDocToString },",
                    "  debug: { printDocToDebug },",
                    "} = require(\"../document/index.js\");",
                    "const { getAlignmentSize } = require(\"../common/util.js\");",
                    "const {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "  countEndOfLineChars,",
                    "  normalizeEndOfLine,",
                    "} = require(\"../common/end-of-line.js\");",
                    "const normalizeOptions = require(\"./options.js\").normalize;",
                    "const massageAST = require(\"./massage-ast.js\");",
                    "const comments = require(\"./comments.js\");",
                    "const parser = require(\"./parser.js\");",
                    "const printAstToDoc = require(\"./ast-to-doc.js\");",
                    "const rangeUtil = require(\"./range-util.js\");",
                    "",
                    "const BOM = \"\\uFEFF\";",
                    "",
                    "const CURSOR = Symbol(\"cursor\");",
                    "",
                    "function attachComments(text, ast, opts) {",
                    "  const astComments = ast.comments;",
                    "  if (astComments) {",
                    "    delete ast.comments;",
                    "    comments.attach(astComments, ast, text, opts);",
                    "  }",
                    "  opts[Symbol.for(\"comments\")] = astComments || [];",
                    "  opts[Symbol.for(\"tokens\")] = ast.tokens || [];",
                    "  opts.originalText = text;",
                    "  return astComments;",
                    "}",
                    "",
                    "function coreFormat(originalText, opts, addAlignmentSize = 0) {",
                    "  if (!originalText || originalText.trim().length === 0) {",
                    "    return { formatted: \"\", cursorOffset: -1, comments: [] };",
                    "  }",
                    "",
                    "  const { ast, text } = parser.parse(originalText, opts);",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    const nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);",
                    "    if (nodeResult && nodeResult.node) {",
                    "      opts.cursorNode = nodeResult.node;",
                    "    }",
                    "  }",
                    "",
                    "  const astComments = attachComments(text, ast, opts);",
                    "  const doc = printAstToDoc(ast, opts, addAlignmentSize);",
                    "",
                    "  const result = printDocToString(doc, opts);",
                    "",
                    "  comments.ensureAllCommentsPrinted(astComments);",
                    "  // Remove extra leading indentation as well as the added indentation after last newline",
                    "  if (addAlignmentSize > 0) {",
                    "    const trimmed = result.formatted.trim();",
                    "",
                    "    if (result.cursorNodeStart !== undefined) {",
                    "      result.cursorNodeStart -= result.formatted.indexOf(trimmed);",
                    "    }",
                    "",
                    "    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);",
                    "  }",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    let oldCursorNodeStart;",
                    "    let oldCursorNodeText;",
                    "",
                    "    let cursorOffsetRelativeToOldCursorNode;",
                    "",
                    "    let newCursorNodeStart;",
                    "    let newCursorNodeText;",
                    "",
                    "    if (opts.cursorNode && result.cursorNodeText) {",
                    "      oldCursorNodeStart = opts.locStart(opts.cursorNode);",
                    "      oldCursorNodeText = text.slice(",
                    "        oldCursorNodeStart,",
                    "        opts.locEnd(opts.cursorNode)",
                    "      );",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode =",
                    "        opts.cursorOffset - oldCursorNodeStart;",
                    "",
                    "      newCursorNodeStart = result.cursorNodeStart;",
                    "      newCursorNodeText = result.cursorNodeText;",
                    "    } else {",
                    "      oldCursorNodeStart = 0;",
                    "      oldCursorNodeText = text;",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;",
                    "",
                    "      newCursorNodeStart = 0;",
                    "      newCursorNodeText = result.formatted;",
                    "    }",
                    "",
                    "    if (oldCursorNodeText === newCursorNodeText) {",
                    "      return {",
                    "        formatted: result.formatted,",
                    "        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,",
                    "        comments: astComments,",
                    "      };",
                    "    }",
                    "",
                    "    // diff old and new cursor node texts, with a special cursor",
                    "    // symbol inserted to find out where it moves to",
                    "",
                    "    const oldCursorNodeCharArray = [...oldCursorNodeText];",
                    "    oldCursorNodeCharArray.splice(",
                    "      cursorOffsetRelativeToOldCursorNode,",
                    "      0,",
                    "      CURSOR",
                    "    );",
                    "",
                    "    const newCursorNodeCharArray = [...newCursorNodeText];",
                    "",
                    "    const cursorNodeDiff = diffArrays(",
                    "      oldCursorNodeCharArray,",
                    "      newCursorNodeCharArray",
                    "    );",
                    "",
                    "    let cursorOffset = newCursorNodeStart;",
                    "    for (const entry of cursorNodeDiff) {",
                    "      if (entry.removed) {",
                    "        if (entry.value.includes(CURSOR)) {",
                    "          break;",
                    "        }",
                    "      } else {",
                    "        cursorOffset += entry.count;",
                    "      }",
                    "    }",
                    "",
                    "    return { formatted: result.formatted, cursorOffset, comments: astComments };",
                    "  }",
                    "",
                    "  return {",
                    "    formatted: result.formatted,",
                    "    cursorOffset: -1,",
                    "    comments: astComments,",
                    "  };",
                    "}",
                    "",
                    "function formatRange(originalText, opts) {",
                    "  const { ast, text } = parser.parse(originalText, opts);",
                    "  const { rangeStart, rangeEnd } = rangeUtil.calculateRange(text, opts, ast);",
                    "  const rangeString = text.slice(rangeStart, rangeEnd);",
                    "",
                    "  // Try to extend the range backwards to the beginning of the line.",
                    "  // This is so we can detect indentation correctly and restore it.",
                    "  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0",
                    "  const rangeStart2 = Math.min(",
                    "    rangeStart,",
                    "    text.lastIndexOf(\"\\n\", rangeStart) + 1",
                    "  );",
                    "  const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];",
                    "",
                    "  const alignmentSize = getAlignmentSize(indentString, opts.tabWidth);",
                    "",
                    "  const rangeResult = coreFormat(",
                    "    rangeString,",
                    "    {",
                    "      ...opts,",
                    "      rangeStart: 0,",
                    "      rangeEnd: Number.POSITIVE_INFINITY,",
                    "      // Track the cursor offset only if it's within our range",
                    "      cursorOffset:",
                    "        opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd",
                    "          ? opts.cursorOffset - rangeStart",
                    "          : -1,",
                    "      // Always use `lf` to format, we'll replace it later",
                    "      endOfLine: \"lf\",",
                    "    },",
                    "    alignmentSize",
                    "  );",
                    "",
                    "  // Since the range contracts to avoid trailing whitespace,",
                    "  // we need to remove the newline that was inserted by the `format` call.",
                    "  const rangeTrimmed = rangeResult.formatted.trimEnd();",
                    "",
                    "  let { cursorOffset } = opts;",
                    "  if (cursorOffset > rangeEnd) {",
                    "    // handle the case where the cursor was past the end of the range",
                    "    cursorOffset += rangeTrimmed.length - rangeString.length;",
                    "  } else if (rangeResult.cursorOffset >= 0) {",
                    "    // handle the case where the cursor was in the range",
                    "    cursorOffset = rangeResult.cursorOffset + rangeStart;",
                    "  }",
                    "  // keep the cursor as it was if it was before the start of the range",
                    "",
                    "  let formatted =",
                    "    text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);",
                    "  if (opts.endOfLine !== \"lf\") {",
                    "    const eol = convertEndOfLineToChars(opts.endOfLine);",
                    "    if (cursorOffset >= 0 && eol === \"\\r\\n\") {",
                    "      cursorOffset += countEndOfLineChars(",
                    "        formatted.slice(0, cursorOffset),",
                    "        \"\\n\"",
                    "      );",
                    "    }",
                    "",
                    "    formatted = formatted.replace(/\\n/g, eol);",
                    "  }",
                    "",
                    "  return { formatted, cursorOffset, comments: rangeResult.comments };",
                    "}",
                    "",
                    "function ensureIndexInText(text, index, defaultValue) {",
                    "  if (",
                    "    typeof index !== \"number\" ||",
                    "    Number.isNaN(index) ||",
                    "    index < 0 ||",
                    "    index > text.length",
                    "  ) {",
                    "    return defaultValue;",
                    "  }",
                    "",
                    "  return index;",
                    "}",
                    "",
                    "function normalizeIndexes(text, options) {",
                    "  let { cursorOffset, rangeStart, rangeEnd } = options;",
                    "  cursorOffset = ensureIndexInText(text, cursorOffset, -1);",
                    "  rangeStart = ensureIndexInText(text, rangeStart, 0);",
                    "  rangeEnd = ensureIndexInText(text, rangeEnd, text.length);",
                    "",
                    "  return { ...options, cursorOffset, rangeStart, rangeEnd };",
                    "}",
                    "",
                    "function normalizeInputAndOptions(text, options) {",
                    "  let { cursorOffset, rangeStart, rangeEnd, endOfLine } = normalizeIndexes(",
                    "    text,",
                    "    options",
                    "  );",
                    "",
                    "  const hasBOM = text.charAt(0) === BOM;",
                    "",
                    "  if (hasBOM) {",
                    "    text = text.slice(1);",
                    "    cursorOffset--;",
                    "    rangeStart--;",
                    "    rangeEnd--;",
                    "  }",
                    "",
                    "  if (endOfLine === \"auto\") {",
                    "    endOfLine = guessEndOfLine(text);",
                    "  }",
                    "",
                    "  // get rid of CR/CRLF parsing",
                    "  if (text.includes(\"\\r\")) {",
                    "    const countCrlfBefore = (index) =>",
                    "      countEndOfLineChars(text.slice(0, Math.max(index, 0)), \"\\r\\n\");",
                    "",
                    "    cursorOffset -= countCrlfBefore(cursorOffset);",
                    "    rangeStart -= countCrlfBefore(rangeStart);",
                    "    rangeEnd -= countCrlfBefore(rangeEnd);",
                    "",
                    "    text = normalizeEndOfLine(text);",
                    "  }",
                    "",
                    "  return {",
                    "    hasBOM,",
                    "    text,",
                    "    options: normalizeIndexes(text, {",
                    "      ...options,",
                    "      cursorOffset,",
                    "      rangeStart,",
                    "      rangeEnd,",
                    "      endOfLine,",
                    "    }),",
                    "  };",
                    "}",
                    "",
                    "function hasPragma(text, options) {",
                    "  const selectedParser = parser.resolveParser(options);",
                    "  return !selectedParser.hasPragma || selectedParser.hasPragma(text);",
                    "}",
                    "",
                    "function formatWithCursor(originalText, originalOptions) {",
                    "  let { hasBOM, text, options } = normalizeInputAndOptions(",
                    "    originalText,",
                    "    normalizeOptions(originalOptions)",
                    "  );",
                    "",
                    "  if (",
                    "    (options.rangeStart >= options.rangeEnd && text !== \"\") ||",
                    "    (options.requirePragma && !hasPragma(text, options))",
                    "  ) {",
                    "    return {",
                    "      formatted: originalText,",
                    "      cursorOffset: originalOptions.cursorOffset,",
                    "      comments: [],",
                    "    };",
                    "  }",
                    "",
                    "  let result;",
                    "",
                    "  if (options.rangeStart > 0 || options.rangeEnd < text.length) {",
                    "    result = formatRange(text, options);",
                    "  } else {",
                    "    if (",
                    "      !options.requirePragma &&",
                    "      options.insertPragma &&",
                    "      options.printer.insertPragma &&",
                    "      !hasPragma(text, options)",
                    "    ) {",
                    "      text = options.printer.insertPragma(text);",
                    "    }",
                    "    result = coreFormat(text, options);",
                    "  }",
                    "",
                    "  if (hasBOM) {",
                    "    result.formatted = BOM + result.formatted;",
                    "",
                    "    if (result.cursorOffset >= 0) {",
                    "      result.cursorOffset++;",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "module.exports = {",
                    "  formatWithCursor,",
                    "",
                    "  parse(originalText, originalOptions, massage) {",
                    "    const { text, options } = normalizeInputAndOptions(",
                    "      originalText,",
                    "      normalizeOptions(originalOptions)",
                    "    );",
                    "    const parsed = parser.parse(text, options);",
                    "    if (massage) {",
                    "      parsed.ast = massageAST(parsed.ast, options);",
                    "    }",
                    "    return parsed;",
                    "  },",
                    "",
                    "  formatAST(ast, options) {",
                    "    options = normalizeOptions(options);",
                    "    const doc = printAstToDoc(ast, options);",
                    "    return printDocToString(doc, options);",
                    "  },",
                    "",
                    "  // Doesn't handle shebang for now",
                    "  formatDoc(doc, options) {",
                    "    return formatWithCursor(printDocToDebug(doc), {",
                    "      ...options,",
                    "      parser: \"__js_expression\",",
                    "    }).formatted;",
                    "  },",
                    "",
                    "  printToDoc(originalText, options) {",
                    "    options = normalizeOptions(options);",
                    "    const { ast, text } = parser.parse(originalText, options);",
                    "    attachComments(text, ast, options);",
                    "    return printAstToDoc(ast, options);",
                    "  },",
                    "",
                    "  printDocToString(doc, options) {",
                    "    return printDocToString(doc, normalizeOptions(options));",
                    "  },",
                    "};"
                ]
            },
            "massage-ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function massageAST(ast, options, parent) {",
                    "  if (Array.isArray(ast)) {",
                    "    return ast.map((e) => massageAST(e, options, parent)).filter(Boolean);",
                    "  }",
                    "",
                    "  if (!ast || typeof ast !== \"object\") {",
                    "    return ast;",
                    "  }",
                    "",
                    "  const cleanFunction = options.printer.massageAstNode;",
                    "  let ignoredProperties;",
                    "  if (cleanFunction && cleanFunction.ignoredProperties) {",
                    "    ignoredProperties = cleanFunction.ignoredProperties;",
                    "  } else {",
                    "    ignoredProperties = new Set();",
                    "  }",
                    "",
                    "  const newObj = {};",
                    "  for (const [key, value] of Object.entries(ast)) {",
                    "    if (!ignoredProperties.has(key) && typeof value !== \"function\") {",
                    "      newObj[key] = massageAST(value, options, ast);",
                    "    }",
                    "  }",
                    "",
                    "  if (cleanFunction) {",
                    "    const result = cleanFunction(ast, newObj, parent);",
                    "    if (result === null) {",
                    "      return;",
                    "    }",
                    "    if (result) {",
                    "      return result;",
                    "    }",
                    "  }",
                    "",
                    "  return newObj;",
                    "}",
                    "",
                    "module.exports = massageAST;"
                ]
            },
            "multiparser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const {",
                    "  utils: { stripTrailingHardline },",
                    "} = require(\"../document/index.js\");",
                    "const { normalize } = require(\"./options.js\");",
                    "const comments = require(\"./comments.js\");",
                    "",
                    "function printSubtree(path, print, options, printAstToDoc) {",
                    "  if (options.printer.embed && options.embeddedLanguageFormatting === \"auto\") {",
                    "    return options.printer.embed(",
                    "      path,",
                    "      print,",
                    "      (text, partialNextOptions, textToDocOptions) =>",
                    "        textToDoc(",
                    "          text,",
                    "          partialNextOptions,",
                    "          options,",
                    "          printAstToDoc,",
                    "          textToDocOptions",
                    "        ),",
                    "      options",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function textToDoc(",
                    "  text,",
                    "  partialNextOptions,",
                    "  parentOptions,",
                    "  printAstToDoc,",
                    "  // TODO: remove `stripTrailingHardline` in v3.0.0",
                    "  { stripTrailingHardline: shouldStripTrailingHardline = false } = {}",
                    ") {",
                    "  const nextOptions = normalize(",
                    "    {",
                    "      ...parentOptions,",
                    "      ...partialNextOptions,",
                    "      parentParser: parentOptions.parser,",
                    "      originalText: text,",
                    "    },",
                    "    { passThrough: true }",
                    "  );",
                    "",
                    "  const result = require(\"./parser.js\").parse(text, nextOptions);",
                    "  const { ast } = result;",
                    "  text = result.text;",
                    "",
                    "  const astComments = ast.comments;",
                    "  delete ast.comments;",
                    "  comments.attach(astComments, ast, text, nextOptions);",
                    "  nextOptions[Symbol.for(\"comments\")] = astComments || [];",
                    "  nextOptions[Symbol.for(\"tokens\")] = ast.tokens || [];",
                    "",
                    "  const doc = printAstToDoc(ast, nextOptions);",
                    "  comments.ensureAllCommentsPrinted(astComments);",
                    "",
                    "  if (shouldStripTrailingHardline) {",
                    "    // TODO: move this to `stripTrailingHardline` function in `/src/document/doc-utils.js`",
                    "    if (typeof doc === \"string\") {",
                    "      return doc.replace(/(?:\\r?\\n)*$/, \"\");",
                    "    }",
                    "",
                    "    return stripTrailingHardline(doc);",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  return doc;",
                    "}",
                    "",
                    "module.exports = {",
                    "  printSubtree,",
                    "};"
                ]
            },
            "options-normalizer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const vnopts = require(\"vnopts\");",
                    "const leven = require(\"leven\");",
                    "const chalk = require(\"chalk\");",
                    "const getLast = require(\"../utils/get-last.js\");",
                    "",
                    "const cliDescriptor = {",
                    "  key: (key) => (key.length === 1 ? `-${key}` : `--${key}`),",
                    "  value: (value) => vnopts.apiDescriptor.value(value),",
                    "  pair: ({ key, value }) =>",
                    "    value === false",
                    "      ? `--no-${key}`",
                    "      : value === true",
                    "      ? cliDescriptor.key(key)",
                    "      : value === \"\"",
                    "      ? `${cliDescriptor.key(key)} without an argument`",
                    "      : `${cliDescriptor.key(key)}=${value}`,",
                    "};",
                    "",
                    "class FlagSchema extends vnopts.ChoiceSchema {",
                    "  constructor({ name, flags }) {",
                    "    super({ name, choices: flags });",
                    "    this._flags = [...flags].sort();",
                    "  }",
                    "  preprocess(value, utils) {",
                    "    if (",
                    "      typeof value === \"string\" &&",
                    "      value.length > 0 &&",
                    "      !this._flags.includes(value)",
                    "    ) {",
                    "      const suggestion = this._flags.find((flag) => leven(flag, value) < 3);",
                    "      if (suggestion) {",
                    "        utils.logger.warn(",
                    "          [",
                    "            `Unknown flag ${chalk.yellow(utils.descriptor.value(value))},`,",
                    "            `did you mean ${chalk.blue(utils.descriptor.value(suggestion))}?`,",
                    "          ].join(\" \")",
                    "        );",
                    "        return suggestion;",
                    "      }",
                    "    }",
                    "    return value;",
                    "  }",
                    "  expected() {",
                    "    return \"a flag\";",
                    "  }",
                    "}",
                    "",
                    "let hasDeprecationWarned;",
                    "",
                    "function normalizeOptions(",
                    "  options,",
                    "  optionInfos,",
                    "  { logger, isCLI = false, passThrough = false } = {}",
                    ") {",
                    "  const unknown = !passThrough",
                    "    ? (key, value, options) => {",
                    "        // Don't suggest `_` for unknown flags",
                    "        const { _, ...schemas } = options.schemas;",
                    "        return vnopts.levenUnknownHandler(key, value, {",
                    "          ...options,",
                    "          schemas,",
                    "        });",
                    "      }",
                    "    : Array.isArray(passThrough)",
                    "    ? (key, value) =>",
                    "        !passThrough.includes(key) ? undefined : { [key]: value }",
                    "    : (key, value) => ({ [key]: value });",
                    "",
                    "  const descriptor = isCLI ? cliDescriptor : vnopts.apiDescriptor;",
                    "  const schemas = optionInfosToSchemas(optionInfos, { isCLI });",
                    "  const normalizer = new vnopts.Normalizer(schemas, {",
                    "    logger,",
                    "    unknown,",
                    "    descriptor,",
                    "  });",
                    "",
                    "  const shouldSuppressDuplicateDeprecationWarnings = logger !== false;",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {",
                    "    normalizer._hasDeprecationWarned = hasDeprecationWarned;",
                    "  }",
                    "",
                    "  const normalized = normalizer.normalize(options);",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings) {",
                    "    hasDeprecationWarned = normalizer._hasDeprecationWarned;",
                    "  }",
                    "",
                    "  return normalized;",
                    "}",
                    "",
                    "function optionInfosToSchemas(optionInfos, { isCLI }) {",
                    "  const schemas = [];",
                    "",
                    "  if (isCLI) {",
                    "    schemas.push(vnopts.AnySchema.create({ name: \"_\" }));",
                    "  }",
                    "",
                    "  for (const optionInfo of optionInfos) {",
                    "    schemas.push(optionInfoToSchema(optionInfo, { isCLI, optionInfos }));",
                    "",
                    "    if (optionInfo.alias && isCLI) {",
                    "      schemas.push(",
                    "        vnopts.AliasSchema.create({",
                    "          name: optionInfo.alias,",
                    "          sourceName: optionInfo.name,",
                    "        })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return schemas;",
                    "}",
                    "",
                    "function optionInfoToSchema(optionInfo, { isCLI, optionInfos }) {",
                    "  let SchemaConstructor;",
                    "  const parameters = { name: optionInfo.name };",
                    "  const handlers = {};",
                    "",
                    "  switch (optionInfo.type) {",
                    "    case \"int\":",
                    "      SchemaConstructor = vnopts.IntegerSchema;",
                    "      if (isCLI) {",
                    "        parameters.preprocess = (value) => Number(value);",
                    "      }",
                    "      break;",
                    "    case \"string\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    case \"choice\":",
                    "      SchemaConstructor = vnopts.ChoiceSchema;",
                    "      parameters.choices = optionInfo.choices.map((choiceInfo) =>",
                    "        typeof choiceInfo === \"object\" && choiceInfo.redirect",
                    "          ? {",
                    "              ...choiceInfo,",
                    "              redirect: {",
                    "                to: { key: optionInfo.name, value: choiceInfo.redirect },",
                    "              },",
                    "            }",
                    "          : choiceInfo",
                    "      );",
                    "      break;",
                    "    case \"boolean\":",
                    "      SchemaConstructor = vnopts.BooleanSchema;",
                    "      break;",
                    "    case \"flag\":",
                    "      SchemaConstructor = FlagSchema;",
                    "      parameters.flags = optionInfos.flatMap((optionInfo) =>",
                    "        [",
                    "          optionInfo.alias,",
                    "          optionInfo.description && optionInfo.name,",
                    "          optionInfo.oppositeDescription && `no-${optionInfo.name}`,",
                    "        ].filter(Boolean)",
                    "      );",
                    "      break;",
                    "    case \"path\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    default:",
                    "      /* istanbul ignore next */",
                    "      throw new Error(`Unexpected type ${optionInfo.type}`);",
                    "  }",
                    "",
                    "  if (optionInfo.exception) {",
                    "    parameters.validate = (value, schema, utils) =>",
                    "      optionInfo.exception(value) || schema.validate(value, utils);",
                    "  } else {",
                    "    parameters.validate = (value, schema, utils) =>",
                    "      value === undefined || schema.validate(value, utils);",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (optionInfo.redirect) {",
                    "    handlers.redirect = (value) =>",
                    "      !value",
                    "        ? undefined",
                    "        : {",
                    "            to: {",
                    "              key: optionInfo.redirect.option,",
                    "              value: optionInfo.redirect.value,",
                    "            },",
                    "          };",
                    "  }",
                    "",
                    "  /* istanbul ignore next */",
                    "  if (optionInfo.deprecated) {",
                    "    handlers.deprecated = true;",
                    "  }",
                    "",
                    "  // allow CLI overriding, e.g., prettier package.json --tab-width 1 --tab-width 2",
                    "  if (isCLI && !optionInfo.array) {",
                    "    const originalPreprocess = parameters.preprocess || ((x) => x);",
                    "    parameters.preprocess = (value, schema, utils) =>",
                    "      schema.preprocess(",
                    "        originalPreprocess(Array.isArray(value) ? getLast(value) : value),",
                    "        utils",
                    "      );",
                    "  }",
                    "",
                    "  return optionInfo.array",
                    "    ? vnopts.ArraySchema.create({",
                    "        ...(isCLI ? { preprocess: (v) => (Array.isArray(v) ? v : [v]) } : {}),",
                    "        ...handlers,",
                    "        valueSchema: SchemaConstructor.create(parameters),",
                    "      })",
                    "    : SchemaConstructor.create({ ...parameters, ...handlers });",
                    "}",
                    "",
                    "function normalizeApiOptions(options, optionInfos, opts) {",
                    "  return normalizeOptions(options, optionInfos, opts);",
                    "}",
                    "",
                    "function normalizeCliOptions(options, optionInfos, opts) {",
                    "  return normalizeOptions(options, optionInfos, { isCLI: true, ...opts });",
                    "}",
                    "",
                    "module.exports = {",
                    "  normalizeApiOptions,",
                    "  normalizeCliOptions,",
                    "};"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\");",
                    "const path = require(\"path\");",
                    "const readlines = require(\"n-readlines\");",
                    "const { UndefinedParserError } = require(\"../common/errors.js\");",
                    "const { getSupportInfo } = require(\"../main/support.js\");",
                    "const normalizer = require(\"./options-normalizer.js\");",
                    "const { resolveParser } = require(\"./parser.js\");",
                    "",
                    "const hiddenDefaults = {",
                    "  astFormat: \"estree\",",
                    "  printer: {},",
                    "  originalText: undefined,",
                    "  locStart: null,",
                    "  locEnd: null,",
                    "};",
                    "",
                    "// Copy options and fill in default values.",
                    "function normalize(options, opts = {}) {",
                    "  const rawOptions = { ...options };",
                    "",
                    "  const supportOptions = getSupportInfo({",
                    "    plugins: options.plugins,",
                    "    showUnreleased: true,",
                    "    showDeprecated: true,",
                    "  }).options;",
                    "",
                    "  const defaults = {",
                    "    ...hiddenDefaults,",
                    "    ...Object.fromEntries(",
                    "      supportOptions",
                    "        .filter((optionInfo) => optionInfo.default !== undefined)",
                    "        .map((option) => [option.name, option.default])",
                    "    ),",
                    "  };",
                    "  if (!rawOptions.parser) {",
                    "    if (!rawOptions.filepath) {",
                    "      const logger = opts.logger || console;",
                    "      logger.warn(",
                    "        \"No parser and no filepath given, using 'babel' the parser now \" +",
                    "          \"but this will throw an error in the future. \" +",
                    "          \"Please specify a parser or a filepath so one can be inferred.\"",
                    "      );",
                    "      rawOptions.parser = \"babel\";",
                    "    } else {",
                    "      rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);",
                    "      if (!rawOptions.parser) {",
                    "        throw new UndefinedParserError(",
                    "          `No parser could be inferred for file: ${rawOptions.filepath}`",
                    "        );",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const parser = resolveParser(",
                    "    normalizer.normalizeApiOptions(",
                    "      rawOptions,",
                    "      [supportOptions.find((x) => x.name === \"parser\")],",
                    "      { passThrough: true, logger: false }",
                    "    )",
                    "  );",
                    "  rawOptions.astFormat = parser.astFormat;",
                    "  rawOptions.locEnd = parser.locEnd;",
                    "  rawOptions.locStart = parser.locStart;",
                    "",
                    "  const plugin = getPlugin(rawOptions);",
                    "  rawOptions.printer = plugin.printers[rawOptions.astFormat];",
                    "",
                    "  const pluginDefaults = Object.fromEntries(",
                    "    supportOptions",
                    "      .filter(",
                    "        (optionInfo) =>",
                    "          optionInfo.pluginDefaults &&",
                    "          optionInfo.pluginDefaults[plugin.name] !== undefined",
                    "      )",
                    "      .map((optionInfo) => [",
                    "        optionInfo.name,",
                    "        optionInfo.pluginDefaults[plugin.name],",
                    "      ])",
                    "  );",
                    "",
                    "  const mixedDefaults = { ...defaults, ...pluginDefaults };",
                    "",
                    "  for (const [k, value] of Object.entries(mixedDefaults)) {",
                    "    if (rawOptions[k] === null || rawOptions[k] === undefined) {",
                    "      rawOptions[k] = value;",
                    "    }",
                    "  }",
                    "",
                    "  if (rawOptions.parser === \"json\") {",
                    "    rawOptions.trailingComma = \"none\";",
                    "  }",
                    "",
                    "  return normalizer.normalizeApiOptions(rawOptions, supportOptions, {",
                    "    passThrough: Object.keys(hiddenDefaults),",
                    "    ...opts,",
                    "  });",
                    "}",
                    "",
                    "function getPlugin(options) {",
                    "  const { astFormat } = options;",
                    "",
                    "  // TODO: test this with plugins",
                    "  /* istanbul ignore next */",
                    "  if (!astFormat) {",
                    "    throw new Error(\"getPlugin() requires astFormat to be set\");",
                    "  }",
                    "  const printerPlugin = options.plugins.find(",
                    "    (plugin) => plugin.printers && plugin.printers[astFormat]",
                    "  );",
                    "  // TODO: test this with plugins",
                    "  /* istanbul ignore next */",
                    "  if (!printerPlugin) {",
                    "    throw new Error(`Couldn't find plugin for AST format \"${astFormat}\"`);",
                    "  }",
                    "",
                    "  return printerPlugin;",
                    "}",
                    "",
                    "function getInterpreter(filepath) {",
                    "  /* istanbul ignore next */",
                    "  if (typeof filepath !== \"string\") {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  let fd;",
                    "  try {",
                    "    fd = fs.openSync(filepath, \"r\");",
                    "  } catch {",
                    "    // istanbul ignore next",
                    "    return \"\";",
                    "  }",
                    "",
                    "  try {",
                    "    const liner = new readlines(fd);",
                    "    const firstLine = liner.next().toString(\"utf8\");",
                    "",
                    "    // #!/bin/env node, #!/usr/bin/env node",
                    "    const m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);",
                    "    if (m1) {",
                    "      return m1[1];",
                    "    }",
                    "",
                    "    // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node",
                    "    const m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);",
                    "    if (m2) {",
                    "      return m2[1];",
                    "    }",
                    "    return \"\";",
                    "  } catch {",
                    "    // There are some weird cases where paths are missing, causing Jest",
                    "    // failures. It's unclear what these correspond to in the real world.",
                    "    /* istanbul ignore next */",
                    "    return \"\";",
                    "  } finally {",
                    "    try {",
                    "      // There are some weird cases where paths are missing, causing Jest",
                    "      // failures. It's unclear what these correspond to in the real world.",
                    "      fs.closeSync(fd);",
                    "    } catch {",
                    "      // nop",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function inferParser(filepath, plugins) {",
                    "  const filename = path.basename(filepath).toLowerCase();",
                    "  const languages = getSupportInfo({ plugins }).languages.filter(",
                    "    (language) => language.since !== null",
                    "  );",
                    "",
                    "  // If the file has no extension, we can try to infer the language from the",
                    "  // interpreter in the shebang line, if any; but since this requires FS access,",
                    "  // do it last.",
                    "  let language = languages.find(",
                    "    (language) =>",
                    "      (language.extensions &&",
                    "        language.extensions.some((extension) =>",
                    "          filename.endsWith(extension)",
                    "        )) ||",
                    "      (language.filenames &&",
                    "        language.filenames.some((name) => name.toLowerCase() === filename))",
                    "  );",
                    "",
                    "  if (!language && !filename.includes(\".\")) {",
                    "    const interpreter = getInterpreter(filepath);",
                    "    language = languages.find(",
                    "      (language) =>",
                    "        language.interpreters && language.interpreters.includes(interpreter)",
                    "    );",
                    "  }",
                    "",
                    "  return language && language.parsers[0];",
                    "}",
                    "",
                    "module.exports = { normalize, hiddenDefaults, inferParser };"
                ]
            },
            "parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const path = require(\"path\");",
                    "const { ConfigError } = require(\"../common/errors.js\");",
                    "const jsLoc = require(\"../language-js/loc.js\");",
                    "",
                    "const { locStart, locEnd } = jsLoc;",
                    "",
                    "// Use defineProperties()/getOwnPropertyDescriptor() to prevent",
                    "// triggering the parsers getters.",
                    "const ownNames = Object.getOwnPropertyNames;",
                    "const ownDescriptor = Object.getOwnPropertyDescriptor;",
                    "function getParsers(options) {",
                    "  const parsers = {};",
                    "  for (const plugin of options.plugins) {",
                    "    // TODO: test this with plugins",
                    "    /* istanbul ignore next */",
                    "    if (!plugin.parsers) {",
                    "      continue;",
                    "    }",
                    "",
                    "    for (const name of ownNames(plugin.parsers)) {",
                    "      Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));",
                    "    }",
                    "  }",
                    "",
                    "  return parsers;",
                    "}",
                    "",
                    "function resolveParser(opts, parsers = getParsers(opts)) {",
                    "  if (typeof opts.parser === \"function\") {",
                    "    // Custom parser API always works with JavaScript.",
                    "    return {",
                    "      parse: opts.parser,",
                    "      astFormat: \"estree\",",
                    "      locStart,",
                    "      locEnd,",
                    "    };",
                    "  }",
                    "",
                    "  if (typeof opts.parser === \"string\") {",
                    "    if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {",
                    "      return parsers[opts.parser];",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    if (process.env.PRETTIER_TARGET === \"universal\") {",
                    "      throw new ConfigError(",
                    "        `Couldn't resolve parser \"${opts.parser}\". Parsers must be explicitly added to the standalone bundle.`",
                    "      );",
                    "    }",
                    "",
                    "    try {",
                    "      return {",
                    "        parse: require(path.resolve(process.cwd(), opts.parser)),",
                    "        astFormat: \"estree\",",
                    "        locStart,",
                    "        locEnd,",
                    "      };",
                    "    } catch {",
                    "      /* istanbul ignore next */",
                    "      throw new ConfigError(`Couldn't resolve parser \"${opts.parser}\"`);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function parse(text, opts) {",
                    "  const parsers = getParsers(opts);",
                    "",
                    "  // Create a new object {parserName: parseFn}. Uses defineProperty() to only call",
                    "  // the parsers getters when actually calling the parser `parse` function.",
                    "  const parsersForCustomParserApi = Object.defineProperties(",
                    "    {},",
                    "    Object.fromEntries(",
                    "      Object.keys(parsers).map((parserName) => [",
                    "        parserName,",
                    "        {",
                    "          enumerable: true,",
                    "          get() {",
                    "            return parsers[parserName].parse;",
                    "          },",
                    "        },",
                    "      ])",
                    "    )",
                    "  );",
                    "",
                    "  const parser = resolveParser(opts, parsers);",
                    "",
                    "  try {",
                    "    if (parser.preprocess) {",
                    "      text = parser.preprocess(text, opts);",
                    "    }",
                    "",
                    "    return {",
                    "      text,",
                    "      ast: parser.parse(text, parsersForCustomParserApi, opts),",
                    "    };",
                    "  } catch (error) {",
                    "    const { loc } = error;",
                    "",
                    "    if (loc) {",
                    "      const { codeFrameColumns } = require(\"@babel/code-frame\");",
                    "      error.codeFrame = codeFrameColumns(text, loc, { highlightCode: true });",
                    "      error.message += \"\\n\" + error.codeFrame;",
                    "      throw error;",
                    "    }",
                    "",
                    "    /* istanbul ignore next */",
                    "    throw error.stack;",
                    "  }",
                    "}",
                    "",
                    "module.exports = { parse, resolveParser };"
                ]
            },
            "range-util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const assert = require(\"assert\");",
                    "const comments = require(\"./comments.js\");",
                    "",
                    "const isJsonParser = ({ parser }) =>",
                    "  parser === \"json\" || parser === \"json5\" || parser === \"json-stringify\";",
                    "",
                    "function findCommonAncestor(startNodeAndParents, endNodeAndParents) {",
                    "  const startNodeAndAncestors = [",
                    "    startNodeAndParents.node,",
                    "    ...startNodeAndParents.parentNodes,",
                    "  ];",
                    "  const endNodeAndAncestors = new Set([",
                    "    endNodeAndParents.node,",
                    "    ...endNodeAndParents.parentNodes,",
                    "  ]);",
                    "  return startNodeAndAncestors.find(",
                    "    (node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node)",
                    "  );",
                    "}",
                    "",
                    "function dropRootParents(parents) {",
                    "  let lastParentIndex = parents.length - 1;",
                    "  for (;;) {",
                    "    const parent = parents[lastParentIndex];",
                    "    if (parent && (parent.type === \"Program\" || parent.type === \"File\")) {",
                    "      lastParentIndex--;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "  return parents.slice(0, lastParentIndex + 1);",
                    "}",
                    "",
                    "function findSiblingAncestors(",
                    "  startNodeAndParents,",
                    "  endNodeAndParents,",
                    "  { locStart, locEnd }",
                    ") {",
                    "  let resultStartNode = startNodeAndParents.node;",
                    "  let resultEndNode = endNodeAndParents.node;",
                    "",
                    "  if (resultStartNode === resultEndNode) {",
                    "    return {",
                    "      startNode: resultStartNode,",
                    "      endNode: resultEndNode,",
                    "    };",
                    "  }",
                    "",
                    "  const startNodeStart = locStart(startNodeAndParents.node);",
                    "  for (const endParent of dropRootParents(endNodeAndParents.parentNodes)) {",
                    "    if (locStart(endParent) >= startNodeStart) {",
                    "      resultEndNode = endParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  const endNodeEnd = locEnd(endNodeAndParents.node);",
                    "  for (const startParent of dropRootParents(startNodeAndParents.parentNodes)) {",
                    "    if (locEnd(startParent) <= endNodeEnd) {",
                    "      resultStartNode = startParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  return {",
                    "    startNode: resultStartNode,",
                    "    endNode: resultEndNode,",
                    "  };",
                    "}",
                    "",
                    "function findNodeAtOffset(",
                    "  node,",
                    "  offset,",
                    "  options,",
                    "  predicate,",
                    "  parentNodes = [],",
                    "  type",
                    ") {",
                    "  const { locStart, locEnd } = options;",
                    "  const start = locStart(node);",
                    "  const end = locEnd(node);",
                    "",
                    "  if (",
                    "    offset > end ||",
                    "    offset < start ||",
                    "    (type === \"rangeEnd\" && offset === start) ||",
                    "    (type === \"rangeStart\" && offset === end)",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  for (const childNode of comments.getSortedChildNodes(node, options)) {",
                    "    const childResult = findNodeAtOffset(",
                    "      childNode,",
                    "      offset,",
                    "      options,",
                    "      predicate,",
                    "      [node, ...parentNodes],",
                    "      type",
                    "    );",
                    "    if (childResult) {",
                    "      return childResult;",
                    "    }",
                    "  }",
                    "",
                    "  if (!predicate || predicate(node, parentNodes[0])) {",
                    "    return {",
                    "      node,",
                    "      parentNodes,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "// See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5",
                    "function isJsSourceElement(type, parentType) {",
                    "  return (",
                    "    parentType !== \"DeclareExportDeclaration\" &&",
                    "    type !== \"TypeParameterDeclaration\" &&",
                    "    (type === \"Directive\" ||",
                    "      type === \"TypeAlias\" ||",
                    "      type === \"TSExportAssignment\" ||",
                    "      type.startsWith(\"Declare\") ||",
                    "      type.startsWith(\"TSDeclare\") ||",
                    "      type.endsWith(\"Statement\") ||",
                    "      type.endsWith(\"Declaration\"))",
                    "  );",
                    "}",
                    "",
                    "const jsonSourceElements = new Set([",
                    "  \"ObjectExpression\",",
                    "  \"ArrayExpression\",",
                    "  \"StringLiteral\",",
                    "  \"NumericLiteral\",",
                    "  \"BooleanLiteral\",",
                    "  \"NullLiteral\",",
                    "  \"UnaryExpression\",",
                    "  \"TemplateLiteral\",",
                    "]);",
                    "const graphqlSourceElements = new Set([",
                    "  \"OperationDefinition\",",
                    "  \"FragmentDefinition\",",
                    "  \"VariableDefinition\",",
                    "  \"TypeExtensionDefinition\",",
                    "  \"ObjectTypeDefinition\",",
                    "  \"FieldDefinition\",",
                    "  \"DirectiveDefinition\",",
                    "  \"EnumTypeDefinition\",",
                    "  \"EnumValueDefinition\",",
                    "  \"InputValueDefinition\",",
                    "  \"InputObjectTypeDefinition\",",
                    "  \"SchemaDefinition\",",
                    "  \"OperationTypeDefinition\",",
                    "  \"InterfaceTypeDefinition\",",
                    "  \"UnionTypeDefinition\",",
                    "  \"ScalarTypeDefinition\",",
                    "]);",
                    "function isSourceElement(opts, node, parentNode) {",
                    "  /* istanbul ignore next */",
                    "  if (!node) {",
                    "    return false;",
                    "  }",
                    "  switch (opts.parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"__babel_estree\":",
                    "      return isJsSourceElement(node.type, parentNode && parentNode.type);",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      return jsonSourceElements.has(node.type);",
                    "    case \"graphql\":",
                    "      return graphqlSourceElements.has(node.kind);",
                    "    case \"vue\":",
                    "      return node.tag !== \"root\";",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function calculateRange(text, opts, ast) {",
                    "  let { rangeStart: start, rangeEnd: end, locStart, locEnd } = opts;",
                    "  assert.ok(end > start);",
                    "  // Contract the range so that it has non-whitespace characters at its endpoints.",
                    "  // This ensures we can format a range that doesn't end on a node.",
                    "  const firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\\S/);",
                    "  const isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;",
                    "  if (!isAllWhitespace) {",
                    "    start += firstNonWhitespaceCharacterIndex;",
                    "    for (; end > start; --end) {",
                    "      if (/\\S/.test(text[end - 1])) {",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const startNodeAndParents = findNodeAtOffset(",
                    "    ast,",
                    "    start,",
                    "    opts,",
                    "    (node, parentNode) => isSourceElement(opts, node, parentNode),",
                    "    [],",
                    "    \"rangeStart\"",
                    "  );",
                    "  const endNodeAndParents =",
                    "    // No need find Node at `end`, it will be the same as `startNodeAndParents`",
                    "    isAllWhitespace",
                    "      ? startNodeAndParents",
                    "      : findNodeAtOffset(",
                    "          ast,",
                    "          end,",
                    "          opts,",
                    "          (node) => isSourceElement(opts, node),",
                    "          [],",
                    "          \"rangeEnd\"",
                    "        );",
                    "  if (!startNodeAndParents || !endNodeAndParents) {",
                    "    return {",
                    "      rangeStart: 0,",
                    "      rangeEnd: 0,",
                    "    };",
                    "  }",
                    "",
                    "  let startNode;",
                    "  let endNode;",
                    "  if (isJsonParser(opts)) {",
                    "    const commonAncestor = findCommonAncestor(",
                    "      startNodeAndParents,",
                    "      endNodeAndParents",
                    "    );",
                    "    startNode = commonAncestor;",
                    "    endNode = commonAncestor;",
                    "  } else {",
                    "    ({ startNode, endNode } = findSiblingAncestors(",
                    "      startNodeAndParents,",
                    "      endNodeAndParents,",
                    "      opts",
                    "    ));",
                    "  }",
                    "",
                    "  return {",
                    "    rangeStart: Math.min(locStart(startNode), locStart(endNode)),",
                    "    rangeEnd: Math.max(locEnd(startNode), locEnd(endNode)),",
                    "  };",
                    "}",
                    "",
                    "module.exports = {",
                    "  calculateRange,",
                    "  findNodeAtOffset,",
                    "};"
                ]
            },
            "support.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const semver = {",
                    "  compare: require(\"semver/functions/compare\"),",
                    "  lt: require(\"semver/functions/lt\"),",
                    "  gte: require(\"semver/functions/gte\"),",
                    "};",
                    "const arrayify = require(\"../utils/arrayify.js\");",
                    "const currentVersion = require(\"../../package.json\").version;",
                    "const coreOptions = require(\"./core-options.js\").options;",
                    "",
                    "/**",
                    " * Strings in `plugins` and `pluginSearchDirs` are handled by a wrapped version",
                    " * of this function created by `withPlugins`. Don't pass them here directly.",
                    " * @param {object} param0",
                    " * @param {(string | object)[]=} param0.plugins Strings are resolved by `withPlugins`.",
                    " * @param {string[]=} param0.pluginSearchDirs Added by `withPlugins`.",
                    " * @param {boolean=} param0.showUnreleased",
                    " * @param {boolean=} param0.showDeprecated",
                    " * @param {boolean=} param0.showInternal",
                    " */",
                    "function getSupportInfo({",
                    "  plugins = [],",
                    "  showUnreleased = false,",
                    "  showDeprecated = false,",
                    "  showInternal = false,",
                    "} = {}) {",
                    "  // pre-release version is smaller than the normal version in semver,",
                    "  // we need to treat it as the normal one so as to test new features.",
                    "  const version = currentVersion.split(\"-\", 1)[0];",
                    "",
                    "  const languages = plugins",
                    "    .flatMap((plugin) => plugin.languages || [])",
                    "    .filter(filterSince);",
                    "",
                    "  const options = arrayify(",
                    "    Object.assign({}, ...plugins.map(({ options }) => options), coreOptions),",
                    "    \"name\"",
                    "  )",
                    "    .filter((option) => filterSince(option) && filterDeprecated(option))",
                    "    .sort((a, b) => (a.name === b.name ? 0 : a.name < b.name ? -1 : 1))",
                    "    .map(mapInternal)",
                    "    .map((option) => {",
                    "      option = { ...option };",
                    "",
                    "      if (Array.isArray(option.default)) {",
                    "        option.default =",
                    "          option.default.length === 1",
                    "            ? option.default[0].value",
                    "            : option.default",
                    "                .filter(filterSince)",
                    "                .sort((info1, info2) =>",
                    "                  semver.compare(info2.since, info1.since)",
                    "                )[0].value;",
                    "      }",
                    "",
                    "      if (Array.isArray(option.choices)) {",
                    "        option.choices = option.choices.filter(",
                    "          (option) => filterSince(option) && filterDeprecated(option)",
                    "        );",
                    "",
                    "        if (option.name === \"parser\") {",
                    "          collectParsersFromLanguages(option, languages, plugins);",
                    "        }",
                    "      }",
                    "",
                    "      const pluginDefaults = Object.fromEntries(",
                    "        plugins",
                    "          .filter(",
                    "            (plugin) =>",
                    "              plugin.defaultOptions &&",
                    "              plugin.defaultOptions[option.name] !== undefined",
                    "          )",
                    "          .map((plugin) => [plugin.name, plugin.defaultOptions[option.name]])",
                    "      );",
                    "",
                    "      return { ...option, pluginDefaults };",
                    "    });",
                    "",
                    "  return { languages, options };",
                    "",
                    "  function filterSince(object) {",
                    "    return (",
                    "      showUnreleased ||",
                    "      !(\"since\" in object) ||",
                    "      (object.since && semver.gte(version, object.since))",
                    "    );",
                    "  }",
                    "",
                    "  function filterDeprecated(object) {",
                    "    return (",
                    "      showDeprecated ||",
                    "      !(\"deprecated\" in object) ||",
                    "      (object.deprecated && semver.lt(version, object.deprecated))",
                    "    );",
                    "  }",
                    "",
                    "  function mapInternal(object) {",
                    "    if (showInternal) {",
                    "      return object;",
                    "    }",
                    "    const { cliName, cliCategory, cliDescription, ...newObject } = object;",
                    "    return newObject;",
                    "  }",
                    "}",
                    "",
                    "function collectParsersFromLanguages(option, languages, plugins) {",
                    "  const existingValues = new Set(option.choices.map((choice) => choice.value));",
                    "  for (const language of languages) {",
                    "    if (language.parsers) {",
                    "      for (const value of language.parsers) {",
                    "        if (!existingValues.has(value)) {",
                    "          existingValues.add(value);",
                    "          const plugin = plugins.find(",
                    "            (plugin) => plugin.parsers && plugin.parsers[value]",
                    "          );",
                    "          let description = language.name;",
                    "          if (plugin && plugin.name) {",
                    "            description += ` (plugin: ${plugin.name})`;",
                    "          }",
                    "          option.choices.push({ value, description });",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "module.exports = {",
                    "  getSupportInfo,",
                    "};"
                ]
            }
        },
        "utils": {
            "arrayify.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = (object, keyName) =>",
                    "  Object.entries(object).map(([key, value]) => ({",
                    "    [keyName]: key,",
                    "    ...value,",
                    "  }));"
                ]
            },
            "create-language.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "module.exports = function (linguistData, override) {",
                    "  const { languageId, ...rest } = linguistData;",
                    "  return {",
                    "    linguistLanguageId: languageId,",
                    "    ...rest,",
                    "    ...override(linguistData),",
                    "  };",
                    "};"
                ]
            },
            "get-file-content-or-null.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const fs = require(\"fs\");",
                    "const fsAsync = fs.promises;",
                    "",
                    "/**",
                    " * @param {string} filename",
                    " * @returns {Promise<null | string>}",
                    " */",
                    "async function getFileContentOrNull(filename) {",
                    "  try {",
                    "    return await fsAsync.readFile(filename, \"utf8\");",
                    "  } catch (error) {",
                    "    return handleError(filename, error);",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {string} filename",
                    " * @returns {null | string}",
                    " */",
                    "getFileContentOrNull.sync = function (filename) {",
                    "  try {",
                    "    return fs.readFileSync(filename, \"utf8\");",
                    "  } catch (error) {",
                    "    return handleError(filename, error);",
                    "  }",
                    "};",
                    "",
                    "function handleError(filename, error) {",
                    "  if (error && error.code === \"ENOENT\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  throw new Error(`Unable to read ${filename}: ${error.message}`);",
                    "}",
                    "",
                    "module.exports = getFileContentOrNull;"
                ]
            },
            "get-last.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const getLast = (arr) => arr[arr.length - 1];",
                    "",
                    "module.exports = getLast;"
                ]
            },
            "get-string-width.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const stringWidth = require(\"string-width\");",
                    "",
                    "const notAsciiRegex = /[^\\x20-\\x7F]/;",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @returns {number}",
                    " */",
                    "function getStringWidth(text) {",
                    "  if (!text) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`",
                    "  if (!notAsciiRegex.test(text)) {",
                    "    return text.length;",
                    "  }",
                    "",
                    "  return stringWidth(text);",
                    "}",
                    "",
                    "module.exports = getStringWidth;"
                ]
            },
            "is-non-empty-array.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "/**",
                    " * @param {any} object",
                    " * @returns {object is Array<any>}",
                    " */",
                    "function isNonEmptyArray(object) {",
                    "  return Array.isArray(object) && object.length > 0;",
                    "}",
                    "",
                    "module.exports = isNonEmptyArray;"
                ]
            },
            "line-column-to-index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "// Super inefficient, needs to be cached.",
                    "module.exports = function (lineColumn, text) {",
                    "  let index = 0;",
                    "  for (let i = 0; i < lineColumn.line - 1; ++i) {",
                    "    index = text.indexOf(\"\\n\", index) + 1;",
                    "  }",
                    "  return index + lineColumn.column;",
                    "};"
                ]
            },
            "load-json5.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const { parse } = require(\"json5\");",
                    "",
                    "module.exports = function (filePath, content) {",
                    "  try {",
                    "    return parse(content);",
                    "  } catch (error) {",
                    "    error.message = `JSON5 Error in ${filePath}:\\n${error.message}`;",
                    "    throw error;",
                    "  }",
                    "};"
                ]
            },
            "load-toml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const parse = require(\"@iarna/toml/parse-string\");",
                    "",
                    "module.exports = function (filePath, content) {",
                    "  try {",
                    "    return parse(content);",
                    "  } catch (error) {",
                    "    error.message = `TOML Error in ${filePath}:\\n${error.message}`;",
                    "    throw error;",
                    "  }",
                    "};"
                ]
            },
            "try-combinations.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "function tryCombinations(...combinations) {",
                    "  let firstError;",
                    "  for (const [index, fn] of combinations.entries()) {",
                    "    try {",
                    "      return { result: fn() };",
                    "    } catch (error) {",
                    "      if (index === 0) {",
                    "        firstError = error;",
                    "      }",
                    "    }",
                    "  }",
                    "  return { error: firstError };",
                    "}",
                    "",
                    "module.exports = tryCombinations;"
                ]
            },
            "front-matter": {
                "parse.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const frontMatterRegex = new RegExp(",
                        "  \"^(?<startDelimiter>-{3}|\\\\+{3})\" +",
                        "    // trailing spaces after delimiters are allowed",
                        "    \"(?<language>[^\\\\n]*)\" +",
                        "    \"\\\\n(?:|(?<value>.*?)\\\\n)\" +",
                        "    // In some markdown processors such as pandoc,",
                        "    // \"...\" can be used as the end delimiter for YAML front-matter.",
                        "    // Adding `\\.{3}` make the regex matches `+++\\n...`, but we'll exclude it later",
                        "    \"(?<endDelimiter>\\\\k<startDelimiter>|\\\\.{3})\" +",
                        "    \"[^\\\\S\\\\n]*(?:\\\\n|$)\",",
                        "  \"s\"",
                        ");",
                        "",
                        "function parse(text) {",
                        "  const match = text.match(frontMatterRegex);",
                        "  if (!match) {",
                        "    return { content: text };",
                        "  }",
                        "",
                        "  const { startDelimiter, language, value = \"\", endDelimiter } = match.groups;",
                        "",
                        "  let lang = language.trim() || \"yaml\";",
                        "  if (startDelimiter === \"+++\") {",
                        "    lang = \"toml\";",
                        "  }",
                        "",
                        "  // Only allow yaml to parse with a different end delimiter",
                        "  if (lang !== \"yaml\" && startDelimiter !== endDelimiter) {",
                        "    return { content: text };",
                        "  }",
                        "",
                        "  const [raw] = match;",
                        "  const frontMatter = {",
                        "    type: \"front-matter\",",
                        "    lang,",
                        "    value,",
                        "    startDelimiter,",
                        "    endDelimiter,",
                        "    raw: raw.replace(/\\n$/, \"\"),",
                        "  };",
                        "",
                        "  return {",
                        "    frontMatter,",
                        "    content: raw.replace(/[^\\n]/g, \" \") + text.slice(raw.length),",
                        "  };",
                        "}",
                        "",
                        "module.exports = parse;"
                    ]
                },
                "print.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const {",
                        "  builders: { hardline, markAsRoot },",
                        "} = require(\"../../document/index.js\");",
                        "",
                        "function print(node, textToDoc) {",
                        "  if (node.lang === \"yaml\") {",
                        "    const value = node.value.trim();",
                        "    const doc = value",
                        "      ? textToDoc(value, { parser: \"yaml\" }, { stripTrailingHardline: true })",
                        "      : \"\";",
                        "    return markAsRoot([",
                        "      node.startDelimiter,",
                        "      hardline,",
                        "      doc,",
                        "      doc ? hardline : \"\",",
                        "      node.endDelimiter,",
                        "    ]);",
                        "  }",
                        "}",
                        "",
                        "module.exports = print;"
                    ]
                }
            }
        }
    },
    "types": {
        "angular-html-parser": {
            "index.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "import \"angular-html-parser/lib/compiler/src/ml_parser/ast\";",
                    "import { HtmlTagDefinition } from \"angular-html-parser/lib/compiler/src/ml_parser/html_tags\";",
                    "",
                    "declare module \"angular-html-parser/lib/compiler/src/ml_parser/ast\" {",
                    "  interface Attribute {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "    // see restoreName in parser-html.js",
                    "    namespace?: string | null;",
                    "    hasExplicitNamespace?: boolean;",
                    "  }",
                    "",
                    "  interface CDATA {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface Comment {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface DocType {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface Element {",
                    "    tagDefinition: HtmlTagDefinition;",
                    "    // see restoreName in parser-html.js",
                    "    namespace?: string | null;",
                    "    hasExplicitNamespace?: boolean;",
                    "  }",
                    "",
                    "  interface Text {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "}"
                ]
            }
        },
        "espree": {
            "index.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "declare module \"espree\" {",
                    "  // https://github.com/eslint/espree#options",
                    "  export interface Options {",
                    "    range?: boolean;",
                    "    loc?: boolean;",
                    "    comment?: boolean;",
                    "    tokens?: boolean;",
                    "    ecmaVersion?:",
                    "      | 3",
                    "      | 5",
                    "      | 6",
                    "      | 7",
                    "      | 8",
                    "      | 9",
                    "      | 10",
                    "      | 11",
                    "      | 12",
                    "      | 2015",
                    "      | 2016",
                    "      | 2017",
                    "      | 2018",
                    "      | 2019",
                    "      | 2020",
                    "      | 2021",
                    "      | 2022",
                    "      | \"latest\";",
                    "    sourceType?: \"script\" | \"module\";",
                    "    ecmaFeatures?: {",
                    "      jsx?: boolean;",
                    "      globalReturn?: boolean;",
                    "      impliedStrict?: boolean;",
                    "    };",
                    "  }",
                    "  // https://github.com/eslint/espree#parse",
                    "  export function parse(code: string, options?: Options): any;",
                    "  // https://github.com/eslint/espree#tokenize",
                    "  export function tokenize(code: string, options?: Options): any;",
                    "}"
                ]
            }
        }
    },
    "website": {
        "README.md": {},
        "package.json": {},
        "sidebars.json": {},
        "siteConfig.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "// Docs: https://docusaurus.io/docs/en/site-config.html",
                "",
                "const path = require(\"path\");",
                "const fs = require(\"fs\");",
                "const { load: parseYaml } = require(\"js-yaml\");",
                "",
                "const PACKAGE = require(\"../package.json\");",
                "const GITHUB_URL = `https://github.com/${PACKAGE.repository}`;",
                "",
                "function loadYaml(fsPath) {",
                "  return parseYaml(fs.readFileSync(path.join(__dirname, fsPath), \"utf8\"));",
                "}",
                "",
                "const users = loadYaml(\"./data/users.yml\");",
                "const editors = loadYaml(\"./data/editors.yml\");",
                "const supportedLanguages = loadYaml(\"./data/languages.yml\");",
                "",
                "const siteConfig = {",
                "  title: \"Prettier\",",
                "  tagline: \"Opinionated Code Formatter\",",
                "  githubUrl: GITHUB_URL,",
                "  url: PACKAGE.homepage,",
                "  baseUrl: \"/\",",
                "  projectName: PACKAGE.name,",
                "  repo: PACKAGE.repository,",
                "  cname: \"prettier.io\",",
                "  users,",
                "  editors,",
                "  supportedLanguages,",
                "  tideliftUrl:",
                "    \"https://tidelift.com/subscription/pkg/npm-prettier?utm_source=npm-prettier&utm_medium=referral&utm_campaign=website\",",
                "  /* base url for editing docs, usage example: editUrl + 'en/doc1.md' */",
                "  editUrl: `${GITHUB_URL}/edit/main/docs/`,",
                "  headerLinks: [",
                "    { href: \"/playground/\", label: \"Playground\" },",
                "    { doc: \"index\", label: \"Docs\" },",
                "    { blog: true, label: \"Blog\" },",
                "    { search: true },",
                "    { href: \"https://opencollective.com/prettier\", label: \"Donate\" },",
                "    { href: GITHUB_URL, label: \"GitHub\" },",
                "  ],",
                "  /* path to images for header/footer */",
                "  headerIcon: \"icon.png\",",
                "  footerIcon: \"icon.png\",",
                "  favicon: \"icon.png\",",
                "  /* colors for website */",
                "  colors: {",
                "    primaryColor: \"#1A2B34\",",
                "    secondaryColor: \"#808080\",",
                "  },",
                "  highlight: {",
                "    theme: \"default\",",
                "    version: require(\"highlight.js/package.json\").version,",
                "  },",
                "  usePrism: [\"javascript\", \"jsx\", \"typescript\", \"ts\", \"js\", \"html\", \"css\"],",
                "  useEnglishUrl: true,",
                "  scripts: [\"https://buttons.github.io/buttons.js\"],",
                "  stylesheets: [",
                "    \"//unpkg.com/@sandhose/prettier-animated-logo@1.0.3/dist/wide.css\",",
                "  ],",
                "  algolia: {",
                "    apiKey: process.env.ALGOLIA_PRETTIER_API_KEY,",
                "    indexName: \"prettier\",",
                "  },",
                "  markdownPlugins: [",
                "    // ignore `<!-- prettier-ignore -->` before passing into Docusaurus to avoid mis-parsing (#3322)",
                "    (md) => {",
                "      md.block.ruler.before(",
                "        \"htmlblock\",",
                "        \"prettierignore\",",
                "        (state, startLine) => {",
                "          const pos = state.bMarks[startLine];",
                "          const max = state.eMarks[startLine];",
                "          if (/<!-- prettier-ignore -->/.test(state.src.slice(pos, max))) {",
                "            state.line += 1;",
                "            return true;",
                "          }",
                "          return false;",
                "        }",
                "      );",
                "    },",
                "  ],",
                "  separateCss: [\"static/separate-css\"],",
                "  gaTrackingId: \"UA-111350464-1\",",
                "  twitter: true,",
                "  twitterUsername: \"PrettierCode\",",
                "  twitterImage: \"icon.png\",",
                "  ogImage: \"icon.png\",",
                "  onPageNav: \"separate\",",
                "};",
                "",
                "module.exports = siteConfig;"
            ]
        },
        "versions.json": {},
        "webpack.config.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "module.exports = {",
                "  entry: {",
                "    playground: \"./playground/index.js\",",
                "  },",
                "  output: {",
                "    filename: \"[name].js\",",
                "    path: __dirname + \"/static/\",",
                "  },",
                "  module: {",
                "    rules: [",
                "      {",
                "        test: /\\.js$/,",
                "        exclude: /node_modules/,",
                "        loader: \"babel-loader\",",
                "        options: {",
                "          presets: [\"@babel/env\", \"@babel/react\"],",
                "        },",
                "      },",
                "    ],",
                "  },",
                "  externals: {",
                "    clipboard: \"ClipboardJS\",",
                "    codemirror: \"CodeMirror\",",
                "    react: \"React\",",
                "    \"react-dom\": \"ReactDOM\",",
                "  },",
                "};"
            ]
        },
        "yarn.lock": {},
        "blog": {
            "2017-04-13-1.0.0.md": {},
            "2017-04-20-1.2.0.md": {},
            "2017-05-03-1.3.0.md": {},
            "2017-06-03-1.4.0.md": {},
            "2017-06-28-1.5.0.md": {},
            "2017-08-29-1.6.0.md": {},
            "2017-09-15-1.7.0.md": {},
            "2017-11-07-1.8.0.md": {},
            "2017-12-05-1.9.0.md": {},
            "2018-01-10-1.10.0.md": {},
            "2018-02-26-1.11.0.md": {},
            "2018-04-09-plugin-php-0.1.md": {},
            "2018-04-11-1.12.0.md": {},
            "2018-05-27-1.13.0.md": {},
            "2018-07-29-1.14.0.md": {},
            "2018-11-07-1.15.0.md": {},
            "2019-01-20-1.16.0.md": {},
            "2019-04-12-1.17.0.md": {},
            "2019-06-06-1.18.0.md": {},
            "2019-11-09-1.19.0.md": {},
            "2020-03-21-2.0.0.md": {},
            "2020-08-24-2.1.0.md": {},
            "2020-11-20-2.2.0.md": {},
            "2020-12-11-plugin-ruby-1.0.md": {},
            "2021-05-09-2.3.0.md": {},
            "2021-09-09-2.4.0.md": {},
            "2021-11-25-2.5.0.md": {},
            "2022-01-06-prettier-begins-paying-maintainers.md": {}
        },
        "core": {
            "Footer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const React = require(\"react\");",
                    "const PropTypes = require(\"prop-types\");",
                    "",
                    "const GithubButton = (props) => (",
                    "  <a",
                    "    className=\"github-button\"",
                    "    href={props.config.githubUrl}",
                    "    data-icon=\"octicon-star\"",
                    "    data-show-count=\"true\"",
                    "    aria-label=\"Star this project on GitHub\"",
                    "  >",
                    "    Star",
                    "  </a>",
                    ");",
                    "",
                    "GithubButton.propTypes = {",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "class Footer extends React.Component {",
                    "  url(path) {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}docs/${language}${path}`;",
                    "  }",
                    "",
                    "  usersUrl() {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}${language}/users`;",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <footer className=\"footerSection nav-footer\" id=\"footer\">",
                    "        <section className=\"sitemap\">",
                    "          <a href={this.props.config.baseUrl} className=\"nav-home\">",
                    "            <img",
                    "              src={this.props.config.baseUrl + this.props.config.footerIcon}",
                    "              alt={this.props.config.title}",
                    "            />",
                    "          </a>",
                    "          <div>",
                    "            <h5>Docs</h5>",
                    "            <a href={this.url(\"/index.html\")}>About</a>",
                    "            <a href={this.url(\"/install.html\")}>Usage</a>",
                    "            <br />",
                    "            <a href=\"https://www.netlify.com\">",
                    "              <img src=\"https://www.netlify.com/img/global/badges/netlify-color-accent.svg\" />",
                    "            </a>",
                    "          </div>",
                    "          <div>",
                    "            <h5>Community</h5>",
                    "            <a href={this.usersUrl()}>User Showcase</a>",
                    "            <a",
                    "              href=\"http://stackoverflow.com/questions/tagged/prettier\"",
                    "              target=\"_blank\"",
                    "              rel=\"noopener noreferrer\"",
                    "            >",
                    "              Stack Overflow",
                    "            </a>",
                    "            <a href=\"https://gitter.im/jlongster/prettier\">Chat on Gitter</a>",
                    "            <a href=\"https://twitter.com/PrettierCode\">",
                    "              @PrettierCode on Twitter",
                    "            </a>",
                    "            <object",
                    "              type=\"image/svg+xml\"",
                    "              data=\"https://img.shields.io/twitter/follow/prettiercode.svg?label=Follow+Prettier&style=social\"",
                    "            >",
                    "              <a href=\"https://twitter.com/intent/follow?screen_name=prettiercode\">",
                    "                <img",
                    "                  alt=\"Follow Prettier on Twitter\"",
                    "                  src=\"https://img.shields.io/twitter/follow/prettiercode.png?label=Follow+Prettier&style=social\"",
                    "                />",
                    "              </a>",
                    "            </object>",
                    "          </div>",
                    "          <div>",
                    "            <h5>More</h5>",
                    "            <a href={this.props.config.baseUrl + \"blog\"}>Blog</a>",
                    "            <a href={this.props.config.githubUrl}>GitHub</a>",
                    "            <a href={this.props.config.githubUrl + \"/issues\"}>Issues</a>",
                    "            <GithubButton config={this.props.config} />",
                    "          </div>",
                    "        </section>",
                    "      </footer>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "Footer.propTypes = {",
                    "  language: PropTypes.string,",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "module.exports = Footer;"
                ]
            }
        },
        "data": {
            "editors.yml": {},
            "languages.yml": {},
            "users.yml": {}
        },
        "pages": {
            "googlefe164a33bda4034b.html": {},
            "playground-redirect.html": {},
            "en": {
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const React = require(\"react\");",
                        "const PropTypes = require(\"prop-types\");",
                        "const AnimatedLogo = require(\"@sandhose/prettier-animated-logo\");",
                        "const { MarkdownBlock, Container } = require(\"../../core/CompLibrary.js\");",
                        "",
                        "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                        "",
                        "const ButtonGroup = (props) => (",
                        "  <div className=\"buttonGroup buttonWrapper\">{props.children}</div>",
                        ");",
                        "",
                        "ButtonGroup.propTypes = {",
                        "  children: PropTypes.node,",
                        "};",
                        "",
                        "class Button extends React.Component {",
                        "  render() {",
                        "    return (",
                        "      <div className=\"pluginWrapper buttonWrapper\">",
                        "        <a className=\"button\" href={this.props.href} target={this.props.target}>",
                        "          {this.props.children}",
                        "        </a>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Button.defaultProps = {",
                        "  target: \"_self\",",
                        "};",
                        "",
                        "Button.propTypes = {",
                        "  href: PropTypes.string,",
                        "  target: PropTypes.string,",
                        "  children: PropTypes.any,",
                        "};",
                        "",
                        "function Tidelift() {",
                        "  return (",
                        "    <a className=\"tidelift\" href={siteConfig.tideliftUrl}>",
                        "      PRETTIER FOR ENTERPRISE",
                        "    </a>",
                        "  );",
                        "}",
                        "",
                        "const HomeSplash = (props) => (",
                        "  <div className=\"homeContainer\">",
                        "    <Tidelift />",
                        "    <div className=\"homeSplashFade\">",
                        "      <div className=\"wrapper homeWrapper\">",
                        "        <div className=\"animatedLogoWrapper\">",
                        "          <AnimatedLogo version=\"wide\" />",
                        "        </div>",
                        "        <div className=\"inner\">",
                        "          <div className=\"section promoSection\">",
                        "            <div className=\"promoRow\">",
                        "              <div className=\"pluginRowBlock\">",
                        "                <Button href=\"/playground/\">Try It Online</Button>&nbsp;",
                        "                <Button href={\"/docs/\" + props.language + \"/install.html\"}>",
                        "                  Install Prettier",
                        "                </Button>",
                        "              </div>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </div>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "HomeSplash.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const TldrSection = ({ language }) => (",
                        "  <div className=\"tldrSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-evenly\",",
                        "        }}",
                        "      >",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>What is Prettier?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>An opinionated code formatter</li>",
                        "            <li>Supports many languages</li>",
                        "            <li>Integrates with most editors</li>",
                        "            <li>Has few options</li>",
                        "          </ul>",
                        "        </div>",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>Why?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>You press save and code is formatted</li>",
                        "            <li>No need to discuss style in code review</li>",
                        "            <li>Saves you time and energy</li>",
                        "            <li>",
                        "              <a href={\"/docs/\" + language + \"/why-prettier.html\"}>And more</a>",
                        "            </li>",
                        "          </ul>",
                        "        </div>",
                        "      </div>",
                        "    </Container>",
                        "  </div>",
                        ");",
                        "",
                        "TldrSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const Language = ({ name, nameLink, showName, image, variants }) => (",
                        "  <div",
                        "    className=\"languageCategory\"",
                        "    style={{",
                        "      display: \"flex\",",
                        "      alignItems: \"flex-start\",",
                        "      paddingBottom: \"1em\",",
                        "    }}",
                        "  >",
                        "    <img src={image} style={{ width: \"50px\", padding: \"0 20px\" }} />",
                        "    <ul>",
                        "      {showName && (",
                        "        <li className=\"accented\">",
                        "          {nameLink ? <a href={nameLink}>{name}</a> : name}",
                        "        </li>",
                        "      )}",
                        "      {variants.map((variant) => (",
                        "        <li key={variant}>",
                        "          <MarkdownBlock>{variant}</MarkdownBlock>",
                        "        </li>",
                        "      ))}",
                        "    </ul>",
                        "  </div>",
                        ");",
                        "",
                        "Language.propTypes = {",
                        "  name: PropTypes.string,",
                        "  nameLink: PropTypes.string,",
                        "  showName: PropTypes.bool,",
                        "  image: PropTypes.string,",
                        "  variants: PropTypes.array,",
                        "};",
                        "",
                        "const LanguagesSection = () => {",
                        "  const languageChunks = siteConfig.supportedLanguages.reduce(",
                        "    (acc, language) => {",
                        "      const last = acc[acc.length - 1];",
                        "      if (",
                        "        last &&",
                        "        last.length < 2 &&",
                        "        last.reduce((sum, lang) => sum + lang.variants.length, 0) +",
                        "          language.variants.length <",
                        "          9",
                        "      ) {",
                        "        last.push(language);",
                        "      } else {",
                        "        acc.push([language]);",
                        "      }",
                        "      return acc;",
                        "    },",
                        "    []",
                        "  );",
                        "",
                        "  return (",
                        "    <div",
                        "      className=\"languagesSection productShowcaseSection\"",
                        "      style={{ textAlign: \"center\" }}",
                        "    >",
                        "      <Container>",
                        "        <h2>Works with the Tools You Use</h2>",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {languageChunks.map((languageChunk, index) => (",
                        "            <div key={index} style={{ flex: \"1 1 auto\" }}>",
                        "              {languageChunk.map((language) => (",
                        "                <Language key={language.name} {...language} />",
                        "              ))}",
                        "            </div>",
                        "          ))}",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "const Editor = ({ content = \"\", image, name }) => (",
                        "  <div className=\"editor\">",
                        "    <img className=\"editorImage\" src={image} />",
                        "    <div className=\"editorInfo\">",
                        "      <h3 className=\"editorName\">{name}</h3>",
                        "      <MarkdownBlock>{content.replace(/\\n/g, \"  \\n\")}</MarkdownBlock>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "Editor.propTypes = {",
                        "  content: PropTypes.string,",
                        "  image: PropTypes.string.isRequired,",
                        "  name: PropTypes.string.isRequired,",
                        "};",
                        "",
                        "const EditorSupportSection = () => (",
                        "  <div className=\"editorSupportSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <h2>Editor Support</h2>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-around\",",
                        "        }}",
                        "      >",
                        "        {siteConfig.editors.map((editor) => (",
                        "          <Editor key={editor.name} {...editor} />",
                        "        ))}",
                        "      </div>",
                        "    </Container>",
                        "",
                        "    <div style={{ float: \"right\" }}>",
                        "      <span>Got more? </span>",
                        "      <a",
                        "        href={`${siteConfig.githubUrl}/edit/main/website/data/editors.yml`}",
                        "        className=\"button\"",
                        "      >",
                        "        Send a PR",
                        "      </a>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "const UsersSection = ({ language }) => {",
                        "  const showcase = siteConfig.users",
                        "    .filter((user) => user.pinned)",
                        "    .map((user, i) => (",
                        "      <a key={i} className=\"growOnHover alignCenter\" href={user.infoLink}>",
                        "        <img className=\"user\" src={user.greyImage} title={user.caption} />",
                        "      </a>",
                        "    ));",
                        "",
                        "  return (",
                        "    <div className=\"usersSection productShowcaseSection\">",
                        "      <Container>",
                        "        <h2>Used By People You Rely On</h2>",
                        "        <div style={{ textAlign: \"right\" }} />",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {showcase}",
                        "        </div>",
                        "        <div className=\"more-users\">",
                        "          <a",
                        "            className=\"button\"",
                        "            href={siteConfig.baseUrl + language + \"/users/\"}",
                        "            target=\"_self\"",
                        "            style={{ marginRight: \"10px\" }}",
                        "          >",
                        "            See Others",
                        "          </a>",
                        "        </div>",
                        "",
                        "        <h2 className=\"ecosystemSubHeader\">Established in the Ecosystem</h2>",
                        "        <div",
                        "          className=\"ecosystemSubSection\"",
                        "          style={{",
                        "            display: \"flex\",",
                        "            justifyContent: \"space-around\",",
                        "            flexFlow: \"row wrap\",",
                        "          }}",
                        "        >",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://2020.stateofjs.com/en-US/other-tools/utilities\"",
                        "              className=\"growOnHover\"",
                        "            >",
                        "              <img",
                        "                src=\"/images/state_of_js_grey.svg\"",
                        "                style={{ height: \"100px\" }}",
                        "              />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                Regularly used by more than <strong>70%</strong> of respondents",
                        "                to State of JS 2020",
                        "              </p>",
                        "              <Button href=\"https://2020.stateofjs.com/en-US/other-tools/utilities\">",
                        "                Go to Survey Results",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://github.com/prettier/prettier\"",
                        "              className=\"growOnHover\"",
                        "            >",
                        "              <img src=\"/images/github_grey.svg\" style={{ height: \"100px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than{\" \"}",
                        "                <strong data-placeholder=\"dependent-github\">3.5 million</strong>{\" \"}",
                        "                dependent repositories on GitHub",
                        "              </p>",
                        "              <Button href=\"https://github.com/prettier/prettier/network/dependents\">",
                        "                Check Them Out",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://npmjs.com/package/prettier\"",
                        "              className=\"growOnHover\"",
                        "            >",
                        "              <img src=\"/images/npm_grey.svg\" style={{ height: \"100px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than <strong data-placeholder=\"dependent-npm\">10k</strong>{\" \"}",
                        "                dependent packages on npm",
                        "              </p>",
                        "              <Button href=\"https://www.npmjs.com/browse/depended/prettier\">",
                        "                See them all",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "UsersSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "class Index extends React.Component {",
                        "  render() {",
                        "    const language = this.props.language || \"en\";",
                        "",
                        "    return (",
                        "      <div>",
                        "        <script src=\"landing.js\" />",
                        "        <HomeSplash language={language} />",
                        "        <div className=\"mainContainer landingContainer\">",
                        "          <TldrSection language={language} />",
                        "          <LanguagesSection />",
                        "          <EditorSupportSection />",
                        "          <UsersSection language={language} />",
                        "        </div>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Index.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "module.exports = Index;"
                    ]
                },
                "versions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * Copyright (c) 2017-present, Facebook, Inc.",
                        " *",
                        " * This source code is licensed under the MIT license found in the",
                        " * LICENSE file in the root directory of this source tree.",
                        " */",
                        "",
                        "const React = require(\"react\");",
                        "const { Container } = require(\"../../core/CompLibrary.js\");",
                        "",
                        "const CWD = process.cwd();",
                        "",
                        "const versions = require(`${CWD}/versions.json`);",
                        "",
                        "const rootPackageJson = require(`${CWD}/../package.json`);",
                        "const defaultBranchVersion = rootPackageJson.version;",
                        "const isDefaultBranchDevVersion = defaultBranchVersion.endsWith(\"-dev\");",
                        "const devVersion = isDefaultBranchDevVersion ? defaultBranchVersion : null;",
                        "const latestVersion = isDefaultBranchDevVersion",
                        "  ? rootPackageJson.devDependencies.prettier",
                        "  : defaultBranchVersion;",
                        "const [latestDocsVersion, ...pastDocsVersions] = versions;",
                        "",
                        "function Versions(props) {",
                        "  const { config: siteConfig } = props;",
                        "  return (",
                        "    <div className=\"docMainWrapper wrapper\">",
                        "      <Container className=\"mainContainer versionsContainer\">",
                        "        <div className=\"post\">",
                        "          <header className=\"postHeader\">",
                        "            <h1>{siteConfig.title} Versions</h1>",
                        "          </header>",
                        "          <table className=\"versions\">",
                        "            <tbody>",
                        "              <tr>",
                        "                <th>Version</th>",
                        "                <th>Install with</th>",
                        "                <th>Documentation</th>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{latestVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/index.html`}>",
                        "                    {latestDocsVersion}",
                        "                  </a>{\" \"}",
                        "                  (latest)",
                        "                </td>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{devVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier/prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/next/index.html`}>",
                        "                    next",
                        "                  </a>{\" \"}",
                        "                  (main)",
                        "                </td>",
                        "              </tr>",
                        "              {pastDocsVersions.length > 0 &&",
                        "                pastDocsVersions.map((pastDocsVersion, index) => {",
                        "                  const pastMajorVersion = pastDocsVersion.replace(/^v/, \"\");",
                        "                  return (",
                        "                    <tr key={index}>",
                        "                      <td>{pastMajorVersion}.x</td>",
                        "                      <td>",
                        "                        <code>",
                        "                          npm install prettier@",
                        "                          {pastMajorVersion}",
                        "                        </code>",
                        "                      </td>",
                        "                      <td>",
                        "                        <a",
                        "                          href={`${siteConfig.baseUrl}docs/en/${pastDocsVersion}/index.html`}",
                        "                        >",
                        "                          {pastDocsVersion}",
                        "                        </a>",
                        "                      </td>",
                        "                    </tr>",
                        "                  );",
                        "                })}",
                        "            </tbody>",
                        "          </table>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "module.exports = Versions;"
                    ]
                },
                "help": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container, GridBlock } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "class Help extends React.Component {",
                            "  render() {",
                            "    const supportLinks = [",
                            "      {",
                            "        content:",
                            "          \"Learn more using the [documentation on this site.](/docs/en/why-prettier.html)\\n\",",
                            "        title: \"Browse Docs\",",
                            "      },",
                            "      {",
                            "        content: \"Ask questions about the documentation and project\\n\",",
                            "        title: \"Join the community\",",
                            "      },",
                            "      {",
                            "        content: \"Find out what's new with this project\\n\",",
                            "        title: \"Stay up to date\",",
                            "      },",
                            "    ];",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"docMainWrapper wrapper\">",
                            "          <Container className=\"mainContainer documentContainer postContainer\">",
                            "            <div className=\"post\">",
                            "              <header className=\"postHeader\">",
                            "                <h2>Need help?</h2>",
                            "              </header>",
                            "              <p>This project is maintained by a dedicated group of people;</p>",
                            "              <GridBlock contents={supportLinks} layout=\"threeColumn\" />",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Help.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "module.exports = Help;"
                        ]
                    }
                },
                "users": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                            "",
                            "class Users extends React.Component {",
                            "  render() {",
                            "    const showcase = siteConfig.users.map((user, i) => (",
                            "      <a key={i} href={user.infoLink}>",
                            "        <img src={user.image} title={user.caption} />",
                            "      </a>",
                            "    ));",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"mainContainer\">",
                            "          <Container padding={[\"bottom\", \"top\"]}>",
                            "            <div className=\"showcaseSection\">",
                            "              <div className=\"prose\">",
                            "                <h1>Who\u2019s Using This?</h1>",
                            "              </div>",
                            "              <blockquote",
                            "                style={{",
                            "                  display: \"flex\",",
                            "                  alignItems: \"center\",",
                            "                  fontSize: \"125%\",",
                            "                }}",
                            "              >",
                            "                <div className=\"prose\">",
                            "                  Prettier is regularly used by more than <strong>70%</strong>",
                            "                  &nbsp;of the respondents to the \u201cUtilities\u201d section of",
                            "                  the&nbsp;",
                            "                  <a href=\"https://2020.stateofjs.com/en-US/other-tools/utilities\">",
                            "                    State&nbsp;of&nbsp;JS&nbsp;2020",
                            "                  </a>{\" \"}",
                            "                  survey (14880&nbsp;developers out of 20974).",
                            "                </div>",
                            "                <a href=\"https://2020.stateofjs.com\">",
                            "                  <img",
                            "                    title=\"State of JS 2020\"",
                            "                    src=\"/images/state_of_js.svg\"",
                            "                    width=\"180\"",
                            "                    style={{ background: \"#222429\", borderRadius: 5 }}",
                            "                  />",
                            "                </a>",
                            "              </blockquote>",
                            "              <div className=\"logos\">{showcase}</div>",
                            "              <div className=\"prose\">",
                            "                ...and{\" \"}",
                            "                <a href=\"https://www.npmjs.com/browse/depended/prettier\">",
                            "                  many more projects",
                            "                </a>",
                            "              </div>",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Users.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "Users.title = \"Who's using Prettier?\";",
                            "",
                            "module.exports = Users;"
                        ]
                    }
                }
            },
            "playground": {
                "index.html": {}
            }
        },
        "playground": {
            "BottomBar.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"bottom-bar\");",
                    "",
                    "export default function BottomBar({ left, right }) {",
                    "  return ReactDOM.createPortal(",
                    "    <React.Fragment>",
                    "      <div className=\"bottom-bar-buttons\">{left}</div>",
                    "      <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">{right}</div>",
                    "    </React.Fragment>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "EditorState.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { stateToggler, shallowEqual } from \"./helpers.js\";",
                    "import * as storage from \"./storage.js\";",
                    "",
                    "export default class EditorState extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = {",
                    "      showSidebar: window.innerWidth > window.innerHeight,",
                    "      showAst: false,",
                    "      showDoc: false,",
                    "      showComments: false,",
                    "      showSecondFormat: false,",
                    "      showInput: true,",
                    "      showOutput: true,",
                    "      toggleSidebar: () => this.setState(stateToggler(\"showSidebar\")),",
                    "      toggleAst: () => this.setState(stateToggler(\"showAst\")),",
                    "      toggleDoc: () => this.setState(stateToggler(\"showDoc\")),",
                    "      toggleComments: () => this.setState(stateToggler(\"showComments\")),",
                    "      toggleSecondFormat: () => this.setState(stateToggler(\"showSecondFormat\")),",
                    "      toggleInput: () => this.setState(stateToggler(\"showInput\")),",
                    "      toggleOutput: () => this.setState(stateToggler(\"showOutput\")),",
                    "      ...storage.get(\"editor_state\"),",
                    "    };",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    if (!shallowEqual(this.state, prevState)) {",
                    "      storage.set(\"editor_state\", this.state);",
                    "    }",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "Playground.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { Button, ClipboardButton } from \"./buttons.js\";",
                    "import EditorState from \"./EditorState.js\";",
                    "import { DebugPanel, InputPanel, OutputPanel } from \"./panels.js\";",
                    "import PrettierFormat from \"./PrettierFormat.js\";",
                    "import { shallowEqual } from \"./helpers.js\";",
                    "import * as urlHash from \"./urlHash.js\";",
                    "import formatMarkdown from \"./markdown.js\";",
                    "import * as util from \"./util.js\";",
                    "import getCodeSample from \"./codeSamples.js\";",
                    "",
                    "import { Sidebar, SidebarCategory } from \"./sidebar/components.js\";",
                    "import SidebarOptions from \"./sidebar/SidebarOptions.js\";",
                    "import Option from \"./sidebar/options.js\";",
                    "import { Checkbox } from \"./sidebar/inputs.js\";",
                    "",
                    "const CATEGORIES_ORDER = [",
                    "  \"Global\",",
                    "  \"Common\",",
                    "  \"JavaScript\",",
                    "  \"Markdown\",",
                    "  \"HTML\",",
                    "  \"Special\",",
                    "];",
                    "const ISSUES_URL = \"https://github.com/prettier/prettier/issues/new?body=\";",
                    "const MAX_LENGTH = 8000 - ISSUES_URL.length; // it seems that GitHub limit is 8195",
                    "const COPY_MESSAGE =",
                    "  \"<!-- The issue body has been saved to the clipboard. Please paste it after this line! \ud83d\udc47 -->\\n\";",
                    "",
                    "const ENABLED_OPTIONS = [",
                    "  \"parser\",",
                    "  \"printWidth\",",
                    "  \"tabWidth\",",
                    "  \"useTabs\",",
                    "  \"semi\",",
                    "  \"singleQuote\",",
                    "  \"bracketSpacing\",",
                    "  \"jsxSingleQuote\",",
                    "  \"quoteProps\",",
                    "  \"arrowParens\",",
                    "  \"trailingComma\",",
                    "  \"proseWrap\",",
                    "  \"htmlWhitespaceSensitivity\",",
                    "  \"insertPragma\",",
                    "  \"requirePragma\",",
                    "  \"vueIndentScriptAndStyle\",",
                    "  \"embeddedLanguageFormatting\",",
                    "  \"bracketSameLine\",",
                    "];",
                    "",
                    "class Playground extends React.Component {",
                    "  constructor(props) {",
                    "    super();",
                    "",
                    "    const original = urlHash.read();",
                    "",
                    "    const defaultOptions = util.getDefaults(",
                    "      props.availableOptions,",
                    "      ENABLED_OPTIONS",
                    "    );",
                    "",
                    "    const options = Object.assign(defaultOptions, original.options);",
                    "",
                    "    // backwards support for old parser `babylon`",
                    "    if (options.parser === \"babylon\") {",
                    "      options.parser = \"babel\";",
                    "    }",
                    "",
                    "    const content = original.content || getCodeSample(options.parser);",
                    "    const selection = {};",
                    "",
                    "    this.state = { content, options, selection };",
                    "",
                    "    this.handleOptionValueChange = this.handleOptionValueChange.bind(this);",
                    "",
                    "    this.setContent = (content) => this.setState({ content });",
                    "    this.clearContent = this.setContent.bind(this, \"\");",
                    "    this.resetOptions = () => this.setState({ options: defaultOptions });",
                    "    this.setSelection = (selection) => this.setState({ selection });",
                    "    this.setSelectionAsRange = () => {",
                    "      const { selection, content, options } = this.state;",
                    "      const { head, anchor } = selection;",
                    "      const range = [head, anchor].map(",
                    "        ({ ch, line }) =>",
                    "          content.split(\"\\n\").slice(0, line).join(\"\\n\").length +",
                    "          ch +",
                    "          (line ? 1 : 0)",
                    "      );",
                    "      const [rangeStart, rangeEnd] = range.sort((a, b) => a - b);",
                    "      const updatedOptions = { ...options, rangeStart, rangeEnd };",
                    "      if (rangeStart === rangeEnd) {",
                    "        delete updatedOptions.rangeStart;",
                    "        delete updatedOptions.rangeEnd;",
                    "      }",
                    "      this.setState({ options: updatedOptions });",
                    "    };",
                    "",
                    "    this.enabledOptions = orderOptions(props.availableOptions, ENABLED_OPTIONS);",
                    "    this.rangeStartOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeStart\"",
                    "    );",
                    "    this.rangeEndOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeEnd\"",
                    "    );",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    const { content, options } = this.state;",
                    "    if (",
                    "      !shallowEqual(prevState.options, this.state.options) ||",
                    "      prevState.content !== content",
                    "    ) {",
                    "      urlHash.replace({ content, options });",
                    "    }",
                    "  }",
                    "",
                    "  handleOptionValueChange(option, value) {",
                    "    this.setState((state) => {",
                    "      const options = { ...state.options };",
                    "",
                    "      if (option.type === \"int\" && Number.isNaN(value)) {",
                    "        delete options[option.name];",
                    "      } else {",
                    "        options[option.name] = value;",
                    "      }",
                    "",
                    "      const content =",
                    "        state.content === \"\" ||",
                    "        state.content === getCodeSample(state.options.parser)",
                    "          ? getCodeSample(options.parser)",
                    "          : state.content;",
                    "",
                    "      return { options, content };",
                    "    });",
                    "  }",
                    "",
                    "  getMarkdown({ formatted, reformatted, full, doc }) {",
                    "    const { content, options } = this.state;",
                    "    const { availableOptions, version } = this.props;",
                    "    const orderedOptions = orderOptions(availableOptions, [",
                    "      ...ENABLED_OPTIONS,",
                    "      \"rangeStart\",",
                    "      \"rangeEnd\",",
                    "    ]);",
                    "    const cliOptions = util.buildCliArgs(orderedOptions, options);",
                    "",
                    "    return formatMarkdown({",
                    "      input: content,",
                    "      output: formatted,",
                    "      output2: reformatted,",
                    "      doc,",
                    "      version,",
                    "      url: window.location.href,",
                    "      options,",
                    "      cliOptions,",
                    "      full,",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { worker, version } = this.props;",
                    "    const { content, options } = this.state;",
                    "",
                    "    // TODO: remove this when v2.3.0 is released",
                    "    const [major, minor] = version.split(\".\", 2).map(Number);",
                    "    const showShowComments =",
                    "      Number.isNaN(major) || (major === 2 && minor >= 3) || major > 2;",
                    "",
                    "    return (",
                    "      <EditorState>",
                    "        {(editorState) => (",
                    "          <PrettierFormat",
                    "            worker={worker}",
                    "            code={content}",
                    "            options={options}",
                    "            debugAst={editorState.showAst}",
                    "            debugDoc={editorState.showDoc}",
                    "            debugComments={showShowComments && editorState.showComments}",
                    "            reformat={editorState.showSecondFormat}",
                    "          >",
                    "            {({ formatted, debug }) => {",
                    "              const fullReport = this.getMarkdown({",
                    "                formatted,",
                    "                reformatted: debug.reformatted,",
                    "                full: true,",
                    "              });",
                    "              const showFullReport =",
                    "                encodeURIComponent(fullReport).length < MAX_LENGTH;",
                    "              return (",
                    "                <React.Fragment>",
                    "                  <div className=\"editors-container\">",
                    "                    <Sidebar visible={editorState.showSidebar}>",
                    "                      <SidebarOptions",
                    "                        categories={CATEGORIES_ORDER}",
                    "                        availableOptions={this.enabledOptions}",
                    "                        optionValues={options}",
                    "                        onOptionValueChange={this.handleOptionValueChange}",
                    "                      />",
                    "                      <SidebarCategory title=\"Range\">",
                    "                        <label>",
                    "                          The selected range will be highlighted in yellow in",
                    "                          the input editor",
                    "                        </label>",
                    "                        <Option",
                    "                          option={this.rangeStartOption}",
                    "                          value={",
                    "                            typeof options.rangeStart === \"number\"",
                    "                              ? options.rangeStart",
                    "                              : \"\"",
                    "                          }",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "                        <Option",
                    "                          option={this.rangeEndOption}",
                    "                          value={",
                    "                            typeof options.rangeEnd === \"number\"",
                    "                              ? options.rangeEnd",
                    "                              : \"\"",
                    "                          }",
                    "                          overrideMax={content.length}",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "",
                    "                        <Button onClick={this.setSelectionAsRange}>",
                    "                          Set selected text as range",
                    "                        </Button>",
                    "                      </SidebarCategory>",
                    "                      <SidebarCategory title=\"Debug\">",
                    "                        <Checkbox",
                    "                          label=\"show input\"",
                    "                          checked={editorState.showInput}",
                    "                          onChange={editorState.toggleInput}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show AST\"",
                    "                          checked={editorState.showAst}",
                    "                          onChange={editorState.toggleAst}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show doc\"",
                    "                          checked={editorState.showDoc}",
                    "                          onChange={editorState.toggleDoc}",
                    "                        />",
                    "                        {showShowComments && (",
                    "                          <Checkbox",
                    "                            label=\"show comments\"",
                    "                            checked={editorState.showComments}",
                    "                            onChange={editorState.toggleComments}",
                    "                          />",
                    "                        )}",
                    "                        <Checkbox",
                    "                          label=\"show output\"",
                    "                          checked={editorState.showOutput}",
                    "                          onChange={editorState.toggleOutput}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show second format\"",
                    "                          checked={editorState.showSecondFormat}",
                    "                          onChange={editorState.toggleSecondFormat}",
                    "                        />",
                    "                        {editorState.showDoc && debug.doc && (",
                    "                          <ClipboardButton",
                    "                            copy={() => this.getMarkdown({ doc: debug.doc })}",
                    "                          >",
                    "                            Copy doc",
                    "                          </ClipboardButton>",
                    "                        )}",
                    "                      </SidebarCategory>",
                    "                      <div className=\"sub-options\">",
                    "                        <Button onClick={this.resetOptions}>",
                    "                          Reset to defaults",
                    "                        </Button>",
                    "                      </div>",
                    "                    </Sidebar>",
                    "                    <div className=\"editors\">",
                    "                      {editorState.showInput ? (",
                    "                        <InputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          ruler={options.printWidth}",
                    "                          value={content}",
                    "                          codeSample={getCodeSample(options.parser)}",
                    "                          overlayStart={options.rangeStart}",
                    "                          overlayEnd={options.rangeEnd}",
                    "                          onChange={this.setContent}",
                    "                          onSelectionChange={this.setSelection}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showAst ? (",
                    "                        <DebugPanel",
                    "                          value={debug.ast || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showDoc ? (",
                    "                        <DebugPanel value={debug.doc || \"\"} />",
                    "                      ) : null}",
                    "                      {showShowComments && editorState.showComments ? (",
                    "                        <DebugPanel",
                    "                          value={debug.comments || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showOutput ? (",
                    "                        <OutputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          value={formatted}",
                    "                          ruler={options.printWidth}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showSecondFormat ? (",
                    "                        <OutputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          value={getSecondFormat(formatted, debug.reformatted)}",
                    "                          ruler={options.printWidth}",
                    "                        />",
                    "                      ) : null}",
                    "                    </div>",
                    "                  </div>",
                    "                  <div className=\"bottom-bar\">",
                    "                    <div className=\"bottom-bar-buttons\">",
                    "                      <Button onClick={editorState.toggleSidebar}>",
                    "                        {editorState.showSidebar ? \"Hide\" : \"Show\"} options",
                    "                      </Button>",
                    "                      <Button onClick={this.clearContent}>Clear</Button>",
                    "                      <ClipboardButton",
                    "                        copy={JSON.stringify(",
                    "                          // Remove `parser` since people usually paste this",
                    "                          // into their .prettierrc and specifying a top-level",
                    "                          // parser there is an anti-pattern. Note:",
                    "                          // `JSON.stringify` omits keys whose values are",
                    "                          // `undefined`.",
                    "                          { ...options, parser: undefined },",
                    "                          null,",
                    "                          2",
                    "                        )}",
                    "                      >",
                    "                        Copy config JSON",
                    "                      </ClipboardButton>",
                    "                    </div>",
                    "                    <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">",
                    "                      <ClipboardButton copy={window.location.href}>",
                    "                        Copy link",
                    "                      </ClipboardButton>",
                    "                      <ClipboardButton",
                    "                        copy={() =>",
                    "                          this.getMarkdown({",
                    "                            formatted,",
                    "                            reformatted: debug.reformatted,",
                    "                          })",
                    "                        }",
                    "                      >",
                    "                        Copy markdown",
                    "                      </ClipboardButton>",
                    "                      <a",
                    "                        href={getReportLink(",
                    "                          showFullReport ? fullReport : COPY_MESSAGE",
                    "                        )}",
                    "                        target=\"_blank\"",
                    "                        rel=\"noopener noreferrer\"",
                    "                      >",
                    "                        <ClipboardButton",
                    "                          copy={() => (showFullReport ? \"\" : fullReport)}",
                    "                        >",
                    "                          Report issue",
                    "                        </ClipboardButton>",
                    "                      </a>",
                    "                    </div>",
                    "                  </div>",
                    "                </React.Fragment>",
                    "              );",
                    "            }}",
                    "          </PrettierFormat>",
                    "        )}",
                    "      </EditorState>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function orderOptions(availableOptions, order) {",
                    "  const optionsByName = {};",
                    "  for (const option of availableOptions) {",
                    "    optionsByName[option.name] = option;",
                    "  }",
                    "",
                    "  return order.map((name) => optionsByName[name]);",
                    "}",
                    "",
                    "function getReportLink(reportBody) {",
                    "  return `${ISSUES_URL}${encodeURIComponent(reportBody)}`;",
                    "}",
                    "",
                    "function getSecondFormat(formatted, reformatted) {",
                    "  return formatted === \"\"",
                    "    ? \"\"",
                    "    : formatted === reformatted",
                    "    ? \"\u2713 Second format is unchanged.\"",
                    "    : reformatted;",
                    "}",
                    "",
                    "export default Playground;"
                ]
            },
            "PrettierFormat.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "export default class PrettierFormat extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { formatted: \"\", debug: {} };",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.format();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    for (const key of [",
                    "      \"code\",",
                    "      \"options\",",
                    "      \"debugAst\",",
                    "      \"debugDoc\",",
                    "      \"debugComments\",",
                    "      \"reformat\",",
                    "    ]) {",
                    "      if (prevProps[key] !== this.props[key]) {",
                    "        this.format();",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  format() {",
                    "    const {",
                    "      worker,",
                    "      code,",
                    "      options,",
                    "      debugAst: ast,",
                    "      debugDoc: doc,",
                    "      debugComments: comments,",
                    "      reformat,",
                    "    } = this.props;",
                    "",
                    "    worker",
                    "      .format(code, options, { ast, doc, comments, reformat })",
                    "      .then((result) => this.setState(result));",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "VersionLink.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"version\");",
                    "",
                    "export default function VersionLink({ version }) {",
                    "  const match = version.match(/^pr-(\\d+)$/);",
                    "  let href;",
                    "  if (match) {",
                    "    href = `pull/${match[1]}`;",
                    "  } else if (/\\.0$/.test(version)) {",
                    "    href = `releases/tag/${version}`;",
                    "  } else {",
                    "    href = `blob/main/CHANGELOG.md#${version.replace(/\\./g, \"\")}`;",
                    "  }",
                    "",
                    "  const formattedVersion = match ? `PR #${match[1]}` : `v${version}`;",
                    "",
                    "  React.useEffect(() => {",
                    "    document.title = `Prettier ${formattedVersion}`;",
                    "  }, [formattedVersion]);",
                    "",
                    "  return ReactDOM.createPortal(",
                    "    <a",
                    "      href={`https://github.com/prettier/prettier/${href}`}",
                    "      target=\"_blank\"",
                    "      rel=\"noreferrer noopener\"",
                    "    >",
                    "      {formattedVersion}",
                    "    </a>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "WorkerApi.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export default function WorkerApi(source) {",
                    "  const worker = new Worker(source);",
                    "  let counter = 0;",
                    "  const handlers = {};",
                    "",
                    "  worker.addEventListener(\"message\", (event) => {",
                    "    const { uid, message, error } = event.data;",
                    "",
                    "    if (!handlers[uid]) {",
                    "      return;",
                    "    }",
                    "",
                    "    const [resolve, reject] = handlers[uid];",
                    "    delete handlers[uid];",
                    "",
                    "    if (error) {",
                    "      reject(error);",
                    "    } else {",
                    "      resolve(message);",
                    "    }",
                    "  });",
                    "",
                    "  function postMessage(message) {",
                    "    const uid = ++counter;",
                    "    return new Promise((resolve, reject) => {",
                    "      handlers[uid] = [resolve, reject];",
                    "      worker.postMessage({ uid, message });",
                    "    });",
                    "  }",
                    "",
                    "  return {",
                    "    getMetadata() {",
                    "      return postMessage({ type: \"meta\" });",
                    "    },",
                    "    format(code, options, debug) {",
                    "      return postMessage({ type: \"format\", code, options, debug });",
                    "    },",
                    "    postMessage,",
                    "  };",
                    "}"
                ]
            },
            "buttons.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import ClipboardJS from \"clipboard\";",
                    "",
                    "export const Button = React.forwardRef((props, ref) => (",
                    "  <button type=\"button\" className=\"btn\" ref={ref} {...props} />",
                    "));",
                    "",
                    "export class ClipboardButton extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { showTooltip: false, tooltipText: \"\" };",
                    "    this.timer = null;",
                    "    this.ref = React.createRef();",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.clipboard = new ClipboardJS(this.ref.current, {",
                    "      text: () => {",
                    "        const { copy } = this.props;",
                    "        return typeof copy === \"function\" ? copy() : copy;",
                    "      },",
                    "    });",
                    "    this.clipboard.on(\"success\", () => this.showTooltip(\"Copied!\"));",
                    "    this.clipboard.on(\"error\", () => this.showTooltip(\"Press ctrl+c to copy\"));",
                    "  }",
                    "",
                    "  showTooltip(text) {",
                    "    this.setState({ showTooltip: true, tooltipText: text }, () => {",
                    "      if (this.timer) {",
                    "        clearTimeout(this.timer);",
                    "      }",
                    "      this.timer = setTimeout(() => {",
                    "        this.timer = null;",
                    "        this.setState({ showTooltip: false });",
                    "      }, 2000);",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { children, copy, ...rest } = this.props;",
                    "    const { showTooltip, tooltipText } = this.state;",
                    "",
                    "    return (",
                    "      <Button ref={this.ref} {...rest}>",
                    "        {showTooltip ? <span className=\"tooltip\">{tooltipText}</span> : null}",
                    "        {children}",
                    "      </Button>",
                    "    );",
                    "  }",
                    "}"
                ]
            },
            "codeSamples.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export default function getCodeSamples(parser) {",
                    "  switch (parser) {",
                    "    case \"babel\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "      return [",
                    "        'function HelloWorld({greeting = \"hello\", greeted = \\'\"World\"\\', silent = false, onMouseOver,}) {',",
                    "        \"\",",
                    "        \"  if(!greeting){return null};\",",
                    "        \"\",",
                    "        \"     // TODO: Don't use random in render\",",
                    "        '  let num = Math.floor (Math.random() * 1E+7).toString().replace(/\\\\.\\\\d+/ig, \"\")',",
                    "        \"\",",
                    "        \"  return <div className='HelloWorld' title={`You are visitor number ${ num }`} onMouseOver={onMouseOver}>\",",
                    "        \"\",",
                    "        \"    <strong>{ greeting.slice( 0, 1 ).toUpperCase() + greeting.slice(1).toLowerCase() }</strong>\",",
                    "        '    {greeting.endsWith(\",\") ? \" \" : <span style={{color: \\'\\\\grey\\'}}>\", \"</span> }',",
                    "        \"    <em>\",",
                    "        \"\\t{ greeted }\",",
                    "        \"\\t</em>\",",
                    "        \"    { (silent)\",",
                    "        '      ? \".\"',",
                    "        '      : \"!\"}',",
                    "        \"\",",
                    "        \"    </div>;\",",
                    "        \"\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"flow\":",
                    "    case \"babel-flow\":",
                    "      return [",
                    "        \"declare export function graphql<Props, Variables, Component: React$ComponentType<Props>>\",",
                    "        \"  (query: GQLDocument, config?: Config<Props, QueryConfigOptions<Variables>>):\",",
                    "        \"  (Component: Component) => React$ComponentType<$Diff<React$ElementConfig<Component>, {\",",
                    "        \"    data: Object|void,\",",
                    "        \"    mutate: Function|void\",",
                    "        \"  }>>\",",
                    "        \"\",",
                    "        'declare type FetchPolicy = \"cache-first\" | \"cache-and-network\" | \"network-only\" | \"cache-only\"',",
                    "      ].join(\"\\n\");",
                    "    case \"typescript\":",
                    "    case \"babel-ts\":",
                    "      return [",
                    "        \"interface MyInterface {\",",
                    "        \"  foo(): string,\",",
                    "        \"  bar: Array<number>,\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"export abstract class Foo implements MyInterface {\",",
                    "        \"  foo() {\",",
                    "        \"            // TODO: return an actual value here\",",
                    "        \"        return 'hello'\",",
                    "        \"      }\",",
                    "        \"  get bar() {\",",
                    "        \"    return [  1,\",",
                    "        \"\",",
                    "        \"      2, 3,\",",
                    "        \"    ]\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"type RequestType = 'GET' | 'HEAD' | 'POST' | 'PUT' | 'OPTIONS' | 'CONNECT' | 'DELETE' | 'TRACE'\",",
                    "      ].join(\"\\n\");",
                    "    case \"css\":",
                    "      // Excerpted from the Bootstrap source, which is licensed under the MIT license:",
                    "      // https://github.com/twbs/bootstrap/blob/v4.0.0-beta.3/LICENSE",
                    "      return [",
                    "        \"@media (max-width: 480px) {\",",
                    "        \"  .bd-examples {margin-right: -.75rem;margin-left: -.75rem\",",
                    "        \"  }\",",
                    "        \"  \",",
                    "        ' .bd-examples>[class^=\"col-\"]  {',",
                    "        \"    padding-right: .75rem;\",",
                    "        \"    padding-left: .75rem;\",",
                    "        \"  \",",
                    "        \"  }\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"scss\":",
                    "      // Excerpted from the Bootstrap source, which is licensed under the MIT license:",
                    "      // https://github.com/twbs/bootstrap/blob/v4.0.0-beta.3/LICENSE",
                    "      return [",
                    "        \"@function color-yiq($color) {\",",
                    "        \"  $r: red($color);$g: green($color);$b: blue($color);\",",
                    "        \"\",",
                    "        \"  $yiq: (($r * 299) + ($g * 587) + ($b * 114)) / 1000;\",",
                    "        \"\",",
                    "        \"  @if ($yiq >= $yiq-contrasted-threshold) {\",",
                    "        \"    @return $yiq-text-dark;\",",
                    "        \"} @else {\",",
                    "        \"    @return $yiq-text-light;\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"@each $color, $value in $colors {\",",
                    "        \"  .swatch-#{$color} {\",",
                    "        \"    color: color-yiq($value);\",",
                    "        \"    background-color: #{$value};\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"less\":",
                    "      // Copied from http://lesscss.org/features/#detached-rulesets-feature",
                    "      return [",
                    "        \"@my-ruleset: {\",",
                    "        \"    .my-selector {\",",
                    "        \"      @media tv {\",",
                    "        \"        background-color: black;\",",
                    "        \"      }\",",
                    "        \"    }\",",
                    "        \"  };\",",
                    "        \"@media (orientation:portrait) {\",",
                    "        \"    @my-ruleset();\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      // Excerpted & adapted from Wikipedia, under the Creative Commons Attribution-ShareAlike License",
                    "      // https://en.wikipedia.org/wiki/JSON#Example",
                    "      return [",
                    "        '{\"allOn\": \"Single\", \"Line\": \"example\",',",
                    "        '\"noSpace\":true,',",
                    "        '  \"quote\": {',",
                    "        \"    'singleQuote': 'example',\",",
                    "        '                  \"indented\": true,',",
                    "        \"  },\",",
                    "        '  \"phoneNumbers\": [',",
                    "        '    {\"type\": \"home\",',",
                    "        '      \"number\": \"212 555-1234\"},',",
                    "        '    {\"type\": \"office\",',",
                    "        '      \"trailing\": \"commas by accident\"},',",
                    "        \"  ],\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"graphql\":",
                    "      return [",
                    "        \"query Browse($offset: Int, $limit: Int, $categories: [String!], $search: String) {\",",
                    "        \"  browse(limit: $limit, offset: $offset, categories: $categories, search: $search) {\",",
                    "        \"    total,\",",
                    "        \"    results {\",",
                    "        \"        title\",",
                    "        \"        price\",",
                    "        \"    }\",",
                    "        \"  }\",",
                    "        \"}\",",
                    "      ].join(\"\\n\");",
                    "    case \"markdown\":",
                    "      return [",
                    "        \"Header\",",
                    "        \"======\",",
                    "        \"\",",
                    "        \"_Look,_ code blocks are formatted *too!*\",",
                    "        \"\",",
                    "        \"``` js\",",
                    "        \"function identity(x) { return x }\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"Pilot|Airport|Hours\",",
                    "        \"--|:--:|--:\",",
                    "        \"John Doe|SKG|1338\",",
                    "        \"Jane Roe|JFK|314\",",
                    "        \"\",",
                    "        \"- - - - - - - - - - - - - - -\",",
                    "        \"\",",
                    "        \"+ List\",",
                    "        \" + with a [link] (/to/somewhere)\",",
                    "        \"+ and [another one]\",",
                    "        \"\",",
                    "        \"\",",
                    "        \"  [another one]:  http://example.com 'Example title'\",",
                    "        \"\",",
                    "        \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\",",
                    "        \"Curabitur consectetur maximus risus, sed maximus tellus tincidunt et.\",",
                    "      ].join(\"\\n\");",
                    "    case \"mdx\":",
                    "      // modified from https://github.com/mdx-js/mdx/blob/master/packages/mdx/test/fixtures/blog-post.md",
                    "      return [",
                    "        \"import     {     Baz } from     './Fixture'\",",
                    "        \"import { Buz  }   from './Fixture'\",",
                    "        \"\",",
                    "        \"export  const   foo    = {\",",
                    "        \"  hi:     `Fudge ${Baz.displayName || 'Baz'}`,\",",
                    "        \"  authors: [\",",
                    "        \"     'fred',\",",
                    "        \"           'sally'\",",
                    "        \"    ]\",",
                    "        \"}\",",
                    "        \"\",",
                    "        \"# Hello,    world!\",",
                    "        \"\",",
                    "        \"\",",
                    "        \" I'm an awesome   paragraph.\",",
                    "        \"\",",
                    "        \"<!-- I'm a comment -->\",",
                    "        \"\",",
                    "        \"<Foo bg='red'>\",",
                    "        \"      <Bar    >hi    </Bar>\",",
                    "        \"       {  hello       }\",",
                    "        \"       {     /* another comment */}\",",
                    "        \"</Foo>\",",
                    "        \"\",",
                    "        \"```\",",
                    "        \"test codeblock\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"```js\",",
                    "        \"module.exports = 'test'\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"```sh\",",
                    "        \"npm i -g foo\",",
                    "        \"```\",",
                    "        \"\",",
                    "        \"| Test  | Table   |\",",
                    "        \"|    :---     | :----  |\",",
                    "        \"|   Col1  | Col2    |\",",
                    "        \"\",",
                    "        \"export   default     ({children   }) => < div>{    children}</div>\",",
                    "        \"\",",
                    "      ].join(\"\\n\");",
                    "    case \"vue\":",
                    "      return [",
                    "        \"<template>\",",
                    "        \"  <p>Templates are formatted as well...\",",
                    "        \"    </p>\",",
                    "        \"</template>\",",
                    "        \"\",",
                    "        \"<script>\",",
                    "        \"let Prettier = format => { your.js('though') }\",",
                    "        \"</script>\",",
                    "        \"\",",
                    "        \"<style>\",",
                    "        \".and { css: too !important }\",",
                    "        \"</style>\",",
                    "      ].join(\"\\n\");",
                    "    case \"yaml\":",
                    "      // modified from http://yaml.org/start.html",
                    "      return [",
                    "        \"---\",",
                    "        \"invoice   :   34843\",",
                    "        \"date   :    2001-01-23\",",
                    "        \"bill-to:    &id001\",",
                    "        \"    given    : Chris\",",
                    "        \"    family  : Dumars\",",
                    "        \"    address:\",",
                    "        \"        lines: |\",",
                    "        \"            458 Walkman Dr.\",",
                    "        \"            Suite #292\",",
                    "        \"        city        : Royal Oak\",",
                    "        \"        state      : MI\",",
                    "        \"        postal  : 48046\",",
                    "        \"ship-to: *id001\",",
                    "        \"product:\",",
                    "        \"    - \",",
                    "        \"    \",",
                    "        \"      sku         : BL394D\",",
                    "        \"      ? quantity    \",",
                    "        \"      : 4\",",
                    "        \"      description : Basketball\",",
                    "        \"      ? price       \",",
                    "        \"      : 450.00\",",
                    "        \"      \",",
                    "        \"      \",",
                    "        \"    - \",",
                    "        \"      sku          :   BL4438H\",",
                    "        \"      quantity      :  1\",",
                    "        \"      description:      Super Hoop\",",
                    "        \"      price         :  2392.00\",",
                    "        \"      \",",
                    "        \"      \",",
                    "        \"tax  :  251.42\",",
                    "        \"total : 4443.52\",",
                    "        \"comments: >\",",
                    "        \"    Late afternoon is best.\",",
                    "        \"    Backup contact is Nancy\",",
                    "        \"    Billsmer @ 338-4338.\",",
                    "        \"\",",
                    "      ].join(\"\\n\");",
                    "    case \"glimmer\":",
                    "      // modified from http://handlebarsjs.com/",
                    "      return [",
                    "        '  <div     class=\"entry\"    >',",
                    "        \"  <h1>{{  title    }}</h1>\",",
                    "        '  <div   class=\"body\">',",
                    "        \"            {{   body         }}\",",
                    "        \"</div> </div>\",",
                    "      ].join(\"\\n\");",
                    "    case \"html\":",
                    "    case \"angular\":",
                    "    case \"lwc\":",
                    "      return [",
                    "        \"<!DOCTYPE html>\",",
                    "        '<HTML CLASS=\"no-js mY-ClAsS\">',",
                    "        \"  <HEAD>\",",
                    "        '    <META CHARSET=\"utf-8\">',",
                    "        \"    <TITLE>My tITlE</TITLE>\",",
                    "        '    <META NAME=\"description\" content=\"My CoNtEnT\">',",
                    "        \"  </HEAD>\",",
                    "        \"  <body>\",",
                    "        \"    <P>Hello world!<BR> This is HTML5 Boilerplate.</P>\",",
                    "        \"    <SCRIPT>\",",
                    "        \"      window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;\",",
                    "        \"      ga('create', 'UA-XXXXX-Y', 'auto'); ga('send', 'pageview')\",",
                    "        \"    </SCRIPT>\",",
                    "        '    <SCRIPT src=\"https://www.google-analytics.com/analytics.js\" ASYNC DEFER></SCRIPT>',",
                    "        \"  </body>\",",
                    "        \"</HTML>\",",
                    "      ].join(\"\\n\");",
                    "    default:",
                    "      return \"\";",
                    "  }",
                    "}"
                ]
            },
            "helpers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function stateToggler(key) {",
                    "  return (state) => ({ [key]: !state[key] });",
                    "}",
                    "",
                    "const { hasOwnProperty } = Object.prototype;",
                    "",
                    "function is(x, y) {",
                    "  // SameValue algorithm",
                    "  if (x === y) {",
                    "    // Steps 1-5, 7-10",
                    "    // Steps 6.b-6.e: +0 != -0",
                    "    return x !== 0 || 1 / x === 1 / y;",
                    "  }",
                    "  // Step 6.a: NaN == NaN",
                    "  return x !== x && y !== y;",
                    "}",
                    "",
                    "export function shallowEqual(objA, objB) {",
                    "  if (is(objA, objB)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    typeof objA !== \"object\" ||",
                    "    objA === null ||",
                    "    typeof objB !== \"object\" ||",
                    "    objB === null",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const keysA = Object.keys(objA);",
                    "  const keysB = Object.keys(objB);",
                    "",
                    "  if (keysA.length !== keysB.length) {",
                    "    return false;",
                    "  }",
                    "",
                    "  for (let i = 0; i < keysA.length; i++) {",
                    "    if (",
                    "      !hasOwnProperty.call(objB, keysA[i]) ||",
                    "      !is(objA[keysA[i]], objB[keysA[i]])",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import \"codemirror-graphql/mode\";",
                    "",
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "import Playground from \"./Playground.js\";",
                    "import VersionLink from \"./VersionLink.js\";",
                    "import WorkerApi from \"./WorkerApi.js\";",
                    "import { fixPrettierVersion } from \"./util.js\";",
                    "",
                    "class App extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { loaded: false };",
                    "    this.worker = new WorkerApi(\"/worker.js\");",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.worker.getMetadata().then(({ supportInfo, version }) => {",
                    "      this.setState({",
                    "        loaded: true,",
                    "        availableOptions: supportInfo.options.map(augmentOption),",
                    "        version: fixPrettierVersion(version),",
                    "      });",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { loaded, availableOptions, version } = this.state;",
                    "",
                    "    if (!loaded) {",
                    "      return \"Loading...\";",
                    "    }",
                    "",
                    "    return (",
                    "      <React.Fragment>",
                    "        <VersionLink version={version} />",
                    "        <Playground",
                    "          worker={this.worker}",
                    "          availableOptions={availableOptions}",
                    "          version={version}",
                    "        />",
                    "      </React.Fragment>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function augmentOption(option) {",
                    "  if (option.type === \"boolean\" && option.default === true) {",
                    "    option.inverted = true;",
                    "  }",
                    "",
                    "  option.cliName =",
                    "    \"--\" +",
                    "    (option.inverted ? \"no-\" : \"\") +",
                    "    option.name.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();",
                    "",
                    "  return option;",
                    "}",
                    "",
                    "ReactDOM.render(<App />, document.getElementById(\"root\"));"
                ]
            },
            "markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function formatMarkdown({",
                    "  input,",
                    "  output,",
                    "  output2,",
                    "  doc,",
                    "  version,",
                    "  url,",
                    "  options,",
                    "  cliOptions,",
                    "  full,",
                    "}) {",
                    "  const syntax = getMarkdownSyntax(options);",
                    "  const optionsString = formatCLIOptions(cliOptions);",
                    "  const isIdempotent = !output2 || output === output2;",
                    "",
                    "  return [",
                    "    `**Prettier ${version}**`,",
                    "    `[Playground link](${url})`,",
                    "    optionsString === \"\" ? null : codeBlock(optionsString, \"sh\"),",
                    "    \"\",",
                    "    \"**Input:**\",",
                    "    codeBlock(input, syntax),",
                    "    ...(doc ? [\"\", \"**Doc:**\", codeBlock(doc, \"js\")] : []),",
                    "    ...(output === undefined",
                    "      ? []",
                    "      : [\"\", \"**Output:**\", codeBlock(output, syntax)]),",
                    "    ...(isIdempotent",
                    "      ? []",
                    "      : [\"\", \"**Second Output:**\", codeBlock(output2, syntax)]),",
                    "    ...(full ? [\"\", \"**Expected behavior:**\", \"\"] : []),",
                    "  ]",
                    "    .filter((part) => part !== null)",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function getMarkdownSyntax(options) {",
                    "  switch (options.parser) {",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"flow\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "      return \"jsx\";",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "      return \"tsx\";",
                    "    case \"json\":",
                    "    case \"json-stringify\":",
                    "      return \"jsonc\";",
                    "    case \"glimmer\":",
                    "      return \"hbs\";",
                    "    case \"angular\":",
                    "    case \"lwc\":",
                    "      return \"html\";",
                    "    default:",
                    "      return options.parser;",
                    "  }",
                    "}",
                    "",
                    "function formatCLIOptions(cliOptions) {",
                    "  return cliOptions",
                    "    .map(([name, value]) => (value === true ? name : `${name} ${value}`))",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function codeBlock(content, syntax) {",
                    "  const backtickSequences = content.match(/`+/g) || [];",
                    "  const longestBacktickSequenceLength = Math.max(",
                    "    ...backtickSequences.map(({ length }) => length)",
                    "  );",
                    "  const prettierIgnoreComment = \"<!-- prettier-ignore -->\";",
                    "  const fenceLength = Math.max(3, longestBacktickSequenceLength + 1);",
                    "  const fence = \"`\".repeat(fenceLength);",
                    "  return [prettierIgnoreComment, fence + (syntax || \"\"), content, fence].join(",
                    "    \"\\n\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = formatMarkdown;"
                ]
            },
            "panels.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import CodeMirror from \"codemirror\";",
                    "import * as React from \"react\";",
                    "",
                    "class CodeMirrorPanel extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this._textareaRef = React.createRef();",
                    "    this._codeMirror = null;",
                    "    this._cached = \"\";",
                    "    this._overlay = null;",
                    "    this.handleChange = this.handleChange.bind(this);",
                    "    this.handleFocus = this.handleFocus.bind(this);",
                    "    this.handleSelectionChange = this.handleSelectionChange.bind(this);",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    const options = { ...this.props };",
                    "    delete options.ruler;",
                    "    delete options.rulerColor;",
                    "    delete options.value;",
                    "    delete options.onChange;",
                    "",
                    "    options.rulers = [makeRuler(this.props)];",
                    "",
                    "    if (options.foldGutter) {",
                    "      options.gutters = [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"];",
                    "    }",
                    "",
                    "    this._codeMirror = CodeMirror.fromTextArea(",
                    "      this._textareaRef.current,",
                    "      options",
                    "    );",
                    "    this._codeMirror.on(\"change\", this.handleChange);",
                    "    this._codeMirror.on(\"focus\", this.handleFocus);",
                    "    this._codeMirror.on(\"beforeSelectionChange\", this.handleSelectionChange);",
                    "",
                    "    window.CodeMirror.keyMap.pcSublime[\"Ctrl-L\"] = false;",
                    "    window.CodeMirror.keyMap.sublime[\"Ctrl-L\"] = false;",
                    "",
                    "    this.updateValue(this.props.value || \"\");",
                    "    this.updateOverlay();",
                    "  }",
                    "",
                    "  componentWillUnmount() {",
                    "    this._codeMirror && this._codeMirror.toTextArea();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    if (this.props.value !== this._cached) {",
                    "      this.updateValue(this.props.value);",
                    "    }",
                    "    if (",
                    "      this.props.overlayStart !== prevProps.overlayStart ||",
                    "      this.props.overlayEnd !== prevProps.overlayEnd",
                    "    ) {",
                    "      this.updateOverlay();",
                    "    }",
                    "    if (this.props.mode !== prevProps.mode) {",
                    "      this._codeMirror.setOption(\"mode\", this.props.mode);",
                    "    }",
                    "    if (this.props.ruler !== prevProps.ruler) {",
                    "      this._codeMirror.setOption(\"rulers\", [makeRuler(this.props)]);",
                    "    }",
                    "  }",
                    "",
                    "  updateValue(value) {",
                    "    this._cached = value;",
                    "    this._codeMirror.setValue(value);",
                    "",
                    "    if (this.props.autoFold instanceof RegExp) {",
                    "      const lines = value.split(\"\\n\");",
                    "      // going backwards to prevent unfolding folds created earlier",
                    "      for (let i = lines.length - 1; i >= 0; i--) {",
                    "        if (this.props.autoFold.test(lines[i])) {",
                    "          this._codeMirror.foldCode(i);",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  updateOverlay() {",
                    "    if (!this.props.readOnly) {",
                    "      if (this._overlay) {",
                    "        this._codeMirror.removeOverlay(this._overlay);",
                    "      }",
                    "      const [start, end] = getIndexPosition(this.props.value, [",
                    "        this.props.overlayStart,",
                    "        this.props.overlayEnd,",
                    "      ]);",
                    "      this._overlay = createOverlay(start, end);",
                    "      this._codeMirror.addOverlay(this._overlay);",
                    "    }",
                    "  }",
                    "",
                    "  handleFocus(/* codeMirror, event */) {",
                    "    if (this._codeMirror.getValue() === this.props.codeSample) {",
                    "      this._codeMirror.execCommand(\"selectAll\");",
                    "    }",
                    "  }",
                    "",
                    "  handleChange(doc, change) {",
                    "    if (change.origin !== \"setValue\") {",
                    "      this._cached = doc.getValue();",
                    "      this.props.onChange(this._cached);",
                    "      this.updateOverlay();",
                    "    }",
                    "  }",
                    "",
                    "  handleSelectionChange(doc, change) {",
                    "    if (this.props.onSelectionChange) {",
                    "      this.props.onSelectionChange(change.ranges[0]);",
                    "    }",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <div className=\"editor input\">",
                    "        <textarea ref={this._textareaRef} />",
                    "      </div>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function getIndexPosition(text, indexes) {",
                    "  indexes = [...indexes];",
                    "  let line = 0;",
                    "  let count = 0;",
                    "  let lineStart = 0;",
                    "  const result = [];",
                    "",
                    "  while (indexes.length > 0) {",
                    "    const index = indexes.shift();",
                    "",
                    "    while (count < index && count < text.length) {",
                    "      if (text[count] === \"\\n\") {",
                    "        line++;",
                    "        lineStart = count + 1;",
                    "      }",
                    "      count++;",
                    "    }",
                    "",
                    "    result.push({ line, pos: count - lineStart });",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function createOverlay(start, end) {",
                    "  return {",
                    "    token(stream) {",
                    "      const { line } = stream.lineOracle;",
                    "",
                    "      if (line < start.line || line > end.line) {",
                    "        stream.skipToEnd();",
                    "      } else if (line === start.line && stream.pos < start.pos) {",
                    "        stream.pos = start.pos;",
                    "      } else if (line === end.line) {",
                    "        if (stream.pos < end.pos) {",
                    "          stream.pos = end.pos;",
                    "          return \"searching\";",
                    "        }",
                    "        stream.skipToEnd();",
                    "      } else {",
                    "        stream.skipToEnd();",
                    "        return \"searching\";",
                    "      }",
                    "    },",
                    "  };",
                    "}",
                    "",
                    "function makeRuler(props) {",
                    "  return { column: props.ruler, color: props.rulerColor };",
                    "}",
                    "",
                    "export function InputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      lineNumbers={true}",
                    "      keyMap=\"sublime\"",
                    "      autoCloseBrackets={true}",
                    "      matchBrackets={true}",
                    "      showCursorWhenSelecting={true}",
                    "      tabSize={4}",
                    "      rulerColor=\"#eeeeee\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function OutputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={true}",
                    "      rulerColor=\"#444444\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function DebugPanel({ value, autoFold }) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={false}",
                    "      foldGutter={true}",
                    "      autoFold={autoFold}",
                    "      mode=\"jsx\"",
                    "      value={value}",
                    "    />",
                    "  );",
                    "}"
                ]
            },
            "storage.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function get(key) {",
                    "  try {",
                    "    return JSON.parse(window.localStorage.getItem(key));",
                    "  } catch {",
                    "    // noop",
                    "  }",
                    "}",
                    "",
                    "export function set(key, value) {",
                    "  try {",
                    "    window.localStorage.setItem(key, JSON.stringify(value));",
                    "  } catch {",
                    "    // noop",
                    "  }",
                    "}"
                ]
            },
            "urlHash.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import LZString from \"lz-string\";",
                    "",
                    "export function read() {",
                    "  const hash = document.location.hash.slice(1);",
                    "  if (!hash) {",
                    "    return {};",
                    "  }",
                    "",
                    "  // backwards support for old json encoded URIComponent",
                    "  const decode = hash.includes(\"%7B%22\")",
                    "    ? decodeURIComponent",
                    "    : LZString.decompressFromEncodedURIComponent;",
                    "",
                    "  try {",
                    "    return JSON.parse(decode(hash));",
                    "  } catch {",
                    "    return {};",
                    "  }",
                    "}",
                    "",
                    "export function replace(state) {",
                    "  const hash = LZString.compressToEncodedURIComponent(JSON.stringify(state));",
                    "  if (",
                    "    typeof URL === \"function\" &&",
                    "    typeof history === \"object\" &&",
                    "    typeof history.replaceState === \"function\"",
                    "  ) {",
                    "    const url = new URL(location);",
                    "    url.hash = hash;",
                    "    history.replaceState(null, null, url);",
                    "  } else {",
                    "    location.hash = hash;",
                    "  }",
                    "}"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function fixPrettierVersion(version) {",
                    "  const match = version.match(/^\\d+\\.\\d+\\.\\d+-pr.(\\d+)$/);",
                    "  if (match) {",
                    "    return `pr-${match[1]}`;",
                    "  }",
                    "  return version;",
                    "}",
                    "",
                    "export function getDefaults(availableOptions, optionNames) {",
                    "  const defaults = {};",
                    "  for (const option of availableOptions) {",
                    "    if (optionNames.includes(option.name)) {",
                    "      defaults[option.name] =",
                    "        option.name === \"parser\" ? \"babel\" : option.default;",
                    "    }",
                    "  }",
                    "  return defaults;",
                    "}",
                    "",
                    "export function buildCliArgs(availableOptions, options) {",
                    "  const args = [];",
                    "  for (const option of availableOptions) {",
                    "    const value = options[option.name];",
                    "",
                    "    if (typeof value === \"undefined\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (option.type === \"boolean\") {",
                    "      if ((value && !option.inverted) || (!value && option.inverted)) {",
                    "        args.push([option.cliName, true]);",
                    "      }",
                    "    } else if (value !== option.default || option.name === \"rangeStart\") {",
                    "      args.push([option.cliName, value]);",
                    "    }",
                    "  }",
                    "  return args;",
                    "}",
                    "",
                    "export function getCodemirrorMode(parser) {",
                    "  switch (parser) {",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return \"css\";",
                    "    case \"graphql\":",
                    "      return \"graphql\";",
                    "    case \"markdown\":",
                    "      return \"markdown\";",
                    "    default:",
                    "      return \"jsx\";",
                    "  }",
                    "}",
                    "",
                    "const astAutoFold = {",
                    "  estree:",
                    "    /^\\s*\"(loc|start|end|tokens|leadingComments|trailingComments|innerComments)\":/,",
                    "  postcss: /^\\s*\"(source|input|raws|file)\":/,",
                    "  html: /^\\s*\"(sourceSpan|valueSpan|nameSpan|startSourceSpan|endSourceSpan|tagDefinition)\":/,",
                    "  mdast: /^\\s*\"position\":/,",
                    "  yaml: /^\\s*\"position\":/,",
                    "  glimmer: /^\\s*\"loc\":/,",
                    "};",
                    "",
                    "export function getAstAutoFold(parser) {",
                    "  switch (parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "    case \"espree\":",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      return astAutoFold.estree;",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return astAutoFold.postcss;",
                    "    case \"html\":",
                    "    case \"angular\":",
                    "    case \"vue\":",
                    "    case \"lwc\":",
                    "      return astAutoFold.html;",
                    "    case \"markdown\":",
                    "    case \"mdx\":",
                    "      return astAutoFold.mdast;",
                    "    case \"yaml\":",
                    "      return astAutoFold.yaml;",
                    "    case \"glimmer\":",
                    "      return astAutoFold.glimmer;",
                    "  }",
                    "}"
                ]
            },
            "sidebar": {
                "SidebarOptions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "import groupBy from \"lodash/groupBy\";",
                        "",
                        "import { SidebarCategory } from \"./components.js\";",
                        "import Option from \"./options.js\";",
                        "",
                        "export default function SidebarOptions({",
                        "  categories,",
                        "  availableOptions,",
                        "  optionValues,",
                        "  onOptionValueChange,",
                        "}) {",
                        "  const options = groupBy(availableOptions, \"category\");",
                        "  return categories.map((category) =>",
                        "    options[category] ? (",
                        "      <SidebarCategory key={category} title={category}>",
                        "        {options[category].map((option) => (",
                        "          <Option",
                        "            key={option.name}",
                        "            option={option}",
                        "            value={optionValues[option.name]}",
                        "            onChange={onOptionValueChange}",
                        "          />",
                        "        ))}",
                        "      </SidebarCategory>",
                        "    ) : null",
                        "  );",
                        "}"
                    ]
                },
                "components.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Sidebar({ visible, children }) {",
                        "  return (",
                        "    <div className={`options-container ${visible ? \"open\" : \"\"}`}>",
                        "      <div className=\"options\">{children}</div>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "export function SidebarCategory({ title, children }) {",
                        "  return (",
                        "    <details className=\"sub-options\" open=\"true\">",
                        "      <summary>{title}</summary>",
                        "      {children}",
                        "    </details>",
                        "  );",
                        "}"
                    ]
                },
                "inputs.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Checkbox({ label: _label, title, checked, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      <input",
                        "        type=\"checkbox\"",
                        "        checked={checked}",
                        "        onChange={(ev) => onChange(ev.target.checked)}",
                        "      />{\" \"}",
                        "      {_label}",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function Select({ label: _label, title, values, selected, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <select value={selected} onChange={(ev) => onChange(ev.target.value)}>",
                        "        {values.map((val) => (",
                        "          <option key={val} value={val}>",
                        "            {val}",
                        "          </option>",
                        "        ))}",
                        "      </select>",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function NumberInput({",
                        "  label: _label,",
                        "  title,",
                        "  value,",
                        "  min,",
                        "  max,",
                        "  step,",
                        "  onChange,",
                        "}) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <input",
                        "        type=\"number\"",
                        "        min={min}",
                        "        max={max}",
                        "        step={step}",
                        "        value={value}",
                        "        onChange={(ev) => onChange(Number.parseInt(ev.target.value, 10))}",
                        "      />",
                        "    </label>",
                        "  );",
                        "}"
                    ]
                },
                "options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "import { Checkbox, Select, NumberInput } from \"./inputs.js\";",
                        "",
                        "export function BooleanOption({ option, value, onChange }) {",
                        "  function maybeInvert(value) {",
                        "    return option.inverted ? !value : value;",
                        "  }",
                        "  return (",
                        "    <Checkbox",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      checked={maybeInvert(value)}",
                        "      onChange={(checked) => onChange(option, maybeInvert(checked))}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function ChoiceOption({ option, value, onChange }) {",
                        "  return (",
                        "    <Select",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      values={option.choices.map((choice) => choice.value)}",
                        "      selected={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function NumberOption({ option, value, onChange }) {",
                        "  return (",
                        "    <NumberInput",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      min={option.range.start}",
                        "      max={option.range.end}",
                        "      step={option.range.step}",
                        "      value={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export default function Option(props) {",
                        "  switch (props.option.type) {",
                        "    case \"boolean\":",
                        "      return <BooleanOption {...props} />;",
                        "    case \"int\":",
                        "      return <NumberOption {...props} />;",
                        "    case \"choice\":",
                        "      return <ChoiceOption {...props} />;",
                        "    default:",
                        "      throw new Error(\"unsupported type\");",
                        "  }",
                        "}",
                        "",
                        "function getDescription(option) {",
                        "  const description = option.inverted",
                        "    ? option.oppositeDescription",
                        "    : option.description;",
                        "  return description && description.replace(/\\n/g, \" \");",
                        "}"
                    ]
                }
            }
        },
        "static": {
            "_redirects": {},
            "icon.png": {},
            "install-service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "if (\"serviceWorker\" in navigator) {",
                    "  navigator.serviceWorker.register(\"/service-worker.js\", {",
                    "    scope: \"/playground/\",",
                    "  });",
                    "}"
                ]
            },
            "landing.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "if (location.hash.slice(1).startsWith(encodeURIComponent(\"{\"))) {",
                    "  location.pathname = \"/playground/\";",
                    "}",
                    "",
                    "window.addEventListener(\"load\", () => {",
                    "  // We don't have access to a unique body css attribute for just the homepage",
                    "  // so instead it is set on load. It's only really visible on a vertical overscroll",
                    "  document.body.style.backgroundColor = \"rgb(24, 32, 37)\";",
                    "",
                    "  const logoWrapper = document.querySelector(\".animatedLogoWrapper\");",
                    "  const logo = document.querySelector(\".prettier-logo-wide\");",
                    "  const lastDash = logo.querySelector(\"g:last-of-type path:last-of-type\");",
                    "",
                    "  function handleLogoDrag(event) {",
                    "    logo.classList.add(\"rolling\");",
                    "    event.preventDefault();",
                    "  }",
                    "",
                    "  logoWrapper.setAttribute(\"draggable\", \"true\");",
                    "  logoWrapper.addEventListener(\"touchstart\", handleLogoDrag);",
                    "  logoWrapper.addEventListener(\"dragstart\", handleLogoDrag);",
                    "",
                    "  lastDash.addEventListener(\"animationend\", (event) => {",
                    "    if (/roll/.test(event.animationName)) {",
                    "      logo.classList.remove(\"rolling\");",
                    "    }",
                    "  });",
                    "});"
                ]
            },
            "manifest.json": {},
            "overrides.css": {},
            "prettier-centered-logo-static.svg": {},
            "prettier.png": {},
            "service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* global toolbox parsersLocation */",
                    "",
                    "\"use strict\";",
                    "",
                    "importScripts(\"lib/parsers-location.js\");",
                    "importScripts(\"https://unpkg.com/sw-toolbox@3.6.0/sw-toolbox.js\");",
                    "",
                    "const parsers = Object.keys(parsersLocation).map((file) => `lib/${file}`);",
                    "",
                    "toolbox.precache([",
                    "  // Scripts",
                    "  \"lib/standalone.js\",",
                    "  \"lib/parsers-location.js\",",
                    "  ...parsers,",
                    "  \"playground.js\",",
                    "  \"https://unpkg.com/sw-toolbox@3.6.0/sw-toolbox.js\",",
                    "",
                    "  // CodeMirror; keep this in sync with website/pages/playground/index.html",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/codemirror.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/fold/foldgutter.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/codemirror.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/javascript/javascript.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/xml/xml.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/jsx/jsx.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/css/css.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/mode/markdown/markdown.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/display/placeholder.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/display/rulers.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/search/searchcursor.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/edit/matchbrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/edit/closebrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/comment/comment.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/wrap/hardwrap.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/fold/foldcode.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/fold/foldgutter.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/addon/fold/brace-fold.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.58.1/keymap/sublime.min.js\",",
                    "",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react/17.0.1/umd/react.production.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react-dom/17.0.1/umd/react-dom.production.min.js\",",
                    "",
                    "  // Images",
                    "  \"/prettier.png\",",
                    "]);",
                    "",
                    "// Default to hit the cache only if there's a network error",
                    "toolbox.router.default = toolbox.networkFirst;",
                    "",
                    "// For scripts, stylesheets and images, we can use the \"fastest\" strategy",
                    "// This means you need to reload twice to get new changes",
                    "toolbox.router.get(/\\.(js|css|png|svg)$/, toolbox.fastest);"
                ]
            },
            "worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* globals prettier prettierPlugins parsersLocation */",
                    "",
                    "\"use strict\";",
                    "",
                    "self.PRETTIER_DEBUG = true;",
                    "",
                    "const imported = Object.create(null);",
                    "function importScriptOnce(url) {",
                    "  if (!imported[url]) {",
                    "    imported[url] = true;",
                    "    importScripts(url);",
                    "  }",
                    "}",
                    "",
                    "importScripts(\"lib/parsers-location.js\");",
                    "importScripts(\"lib/standalone.js\");",
                    "",
                    "// this is required to only load parsers when we need them",
                    "const parsers = Object.create(null);",
                    "for (const file in parsersLocation) {",
                    "  const { parsers: moduleParsers, property } = parsersLocation[file];",
                    "  const url = `lib/${file}`;",
                    "  for (const parserName of moduleParsers) {",
                    "    Object.defineProperty(parsers, parserName, {",
                    "      get() {",
                    "        importScriptOnce(url);",
                    "        return prettierPlugins[property].parsers[parserName];",
                    "      },",
                    "    });",
                    "  }",
                    "}",
                    "",
                    "self.onmessage = function (event) {",
                    "  self.postMessage({",
                    "    uid: event.data.uid,",
                    "    message: handleMessage(event.data.message),",
                    "  });",
                    "};",
                    "",
                    "function serializeAst(ast) {",
                    "  return JSON.stringify(",
                    "    ast,",
                    "    (_, value) =>",
                    "      value instanceof Error",
                    "        ? { name: value.name, message: value.message, ...value }",
                    "        : typeof value === \"bigint\"",
                    "        ? `BigInt('${String(value)}')`",
                    "        : value,",
                    "    2",
                    "  );",
                    "}",
                    "",
                    "function handleMessage(message) {",
                    "  if (message.type === \"meta\") {",
                    "    return {",
                    "      type: \"meta\",",
                    "      supportInfo: JSON.parse(",
                    "        JSON.stringify(",
                    "          prettier.getSupportInfo({",
                    "            showUnreleased: true,",
                    "          })",
                    "        )",
                    "      ),",
                    "      version: prettier.version,",
                    "    };",
                    "  }",
                    "",
                    "  if (message.type === \"format\") {",
                    "    const options = message.options || {};",
                    "",
                    "    delete options.ast;",
                    "    delete options.doc;",
                    "    delete options.output2;",
                    "",
                    "    const plugins = [{ parsers }];",
                    "    options.plugins = plugins;",
                    "",
                    "    const formatResult = formatCode(message.code, options);",
                    "",
                    "    const response = {",
                    "      formatted: formatResult.formatted,",
                    "      debug: {",
                    "        ast: null,",
                    "        doc: null,",
                    "        comments: null,",
                    "        reformatted: null,",
                    "      },",
                    "    };",
                    "",
                    "    if (message.debug.ast) {",
                    "      let ast;",
                    "      let errored = false;",
                    "      try {",
                    "        ast = serializeAst(prettier.__debug.parse(message.code, options).ast);",
                    "      } catch (e) {",
                    "        errored = true;",
                    "        ast = String(e);",
                    "      }",
                    "",
                    "      if (!errored) {",
                    "        try {",
                    "          ast = formatCode(ast, { parser: \"json\", plugins }).formatted;",
                    "        } catch {",
                    "          ast = serializeAst(ast);",
                    "        }",
                    "      }",
                    "      response.debug.ast = ast;",
                    "    }",
                    "",
                    "    if (message.debug.doc) {",
                    "      try {",
                    "        response.debug.doc = prettier.__debug.formatDoc(",
                    "          prettier.__debug.printToDoc(message.code, options),",
                    "          { parser: \"babel\", plugins }",
                    "        );",
                    "      } catch (e) {",
                    "        response.debug.doc = String(e);",
                    "      }",
                    "    }",
                    "",
                    "    if (message.debug.comments) {",
                    "      response.debug.comments = formatCode(",
                    "        JSON.stringify(formatResult.comments || []),",
                    "        { parser: \"json\", plugins }",
                    "      ).formatted;",
                    "    }",
                    "",
                    "    if (message.debug.reformat) {",
                    "      response.debug.reformatted = formatCode(",
                    "        response.formatted,",
                    "        options",
                    "      ).formatted;",
                    "    }",
                    "",
                    "    return response;",
                    "  }",
                    "}",
                    "",
                    "function formatCode(text, options) {",
                    "  try {",
                    "    return prettier.formatWithCursor(text, options);",
                    "  } catch (e) {",
                    "    if (e.constructor && e.constructor.name === \"SyntaxError\") {",
                    "      // Likely something wrong with the user's code",
                    "      return { formatted: String(e) };",
                    "    }",
                    "    // Likely a bug in Prettier",
                    "    // Provide the whole stack for debugging",
                    "    return { formatted: e.stack || String(e) };",
                    "  }",
                    "}"
                ]
            },
            "images": {
                "get_started_rects.svg": {},
                "github.svg": {},
                "github_grey.svg": {},
                "npm.svg": {},
                "npm_grey.svg": {},
                "state_of_js.svg": {},
                "state_of_js_grey.svg": {},
                "tidelift-small.png": {},
                "editors": {
                    "atom-128px.png": {},
                    "editor_atom.svg": {},
                    "editor_emacs.svg": {},
                    "editor_espresso.svg": {},
                    "editor_nova.svg": {},
                    "editor_sublime.svg": {},
                    "editor_vim.svg": {},
                    "editor_vs.svg": {},
                    "editor_vscode.svg": {},
                    "editor_webstorm.svg": {},
                    "emacs-128px.png": {},
                    "espresso-128px.png": {},
                    "sublimetext-128px.png": {},
                    "vim-128px.png": {},
                    "visualstudio-128px.png": {},
                    "vscode-128px.png": {},
                    "webstorm-128px.png": {}
                },
                "languages": {
                    "css-128px.png": {},
                    "css_small_grey.svg": {},
                    "graphql-128px.png": {},
                    "graphql_small_grey.svg": {},
                    "js-128px.png": {},
                    "js_small_grey.svg": {},
                    "markdown-128px.png": {},
                    "markdown_small_grey.svg": {},
                    "python_small_grey.svg": {},
                    "swift_small_grey.svg": {},
                    "tools_css.svg": {},
                    "tools_gql.svg": {},
                    "tools_html.svg": {},
                    "tools_js.svg": {},
                    "tools_md.svg": {},
                    "tools_wip.svg": {},
                    "tools_yaml.svg": {}
                },
                "users": {
                    "3yourmind.svg": {},
                    "aircall.svg": {},
                    "algolia-200x100.png": {},
                    "assertible-200x100.png": {},
                    "babel-200x100.png": {},
                    "brigad-200x100.png": {},
                    "buildcom.svg": {},
                    "campusjaeger.svg": {},
                    "charlietango-200x100.png": {},
                    "chillicream.svg": {},
                    "codecarrot.svg": {},
                    "codemix-200x100.png": {},
                    "computerbase.svg": {},
                    "contiamo-200x100.png": {},
                    "danger-200x100.png": {},
                    "dev-it-jobs-200-100.jpg": {},
                    "discord-200x100.png": {},
                    "drizly-200x100.png": {},
                    "dropbox.svg": {},
                    "dropbox_grey.svg": {},
                    "escrow-200x100.png": {},
                    "estalee.svg": {},
                    "eventstag-200x100.png": {},
                    "exponea.svg": {},
                    "eyesquare-200x100.png": {},
                    "facebook-200x100.png": {},
                    "freelancer-200x100.png": {},
                    "getonboard-200x100.png": {},
                    "gumgum-200x100.png": {},
                    "hackclub-200x100.png": {},
                    "hasura-200x100.png": {},
                    "hearthsim-200x100.png": {},
                    "heroku.svg": {},
                    "holidaycheck-200x100.png": {},
                    "housinganywhere.svg": {},
                    "hudl-200x100.png": {},
                    "icons8.svg": {},
                    "ideati-200x100.png": {},
                    "iress-200x100.png": {},
                    "jane-200x100.png": {},
                    "jest-200x100.png": {},
                    "leesa.svg": {},
                    "lifesum-200x100.png": {},
                    "loyaltylion-200x100.png": {},
                    "m6web-200x100.png": {},
                    "materialui-200x100.png": {},
                    "mathrioshka-200x100.png": {},
                    "metric-ai-white.svg": {},
                    "monei-200x100.png": {},
                    "mongodb-200x100.png": {},
                    "moonmail-200x100.png": {},
                    "n26-200x100.png": {},
                    "nhl-200x100.png": {},
                    "nrwl-200x100.png": {},
                    "openbravo-200x100.png": {},
                    "outreach-200x100.png": {},
                    "paypal-200x100.png": {},
                    "quip.svg": {},
                    "react-200x100.png": {},
                    "researchanddesign.svg": {},
                    "rnfirebase-200x100.png": {},
                    "salesforce.svg": {},
                    "sevenspan-200x100.png": {},
                    "shelf-200x100.png": {},
                    "smooth-code-200x100.png": {},
                    "storybook-200x100.png": {},
                    "swissdev-devops-jobs-200-100.png": {},
                    "talkable-200x100.png": {},
                    "toptal.png": {},
                    "tradeshift-200x100.png": {},
                    "tradie-training.png": {},
                    "transloadit-200x100.png": {},
                    "troops-200x100.png": {},
                    "used_by_babel.svg": {},
                    "used_by_danger.svg": {},
                    "used_by_facebook.svg": {},
                    "used_by_jest.svg": {},
                    "used_by_react.svg": {},
                    "used_by_spotify.svg": {},
                    "used_by_storybook.svg": {},
                    "used_by_webpack.svg": {},
                    "used_by_yarn.svg": {},
                    "used_by_zeit.svg": {},
                    "webflow-200x100.png": {},
                    "webpack-200x100.png": {},
                    "wingify-200x100.png": {},
                    "wire-200x100.png": {},
                    "yarn-200x100.png": {},
                    "yelp-200x100.png": {},
                    "zeit-200x100.png": {},
                    "zipch-200x100.png": {}
                }
            },
            "separate-css": {
                "playground.css": {}
            }
        },
        "versioned_docs": {
            "version-stable": {
                "api.md": {},
                "browser.md": {},
                "cli.md": {},
                "comparison.md": {},
                "configuration.md": {},
                "editors.md": {},
                "for-enterprise.md": {},
                "ignore.md": {},
                "index.md": {},
                "install.md": {},
                "integrating-with-linters.md": {},
                "option-philosophy.md": {},
                "options.md": {},
                "plugins.md": {},
                "precommit.md": {},
                "rationale.md": {},
                "related-projects.md": {},
                "technical-details.md": {},
                "vim.md": {},
                "watching-files.md": {},
                "webstorm.md": {},
                "why-prettier.md": {}
            }
        },
        "versioned_sidebars": {
            "version-stable-sidebars.json": {}
        }
    }
}