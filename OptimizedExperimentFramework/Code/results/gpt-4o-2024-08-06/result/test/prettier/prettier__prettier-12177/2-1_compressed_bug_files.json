{
    "1": {
        "bug_file": "src/language-js/print/statement.js",
        "compressed": "NO",
        "line_numbers": 251,
        "compressed_line_numbers": 251,
        "compressed_bug_file_content": "\"use strict\";\n\nconst {\n  builders: { hardline },\n} = require(\"../../document/index.js\");\nconst pathNeedsParens = require(\"../needs-parens.js\");\nconst {\n  getLeftSidePathName,\n  hasNakedLeftSide,\n  isJsxNode,\n  isTheOnlyJsxElementInMarkdown,\n  hasComment,\n  CommentCheckFlags,\n  isNextLineEmpty,\n} = require(\"../utils/index.js\");\nconst { shouldPrintParamsWithoutParens } = require(\"./function.js\");\n\n/**\n * @typedef {import(\"../../document\").Doc} Doc\n * @typedef {import(\"../../common/ast-path\")} AstPath\n */\n\nfunction printStatementSequence(path, options, print, property) {\n  const node = path.getValue();\n  const parts = [];\n  const isClassBody = node.type === \"ClassBody\";\n  const lastStatement = getLastStatement(node[property]);\n\n  path.each((path, index, statements) => {\n    const node = path.getValue();\n\n    // Skip printing EmptyStatement nodes to avoid leaving stray\n    // semicolons lying around.\n    if (node.type === \"EmptyStatement\") {\n      return;\n    }\n\n    const printed = print();\n\n    // in no-semi mode, prepend statement with semicolon if it might break ASI\n    // don't prepend the only JSX element in a program with semicolon\n    if (\n      !options.semi &&\n      !isClassBody &&\n      !isTheOnlyJsxElementInMarkdown(options, path) &&\n      statementNeedsASIProtection(path, options)\n    ) {\n      if (hasComment(node, CommentCheckFlags.Leading)) {\n        parts.push(print([], { needsSemi: true }));\n      } else {\n        parts.push(\";\", printed);\n      }\n    } else {\n      parts.push(printed);\n    }\n\n    if (\n      !options.semi &&\n      isClassBody &&\n      isClassProperty(node) &&\n      // `ClassBody` don't allow `EmptyStatement`,\n      // so we can use `statements` to get next node\n      shouldPrintSemicolonAfterClassProperty(node, statements[index + 1])\n    ) {\n      parts.push(\";\");\n    }\n\n    if (node !== lastStatement) {\n      parts.push(hardline);\n\n      if (isNextLineEmpty(node, options)) {\n        parts.push(hardline);\n      }\n    }\n  }, property);\n\n  return parts;\n}\n\nfunction getLastStatement(statements) {\n  for (let i = statements.length - 1; i >= 0; i--) {\n    const statement = statements[i];\n    if (statement.type !== \"EmptyStatement\") {\n      return statement;\n    }\n  }\n}\n\nfunction statementNeedsASIProtection(path, options) {\n  const node = path.getNode();\n\n  if (node.type !== \"ExpressionStatement\") {\n    return false;\n  }\n\n  return path.call(\n    (childPath) => expressionNeedsASIProtection(childPath, options),\n    \"expression\"\n  );\n}\n\nfunction expressionNeedsASIProtection(path, options) {\n  const node = path.getValue();\n  switch (node.type) {\n    case \"ParenthesizedExpression\":\n    case \"TypeCastExpression\":\n    case \"ArrayExpression\":\n    case \"ArrayPattern\":\n    case \"TemplateLiteral\":\n    case \"TemplateElement\":\n    case \"RegExpLiteral\":\n      return true;\n    case \"ArrowFunctionExpression\": {\n      if (!shouldPrintParamsWithoutParens(path, options)) {\n        return true;\n      }\n      break;\n    }\n    case \"UnaryExpression\": {\n      const { prefix, operator } = node;\n      if (prefix && (operator === \"+\" || operator === \"-\")) {\n        return true;\n      }\n      break;\n    }\n    case \"BindExpression\": {\n      if (!node.object) {\n        return true;\n      }\n      break;\n    }\n    case \"Literal\": {\n      if (node.regex) {\n        return true;\n      }\n      break;\n    }\n    default: {\n      if (isJsxNode(node)) {\n        return true;\n      }\n    }\n  }\n\n  if (pathNeedsParens(path, options)) {\n    return true;\n  }\n\n  if (!hasNakedLeftSide(node)) {\n    return false;\n  }\n\n  return path.call(\n    (childPath) => expressionNeedsASIProtection(childPath, options),\n    ...getLeftSidePathName(path, node)\n  );\n}\n\nfunction printBody(path, options, print) {\n  return printStatementSequence(path, options, print, \"body\");\n}\n\nfunction printSwitchCaseConsequent(path, options, print) {\n  return printStatementSequence(path, options, print, \"consequent\");\n}\n\nconst isClassProperty = ({ type }) =>\n  type === \"ClassProperty\" ||\n  type === \"PropertyDefinition\" ||\n  type === \"ClassPrivateProperty\";\n/**\n * @returns {boolean}\n */\nfunction shouldPrintSemicolonAfterClassProperty(node, nextNode) {\n  const name = node.key && node.key.name;\n  // this isn't actually possible yet with most parsers available today\n  // so isn't properly tested yet.\n  if (\n    (name === \"static\" || name === \"get\" || name === \"set\") &&\n    !node.value &&\n    !node.typeAnnotation\n  ) {\n    return true;\n  }\n\n  if (!nextNode) {\n    return false;\n  }\n\n  if (\n    nextNode.static ||\n    nextNode.accessibility // TypeScript\n  ) {\n    return false;\n  }\n\n  if (!nextNode.computed) {\n    const name = nextNode.key && nextNode.key.name;\n    if (name === \"in\" || name === \"instanceof\") {\n      return true;\n    }\n  }\n\n  // Flow variance sigil +/- requires semi if there's no\n  // \"declare\" or \"static\" keyword before it.\n  if (\n    isClassProperty(nextNode) &&\n    nextNode.variance &&\n    !nextNode.static &&\n    !nextNode.declare\n  ) {\n    return true;\n  }\n\n  switch (nextNode.type) {\n    case \"ClassProperty\":\n    case \"PropertyDefinition\":\n    case \"TSAbstractPropertyDefinition\":\n      return nextNode.computed;\n    case \"MethodDefinition\": // Flow\n    case \"TSAbstractMethodDefinition\": // TypeScript\n    case \"ClassMethod\":\n    case \"ClassPrivateMethod\": {\n      // Babel\n      const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;\n      if (isAsync || nextNode.kind === \"get\" || nextNode.kind === \"set\") {\n        return false;\n      }\n\n      const isGenerator = nextNode.value\n        ? nextNode.value.generator\n        : nextNode.generator;\n      if (nextNode.computed || isGenerator) {\n        return true;\n      }\n\n      return false;\n    }\n\n    case \"TSIndexSignature\":\n      return true;\n  }\n\n  /* istanbul ignore next */\n  return false;\n}\n\nmodule.exports = {\n  printBody,\n  printSwitchCaseConsequent,\n};"
    },
    "2": {
        "bug_file": "src/language-js/print/comment.js",
        "compressed": "NO",
        "line_numbers": 80,
        "compressed_line_numbers": 80,
        "compressed_bug_file_content": "\"use strict\";\n\nconst { hasNewline } = require(\"../../common/util.js\");\nconst {\n  builders: { join, hardline },\n  utils: { replaceTextEndOfLine },\n} = require(\"../../document/index.js\");\n\nconst { isLineComment } = require(\"../utils/index.js\");\nconst { locStart, locEnd } = require(\"../loc.js\");\nconst isBlockComment = require(\"../utils/is-block-comment.js\");\n\nfunction printComment(commentPath, options) {\n  const comment = commentPath.getValue();\n\n  if (isLineComment(comment)) {\n    // Supports `//`, `#!`, `<!--`, and `-->`\n    return options.originalText\n      .slice(locStart(comment), locEnd(comment))\n      .trimEnd();\n  }\n\n  if (isBlockComment(comment)) {\n    if (isIndentableBlockComment(comment)) {\n      const printed = printIndentableBlockComment(comment);\n      // We need to prevent an edge case of a previous trailing comment\n      // printed as a `lineSuffix` which causes the comments to be\n      // interleaved. See https://github.com/prettier/prettier/issues/4412\n      if (\n        comment.trailing &&\n        !hasNewline(options.originalText, locStart(comment), {\n          backwards: true,\n        })\n      ) {\n        return [hardline, printed];\n      }\n      return printed;\n    }\n\n    const commentEnd = locEnd(comment);\n    const isInsideFlowComment =\n      options.originalText.slice(commentEnd - 3, commentEnd) === \"*-/\";\n    return [\n      \"/*\",\n      replaceTextEndOfLine(comment.value),\n      isInsideFlowComment ? \"*-/\" : \"*/\",\n    ];\n  }\n\n  /* istanbul ignore next */\n  throw new Error(\"Not a comment: \" + JSON.stringify(comment));\n}\n\nfunction isIndentableBlockComment(comment) {\n  // If the comment has multiple lines and every line starts with a star\n  // we can fix the indentation of each line. The stars in the `/*` and\n  // `*/` delimiters are not included in the comment value, so add them\n  // back first.\n  const lines = `*${comment.value}*`.split(\"\\n\");\n  return lines.length > 1 && lines.every((line) => line.trim()[0] === \"*\");\n}\n\nfunction printIndentableBlockComment(comment) {\n  const lines = comment.value.split(\"\\n\");\n\n  return [\n    \"/*\",\n    join(\n      hardline,\n      lines.map((line, index) =>\n        index === 0\n          ? line.trimEnd()\n          : \" \" + (index < lines.length - 1 ? line.trim() : line.trimStart())\n      )\n    ),\n    \"*/\",\n  ];\n}\n\nmodule.exports = { printComment };"
    },
    "3": {
        "bug_file": "src/main/core.js",
        "compressed": "NO",
        "line_numbers": 366,
        "compressed_line_numbers": 366,
        "compressed_bug_file_content": "\"use strict\";\n\n// Use `diff/lib/diff/array.js` instead of `diff` to reduce bundle size\nconst { diffArrays } = require(\"diff/lib/diff/array.js\");\n\nconst {\n  printer: { printDocToString },\n  debug: { printDocToDebug },\n} = require(\"../document/index.js\");\nconst { getAlignmentSize } = require(\"../common/util.js\");\nconst {\n  guessEndOfLine,\n  convertEndOfLineToChars,\n  countEndOfLineChars,\n  normalizeEndOfLine,\n} = require(\"../common/end-of-line.js\");\nconst normalizeOptions = require(\"./options.js\").normalize;\nconst massageAST = require(\"./massage-ast.js\");\nconst comments = require(\"./comments.js\");\nconst parser = require(\"./parser.js\");\nconst printAstToDoc = require(\"./ast-to-doc.js\");\nconst rangeUtil = require(\"./range-util.js\");\n\nconst BOM = \"\\uFEFF\";\n\nconst CURSOR = Symbol(\"cursor\");\n\nfunction attachComments(text, ast, opts) {\n  const astComments = ast.comments;\n  if (astComments) {\n    delete ast.comments;\n    comments.attach(astComments, ast, text, opts);\n  }\n  opts[Symbol.for(\"comments\")] = astComments || [];\n  opts[Symbol.for(\"tokens\")] = ast.tokens || [];\n  opts.originalText = text;\n  return astComments;\n}\n\nfunction coreFormat(originalText, opts, addAlignmentSize = 0) {\n  if (!originalText || originalText.trim().length === 0) {\n    return { formatted: \"\", cursorOffset: -1, comments: [] };\n  }\n\n  const { ast, text } = parser.parse(originalText, opts);\n\n  if (opts.cursorOffset >= 0) {\n    const nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);\n    if (nodeResult && nodeResult.node) {\n      opts.cursorNode = nodeResult.node;\n    }\n  }\n\n  const astComments = attachComments(text, ast, opts);\n  const doc = printAstToDoc(ast, opts, addAlignmentSize);\n\n  const result = printDocToString(doc, opts);\n\n  comments.ensureAllCommentsPrinted(astComments);\n  // Remove extra leading indentation as well as the added indentation after last newline\n  if (addAlignmentSize > 0) {\n    const trimmed = result.formatted.trim();\n\n    if (result.cursorNodeStart !== undefined) {\n      result.cursorNodeStart -= result.formatted.indexOf(trimmed);\n    }\n\n    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);\n  }\n\n  if (opts.cursorOffset >= 0) {\n    let oldCursorNodeStart;\n    let oldCursorNodeText;\n\n    let cursorOffsetRelativeToOldCursorNode;\n\n    let newCursorNodeStart;\n    let newCursorNodeText;\n\n    if (opts.cursorNode && result.cursorNodeText) {\n      oldCursorNodeStart = opts.locStart(opts.cursorNode);\n      oldCursorNodeText = text.slice(\n        oldCursorNodeStart,\n        opts.locEnd(opts.cursorNode)\n      );\n\n      cursorOffsetRelativeToOldCursorNode =\n        opts.cursorOffset - oldCursorNodeStart;\n\n      newCursorNodeStart = result.cursorNodeStart;\n      newCursorNodeText = result.cursorNodeText;\n    } else {\n      oldCursorNodeStart = 0;\n      oldCursorNodeText = text;\n\n      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;\n\n      newCursorNodeStart = 0;\n      newCursorNodeText = result.formatted;\n    }\n\n    if (oldCursorNodeText === newCursorNodeText) {\n      return {\n        formatted: result.formatted,\n        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,\n        comments: astComments,\n      };\n    }\n\n    // diff old and new cursor node texts, with a special cursor\n    // symbol inserted to find out where it moves to\n\n    const oldCursorNodeCharArray = [...oldCursorNodeText];\n    oldCursorNodeCharArray.splice(\n      cursorOffsetRelativeToOldCursorNode,\n      0,\n      CURSOR\n    );\n\n    const newCursorNodeCharArray = [...newCursorNodeText];\n\n    const cursorNodeDiff = diffArrays(\n      oldCursorNodeCharArray,\n      newCursorNodeCharArray\n    );\n\n    let cursorOffset = newCursorNodeStart;\n    for (const entry of cursorNodeDiff) {\n      if (entry.removed) {\n        if (entry.value.includes(CURSOR)) {\n          break;\n        }\n      } else {\n        cursorOffset += entry.count;\n      }\n    }\n\n    return { formatted: result.formatted, cursorOffset, comments: astComments };\n  }\n\n  return {\n    formatted: result.formatted,\n    cursorOffset: -1,\n    comments: astComments,\n  };\n}\n\nfunction formatRange(originalText, opts) {\n  const { ast, text } = parser.parse(originalText, opts);\n  const { rangeStart, rangeEnd } = rangeUtil.calculateRange(text, opts, ast);\n  const rangeString = text.slice(rangeStart, rangeEnd);\n\n  // Try to extend the range backwards to the beginning of the line.\n  // This is so we can detect indentation correctly and restore it.\n  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0\n  const rangeStart2 = Math.min(\n    rangeStart,\n    text.lastIndexOf(\"\\n\", rangeStart) + 1\n  );\n  const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];\n\n  const alignmentSize = getAlignmentSize(indentString, opts.tabWidth);\n\n  const rangeResult = coreFormat(\n    rangeString,\n    {\n      ...opts,\n      rangeStart: 0,\n      rangeEnd: Number.POSITIVE_INFINITY,\n      // Track the cursor offset only if it's within our range\n      cursorOffset:\n        opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd\n          ? opts.cursorOffset - rangeStart\n          : -1,\n      // Always use `lf` to format, we'll replace it later\n      endOfLine: \"lf\",\n    },\n    alignmentSize\n  );\n\n  // Since the range contracts to avoid trailing whitespace,\n  // we need to remove the newline that was inserted by the `format` call.\n  const rangeTrimmed = rangeResult.formatted.trimEnd();\n\n  let { cursorOffset } = opts;\n  if (cursorOffset > rangeEnd) {\n    // handle the case where the cursor was past the end of the range\n    cursorOffset += rangeTrimmed.length - rangeString.length;\n  } else if (rangeResult.cursorOffset >= 0) {\n    // handle the case where the cursor was in the range\n    cursorOffset = rangeResult.cursorOffset + rangeStart;\n  }\n  // keep the cursor as it was if it was before the start of the range\n\n  let formatted =\n    text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);\n  if (opts.endOfLine !== \"lf\") {\n    const eol = convertEndOfLineToChars(opts.endOfLine);\n    if (cursorOffset >= 0 && eol === \"\\r\\n\") {\n      cursorOffset += countEndOfLineChars(\n        formatted.slice(0, cursorOffset),\n        \"\\n\"\n      );\n    }\n\n    formatted = formatted.replace(/\\n/g, eol);\n  }\n\n  return { formatted, cursorOffset, comments: rangeResult.comments };\n}\n\nfunction ensureIndexInText(text, index, defaultValue) {\n  if (\n    typeof index !== \"number\" ||\n    Number.isNaN(index) ||\n    index < 0 ||\n    index > text.length\n  ) {\n    return defaultValue;\n  }\n\n  return index;\n}\n\nfunction normalizeIndexes(text, options) {\n  let { cursorOffset, rangeStart, rangeEnd } = options;\n  cursorOffset = ensureIndexInText(text, cursorOffset, -1);\n  rangeStart = ensureIndexInText(text, rangeStart, 0);\n  rangeEnd = ensureIndexInText(text, rangeEnd, text.length);\n\n  return { ...options, cursorOffset, rangeStart, rangeEnd };\n}\n\nfunction normalizeInputAndOptions(text, options) {\n  let { cursorOffset, rangeStart, rangeEnd, endOfLine } = normalizeIndexes(\n    text,\n    options\n  );\n\n  const hasBOM = text.charAt(0) === BOM;\n\n  if (hasBOM) {\n    text = text.slice(1);\n    cursorOffset--;\n    rangeStart--;\n    rangeEnd--;\n  }\n\n  if (endOfLine === \"auto\") {\n    endOfLine = guessEndOfLine(text);\n  }\n\n  // get rid of CR/CRLF parsing\n  if (text.includes(\"\\r\")) {\n    const countCrlfBefore = (index) =>\n      countEndOfLineChars(text.slice(0, Math.max(index, 0)), \"\\r\\n\");\n\n    cursorOffset -= countCrlfBefore(cursorOffset);\n    rangeStart -= countCrlfBefore(rangeStart);\n    rangeEnd -= countCrlfBefore(rangeEnd);\n\n    text = normalizeEndOfLine(text);\n  }\n\n  return {\n    hasBOM,\n    text,\n    options: normalizeIndexes(text, {\n      ...options,\n      cursorOffset,\n      rangeStart,\n      rangeEnd,\n      endOfLine,\n    }),\n  };\n}\n\nfunction hasPragma(text, options) {\n  const selectedParser = parser.resolveParser(options);\n  return !selectedParser.hasPragma || selectedParser.hasPragma(text);\n}\n\nfunction formatWithCursor(originalText, originalOptions) {\n  let { hasBOM, text, options } = normalizeInputAndOptions(\n    originalText,\n    normalizeOptions(originalOptions)\n  );\n\n  if (\n    (options.rangeStart >= options.rangeEnd && text !== \"\") ||\n    (options.requirePragma && !hasPragma(text, options))\n  ) {\n    return {\n      formatted: originalText,\n      cursorOffset: originalOptions.cursorOffset,\n      comments: [],\n    };\n  }\n\n  let result;\n\n  if (options.rangeStart > 0 || options.rangeEnd < text.length) {\n    result = formatRange(text, options);\n  } else {\n    if (\n      !options.requirePragma &&\n      options.insertPragma &&\n      options.printer.insertPragma &&\n      !hasPragma(text, options)\n    ) {\n      text = options.printer.insertPragma(text);\n    }\n    result = coreFormat(text, options);\n  }\n\n  if (hasBOM) {\n    result.formatted = BOM + result.formatted;\n\n    if (result.cursorOffset >= 0) {\n      result.cursorOffset++;\n    }\n  }\n\n  return result;\n}\n\nmodule.exports = {\n  formatWithCursor,\n\n  parse(originalText, originalOptions, massage) {\n    const { text, options } = normalizeInputAndOptions(\n      originalText,\n      normalizeOptions(originalOptions)\n    );\n    const parsed = parser.parse(text, options);\n    if (massage) {\n      parsed.ast = massageAST(parsed.ast, options);\n    }\n    return parsed;\n  },\n\n  formatAST(ast, options) {\n    options = normalizeOptions(options);\n    const doc = printAstToDoc(ast, options);\n    return printDocToString(doc, options);\n  },\n\n  // Doesn't handle shebang for now\n  formatDoc(doc, options) {\n    return formatWithCursor(printDocToDebug(doc), {\n      ...options,\n      parser: \"__js_expression\",\n    }).formatted;\n  },\n\n  printToDoc(originalText, options) {\n    options = normalizeOptions(options);\n    const { ast, text } = parser.parse(originalText, options);\n    attachComments(text, ast, options);\n    return printAstToDoc(ast, options);\n  },\n\n  printDocToString(doc, options) {\n    return printDocToString(doc, normalizeOptions(options));\n  },\n};"
    }
}