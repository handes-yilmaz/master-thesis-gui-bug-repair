{
    "1": {
        "bug_file": "src/language-js/parse/typescript.js",
        "compressed": "NO",
        "line_numbers": 80,
        "compressed_line_numbers": 80,
        "compressed_bug_file_content": "import { parseWithNodeMaps } from \"@typescript-eslint/typescript-estree/dist/parser.js\";\nimport createError from \"../../common/parser-create-error.js\";\nimport tryCombinations from \"../../utils/try-combinations.js\";\nimport createParser from \"./utils/create-parser.js\";\nimport replaceHashbang from \"./utils/replace-hashbang.js\";\nimport postprocess from \"./postprocess/index.js\";\nimport { throwErrorForInvalidNodes } from \"./postprocess/typescript.js\";\n\n/** @type {import(\"@typescript-eslint/typescript-estree\").TSESTreeOptions} */\nconst parseOptions = {\n  // `jest@<=26.4.2` rely on `loc`\n  // https://github.com/facebook/jest/issues/10444\n  // Set `loc` and `range` to `true` also prevent AST traverse\n  // https://github.com/typescript-eslint/typescript-eslint/blob/733b3598c17d3a712cf6f043115587f724dbe3ef/packages/typescript-estree/src/ast-converter.ts#L38\n  loc: true,\n  range: true,\n  comment: true,\n  jsx: true,\n  tokens: true,\n  loggerFn: false,\n  project: [],\n};\n\nfunction createParseError(error) {\n  const { message, lineNumber, column } = error;\n\n  /* c8 ignore next 3 */\n  if (typeof lineNumber !== \"number\") {\n    return error;\n  }\n\n  return createError(message, {\n    loc: {\n      start: { line: lineNumber, column: column + 1 },\n    },\n    cause: error,\n  });\n}\n\nfunction parse(text) {\n  const textToParse = replaceHashbang(text);\n  const jsx = isProbablyJsx(text);\n\n  let result;\n  try {\n    result = tryCombinations([\n      // Try passing with our best guess first.\n      () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx }),\n      // But if we get it wrong, try the opposite.\n      () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx: !jsx }),\n    ]);\n  } catch ({\n    errors: [\n      // Suppose our guess is correct, throw the first error\n      error,\n    ],\n  }) {\n    throw createParseError(error);\n  }\n\n  throwErrorForInvalidNodes(result, text);\n\n  return postprocess(result.ast, { parser: \"typescript\", text });\n}\n\n/**\n * Use a naive regular expression to detect JSX\n */\nfunction isProbablyJsx(text) {\n  return new RegExp(\n    [\n      \"(?:^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string\n      \"|\",\n      \"(?:^[^/]{2}.*/>)\", // Contains \"/>\" on line not starting with \"//\"\n    ].join(\"\"),\n    \"m\"\n  ).test(text);\n}\n\nexport const typescript = createParser(parse);"
    },
    "2": {
        "bug_file": "src/language-js/print/type-parameters.js",
        "compressed": "NO",
        "line_numbers": 177,
        "compressed_line_numbers": 177,
        "compressed_bug_file_content": "import { printDanglingComments } from \"../../main/comments/print.js\";\nimport {\n  join,\n  line,\n  hardline,\n  softline,\n  group,\n  indent,\n  ifBreak,\n} from \"../../document/builders.js\";\nimport {\n  isTestCall,\n  hasComment,\n  CommentCheckFlags,\n  isTSXFile,\n  shouldPrintComma,\n  getFunctionParameters,\n  isObjectType,\n} from \"../utils/index.js\";\nimport createGroupIdMapper from \"../../utils/create-group-id-mapper.js\";\nimport {\n  printTypeAnnotationProperty,\n  shouldHugType,\n} from \"./type-annotation.js\";\nimport { isArrowFunctionVariableDeclarator } from \"./assignment.js\";\nimport { printTypeScriptMappedTypeModifier } from \"./mapped-type.js\";\n\nconst getTypeParametersGroupId = createGroupIdMapper(\"typeParameters\");\n\nfunction printTypeParameters(path, options, print, paramsKey) {\n  const { node } = path;\n\n  if (!node[paramsKey]) {\n    return \"\";\n  }\n\n  // for TypeParameterDeclaration typeParameters is a single node\n  if (!Array.isArray(node[paramsKey])) {\n    return print(paramsKey);\n  }\n\n  const grandparent = path.getNode(2);\n  const isParameterInTestCall = grandparent && isTestCall(grandparent);\n\n  const isArrowFunctionVariable = path.match(\n    (node) =>\n      !(node[paramsKey].length === 1 && isObjectType(node[paramsKey][0])),\n    undefined,\n    (node, name) => name === \"typeAnnotation\",\n    (node) => node.type === \"Identifier\",\n    isArrowFunctionVariableDeclarator\n  );\n\n  const shouldInline =\n    node[paramsKey].length === 0 ||\n    (!isArrowFunctionVariable &&\n      (isParameterInTestCall ||\n        (node[paramsKey].length === 1 &&\n          (node[paramsKey][0].type === \"NullableTypeAnnotation\" ||\n            shouldHugType(node[paramsKey][0])))));\n\n  if (shouldInline) {\n    return [\n      \"<\",\n      join(\", \", path.map(print, paramsKey)),\n      printDanglingCommentsForInline(path, options),\n      \">\",\n    ];\n  }\n\n  // Keep comma if the file extension is .tsx and\n  // has one type parameter that isn't extend with any types.\n  // Because, otherwise formatted result will be invalid as tsx.\n  const trailingComma =\n    node.type === \"TSTypeParameterInstantiation\" // https://github.com/microsoft/TypeScript/issues/21984\n      ? \"\"\n      : getFunctionParameters(node).length === 1 &&\n        isTSXFile(options) &&\n        !node[paramsKey][0].constraint &&\n        path.parent.type === \"ArrowFunctionExpression\"\n      ? \",\"\n      : shouldPrintComma(options)\n      ? ifBreak(\",\")\n      : \"\";\n\n  return group(\n    [\n      \"<\",\n      indent([softline, join([\",\", line], path.map(print, paramsKey))]),\n      trailingComma,\n      softline,\n      \">\",\n    ],\n    { id: getTypeParametersGroupId(node) }\n  );\n}\n\nfunction printDanglingCommentsForInline(path, options) {\n  const { node } = path;\n  if (!hasComment(node, CommentCheckFlags.Dangling)) {\n    return \"\";\n  }\n  const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);\n  const printed = printDanglingComments(path, options, {\n    indent: !hasOnlyBlockComments,\n  });\n  if (hasOnlyBlockComments) {\n    return printed;\n  }\n  return [printed, hardline];\n}\n\nfunction printTypeParameter(path, options, print) {\n  const { node, parent } = path;\n\n  /**\n   * @type {import(\"../../document/builders.js\").Doc[]}\n   */\n  const parts = [node.type === \"TSTypeParameter\" && node.const ? \"const \" : \"\"];\n\n  const name = node.type === \"TSTypeParameter\" ? print(\"name\") : node.name;\n\n  if (parent.type === \"TSMappedType\") {\n    if (parent.readonly) {\n      parts.push(\n        printTypeScriptMappedTypeModifier(parent.readonly, \"readonly\"),\n        \" \"\n      );\n    }\n    parts.push(\"[\", name);\n    if (node.constraint) {\n      parts.push(\" in \", print(\"constraint\"));\n    }\n    if (parent.nameType) {\n      parts.push(\n        \" as \",\n        path.callParent(() => print(\"nameType\"))\n      );\n    }\n    parts.push(\"]\");\n    return parts;\n  }\n\n  if (node.variance) {\n    parts.push(print(\"variance\"));\n  }\n\n  if (node.in) {\n    parts.push(\"in \");\n  }\n\n  if (node.out) {\n    parts.push(\"out \");\n  }\n\n  parts.push(name);\n\n  if (node.bound) {\n    if (node.usesExtendsBound) {\n      parts.push(\" extends \");\n    }\n\n    parts.push(printTypeAnnotationProperty(path, print, \"bound\"));\n  }\n\n  if (node.constraint) {\n    parts.push(\" extends\", indent([line, print(\"constraint\")]));\n  }\n\n  if (node.default) {\n    parts.push(\" = \", print(\"default\"));\n  }\n\n  return group(parts);\n}\n\nexport { printTypeParameter, printTypeParameters, getTypeParametersGroupId };"
    },
    "3": {
        "bug_file": "src/language-js/printer-estree.js",
        "compressed": "YES",
        "line_numbers": 750,
        "compressed_line_numbers": 140,
        "compressed_bug_file_content": "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.\nimport { printDanglingComments } from \"../main/comments/print.js\";\nimport printIgnored from \"../main/print-ignored.js\";\nimport hasNewline from \"../utils/has-newline.js\";\nimport {\n\n\nimport { replaceEndOfLine, inheritLabel } from \"../document/utils.js\";\nimport UnexpectedNodeError from \"../utils/unexpected-node-error.js\";\nimport isNonEmptyArray from \"../utils/is-non-empty-array.js\";\n\nimport pathNeedsParens from \"./needs-parens.js\";\nimport {\n\n\nimport { locStart, locEnd } from \"./loc.js\";\nimport isBlockComment from \"./utils/is-block-comment.js\";\nimport isIgnored from \"./utils/is-ignored.js\";\n\nimport { printHtmlBinding } from \"./print/html-binding.js\";\nimport { printAngular } from \"./print/angular.js\";\nimport { printJsx } from \"./print/jsx.js\";\nimport { printFlow } from \"./print/flow.js\";\nimport { printTypescript } from \"./print/typescript.js\";\nimport {\n\n\nimport {\n\n\nimport { printTernary } from \"./print/ternary.js\";\nimport {\n\n\nimport { printArray } from \"./print/array.js\";\nimport { printObject } from \"./print/object.js\";\nimport {\n\n\nimport { printProperty } from \"./print/property.js\";\nimport {\n\n\nimport { printCallExpression } from \"./print/call-expression.js\";\nimport {\n\n\nimport { printBinaryishExpression } from \"./print/binaryish.js\";\nimport { printStatementSequence } from \"./print/statement.js\";\nimport { printMemberExpression } from \"./print/member.js\";\nimport { printBlock, printBlockBody } from \"./print/block.js\";\nimport { printLiteral } from \"./print/literal.js\";\nimport { printDecorators } from \"./print/decorators.js\";\nimport { printTypeAnnotationProperty } from \"./print/type-annotation.js\";\nimport { shouldPrintLeadingSemicolon } from \"./print/semicolon.js\";\nimport { printExpressionStatement } from \"./print/expression-statement.js\";\n\n/**\n * @typedef {import(\"../common/ast-path.js\").default} AstPath\n * @typedef {import(\"../document/builders.js\").Doc} Doc\n */\n\n// Their decorators are handled themselves, and they don't need parentheses or leading semicolons\n\n\n/**\n * @param {AstPath} path\n * @param {*} options\n * @param {*} print\n * @param {*} [args]\n * @returns {Doc}\n */\n\n\n  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons\n\n\n/**\n * @param {AstPath} path\n * @param {*} options\n * @param {*} print\n * @param {*} [args]\n * @returns {Doc}\n */\n\n\n  /** @type{Doc[]} */\n\n\n    // Babel extension.\n\n\n    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.\n\n\n          // avoid printing `await (await` on one line\n\n\n    // Babel 6\n\n\n        // For ExpressionStatements and for-loop heads, which are among\n        // the few places a SequenceExpression appears unparenthesized, we want\n        // to indent expressions after the first.\n\n\n      // We generally want to terminate all variable declarations with a\n      // semicolon, except when they in the () part of for loops.\n\n\n        // Indent first var to comply with eslint one-var rule\n\n\n      // We want to keep dangling comments above the loop to stay consistent.\n      // Any comment positioned between the for statement and the parentheses\n      // is going to be printed before the statement.\n\n\n    // Note: ignoring n.lexical because it has no printing consequences.\n\n\n    // JSX extensions below.\n\n\n    // For hack-style pipeline\n\n\n      /* c8 ignore next */\n\n\nexport const experimentalFeatures = {\n  // TODO: Make this default behavior\n\n\nexport { genericPrint as print };\nexport * from \"./comments/printer-methods.js\";\nexport { default as embed } from \"./embed/index.js\";\nexport { default as massageAstNode } from \"./clean.js\";\nexport { insertPragma } from \"./pragma.js\";\nexport { default as getVisitorKeys } from \"./traverse/get-visitor-keys.js\";\n"
    }
}