{
    ".codecov.yml": {},
    ".editorconfig": {},
    ".eslintignore": {},
    ".eslintrc.cjs": {},
    ".git-blame-ignore-revs": {},
    ".gitattributes": {},
    ".gitignore": {},
    ".gitpod.yml": {},
    ".ignore": {},
    ".prettierignore": {},
    ".prettierrc": {},
    ".yarnrc.yml": {},
    "CHANGELOG.md": {},
    "CODE_OF_CONDUCT.md": {},
    "CONTRIBUTING.md": {},
    "LICENSE": {},
    "README.md": {},
    "commands.md": {},
    "cspell.json": {},
    "index.js": {
        "classes": [],
        "functions": [],
        "text": [
            "export * from \"./src/index.js\";"
        ]
    },
    "jest.config.js": {
        "classes": [],
        "functions": [],
        "text": [
            "import path from \"node:path\";",
            "import createEsmUtils from \"esm-utils\";",
            "import installPrettier from \"./tests/config/install-prettier.js\";",
            "",
            "const { dirname: PROJECT_ROOT } = createEsmUtils(import.meta);",
            "const isProduction = process.env.NODE_ENV === \"production\";",
            "// Disabled https://github.com/nicolo-ribaudo/jest-light-runner/pull/13",
            "// const ENABLE_CODE_COVERAGE = Boolean(process.env.ENABLE_CODE_COVERAGE);",
            "const TEST_STANDALONE = Boolean(process.env.TEST_STANDALONE);",
            "const INSTALL_PACKAGE = Boolean(process.env.INSTALL_PACKAGE);",
            "// When debugging production test, this flag can skip installing package",
            "const SKIP_PRODUCTION_INSTALL = Boolean(process.env.SKIP_PRODUCTION_INSTALL);",
            "const SKIP_TESTS_WITH_NEW_SYNTAX = process.versions.node.startsWith(\"14.\");",
            "",
            "let PRETTIER_DIR = isProduction",
            "  ? path.join(PROJECT_ROOT, \"dist\")",
            "  : PROJECT_ROOT;",
            "let PRETTIER_INSTALLED_DIR = \"\";",
            "if (",
            "  INSTALL_PACKAGE ||",
            "  (isProduction && !TEST_STANDALONE && !SKIP_PRODUCTION_INSTALL)",
            ") {",
            "  PRETTIER_INSTALLED_DIR = installPrettier(PRETTIER_DIR);",
            "  PRETTIER_DIR = path.join(PRETTIER_INSTALLED_DIR, \"node_modules/prettier\");",
            "}",
            "process.env.PRETTIER_INSTALLED_DIR = PRETTIER_INSTALLED_DIR;",
            "process.env.PRETTIER_DIR = PRETTIER_DIR;",
            "",
            "const testPathIgnorePatterns = [];",
            "if (TEST_STANDALONE) {",
            "  testPathIgnorePatterns.push(\"<rootDir>/tests/integration/\");",
            "}",
            "if (isProduction) {",
            "  // Only run unit test for development",
            "  testPathIgnorePatterns.push(\"<rootDir>/tests/unit/\");",
            "} else {",
            "  // Only test bundles for production",
            "  testPathIgnorePatterns.push(",
            "    \"<rootDir>/tests/integration/__tests__/bundle.js\"",
            "  );",
            "}",
            "",
            "if (SKIP_TESTS_WITH_NEW_SYNTAX) {",
            "  testPathIgnorePatterns.push(",
            "    \"<rootDir>/tests/integration/__tests__/help-options.js\",",
            "    \"<rootDir>/tests/integration/__tests__/plugin-parsers.js\",",
            "    \"<rootDir>/tests/integration/__tests__/normalize-doc.js\",",
            "    \"<rootDir>/tests/integration/__tests__/doc-utils-clean-doc.js\"",
            "  );",
            "}",
            "",
            "const config = {",
            "  setupFiles: [",
            "    \"<rootDir>/tests/config/format-test-setup.js\",",
            "    \"<rootDir>/tests/integration/integration-test-setup.js\",",
            "  ],",
            "  runner: \"jest-light-runner\",",
            "  snapshotSerializers: [",
            "    \"jest-snapshot-serializer-raw\",",
            "    \"jest-snapshot-serializer-ansi\",",
            "  ],",
            "  testMatch: [",
            "    \"<rootDir>/tests/format/**/jsfmt.spec.js\",",
            "    \"<rootDir>/tests/integration/__tests__/**/*.js\",",
            "    \"<rootDir>/tests/unit/**/*.js\",",
            "    \"<rootDir>/tests/dts/unit/**/*.js\",",
            "  ],",
            "  testPathIgnorePatterns,",
            "  // collectCoverage: ENABLE_CODE_COVERAGE,",
            "  collectCoverageFrom: [\"<rootDir>/src/**/*.js\", \"<rootDir>/bin/**/*.js\"],",
            "  coveragePathIgnorePatterns: [",
            "    \"<rootDir>/src/standalone.js\",",
            "    \"<rootDir>/src/document/debug.js\",",
            "  ],",
            "  coverageReporters: [\"text\", \"lcov\"],",
            "  moduleNameMapper: {",
            "    \"prettier-local\": \"<rootDir>/tests/config/prettier-entry.js\",",
            "    \"prettier-standalone\": \"<rootDir>/tests/config/require-standalone.cjs\",",
            "  },",
            "  modulePathIgnorePatterns: [",
            "    \"<rootDir>/dist\",",
            "    \"<rootDir>/website\",",
            "    \"<rootDir>/scripts/release\",",
            "  ],",
            "  transform: {},",
            "  watchPlugins: [",
            "    \"jest-watch-typeahead/filename\",",
            "    \"jest-watch-typeahead/testname\",",
            "  ],",
            "};",
            "",
            "export default config;"
        ]
    },
    "netlify.toml": {},
    "package.json": {},
    "standalone.js": {
        "classes": [],
        "functions": [],
        "text": [
            "export * from \"./src/standalone.js\";"
        ]
    },
    "tsconfig.json": {},
    "yarn.lock": {},
    "bin": {
        "prettier.cjs": {},
        "prettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "#!/usr/bin/env node",
                "",
                "// Add this file so we can use `node bin/prettier` or `node bin/prettier.js`",
                "// instead of `node bin/prettier.cjs`.",
                "",
                "import \"./prettier.cjs\";"
            ]
        }
    },
    "changelog_unreleased": {
        "BLOG_POST_INTRO_TEMPLATE.md": {},
        "TEMPLATE.md": {},
        "angular": {
            ".gitkeep": {},
            "13609.md": {},
            "14216.md": {},
            "14658.md": {}
        },
        "api": {
            ".gitkeep": {},
            "11830.md": {},
            "12574.md": {},
            "12740.md": {},
            "12748.md": {},
            "13130.md": {},
            "13201.md": {},
            "13203.md": {},
            "13220.md": {},
            "13250.md": {},
            "13268.md": {},
            "13397.md": {},
            "13532-2.md": {},
            "14108.md": {},
            "14212.md": {},
            "14317.md": {},
            "14576.md": {}
        },
        "cli": {
            ".gitkeep": {},
            "11369.md": {},
            "13204.md": {},
            "14332.md": {},
            "14333.md": {}
        },
        "css": {
            ".gitkeep": {},
            "13402.md": {},
            "14208.md": {},
            "14476.md": {},
            "7933.md": {},
            "9209.md": {}
        },
        "flow": {
            ".gitkeep": {},
            "13396.md": {},
            "13687.md": {},
            "14085.md": {},
            "14573.md": {},
            "14619.md": {}
        },
        "graphql": {
            ".gitkeep": {},
            "12835.md": {}
        },
        "handlebars": {
            ".gitkeep": {}
        },
        "html": {
            ".gitkeep": {},
            "13578.md": {},
            "14400.md": {},
            "14615.md": {},
            "7391.md": {}
        },
        "javascript": {
            ".gitkeep": {},
            "10714.md": {},
            "13143.md": {},
            "13340.md": {},
            "13341.md": {},
            "13391.md": {},
            "13410.md": {},
            "13438.md": {},
            "13445.md": {},
            "13532.md": {},
            "13621.md": {},
            "13752.md": {},
            "13771.md": {},
            "14065.md": {},
            "14163.md": {},
            "14192.md": {},
            "14314.md": {},
            "14391.md": {},
            "14406.md": {},
            "14409.md": {},
            "14599.md": {}
        },
        "json": {
            ".gitkeep": {}
        },
        "less": {
            ".gitkeep": {},
            "11343.md": {},
            "14109.md": {}
        },
        "lwc": {
            ".gitkeep": {}
        },
        "markdown": {
            ".gitkeep": {},
            "11597.md": {},
            "13590.md": {}
        },
        "mdx": {
            ".gitkeep": {}
        },
        "misc": {
            ".gitkeep": {}
        },
        "scss": {
            ".gitkeep": {},
            "13487.md": {}
        },
        "typescript": {
            ".gitkeep": {},
            "13427.md": {},
            "13608.md": {},
            "13860.md": {},
            "14171.md": {},
            "14402.md": {},
            "14654.md": {},
            "14659.md": {},
            "14672.md": {}
        },
        "vue": {
            ".gitkeep": {},
            "14401.md": {},
            "14506.md": {},
            "14542.md": {},
            "14557.md": {},
            "14587.md": {}
        },
        "yaml": {
            ".gitkeep": {}
        }
    },
    "src": {
        "index.cjs": {},
        "index.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// Copied from `@types/prettier`",
                "// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5bb07fc4b087cb7ee91084afa6fe750551a7bbb1/types/prettier/index.d.ts",
                "",
                "// Minimum TypeScript Version: 4.2",
                "",
                "// Add `export {}` here to shut off automatic exporting from index.d.ts. There",
                "// are quite a few utility types here that don't need to be shipped with the",
                "// exported module.",
                "export {};",
                "",
                "import { builders, printer, utils } from \"./document/public.js\";",
                "",
                "export namespace doc {",
                "  export { builders, printer, utils };",
                "}",
                "",
                "// This utility is here to handle the case where you have an explicit union",
                "// between string literals and the generic string type. It would normally",
                "// resolve out to just the string type, but this generic LiteralUnion maintains",
                "// the intellisense of the original union.",
                "//",
                "// It comes from this issue: microsoft/TypeScript#29729:",
                "//   https://github.com/microsoft/TypeScript/issues/29729#issuecomment-700527227",
                "export type LiteralUnion<T extends U, U = string> =",
                "  | T",
                "  | (Pick<U, never> & { _?: never | undefined });",
                "",
                "export type AST = any;",
                "export type Doc = doc.builders.Doc;",
                "",
                "// The type of elements that make up the given array T.",
                "type ArrayElement<T> = T extends Array<infer E> ? E : never;",
                "",
                "// A union of the properties of the given object that are arrays.",
                "type ArrayProperties<T> = {",
                "  [K in keyof T]: NonNullable<T[K]> extends any[] ? K : never;",
                "}[keyof T];",
                "",
                "// A union of the properties of the given array T that can be used to index it.",
                "// If the array is a tuple, then that's going to be the explicit indices of the",
                "// array, otherwise it's going to just be number.",
                "type IndexProperties<T extends { length: number }> = IsTuple<T> extends true",
                "  ? Exclude<Partial<T>[\"length\"], T[\"length\"]>",
                "  : number;",
                "",
                "// Effectively performing T[P], except that it's telling TypeScript that it's",
                "// safe to do this for tuples, arrays, or objects.",
                "type IndexValue<T, P> = T extends any[]",
                "  ? P extends number",
                "    ? T[P]",
                "    : never",
                "  : P extends keyof T",
                "  ? T[P]",
                "  : never;",
                "",
                "// Determines if an object T is an array like string[] (in which case this",
                "// evaluates to false) or a tuple like [string] (in which case this evaluates to",
                "// true).",
                "// eslint-disable-next-line @typescript-eslint/no-unused-vars",
                "type IsTuple<T> = T extends []",
                "  ? true",
                "  : T extends [infer First, ...infer Remain]",
                "  ? IsTuple<Remain>",
                "  : false;",
                "",
                "type CallProperties<T> = T extends any[] ? IndexProperties<T> : keyof T;",
                "type IterProperties<T> = T extends any[]",
                "  ? IndexProperties<T>",
                "  : ArrayProperties<T>;",
                "",
                "type CallCallback<T, U> = (path: AstPath<T>, index: number, value: any) => U;",
                "type EachCallback<T> = (",
                "  path: AstPath<ArrayElement<T>>,",
                "  index: number,",
                "  value: any",
                ") => void;",
                "type MapCallback<T, U> = (",
                "  path: AstPath<ArrayElement<T>>,",
                "  index: number,",
                "  value: any",
                ") => U;",
                "",
                "// https://github.com/prettier/prettier/blob/next/src/common/ast-path.js",
                "export class AstPath<T = any> {",
                "  constructor(value: T);",
                "",
                "  get key(): string | null;",
                "  get index(): number | null;",
                "  get node(): T;",
                "  get parent(): T | null;",
                "  get grandparent(): T | null;",
                "  get isInArray(): boolean;",
                "  get siblings(): T[] | null;",
                "  get next(): T | null;",
                "  get previous(): T | null;",
                "  get isFirst(): boolean;",
                "  get isLast(): boolean;",
                "  get isRoot(): boolean;",
                "  get root(): T;",
                "  get ancestors(): T[];",
                "",
                "  stack: T[];",
                "",
                "  callParent<U>(callback: (path: this) => U, count?: number): U;",
                "",
                "  /**",
                "   * @deprecated Please use `AstPath#key` or `AstPath#index`",
                "   */",
                "  getName(): PropertyKey | null;",
                "",
                "  /**",
                "   * @deprecated Please use `AstPath#node` or  `AstPath#siblings`",
                "   */",
                "  getValue(): T;",
                "",
                "  getNode(count?: number): T | null;",
                "",
                "  getParentNode(count?: number): T | null;",
                "",
                "  match(",
                "    ...predicates: Array<",
                "      (node: any, name: string | null, number: number | null) => boolean",
                "    >",
                "  ): boolean;",
                "",
                "  // For each of the tree walk functions (call, each, and map) this provides 5",
                "  // strict type signatures, along with a fallback at the end if you end up",
                "  // calling more than 5 properties deep. This helps a lot with typing because",
                "  // for the majority of cases you're calling fewer than 5 properties, so the",
                "  // tree walk functions have a clearer understanding of what you're doing.",
                "  //",
                "  // Note that resolving these types is somewhat complicated, and it wasn't",
                "  // even supported until TypeScript 4.2 (before it would just say that the",
                "  // type instantiation was excessively deep and possibly infinite).",
                "",
                "  call<U>(callback: CallCallback<T, U>): U;",
                "  call<U, P1 extends CallProperties<T>>(",
                "    callback: CallCallback<IndexValue<T, P1>, U>,",
                "    prop1: P1",
                "  ): U;",
                "  call<U, P1 extends keyof T, P2 extends CallProperties<T[P1]>>(",
                "    callback: CallCallback<IndexValue<IndexValue<T, P1>, P2>, U>,",
                "    prop1: P1,",
                "    prop2: P2",
                "  ): U;",
                "  call<",
                "    U,",
                "    P1 extends keyof T,",
                "    P2 extends CallProperties<T[P1]>,",
                "    P3 extends CallProperties<IndexValue<T[P1], P2>>",
                "  >(",
                "    callback: CallCallback<",
                "      IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>,",
                "      U",
                "    >,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3",
                "  ): U;",
                "  call<",
                "    U,",
                "    P1 extends keyof T,",
                "    P2 extends CallProperties<T[P1]>,",
                "    P3 extends CallProperties<IndexValue<T[P1], P2>>,",
                "    P4 extends CallProperties<IndexValue<IndexValue<T[P1], P2>, P3>>",
                "  >(",
                "    callback: CallCallback<",
                "      IndexValue<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>, P4>,",
                "      U",
                "    >,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3,",
                "    prop4: P4",
                "  ): U;",
                "  call<U, P extends PropertyKey>(",
                "    callback: CallCallback<any, U>,",
                "    prop1: P,",
                "    prop2: P,",
                "    prop3: P,",
                "    prop4: P,",
                "    ...props: P[]",
                "  ): U;",
                "",
                "  each(callback: EachCallback<T>): void;",
                "  each<P1 extends IterProperties<T>>(",
                "    callback: EachCallback<IndexValue<T, P1>>,",
                "    prop1: P1",
                "  ): void;",
                "  each<P1 extends keyof T, P2 extends IterProperties<T[P1]>>(",
                "    callback: EachCallback<IndexValue<IndexValue<T, P1>, P2>>,",
                "    prop1: P1,",
                "    prop2: P2",
                "  ): void;",
                "  each<",
                "    P1 extends keyof T,",
                "    P2 extends IterProperties<T[P1]>,",
                "    P3 extends IterProperties<IndexValue<T[P1], P2>>",
                "  >(",
                "    callback: EachCallback<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>>,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3",
                "  ): void;",
                "  each<",
                "    P1 extends keyof T,",
                "    P2 extends IterProperties<T[P1]>,",
                "    P3 extends IterProperties<IndexValue<T[P1], P2>>,",
                "    P4 extends IterProperties<IndexValue<IndexValue<T[P1], P2>, P3>>",
                "  >(",
                "    callback: EachCallback<",
                "      IndexValue<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>, P4>",
                "    >,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3,",
                "    prop4: P4",
                "  ): void;",
                "  each(",
                "    callback: EachCallback<any[]>,",
                "    prop1: PropertyKey,",
                "    prop2: PropertyKey,",
                "    prop3: PropertyKey,",
                "    prop4: PropertyKey,",
                "    ...props: PropertyKey[]",
                "  ): void;",
                "",
                "  map<U>(callback: MapCallback<T, U>): U[];",
                "  map<U, P1 extends IterProperties<T>>(",
                "    callback: MapCallback<IndexValue<T, P1>, U>,",
                "    prop1: P1",
                "  ): U[];",
                "  map<U, P1 extends keyof T, P2 extends IterProperties<T[P1]>>(",
                "    callback: MapCallback<IndexValue<IndexValue<T, P1>, P2>, U>,",
                "    prop1: P1,",
                "    prop2: P2",
                "  ): U[];",
                "  map<",
                "    U,",
                "    P1 extends keyof T,",
                "    P2 extends IterProperties<T[P1]>,",
                "    P3 extends IterProperties<IndexValue<T[P1], P2>>",
                "  >(",
                "    callback: MapCallback<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>, U>,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3",
                "  ): U[];",
                "  map<",
                "    U,",
                "    P1 extends keyof T,",
                "    P2 extends IterProperties<T[P1]>,",
                "    P3 extends IterProperties<IndexValue<T[P1], P2>>,",
                "    P4 extends IterProperties<IndexValue<IndexValue<T[P1], P2>, P3>>",
                "  >(",
                "    callback: MapCallback<",
                "      IndexValue<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>, P4>,",
                "      U",
                "    >,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3,",
                "    prop4: P4",
                "  ): U[];",
                "  map<U>(",
                "    callback: MapCallback<any[], U>,",
                "    prop1: PropertyKey,",
                "    prop2: PropertyKey,",
                "    prop3: PropertyKey,",
                "    prop4: PropertyKey,",
                "    ...props: PropertyKey[]",
                "  ): U[];",
                "}",
                "",
                "/** @deprecated `FastPath` was renamed to `AstPath` */",
                "export type FastPath<T = any> = AstPath<T>;",
                "",
                "export type BuiltInParser = (text: string, options?: any) => AST;",
                "export type BuiltInParserName =",
                "  | \"acorn\"",
                "  | \"angular\"",
                "  | \"babel-flow\"",
                "  | \"babel-ts\"",
                "  | \"babel\"",
                "  | \"css\"",
                "  | \"espree\"",
                "  | \"flow\"",
                "  | \"glimmer\"",
                "  | \"graphql\"",
                "  | \"html\"",
                "  | \"json-stringify\"",
                "  | \"json\"",
                "  | \"json5\"",
                "  | \"less\"",
                "  | \"lwc\"",
                "  | \"markdown\"",
                "  | \"mdx\"",
                "  | \"meriyah\"",
                "  | \"scss\"",
                "  | \"typescript\"",
                "  | \"vue\"",
                "  | \"yaml\";",
                "export type BuiltInParsers = Record<BuiltInParserName, BuiltInParser>;",
                "",
                "export type CustomParser = (",
                "  text: string,",
                "  options: Options",
                ") => AST | Promise<AST>;",
                "",
                "/**",
                " * For use in `.prettierrc.js`, `.prettierrc.cjs`, `prettierrc.mjs`, `prettier.config.js`, `prettier.config.cjs`, `prettier.config.mjs`",
                " */",
                "export interface Config extends Options {",
                "  overrides?: Array<{",
                "    files: string | string[];",
                "    excludeFiles?: string | string[];",
                "    options?: Options;",
                "  }>;",
                "}",
                "",
                "export interface Options extends Partial<RequiredOptions> {}",
                "",
                "export interface RequiredOptions extends doc.printer.Options {",
                "  /**",
                "   * Print semicolons at the ends of statements.",
                "   * @default true",
                "   */",
                "  semi: boolean;",
                "  /**",
                "   * Use single quotes instead of double quotes.",
                "   * @default false",
                "   */",
                "  singleQuote: boolean;",
                "  /**",
                "   * Use single quotes in JSX.",
                "   * @default false",
                "   */",
                "  jsxSingleQuote: boolean;",
                "  /**",
                "   * Print trailing commas wherever possible.",
                "   * @default \"all\"",
                "   */",
                "  trailingComma: \"none\" | \"es5\" | \"all\";",
                "  /**",
                "   * Print spaces between brackets in object literals.",
                "   * @default true",
                "   */",
                "  bracketSpacing: boolean;",
                "  /**",
                "   * Put the `>` of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being",
                "   * alone on the next line (does not apply to self closing elements).",
                "   * @default false",
                "   */",
                "  bracketSameLine: boolean;",
                "  /**",
                "   * Put the `>` of a multi-line JSX element at the end of the last line instead of being alone on the next line.",
                "   * @default false",
                "   * @deprecated use bracketSameLine instead",
                "   */",
                "  jsxBracketSameLine: boolean;",
                "  /**",
                "   * Format only a segment of a file.",
                "   * @default 0",
                "   */",
                "  rangeStart: number;",
                "  /**",
                "   * Format only a segment of a file.",
                "   * @default Number.POSITIVE_INFINITY",
                "   */",
                "  rangeEnd: number;",
                "  /**",
                "   * Specify which parser to use.",
                "   */",
                "  parser: LiteralUnion<BuiltInParserName> | CustomParser;",
                "  /**",
                "   * Specify the input filepath. This will be used to do parser inference.",
                "   */",
                "  filepath: string;",
                "  /**",
                "   * Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file.",
                "   * This is very useful when gradually transitioning large, unformatted codebases to prettier.",
                "   * @default false",
                "   */",
                "  requirePragma: boolean;",
                "  /**",
                "   * Prettier can insert a special @format marker at the top of files specifying that",
                "   * the file has been formatted with prettier. This works well when used in tandem with",
                "   * the --require-pragma option. If there is already a docblock at the top of",
                "   * the file then this option will add a newline to it with the @format marker.",
                "   * @default false",
                "   */",
                "  insertPragma: boolean;",
                "  /**",
                "   * By default, Prettier will wrap markdown text as-is since some services use a linebreak-sensitive renderer.",
                "   * In some cases you may want to rely on editor/viewer soft wrapping instead, so this option allows you to opt out.",
                "   * @default \"preserve\"",
                "   */",
                "  proseWrap: \"always\" | \"never\" | \"preserve\";",
                "  /**",
                "   * Include parentheses around a sole arrow function parameter.",
                "   * @default \"always\"",
                "   */",
                "  arrowParens: \"avoid\" | \"always\";",
                "  /**",
                "   * Provide ability to support new languages to prettier.",
                "   */",
                "  plugins: Array<string | Plugin>;",
                "  /**",
                "   * Specify plugin directory paths to search for plugins if not installed in the same `node_modules` where prettier is located.",
                "   */",
                "  pluginSearchDirs: string[] | false;",
                "  /**",
                "   * How to handle whitespaces in HTML.",
                "   * @default \"css\"",
                "   */",
                "  htmlWhitespaceSensitivity: \"css\" | \"strict\" | \"ignore\";",
                "  /**",
                "   * Which end of line characters to apply.",
                "   * @default \"lf\"",
                "   */",
                "  endOfLine: \"auto\" | \"lf\" | \"crlf\" | \"cr\";",
                "  /**",
                "   * Change when properties in objects are quoted.",
                "   * @default \"as-needed\"",
                "   */",
                "  quoteProps: \"as-needed\" | \"consistent\" | \"preserve\";",
                "  /**",
                "   * Whether or not to indent the code inside <script> and <style> tags in Vue files.",
                "   * @default false",
                "   */",
                "  vueIndentScriptAndStyle: boolean;",
                "  /**",
                "   * Control whether Prettier formats quoted code embedded in the file.",
                "   * @default \"auto\"",
                "   */",
                "  embeddedLanguageFormatting: \"auto\" | \"off\";",
                "  /**",
                "   * Enforce single attribute per line in HTML, Vue and JSX.",
                "   * @default false",
                "   */",
                "  singleAttributePerLine: boolean;",
                "}",
                "",
                "export interface ParserOptions<T = any> extends RequiredOptions {",
                "  locStart: (node: T) => number;",
                "  locEnd: (node: T) => number;",
                "  originalText: string;",
                "}",
                "",
                "export interface Plugin<T = any> {",
                "  languages?: SupportLanguage[] | undefined;",
                "  parsers?:",
                "    | { [parserName: string]: Parser<T> | (() => Promise<Parser<T>>) }",
                "    | undefined;",
                "  printers?: { [astFormat: string]: Printer<T> } | undefined;",
                "  options?: SupportOptions | undefined;",
                "  defaultOptions?: Partial<RequiredOptions> | undefined;",
                "}",
                "",
                "export interface Parser<T = any> {",
                "  parse: (text: string, options: ParserOptions<T>) => T | Promise<T>;",
                "  astFormat: string;",
                "  hasPragma?: ((text: string) => boolean) | undefined;",
                "  locStart: (node: T) => number;",
                "  locEnd: (node: T) => number;",
                "  preprocess?:",
                "    | ((text: string, options: ParserOptions<T>) => string)",
                "    | undefined;",
                "}",
                "",
                "export interface Printer<T = any> {",
                "  print(",
                "    path: AstPath<T>,",
                "    options: ParserOptions<T>,",
                "    print: (path: AstPath<T>) => Doc,",
                "    args?: unknown",
                "  ): Doc;",
                "  embed?:",
                "    | ((",
                "        path: AstPath,",
                "        options: Options",
                "      ) =>",
                "        | ((",
                "            textToDoc: (text: string, options: Options) => Promise<Doc>,",
                "            print: (",
                "              selector?: string | number | Array<string | number> | AstPath",
                "            ) => Doc,",
                "            path: AstPath,",
                "            options: Options",
                "          ) => Promise<Doc | undefined> | Doc | undefined)",
                "        | Doc",
                "        | null)",
                "    | undefined;",
                "  insertPragma?: (text: string) => string;",
                "  /**",
                "   * @returns `null` if you want to remove this node",
                "   * @returns `void` if you want to use modified newNode",
                "   * @returns anything if you want to replace the node with it",
                "   */",
                "  massageAstNode?: ((node: any, newNode: any, parent: any) => any) | undefined;",
                "  hasPrettierIgnore?: ((path: AstPath<T>) => boolean) | undefined;",
                "  canAttachComment?: ((node: T) => boolean) | undefined;",
                "  isBlockComment?: ((node: T) => boolean) | undefined;",
                "  willPrintOwnComments?: ((path: AstPath<T>) => boolean) | undefined;",
                "  printComment?:",
                "    | ((commentPath: AstPath<T>, options: ParserOptions<T>) => Doc)",
                "    | undefined;",
                "  /**",
                "   * By default, Prettier searches all object properties (except for a few predefined ones) of each node recursively.",
                "   * This function can be provided to override that behavior.",
                "   * @param node The node whose children should be returned.",
                "   * @param options Current options.",
                "   * @returns `[]` if the node has no children or `undefined` to fall back on the default behavior.",
                "   */",
                "  getCommentChildNodes?:",
                "    | ((node: T, options: ParserOptions<T>) => T[] | undefined)",
                "    | undefined;",
                "  handleComments?:",
                "    | {",
                "        ownLine?:",
                "          | ((",
                "              commentNode: any,",
                "              text: string,",
                "              options: ParserOptions<T>,",
                "              ast: T,",
                "              isLastComment: boolean",
                "            ) => boolean)",
                "          | undefined;",
                "        endOfLine?:",
                "          | ((",
                "              commentNode: any,",
                "              text: string,",
                "              options: ParserOptions<T>,",
                "              ast: T,",
                "              isLastComment: boolean",
                "            ) => boolean)",
                "          | undefined;",
                "        remaining?:",
                "          | ((",
                "              commentNode: any,",
                "              text: string,",
                "              options: ParserOptions<T>,",
                "              ast: T,",
                "              isLastComment: boolean",
                "            ) => boolean)",
                "          | undefined;",
                "      }",
                "    | undefined;",
                "}",
                "",
                "export interface CursorOptions extends Options {",
                "  /**",
                "   * Specify where the cursor is.",
                "   */",
                "  cursorOffset: number;",
                "  rangeStart?: never;",
                "  rangeEnd?: never;",
                "}",
                "",
                "export interface CursorResult {",
                "  formatted: string;",
                "  cursorOffset: number;",
                "}",
                "",
                "/**",
                " * `format` is used to format text using Prettier. [Options](https://prettier.io/docs/en/options.html) may be provided to override the defaults.",
                " */",
                "export function format(source: string, options?: Options): Promise<string>;",
                "",
                "/**",
                " * `check` checks to see if the file has been formatted with Prettier given those options and returns a `Boolean`.",
                " * This is similar to the `--list-different` parameter in the CLI and is useful for running Prettier in CI scenarios.",
                " */",
                "export function check(source: string, options?: Options): Promise<boolean>;",
                "",
                "/**",
                " * `formatWithCursor` both formats the code, and translates a cursor position from unformatted code to formatted code.",
                " * This is useful for editor integrations, to prevent the cursor from moving when code is formatted.",
                " *",
                " * The `cursorOffset` option should be provided, to specify where the cursor is. This option cannot be used with `rangeStart` and `rangeEnd`.",
                " */",
                "export function formatWithCursor(",
                "  source: string,",
                "  options: CursorOptions",
                "): Promise<CursorResult>;",
                "",
                "export function formatAST(ast: any, options?: Options): Promise<string>;",
                "",
                "export interface ResolveConfigOptions {",
                "  /**",
                "   * If set to `false`, all caching will be bypassed.",
                "   */",
                "  useCache?: boolean | undefined;",
                "  /**",
                "   * Pass directly the path of the config file if you don't wish to search for it.",
                "   */",
                "  config?: string | undefined;",
                "  /**",
                "   * If set to `true` and an `.editorconfig` file is in your project,",
                "   * Prettier will parse it and convert its properties to the corresponding prettier configuration.",
                "   * This configuration will be overridden by `.prettierrc`, etc. Currently,",
                "   * the following EditorConfig properties are supported:",
                "   * - indent_style",
                "   * - indent_size/tab_width",
                "   * - max_line_length",
                "   */",
                "  editorconfig?: boolean | undefined;",
                "}",
                "",
                "/**",
                " * `resolveConfig` can be used to resolve configuration for a given source file,",
                " * passing its path as the first argument. The config search will start at the",
                " * file path and continue to search up the directory.",
                " * (You can use `process.cwd()` to start searching from the current directory).",
                " *",
                " * A promise is returned which will resolve to:",
                " *",
                " *  - An options object, providing a [config file](https://prettier.io/docs/en/configuration.html) was found.",
                " *  - `null`, if no file was found.",
                " *",
                " * The promise will be rejected if there was an error parsing the configuration file.",
                " */",
                "export function resolveConfig(",
                "  filePath: string,",
                "  options?: ResolveConfigOptions",
                "): Promise<Options | null>;",
                "",
                "/**",
                " * `resolveConfigFile` can be used to find the path of the Prettier configuration file,",
                " * that will be used when resolving the config (i.e. when calling `resolveConfig`).",
                " *",
                " * A promise is returned which will resolve to:",
                " *",
                " * - The path of the configuration file.",
                " * - `null`, if no file was found.",
                " *",
                " * The promise will be rejected if there was an error parsing the configuration file.",
                " */",
                "export function resolveConfigFile(filePath?: string): Promise<string | null>;",
                "",
                "/**",
                " * As you repeatedly call `resolveConfig`, the file system structure will be cached for performance. This function will clear the cache.",
                " * Generally this is only needed for editor integrations that know that the file system has changed since the last format took place.",
                " */",
                "export function clearConfigCache(): Promise<void>;",
                "",
                "export interface SupportLanguage {",
                "  name: string;",
                "  since?: string | undefined;",
                "  parsers: BuiltInParserName[] | string[];",
                "  group?: string | undefined;",
                "  tmScope?: string | undefined;",
                "  aceMode?: string | undefined;",
                "  codemirrorMode?: string | undefined;",
                "  codemirrorMimeType?: string | undefined;",
                "  aliases?: string[] | undefined;",
                "  extensions?: string[] | undefined;",
                "  filenames?: string[] | undefined;",
                "  linguistLanguageId?: number | undefined;",
                "  vscodeLanguageIds?: string[] | undefined;",
                "  interpreters?: string[] | undefined;",
                "}",
                "",
                "export interface SupportOptionRange {",
                "  start: number;",
                "  end: number;",
                "  step: number;",
                "}",
                "",
                "export type SupportOptionType =",
                "  | \"int\"",
                "  | \"string\"",
                "  | \"boolean\"",
                "  | \"choice\"",
                "  | \"path\";",
                "",
                "export type CoreCategoryType =",
                "  | \"Config\"",
                "  | \"Editor\"",
                "  | \"Format\"",
                "  | \"Other\"",
                "  | \"Output\"",
                "  | \"Global\"",
                "  | \"Special\";",
                "",
                "export interface BaseSupportOption<Type extends SupportOptionType> {",
                "  readonly name?: string | undefined;",
                "  /**",
                "   * Usually you can use {@link CoreCategoryType}",
                "   */",
                "  category: string;",
                "  /**",
                "   * The type of the option.",
                "   *",
                "   * When passing a type other than the ones listed below, the option is",
                "   * treated as taking any string as argument, and `--option <${type}>` will",
                "   * be displayed in --help.",
                "   */",
                "  type: Type;",
                "  /**",
                "   * Indicate that the option is deprecated.",
                "   *",
                "   * Use a string to add an extra message to --help for the option,",
                "   * for example to suggest a replacement option.",
                "   */",
                "  deprecated?: true | string | undefined;",
                "  /**",
                "   * Description to be displayed in --help. If omitted, the option won't be",
                "   * shown at all in --help.",
                "   */",
                "  description?: string | undefined;",
                "}",
                "",
                "export interface IntSupportOption extends BaseSupportOption<\"int\"> {",
                "  default?: number | undefined;",
                "  array?: false | undefined;",
                "  range?: SupportOptionRange | undefined;",
                "}",
                "",
                "export interface IntArraySupportOption extends BaseSupportOption<\"int\"> {",
                "  default?: Array<{ value: number[] }> | undefined;",
                "  array: true;",
                "}",
                "",
                "export interface StringSupportOption extends BaseSupportOption<\"string\"> {",
                "  default?: string | undefined;",
                "  array?: false | undefined;",
                "}",
                "",
                "export interface StringArraySupportOption extends BaseSupportOption<\"string\"> {",
                "  default?: Array<{ value: string[] }> | undefined;",
                "  array: true;",
                "}",
                "",
                "export interface BooleanSupportOption extends BaseSupportOption<\"boolean\"> {",
                "  default?: boolean | undefined;",
                "  array?: false | undefined;",
                "  description: string;",
                "  oppositeDescription?: string | undefined;",
                "}",
                "",
                "export interface BooleanArraySupportOption",
                "  extends BaseSupportOption<\"boolean\"> {",
                "  default?: Array<{ value: boolean[] }> | undefined;",
                "  array: true;",
                "}",
                "",
                "export interface ChoiceSupportOption<Value = any>",
                "  extends BaseSupportOption<\"choice\"> {",
                "  default?: Value | Array<{ value: Value }> | undefined;",
                "  description: string;",
                "  choices: Array<{",
                "    since?: string | undefined;",
                "    value: Value;",
                "    description: string;",
                "  }>;",
                "}",
                "",
                "export interface PathSupportOption extends BaseSupportOption<\"path\"> {",
                "  default?: string | undefined;",
                "  array?: false | undefined;",
                "}",
                "",
                "export interface PathArraySupportOption extends BaseSupportOption<\"path\"> {",
                "  default?: Array<{ value: string[] }> | undefined;",
                "  array: true;",
                "}",
                "",
                "export type SupportOption =",
                "  | IntSupportOption",
                "  | IntArraySupportOption",
                "  | StringSupportOption",
                "  | StringArraySupportOption",
                "  | BooleanSupportOption",
                "  | BooleanArraySupportOption",
                "  | ChoiceSupportOption",
                "  | PathSupportOption",
                "  | PathArraySupportOption;",
                "",
                "export interface SupportOptions extends Record<string, SupportOption> {}",
                "",
                "export interface SupportInfo {",
                "  languages: SupportLanguage[];",
                "  options: SupportOption[];",
                "}",
                "",
                "export interface FileInfoOptions {",
                "  ignorePath?: string | string[] | undefined;",
                "  withNodeModules?: boolean | undefined;",
                "  plugins?: string[] | undefined;",
                "  resolveConfig?: boolean | undefined;",
                "}",
                "",
                "export interface FileInfoResult {",
                "  ignored: boolean;",
                "  inferredParser: string | null;",
                "}",
                "",
                "export function getFileInfo(",
                "  filePath: string,",
                "  options?: FileInfoOptions",
                "): Promise<FileInfoResult>;",
                "",
                "/**",
                " * Returns an object representing the parsers, languages and file types Prettier supports for the current version.",
                " */",
                "export function getSupportInfo(): Promise<SupportInfo>;",
                "",
                "/**",
                " * `version` field in `package.json`",
                " */",
                "export const version: string;",
                "",
                "// https://github.com/prettier/prettier/blob/next/src/utils/public.js",
                "export namespace util {",
                "  interface SkipOptions {",
                "    backwards?: boolean | undefined;",
                "  }",
                "",
                "  type Quote = \"'\" | '\"';",
                "",
                "  function getMaxContinuousCount(text: string, searchString: string): number;",
                "",
                "  function getStringWidth(text: string): number;",
                "",
                "  function getAlignmentSize(",
                "    text: string,",
                "    tabWidth: number,",
                "    startIndex?: number | undefined",
                "  ): number;",
                "",
                "  function getIndentSize(value: string, tabWidth: number): number;",
                "",
                "  function skipNewline(",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions | undefined",
                "  ): number | false;",
                "",
                "  function skipInlineComment(",
                "    text: string,",
                "    startIndex: number | false",
                "  ): number | false;",
                "",
                "  function skipTrailingComment(",
                "    text: string,",
                "    startIndex: number | false",
                "  ): number | false;",
                "",
                "  function skipTrailingComment(",
                "    text: string,",
                "    startIndex: number | false",
                "  ): number | false;",
                "",
                "  function hasNewline(",
                "    text: string,",
                "    startIndex: number,",
                "    options?: SkipOptions | undefined",
                "  ): boolean;",
                "",
                "  function hasNewlineInRange(",
                "    text: string,",
                "    startIndex: number,",
                "    endIndex: number",
                "  ): boolean;",
                "",
                "  function hasSpaces(",
                "    text: string,",
                "    startIndex: number,",
                "    options?: SkipOptions | undefined",
                "  ): boolean;",
                "",
                "  function getNextNonSpaceNonCommentCharacter(",
                "    text: string,",
                "    startIndex: number",
                "  ): string;",
                "",
                "  function makeString(",
                "    rawText: string,",
                "    enclosingQuote: Quote,",
                "    unescapeUnnecessaryEscapes?: boolean | undefined",
                "  ): string;",
                "",
                "  function skip(",
                "    characters: string | RegExp",
                "  ): (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  const skipWhitespace: (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  const skipSpaces: (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  const skipToLineEnd: (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  const skipEverythingButNewLine: (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  function addLeadingComment(node: any, comment: any): void;",
                "",
                "  function addDanglingComment(node: any, comment: any, marker: any): void;",
                "",
                "  function addTrailingComment(node: any, comment: any): void;",
                "}"
            ]
        },
        "index.js": {
            "classes": [],
            "functions": [],
            "text": [
                "import vnopts from \"vnopts\";",
                "import fastGlob from \"fast-glob\";",
                "import * as core from \"./main/core.js\";",
                "import {",
                "  getSupportInfo as getSupportInfoWithoutPlugins,",
                "  normalizeOptionSettings,",
                "} from \"./main/support.js\";",
                "import getFileInfoWithoutPlugins from \"./common/get-file-info.js\";",
                "import {",
                "  loadBuiltinPlugins,",
                "  loadPlugins,",
                "  searchPlugins,",
                "  clearCache as clearPluginCache,",
                "} from \"./main/plugins/index.js\";",
                "import {",
                "  resolveConfig,",
                "  resolveConfigFile,",
                "  clearCache as clearConfigCache,",
                "} from \"./config/resolve-config.js\";",
                "import * as errors from \"./common/errors.js\";",
                "import * as optionCategories from \"./main/option-categories.js\";",
                "import { createIsIgnoredFunction } from \"./utils/ignore.js\";",
                "import { formatOptionsHiddenDefaults } from \"./main/normalize-format-options.js\";",
                "import normalizeOptions from \"./main/normalize-options.js\";",
                "import partition from \"./utils/partition.js\";",
                "import isNonEmptyArray from \"./utils/is-non-empty-array.js\";",
                "import omit from \"./utils/object-omit.js\";",
                "",
                "/**",
                " * @param {*} fn",
                " * @param {number} [optionsArgumentIndex]",
                " * @returns {*}",
                " */",
                "function withPlugins(",
                "  fn,",
                "  optionsArgumentIndex = 1 // Usually `options` is the 2nd argument",
                ") {",
                "  return async (...args) => {",
                "    const options = args[optionsArgumentIndex] ?? {};",
                "    const { plugins = [], pluginSearchDirs } = options;",
                "",
                "    args[optionsArgumentIndex] = {",
                "      ...options,",
                "      plugins: (",
                "        await Promise.all([",
                "          loadBuiltinPlugins(),",
                "          // TODO: standalone version allow `plugins` to be `prettierPlugins` which is an object, should allow that too",
                "          loadPlugins(plugins),",
                "          options.pluginSearchDirs === false",
                "            ? []",
                "            : searchPlugins(pluginSearchDirs),",
                "        ])",
                "      ).flat(),",
                "    };",
                "",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "async function format(text, options) {",
                "  const { formatted } = await formatWithCursor(text, {",
                "    ...options,",
                "    cursorOffset: -1,",
                "  });",
                "  return formatted;",
                "}",
                "",
                "async function check(text, options) {",
                "  return (await format(text, options)) === text;",
                "}",
                "",
                "// eslint-disable-next-line require-await",
                "async function clearCache() {",
                "  clearConfigCache();",
                "  clearPluginCache();",
                "}",
                "",
                "/** @type {typeof getFileInfoWithoutPlugins} */",
                "const getFileInfo = withPlugins(getFileInfoWithoutPlugins);",
                "",
                "/** @type {typeof getSupportInfoWithoutPlugins} */",
                "const getSupportInfo = withPlugins(getSupportInfoWithoutPlugins, 0);",
                "",
                "// Internal shared with cli",
                "const sharedWithCli = {",
                "  errors,",
                "  optionCategories,",
                "  createIsIgnoredFunction,",
                "  formatOptionsHiddenDefaults,",
                "  normalizeOptions,",
                "  getSupportInfoWithoutPlugins,",
                "  normalizeOptionSettings,",
                "  vnopts,",
                "  fastGlob,",
                "  utils: {",
                "    isNonEmptyArray,",
                "    partition,",
                "    omit,",
                "  },",
                "};",
                "",
                "const debugApis = {",
                "  parse: withPlugins(core.parse),",
                "  formatAST: withPlugins(core.formatAst),",
                "  formatDoc: withPlugins(core.formatDoc),",
                "  printToDoc: withPlugins(core.printToDoc),",
                "  printDocToString: withPlugins(core.printDocToString),",
                "};",
                "",
                "export {",
                "  formatWithCursor,",
                "  format,",
                "  check,",
                "  resolveConfig,",
                "  resolveConfigFile,",
                "  clearCache as clearConfigCache,",
                "  getFileInfo,",
                "  getSupportInfo,",
                "  sharedWithCli as __internal,",
                "  debugApis as __debug,",
                "};",
                "export * as util from \"./utils/public.js\";",
                "export * as doc from \"./document/public.js\";",
                "export { default as version } from \"./main/version.evaluate.cjs\";"
            ]
        },
        "standalone.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "import { CursorOptions, CursorResult, Options, SupportInfo } from \"./index.js\";",
                "",
                "/**",
                " * formatWithCursor both formats the code, and translates a cursor position from unformatted code to formatted code.",
                " * This is useful for editor integrations, to prevent the cursor from moving when code is formatted",
                " *",
                " * The cursorOffset option should be provided, to specify where the cursor is. This option cannot be used with rangeStart and rangeEnd.",
                " *",
                " * ```js",
                " * await prettier.formatWithCursor(\" 1\", { cursorOffset: 2, parser: \"babel\" });",
                " * ```",
                " * `-> { formatted: \"1;\\n\", cursorOffset: 1 }`",
                " */",
                "export function formatWithCursor(",
                "  source: string,",
                "  options: CursorOptions",
                "): Promise<CursorResult>;",
                "",
                "/**",
                " * `format` is used to format text using Prettier. [Options](https://prettier.io/docs/en/options.html) may be provided to override the defaults.",
                " */",
                "export function format(source: string, options?: Options): Promise<string>;",
                "",
                "/**",
                " * `check` checks to see if the file has been formatted with Prettier given those options and returns a `Boolean`.",
                " * This is similar to the `--list-different` parameter in the CLI and is useful for running Prettier in CI scenarios.",
                " */",
                "export function check(source: string, options?: Options): Promise<boolean>;",
                "",
                "/**",
                " * Returns an object representing the parsers, languages and file types Prettier supports for the current version.",
                " */",
                "export function getSupportInfo(): Promise<SupportInfo>;"
            ]
        },
        "standalone.js": {
            "classes": [],
            "functions": [],
            "text": [
                "import * as core from \"./main/core.js\";",
                "import { getSupportInfo as getSupportInfoWithoutPlugins } from \"./main/support.js\";",
                "",
                "function withPlugins(",
                "  fn,",
                "  optionsArgumentIndex = 1 // Usually `options` is the 2nd argument",
                ") {",
                "  // Returns Promises to consistent with functions in `index.js`",
                "  // eslint-disable-next-line require-await",
                "  return async (...args) => {",
                "    const options = args[optionsArgumentIndex] ?? {};",
                "    const plugins = options.plugins ?? [];",
                "",
                "    args[optionsArgumentIndex] = {",
                "      ...options,",
                "      plugins: Array.isArray(plugins) ? plugins : Object.values(plugins),",
                "    };",
                "",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "async function format(text, options) {",
                "  const { formatted } = await formatWithCursor(text, {",
                "    ...options,",
                "    cursorOffset: -1,",
                "  });",
                "  return formatted;",
                "}",
                "",
                "async function check(text, options) {",
                "  return (await format(text, options)) === text;",
                "}",
                "",
                "const getSupportInfo = withPlugins(getSupportInfoWithoutPlugins, 0);",
                "",
                "const debugApis = {",
                "  parse: withPlugins(core.parse),",
                "  formatAST: withPlugins(core.formatAst),",
                "  formatDoc: withPlugins(core.formatDoc),",
                "  printToDoc: withPlugins(core.printToDoc),",
                "  printDocToString: withPlugins(core.printDocToString),",
                "};",
                "",
                "export {",
                "  formatWithCursor,",
                "  format,",
                "  check,",
                "  getSupportInfo,",
                "  debugApis as __debug,",
                "};",
                "export * as util from \"./utils/public.js\";",
                "export * as doc from \"./document/public.js\";",
                "export { default as version } from \"./main/version.evaluate.cjs\";"
            ]
        },
        "cli": {
            "cli-options.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { outdent } from \"outdent\";",
                    "import { optionCategories } from \"./prettier-internal.js\";",
                    "",
                    "/**",
                    " * {",
                    " *   [optionName]: {",
                    " *     // The type of the option. For 'choice', see also `choices` below.",
                    " *     // When passing a type other than the ones listed below, the option is",
                    " *     // treated as taking any string as argument, and `--option <${type}>` will",
                    " *     // be displayed in --help.",
                    " *     type: \"boolean\" | \"choice\" | \"int\" | string;",
                    " *",
                    " *     // Default value to be passed to the minimist option `default`.",
                    " *     default?: any;",
                    " *",
                    " *     // Alias name to be passed to the minimist option `alias`.",
                    " *     alias?: string;",
                    " *",
                    " *     // For grouping options by category in --help.",
                    " *     category?: string;",
                    " *",
                    " *     // Description to be displayed in --help. If omitted, the option won't be",
                    " *     // shown at all in --help (but see also `oppositeDescription` below).",
                    " *     description?: string;",
                    " *",
                    " *     // Description for `--no-${name}` to be displayed in --help. If omitted,",
                    " *     // `--no-${name}` won't be shown.",
                    " *     oppositeDescription?: string;",
                    " *",
                    " *     // Indicate if this option is simply passed to the API.",
                    " *     // true: use camelified name as the API option name.",
                    " *     // string: use this value as the API option name.",
                    " *     forwardToApi?: boolean | string;",
                    " *",
                    " *     // Indicate that a CLI flag should be an array when forwarded to the API.",
                    " *     array?: boolean;",
                    " *",
                    " *     // Specify available choices for validation. They will also be displayed",
                    " *     // in --help as <a|b|c>.",
                    " *     // Use an object instead of a string if a choice is deprecated and should",
                    " *     // be treated as `redirect` instead, or if you'd like to add description for",
                    " *     // the choice.",
                    " *     choices?: Array<",
                    " *       | string",
                    " *       | { value: string, description?: string, deprecated?: boolean, redirect?: string }",
                    " *     >;",
                    " *",
                    " *     // If the option has a value that is an exception to the regular value",
                    " *     // constraints, indicate that value here (or use a function for more",
                    " *     // flexibility).",
                    " *     exception?: ((value: any) => boolean);",
                    " *",
                    " *     // Indicate that the option is deprecated. Use a string to add an extra",
                    " *     // message to --help for the option, for example to suggest a replacement",
                    " *     // option.",
                    " *     deprecated?: true | string;",
                    " *   }",
                    " * }",
                    " *",
                    " * Note: The options below are sorted alphabetically.",
                    " */",
                    "/* eslint sort-keys: \"error\" */",
                    "const options = {",
                    "  cache: {",
                    "    default: false,",
                    "    description: \"Only format changed files. Cannot use with --stdin-filepath.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  cacheLocation: {",
                    "    description: \"Path to the cache file.\",",
                    "    type: \"path\",",
                    "  },",
                    "  cacheStrategy: {",
                    "    choices: [",
                    "      {",
                    "        description: \"Use the file metadata such as timestamps as cache keys\",",
                    "        value: \"metadata\",",
                    "      },",
                    "      {",
                    "        description: \"Use the file content as cache keys\",",
                    "        value: \"content\",",
                    "      },",
                    "    ],",
                    "    description: \"Strategy for the cache to use for detecting changed files.\",",
                    "    type: \"choice\",",
                    "  },",
                    "  check: {",
                    "    alias: \"c\",",
                    "    category: optionCategories.CATEGORY_OUTPUT,",
                    "    description: outdent`",
                    "      Check if the given files are formatted, print a human-friendly summary",
                    "      message and paths to unformatted files (see also --list-different).",
                    "    `,",
                    "    type: \"boolean\",",
                    "  },",
                    "  color: {",
                    "    // The supports-color package (a sub sub dependency) looks directly at",
                    "    // `process.argv` for `--no-color` and such-like options. The reason it is",
                    "    // listed here is to avoid \"Ignored unknown option: --no-color\" warnings.",
                    "    // See https://github.com/chalk/supports-color/#info for more information.",
                    "    default: true,",
                    "    description: \"Colorize error messages.\",",
                    "    oppositeDescription: \"Do not colorize error messages.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  config: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).\",",
                    "    exception: (value) => value === false,",
                    "    oppositeDescription: \"Do not look for a configuration file.\",",
                    "    type: \"path\",",
                    "  },",
                    "  configPrecedence: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    choices: [",
                    "      {",
                    "        description: \"CLI options take precedence over config file\",",
                    "        value: \"cli-override\",",
                    "      },",
                    "      {",
                    "        description: \"Config file take precedence over CLI options\",",
                    "        value: \"file-override\",",
                    "      },",
                    "      {",
                    "        description: outdent`",
                    "          If a config file is found will evaluate it and ignore other CLI options.",
                    "          If no config file is found CLI options will evaluate as normal.",
                    "        `,",
                    "        value: \"prefer-file\",",
                    "      },",
                    "    ],",
                    "    default: \"cli-override\",",
                    "    description:",
                    "      \"Define in which order config files and CLI options should be evaluated.\",",
                    "    type: \"choice\",",
                    "  },",
                    "  debugBenchmark: {",
                    "    // Run the formatting benchmarks. Requires 'benchmark' module to be installed.",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugCheck: {",
                    "    // Run the formatting once again on the formatted output, throw if different.",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugPrintAst: {",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugPrintComments: {",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugPrintDoc: {",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugRepeat: {",
                    "    // Repeat the formatting a few times and measure the average duration.",
                    "    default: 0,",
                    "    type: \"int\",",
                    "  },",
                    "  editorconfig: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    default: true,",
                    "    description: \"Take .editorconfig into account when parsing configuration.\",",
                    "    oppositeDescription:",
                    "      \"Don't take .editorconfig into account when parsing configuration.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  errorOnUnmatchedPattern: {",
                    "    oppositeDescription: \"Prevent errors when pattern is unmatched.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  fileInfo: {",
                    "    description: outdent`",
                    "      Extract the following info (as JSON) for a given file path. Reported fields:",
                    "      * ignored (boolean) - true if file path is filtered by --ignore-path",
                    "      * inferredParser (string | null) - name of parser inferred from file path",
                    "    `,",
                    "    type: \"path\",",
                    "  },",
                    "  findConfigPath: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Find and print the path to a configuration file for the given input file.\",",
                    "    type: \"path\",",
                    "  },",
                    "  help: {",
                    "    alias: \"h\",",
                    "    description: outdent`",
                    "      Show CLI usage, or details about the given flag.",
                    "      Example: --help write",
                    "    `,",
                    "    exception: (value) => value === \"\",",
                    "    type: \"flag\",",
                    "  },",
                    "  ignorePath: {",
                    "    array: true,",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    default: [{ value: [\".prettierignore\"] }],",
                    "    description: outdent`",
                    "      Path to a file with patterns describing files to ignore.",
                    "      Multiple values are accepted.",
                    "    `,",
                    "    type: \"path\",",
                    "  },",
                    "  ignoreUnknown: {",
                    "    alias: \"u\",",
                    "    description: \"Ignore unknown files.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  listDifferent: {",
                    "    alias: \"l\",",
                    "    category: optionCategories.CATEGORY_OUTPUT,",
                    "    description:",
                    "      \"Print the names of files that are different from Prettier's formatting (see also --check).\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  logLevel: {",
                    "    choices: [\"silent\", \"error\", \"warn\", \"log\", \"debug\"],",
                    "    default: \"log\",",
                    "    description: \"What level of logs to report.\",",
                    "    type: \"choice\",",
                    "  },",
                    "  pluginSearch: {",
                    "    oppositeDescription: \"Disable plugin autoloading.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  supportInfo: {",
                    "    description: \"Print support information as JSON.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  version: {",
                    "    alias: \"v\",",
                    "    description: \"Print Prettier version.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  withNodeModules: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    description: \"Process files inside 'node_modules' directory.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  write: {",
                    "    alias: \"w\",",
                    "    category: optionCategories.CATEGORY_OUTPUT,",
                    "    description: \"Edit files in-place. (Beware!)\",",
                    "    type: \"boolean\",",
                    "  },",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { outdent } from \"outdent\";",
                    "import { optionCategories } from \"./prettier-internal.js\";",
                    "",
                    "const categoryOrder = [",
                    "  optionCategories.CATEGORY_OUTPUT,",
                    "  optionCategories.CATEGORY_FORMAT,",
                    "  optionCategories.CATEGORY_CONFIG,",
                    "  optionCategories.CATEGORY_EDITOR,",
                    "  optionCategories.CATEGORY_OTHER,",
                    "];",
                    "",
                    "const usageSummary = outdent`",
                    "  Usage: prettier [options] [file/dir/glob ...]",
                    "",
                    "  By default, output is written to stdout.",
                    "  Stdin is read if it is piped to Prettier and no files are given.",
                    "`;",
                    "",
                    "export { categoryOrder, usageSummary };"
                ]
            },
            "context.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { getContextOptions } from \"./options/get-context-options.js\";",
                    "import {",
                    "  parseArgv,",
                    "  parseArgvWithoutPlugins,",
                    "} from \"./options/parse-cli-arguments.js\";",
                    "",
                    "/**",
                    " * @typedef {Object} Context",
                    " * @property logger",
                    " * @property {string[]} rawArguments",
                    " * @property argv",
                    " * @property {string[]} filePatterns",
                    " * @property {any[]} supportOptions",
                    " * @property detailedOptions",
                    " * @property languages",
                    " * @property {Partial<Context>[]} stack",
                    " * @property pushContextPlugins",
                    " * @property popContextPlugins",
                    " */",
                    "",
                    "class Context {",
                    "  #stack = [];",
                    "",
                    "  constructor({ rawArguments, logger }) {",
                    "    this.rawArguments = rawArguments;",
                    "    this.logger = logger;",
                    "  }",
                    "",
                    "  async init() {",
                    "    const { rawArguments, logger } = this;",
                    "",
                    "    const { plugins, pluginSearchDirs } = parseArgvWithoutPlugins(",
                    "      rawArguments,",
                    "      logger,",
                    "      [\"plugin\", \"plugin-search-dir\"]",
                    "    );",
                    "",
                    "    await this.pushContextPlugins(plugins, pluginSearchDirs);",
                    "",
                    "    const argv = parseArgv(rawArguments, this.detailedOptions, logger);",
                    "    this.argv = argv;",
                    "    this.filePatterns = argv._;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string[]} plugins",
                    "   * @param {string[]=} pluginSearchDirs",
                    "   */",
                    "  async pushContextPlugins(plugins, pluginSearchDirs) {",
                    "    const options = await getContextOptions(plugins, pluginSearchDirs);",
                    "    this.#stack.push(options);",
                    "    Object.assign(this, options);",
                    "  }",
                    "",
                    "  popContextPlugins() {",
                    "    this.#stack.pop();",
                    "    Object.assign(this, this.#stack.at(-1));",
                    "  }",
                    "",
                    "  // eslint-disable-next-line getter-return",
                    "  get performanceTestFlag() {",
                    "    const { debugBenchmark, debugRepeat } = this.argv;",
                    "    /* c8 ignore start */",
                    "    if (debugBenchmark) {",
                    "      return {",
                    "        name: \"--debug-benchmark\",",
                    "        debugBenchmark: true,",
                    "      };",
                    "    }",
                    "    /* c8 ignore stop */",
                    "",
                    "    if (debugRepeat > 0) {",
                    "      return {",
                    "        name: \"--debug-repeat\",",
                    "        debugRepeat,",
                    "      };",
                    "    }",
                    "",
                    "    /* c8 ignore start */",
                    "    const { PRETTIER_PERF_REPEAT } = process.env;",
                    "    if (PRETTIER_PERF_REPEAT && /^\\d+$/.test(PRETTIER_PERF_REPEAT)) {",
                    "      return {",
                    "        name: \"PRETTIER_PERF_REPEAT (environment variable)\",",
                    "        debugRepeat: Number(PRETTIER_PERF_REPEAT),",
                    "      };",
                    "    }",
                    "    /* c8 ignore stop */",
                    "  }",
                    "}",
                    "",
                    "export default Context;"
                ]
            },
            "expand-patterns.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import { statSafe, normalizeToPosix } from \"./utils.js\";",
                    "import { fastGlob } from \"./prettier-internal.js\";",
                    "",
                    "/** @typedef {import('./context').Context} Context */",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "async function* expandPatterns(context) {",
                    "  const seen = new Set();",
                    "  let noResults = true;",
                    "",
                    "  for await (const pathOrError of expandPatternsInternal(context)) {",
                    "    noResults = false;",
                    "    if (typeof pathOrError !== \"string\") {",
                    "      yield pathOrError;",
                    "      continue;",
                    "    }",
                    "",
                    "    const fileName = path.resolve(pathOrError);",
                    "",
                    "    // filter out duplicates",
                    "    if (seen.has(fileName)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    seen.add(fileName);",
                    "    yield fileName;",
                    "  }",
                    "",
                    "  if (noResults && context.argv.errorOnUnmatchedPattern !== false) {",
                    "    // If there was no files and no other errors, let's yield a general error.",
                    "    yield {",
                    "      error: `No matching files. Patterns: ${context.filePatterns.join(\" \")}`,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "async function* expandPatternsInternal(context) {",
                    "  // Ignores files in version control systems directories and `node_modules`",
                    "  const silentlyIgnoredDirs = [\".git\", \".sl\", \".svn\", \".hg\"];",
                    "  if (context.argv.withNodeModules !== true) {",
                    "    silentlyIgnoredDirs.push(\"node_modules\");",
                    "  }",
                    "  const globOptions = {",
                    "    dot: true,",
                    "    ignore: silentlyIgnoredDirs.map((dir) => \"**/\" + dir),",
                    "  };",
                    "",
                    "  let supportedFilesGlob;",
                    "  const cwd = process.cwd();",
                    "",
                    "  /** @type {Array<{ type: 'file' | 'dir' | 'glob'; glob: string; input: string; }>} */",
                    "  const entries = [];",
                    "",
                    "  for (const pattern of context.filePatterns) {",
                    "    const absolutePath = path.resolve(cwd, pattern);",
                    "",
                    "    if (containsIgnoredPathSegment(absolutePath, cwd, silentlyIgnoredDirs)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const stat = await statSafe(absolutePath);",
                    "    if (stat) {",
                    "      if (stat.isFile()) {",
                    "        entries.push({",
                    "          type: \"file\",",
                    "          glob: escapePathForGlob(fixWindowsSlashes(pattern)),",
                    "          input: pattern,",
                    "        });",
                    "      } else if (stat.isDirectory()) {",
                    "        /*",
                    "        1. Remove trailing `/`, `fast-glob` can't find files for `src//*.js` pattern",
                    "        2. Cleanup dirname, when glob `src/../*.js` pattern with `fast-glob`,",
                    "          it returns files like 'src/../index.js'",
                    "        */",
                    "        const relativePath = path.relative(cwd, absolutePath) || \".\";",
                    "        entries.push({",
                    "          type: \"dir\",",
                    "          glob:",
                    "            escapePathForGlob(fixWindowsSlashes(relativePath)) +",
                    "            \"/\" +",
                    "            getSupportedFilesGlob(),",
                    "          input: pattern,",
                    "        });",
                    "      }",
                    "    } else if (pattern[0] === \"!\") {",
                    "      // convert negative patterns to `ignore` entries",
                    "      globOptions.ignore.push(fixWindowsSlashes(pattern.slice(1)));",
                    "    } else {",
                    "      entries.push({",
                    "        type: \"glob\",",
                    "        glob: fixWindowsSlashes(pattern),",
                    "        input: pattern,",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  for (const { type, glob, input } of entries) {",
                    "    let result;",
                    "",
                    "    try {",
                    "      result = await fastGlob(glob, globOptions);",
                    "    } catch ({ message }) {",
                    "      /* c8 ignore next 4 */",
                    "      yield {",
                    "        error: `${errorMessages.globError[type]}: \"${input}\".\\n${message}`,",
                    "      };",
                    "      continue;",
                    "    }",
                    "",
                    "    if (result.length === 0) {",
                    "      if (context.argv.errorOnUnmatchedPattern !== false) {",
                    "        yield { error: `${errorMessages.emptyResults[type]}: \"${input}\".` };",
                    "      }",
                    "    } else {",
                    "      yield* sortPaths(result);",
                    "    }",
                    "  }",
                    "",
                    "  function getSupportedFilesGlob() {",
                    "    if (!supportedFilesGlob) {",
                    "      const extensions = context.languages.flatMap(",
                    "        (lang) => lang.extensions || []",
                    "      );",
                    "      const filenames = context.languages.flatMap(",
                    "        (lang) => lang.filenames || []",
                    "      );",
                    "      supportedFilesGlob = `**/{${[",
                    "        ...extensions.map((ext) => \"*\" + (ext[0] === \".\" ? ext : \".\" + ext)),",
                    "        ...filenames,",
                    "      ]}}`;",
                    "    }",
                    "    return supportedFilesGlob;",
                    "  }",
                    "}",
                    "",
                    "const errorMessages = {",
                    "  globError: {",
                    "    file: \"Unable to resolve file\",",
                    "    dir: \"Unable to expand directory\",",
                    "    glob: \"Unable to expand glob pattern\",",
                    "  },",
                    "  emptyResults: {",
                    "    file: \"Explicitly specified file was ignored due to negative glob patterns\",",
                    "    dir: \"No supported files were found in the directory\",",
                    "    glob: \"No files matching the pattern were found\",",
                    "  },",
                    "};",
                    "",
                    "/**",
                    " * @param {string} absolutePath",
                    " * @param {string} cwd",
                    " * @param {string[]} ignoredDirectories",
                    " */",
                    "function containsIgnoredPathSegment(absolutePath, cwd, ignoredDirectories) {",
                    "  return path",
                    "    .relative(cwd, absolutePath)",
                    "    .split(path.sep)",
                    "    .some((dir) => ignoredDirectories.includes(dir));",
                    "}",
                    "",
                    "/**",
                    " * @param {string[]} paths",
                    " */",
                    "function sortPaths(paths) {",
                    "  return paths.sort((a, b) => a.localeCompare(b));",
                    "}",
                    "",
                    "/**",
                    " * This function should be replaced with `fastGlob.escapePath` when these issues are fixed:",
                    " * - https://github.com/mrmlnc/fast-glob/issues/261",
                    " * - https://github.com/mrmlnc/fast-glob/issues/262",
                    " * @param {string} path",
                    " */",
                    "function escapePathForGlob(path) {",
                    "  return fastGlob",
                    "    .escapePath(",
                    "      path.replaceAll(\"\\\\\", \"\\0\") // Workaround for fast-glob#262 (part 1)",
                    "    )",
                    "    .replaceAll(\"\\\\!\", \"@(!)\") // Workaround for fast-glob#261",
                    "    .replaceAll(\"\\0\", \"@(\\\\\\\\)\"); // Workaround for fast-glob#262 (part 2)",
                    "}",
                    "",
                    "/**",
                    " * Using backslashes in globs is probably not okay, but not accepting",
                    " * backslashes as path separators on Windows is even more not okay.",
                    " * https://github.com/prettier/prettier/pull/6776#discussion_r380723717",
                    " * https://github.com/mrmlnc/fast-glob#how-to-write-patterns-on-windows",
                    " */",
                    "const fixWindowsSlashes = normalizeToPosix;",
                    "",
                    "export { expandPatterns };"
                ]
            },
            "file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import stringify from \"fast-json-stable-stringify\";",
                    "import { format, getFileInfo } from \"../index.js\";",
                    "import { printToScreen } from \"./utils.js\";",
                    "",
                    "async function logFileInfoOrDie(context) {",
                    "  const {",
                    "    fileInfo: file,",
                    "    ignorePath,",
                    "    withNodeModules,",
                    "    plugins,",
                    "    pluginSearchDirs,",
                    "    config,",
                    "  } = context.argv;",
                    "",
                    "  const fileInfo = await getFileInfo(file, {",
                    "    ignorePath,",
                    "    withNodeModules,",
                    "    plugins,",
                    "    pluginSearchDirs,",
                    "    resolveConfig: config !== false,",
                    "  });",
                    "",
                    "  printToScreen(await format(stringify(fileInfo), { parser: \"json\" }));",
                    "}",
                    "",
                    "export default logFileInfoOrDie;"
                ]
            },
            "find-cache-file.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "import os from \"node:os\";",
                    "import path from \"node:path\";",
                    "import findCacheDir from \"find-cache-dir\";",
                    "import { statSafe, isJson } from \"./utils.js\";",
                    "",
                    "/**",
                    " * Find default cache file (`./node_modules/.cache/prettier/.prettier-cache`) using https://github.com/avajs/find-cache-dir",
                    " */",
                    "function findDefaultCacheFile() {",
                    "  const cacheDir =",
                    "    findCacheDir({ name: \"prettier\", create: true }) || os.tmpdir();",
                    "  const cacheFilePath = path.join(cacheDir, \".prettier-cache\");",
                    "  return cacheFilePath;",
                    "}",
                    "",
                    "async function findCacheFileFromOption(cacheLocation) {",
                    "  const cacheFile = path.resolve(cacheLocation);",
                    "",
                    "  const stat = await statSafe(cacheFile);",
                    "  if (stat) {",
                    "    if (stat.isDirectory()) {",
                    "      throw new Error(",
                    "        `Resolved --cache-location '${cacheFile}' is a directory`",
                    "      );",
                    "    }",
                    "",
                    "    const data = await fs.readFile(cacheFile, \"utf8\");",
                    "    if (!isJson(data)) {",
                    "      throw new Error(`'${cacheFile}' isn't a valid JSON file`);",
                    "    }",
                    "  }",
                    "",
                    "  return cacheFile;",
                    "}",
                    "",
                    "/**",
                    " * @param {string | undefined} cacheLocation",
                    " * @returns {Promise<string>}",
                    " */",
                    "async function findCacheFile(cacheLocation) {",
                    "  if (!cacheLocation) {",
                    "    return findDefaultCacheFile();",
                    "  }",
                    "  const cacheFile = await findCacheFileFromOption(cacheLocation);",
                    "  return cacheFile;",
                    "}",
                    "",
                    "export default findCacheFile;"
                ]
            },
            "find-config-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import { resolveConfigFile } from \"../index.js\";",
                    "import { printToScreen, normalizeToPosix } from \"./utils.js\";",
                    "",
                    "async function logResolvedConfigPathOrDie(context) {",
                    "  const file = context.argv.findConfigPath;",
                    "  const configFile = await resolveConfigFile(file);",
                    "  if (configFile) {",
                    "    printToScreen(normalizeToPosix(path.relative(process.cwd(), configFile)));",
                    "  } else {",
                    "    throw new Error(`Can not find configure file for \"${file}\".`);",
                    "  }",
                    "}",
                    "",
                    "export default logResolvedConfigPathOrDie;"
                ]
            },
            "format-results-cache.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// Inspired by LintResultsCache from ESLint",
                    "// https://github.com/eslint/eslint/blob/c2d0a830754b6099a3325e6d3348c3ba983a677a/lib/cli-engine/lint-result-cache.js",
                    "",
                    "import fileEntryCache from \"file-entry-cache\";",
                    "import stringify from \"fast-json-stable-stringify\";",
                    "import { version as prettierVersion } from \"../index.js\";",
                    "import { createHash } from \"./utils.js\";",
                    "",
                    "const optionsHashCache = new WeakMap();",
                    "const nodeVersion = process.version;",
                    "",
                    "/**",
                    " * @param {*} options",
                    " * @returns {string}",
                    " */",
                    "function getHashOfOptions(options) {",
                    "  if (optionsHashCache.has(options)) {",
                    "    return optionsHashCache.get(options);",
                    "  }",
                    "  const hash = createHash(",
                    "    `${prettierVersion}_${nodeVersion}_${stringify(options)}`",
                    "  );",
                    "  optionsHashCache.set(options, hash);",
                    "  return hash;",
                    "}",
                    "",
                    "/**",
                    " * @typedef {{ hashOfOptions?: string }} OurMeta",
                    " * @typedef {import(\"file-entry-cache\").FileDescriptor} FileDescriptor",
                    " *",
                    " * @param {import(\"file-entry-cache\").FileDescriptor} fileDescriptor",
                    " * @returns {FileDescriptor[\"meta\"] & OurMeta}",
                    " */",
                    "function getMetadataFromFileDescriptor(fileDescriptor) {",
                    "  return fileDescriptor.meta;",
                    "}",
                    "",
                    "class FormatResultsCache {",
                    "  #fileEntryCache;",
                    "",
                    "  /**",
                    "   * @param {string} cacheFileLocation The path of cache file location. (default: `node_modules/.cache/prettier/.prettier-cache`)",
                    "   * @param {string} cacheStrategy",
                    "   */",
                    "  constructor(cacheFileLocation, cacheStrategy) {",
                    "    const useChecksum = cacheStrategy === \"content\";",
                    "",
                    "    this.#fileEntryCache = fileEntryCache.create(",
                    "      /* cacheId */ cacheFileLocation,",
                    "      /* directory */ undefined,",
                    "      useChecksum",
                    "    );",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string} filePath",
                    "   * @param {any} options",
                    "   */",
                    "  existsAvailableFormatResultsCache(filePath, options) {",
                    "    const fileDescriptor = this.#fileEntryCache.getFileDescriptor(filePath);",
                    "",
                    "    /* c8 ignore next 3 */",
                    "    if (fileDescriptor.notFound) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const hashOfOptions = getHashOfOptions(options);",
                    "    const meta = getMetadataFromFileDescriptor(fileDescriptor);",
                    "    const changed =",
                    "      fileDescriptor.changed || meta.hashOfOptions !== hashOfOptions;",
                    "",
                    "    return !changed;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string} filePath",
                    "   * @param {any} options",
                    "   */",
                    "  setFormatResultsCache(filePath, options) {",
                    "    const fileDescriptor = this.#fileEntryCache.getFileDescriptor(filePath);",
                    "    const meta = getMetadataFromFileDescriptor(fileDescriptor);",
                    "    if (fileDescriptor && !fileDescriptor.notFound) {",
                    "      meta.hashOfOptions = getHashOfOptions(options);",
                    "    }",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string} filePath",
                    "   */",
                    "  removeFormatResultsCache(filePath) {",
                    "    this.#fileEntryCache.removeEntry(filePath);",
                    "  }",
                    "",
                    "  reconcile() {",
                    "    this.#fileEntryCache.reconcile();",
                    "  }",
                    "}",
                    "",
                    "export default FormatResultsCache;"
                ]
            },
            "format.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "import path from \"node:path\";",
                    "import chalk from \"chalk\";",
                    "import { createTwoFilesPatch } from \"diff\";",
                    "import * as prettier from \"../index.js\";",
                    "import mockable from \"../common/mockable.js\";",
                    "import { createIsIgnoredFunction, errors } from \"./prettier-internal.js\";",
                    "import { expandPatterns } from \"./expand-patterns.js\";",
                    "import getOptionsForFile from \"./options/get-options-for-file.js\";",
                    "import isTTY from \"./is-tty.js\";",
                    "import findCacheFile from \"./find-cache-file.js\";",
                    "import FormatResultsCache from \"./format-results-cache.js\";",
                    "import { statSafe, normalizeToPosix } from \"./utils.js\";",
                    "",
                    "const { getStdin, writeFormattedFile } = mockable;",
                    "",
                    "function diff(a, b) {",
                    "  return createTwoFilesPatch(\"\", \"\", a, b, \"\", \"\", { context: 2 });",
                    "}",
                    "",
                    "class DebugError extends Error {}",
                    "",
                    "function handleError(context, filename, error, printedFilename) {",
                    "  if (error instanceof errors.UndefinedParserError) {",
                    "    // Can't test on CI, `isTTY()` is always false, see ./is-tty.js",
                    "    /* c8 ignore next 3 */",
                    "    if ((context.argv.write || context.argv.ignoreUnknown) && printedFilename) {",
                    "      printedFilename.clear();",
                    "    }",
                    "",
                    "    if (context.argv.ignoreUnknown) {",
                    "      return;",
                    "    }",
                    "    if (!context.argv.check && !context.argv.listDifferent) {",
                    "      process.exitCode = 2;",
                    "    }",
                    "    context.logger.error(error.message);",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.write) {",
                    "    // Add newline to split errors from filename line.",
                    "    process.stdout.write(\"\\n\");",
                    "  }",
                    "",
                    "  const isParseError = Boolean(error?.loc);",
                    "  const isValidationError = /^Invalid \\S+ value\\./.test(error?.message);",
                    "",
                    "  if (isParseError) {",
                    "    // `invalid.js: SyntaxError: Unexpected token (1:1)`.",
                    "    context.logger.error(`${filename}: ${String(error)}`);",
                    "  } else if (isValidationError || error instanceof errors.ConfigError) {",
                    "    // `Invalid printWidth value. Expected an integer, but received 0.5.`",
                    "    context.logger.error(error.message);",
                    "    // If validation fails for one file, it will fail for all of them.",
                    "    process.exit(1);",
                    "  } else if (error instanceof DebugError) {",
                    "    // `invalid.js: Some debug error message`",
                    "    context.logger.error(`${filename}: ${error.message}`);",
                    "  } else {",
                    "    // `invalid.js: Error: Some unexpected error\\n[stack trace]`",
                    "    /* c8 ignore next */",
                    "    context.logger.error(filename + \": \" + (error.stack || error));",
                    "  }",
                    "",
                    "  // Don't exit the process if one file failed",
                    "  process.exitCode = 2;",
                    "}",
                    "",
                    "function writeOutput(context, result, options) {",
                    "  // Don't use `console.log` here since it adds an extra newline at the end.",
                    "  process.stdout.write(",
                    "    context.argv.debugCheck ? result.filepath : result.formatted",
                    "  );",
                    "",
                    "  if (options && options.cursorOffset >= 0) {",
                    "    process.stderr.write(result.cursorOffset + \"\\n\");",
                    "  }",
                    "}",
                    "",
                    "async function listDifferent(context, input, options, filename) {",
                    "  if (!context.argv.check && !context.argv.listDifferent) {",
                    "    return;",
                    "  }",
                    "",
                    "  try {",
                    "    if (!options.filepath && !options.parser) {",
                    "      throw new errors.UndefinedParserError(",
                    "        \"No parser and no file path given, couldn't infer a parser.\"",
                    "      );",
                    "    }",
                    "    if (!(await prettier.check(input, options)) && !context.argv.write) {",
                    "      context.logger.log(filename);",
                    "      process.exitCode = 1;",
                    "    }",
                    "  } catch (error) {",
                    "    context.logger.error(error.message);",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "async function format(context, input, opt) {",
                    "  if (!opt.parser && !opt.filepath) {",
                    "    throw new errors.UndefinedParserError(",
                    "      \"No parser and no file path given, couldn't infer a parser.\"",
                    "    );",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintDoc) {",
                    "    const doc = await prettier.__debug.printToDoc(input, opt);",
                    "    return { formatted: (await prettier.__debug.formatDoc(doc)) + \"\\n\" };",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintComments) {",
                    "    return {",
                    "      formatted: await prettier.format(",
                    "        JSON.stringify(",
                    "          (await prettier.formatWithCursor(input, opt)).comments || []",
                    "        ),",
                    "        { parser: \"json\" }",
                    "      ),",
                    "    };",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintAst) {",
                    "    const { ast } = await prettier.__debug.parse(input, opt);",
                    "    return {",
                    "      formatted: JSON.stringify(ast),",
                    "    };",
                    "  }",
                    "",
                    "  if (context.argv.debugCheck) {",
                    "    const pp = await prettier.format(input, opt);",
                    "    const pppp = await prettier.format(pp, opt);",
                    "    if (pp !== pppp) {",
                    "      throw new DebugError(",
                    "        \"prettier(input) !== prettier(prettier(input))\\n\" + diff(pp, pppp)",
                    "      );",
                    "    } else {",
                    "      const stringify = (obj) => JSON.stringify(obj, null, 2);",
                    "      const ast = stringify(",
                    "        (await prettier.__debug.parse(input, opt, { massage: true })).ast",
                    "      );",
                    "      const past = stringify(",
                    "        (await prettier.__debug.parse(pp, opt, { massage: true })).ast",
                    "      );",
                    "",
                    "      /* c8 ignore start */",
                    "      if (ast !== past) {",
                    "        const MAX_AST_SIZE = 2097152; // 2MB",
                    "        const astDiff =",
                    "          ast.length > MAX_AST_SIZE || past.length > MAX_AST_SIZE",
                    "            ? \"AST diff too large to render\"",
                    "            : diff(ast, past);",
                    "        throw new DebugError(",
                    "          \"ast(input) !== ast(prettier(input))\\n\" +",
                    "            astDiff +",
                    "            \"\\n\" +",
                    "            diff(input, pp)",
                    "        );",
                    "      }",
                    "      /* c8 ignore end */",
                    "    }",
                    "    return { formatted: pp, filepath: opt.filepath || \"(stdin)\\n\" };",
                    "  }",
                    "",
                    "  const { performanceTestFlag } = context;",
                    "  if (performanceTestFlag?.debugBenchmark) {",
                    "    let benchmark;",
                    "    try {",
                    "      // eslint-disable-next-line import/no-extraneous-dependencies",
                    "      ({ default: benchmark } = await import(\"benchmark\"));",
                    "    } catch {",
                    "      context.logger.debug(",
                    "        \"'--debug-benchmark' requires the 'benchmark' package to be installed.\"",
                    "      );",
                    "      process.exit(2);",
                    "    }",
                    "    context.logger.debug(",
                    "      \"'--debug-benchmark' option found, measuring formatWithCursor with 'benchmark' module.\"",
                    "    );",
                    "    const suite = new benchmark.Suite();",
                    "    suite.add(\"format\", {",
                    "      defer: true,",
                    "      async fn(deferred) {",
                    "        await prettier.formatWithCursor(input, opt);",
                    "        deferred.resolve();",
                    "      },",
                    "    });",
                    "    const result = await new Promise((resolve) => {",
                    "      suite",
                    "        .on(\"complete\", (event) => {",
                    "          resolve({",
                    "            benchmark: String(event.target),",
                    "            hz: event.target.hz,",
                    "            ms: event.target.times.cycle * 1000,",
                    "          });",
                    "        })",
                    "        .run({ async: false });",
                    "    });",
                    "    context.logger.debug(",
                    "      \"'--debug-benchmark' measurements for formatWithCursor: \" +",
                    "        JSON.stringify(result, null, 2)",
                    "    );",
                    "  } else if (performanceTestFlag?.debugRepeat) {",
                    "    const repeat = performanceTestFlag.debugRepeat;",
                    "    context.logger.debug(",
                    "      `'${performanceTestFlag.name}' found, running formatWithCursor ${repeat} times.`",
                    "    );",
                    "    let totalMs = 0;",
                    "    for (let i = 0; i < repeat; ++i) {",
                    "      // should be using `performance.now()`, but only `Date` is cross-platform enough",
                    "      const startMs = Date.now();",
                    "      await prettier.formatWithCursor(input, opt);",
                    "      totalMs += Date.now() - startMs;",
                    "    }",
                    "    const averageMs = totalMs / repeat;",
                    "    const results = {",
                    "      repeat,",
                    "      hz: 1000 / averageMs,",
                    "      ms: averageMs,",
                    "    };",
                    "    context.logger.debug(",
                    "      `'${",
                    "        performanceTestFlag.name",
                    "      }' measurements for formatWithCursor: ${JSON.stringify(results, null, 2)}`",
                    "    );",
                    "  }",
                    "",
                    "  return prettier.formatWithCursor(input, opt);",
                    "}",
                    "",
                    "async function createIsIgnoredFromContextOrDie(context) {",
                    "  try {",
                    "    return await createIsIgnoredFunction(",
                    "      context.argv.ignorePath,",
                    "      context.argv.withNodeModules",
                    "    );",
                    "  } catch (e) {",
                    "    context.logger.error(e.message);",
                    "    process.exit(2);",
                    "  }",
                    "}",
                    "",
                    "async function formatStdin(context) {",
                    "  const { filepath } = context.argv;",
                    "",
                    "  try {",
                    "    const input = await getStdin();",
                    "",
                    "    let isFileIgnored = false;",
                    "    if (filepath) {",
                    "      const isIgnored = await createIsIgnoredFromContextOrDie(context);",
                    "      isFileIgnored = isIgnored(filepath);",
                    "    }",
                    "",
                    "    if (isFileIgnored) {",
                    "      writeOutput(context, { formatted: input });",
                    "      return;",
                    "    }",
                    "",
                    "    const options = await getOptionsForFile(",
                    "      context,",
                    "      filepath ? path.resolve(process.cwd(), filepath) : process.cwd()",
                    "    );",
                    "",
                    "    if (await listDifferent(context, input, options, \"(stdin)\")) {",
                    "      return;",
                    "    }",
                    "",
                    "    const formatted = await format(context, input, options);",
                    "",
                    "    const { performanceTestFlag } = context;",
                    "    if (performanceTestFlag) {",
                    "      context.logger.log(",
                    "        `'${performanceTestFlag.name}' option found, skipped print code to screen.`",
                    "      );",
                    "      return;",
                    "    }",
                    "",
                    "    writeOutput(context, formatted, options);",
                    "  } catch (error) {",
                    "    handleError(context, filepath || \"stdin\", error);",
                    "  }",
                    "}",
                    "",
                    "async function formatFiles(context) {",
                    "  // This will be used to filter file paths after the glob is checked,",
                    "  // before any files are actually written",
                    "  const isIgnored = await createIsIgnoredFromContextOrDie(context);",
                    "  const cwd = process.cwd();",
                    "",
                    "  let numberOfUnformattedFilesFound = 0;",
                    "  const { performanceTestFlag } = context;",
                    "",
                    "  if (context.argv.check && !performanceTestFlag) {",
                    "    context.logger.log(\"Checking formatting...\");",
                    "  }",
                    "",
                    "  let formatResultsCache;",
                    "  const cacheFilePath = await findCacheFile(context.argv.cacheLocation);",
                    "  if (context.argv.cache) {",
                    "    formatResultsCache = new FormatResultsCache(",
                    "      cacheFilePath,",
                    "      context.argv.cacheStrategy || \"content\"",
                    "    );",
                    "  } else {",
                    "    if (context.argv.cacheStrategy) {",
                    "      context.logger.error(",
                    "        \"`--cache-strategy` cannot be used without `--cache`.\"",
                    "      );",
                    "      process.exit(2);",
                    "    }",
                    "    if (!context.argv.cacheLocation) {",
                    "      const stat = await statSafe(cacheFilePath);",
                    "      if (stat) {",
                    "        await fs.unlink(cacheFilePath);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  for await (const pathOrError of expandPatterns(context)) {",
                    "    if (typeof pathOrError === \"object\") {",
                    "      context.logger.error(pathOrError.error);",
                    "      // Don't exit, but set the exit code to 2",
                    "      process.exitCode = 2;",
                    "      continue;",
                    "    }",
                    "",
                    "    const filename = pathOrError;",
                    "",
                    "    const isFileIgnored = isIgnored(filename);",
                    "    if (",
                    "      isFileIgnored &&",
                    "      (context.argv.debugCheck ||",
                    "        context.argv.write ||",
                    "        context.argv.check ||",
                    "        context.argv.listDifferent)",
                    "    ) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const options = {",
                    "      ...(await getOptionsForFile(context, filename)),",
                    "      filepath: filename,",
                    "    };",
                    "",
                    "    const fileNameToDisplay = normalizeToPosix(path.relative(cwd, filename));",
                    "    let printedFilename;",
                    "    if (isTTY()) {",
                    "      printedFilename = context.logger.log(fileNameToDisplay, {",
                    "        newline: false,",
                    "        clearable: true,",
                    "      });",
                    "    }",
                    "",
                    "    let input;",
                    "    try {",
                    "      input = await fs.readFile(filename, \"utf8\");",
                    "    } catch (error) {",
                    "      // Add newline to split errors from filename line.",
                    "      /* c8 ignore start */",
                    "      context.logger.log(\"\");",
                    "",
                    "      context.logger.error(",
                    "        `Unable to read file \"${fileNameToDisplay}\":\\n${error.message}`",
                    "      );",
                    "",
                    "      // Don't exit the process if one file failed",
                    "      process.exitCode = 2;",
                    "",
                    "      continue;",
                    "      /* c8 ignore stop */",
                    "    }",
                    "",
                    "    if (isFileIgnored) {",
                    "      writeOutput(context, { formatted: input }, options);",
                    "      continue;",
                    "    }",
                    "",
                    "    const start = Date.now();",
                    "",
                    "    const isCacheExists = formatResultsCache?.existsAvailableFormatResultsCache(",
                    "      filename,",
                    "      options",
                    "    );",
                    "",
                    "    let result;",
                    "    let output;",
                    "",
                    "    try {",
                    "      if (isCacheExists) {",
                    "        result = { formatted: input };",
                    "      } else {",
                    "        result = await format(context, input, options);",
                    "      }",
                    "      output = result.formatted;",
                    "    } catch (error) {",
                    "      handleError(context, fileNameToDisplay, error, printedFilename);",
                    "      continue;",
                    "    }",
                    "",
                    "    const isDifferent = output !== input;",
                    "    let shouldSetCache = !isDifferent;",
                    "",
                    "    if (printedFilename) {",
                    "      // Remove previously printed filename to log it with duration.",
                    "      printedFilename.clear();",
                    "    }",
                    "",
                    "    if (performanceTestFlag) {",
                    "      context.logger.log(",
                    "        `'${performanceTestFlag.name}' option found, skipped print code or write files.`",
                    "      );",
                    "      return;",
                    "    }",
                    "",
                    "    if (context.argv.write) {",
                    "      // Don't write the file if it won't change in order not to invalidate",
                    "      // mtime based caches.",
                    "      if (isDifferent) {",
                    "        if (!context.argv.check && !context.argv.listDifferent) {",
                    "          context.logger.log(`${fileNameToDisplay} ${Date.now() - start}ms`);",
                    "        }",
                    "",
                    "        try {",
                    "          await writeFormattedFile(filename, output);",
                    "",
                    "          // Set cache if format succeeds",
                    "          shouldSetCache = true;",
                    "        } catch (error) {",
                    "          context.logger.error(",
                    "            `Unable to write file \"${fileNameToDisplay}\":\\n${error.message}`",
                    "          );",
                    "",
                    "          // Don't exit the process if one file failed",
                    "          process.exitCode = 2;",
                    "        }",
                    "      } else if (!context.argv.check && !context.argv.listDifferent) {",
                    "        const message = `${chalk.grey(fileNameToDisplay)} ${",
                    "          Date.now() - start",
                    "        }ms`;",
                    "        if (isCacheExists) {",
                    "          context.logger.log(`${message} (cached)`);",
                    "        } else {",
                    "          context.logger.log(message);",
                    "        }",
                    "      }",
                    "    } else if (context.argv.debugCheck) {",
                    "      if (result.filepath) {",
                    "        context.logger.log(fileNameToDisplay);",
                    "      } else {",
                    "        /* c8 ignore next */",
                    "        process.exitCode = 2;",
                    "      }",
                    "    } else if (!context.argv.check && !context.argv.listDifferent) {",
                    "      writeOutput(context, result, options);",
                    "    }",
                    "",
                    "    if (shouldSetCache) {",
                    "      formatResultsCache?.setFormatResultsCache(filename, options);",
                    "    } else {",
                    "      formatResultsCache?.removeFormatResultsCache(filename);",
                    "    }",
                    "",
                    "    if (isDifferent) {",
                    "      if (context.argv.check) {",
                    "        context.logger.warn(fileNameToDisplay);",
                    "      } else if (context.argv.listDifferent) {",
                    "        context.logger.log(fileNameToDisplay);",
                    "      }",
                    "      numberOfUnformattedFilesFound += 1;",
                    "    }",
                    "  }",
                    "",
                    "  formatResultsCache?.reconcile();",
                    "",
                    "  // Print check summary based on expected exit code",
                    "  if (context.argv.check) {",
                    "    if (numberOfUnformattedFilesFound === 0) {",
                    "      context.logger.log(\"All matched files use Prettier code style!\");",
                    "    } else {",
                    "      const files =",
                    "        numberOfUnformattedFilesFound === 1",
                    "          ? \"the above file\"",
                    "          : `${numberOfUnformattedFilesFound} files`;",
                    "      context.logger.warn(",
                    "        context.argv.write",
                    "          ? `Code style issues fixed in ${files}.`",
                    "          : `Code style issues found in ${files}. Run Prettier to fix.`",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  // Ensure non-zero exitCode when using --check/list-different is not combined with --write",
                    "  if (",
                    "    (context.argv.check || context.argv.listDifferent) &&",
                    "    numberOfUnformattedFilesFound > 0 &&",
                    "    !process.exitCode &&",
                    "    !context.argv.write",
                    "  ) {",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "export { formatStdin, formatFiles };"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as prettier from \"../index.js\";",
                    "import createLogger from \"./logger.js\";",
                    "import Context from \"./context.js\";",
                    "import { parseArgvWithoutPlugins } from \"./options/parse-cli-arguments.js\";",
                    "import { createDetailedUsage, createUsage } from \"./usage.js\";",
                    "import { formatStdin, formatFiles } from \"./format.js\";",
                    "import logFileInfoOrDie from \"./file-info.js\";",
                    "import logResolvedConfigPathOrDie from \"./find-config-path.js\";",
                    "import { printToScreen, isNonEmptyArray } from \"./utils.js\";",
                    "import printSupportInfo from \"./print-support-info.js\";",
                    "",
                    "async function run(rawArguments) {",
                    "  // Create a default level logger, so we can log errors during `logLevel` parsing",
                    "  let logger = createLogger();",
                    "",
                    "  try {",
                    "    const { logLevel } = parseArgvWithoutPlugins(",
                    "      rawArguments,",
                    "      logger,",
                    "      \"log-level\"",
                    "    );",
                    "    if (logLevel !== logger.logLevel) {",
                    "      logger = createLogger(logLevel);",
                    "    }",
                    "    const context = new Context({ rawArguments, logger });",
                    "    await context.init();",
                    "    if (logger.logLevel !== \"debug\" && context.performanceTestFlag) {",
                    "      context.logger = createLogger(\"debug\");",
                    "    }",
                    "",
                    "    await main(context);",
                    "  } catch (error) {",
                    "    logger.error(error.message);",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "async function main(context) {",
                    "  context.logger.debug(`normalized argv: ${JSON.stringify(context.argv)}`);",
                    "",
                    "  if (context.argv.pluginSearch === false) {",
                    "    const rawPluginSearchDirs = context.argv.__raw[\"plugin-search-dir\"];",
                    "    if (",
                    "      typeof rawPluginSearchDirs === \"string\" ||",
                    "      isNonEmptyArray(rawPluginSearchDirs)",
                    "    ) {",
                    "      throw new Error(",
                    "        \"Cannot use --no-plugin-search and --plugin-search-dir together.\"",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (context.argv.check && context.argv.listDifferent) {",
                    "    throw new Error(\"Cannot use --check and --list-different together.\");",
                    "  }",
                    "",
                    "  if (context.argv.write && context.argv.debugCheck) {",
                    "    throw new Error(\"Cannot use --write and --debug-check together.\");",
                    "  }",
                    "",
                    "  if (context.argv.findConfigPath && context.filePatterns.length > 0) {",
                    "    throw new Error(\"Cannot use --find-config-path with multiple files\");",
                    "  }",
                    "",
                    "  if (context.argv.fileInfo && context.filePatterns.length > 0) {",
                    "    throw new Error(\"Cannot use --file-info with multiple files\");",
                    "  }",
                    "",
                    "  if (context.argv.version) {",
                    "    printToScreen(prettier.version);",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.help !== undefined) {",
                    "    printToScreen(",
                    "      typeof context.argv.help === \"string\" && context.argv.help !== \"\"",
                    "        ? createDetailedUsage(context, context.argv.help)",
                    "        : createUsage(context)",
                    "    );",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.supportInfo) {",
                    "    return printSupportInfo();",
                    "  }",
                    "",
                    "  const hasFilePatterns = context.filePatterns.length > 0;",
                    "  const useStdin =",
                    "    !hasFilePatterns && (!process.stdin.isTTY || context.argv.filePath);",
                    "",
                    "  if (context.argv.findConfigPath) {",
                    "    await logResolvedConfigPathOrDie(context);",
                    "  } else if (context.argv.fileInfo) {",
                    "    await logFileInfoOrDie(context);",
                    "  } else if (useStdin) {",
                    "    if (context.argv.cache) {",
                    "      context.logger.error(\"`--cache` cannot be used with stdin.\");",
                    "      process.exit(2);",
                    "    }",
                    "    await formatStdin(context);",
                    "  } else if (hasFilePatterns) {",
                    "    await formatFiles(context);",
                    "  } else {",
                    "    process.exitCode = 1;",
                    "    printToScreen(createUsage(context));",
                    "  }",
                    "}",
                    "",
                    "export { run };"
                ]
            },
            "is-tty.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import mockable from \"../common/mockable.js\";",
                    "",
                    "// Some CI pipelines incorrectly report process.stdout.isTTY status,",
                    "// which causes unwanted lines in the output. An additional check for isCI() helps.",
                    "// See https://github.com/prettier/prettier/issues/5801",
                    "export default function isTTY() {",
                    "  return process.stdout.isTTY && !mockable.isCI();",
                    "}"
                ]
            },
            "logger.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import readline from \"node:readline\";",
                    "import chalk, { chalkStderr } from \"chalk\";",
                    "import stripAnsi from \"strip-ansi\";",
                    "import wcwidth from \"wcwidth\";",
                    "",
                    "const countLines = (stream, text) => {",
                    "  const columns = stream.columns || 80;",
                    "  let lineCount = 0;",
                    "  for (const line of stripAnsi(text).split(\"\\n\")) {",
                    "    lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));",
                    "  }",
                    "  return lineCount;",
                    "};",
                    "",
                    "const clear = (stream, text) => () => {",
                    "  const lineCount = countLines(stream, text);",
                    "",
                    "  for (let line = 0; line < lineCount; line++) {",
                    "    /* c8 ignore next 3 */",
                    "    if (line > 0) {",
                    "      readline.moveCursor(stream, 0, -1);",
                    "    }",
                    "",
                    "    readline.clearLine(stream, 0);",
                    "    readline.cursorTo(stream, 0);",
                    "  }",
                    "};",
                    "",
                    "const emptyLogResult = { clear() {} };",
                    "function createLogger(logLevel = \"log\") {",
                    "  return {",
                    "    logLevel,",
                    "    warn: createLogFunc(\"warn\", \"yellow\"),",
                    "    error: createLogFunc(\"error\", \"red\"),",
                    "    debug: createLogFunc(\"debug\", \"blue\"),",
                    "    log: createLogFunc(\"log\"),",
                    "  };",
                    "",
                    "  function createLogFunc(loggerName, color) {",
                    "    if (!shouldLog(loggerName)) {",
                    "      return () => emptyLogResult;",
                    "    }",
                    "",
                    "    const stream = process[loggerName === \"log\" ? \"stdout\" : \"stderr\"];",
                    "    const chalkInstance = loggerName === \"log\" ? chalk : chalkStderr;",
                    "    const prefix = color ? `[${chalkInstance[color](loggerName)}] ` : \"\";",
                    "",
                    "    return (message, options) => {",
                    "      options = {",
                    "        newline: true,",
                    "        clearable: false,",
                    "        ...options,",
                    "      };",
                    "      message =",
                    "        message.replaceAll(/^/gm, prefix) + (options.newline ? \"\\n\" : \"\");",
                    "      stream.write(message);",
                    "",
                    "      if (options.clearable) {",
                    "        return {",
                    "          clear: clear(stream, message),",
                    "        };",
                    "      }",
                    "    };",
                    "  }",
                    "",
                    "  function shouldLog(loggerName) {",
                    "    switch (logLevel) {",
                    "      case \"silent\":",
                    "        return false;",
                    "      case \"debug\":",
                    "        if (loggerName === \"debug\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"log\":",
                    "        if (loggerName === \"log\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"warn\":",
                    "        if (loggerName === \"warn\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"error\":",
                    "        return loggerName === \"error\";",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "export default createLogger;"
                ]
            },
            "prettier-internal.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// @ts-expect-error",
                    "import { __internal as sharedWithCli } from \"../index.js\";",
                    "",
                    "export const {",
                    "  errors,",
                    "  optionCategories,",
                    "  createIsIgnoredFunction,",
                    "  formatOptionsHiddenDefaults,",
                    "  normalizeOptions,",
                    "  getSupportInfoWithoutPlugins,",
                    "  normalizeOptionSettings,",
                    "  vnopts,",
                    "  fastGlob,",
                    "} = sharedWithCli;"
                ]
            },
            "print-support-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import stringify from \"fast-json-stable-stringify\";",
                    "import { getSupportInfo, format } from \"../index.js\";",
                    "import { printToScreen, omit } from \"./utils.js\";",
                    "",
                    "const sortByName = (array) =>",
                    "  array.sort((a, b) => a.name.localeCompare(b.name));",
                    "",
                    "async function printSupportInfo() {",
                    "  const { languages, options } = await getSupportInfo();",
                    "  const supportInfo = {",
                    "    languages: sortByName(languages),",
                    "    options: sortByName(options).map((option) =>",
                    "      omit(option, [\"cliName\", \"cliCategory\", \"cliDescription\"])",
                    "    ),",
                    "  };",
                    "",
                    "  printToScreen(await format(stringify(supportInfo), { parser: \"json\" }));",
                    "}",
                    "",
                    "export default printSupportInfo;"
                ]
            },
            "usage.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import camelCase from \"camelcase\";",
                    "import { categoryOrder, usageSummary } from \"./constants.evaluate.js\";",
                    "import { groupBy } from \"./utils.js\";",
                    "import { formatOptionsHiddenDefaults } from \"./prettier-internal.js\";",
                    "",
                    "const OPTION_USAGE_THRESHOLD = 25;",
                    "const CHOICE_USAGE_MARGIN = 3;",
                    "const CHOICE_USAGE_INDENTATION = 2;",
                    "",
                    "function indent(str, spaces) {",
                    "  return str.replaceAll(/^/gm, \" \".repeat(spaces));",
                    "}",
                    "",
                    "function createDefaultValueDisplay(value) {",
                    "  return Array.isArray(value)",
                    "    ? `[${value.map(createDefaultValueDisplay).join(\", \")}]`",
                    "    : value;",
                    "}",
                    "",
                    "function getOptionDefaultValue(context, optionName) {",
                    "  // --no-option",
                    "  const option = context.detailedOptions.find(",
                    "    ({ name }) => name === optionName",
                    "  );",
                    "",
                    "  if (option?.default !== undefined) {",
                    "    return option.default;",
                    "  }",
                    "",
                    "  const optionCamelName = camelCase(optionName);",
                    "  return (",
                    "    formatOptionsHiddenDefaults[optionCamelName] ??",
                    "    context.supportOptions.find(",
                    "      (option) => !option.deprecated && option.name === optionCamelName",
                    "    )?.default",
                    "  );",
                    "}",
                    "",
                    "function createOptionUsageHeader(option) {",
                    "  const name = `--${option.name}`;",
                    "  const alias = option.alias ? `-${option.alias},` : null;",
                    "  const type = createOptionUsageType(option);",
                    "  return [alias, name, type].filter(Boolean).join(\" \");",
                    "}",
                    "",
                    "function createOptionUsageRow(header, content, threshold) {",
                    "  const separator =",
                    "    header.length >= threshold",
                    "      ? `\\n${\" \".repeat(threshold)}`",
                    "      : \" \".repeat(threshold - header.length);",
                    "",
                    "  const description = content.replaceAll(\"\\n\", `\\n${\" \".repeat(threshold)}`);",
                    "",
                    "  return `${header}${separator}${description}`;",
                    "}",
                    "",
                    "function createOptionUsageType(option) {",
                    "  switch (option.type) {",
                    "    case \"boolean\":",
                    "      return null;",
                    "    case \"choice\":",
                    "      return `<${option.choices",
                    "        .filter((choice) => !choice.deprecated)",
                    "        .map((choice) => choice.value)",
                    "        .join(\"|\")}>`;",
                    "    default:",
                    "      return `<${option.type}>`;",
                    "  }",
                    "}",
                    "",
                    "function createChoiceUsages(choices, margin, indentation) {",
                    "  const activeChoices = choices.filter((choice) => !choice.deprecated);",
                    "  const threshold =",
                    "    Math.max(0, ...activeChoices.map((choice) => choice.value.length)) + margin;",
                    "  return activeChoices.map((choice) =>",
                    "    indent(",
                    "      createOptionUsageRow(choice.value, choice.description, threshold),",
                    "      indentation",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function createOptionUsage(context, option, threshold) {",
                    "  const header = createOptionUsageHeader(option);",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  return createOptionUsageRow(",
                    "    header,",
                    "    `${option.description}${",
                    "      optionDefaultValue === undefined",
                    "        ? \"\"",
                    "        : `\\nDefaults to ${createDefaultValueDisplay(optionDefaultValue)}.`",
                    "    }`,",
                    "    threshold",
                    "  );",
                    "}",
                    "",
                    "function getOptionsWithOpposites(options) {",
                    "  // Add --no-foo after --foo.",
                    "  const optionsWithOpposites = options.map((option) => [",
                    "    option.description ? option : null,",
                    "    option.oppositeDescription",
                    "      ? {",
                    "          ...option,",
                    "          name: `no-${option.name}`,",
                    "          type: \"boolean\",",
                    "          description: option.oppositeDescription,",
                    "        }",
                    "      : null,",
                    "  ]);",
                    "  return optionsWithOpposites.flat().filter(Boolean);",
                    "}",
                    "",
                    "function createUsage(context) {",
                    "  const sortedOptions = context.detailedOptions.sort((optionA, optionB) =>",
                    "    optionA.name.localeCompare(optionB.name)",
                    "  );",
                    "",
                    "  const options = getOptionsWithOpposites(sortedOptions).filter(",
                    "    // remove unnecessary option (e.g. `semi`, `color`, etc.), which is only used for --help <flag>",
                    "    (option) =>",
                    "      !(",
                    "        option.type === \"boolean\" &&",
                    "        option.oppositeDescription &&",
                    "        !option.name.startsWith(\"no-\")",
                    "      )",
                    "  );",
                    "  const groupedOptions = groupBy(options, (option) => option.category);",
                    "",
                    "  const firstCategories = categoryOrder.slice(0, -1);",
                    "  const lastCategories = categoryOrder.slice(-1);",
                    "  const restCategories = Object.keys(groupedOptions).filter(",
                    "    (category) => !categoryOrder.includes(category)",
                    "  );",
                    "  const allCategories = [",
                    "    ...firstCategories,",
                    "    ...restCategories,",
                    "    ...lastCategories,",
                    "  ];",
                    "",
                    "  const optionsUsage = allCategories.map((category) => {",
                    "    const categoryOptions = groupedOptions[category]",
                    "      .map((option) =>",
                    "        createOptionUsage(context, option, OPTION_USAGE_THRESHOLD)",
                    "      )",
                    "      .join(\"\\n\");",
                    "    return `${category} options:\\n\\n${indent(categoryOptions, 2)}`;",
                    "  });",
                    "",
                    "  return [usageSummary, ...optionsUsage, \"\"].join(\"\\n\\n\");",
                    "}",
                    "",
                    "function createPluginDefaults(pluginDefaults) {",
                    "  if (!pluginDefaults || Object.keys(pluginDefaults).length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const defaults = Object.entries(pluginDefaults)",
                    "    .sort(([pluginNameA], [pluginNameB]) =>",
                    "      pluginNameA.localeCompare(pluginNameB)",
                    "    )",
                    "    .map(",
                    "      ([plugin, value]) => `* ${plugin}: ${createDefaultValueDisplay(value)}`",
                    "    )",
                    "    .join(\"\\n\");",
                    "",
                    "  return `\\nPlugin defaults:\\n${defaults}`;",
                    "}",
                    "",
                    "function createDetailedUsage(context, flag) {",
                    "  const option = getOptionsWithOpposites(context.detailedOptions).find(",
                    "    (option) => option.name === flag || option.alias === flag",
                    "  );",
                    "",
                    "  const header = createOptionUsageHeader(option);",
                    "  const description = `\\n\\n${indent(option.description, 2)}`;",
                    "",
                    "  const choices =",
                    "    option.type !== \"choice\"",
                    "      ? \"\"",
                    "      : `\\n\\nValid options:\\n\\n${createChoiceUsages(",
                    "          option.choices,",
                    "          CHOICE_USAGE_MARGIN,",
                    "          CHOICE_USAGE_INDENTATION",
                    "        ).join(\"\\n\")}`;",
                    "",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  const defaults =",
                    "    optionDefaultValue !== undefined",
                    "      ? `\\n\\nDefault: ${createDefaultValueDisplay(optionDefaultValue)}`",
                    "      : \"\";",
                    "",
                    "  const pluginDefaults = createPluginDefaults(option.pluginDefaults);",
                    "  return `${header}${description}${choices}${defaults}${pluginDefaults}`;",
                    "}",
                    "",
                    "export { createUsage, createDetailedUsage };"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "import path from \"node:path\";",
                    "import sdbm from \"sdbm\";",
                    "// @ts-expect-error",
                    "import { __internal as sharedWithCli } from \"../index.js\";",
                    "",
                    "// eslint-disable-next-line no-console",
                    "const printToScreen = console.log.bind(console);",
                    "",
                    "/**",
                    " * @template Obj",
                    " * @template Key",
                    " * @param {Array<Obj>} array",
                    " * @param {(value: Obj) => Key} iteratee",
                    " * @returns {{[p in Key]: T}}",
                    " */",
                    "function groupBy(array, iteratee) {",
                    "  const result = Object.create(null);",
                    "",
                    "  for (const value of array) {",
                    "    const key = iteratee(value);",
                    "",
                    "    if (Array.isArray(result[key])) {",
                    "      result[key].push(value);",
                    "    } else {",
                    "      result[key] = [value];",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "/**",
                    " * @template Obj",
                    " * @template {keyof Obj} Keys",
                    " * @param {Obj} object",
                    " * @param {Array<Keys>} keys",
                    " * @returns {{[key in Keys]: Obj[key]}}",
                    " */",
                    "function pick(object, keys) {",
                    "  const entries = keys.map((key) => [key, object[key]]);",
                    "  return Object.fromEntries(entries);",
                    "}",
                    "",
                    "/**",
                    " * @param {string} source",
                    " * @returns {string}",
                    " */",
                    "function createHash(source) {",
                    "  return String(sdbm(source));",
                    "}",
                    "",
                    "/**",
                    " * Get stats of a given path.",
                    " * @param {string} filePath The path to target file.",
                    " * @returns {Promise<import('fs').Stats | undefined>} The stats.",
                    " */",
                    "async function statSafe(filePath) {",
                    "  try {",
                    "    return await fs.stat(filePath);",
                    "  } catch (error) {",
                    "    /* c8 ignore next 3 */",
                    "    if (error.code !== \"ENOENT\") {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @returns {boolean}",
                    " */",
                    "function isJson(value) {",
                    "  try {",
                    "    JSON.parse(value);",
                    "    return true;",
                    "  } catch {",
                    "    return false;",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * Replace `\\` with `/` on Windows",
                    " * @param {string} filepath",
                    " * @returns {string}",
                    " */",
                    "const normalizeToPosix =",
                    "  path.sep === \"\\\\\"",
                    "    ? (filepath) => filepath.replaceAll(\"\\\\\", \"/\")",
                    "    : (filepath) => filepath;",
                    "",
                    "export const { isNonEmptyArray, partition, omit } = sharedWithCli.utils;",
                    "export {",
                    "  printToScreen,",
                    "  groupBy,",
                    "  pick,",
                    "  createHash,",
                    "  statSafe,",
                    "  isJson,",
                    "  normalizeToPosix,",
                    "};"
                ]
            },
            "options": {
                "create-minimist-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "export default function createMinimistOptions(detailedOptions) {",
                        "  const booleanNames = [];",
                        "  const stringNames = [];",
                        "  const defaultValues = {};",
                        "",
                        "  for (const option of detailedOptions) {",
                        "    const { name, alias, type } = option;",
                        "    const names = type === \"boolean\" ? booleanNames : stringNames;",
                        "    names.push(name);",
                        "    if (alias) {",
                        "      names.push(alias);",
                        "    }",
                        "",
                        "    if (",
                        "      !option.deprecated &&",
                        "      (!option.forwardToApi ||",
                        "        name === \"plugin\" ||",
                        "        name === \"plugin-search-dir\") &&",
                        "      option.default !== undefined",
                        "    ) {",
                        "      defaultValues[option.name] = option.default;",
                        "    }",
                        "  }",
                        "",
                        "  return {",
                        "    // we use vnopts' AliasSchema to handle aliases for better error messages",
                        "    alias: {},",
                        "    boolean: booleanNames,",
                        "    string: stringNames,",
                        "    default: defaultValues,",
                        "  };",
                        "}"
                    ]
                },
                "get-context-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import dashify from \"dashify\";",
                        "import { getSupportInfo } from \"../../index.js\";",
                        "import {",
                        "  optionCategories,",
                        "  getSupportInfoWithoutPlugins,",
                        "  normalizeOptionSettings,",
                        "} from \"../prettier-internal.js\";",
                        "import cliOptions from \"../cli-options.evaluate.js\";",
                        "",
                        "const detailedCliOptions = normalizeOptionSettings(cliOptions).map((option) =>",
                        "  normalizeDetailedOption(option)",
                        ");",
                        "",
                        "function apiOptionToCliOption(apiOption) {",
                        "  const cliOption = {",
                        "    ...apiOption,",
                        "    description: apiOption.cliDescription ?? apiOption.description,",
                        "    category: apiOption.cliCategory ?? optionCategories.CATEGORY_FORMAT,",
                        "    forwardToApi: apiOption.name,",
                        "  };",
                        "",
                        "  /* c8 ignore start */",
                        "  if (apiOption.deprecated) {",
                        "    delete cliOption.forwardToApi;",
                        "    delete cliOption.description;",
                        "    delete cliOption.oppositeDescription;",
                        "    cliOption.deprecated = true;",
                        "  }",
                        "  /* c8 ignore stop */",
                        "",
                        "  return normalizeDetailedOption(cliOption);",
                        "}",
                        "",
                        "function normalizeDetailedOption(option) {",
                        "  return {",
                        "    category: optionCategories.CATEGORY_OTHER,",
                        "    ...option,",
                        "    name: option.cliName ?? dashify(option.name),",
                        "    choices: option.choices?.map((choice) => {",
                        "      const newChoice = {",
                        "        description: \"\",",
                        "        deprecated: false,",
                        "        ...(typeof choice === \"object\" ? choice : { value: choice }),",
                        "      };",
                        "      /* c8 ignore next 3 */",
                        "      if (newChoice.value === true) {",
                        "        newChoice.value = \"\"; // backward compatibility for original boolean option",
                        "      }",
                        "      return newChoice;",
                        "    }),",
                        "  };",
                        "}",
                        "",
                        "function supportInfoToContextOptions({ options: supportOptions, languages }) {",
                        "  const detailedOptions = [",
                        "    ...detailedCliOptions,",
                        "    ...supportOptions.map((apiOption) => apiOptionToCliOption(apiOption)),",
                        "  ];",
                        "",
                        "  return {",
                        "    supportOptions,",
                        "    languages,",
                        "    detailedOptions,",
                        "  };",
                        "}",
                        "",
                        "async function getContextOptions(plugins, pluginSearchDirs) {",
                        "  const supportInfo = await getSupportInfo({",
                        "    showDeprecated: true,",
                        "    plugins,",
                        "    pluginSearchDirs,",
                        "  });",
                        "",
                        "  return supportInfoToContextOptions(supportInfo);",
                        "}",
                        "",
                        "function getContextOptionsWithoutPlugins() {",
                        "  const supportInfo = getSupportInfoWithoutPlugins();",
                        "  return supportInfoToContextOptions(supportInfo);",
                        "}",
                        "",
                        "export { getContextOptions, getContextOptionsWithoutPlugins };"
                    ]
                },
                "get-options-for-file.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import dashify from \"dashify\";",
                        "import { resolveConfig } from \"../../index.js\";",
                        "import { normalizeOptions as normalizeApiOptions } from \"../prettier-internal.js\";",
                        "import minimist from \"./minimist.js\";",
                        "import createMinimistOptions from \"./create-minimist-options.js\";",
                        "import normalizeCliOptions from \"./normalize-cli-options.js\";",
                        "",
                        "function getOptions(argv, detailedOptions) {",
                        "  return Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(({ forwardToApi }) => forwardToApi)",
                        "      .map(({ forwardToApi, name }) => [forwardToApi, argv[name]])",
                        "  );",
                        "}",
                        "",
                        "function cliifyOptions(object, apiDetailedOptionMap) {",
                        "  return Object.fromEntries(",
                        "    Object.entries(object || {}).map(([key, value]) => {",
                        "      const apiOption = apiDetailedOptionMap[key];",
                        "      const cliKey = apiOption ? apiOption.name : key;",
                        "",
                        "      return [dashify(cliKey), value];",
                        "    })",
                        "  );",
                        "}",
                        "",
                        "function createApiDetailedOptionMap(detailedOptions) {",
                        "  return Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(",
                        "        (option) => option.forwardToApi && option.forwardToApi !== option.name",
                        "      )",
                        "      .map((option) => [option.forwardToApi, option])",
                        "  );",
                        "}",
                        "",
                        "function parseArgsToOptions(context, overrideDefaults) {",
                        "  const minimistOptions = createMinimistOptions(context.detailedOptions);",
                        "  const apiDetailedOptionMap = createApiDetailedOptionMap(",
                        "    context.detailedOptions",
                        "  );",
                        "  return getOptions(",
                        "    normalizeCliOptions(",
                        "      minimist(context.rawArguments, {",
                        "        string: minimistOptions.string,",
                        "        boolean: minimistOptions.boolean,",
                        "        default: cliifyOptions(overrideDefaults, apiDetailedOptionMap),",
                        "      }),",
                        "      context.detailedOptions,",
                        "      { logger: false }",
                        "    ),",
                        "    context.detailedOptions",
                        "  );",
                        "}",
                        "",
                        "async function getOptionsOrDie(context, filePath) {",
                        "  try {",
                        "    if (context.argv.config === false) {",
                        "      context.logger.debug(",
                        "        \"'--no-config' option found, skip loading config file.\"",
                        "      );",
                        "      return null;",
                        "    }",
                        "",
                        "    context.logger.debug(",
                        "      context.argv.config",
                        "        ? `load config file from '${context.argv.config}'`",
                        "        : `resolve config from '${filePath}'`",
                        "    );",
                        "",
                        "    const options = await resolveConfig(filePath, {",
                        "      editorconfig: context.argv.editorconfig,",
                        "      config: context.argv.config,",
                        "    });",
                        "",
                        "    context.logger.debug(\"loaded options `\" + JSON.stringify(options) + \"`\");",
                        "    return options;",
                        "  } catch (error) {",
                        "    context.logger.error(",
                        "      `Invalid configuration for file \"${filePath}\":\\n` + error.message",
                        "    );",
                        "    process.exit(2);",
                        "  }",
                        "}",
                        "",
                        "function applyConfigPrecedence(context, options) {",
                        "  try {",
                        "    switch (context.argv.configPrecedence) {",
                        "      case \"cli-override\":",
                        "        return parseArgsToOptions(context, options);",
                        "      case \"file-override\":",
                        "        return { ...parseArgsToOptions(context), ...options };",
                        "      case \"prefer-file\":",
                        "        return options || parseArgsToOptions(context);",
                        "    }",
                        "  } catch (error) {",
                        "    /* c8 ignore start */",
                        "    context.logger.error(error.toString());",
                        "    process.exit(2);",
                        "    /* c8 ignore stop */",
                        "  }",
                        "}",
                        "",
                        "async function getOptionsForFile(context, filepath) {",
                        "  const options = await getOptionsOrDie(context, filepath);",
                        "",
                        "  const hasPlugins = options?.plugins;",
                        "  if (hasPlugins) {",
                        "    await context.pushContextPlugins(options.plugins);",
                        "  }",
                        "",
                        "  const appliedOptions = {",
                        "    filepath,",
                        "    ...applyConfigPrecedence(",
                        "      context,",
                        "      options &&",
                        "        normalizeApiOptions(options, context.supportOptions, {",
                        "          logger: context.logger,",
                        "        })",
                        "    ),",
                        "  };",
                        "",
                        "  context.logger.debug(",
                        "    `applied config-precedence (${context.argv.configPrecedence}): ` +",
                        "      `${JSON.stringify(appliedOptions)}`",
                        "  );",
                        "",
                        "  if (hasPlugins) {",
                        "    context.popContextPlugins();",
                        "  }",
                        "",
                        "  return appliedOptions;",
                        "}",
                        "",
                        "export default getOptionsForFile;"
                    ]
                },
                "minimist.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import minimist from \"minimist\";",
                        "",
                        "const PLACEHOLDER = null;",
                        "",
                        "/**",
                        " * unspecified boolean flag without default value is parsed as `undefined` instead of `false`",
                        " */",
                        "export default function minimistParse(args, options) {",
                        "  /* c8 ignore next */",
                        "  const boolean = options.boolean ?? [];",
                        "  /* c8 ignore next */",
                        "  const defaults = options.default ?? {};",
                        "",
                        "  const booleanWithoutDefault = boolean.filter((key) => !(key in defaults));",
                        "  const newDefaults = {",
                        "    ...defaults,",
                        "    ...Object.fromEntries(",
                        "      booleanWithoutDefault.map((key) => [key, PLACEHOLDER])",
                        "    ),",
                        "  };",
                        "",
                        "  const parsed = minimist(args, { ...options, default: newDefaults });",
                        "",
                        "  return Object.fromEntries(",
                        "    Object.entries(parsed).filter(([, value]) => value !== PLACEHOLDER)",
                        "  );",
                        "}"
                    ]
                },
                "normalize-cli-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import chalk from \"chalk\";",
                        "import leven from \"leven\";",
                        "import { normalizeOptions, vnopts } from \"../prettier-internal.js\";",
                        "",
                        "const descriptor = {",
                        "  key: (key) => (key.length === 1 ? `-${key}` : `--${key}`),",
                        "  value: (value) => vnopts.apiDescriptor.value(value),",
                        "  pair: ({ key, value }) =>",
                        "    value === false",
                        "      ? `--no-${key}`",
                        "      : value === true",
                        "      ? descriptor.key(key)",
                        "      : value === \"\"",
                        "      ? `${descriptor.key(key)} without an argument`",
                        "      : `${descriptor.key(key)}=${value}`,",
                        "};",
                        "",
                        "class FlagSchema extends vnopts.ChoiceSchema {",
                        "  #flags = [];",
                        "",
                        "  constructor({ name, flags }) {",
                        "    super({ name, choices: flags });",
                        "    this.#flags = [...flags].sort();",
                        "  }",
                        "  preprocess(value, utils) {",
                        "    if (",
                        "      typeof value === \"string\" &&",
                        "      value.length > 0 &&",
                        "      !this.#flags.includes(value)",
                        "    ) {",
                        "      const suggestion = this.#flags.find((flag) => leven(flag, value) < 3);",
                        "      if (suggestion) {",
                        "        utils.logger.warn(",
                        "          [",
                        "            `Unknown flag ${chalk.yellow(utils.descriptor.value(value))},`,",
                        "            `did you mean ${chalk.blue(utils.descriptor.value(suggestion))}?`,",
                        "          ].join(\" \")",
                        "        );",
                        "        return suggestion;",
                        "      }",
                        "    }",
                        "    return value;",
                        "  }",
                        "  expected() {",
                        "    return \"a flag\";",
                        "  }",
                        "}",
                        "",
                        "function normalizeCliOptions(options, optionInfos, opts) {",
                        "  return normalizeOptions(options, optionInfos, {",
                        "    ...opts,",
                        "    isCLI: true,",
                        "    FlagSchema,",
                        "    descriptor,",
                        "  });",
                        "}",
                        "",
                        "export default normalizeCliOptions;"
                    ]
                },
                "parse-cli-arguments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import camelCase from \"camelcase\";",
                        "import { pick } from \"../utils.js\";",
                        "import { getContextOptionsWithoutPlugins } from \"./get-context-options.js\";",
                        "import minimist from \"./minimist.js\";",
                        "import createMinimistOptions from \"./create-minimist-options.js\";",
                        "import normalizeCliOptions from \"./normalize-cli-options.js\";",
                        "",
                        "function parseArgv(rawArguments, detailedOptions, logger, keys) {",
                        "  const minimistOptions = createMinimistOptions(detailedOptions);",
                        "  let argv = minimist(rawArguments, minimistOptions);",
                        "",
                        "  if (keys) {",
                        "    if (keys.includes(\"plugin-search-dir\") && !keys.includes(\"plugin-search\")) {",
                        "      keys.push(\"plugin-search\");",
                        "    }",
                        "",
                        "    detailedOptions = detailedOptions.filter((option) =>",
                        "      keys.includes(option.name)",
                        "    );",
                        "    argv = pick(argv, keys);",
                        "  }",
                        "",
                        "  const normalized = normalizeCliOptions(argv, detailedOptions, { logger });",
                        "",
                        "  return {",
                        "    ...Object.fromEntries(",
                        "      Object.entries(normalized).map(([key, value]) => {",
                        "        const option = detailedOptions.find(({ name }) => name === key) || {};",
                        "        // If the flag is a prettier option, use the option name",
                        "        // `--plugin-search-dir` -> `pluginSearchDirs`",
                        "        // Otherwise use camel case for readability",
                        "        // `--ignore-unknown` -> `ignoreUnknown`",
                        "        return [option.forwardToApi || camelCase(key), value];",
                        "      })",
                        "    ),",
                        "    _: normalized._?.map(String),",
                        "    get __raw() {",
                        "      return argv;",
                        "    },",
                        "  };",
                        "}",
                        "",
                        "const { detailedOptions: detailedOptionsWithoutPlugins } =",
                        "  getContextOptionsWithoutPlugins();",
                        "function parseArgvWithoutPlugins(rawArguments, logger, keys) {",
                        "  return parseArgv(",
                        "    rawArguments,",
                        "    detailedOptionsWithoutPlugins,",
                        "    logger,",
                        "    typeof keys === \"string\" ? [keys] : keys",
                        "  );",
                        "}",
                        "",
                        "export { parseArgv, parseArgvWithoutPlugins };"
                    ]
                }
            }
        },
        "common": {
            "ast-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "class AstPath {",
                    "  constructor(value) {",
                    "    this.stack = [value];",
                    "  }",
                    "",
                    "  /** @type {string | null} */",
                    "  get key() {",
                    "    const { stack, siblings } = this;",
                    "    return stack.at(siblings === null ? -2 : -4) ?? null;",
                    "  }",
                    "",
                    "  /** @type {number | null} */",
                    "  get index() {",
                    "    return this.siblings === null ? null : this.stack.at(-2);",
                    "  }",
                    "",
                    "  /** @type {object} */",
                    "  get node() {",
                    "    return this.stack.at(-1);",
                    "  }",
                    "",
                    "  /** @type {object | null} */",
                    "  get parent() {",
                    "    return this.getNode(1);",
                    "  }",
                    "",
                    "  /** @type {object | null} */",
                    "  get grandparent() {",
                    "    return this.getNode(2);",
                    "  }",
                    "",
                    "  /** @type {boolean} */",
                    "  get isInArray() {",
                    "    return this.siblings !== null;",
                    "  }",
                    "",
                    "  /** @type {object[] | null} */",
                    "  get siblings() {",
                    "    const { stack } = this;",
                    "    const maybeArray = stack.at(-3);",
                    "    return Array.isArray(maybeArray) ? maybeArray : null;",
                    "  }",
                    "",
                    "  /** @type {object | null} */",
                    "  get next() {",
                    "    const { siblings } = this;",
                    "    return siblings === null ? null : siblings[this.index + 1];",
                    "  }",
                    "",
                    "  /** @type {object | null} */",
                    "  get previous() {",
                    "    const { siblings } = this;",
                    "    return siblings === null ? null : siblings[this.index - 1];",
                    "  }",
                    "",
                    "  /** @type {boolean} */",
                    "  get isFirst() {",
                    "    return this.index === 0;",
                    "  }",
                    "",
                    "  /** @type {boolean} */",
                    "  get isLast() {",
                    "    const { siblings, index } = this;",
                    "    return siblings !== null && index === siblings.length - 1;",
                    "  }",
                    "",
                    "  /** @type {boolean} */",
                    "  get isRoot() {",
                    "    return this.stack.length === 1;",
                    "  }",
                    "",
                    "  /** @type {object} */",
                    "  get root() {",
                    "    return this.stack[0];",
                    "  }",
                    "",
                    "  /** @type {object[]} */",
                    "  get ancestors() {",
                    "    return [...this.#getAncestors()];",
                    "  }",
                    "",
                    "  // The name of the current property is always the penultimate element of",
                    "  // this.stack, and always a string/number/symbol.",
                    "  getName() {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    if (length > 1) {",
                    "      return stack.at(-2);",
                    "    }",
                    "    // Since the name is a string/number/symbol, null is a safe sentinel value",
                    "    // to return if we do not know the name of the (root) value.",
                    "    /* c8 ignore next */",
                    "    return null;",
                    "  }",
                    "",
                    "  // The value of the current property is always the final element of",
                    "  // this.stack.",
                    "  getValue() {",
                    "    return this.stack.at(-1);",
                    "  }",
                    "",
                    "  getNode(count = 0) {",
                    "    const stackIndex = this.#getNodeStackIndex(count);",
                    "    return stackIndex === -1 ? null : this.stack[stackIndex];",
                    "  }",
                    "",
                    "  getParentNode(count = 0) {",
                    "    return this.getNode(count + 1);",
                    "  }",
                    "",
                    "  #getNodeStackIndex(count) {",
                    "    const { stack } = this;",
                    "    for (let i = stack.length - 1; i >= 0; i -= 2) {",
                    "      if (!Array.isArray(stack[i]) && --count < 0) {",
                    "        return i;",
                    "      }",
                    "    }",
                    "    return -1;",
                    "  }",
                    "",
                    "  // Temporarily push properties named by string arguments given after the",
                    "  // callback function onto this.stack, then call the callback with a",
                    "  // reference to this (modified) AstPath object. Note that the stack will",
                    "  // be restored to its original state after the callback is finished, so it",
                    "  // is probably a mistake to retain a reference to the path.",
                    "  call(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = stack.at(-1);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "    try {",
                    "      return callback(this);",
                    "    } finally {",
                    "      stack.length = length;",
                    "    }",
                    "  }",
                    "",
                    "  callParent(callback, count = 0) {",
                    "    const stackIndex = this.#getNodeStackIndex(count + 1);",
                    "    const parentValues = this.stack.splice(stackIndex + 1);",
                    "    try {",
                    "      return callback(this);",
                    "    } finally {",
                    "      this.stack.push(...parentValues);",
                    "    }",
                    "  }",
                    "",
                    "  // Similar to AstPath.prototype.call, except that the value obtained by",
                    "  // accessing this.getValue()[name1][name2]... should be array. The",
                    "  // callback will be called with a reference to this path object for each",
                    "  // element of the array.",
                    "  each(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = stack.at(-1);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "",
                    "    try {",
                    "      for (let i = 0; i < value.length; ++i) {",
                    "        stack.push(i, value[i]);",
                    "        callback(this, i, value);",
                    "        stack.length -= 2;",
                    "      }",
                    "    } finally {",
                    "      stack.length = length;",
                    "    }",
                    "  }",
                    "",
                    "  // Similar to AstPath.prototype.each, except that the results of the",
                    "  // callback function invocations are stored in an array and returned at",
                    "  // the end of the iteration.",
                    "  map(callback, ...names) {",
                    "    const result = [];",
                    "    this.each((path, index, value) => {",
                    "      result[index] = callback(path, index, value);",
                    "    }, ...names);",
                    "    return result;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {...(",
                    "   *   | ((node: any, name: string | null, number: number | null) => boolean)",
                    "   *   | undefined",
                    "   * )} predicates",
                    "   */",
                    "  match(...predicates) {",
                    "    let stackPointer = this.stack.length - 1;",
                    "",
                    "    let name = null;",
                    "    let node = this.stack[stackPointer--];",
                    "",
                    "    for (const predicate of predicates) {",
                    "      /* c8 ignore next 3 */",
                    "      if (node === undefined) {",
                    "        return false;",
                    "      }",
                    "",
                    "      // skip index/array",
                    "      let number = null;",
                    "      if (typeof name === \"number\") {",
                    "        number = name;",
                    "        name = this.stack[stackPointer--];",
                    "        node = this.stack[stackPointer--];",
                    "      }",
                    "",
                    "      if (predicate && !predicate(node, name, number)) {",
                    "        return false;",
                    "      }",
                    "",
                    "      name = this.stack[stackPointer--];",
                    "      node = this.stack[stackPointer--];",
                    "    }",
                    "",
                    "    return true;",
                    "  }",
                    "",
                    "  /**",
                    "   * Traverses the ancestors of the current node heading toward the tree root",
                    "   * until it finds a node that matches the provided predicate function. Will",
                    "   * return the first matching ancestor. If no such node exists, returns undefined.",
                    "   * @param {(node: any) => boolean} predicate",
                    "   * @internal Unstable API. Don't use in plugins for now.",
                    "   */",
                    "  findAncestor(predicate) {",
                    "    for (const node of this.#getAncestors()) {",
                    "      if (predicate(node)) {",
                    "        return node;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  /**",
                    "   * Traverses the ancestors of the current node heading toward the tree root",
                    "   * until it finds a node that matches the provided predicate function.",
                    "   * returns true if matched node found.",
                    "   * @param {(node: any) => boolean} predicate",
                    "   * @returns {boolean}",
                    "   * @internal Unstable API. Don't use in plugins for now.",
                    "   */",
                    "  hasAncestor(predicate) {",
                    "    for (const node of this.#getAncestors()) {",
                    "      if (predicate(node)) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "",
                    "    return false;",
                    "  }",
                    "",
                    "  *#getAncestors() {",
                    "    const { stack } = this;",
                    "",
                    "    for (let index = stack.length - 3; index >= 0; index -= 2) {",
                    "      const value = stack[index];",
                    "      if (!Array.isArray(value)) {",
                    "        yield value;",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "export default AstPath;"
                ]
            },
            "common-options.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const CATEGORY_COMMON = \"Common\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  bracketSpacing: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print spaces between brackets.\",",
                    "    oppositeDescription: \"Do not print spaces between brackets.\",",
                    "  },",
                    "  singleQuote: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes instead of double quotes.\",",
                    "  },",
                    "  proseWrap: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"choice\",",
                    "    default: \"preserve\",",
                    "    description: \"How to wrap prose.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"always\",",
                    "        description: \"Wrap prose if it exceeds the print width.\",",
                    "      },",
                    "      {",
                    "        value: \"never\",",
                    "        description: \"Do not wrap prose.\",",
                    "      },",
                    "      {",
                    "        value: \"preserve\",",
                    "        description: \"Wrap prose as-is.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  bracketSameLine: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description:",
                    "      \"Put > of opening tags on the last line instead of on a new line.\",",
                    "  },",
                    "  singleAttributePerLine: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Enforce single attribute per line in HTML, Vue and JSX.\",",
                    "  },",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "end-of-line.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function guessEndOfLine(text) {",
                    "  const index = text.indexOf(\"\\r\");",
                    "  if (index >= 0) {",
                    "    return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";",
                    "  }",
                    "  return \"lf\";",
                    "}",
                    "",
                    "function convertEndOfLineToChars(value) {",
                    "  switch (value) {",
                    "    case \"cr\":",
                    "      return \"\\r\";",
                    "    case \"crlf\":",
                    "      return \"\\r\\n\";",
                    "    default:",
                    "      return \"\\n\";",
                    "  }",
                    "}",
                    "",
                    "function countEndOfLineChars(text, eol) {",
                    "  let regex;",
                    "",
                    "  switch (eol) {",
                    "    case \"\\n\":",
                    "      regex = /\\n/g;",
                    "      break;",
                    "    case \"\\r\":",
                    "      regex = /\\r/g;",
                    "      break;",
                    "    case \"\\r\\n\":",
                    "      regex = /\\r\\n/g;",
                    "      break;",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);",
                    "  }",
                    "",
                    "  const endOfLines = text.match(regex);",
                    "  return endOfLines ? endOfLines.length : 0;",
                    "}",
                    "",
                    "function normalizeEndOfLine(text) {",
                    "  return text.replaceAll(/\\r\\n?/g, \"\\n\");",
                    "}",
                    "",
                    "export {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "  countEndOfLineChars,",
                    "  normalizeEndOfLine,",
                    "};"
                ]
            },
            "errors.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "class ConfigError extends Error {}",
                    "class UndefinedParserError extends Error {}",
                    "class ArgExpansionBailout extends Error {}",
                    "",
                    "export { ConfigError, UndefinedParserError, ArgExpansionBailout };"
                ]
            },
            "get-file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import inferParser from \"../utils/infer-parser.js\";",
                    "import { resolveConfig } from \"../config/resolve-config.js\";",
                    "import { isIgnored } from \"../utils/ignore.js\";",
                    "",
                    "/**",
                    " * @typedef {{ ignorePath?: string, withNodeModules?: boolean, plugins: object, resolveConfig?: boolean }} FileInfoOptions",
                    " * @typedef {{ ignored: boolean, inferredParser: string | null }} FileInfoResult",
                    " */",
                    "",
                    "/**",
                    " * @param {string} filePath",
                    " * @param {FileInfoOptions} options",
                    " * @returns {Promise<FileInfoResult>}",
                    " *",
                    " * Please note that prettier.getFileInfo() expects options.plugins to be an array of paths,",
                    " * not an object. A transformation from this array to an object is automatically done",
                    " * internally by the method wrapper. See withPlugins() in index.js.",
                    " */",
                    "async function getFileInfo(filePath, options) {",
                    "  if (typeof filePath !== \"string\") {",
                    "    throw new TypeError(",
                    "      `expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``",
                    "    );",
                    "  }",
                    "",
                    "  let { ignorePath, withNodeModules } = options;",
                    "  // In API we allow single `ignorePath`",
                    "  if (!Array.isArray(ignorePath)) {",
                    "    ignorePath = [ignorePath];",
                    "  }",
                    "",
                    "  const ignored = await isIgnored(filePath, { ignorePath, withNodeModules });",
                    "",
                    "  let inferredParser;",
                    "  if (!ignored) {",
                    "    inferredParser = await getParser(filePath, options);",
                    "  }",
                    "",
                    "  return {",
                    "    ignored,",
                    "    inferredParser: inferredParser ?? null,",
                    "  };",
                    "}",
                    "",
                    "async function getParser(filePath, options) {",
                    "  let config;",
                    "  if (options.resolveConfig !== false) {",
                    "    config = await resolveConfig(filePath);",
                    "  }",
                    "",
                    "  return config?.parser ?? inferParser(options, { physicalFile: filePath });",
                    "}",
                    "",
                    "export default getFileInfo;"
                ]
            },
            "mockable.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "import { cosmiconfig } from \"cosmiconfig\";",
                    "import { sync as findParentDir } from \"find-parent-dir\";",
                    "import getStdin from \"get-stdin\";",
                    "import { isCI } from \"ci-info\";",
                    "",
                    "function writeFormattedFile(file, data) {",
                    "  return fs.writeFile(file, data);",
                    "}",
                    "",
                    "const mockable = {",
                    "  cosmiconfig,",
                    "  findParentDir,",
                    "  getStdin,",
                    "  isCI: () => isCI,",
                    "  writeFormattedFile,",
                    "};",
                    "",
                    "export default mockable;"
                ]
            },
            "parser-create-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function createError(message, options) {",
                    "  // TODO: Use `Error.prototype.cause` when we drop support for Node.js<18.7.0",
                    "",
                    "  // Construct an error similar to the ones thrown by Babel.",
                    "  const error = new SyntaxError(",
                    "    message +",
                    "      \" (\" +",
                    "      options.loc.start.line +",
                    "      \":\" +",
                    "      options.loc.start.column +",
                    "      \")\"",
                    "  );",
                    "",
                    "  return Object.assign(error, options);",
                    "}",
                    "",
                    "export default createError;"
                ]
            }
        },
        "config": {
            "find-project-root.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// Simple version of `find-project-root`",
                    "// https://github.com/kirstein/find-project-root/blob/master/index.js",
                    "",
                    "import fs from \"node:fs\";",
                    "import path from \"node:path\";",
                    "",
                    "const MARKERS = [\".git\", \".hg\"];",
                    "",
                    "const markerExists = (directory) =>",
                    "  MARKERS.some((mark) => fs.existsSync(path.join(directory, mark)));",
                    "",
                    "function findProjectRoot(directory) {",
                    "  while (!markerExists(directory)) {",
                    "    const parentDirectory = path.resolve(directory, \"..\");",
                    "    if (parentDirectory === directory) {",
                    "      break;",
                    "    }",
                    "    directory = parentDirectory;",
                    "  }",
                    "",
                    "  return directory;",
                    "}",
                    "",
                    "export default findProjectRoot;"
                ]
            },
            "get-prettier-config-explorer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { pathToFileURL } from \"node:url\";",
                    "import parseToml from \"@iarna/toml/parse-async.js\";",
                    "import parseJson5 from \"json5/lib/parse.js\";",
                    "import mockable from \"../common/mockable.js\";",
                    "import loadExternalConfig from \"./load-external-config.js\";",
                    "",
                    "const { cosmiconfig } = mockable;",
                    "",
                    "const searchPlaces = [",
                    "  \"package.json\",",
                    "  \".prettierrc\",",
                    "  \".prettierrc.json\",",
                    "  \".prettierrc.yaml\",",
                    "  \".prettierrc.yml\",",
                    "  \".prettierrc.json5\",",
                    "  \".prettierrc.js\",",
                    "  \".prettierrc.mjs\",",
                    "  \".prettierrc.cjs\",",
                    "  \"prettier.config.js\",",
                    "  \"prettier.config.mjs\",",
                    "  \"prettier.config.cjs\",",
                    "  \".prettierrc.toml\",",
                    "];",
                    "",
                    "async function loadJs(filepath /*, content*/) {",
                    "  const module = await import(pathToFileURL(filepath).href);",
                    "  return module.default;",
                    "}",
                    "",
                    "const loaders = {",
                    "  async \".toml\"(filePath, content) {",
                    "    try {",
                    "      return await parseToml(content);",
                    "    } catch (error) {",
                    "      error.message = `TOML Error in ${filePath}:\\n${error.message}`;",
                    "      throw error;",
                    "    }",
                    "  },",
                    "  \".json5\"(filePath, content) {",
                    "    try {",
                    "      return parseJson5(content);",
                    "    } catch (error) {",
                    "      error.message = `JSON5 Error in ${filePath}:\\n${error.message}`;",
                    "      throw error;",
                    "    }",
                    "  },",
                    "  \".js\": loadJs,",
                    "  \".mjs\": loadJs,",
                    "  \".cjs\": loadJs,",
                    "};",
                    "",
                    "async function transform(result) {",
                    "  if (!result?.config) {",
                    "    return result;",
                    "  }",
                    "",
                    "  let { config, filepath } = result;",
                    "",
                    "  /*",
                    "  We support external config",
                    "",
                    "  ```json",
                    "  {",
                    "    \"prettier\": \"my-prettier-config-package-or-file\"",
                    "  }",
                    "  ```",
                    "  */",
                    "  if (typeof config === \"string\") {",
                    "    config = await loadExternalConfig(config, filepath);",
                    "    result.config = config;",
                    "  }",
                    "",
                    "  if (typeof config !== \"object\") {",
                    "    throw new TypeError(",
                    "      \"Config is only allowed to be an object, \" +",
                    "        `but received ${typeof config} in \"${filepath}\"`",
                    "    );",
                    "  }",
                    "",
                    "  delete config.$schema;",
                    "  return result;",
                    "}",
                    "",
                    "/**",
                    " * @param {{cache: boolean }} options",
                    " * @return {ReturnType<import(\"cosmiconfig\").cosmiconfig>}",
                    " */",
                    "function getExplorer(options) {",
                    "  return cosmiconfig(\"prettier\", {",
                    "    cache: options.cache,",
                    "    transform,",
                    "    searchPlaces,",
                    "    loaders,",
                    "  });",
                    "}",
                    "",
                    "export default getExplorer;"
                ]
            },
            "load-external-config.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import requireFromFile from \"../utils/require-from-file.js\";",
                    "import importFromFile from \"../utils/import-from-file.js\";",
                    "",
                    "async function loadExternalConfig(config, filepath) {",
                    "  /*",
                    "  Try `require()` first, this is how it works in Prettier v2.",
                    "  Kept this because the external config path or package may can't load with `import()`:",
                    "  1. is JSON file or package",
                    "  2. is CommonJS file without extension",
                    "  3. is a dirname with index.js inside",
                    "  */",
                    "  try {",
                    "    return requireFromFile(config, filepath);",
                    "  } catch (error) {",
                    "    if (",
                    "      error?.code !== \"MODULE_NOT_FOUND\" &&",
                    "      error?.code !== \"ERR_REQUIRE_ESM\"",
                    "    ) {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "",
                    "  const module = await importFromFile(config, filepath);",
                    "  return module.default;",
                    "}",
                    "",
                    "export default loadExternalConfig;"
                ]
            },
            "resolve-config.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import micromatch from \"micromatch\";",
                    "import mem, { memClear } from \"mem\";",
                    "import partition from \"../utils/partition.js\";",
                    "import loadEditorConfigWithoutCache from \"./resolve-editorconfig.js\";",
                    "import getPrettierConfigExplorerWithoutCache from \"./get-prettier-config-explorer.js\";",
                    "",
                    "const getPrettierConfigExplorer = mem(getPrettierConfigExplorerWithoutCache, {",
                    "  cacheKey: ([options]) => options.cache,",
                    "});",
                    "const memoizedLoadEditorConfig = mem(loadEditorConfigWithoutCache);",
                    "function clearCache() {",
                    "  memClear(getPrettierConfigExplorer);",
                    "  memClear(memoizedLoadEditorConfig);",
                    "}",
                    "",
                    "function loadEditorConfig(filePath, options) {",
                    "  if (!filePath || !options.editorconfig) {",
                    "    return;",
                    "  }",
                    "",
                    "  return (",
                    "    options.useCache ? memoizedLoadEditorConfig : loadEditorConfigWithoutCache",
                    "  )(filePath);",
                    "}",
                    "",
                    "function loadPrettierConfig(filePath, options) {",
                    "  const { useCache, config: configPath } = options;",
                    "  const { load, search } = getPrettierConfigExplorer({",
                    "    cache: Boolean(useCache),",
                    "  });",
                    "  return configPath ? load(configPath) : search(filePath);",
                    "}",
                    "",
                    "async function resolveConfig(filePath, options) {",
                    "  options = { useCache: true, ...options };",
                    "",
                    "  const [result, editorConfigured] = await Promise.all([",
                    "    loadPrettierConfig(filePath, options),",
                    "    loadEditorConfig(filePath, options),",
                    "  ]);",
                    "",
                    "  if (!result && !editorConfigured) {",
                    "    return null;",
                    "  }",
                    "",
                    "  const merged = {",
                    "    ...editorConfigured,",
                    "    ...mergeOverrides(result, filePath),",
                    "  };",
                    "",
                    "  for (const optionName of [\"plugins\", \"pluginSearchDirs\"]) {",
                    "    if (Array.isArray(merged[optionName])) {",
                    "      merged[optionName] = merged[optionName].map((value) =>",
                    "        typeof value === \"string\" && value.startsWith(\".\") // relative path",
                    "          ? path.resolve(path.dirname(result.filepath), value)",
                    "          : value",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return merged;",
                    "}",
                    "",
                    "async function resolveConfigFile(filePath) {",
                    "  const { search } = getPrettierConfigExplorer({ cache: false });",
                    "  const result = await search(filePath);",
                    "  return result ? result.filepath : null;",
                    "}",
                    "",
                    "function mergeOverrides(configResult, filePath) {",
                    "  const { config, filepath: configPath } = configResult || {};",
                    "  const { overrides, ...options } = config || {};",
                    "  if (filePath && overrides) {",
                    "    const relativeFilePath = path.relative(path.dirname(configPath), filePath);",
                    "    for (const override of overrides) {",
                    "      if (",
                    "        pathMatchesGlobs(",
                    "          relativeFilePath,",
                    "          override.files,",
                    "          override.excludeFiles",
                    "        )",
                    "      ) {",
                    "        Object.assign(options, override.options);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  return options;",
                    "}",
                    "",
                    "// Based on eslint: https://github.com/eslint/eslint/blob/master/lib/config/config-ops.js",
                    "function pathMatchesGlobs(filePath, patterns, excludedPatterns) {",
                    "  const patternList = Array.isArray(patterns) ? patterns : [patterns];",
                    "  // micromatch always matches against basename when the option is enabled",
                    "  // use only patterns without slashes with it to match minimatch behavior",
                    "  const [withSlashes, withoutSlashes] = partition(patternList, (pattern) =>",
                    "    pattern.includes(\"/\")",
                    "  );",
                    "",
                    "  return (",
                    "    micromatch.isMatch(filePath, withoutSlashes, {",
                    "      ignore: excludedPatterns,",
                    "      basename: true,",
                    "      dot: true,",
                    "    }) ||",
                    "    micromatch.isMatch(filePath, withSlashes, {",
                    "      ignore: excludedPatterns,",
                    "      basename: false,",
                    "      dot: true,",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "export { resolveConfig, resolveConfigFile, clearCache };"
                ]
            },
            "resolve-editorconfig.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import editorconfig from \"editorconfig\";",
                    "import editorConfigToPrettier from \"editorconfig-to-prettier\";",
                    "import findProjectRoot from \"./find-project-root.js\";",
                    "",
                    "async function loadEditorConfig(filePath) {",
                    "  const editorConfig = await editorconfig.parse(filePath, {",
                    "    root: findProjectRoot(path.dirname(path.resolve(filePath))),",
                    "  });",
                    "",
                    "  const config = editorConfigToPrettier(editorConfig);",
                    "",
                    "  if (config) {",
                    "    // We are not using this option",
                    "    delete config.insertFinalNewline;",
                    "  }",
                    "",
                    "  return config;",
                    "}",
                    "",
                    "export default loadEditorConfig;"
                ]
            }
        },
        "document": {
            "builders.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  DOC_TYPE_CURSOR,",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "} from \"./constants.js\";",
                    "import { assertDoc, assertDocArray } from \"./utils/assert-doc.js\";",
                    "",
                    "/**",
                    " * TBD properly tagged union for Doc object type is needed here.",
                    " *",
                    " * @typedef {object} DocObject",
                    " * @property {string} type",
                    " * @property {boolean} [hard]",
                    " * @property {boolean} [literal]",
                    " *",
                    " * @typedef {Doc[]} DocArray",
                    " *",
                    " * @typedef {string | DocObject | DocArray} Doc",
                    " */",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function indent(contents) {",
                    "  assertDoc(contents);",
                    "",
                    "  return { type: DOC_TYPE_INDENT, contents };",
                    "}",
                    "",
                    "/**",
                    " * @param {number | string} widthOrString",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function align(widthOrString, contents) {",
                    "  assertDoc(contents);",
                    "",
                    "  return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function group(contents, opts = {}) {",
                    "  assertDoc(contents);",
                    "  assertDocArray(opts.expandedStates, /* optional */ true);",
                    "",
                    "  return {",
                    "    type: DOC_TYPE_GROUP,",
                    "    id: opts.id,",
                    "    contents,",
                    "    break: Boolean(opts.shouldBreak),",
                    "    expandedStates: opts.expandedStates,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedentToRoot(contents) {",
                    "  return align(Number.NEGATIVE_INFINITY, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function markAsRoot(contents) {",
                    "  // @ts-expect-error - TBD ???:",
                    "  return align({ type: \"root\" }, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedent(contents) {",
                    "  return align(-1, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} states",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function conditionalGroup(states, opts) {",
                    "  return group(states[0], { ...opts, expandedStates: states });",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} parts",
                    " * @returns Doc",
                    " */",
                    "function fill(parts) {",
                    "  assertDocArray(parts);",
                    "",
                    "  return { type: DOC_TYPE_FILL, parts };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} breakContents",
                    " * @param {Doc} [flatContents]",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function ifBreak(breakContents, flatContents = \"\", opts = {}) {",
                    "  assertDoc(breakContents);",
                    "  if (flatContents !== \"\") {",
                    "    assertDoc(flatContents);",
                    "  }",
                    "",
                    "  return {",
                    "    type: DOC_TYPE_IF_BREAK,",
                    "    breakContents,",
                    "    flatContents,",
                    "    groupId: opts.groupId,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * Optimized version of `ifBreak(indent(doc), doc, { groupId: ... })`",
                    " * @param {Doc} contents",
                    " * @param {{ groupId: symbol, negate?: boolean }} opts",
                    " * @returns Doc",
                    " */",
                    "function indentIfBreak(contents, opts) {",
                    "  assertDoc(contents);",
                    "",
                    "  return {",
                    "    type: DOC_TYPE_INDENT_IF_BREAK,",
                    "    contents,",
                    "    groupId: opts.groupId,",
                    "    negate: opts.negate,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function lineSuffix(contents) {",
                    "  assertDoc(contents);",
                    "",
                    "  return { type: DOC_TYPE_LINE_SUFFIX, contents };",
                    "}",
                    "",
                    "const lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY };",
                    "const breakParent = { type: DOC_TYPE_BREAK_PARENT };",
                    "const trim = { type: DOC_TYPE_TRIM };",
                    "",
                    "const hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: true };",
                    "const literallineWithoutBreakParent = {",
                    "  type: DOC_TYPE_LINE,",
                    "  hard: true,",
                    "  literal: true,",
                    "};",
                    "",
                    "const line = { type: DOC_TYPE_LINE };",
                    "const softline = { type: DOC_TYPE_LINE, soft: true };",
                    "const hardline = [hardlineWithoutBreakParent, breakParent];",
                    "const literalline = [literallineWithoutBreakParent, breakParent];",
                    "",
                    "const cursor = { type: DOC_TYPE_CURSOR };",
                    "",
                    "/**",
                    " * @param {Doc} separator",
                    " * @param {Doc[]} docs",
                    " * @returns Doc",
                    " */",
                    "function join(separator, docs) {",
                    "  assertDoc(separator);",
                    "  assertDocArray(docs);",
                    "",
                    "  const parts = [];",
                    "",
                    "  for (let i = 0; i < docs.length; i++) {",
                    "    if (i !== 0) {",
                    "      parts.push(separator);",
                    "    }",
                    "",
                    "    parts.push(docs[i]);",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} doc",
                    " * @param {number} size",
                    " * @param {number} tabWidth",
                    " */",
                    "function addAlignmentToDoc(doc, size, tabWidth) {",
                    "  assertDoc(doc);",
                    "",
                    "  let aligned = doc;",
                    "  if (size > 0) {",
                    "    // Use indent to add tabs for all the levels of tabs we need",
                    "    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {",
                    "      aligned = indent(aligned);",
                    "    }",
                    "    // Use align for all the spaces that are needed",
                    "    aligned = align(size % tabWidth, aligned);",
                    "    // size is absolute from 0 and not relative to the current",
                    "    // indentation, so we use -Infinity to reset the indentation to 0",
                    "    aligned = align(Number.NEGATIVE_INFINITY, aligned);",
                    "  }",
                    "  return aligned;",
                    "}",
                    "",
                    "/**",
                    " * Mark a doc with an arbitrary truthy value. This doesn't affect how the doc is printed, but can be useful for heuristics based on doc introspection.",
                    " * @param {any} label If falsy, the `contents` doc is returned as is.",
                    " * @param {Doc} contents",
                    " */",
                    "function label(label, contents) {",
                    "  assertDoc(contents);",
                    "",
                    "  return label ? { type: DOC_TYPE_LABEL, label, contents } : contents;",
                    "}",
                    "",
                    "export {",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  trim,",
                    "  indent,",
                    "  indentIfBreak,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent,",
                    "  hardlineWithoutBreakParent,",
                    "  literallineWithoutBreakParent,",
                    "  label,",
                    "};"
                ]
            },
            "constants.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export const DOC_TYPE_STRING = \"string\";",
                    "export const DOC_TYPE_ARRAY = \"array\";",
                    "export const DOC_TYPE_CURSOR = \"cursor\";",
                    "export const DOC_TYPE_INDENT = \"indent\";",
                    "export const DOC_TYPE_ALIGN = \"align\";",
                    "export const DOC_TYPE_TRIM = \"trim\";",
                    "export const DOC_TYPE_GROUP = \"group\";",
                    "export const DOC_TYPE_FILL = \"fill\";",
                    "export const DOC_TYPE_IF_BREAK = \"if-break\";",
                    "export const DOC_TYPE_INDENT_IF_BREAK = \"indent-if-break\";",
                    "export const DOC_TYPE_LINE_SUFFIX = \"line-suffix\";",
                    "export const DOC_TYPE_LINE_SUFFIX_BOUNDARY = \"line-suffix-boundary\";",
                    "export const DOC_TYPE_LINE = \"line\";",
                    "export const DOC_TYPE_LABEL = \"label\";",
                    "export const DOC_TYPE_BREAK_PARENT = \"break-parent\";",
                    "",
                    "export const VALID_OBJECT_DOC_TYPES = new Set([",
                    "  DOC_TYPE_CURSOR,",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "]);"
                ]
            },
            "debug.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "} from \"./constants.js\";",
                    "",
                    "function flattenDoc(doc) {",
                    "  if (!doc) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (Array.isArray(doc)) {",
                    "    const res = [];",
                    "    for (const part of doc) {",
                    "      if (Array.isArray(part)) {",
                    "        res.push(...flattenDoc(part));",
                    "      } else {",
                    "        const flattened = flattenDoc(part);",
                    "        if (flattened !== \"\") {",
                    "          res.push(flattened);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return res;",
                    "  }",
                    "",
                    "  if (doc.type === DOC_TYPE_IF_BREAK) {",
                    "    return {",
                    "      ...doc,",
                    "      breakContents: flattenDoc(doc.breakContents),",
                    "      flatContents: flattenDoc(doc.flatContents),",
                    "    };",
                    "  }",
                    "",
                    "  if (doc.type === DOC_TYPE_GROUP) {",
                    "    return {",
                    "      ...doc,",
                    "      contents: flattenDoc(doc.contents),",
                    "      expandedStates: doc.expandedStates?.map(flattenDoc),",
                    "    };",
                    "  }",
                    "",
                    "  if (doc.type === DOC_TYPE_FILL) {",
                    "    return { type: \"fill\", parts: doc.parts.map(flattenDoc) };",
                    "  }",
                    "",
                    "  if (doc.contents) {",
                    "    return { ...doc, contents: flattenDoc(doc.contents) };",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function printDocToDebug(doc) {",
                    "  /** @type Record<symbol, string> */",
                    "  const printedSymbols = Object.create(null);",
                    "  /** @type Set<string> */",
                    "  const usedKeysForSymbols = new Set();",
                    "  return printDoc(flattenDoc(doc));",
                    "",
                    "  function printDoc(doc, index, parentParts) {",
                    "    if (typeof doc === \"string\") {",
                    "      return JSON.stringify(doc);",
                    "    }",
                    "",
                    "    if (Array.isArray(doc)) {",
                    "      const printed = doc.map(printDoc).filter(Boolean);",
                    "      return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_LINE) {",
                    "      const withBreakParent =",
                    "        parentParts?.[index + 1]?.type === DOC_TYPE_BREAK_PARENT;",
                    "      if (doc.literal) {",
                    "        return withBreakParent",
                    "          ? \"literalline\"",
                    "          : \"literallineWithoutBreakParent\";",
                    "      }",
                    "      if (doc.hard) {",
                    "        return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";",
                    "      }",
                    "      if (doc.soft) {",
                    "        return \"softline\";",
                    "      }",
                    "      return \"line\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_BREAK_PARENT) {",
                    "      const afterHardline =",
                    "        parentParts?.[index - 1]?.type === DOC_TYPE_LINE &&",
                    "        parentParts[index - 1].hard;",
                    "      return afterHardline ? undefined : \"breakParent\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_TRIM) {",
                    "      return \"trim\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_INDENT) {",
                    "      return \"indent(\" + printDoc(doc.contents) + \")\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_ALIGN) {",
                    "      return doc.n === Number.NEGATIVE_INFINITY",
                    "        ? \"dedentToRoot(\" + printDoc(doc.contents) + \")\"",
                    "        : doc.n < 0",
                    "        ? \"dedent(\" + printDoc(doc.contents) + \")\"",
                    "        : doc.n.type === \"root\"",
                    "        ? \"markAsRoot(\" + printDoc(doc.contents) + \")\"",
                    "        : \"align(\" +",
                    "          JSON.stringify(doc.n) +",
                    "          \", \" +",
                    "          printDoc(doc.contents) +",
                    "          \")\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_IF_BREAK) {",
                    "      return (",
                    "        \"ifBreak(\" +",
                    "        printDoc(doc.breakContents) +",
                    "        (doc.flatContents ? \", \" + printDoc(doc.flatContents) : \"\") +",
                    "        (doc.groupId",
                    "          ? (!doc.flatContents ? ', \"\"' : \"\") +",
                    "            `, { groupId: ${printGroupId(doc.groupId)} }`",
                    "          : \"\") +",
                    "        \")\"",
                    "      );",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_INDENT_IF_BREAK) {",
                    "      const optionsParts = [];",
                    "",
                    "      if (doc.negate) {",
                    "        optionsParts.push(\"negate: true\");",
                    "      }",
                    "",
                    "      if (doc.groupId) {",
                    "        optionsParts.push(`groupId: ${printGroupId(doc.groupId)}`);",
                    "      }",
                    "",
                    "      const options =",
                    "        optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";",
                    "",
                    "      return `indentIfBreak(${printDoc(doc.contents)}${options})`;",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_GROUP) {",
                    "      const optionsParts = [];",
                    "",
                    "      if (doc.break && doc.break !== \"propagated\") {",
                    "        optionsParts.push(\"shouldBreak: true\");",
                    "      }",
                    "",
                    "      if (doc.id) {",
                    "        optionsParts.push(`id: ${printGroupId(doc.id)}`);",
                    "      }",
                    "",
                    "      const options =",
                    "        optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";",
                    "",
                    "      if (doc.expandedStates) {",
                    "        return `conditionalGroup([${doc.expandedStates",
                    "          .map((part) => printDoc(part))",
                    "          .join(\",\")}]${options})`;",
                    "      }",
                    "",
                    "      return `group(${printDoc(doc.contents)}${options})`;",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_FILL) {",
                    "      return `fill([${doc.parts.map((part) => printDoc(part)).join(\", \")}])`;",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_LINE_SUFFIX) {",
                    "      return \"lineSuffix(\" + printDoc(doc.contents) + \")\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_LINE_SUFFIX_BOUNDARY) {",
                    "      return \"lineSuffixBoundary\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_LABEL) {",
                    "      return `label(${JSON.stringify(doc.label)}, ${printDoc(doc.contents)})`;",
                    "    }",
                    "",
                    "    throw new Error(\"Unknown doc type \" + doc.type);",
                    "  }",
                    "",
                    "  function printGroupId(id) {",
                    "    if (typeof id !== \"symbol\") {",
                    "      return JSON.stringify(String(id));",
                    "    }",
                    "",
                    "    if (id in printedSymbols) {",
                    "      return printedSymbols[id];",
                    "    }",
                    "",
                    "    const prefix = id.description || \"symbol\";",
                    "    for (let counter = 0; ; counter++) {",
                    "      const key = prefix + (counter > 0 ? ` #${counter}` : \"\");",
                    "      if (!usedKeysForSymbols.has(key)) {",
                    "        usedKeysForSymbols.add(key);",
                    "        return (printedSymbols[id] = `Symbol.for(${JSON.stringify(key)})`);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "export { printDocToDebug };"
                ]
            },
            "invalid-doc-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { VALID_OBJECT_DOC_TYPES } from \"./constants.js\";",
                    "import getDocType from \"./utils/get-doc-type.js\";",
                    "",
                    "const disjunctionListFormat = (list) =>",
                    "  new Intl.ListFormat(\"en-US\", { type: \"disjunction\" }).format(list);",
                    "",
                    "function getDocErrorMessage(doc) {",
                    "  const type = doc === null ? \"null\" : typeof doc;",
                    "  if (type !== \"string\" && type !== \"object\") {",
                    "    return `Unexpected doc '${type}', \\nExpected it to be 'string' or 'object'.`;",
                    "  }",
                    "",
                    "  /* c8 ignore next 3 */",
                    "  if (getDocType(doc)) {",
                    "    throw new Error(\"doc is valid.\");",
                    "  }",
                    "",
                    "  // eslint-disable-next-line prettier-internal-rules/no-unnecessary-ast-path-call",
                    "  const objectType = Object.prototype.toString.call(doc);",
                    "  if (objectType !== \"[object Object]\") {",
                    "    return `Unexpected doc '${objectType}'.`;",
                    "  }",
                    "",
                    "  const EXPECTED_TYPE_VALUES = disjunctionListFormat(",
                    "    [...VALID_OBJECT_DOC_TYPES].map((type) => `'${type}'`)",
                    "  );",
                    "",
                    "  return `Unexpected doc.type '${doc.type}'.\\nExpected it to be ${EXPECTED_TYPE_VALUES}.`;",
                    "}",
                    "",
                    "class InvalidDocError extends Error {",
                    "  name = \"InvalidDocError\";",
                    "",
                    "  constructor(doc) {",
                    "    super(getDocErrorMessage(doc));",
                    "    this.doc = doc;",
                    "  }",
                    "}",
                    "",
                    "export default InvalidDocError;"
                ]
            },
            "printer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { convertEndOfLineToChars } from \"../common/end-of-line.js\";",
                    "import getStringWidth from \"../utils/get-string-width.js\";",
                    "import {",
                    "  DOC_TYPE_STRING,",
                    "  DOC_TYPE_ARRAY,",
                    "  DOC_TYPE_CURSOR,",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "} from \"./constants.js\";",
                    "import { fill, indent, hardlineWithoutBreakParent } from \"./builders.js\";",
                    "import { getDocParts, getDocType, propagateBreaks } from \"./utils.js\";",
                    "import InvalidDocError from \"./invalid-doc-error.js\";",
                    "",
                    "/** @typedef {typeof MODE_BREAK | typeof MODE_FLAT} Mode */",
                    "/** @typedef {{ ind: any, doc: any, mode: Mode }} Command */",
                    "/** @typedef {Record<symbol, Mode>} GroupModeMap */",
                    "",
                    "/** @type {unique symbol} */",
                    "const MODE_BREAK = Symbol(\"MODE_BREAK\");",
                    "/** @type {unique symbol} */",
                    "const MODE_FLAT = Symbol(\"MODE_FLAT\");",
                    "",
                    "const CURSOR_PLACEHOLDER = Symbol(\"cursor\");",
                    "",
                    "function rootIndent() {",
                    "  return { value: \"\", length: 0, queue: [] };",
                    "}",
                    "",
                    "function makeIndent(ind, options) {",
                    "  return generateInd(ind, { type: \"indent\" }, options);",
                    "}",
                    "",
                    "function makeAlign(indent, widthOrDoc, options) {",
                    "  if (widthOrDoc === Number.NEGATIVE_INFINITY) {",
                    "    return indent.root || rootIndent();",
                    "  }",
                    "",
                    "  if (widthOrDoc < 0) {",
                    "    return generateInd(indent, { type: \"dedent\" }, options);",
                    "  }",
                    "",
                    "  if (!widthOrDoc) {",
                    "    return indent;",
                    "  }",
                    "",
                    "  if (widthOrDoc.type === \"root\") {",
                    "    return { ...indent, root: indent };",
                    "  }",
                    "",
                    "  const alignType =",
                    "    typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";",
                    "",
                    "  return generateInd(indent, { type: alignType, n: widthOrDoc }, options);",
                    "}",
                    "",
                    "function generateInd(ind, newPart, options) {",
                    "  const queue =",
                    "    newPart.type === \"dedent\"",
                    "      ? ind.queue.slice(0, -1)",
                    "      : [...ind.queue, newPart];",
                    "",
                    "  let value = \"\";",
                    "  let length = 0;",
                    "  let lastTabs = 0;",
                    "  let lastSpaces = 0;",
                    "",
                    "  for (const part of queue) {",
                    "    switch (part.type) {",
                    "      case \"indent\":",
                    "        flush();",
                    "        if (options.useTabs) {",
                    "          addTabs(1);",
                    "        } else {",
                    "          addSpaces(options.tabWidth);",
                    "        }",
                    "        break;",
                    "      case \"stringAlign\":",
                    "        flush();",
                    "        value += part.n;",
                    "        length += part.n.length;",
                    "        break;",
                    "      case \"numberAlign\":",
                    "        lastTabs += 1;",
                    "        lastSpaces += part.n;",
                    "        break;",
                    "      default:",
                    "        /* c8 ignore next */",
                    "        throw new Error(`Unexpected type '${part.type}'`);",
                    "    }",
                    "  }",
                    "",
                    "  flushSpaces();",
                    "",
                    "  return { ...ind, value, length, queue };",
                    "",
                    "  function addTabs(count) {",
                    "    value += \"\\t\".repeat(count);",
                    "    length += options.tabWidth * count;",
                    "  }",
                    "",
                    "  function addSpaces(count) {",
                    "    value += \" \".repeat(count);",
                    "    length += count;",
                    "  }",
                    "",
                    "  function flush() {",
                    "    if (options.useTabs) {",
                    "      flushTabs();",
                    "    } else {",
                    "      flushSpaces();",
                    "    }",
                    "  }",
                    "",
                    "  function flushTabs() {",
                    "    if (lastTabs > 0) {",
                    "      addTabs(lastTabs);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function flushSpaces() {",
                    "    if (lastSpaces > 0) {",
                    "      addSpaces(lastSpaces);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function resetLast() {",
                    "    lastTabs = 0;",
                    "    lastSpaces = 0;",
                    "  }",
                    "}",
                    "",
                    "// Trim `Tab(U+0009)` and `Space(U+0020)` at the end of line",
                    "function trim(out) {",
                    "  let trimCount = 0;",
                    "  let cursorCount = 0;",
                    "  let outIndex = out.length;",
                    "",
                    "  outer: while (outIndex--) {",
                    "    const last = out[outIndex];",
                    "",
                    "    if (last === CURSOR_PLACEHOLDER) {",
                    "      cursorCount++;",
                    "      continue;",
                    "    }",
                    "",
                    "    /* c8 ignore next 3 */",
                    "    if (process.env.NODE_ENV !== \"production\" && typeof last !== \"string\") {",
                    "      throw new Error(`Unexpected value in trim: '${typeof last}'`);",
                    "    }",
                    "",
                    "    // Not using a regexp here because regexps for trimming off trailing",
                    "    // characters are known to have performance issues.",
                    "    for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {",
                    "      const char = last[charIndex];",
                    "      if (char === \" \" || char === \"\\t\") {",
                    "        trimCount++;",
                    "      } else {",
                    "        out[outIndex] = last.slice(0, charIndex + 1);",
                    "        break outer;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  if (trimCount > 0 || cursorCount > 0) {",
                    "    out.length = outIndex + 1;",
                    "",
                    "    while (cursorCount-- > 0) {",
                    "      out.push(CURSOR_PLACEHOLDER);",
                    "    }",
                    "  }",
                    "",
                    "  return trimCount;",
                    "}",
                    "",
                    "/**",
                    " * @param {Command} next",
                    " * @param {Command[]} restCommands",
                    " * @param {number} width",
                    " * @param {boolean} hasLineSuffix",
                    " * @param {GroupModeMap} groupModeMap",
                    " * @param {boolean} [mustBeFlat]",
                    " * @returns {boolean}",
                    " */",
                    "function fits(",
                    "  next,",
                    "  restCommands,",
                    "  width,",
                    "  hasLineSuffix,",
                    "  groupModeMap,",
                    "  mustBeFlat",
                    ") {",
                    "  if (width === Number.POSITIVE_INFINITY) {",
                    "    return true;",
                    "  }",
                    "",
                    "  let restIdx = restCommands.length;",
                    "  /** @type {Array<Omit<Command, 'ind'>>} */",
                    "  const cmds = [next];",
                    "  // `out` is only used for width counting because `trim` requires to look",
                    "  // backwards for space characters.",
                    "  const out = [];",
                    "  while (width >= 0) {",
                    "    if (cmds.length === 0) {",
                    "      if (restIdx === 0) {",
                    "        return true;",
                    "      }",
                    "      cmds.push(restCommands[--restIdx]);",
                    "",
                    "      continue;",
                    "    }",
                    "",
                    "    const { mode, doc } = cmds.pop();",
                    "",
                    "    switch (getDocType(doc)) {",
                    "      case DOC_TYPE_STRING:",
                    "        out.push(doc);",
                    "        width -= getStringWidth(doc);",
                    "        break;",
                    "",
                    "      case DOC_TYPE_ARRAY:",
                    "      case DOC_TYPE_FILL: {",
                    "        const parts = getDocParts(doc);",
                    "        for (let i = parts.length - 1; i >= 0; i--) {",
                    "          cmds.push({ mode, doc: parts[i] });",
                    "        }",
                    "        break;",
                    "      }",
                    "",
                    "      case DOC_TYPE_INDENT:",
                    "      case DOC_TYPE_ALIGN:",
                    "      case DOC_TYPE_INDENT_IF_BREAK:",
                    "      case DOC_TYPE_LABEL:",
                    "        cmds.push({ mode, doc: doc.contents });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_TRIM:",
                    "        width += trim(out);",
                    "        break;",
                    "",
                    "      case DOC_TYPE_GROUP: {",
                    "        if (mustBeFlat && doc.break) {",
                    "          return false;",
                    "        }",
                    "        const groupMode = doc.break ? MODE_BREAK : mode;",
                    "        // The most expanded state takes up the least space on the current line.",
                    "        const contents =",
                    "          doc.expandedStates && groupMode === MODE_BREAK",
                    "            ? doc.expandedStates.at(-1)",
                    "            : doc.contents;",
                    "        cmds.push({ mode: groupMode, doc: contents });",
                    "        break;",
                    "      }",
                    "",
                    "      case DOC_TYPE_IF_BREAK: {",
                    "        const groupMode = doc.groupId",
                    "          ? groupModeMap[doc.groupId] || MODE_FLAT",
                    "          : mode;",
                    "        const contents =",
                    "          groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;",
                    "        if (contents) {",
                    "          cmds.push({ mode, doc: contents });",
                    "        }",
                    "        break;",
                    "      }",
                    "",
                    "      case DOC_TYPE_LINE:",
                    "        if (mode === MODE_BREAK || doc.hard) {",
                    "          return true;",
                    "        }",
                    "        if (!doc.soft) {",
                    "          out.push(\" \");",
                    "          width--;",
                    "        }",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LINE_SUFFIX:",
                    "        hasLineSuffix = true;",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "        if (hasLineSuffix) {",
                    "          return false;",
                    "        }",
                    "        break;",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function printDocToString(doc, options) {",
                    "  /** @type GroupModeMap */",
                    "  const groupModeMap = {};",
                    "",
                    "  const width = options.printWidth;",
                    "  const newLine = convertEndOfLineToChars(options.endOfLine);",
                    "  let pos = 0;",
                    "  // cmds is basically a stack. We've turned a recursive call into a",
                    "  // while loop which is much faster. The while loop below adds new",
                    "  // cmds to the array instead of recursively calling `print`.",
                    "  /** @type Command[] */",
                    "  const cmds = [{ ind: rootIndent(), mode: MODE_BREAK, doc }];",
                    "  const out = [];",
                    "  let shouldRemeasure = false;",
                    "  /** @type Command[] */",
                    "  const lineSuffix = [];",
                    "  let printedCursorCount = 0;",
                    "",
                    "  propagateBreaks(doc);",
                    "",
                    "  while (cmds.length > 0) {",
                    "    const { ind, mode, doc } = cmds.pop();",
                    "    switch (getDocType(doc)) {",
                    "      case DOC_TYPE_STRING: {",
                    "        const formatted =",
                    "          newLine !== \"\\n\" ? doc.replaceAll(\"\\n\", newLine) : doc;",
                    "        out.push(formatted);",
                    "        // Plugins may print single string, should skip measure the width",
                    "        if (cmds.length > 0) {",
                    "          pos += getStringWidth(formatted);",
                    "        }",
                    "        break;",
                    "      }",
                    "",
                    "      case DOC_TYPE_ARRAY:",
                    "        for (let i = doc.length - 1; i >= 0; i--) {",
                    "          cmds.push({ ind, mode, doc: doc[i] });",
                    "        }",
                    "        break;",
                    "",
                    "      case DOC_TYPE_CURSOR:",
                    "        if (printedCursorCount >= 2) {",
                    "          throw new Error(\"There are too many 'cursor' in doc.\");",
                    "        }",
                    "        out.push(CURSOR_PLACEHOLDER);",
                    "        printedCursorCount++;",
                    "        break;",
                    "",
                    "      case DOC_TYPE_INDENT:",
                    "        cmds.push({ ind: makeIndent(ind, options), mode, doc: doc.contents });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_ALIGN:",
                    "        cmds.push({",
                    "          ind: makeAlign(ind, doc.n, options),",
                    "          mode,",
                    "          doc: doc.contents,",
                    "        });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_TRIM:",
                    "        pos -= trim(out);",
                    "        break;",
                    "",
                    "      case DOC_TYPE_GROUP:",
                    "        switch (mode) {",
                    "          case MODE_FLAT:",
                    "            if (!shouldRemeasure) {",
                    "              cmds.push({",
                    "                ind,",
                    "                mode: doc.break ? MODE_BREAK : MODE_FLAT,",
                    "                doc: doc.contents,",
                    "              });",
                    "",
                    "              break;",
                    "            }",
                    "          // fallthrough",
                    "",
                    "          case MODE_BREAK: {",
                    "            shouldRemeasure = false;",
                    "",
                    "            const next = { ind, mode: MODE_FLAT, doc: doc.contents };",
                    "            const rem = width - pos;",
                    "            const hasLineSuffix = lineSuffix.length > 0;",
                    "",
                    "            if (",
                    "              !doc.break &&",
                    "              fits(next, cmds, rem, hasLineSuffix, groupModeMap)",
                    "            ) {",
                    "              cmds.push(next);",
                    "            } else {",
                    "              // Expanded states are a rare case where a document",
                    "              // can manually provide multiple representations of",
                    "              // itself. It provides an array of documents",
                    "              // going from the least expanded (most flattened)",
                    "              // representation first to the most expanded. If a",
                    "              // group has these, we need to manually go through",
                    "              // these states and find the first one that fits.",
                    "              // eslint-disable-next-line no-lonely-if",
                    "              if (doc.expandedStates) {",
                    "                const mostExpanded = doc.expandedStates.at(-1);",
                    "",
                    "                if (doc.break) {",
                    "                  cmds.push({ ind, mode: MODE_BREAK, doc: mostExpanded });",
                    "",
                    "                  break;",
                    "                } else {",
                    "                  for (let i = 1; i < doc.expandedStates.length + 1; i++) {",
                    "                    if (i >= doc.expandedStates.length) {",
                    "                      cmds.push({ ind, mode: MODE_BREAK, doc: mostExpanded });",
                    "",
                    "                      break;",
                    "                    } else {",
                    "                      const state = doc.expandedStates[i];",
                    "                      const cmd = { ind, mode: MODE_FLAT, doc: state };",
                    "",
                    "                      if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {",
                    "                        cmds.push(cmd);",
                    "",
                    "                        break;",
                    "                      }",
                    "                    }",
                    "                  }",
                    "                }",
                    "              } else {",
                    "                cmds.push({ ind, mode: MODE_BREAK, doc: doc.contents });",
                    "              }",
                    "            }",
                    "",
                    "            break;",
                    "          }",
                    "        }",
                    "",
                    "        if (doc.id) {",
                    "          groupModeMap[doc.id] = cmds.at(-1).mode;",
                    "        }",
                    "        break;",
                    "      // Fills each line with as much code as possible before moving to a new",
                    "      // line with the same indentation.",
                    "      //",
                    "      // Expects doc.parts to be an array of alternating content and",
                    "      // whitespace. The whitespace contains the linebreaks.",
                    "      //",
                    "      // For example:",
                    "      //   [\"I\", line, \"love\", line, \"monkeys\"]",
                    "      // or",
                    "      //   [{ type: group, ... }, softline, { type: group, ... }]",
                    "      //",
                    "      // It uses this parts structure to handle three main layout cases:",
                    "      // * The first two content items fit on the same line without",
                    "      //   breaking",
                    "      //   -> output the first content item and the whitespace \"flat\".",
                    "      // * Only the first content item fits on the line without breaking",
                    "      //   -> output the first content item \"flat\" and the whitespace with",
                    "      //   \"break\".",
                    "      // * Neither content item fits on the line without breaking",
                    "      //   -> output the first content item and the whitespace with \"break\".",
                    "      case DOC_TYPE_FILL: {",
                    "        const rem = width - pos;",
                    "",
                    "        const { parts } = doc;",
                    "        if (parts.length === 0) {",
                    "          break;",
                    "        }",
                    "",
                    "        const [content, whitespace] = parts;",
                    "        const contentFlatCmd = { ind, mode: MODE_FLAT, doc: content };",
                    "        const contentBreakCmd = { ind, mode: MODE_BREAK, doc: content };",
                    "        const contentFits = fits(",
                    "          contentFlatCmd,",
                    "          [],",
                    "          rem,",
                    "          lineSuffix.length > 0,",
                    "          groupModeMap,",
                    "          true",
                    "        );",
                    "",
                    "        if (parts.length === 1) {",
                    "          if (contentFits) {",
                    "            cmds.push(contentFlatCmd);",
                    "          } else {",
                    "            cmds.push(contentBreakCmd);",
                    "          }",
                    "          break;",
                    "        }",
                    "",
                    "        const whitespaceFlatCmd = { ind, mode: MODE_FLAT, doc: whitespace };",
                    "        const whitespaceBreakCmd = { ind, mode: MODE_BREAK, doc: whitespace };",
                    "",
                    "        if (parts.length === 2) {",
                    "          if (contentFits) {",
                    "            cmds.push(whitespaceFlatCmd, contentFlatCmd);",
                    "          } else {",
                    "            cmds.push(whitespaceBreakCmd, contentBreakCmd);",
                    "          }",
                    "          break;",
                    "        }",
                    "",
                    "        // At this point we've handled the first pair (context, separator)",
                    "        // and will create a new fill doc for the rest of the content.",
                    "        // Ideally we wouldn't mutate the array here but copying all the",
                    "        // elements to a new array would make this algorithm quadratic,",
                    "        // which is unusable for large arrays (e.g. large texts in JSX).",
                    "        parts.splice(0, 2);",
                    "        const remainingCmd = { ind, mode, doc: fill(parts) };",
                    "",
                    "        const secondContent = parts[0];",
                    "",
                    "        const firstAndSecondContentFlatCmd = {",
                    "          ind,",
                    "          mode: MODE_FLAT,",
                    "          doc: [content, whitespace, secondContent],",
                    "        };",
                    "        const firstAndSecondContentFits = fits(",
                    "          firstAndSecondContentFlatCmd,",
                    "          [],",
                    "          rem,",
                    "          lineSuffix.length > 0,",
                    "          groupModeMap,",
                    "          true",
                    "        );",
                    "",
                    "        if (firstAndSecondContentFits) {",
                    "          cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);",
                    "        } else if (contentFits) {",
                    "          cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);",
                    "        } else {",
                    "          cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);",
                    "        }",
                    "        break;",
                    "      }",
                    "      case DOC_TYPE_IF_BREAK:",
                    "      case DOC_TYPE_INDENT_IF_BREAK: {",
                    "        const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                    "        if (groupMode === MODE_BREAK) {",
                    "          const breakContents =",
                    "            doc.type === DOC_TYPE_IF_BREAK",
                    "              ? doc.breakContents",
                    "              : doc.negate",
                    "              ? doc.contents",
                    "              : indent(doc.contents);",
                    "          if (breakContents) {",
                    "            cmds.push({ ind, mode, doc: breakContents });",
                    "          }",
                    "        }",
                    "        if (groupMode === MODE_FLAT) {",
                    "          const flatContents =",
                    "            doc.type === DOC_TYPE_IF_BREAK",
                    "              ? doc.flatContents",
                    "              : doc.negate",
                    "              ? indent(doc.contents)",
                    "              : doc.contents;",
                    "          if (flatContents) {",
                    "            cmds.push({ ind, mode, doc: flatContents });",
                    "          }",
                    "        }",
                    "",
                    "        break;",
                    "      }",
                    "      case DOC_TYPE_LINE_SUFFIX:",
                    "        lineSuffix.push({ ind, mode, doc: doc.contents });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "        if (lineSuffix.length > 0) {",
                    "          cmds.push({ ind, mode, doc: hardlineWithoutBreakParent });",
                    "        }",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LINE:",
                    "        switch (mode) {",
                    "          case MODE_FLAT:",
                    "            if (!doc.hard) {",
                    "              if (!doc.soft) {",
                    "                out.push(\" \");",
                    "",
                    "                pos += 1;",
                    "              }",
                    "",
                    "              break;",
                    "            } else {",
                    "              // This line was forced into the output even if we",
                    "              // were in flattened mode, so we need to tell the next",
                    "              // group that no matter what, it needs to remeasure",
                    "              // because the previous measurement didn't accurately",
                    "              // capture the entire expression (this is necessary",
                    "              // for nested groups)",
                    "              shouldRemeasure = true;",
                    "            }",
                    "          // fallthrough",
                    "",
                    "          case MODE_BREAK:",
                    "            if (lineSuffix.length > 0) {",
                    "              cmds.push({ ind, mode, doc }, ...lineSuffix.reverse());",
                    "              lineSuffix.length = 0;",
                    "              break;",
                    "            }",
                    "",
                    "            if (doc.literal) {",
                    "              if (ind.root) {",
                    "                out.push(newLine, ind.root.value);",
                    "                pos = ind.root.length;",
                    "              } else {",
                    "                out.push(newLine);",
                    "                pos = 0;",
                    "              }",
                    "            } else {",
                    "              pos -= trim(out);",
                    "              out.push(newLine + ind.value);",
                    "              pos = ind.length;",
                    "            }",
                    "            break;",
                    "        }",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LABEL:",
                    "        cmds.push({ ind, mode, doc: doc.contents });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_BREAK_PARENT:",
                    "        // No op",
                    "        break;",
                    "",
                    "      default:",
                    "        throw new InvalidDocError(doc);",
                    "    }",
                    "",
                    "    // Flush remaining line-suffix contents at the end of the document, in case",
                    "    // there is no new line after the line-suffix.",
                    "    if (cmds.length === 0 && lineSuffix.length > 0) {",
                    "      cmds.push(...lineSuffix.reverse());",
                    "      lineSuffix.length = 0;",
                    "    }",
                    "  }",
                    "",
                    "  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);",
                    "  if (cursorPlaceholderIndex !== -1) {",
                    "    const otherCursorPlaceholderIndex = out.indexOf(",
                    "      CURSOR_PLACEHOLDER,",
                    "      cursorPlaceholderIndex + 1",
                    "    );",
                    "    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");",
                    "    const aroundCursor = out",
                    "      .slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex)",
                    "      .join(\"\");",
                    "    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");",
                    "",
                    "    return {",
                    "      formatted: beforeCursor + aroundCursor + afterCursor,",
                    "      cursorNodeStart: beforeCursor.length,",
                    "      cursorNodeText: aroundCursor,",
                    "    };",
                    "  }",
                    "",
                    "  return { formatted: out.join(\"\") };",
                    "}",
                    "",
                    "export { printDocToString };"
                ]
            },
            "public.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "// https://github.com/prettier/prettier/blob/next/src/document/public.js",
                    "export namespace builders {",
                    "  type DocCommand =",
                    "    | Align",
                    "    | BreakParent",
                    "    | Cursor",
                    "    | Fill",
                    "    | Group",
                    "    | IfBreak",
                    "    | Indent",
                    "    | IndentIfBreak",
                    "    | Label",
                    "    | Line",
                    "    | LineSuffix",
                    "    | LineSuffixBoundary",
                    "    | Trim;",
                    "  type Doc = string | Doc[] | DocCommand;",
                    "",
                    "  interface Align {",
                    "    type: \"align\";",
                    "    contents: Doc;",
                    "    n: number | string | { type: \"root\" };",
                    "  }",
                    "",
                    "  interface BreakParent {",
                    "    type: \"break-parent\";",
                    "  }",
                    "",
                    "  interface Cursor {",
                    "    type: \"cursor\";",
                    "    placeholder: symbol;",
                    "  }",
                    "",
                    "  interface Fill {",
                    "    type: \"fill\";",
                    "    parts: Doc[];",
                    "  }",
                    "",
                    "  interface Group {",
                    "    type: \"group\";",
                    "    contents: Doc;",
                    "    break: boolean;",
                    "    expandedStates: Doc[];",
                    "  }",
                    "",
                    "  interface HardlineWithoutBreakParent extends Line {",
                    "    hard: true;",
                    "  }",
                    "",
                    "  interface IfBreak {",
                    "    type: \"if-break\";",
                    "    breakContents: Doc;",
                    "    flatContents: Doc;",
                    "  }",
                    "",
                    "  interface Indent {",
                    "    type: \"indent\";",
                    "    contents: Doc;",
                    "  }",
                    "",
                    "  interface IndentIfBreak {",
                    "    type: \"indent-if-break\";",
                    "  }",
                    "",
                    "  interface Label {",
                    "    type: \"label\";",
                    "  }",
                    "",
                    "  interface Line {",
                    "    type: \"line\";",
                    "    soft?: boolean | undefined;",
                    "    hard?: boolean | undefined;",
                    "    literal?: boolean | undefined;",
                    "  }",
                    "",
                    "  interface LineSuffix {",
                    "    type: \"line-suffix\";",
                    "    contents: Doc;",
                    "  }",
                    "",
                    "  interface LineSuffixBoundary {",
                    "    type: \"line-suffix-boundary\";",
                    "  }",
                    "",
                    "  interface LiterallineWithoutBreakParent extends Line {",
                    "    hard: true;",
                    "    literal: true;",
                    "  }",
                    "",
                    "  type LiteralLine = [LiterallineWithoutBreakParent, BreakParent];",
                    "",
                    "  interface Softline extends Line {",
                    "    soft: true;",
                    "  }",
                    "",
                    "  type Hardline = [HardlineWithoutBreakParent, BreakParent];",
                    "",
                    "  interface Trim {",
                    "    type: \"trim\";",
                    "  }",
                    "",
                    "  interface GroupOptions {",
                    "    shouldBreak?: boolean | undefined;",
                    "    id?: symbol | undefined;",
                    "  }",
                    "",
                    "  function addAlignmentToDoc(doc: Doc, size: number, tabWidth: number): Doc;",
                    "",
                    "  /** @see [align](https://github.com/prettier/prettier/blob/main/commands.md#align) */",
                    "  function align(widthOrString: Align[\"n\"], doc: Doc): Align;",
                    "",
                    "  /** @see [breakParent](https://github.com/prettier/prettier/blob/main/commands.md#breakparent) */",
                    "  const breakParent: BreakParent;",
                    "",
                    "  /** @see [conditionalGroup](https://github.com/prettier/prettier/blob/main/commands.md#conditionalgroup) */",
                    "  function conditionalGroup(alternatives: Doc[], options?: GroupOptions): Group;",
                    "",
                    "  /** @see [dedent](https://github.com/prettier/prettier/blob/main/commands.md#dedent) */",
                    "  function dedent(doc: Doc): Align;",
                    "",
                    "  /** @see [dedentToRoot](https://github.com/prettier/prettier/blob/main/commands.md#dedenttoroot) */",
                    "  function dedentToRoot(doc: Doc): Align;",
                    "",
                    "  /** @see [fill](https://github.com/prettier/prettier/blob/main/commands.md#fill) */",
                    "  function fill(docs: Doc[]): Fill;",
                    "",
                    "  /** @see [group](https://github.com/prettier/prettier/blob/main/commands.md#group) */",
                    "  function group(doc: Doc, opts?: GroupOptions): Group;",
                    "",
                    "  /** @see [hardline](https://github.com/prettier/prettier/blob/main/commands.md#hardline) */",
                    "  const hardline: Hardline;",
                    "",
                    "  /** @see [hardlineWithoutBreakParent](https://github.com/prettier/prettier/blob/main/commands.md#hardlinewithoutbreakparent-and-literallinewithoutbreakparent) */",
                    "  const hardlineWithoutBreakParent: HardlineWithoutBreakParent;",
                    "",
                    "  /** @see [ifBreak](https://github.com/prettier/prettier/blob/main/commands.md#ifbreak) */",
                    "  function ifBreak(",
                    "    ifBreak: Doc,",
                    "    noBreak?: Doc,",
                    "    options?: { groupId?: symbol | undefined }",
                    "  ): IfBreak;",
                    "",
                    "  /** @see [indent](https://github.com/prettier/prettier/blob/main/commands.md#indent) */",
                    "  function indent(doc: Doc): Indent;",
                    "",
                    "  /** @see [indentIfBreak](https://github.com/prettier/prettier/blob/main/commands.md#indentifbreak) */",
                    "  function indentIfBreak(",
                    "    doc: Doc,",
                    "    opts: { groupId: symbol; negate?: boolean | undefined }",
                    "  ): IndentIfBreak;",
                    "",
                    "  /** @see [join](https://github.com/prettier/prettier/blob/main/commands.md#join) */",
                    "  function join(sep: Doc, docs: Doc[]): Doc[];",
                    "",
                    "  /** @see [label](https://github.com/prettier/prettier/blob/main/commands.md#label) */",
                    "  function label(label: any | undefined, contents: Doc): Doc;",
                    "",
                    "  /** @see [line](https://github.com/prettier/prettier/blob/main/commands.md#line) */",
                    "  const line: Line;",
                    "",
                    "  /** @see [lineSuffix](https://github.com/prettier/prettier/blob/main/commands.md#linesuffix) */",
                    "  function lineSuffix(suffix: Doc): LineSuffix;",
                    "",
                    "  /** @see [lineSuffixBoundary](https://github.com/prettier/prettier/blob/main/commands.md#linesuffixboundary) */",
                    "  const lineSuffixBoundary: LineSuffixBoundary;",
                    "",
                    "  /** @see [literalline](https://github.com/prettier/prettier/blob/main/commands.md#literalline) */",
                    "  const literalline: LiteralLine;",
                    "",
                    "  /** @see [literallineWithoutBreakParent](https://github.com/prettier/prettier/blob/main/commands.md#hardlinewithoutbreakparent-and-literallinewithoutbreakparent) */",
                    "  const literallineWithoutBreakParent: LiterallineWithoutBreakParent;",
                    "",
                    "  /** @see [markAsRoot](https://github.com/prettier/prettier/blob/main/commands.md#markasroot) */",
                    "  function markAsRoot(doc: Doc): Align;",
                    "",
                    "  /** @see [softline](https://github.com/prettier/prettier/blob/main/commands.md#softline) */",
                    "  const softline: Softline;",
                    "",
                    "  /** @see [trim](https://github.com/prettier/prettier/blob/main/commands.md#trim) */",
                    "  const trim: Trim;",
                    "",
                    "  /** @see [cursor](https://github.com/prettier/prettier/blob/main/commands.md#cursor) */",
                    "  const cursor: Cursor;",
                    "}",
                    "",
                    "export namespace printer {",
                    "  function printDocToString(",
                    "    doc: builders.Doc,",
                    "    options: Options",
                    "  ): {",
                    "    formatted: string;",
                    "    cursorNodeStart?: number | undefined;",
                    "    cursorNodeText?: string | undefined;",
                    "  };",
                    "  interface Options {",
                    "    /**",
                    "     * Specify the line length that the printer will wrap on.",
                    "     * @default 80",
                    "     */",
                    "    printWidth: number;",
                    "    /**",
                    "     * Specify the number of spaces per indentation-level.",
                    "     * @default 2",
                    "     */",
                    "    tabWidth: number;",
                    "    /**",
                    "     * Indent lines with tabs instead of spaces",
                    "     * @default false",
                    "     */",
                    "    useTabs?: boolean;",
                    "    parentParser?: string | undefined;",
                    "    __embeddedInHtml?: boolean | undefined;",
                    "  }",
                    "}",
                    "",
                    "export namespace utils {",
                    "  function willBreak(doc: builders.Doc): boolean;",
                    "  function traverseDoc(",
                    "    doc: builders.Doc,",
                    "    onEnter?: (doc: builders.Doc) => void | boolean,",
                    "    onExit?: (doc: builders.Doc) => void,",
                    "    shouldTraverseConditionalGroups?: boolean",
                    "  ): void;",
                    "  function findInDoc<T = builders.Doc>(",
                    "    doc: builders.Doc,",
                    "    callback: (doc: builders.Doc) => T,",
                    "    defaultValue: T",
                    "  ): T;",
                    "  function mapDoc<T = builders.Doc>(",
                    "    doc: builders.Doc,",
                    "    callback: (doc: builders.Doc) => T",
                    "  ): T;",
                    "  function removeLines(doc: builders.Doc): builders.Doc;",
                    "  function stripTrailingHardline(doc: builders.Doc): builders.Doc;",
                    "  function replaceEndOfLine(",
                    "    doc: builders.Doc,",
                    "    replacement?: builders.Doc",
                    "  ): builders.Doc;",
                    "  function canBreak(doc: builders.Doc): boolean;",
                    "}"
                ]
            },
            "public.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  trim,",
                    "  indent,",
                    "  indentIfBreak,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent,",
                    "  hardlineWithoutBreakParent,",
                    "  literallineWithoutBreakParent,",
                    "  label,",
                    "} from \"./builders.js\";",
                    "import { printDocToString } from \"./printer.js\";",
                    "import {",
                    "  willBreak,",
                    "  traverseDoc,",
                    "  findInDoc,",
                    "  mapDoc,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  replaceEndOfLine,",
                    "  canBreak,",
                    "} from \"./utils.js\";",
                    "",
                    "export const builders = {",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  trim,",
                    "  indent,",
                    "  indentIfBreak,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent,",
                    "  hardlineWithoutBreakParent,",
                    "  literallineWithoutBreakParent,",
                    "  label,",
                    "  // TODO: Remove this in v4",
                    "  concat: (parts) => parts,",
                    "};",
                    "export const printer = { printDocToString };",
                    "export const utils = {",
                    "  willBreak,",
                    "  traverseDoc,",
                    "  findInDoc,",
                    "  mapDoc,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  replaceEndOfLine,",
                    "  canBreak,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  DOC_TYPE_STRING,",
                    "  DOC_TYPE_ARRAY,",
                    "  DOC_TYPE_CURSOR,",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "} from \"./constants.js\";",
                    "import { literalline, join } from \"./builders.js\";",
                    "import getDocType from \"./utils/get-doc-type.js\";",
                    "import traverseDoc from \"./utils/traverse-doc.js\";",
                    "import InvalidDocError from \"./invalid-doc-error.js\";",
                    "",
                    "const getDocParts = (doc) => {",
                    "  if (Array.isArray(doc)) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  /* c8 ignore next 3 */",
                    "  if (doc.type !== DOC_TYPE_FILL) {",
                    "    throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL}'.`);",
                    "  }",
                    "",
                    "  return doc.parts;",
                    "};",
                    "",
                    "function mapDoc(doc, cb) {",
                    "  // Avoid creating `Map`",
                    "  if (typeof doc === \"string\") {",
                    "    return cb(doc);",
                    "  }",
                    "",
                    "  // Within a doc tree, the same subtrees can be found multiple times.",
                    "  // E.g., often this happens in conditional groups.",
                    "  // As an optimization (those subtrees can be huge) and to maintain the",
                    "  // reference structure of the tree, the mapping results are cached in",
                    "  // a map and reused.",
                    "  const mapped = new Map();",
                    "",
                    "  return rec(doc);",
                    "",
                    "  function rec(doc) {",
                    "    if (mapped.has(doc)) {",
                    "      return mapped.get(doc);",
                    "    }",
                    "    const result = process(doc);",
                    "    mapped.set(doc, result);",
                    "    return result;",
                    "  }",
                    "",
                    "  function process(doc) {",
                    "    switch (getDocType(doc)) {",
                    "      case DOC_TYPE_ARRAY:",
                    "        return cb(doc.map(rec));",
                    "",
                    "      case DOC_TYPE_FILL:",
                    "        return cb({ ...doc, parts: doc.parts.map(rec) });",
                    "",
                    "      case DOC_TYPE_IF_BREAK:",
                    "        return cb({",
                    "          ...doc,",
                    "          breakContents: rec(doc.breakContents),",
                    "          flatContents: rec(doc.flatContents),",
                    "        });",
                    "",
                    "      case DOC_TYPE_GROUP: {",
                    "        let { expandedStates, contents } = doc;",
                    "        if (expandedStates) {",
                    "          expandedStates = expandedStates.map(rec);",
                    "          contents = expandedStates[0];",
                    "        } else {",
                    "          contents = rec(contents);",
                    "        }",
                    "        return cb({ ...doc, contents, expandedStates });",
                    "      }",
                    "",
                    "      case DOC_TYPE_ALIGN:",
                    "      case DOC_TYPE_INDENT:",
                    "      case DOC_TYPE_INDENT_IF_BREAK:",
                    "      case DOC_TYPE_LABEL:",
                    "      case DOC_TYPE_LINE_SUFFIX:",
                    "        return cb({ ...doc, contents: rec(doc.contents) });",
                    "",
                    "      case DOC_TYPE_STRING:",
                    "      case DOC_TYPE_CURSOR:",
                    "      case DOC_TYPE_TRIM:",
                    "      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "      case DOC_TYPE_LINE:",
                    "      case DOC_TYPE_BREAK_PARENT:",
                    "        return cb(doc);",
                    "",
                    "      default:",
                    "        /* c8 ignore next 3 */",
                    "        throw new InvalidDocError(doc);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function findInDoc(doc, fn, defaultValue) {",
                    "  let result = defaultValue;",
                    "  let shouldSkipFurtherProcessing = false;",
                    "  function findInDocOnEnterFn(doc) {",
                    "    if (shouldSkipFurtherProcessing) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const maybeResult = fn(doc);",
                    "    if (maybeResult !== undefined) {",
                    "      shouldSkipFurtherProcessing = true;",
                    "      result = maybeResult;",
                    "    }",
                    "  }",
                    "  traverseDoc(doc, findInDocOnEnterFn);",
                    "  return result;",
                    "}",
                    "",
                    "function willBreakFn(doc) {",
                    "  if (doc.type === DOC_TYPE_GROUP && doc.break) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === DOC_TYPE_LINE && doc.hard) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === DOC_TYPE_BREAK_PARENT) {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function willBreak(doc) {",
                    "  return findInDoc(doc, willBreakFn, false);",
                    "}",
                    "",
                    "function breakParentGroup(groupStack) {",
                    "  if (groupStack.length > 0) {",
                    "    const parentGroup = groupStack.at(-1);",
                    "    // Breaks are not propagated through conditional groups because",
                    "    // the user is expected to manually handle what breaks.",
                    "    if (!parentGroup.expandedStates && !parentGroup.break) {",
                    "      // An alternative truthy value allows to distinguish propagated group breaks",
                    "      // and not to print them as `group(..., { break: true })` in `--debug-print-doc`.",
                    "      parentGroup.break = \"propagated\";",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function propagateBreaks(doc) {",
                    "  const alreadyVisitedSet = new Set();",
                    "  const groupStack = [];",
                    "  function propagateBreaksOnEnterFn(doc) {",
                    "    if (doc.type === DOC_TYPE_BREAK_PARENT) {",
                    "      breakParentGroup(groupStack);",
                    "    }",
                    "    if (doc.type === DOC_TYPE_GROUP) {",
                    "      groupStack.push(doc);",
                    "      if (alreadyVisitedSet.has(doc)) {",
                    "        return false;",
                    "      }",
                    "      alreadyVisitedSet.add(doc);",
                    "    }",
                    "  }",
                    "  function propagateBreaksOnExitFn(doc) {",
                    "    if (doc.type === DOC_TYPE_GROUP) {",
                    "      const group = groupStack.pop();",
                    "      if (group.break) {",
                    "        breakParentGroup(groupStack);",
                    "      }",
                    "    }",
                    "  }",
                    "  traverseDoc(",
                    "    doc,",
                    "    propagateBreaksOnEnterFn,",
                    "    propagateBreaksOnExitFn,",
                    "    /* shouldTraverseConditionalGroups */ true",
                    "  );",
                    "}",
                    "",
                    "function removeLinesFn(doc) {",
                    "  // Force this doc into flat mode by statically converting all",
                    "  // lines into spaces (or soft lines into nothing). Hard lines",
                    "  // should still output because there's too great of a chance",
                    "  // of breaking existing assumptions otherwise.",
                    "  if (doc.type === DOC_TYPE_LINE && !doc.hard) {",
                    "    return doc.soft ? \"\" : \" \";",
                    "  }",
                    "",
                    "  if (doc.type === DOC_TYPE_IF_BREAK) {",
                    "    return doc.flatContents;",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function removeLines(doc) {",
                    "  return mapDoc(doc, removeLinesFn);",
                    "}",
                    "",
                    "function stripTrailingHardlineFromParts(parts) {",
                    "  parts = [...parts];",
                    "",
                    "  while (",
                    "    parts.length >= 2 &&",
                    "    parts.at(-2).type === DOC_TYPE_LINE &&",
                    "    parts.at(-1).type === DOC_TYPE_BREAK_PARENT",
                    "  ) {",
                    "    parts.length -= 2;",
                    "  }",
                    "",
                    "  if (parts.length > 0) {",
                    "    const lastPart = stripTrailingHardlineFromDoc(parts.at(-1));",
                    "    parts[parts.length - 1] = lastPart;",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function stripTrailingHardlineFromDoc(doc) {",
                    "  switch (getDocType(doc)) {",
                    "    case DOC_TYPE_ALIGN:",
                    "    case DOC_TYPE_INDENT:",
                    "    case DOC_TYPE_INDENT_IF_BREAK:",
                    "    case DOC_TYPE_GROUP:",
                    "    case DOC_TYPE_LINE_SUFFIX:",
                    "    case DOC_TYPE_LABEL: {",
                    "      const contents = stripTrailingHardlineFromDoc(doc.contents);",
                    "      return { ...doc, contents };",
                    "    }",
                    "",
                    "    case DOC_TYPE_IF_BREAK:",
                    "      return {",
                    "        ...doc,",
                    "        breakContents: stripTrailingHardlineFromDoc(doc.breakContents),",
                    "        flatContents: stripTrailingHardlineFromDoc(doc.flatContents),",
                    "      };",
                    "",
                    "    case DOC_TYPE_FILL:",
                    "      return { ...doc, parts: stripTrailingHardlineFromParts(doc.parts) };",
                    "",
                    "    case DOC_TYPE_ARRAY:",
                    "      return stripTrailingHardlineFromParts(doc);",
                    "",
                    "    case DOC_TYPE_STRING:",
                    "      return doc.replace(/[\\n\\r]*$/, \"\");",
                    "",
                    "    case DOC_TYPE_CURSOR:",
                    "    case DOC_TYPE_TRIM:",
                    "    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "    case DOC_TYPE_LINE:",
                    "    case DOC_TYPE_BREAK_PARENT:",
                    "      // No op",
                    "      break;",
                    "",
                    "    default:",
                    "      throw new InvalidDocError(doc);",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function stripTrailingHardline(doc) {",
                    "  // HACK remove ending hardline, original PR: #1984",
                    "  return stripTrailingHardlineFromDoc(cleanDoc(doc));",
                    "}",
                    "",
                    "function cleanDocFn(doc) {",
                    "  switch (getDocType(doc)) {",
                    "    case DOC_TYPE_FILL:",
                    "      if (doc.parts.every((part) => part === \"\")) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case DOC_TYPE_GROUP:",
                    "      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {",
                    "        return \"\";",
                    "      }",
                    "      // Remove nested only group",
                    "      if (",
                    "        doc.contents.type === DOC_TYPE_GROUP &&",
                    "        doc.contents.id === doc.id &&",
                    "        doc.contents.break === doc.break &&",
                    "        doc.contents.expandedStates === doc.expandedStates",
                    "      ) {",
                    "        return doc.contents;",
                    "      }",
                    "      break;",
                    "    case DOC_TYPE_ALIGN:",
                    "    case DOC_TYPE_INDENT:",
                    "    case DOC_TYPE_INDENT_IF_BREAK:",
                    "    case DOC_TYPE_LINE_SUFFIX:",
                    "      if (!doc.contents) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case DOC_TYPE_IF_BREAK:",
                    "      if (!doc.flatContents && !doc.breakContents) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case DOC_TYPE_ARRAY: {",
                    "      // Flat array, concat strings",
                    "      const parts = [];",
                    "      for (const part of doc) {",
                    "        if (!part) {",
                    "          continue;",
                    "        }",
                    "        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];",
                    "        if (",
                    "          typeof currentPart === \"string\" &&",
                    "          typeof parts.at(-1) === \"string\"",
                    "        ) {",
                    "          parts[parts.length - 1] += currentPart;",
                    "        } else {",
                    "          parts.push(currentPart);",
                    "        }",
                    "        parts.push(...restParts);",
                    "      }",
                    "",
                    "      if (parts.length === 0) {",
                    "        return \"\";",
                    "      }",
                    "",
                    "      if (parts.length === 1) {",
                    "        return parts[0];",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    case DOC_TYPE_STRING:",
                    "    case DOC_TYPE_CURSOR:",
                    "    case DOC_TYPE_TRIM:",
                    "    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "    case DOC_TYPE_LINE:",
                    "    case DOC_TYPE_LABEL:",
                    "    case DOC_TYPE_BREAK_PARENT:",
                    "      // No op",
                    "      break;",
                    "    default:",
                    "      /* c8 ignore next 3 */",
                    "      throw new InvalidDocError(doc);",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "// A safer version of `normalizeDoc`",
                    "// - `normalizeDoc` concat strings and flat array in `fill`, while `cleanDoc` don't",
                    "// - On array, `normalizeDoc` always return object with `parts`, `cleanDoc` may return strings",
                    "// - `cleanDoc` also remove nested `group`s and empty `fill`/`align`/`indent`/`line-suffix`/`if-break` if possible",
                    "function cleanDoc(doc) {",
                    "  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));",
                    "}",
                    "",
                    "function normalizeParts(parts) {",
                    "  const newParts = [];",
                    "",
                    "  const restParts = parts.filter(Boolean);",
                    "  while (restParts.length > 0) {",
                    "    const part = restParts.shift();",
                    "",
                    "    if (!part) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (Array.isArray(part)) {",
                    "      restParts.unshift(...part);",
                    "      continue;",
                    "    }",
                    "",
                    "    if (",
                    "      newParts.length > 0 &&",
                    "      typeof newParts.at(-1) === \"string\" &&",
                    "      typeof part === \"string\"",
                    "    ) {",
                    "      newParts[newParts.length - 1] += part;",
                    "      continue;",
                    "    }",
                    "",
                    "    newParts.push(part);",
                    "  }",
                    "",
                    "  return newParts;",
                    "}",
                    "",
                    "function normalizeDoc(doc) {",
                    "  return mapDoc(doc, (currentDoc) => {",
                    "    if (Array.isArray(currentDoc)) {",
                    "      return normalizeParts(currentDoc);",
                    "    }",
                    "    if (!currentDoc.parts) {",
                    "      return currentDoc;",
                    "    }",
                    "    return {",
                    "      ...currentDoc,",
                    "      parts: normalizeParts(currentDoc.parts),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "function replaceEndOfLine(doc, replacement = literalline) {",
                    "  return mapDoc(doc, (currentDoc) =>",
                    "    typeof currentDoc === \"string\"",
                    "      ? join(replacement, currentDoc.split(\"\\n\"))",
                    "      : currentDoc",
                    "  );",
                    "}",
                    "",
                    "function canBreakFn(doc) {",
                    "  if (doc.type === DOC_TYPE_LINE) {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function canBreak(doc) {",
                    "  return findInDoc(doc, canBreakFn, false);",
                    "}",
                    "",
                    "function inheritLabel(doc, fn) {",
                    "  return doc.type === DOC_TYPE_LABEL",
                    "    ? { ...doc, contents: fn(doc.contents) }",
                    "    : fn(doc);",
                    "}",
                    "",
                    "export {",
                    "  getDocParts,",
                    "  willBreak,",
                    "  traverseDoc,",
                    "  findInDoc,",
                    "  mapDoc,",
                    "  propagateBreaks,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  normalizeParts,",
                    "  normalizeDoc,",
                    "  cleanDoc,",
                    "  replaceEndOfLine,",
                    "  canBreak,",
                    "  getDocType,",
                    "  inheritLabel,",
                    "};"
                ]
            },
            "utils": {
                "assert-doc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import traverseDoc from \"./traverse-doc.js\";",
                        "",
                        "const checked = process.env.NODE_ENV !== \"production\" && new WeakSet();",
                        "const noop = () => {};",
                        "const assertDoc =",
                        "  process.env.NODE_ENV === \"production\"",
                        "    ? noop",
                        "    : function (doc) {",
                        "        traverseDoc(doc, (doc) => {",
                        "          if (checked.has(doc)) {",
                        "            return false;",
                        "          }",
                        "",
                        "          if (typeof doc !== \"string\") {",
                        "            checked.add(doc);",
                        "          }",
                        "        });",
                        "      };",
                        "",
                        "const assertDocArray =",
                        "  process.env.NODE_ENV === \"production\"",
                        "    ? noop",
                        "    : function (docs, optional = false) {",
                        "        if (optional && !docs) {",
                        "          return;",
                        "        }",
                        "",
                        "        if (!Array.isArray(docs)) {",
                        "          throw new TypeError(\"Unexpected doc array.\");",
                        "        }",
                        "",
                        "        for (const doc of docs) {",
                        "          assertDoc(doc);",
                        "        }",
                        "      };",
                        "",
                        "export { assertDoc, assertDocArray };"
                    ]
                },
                "get-doc-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  DOC_TYPE_STRING,",
                        "  DOC_TYPE_ARRAY,",
                        "  VALID_OBJECT_DOC_TYPES,",
                        "} from \"../constants.js\";",
                        "",
                        "function getDocType(doc) {",
                        "  if (typeof doc === \"string\") {",
                        "    return DOC_TYPE_STRING;",
                        "  }",
                        "",
                        "  if (Array.isArray(doc)) {",
                        "    return DOC_TYPE_ARRAY;",
                        "  }",
                        "",
                        "  if (!doc) {",
                        "    return;",
                        "  }",
                        "",
                        "  const { type } = doc;",
                        "",
                        "  if (VALID_OBJECT_DOC_TYPES.has(type)) {",
                        "    return type;",
                        "  }",
                        "}",
                        "",
                        "export default getDocType;"
                    ]
                },
                "traverse-doc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  DOC_TYPE_STRING,",
                        "  DOC_TYPE_ARRAY,",
                        "  DOC_TYPE_CURSOR,",
                        "  DOC_TYPE_INDENT,",
                        "  DOC_TYPE_ALIGN,",
                        "  DOC_TYPE_TRIM,",
                        "  DOC_TYPE_GROUP,",
                        "  DOC_TYPE_FILL,",
                        "  DOC_TYPE_IF_BREAK,",
                        "  DOC_TYPE_INDENT_IF_BREAK,",
                        "  DOC_TYPE_LINE_SUFFIX,",
                        "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                        "  DOC_TYPE_LINE,",
                        "  DOC_TYPE_LABEL,",
                        "  DOC_TYPE_BREAK_PARENT,",
                        "} from \"../constants.js\";",
                        "import InvalidDocError from \"../invalid-doc-error.js\";",
                        "import getDocType from \"./get-doc-type.js\";",
                        "",
                        "// Using a unique object to compare by reference.",
                        "const traverseDocOnExitStackMarker = {};",
                        "",
                        "function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {",
                        "  const docsStack = [doc];",
                        "",
                        "  while (docsStack.length > 0) {",
                        "    const doc = docsStack.pop();",
                        "",
                        "    if (doc === traverseDocOnExitStackMarker) {",
                        "      onExit(docsStack.pop());",
                        "      continue;",
                        "    }",
                        "",
                        "    if (onExit) {",
                        "      docsStack.push(doc, traverseDocOnExitStackMarker);",
                        "    }",
                        "",
                        "    const docType = getDocType(doc);",
                        "    if (!docType) {",
                        "      throw new InvalidDocError(doc);",
                        "    }",
                        "",
                        "    // Should Recurse",
                        "    if (onEnter?.(doc) === false) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // When there are multiple parts to process,",
                        "    // the parts need to be pushed onto the stack in reverse order,",
                        "    // so that they are processed in the original order",
                        "    // when the stack is popped.",
                        "",
                        "    switch (docType) {",
                        "      case DOC_TYPE_ARRAY:",
                        "      case DOC_TYPE_FILL: {",
                        "        const parts = docType === DOC_TYPE_ARRAY ? doc : doc.parts;",
                        "        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {",
                        "          docsStack.push(parts[i]);",
                        "        }",
                        "        break;",
                        "      }",
                        "",
                        "      case DOC_TYPE_IF_BREAK:",
                        "        docsStack.push(doc.flatContents, doc.breakContents);",
                        "        break;",
                        "",
                        "      case DOC_TYPE_GROUP:",
                        "        if (shouldTraverseConditionalGroups && doc.expandedStates) {",
                        "          for (let ic = doc.expandedStates.length, i = ic - 1; i >= 0; --i) {",
                        "            docsStack.push(doc.expandedStates[i]);",
                        "          }",
                        "        } else {",
                        "          docsStack.push(doc.contents);",
                        "        }",
                        "        break;",
                        "",
                        "      case DOC_TYPE_ALIGN:",
                        "      case DOC_TYPE_INDENT:",
                        "      case DOC_TYPE_INDENT_IF_BREAK:",
                        "      case DOC_TYPE_LABEL:",
                        "      case DOC_TYPE_LINE_SUFFIX:",
                        "        docsStack.push(doc.contents);",
                        "        break;",
                        "",
                        "      case DOC_TYPE_STRING:",
                        "      case DOC_TYPE_CURSOR:",
                        "      case DOC_TYPE_TRIM:",
                        "      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                        "      case DOC_TYPE_LINE:",
                        "      case DOC_TYPE_BREAK_PARENT:",
                        "        // No children",
                        "        break;",
                        "",
                        "      default:",
                        "        throw new InvalidDocError(doc);",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "export default traverseDoc;"
                    ]
                }
            }
        },
        "language-css": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isFrontMatter from \"../utils/front-matter/is-front-matter.js\";",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"raw\", // front-matter",
                    "  \"raws\",",
                    "  \"sourceIndex\",",
                    "  \"source\",",
                    "  \"before\",",
                    "  \"after\",",
                    "  \"trailingComma\",",
                    "  \"spaces\",",
                    "]);",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  if (isFrontMatter(ast) && ast.lang === \"yaml\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"css-comment\" &&",
                    "    parent.type === \"css-root\" &&",
                    "    parent.nodes.length > 0",
                    "  ) {",
                    "    // --insert-pragma",
                    "    // first non-front-matter comment",
                    "    if (",
                    "      parent.nodes[0] === ast ||",
                    "      (isFrontMatter(parent.nodes[0]) && parent.nodes[1] === ast)",
                    "    ) {",
                    "      /**",
                    "       * something",
                    "       *",
                    "       * @format",
                    "       */",
                    "      delete newObj.text;",
                    "",
                    "      // standalone pragma",
                    "      if (/^\\*\\s*@(?:format|prettier)\\s*$/.test(ast.text)) {",
                    "        return null;",
                    "      }",
                    "    }",
                    "",
                    "    // Last comment is not parsed, when omitting semicolon, #8675",
                    "    if (parent.type === \"css-root\" && parent.nodes.at(-1) === ast) {",
                    "      return null;",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"value-root\") {",
                    "    delete newObj.text;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"media-query\" ||",
                    "    ast.type === \"media-query-list\" ||",
                    "    ast.type === \"media-feature-expression\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"css-rule\") {",
                    "    delete newObj.params;",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-combinator\") {",
                    "    newObj.value = newObj.value.replaceAll(/\\s+/g, \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"media-feature\") {",
                    "    newObj.value = newObj.value.replaceAll(\" \", \"\");",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"value-word\" &&",
                    "      ((ast.isColor && ast.isHex) ||",
                    "        [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(",
                    "          newObj.value.toLowerCase()",
                    "        ))) ||",
                    "    ast.type === \"media-feature\" ||",
                    "    ast.type === \"selector-root-invalid\" ||",
                    "    ast.type === \"selector-pseudo\"",
                    "  ) {",
                    "    newObj.value = newObj.value.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-decl\") {",
                    "    newObj.prop = newObj.prop.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-atrule\" || ast.type === \"css-import\") {",
                    "    newObj.name = newObj.name.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"value-number\") {",
                    "    newObj.unit = newObj.unit.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"value-unknown\") {",
                    "    newObj.value = newObj.value.replaceAll(/;$/g, \"\");",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-feature\" ||",
                    "      ast.type === \"media-keyword\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"media-unknown\" ||",
                    "      ast.type === \"media-url\" ||",
                    "      ast.type === \"media-value\" ||",
                    "      ast.type === \"selector-attribute\" ||",
                    "      ast.type === \"selector-string\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"value-string\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = cleanCSSStrings(newObj.value);",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-attribute\") {",
                    "    newObj.attribute = newObj.attribute.trim();",
                    "",
                    "    if (newObj.namespace && typeof newObj.namespace === \"string\") {",
                    "      newObj.namespace = newObj.namespace.trim();",
                    "",
                    "      if (newObj.namespace.length === 0) {",
                    "        newObj.namespace = true;",
                    "      }",
                    "    }",
                    "",
                    "    if (newObj.value) {",
                    "      newObj.value = newObj.value.trim().replaceAll(/^[\"']|[\"']$/g, \"\");",
                    "      delete newObj.quoted;",
                    "    }",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-value\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"value-number\" ||",
                    "      ast.type === \"selector-root-invalid\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"selector-tag\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = newObj.value.replaceAll(",
                    "      /([\\d+.Ee-]+)([A-Za-z]*)/g,",
                    "      (match, numStr, unit) => {",
                    "        const num = Number(numStr);",
                    "        return Number.isNaN(num) ? match : num + unit.toLowerCase();",
                    "      }",
                    "    );",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-tag\") {",
                    "    const lowercasedValue = ast.value.toLowerCase();",
                    "",
                    "    if ([\"from\", \"to\"].includes(lowercasedValue)) {",
                    "      newObj.value = lowercasedValue;",
                    "    }",
                    "  }",
                    "",
                    "  // Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`",
                    "  if (ast.type === \"css-atrule\" && ast.name.toLowerCase() === \"supports\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // Workaround for SCSS nested properties",
                    "  if (ast.type === \"selector-unknown\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // Workaround for SCSS arbitrary arguments",
                    "  if (ast.type === \"value-comma_group\") {",
                    "    const index = ast.groups.findIndex(",
                    "      (node) => node.type === \"value-number\" && node.unit === \"...\"",
                    "    );",
                    "",
                    "    if (index !== -1) {",
                    "      newObj.groups[index].unit = \"\";",
                    "      newObj.groups.splice(index + 1, 0, {",
                    "        type: \"value-word\",",
                    "        value: \"...\",",
                    "        isColor: false,",
                    "        isHex: false,",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  // We parse `@var[ foo ]` and `@var[foo]` differently",
                    "  if (",
                    "    ast.type === \"value-comma_group\" &&",
                    "    ast.groups.some(",
                    "      (node) =>",
                    "        (node.type === \"value-atword\" && node.value.endsWith(\"[\")) ||",
                    "        (node.type === \"value-word\" && node.value.startsWith(\"]\"))",
                    "    )",
                    "  ) {",
                    "    return {",
                    "      type: \"value-atword\",",
                    "      value: ast.groups.map((node) => node.value).join(\"\"),",
                    "      group: {",
                    "        open: null,",
                    "        close: null,",
                    "        groups: [],",
                    "        type: \"value-paren_group\",",
                    "      },",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "function cleanCSSStrings(value) {",
                    "  return value.replaceAll(\"'\", '\"').replaceAll(/\\\\([^\\dA-Fa-f])/g, \"$1\");",
                    "}",
                    "",
                    "export default clean;"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { hardline } from \"../document/builders.js\";",
                    "import printFrontMatter from \"../utils/front-matter/print.js\";",
                    "",
                    "function embed(path) {",
                    "  const { node } = path;",
                    "",
                    "  if (node.type === \"front-matter\") {",
                    "    return async (textToDoc) => {",
                    "      const doc = await printFrontMatter(node, textToDoc);",
                    "      return doc ? [doc, hardline] : undefined;",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "// `front-matter` only available on `css-root`",
                    "embed.getVisitorKeys = (node) =>",
                    "  node.type === \"css-root\" ? [\"frontMatter\"] : [];",
                    "",
                    "export default embed;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-postcss.js\";",
                    "",
                    "export const printers = {",
                    "  postcss: printer,",
                    "};",
                    "export const parsers = createParsers(",
                    "  // TODO: switch these to just `postcss` and use `language` instead.",
                    "  [",
                    "    {",
                    "      importParsers: () => import(\"./parser-postcss.js\"),",
                    "      parserNames: [\"css\", \"less\", \"scss\"],",
                    "    },",
                    "  ]",
                    ");",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.CSS, (data) => ({",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"css\"],",
                    "    extensions: [",
                    "      ...data.extensions,",
                    "      // `WeiXin Style Sheets`(Weixin Mini Programs)",
                    "      // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                    "      \".wxss\",",
                    "    ],",
                    "  })),",
                    "  createLanguage(linguistLanguages.PostCSS, () => ({",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"postcss\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.Less, () => ({",
                    "    parsers: [\"less\"],",
                    "    vscodeLanguageIds: [\"less\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.SCSS, () => ({",
                    "    parsers: [\"scss\"],",
                    "    vscodeLanguageIds: [\"scss\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { skipEverythingButNewLine } from \"../utils/skip.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import lineColumnToIndex from \"../utils/line-column-to-index.js\";",
                    "",
                    "function calculateLocStart(node, text) {",
                    "  // `postcss>=8`",
                    "  if (typeof node.source?.start?.offset === \"number\") {",
                    "    return node.source.start.offset;",
                    "  }",
                    "",
                    "  // value-* nodes have this",
                    "  if (typeof node.sourceIndex === \"number\") {",
                    "    return node.sourceIndex;",
                    "  }",
                    "",
                    "  if (node.source?.start) {",
                    "    return lineColumnToIndex(node.source.start, text);",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  throw Object.assign(new Error(\"Can not locate node.\"), { node });",
                    "}",
                    "",
                    "function calculateLocEnd(node, text) {",
                    "  if (node.type === \"css-comment\" && node.inline) {",
                    "    return skipEverythingButNewLine(text, node.source.startOffset);",
                    "  }",
                    "",
                    "  // `postcss>=8`",
                    "  if (typeof node.source?.end?.offset === \"number\") {",
                    "    // https://github.com/postcss/postcss/issues/1450",
                    "    return node.source.end.offset + 1;",
                    "  }",
                    "",
                    "  if (node.source) {",
                    "    if (node.source.end) {",
                    "      return lineColumnToIndex(node.source.end, text);",
                    "    }",
                    "",
                    "    if (isNonEmptyArray(node.nodes)) {",
                    "      return calculateLocEnd(node.nodes.at(-1), text);",
                    "    }",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function calculateLoc(node, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text);",
                    "    node.source.endOffset = calculateLocEnd(node, text);",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (child.type === \"value-root\" || child.type === \"value-unknown\") {",
                    "      calculateValueNodeLoc(",
                    "        child,",
                    "        getValueRootOffset(node),",
                    "        child.text || child.value",
                    "      );",
                    "    } else {",
                    "      calculateLoc(child, text);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function calculateValueNodeLoc(node, rootOffset, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text) + rootOffset;",
                    "    node.source.endOffset = calculateLocEnd(node, text) + rootOffset;",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    calculateValueNodeLoc(child, rootOffset, text);",
                    "  }",
                    "}",
                    "",
                    "function getValueRootOffset(node) {",
                    "  let result = node.source.startOffset;",
                    "  if (typeof node.prop === \"string\") {",
                    "    result += node.prop.length;",
                    "  }",
                    "",
                    "  if (node.type === \"css-atrule\" && typeof node.name === \"string\") {",
                    "    result +=",
                    "      1 + node.name.length + node.raws.afterName.match(/^\\s*:?\\s*/)[0].length;",
                    "  }",
                    "",
                    "  if (node.type !== \"css-atrule\" && typeof node.raws?.between === \"string\") {",
                    "    result += node.raws.between.length;",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "/**",
                    " * Workaround for a bug: quotes and asterisks in inline comments corrupt loc data of subsequent nodes.",
                    " * This function replaces the quotes and asterisks with spaces. Later, when the comments are printed,",
                    " * their content is extracted from the original text.",
                    " * - https://github.com/prettier/prettier/issues/7780",
                    " * - https://github.com/shellscape/postcss-less/issues/145",
                    " * - https://github.com/prettier/prettier/issues/8130",
                    " * @param text {string}",
                    " */",
                    "function replaceQuotesInInlineComments(text) {",
                    "  /** @typedef { 'initial' | 'single-quotes' | 'double-quotes' | 'url' | 'comment-block' | 'comment-inline' } State */",
                    "  /** @type {State} */",
                    "  let state = \"initial\";",
                    "  /** @type {State} */",
                    "  let stateToReturnFromQuotes = \"initial\";",
                    "  let inlineCommentStartIndex;",
                    "  let inlineCommentContainsQuotes = false;",
                    "  const inlineCommentsToReplace = [];",
                    "",
                    "  for (let i = 0; i < text.length; i++) {",
                    "    const c = text[i];",
                    "",
                    "    switch (state) {",
                    "      case \"initial\":",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          (c === \"u\" || c === \"U\") &&",
                    "          text.slice(i, i + 4).toLowerCase() === \"url(\"",
                    "        ) {",
                    "          state = \"url\";",
                    "          i += 3;",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"*\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-block\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"/\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-inline\";",
                    "          inlineCommentStartIndex = i - 1;",
                    "          continue;",
                    "        }",
                    "",
                    "        continue;",
                    "",
                    "      case \"single-quotes\":",
                    "        if (c === \"'\" && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"double-quotes\":",
                    "        if (c === '\"' && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"url\":",
                    "        if (c === \")\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-block\":",
                    "        if (c === \"/\" && text[i - 1] === \"*\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-inline\":",
                    "        if (c === '\"' || c === \"'\" || c === \"*\") {",
                    "          inlineCommentContainsQuotes = true;",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          if (inlineCommentContainsQuotes) {",
                    "            inlineCommentsToReplace.push([inlineCommentStartIndex, i]);",
                    "          }",
                    "          state = \"initial\";",
                    "          inlineCommentContainsQuotes = false;",
                    "        }",
                    "        continue;",
                    "    }",
                    "  }",
                    "",
                    "  for (const [start, end] of inlineCommentsToReplace) {",
                    "    text =",
                    "      text.slice(0, start) +",
                    "      text.slice(start, end).replaceAll(/[\"'*]/g, \" \") +",
                    "      text.slice(end);",
                    "  }",
                    "",
                    "  return text;",
                    "}",
                    "",
                    "function locStart(node) {",
                    "  return node.source?.startOffset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.source?.endOffset;",
                    "}",
                    "",
                    "export { locStart, locEnd, calculateLoc, replaceQuotesInInlineComments };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import postcssParse from \"postcss/lib/parse\";",
                    "import postcssLess from \"postcss-less\";",
                    "import postcssScssParse from \"postcss-scss/lib/scss-parse\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import parseFrontMatter from \"../utils/front-matter/parse.js\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import {",
                    "  locStart,",
                    "  locEnd,",
                    "  calculateLoc,",
                    "  replaceQuotesInInlineComments,",
                    "} from \"./loc.js\";",
                    "import isSCSSNestedPropertyNode from \"./utils/is-scss-nested-property-node.js\";",
                    "import isModuleRuleName from \"./utils/is-module-rule-name.js\";",
                    "import parseValue from \"./parse/parse-value.js\";",
                    "import parseSelector from \"./parse/parse-selector.js\";",
                    "import parseMediaQuery from \"./parse/parse-media-query.js\";",
                    "import { addTypePrefix } from \"./parse/utils.js\";",
                    "",
                    "const DEFAULT_SCSS_DIRECTIVE = /(\\s*)(!default).*$/;",
                    "const GLOBAL_SCSS_DIRECTIVE = /(\\s*)(!global).*$/;",
                    "",
                    "function parseNestedCSS(node, options) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "",
                    "    for (const key in node) {",
                    "      parseNestedCSS(node[key], options);",
                    "    }",
                    "",
                    "    if (!node.type) {",
                    "      return node;",
                    "    }",
                    "",
                    "    /* c8 ignore next */",
                    "    node.raws ??= {};",
                    "",
                    "    // Custom properties looks like declarations",
                    "    if (",
                    "      node.type === \"css-decl\" &&",
                    "      typeof node.prop === \"string\" &&",
                    "      node.prop.startsWith(\"--\") &&",
                    "      typeof node.value === \"string\" &&",
                    "      node.value.startsWith(\"{\")",
                    "    ) {",
                    "      let rules;",
                    "      if (node.value.trimEnd().endsWith(\"}\")) {",
                    "        const textBefore = options.originalText.slice(",
                    "          0,",
                    "          node.source.start.offset",
                    "        );",
                    "        const nodeText =",
                    "          \"a\".repeat(node.prop.length) +",
                    "          options.originalText.slice(",
                    "            node.source.start.offset + node.prop.length,",
                    "            node.source.end.offset + 1",
                    "          );",
                    "        const fakeContent = textBefore.replaceAll(/[^\\n]/g, \" \") + nodeText;",
                    "        let parse;",
                    "        if (options.parser === \"scss\") {",
                    "          parse = parseScss;",
                    "        } else if (options.parser === \"less\") {",
                    "          parse = parseLess;",
                    "        } else {",
                    "          parse = parseCss;",
                    "        }",
                    "        let ast;",
                    "        try {",
                    "          ast = parse(fakeContent, { ...options });",
                    "        } catch {",
                    "          // noop",
                    "        }",
                    "        if (ast?.nodes?.length === 1 && ast.nodes[0].type === \"css-rule\") {",
                    "          rules = ast.nodes[0].nodes;",
                    "        }",
                    "      }",
                    "      if (rules) {",
                    "        node.value = {",
                    "          type: \"css-rule\",",
                    "          nodes: rules,",
                    "        };",
                    "      } else {",
                    "        node.value = {",
                    "          type: \"value-unknown\",",
                    "          value: node.raws.value.raw,",
                    "        };",
                    "      }",
                    "      return node;",
                    "    }",
                    "",
                    "    let selector = \"\";",
                    "",
                    "    if (typeof node.selector === \"string\") {",
                    "      selector = node.raws.selector",
                    "        ? node.raws.selector.scss ?? node.raws.selector.raw",
                    "        : node.selector;",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        selector += node.raws.between;",
                    "      }",
                    "",
                    "      node.raws.selector = selector;",
                    "    }",
                    "",
                    "    let value = \"\";",
                    "",
                    "    if (typeof node.value === \"string\") {",
                    "      value = node.raws.value",
                    "        ? node.raws.value.scss ?? node.raws.value.raw",
                    "        : node.value;",
                    "",
                    "      value = value.trim();",
                    "",
                    "      node.raws.value = value;",
                    "    }",
                    "",
                    "    let params = \"\";",
                    "",
                    "    if (typeof node.params === \"string\") {",
                    "      params = node.raws.params",
                    "        ? node.raws.params.scss ?? node.raws.params.raw",
                    "        : node.params;",
                    "",
                    "      if (node.raws.afterName && node.raws.afterName.trim().length > 0) {",
                    "        params = node.raws.afterName + params;",
                    "      }",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        params = params + node.raws.between;",
                    "      }",
                    "",
                    "      params = params.trim();",
                    "",
                    "      node.raws.params = params;",
                    "    }",
                    "",
                    "    // Ignore LESS mixin declaration",
                    "    if (selector.trim().length > 0) {",
                    "      // TODO: confirm this code is dead",
                    "      /* c8 ignore next 3 */",
                    "      if (selector.startsWith(\"@\") && selector.endsWith(\":\")) {",
                    "        return node;",
                    "      }",
                    "",
                    "      // TODO: confirm this code is dead",
                    "      /* c8 ignore next 6 */",
                    "      // Ignore LESS mixins",
                    "      if (node.mixin) {",
                    "        node.selector = parseValue(selector, options);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      // Check on SCSS nested property",
                    "      if (isSCSSNestedPropertyNode(node, options)) {",
                    "        node.isSCSSNesterProperty = true;",
                    "      }",
                    "",
                    "      node.selector = parseSelector(selector);",
                    "",
                    "      return node;",
                    "    }",
                    "",
                    "    if (value.length > 0) {",
                    "      const defaultSCSSDirectiveIndex = value.match(DEFAULT_SCSS_DIRECTIVE);",
                    "",
                    "      if (defaultSCSSDirectiveIndex) {",
                    "        value = value.slice(0, defaultSCSSDirectiveIndex.index);",
                    "        node.scssDefault = true;",
                    "",
                    "        if (defaultSCSSDirectiveIndex[0].trim() !== \"!default\") {",
                    "          node.raws.scssDefault = defaultSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      const globalSCSSDirectiveIndex = value.match(GLOBAL_SCSS_DIRECTIVE);",
                    "",
                    "      if (globalSCSSDirectiveIndex) {",
                    "        value = value.slice(0, globalSCSSDirectiveIndex.index);",
                    "        node.scssGlobal = true;",
                    "",
                    "        if (globalSCSSDirectiveIndex[0].trim() !== \"!global\") {",
                    "          node.raws.scssGlobal = globalSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      if (value.startsWith(\"progid:\")) {",
                    "        return {",
                    "          type: \"value-unknown\",",
                    "          value,",
                    "        };",
                    "      }",
                    "",
                    "      node.value = parseValue(value, options);",
                    "    }",
                    "",
                    "    if (",
                    "      options.parser === \"less\" &&",
                    "      node.type === \"css-decl\" &&",
                    "      value.startsWith(\"extend(\")",
                    "    ) {",
                    "      // extend is missing",
                    "      node.extend ||= node.raws.between === \":\";",
                    "",
                    "      // `:extend()` is parsed as value",
                    "      if (node.extend && !node.selector) {",
                    "        delete node.value;",
                    "        node.selector = parseSelector(value.slice(\"extend(\".length, -1));",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\") {",
                    "      if (options.parser === \"less\") {",
                    "        // mixin",
                    "        if (node.mixin) {",
                    "          const source =",
                    "            node.raws.identifier +",
                    "            node.name +",
                    "            node.raws.afterName +",
                    "            node.raws.params;",
                    "          node.selector = parseSelector(source);",
                    "          delete node.params;",
                    "          return node;",
                    "        }",
                    "",
                    "        // function",
                    "        if (node.function) {",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      // only css support custom-selector",
                    "      if (options.parser === \"css\" && node.name === \"custom-selector\") {",
                    "        const customSelector = node.params.match(/:--\\S+\\s+/)[0].trim();",
                    "        node.customSelector = customSelector;",
                    "        node.selector = parseSelector(",
                    "          node.params.slice(customSelector.length).trim()",
                    "        );",
                    "        delete node.params;",
                    "        return node;",
                    "      }",
                    "",
                    "      if (options.parser === \"less\") {",
                    "        // postcss-less doesn't recognize variables in some cases.",
                    "        // `@color: blue;` is recognized fine, but the cases below aren't:",
                    "",
                    "        // `@color:blue;`",
                    "        if (node.name.includes(\":\") && !node.params) {",
                    "          node.variable = true;",
                    "          const parts = node.name.split(\":\");",
                    "          node.name = parts[0];",
                    "          node.value = parseValue(parts.slice(1).join(\":\"), options);",
                    "        }",
                    "",
                    "        // `@color :blue;`",
                    "        if (",
                    "          ![\"page\", \"nest\", \"keyframes\"].includes(node.name) &&",
                    "          node.params?.[0] === \":\"",
                    "        ) {",
                    "          node.variable = true;",
                    "          const text = node.params.slice(1);",
                    "          if (text) {",
                    "            node.value = parseValue(text, options);",
                    "          }",
                    "          node.raws.afterName += \":\";",
                    "        }",
                    "",
                    "        // Less variable",
                    "        if (node.variable) {",
                    "          delete node.params;",
                    "",
                    "          if (!node.value) {",
                    "            delete node.value;",
                    "          }",
                    "",
                    "          return node;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\" && params.length > 0) {",
                    "      const { name } = node;",
                    "      const lowercasedName = node.name.toLowerCase();",
                    "",
                    "      if (name === \"warn\" || name === \"error\") {",
                    "        node.params = {",
                    "          type: \"media-unknown\",",
                    "          value: params,",
                    "        };",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"extend\" || name === \"nest\") {",
                    "        node.selector = parseSelector(params);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"at-root\") {",
                    "        if (/^\\(\\s*(?:without|with)\\s*:.+\\)$/s.test(params)) {",
                    "          node.params = parseValue(params, options);",
                    "        } else {",
                    "          node.selector = parseSelector(params);",
                    "          delete node.params;",
                    "        }",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (isModuleRuleName(lowercasedName)) {",
                    "        node.import = true;",
                    "        delete node.filename;",
                    "        node.params = parseValue(params, options);",
                    "        return node;",
                    "      }",
                    "",
                    "      if (",
                    "        [",
                    "          \"namespace\",",
                    "          \"supports\",",
                    "          \"if\",",
                    "          \"else\",",
                    "          \"for\",",
                    "          \"each\",",
                    "          \"while\",",
                    "          \"debug\",",
                    "          \"mixin\",",
                    "          \"include\",",
                    "          \"function\",",
                    "          \"return\",",
                    "          \"define-mixin\",",
                    "          \"add-mixin\",",
                    "        ].includes(name)",
                    "      ) {",
                    "        // Remove unnecessary spaces in SCSS variable arguments",
                    "        // Move spaces after the `...`, so we can keep the range correct",
                    "        params = params.replace(/(\\$\\S+?)(\\s+)?\\.{3}/, \"$1...$2\");",
                    "        // Remove unnecessary spaces before SCSS control, mixin and function directives",
                    "        // Move spaces after the `(`, so we can keep the range correct",
                    "        params = params.replace(/^(?!if)(\\S+)(\\s+)\\(/, \"$1($2\");",
                    "",
                    "        node.value = parseValue(params, options);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if ([\"media\", \"custom-media\"].includes(lowercasedName)) {",
                    "        if (params.includes(\"#{\")) {",
                    "          // Workaround for media at rule with scss interpolation",
                    "          return {",
                    "            type: \"media-unknown\",",
                    "            value: params,",
                    "          };",
                    "        }",
                    "",
                    "        node.params = parseMediaQuery(params);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      node.params = params;",
                    "",
                    "      return node;",
                    "    }",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function parseWithParser(parse, text, options) {",
                    "  const parsed = parseFrontMatter(text);",
                    "  const { frontMatter } = parsed;",
                    "  text = parsed.content;",
                    "",
                    "  let result;",
                    "",
                    "  try {",
                    "    result = parse(text, {",
                    "      // Prevent file access https://github.com/postcss/postcss/blob/4f4e2932fc97e2c117e1a4b15f0272ed551ed59d/lib/previous-map.js#L18",
                    "      map: false,",
                    "    });",
                    "  } catch (error) {",
                    "    const { name, reason, line, column } = error;",
                    "    /* c8 ignore 3 */",
                    "    if (typeof line !== \"number\") {",
                    "      throw error;",
                    "    }",
                    "",
                    "    throw createError(`${name}: ${reason}`, {",
                    "      loc: { start: { line, column } },",
                    "      cause: error,",
                    "    });",
                    "  }",
                    "",
                    "  options.originalText = text;",
                    "  result = parseNestedCSS(addTypePrefix(result, \"css-\"), options);",
                    "",
                    "  calculateLoc(result, text);",
                    "",
                    "  if (frontMatter) {",
                    "    frontMatter.source = {",
                    "      startOffset: 0,",
                    "      endOffset: frontMatter.raw.length,",
                    "    };",
                    "    result.frontMatter = frontMatter;",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function parseCss(text, options = {}) {",
                    "  return parseWithParser(postcssParse.default, text, options);",
                    "}",
                    "",
                    "function parseLess(text, options = {}) {",
                    "  return parseWithParser(",
                    "    // Workaround for https://github.com/shellscape/postcss-less/issues/145",
                    "    // See comments for `replaceQuotesInInlineComments` in `loc.js`.",
                    "    (text) => postcssLess.parse(replaceQuotesInInlineComments(text)),",
                    "    text,",
                    "    options",
                    "  );",
                    "}",
                    "",
                    "function parseScss(text, options = {}) {",
                    "  return parseWithParser(postcssScssParse, text, options);",
                    "}",
                    "",
                    "const postCssParser = {",
                    "  astFormat: \"postcss\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "export const css = { ...postCssParser, parse: parseCss };",
                    "export const less = { ...postCssParser, parse: parseLess };",
                    "export const scss = { ...postCssParser, parse: parseScss };"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  hasPragma as jsHasPragma,",
                    "  insertPragma as jsInsertPragma,",
                    "} from \"../language-js/pragma.js\";",
                    "import parseFrontMatter from \"../utils/front-matter/parse.js\";",
                    "",
                    "function hasPragma(text) {",
                    "  return jsHasPragma(parseFrontMatter(text).content);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  const { frontMatter, content } = parseFrontMatter(text);",
                    "  return (",
                    "    (frontMatter ? frontMatter.raw + \"\\n\\n\" : \"\") + jsInsertPragma(content)",
                    "  );",
                    "}",
                    "",
                    "export { hasPragma, insertPragma };"
                ]
            },
            "printer-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import printString from \"../utils/print-string.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import {",
                    "  join,",
                    "  line,",
                    "  hardline,",
                    "  softline,",
                    "  group,",
                    "  indent,",
                    "  dedent,",
                    "  ifBreak,",
                    "  breakParent,",
                    "} from \"../document/builders.js\";",
                    "import { removeLines } from \"../document/utils.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import clean from \"./clean.js\";",
                    "import embed from \"./embed.js\";",
                    "import { insertPragma } from \"./pragma.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "import {",
                    "  maybeToLowerCase,",
                    "  insideValueFunctionNode,",
                    "  insideICSSRuleNode,",
                    "  insideAtRuleNode,",
                    "  isKeyframeAtRuleKeywords,",
                    "  isWideKeywords,",
                    "  isLastNode,",
                    "  isSCSSControlDirectiveNode,",
                    "  isDetachedRulesetDeclarationNode,",
                    "  hasComposesNode,",
                    "  hasParensAroundNode,",
                    "  isDetachedRulesetCallNode,",
                    "  isTemplatePlaceholderNode,",
                    "  isTemplatePropNode,",
                    "  isMediaAndSupportsKeywords,",
                    "  lastLineHasInlineComment,",
                    "} from \"./utils/index.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import {",
                    "  adjustStrings,",
                    "  adjustNumbers,",
                    "  quoteAttributeValue,",
                    "  printUnit,",
                    "  printCssNumber,",
                    "} from \"./print/misc.js\";",
                    "import printCommaSeparatedValueGroup from \"./print/comma-separated-value-group.js\";",
                    "import {",
                    "  printParenthesizedValueGroup,",
                    "  shouldBreakList,",
                    "} from \"./print/parenthesized-value-group.js\";",
                    "import printSequence from \"./print/sequence.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return [node.raw, hardline];",
                    "    case \"css-root\": {",
                    "      const nodes = printSequence(path, options, print);",
                    "      let after = node.raws.after.trim();",
                    "      if (after.startsWith(\";\")) {",
                    "        after = after.slice(1).trim();",
                    "      }",
                    "",
                    "      return [",
                    "        node.frontMatter ? [print(\"frontMatter\"), hardline] : \"\",",
                    "        nodes,",
                    "        after ? ` ${after}` : \"\",",
                    "        node.nodes.length > 0 ? hardline : \"\",",
                    "      ];",
                    "    }",
                    "    case \"css-comment\": {",
                    "      const isInlineComment = node.inline || node.raws.inline;",
                    "",
                    "      const text = options.originalText.slice(locStart(node), locEnd(node));",
                    "",
                    "      return isInlineComment ? text.trimEnd() : text;",
                    "    }",
                    "    case \"css-rule\":",
                    "      return [",
                    "        print(\"selector\"),",
                    "        node.important ? \" !important\" : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              node.selector?.type === \"selector-unknown\" &&",
                    "              lastLineHasInlineComment(node.selector.value)",
                    "                ? line",
                    "                : node.selector",
                    "                ? \" \"",
                    "                : \"\",",
                    "              \"{\",",
                    "              node.nodes.length > 0",
                    "                ? indent([hardline, printSequence(path, options, print)])",
                    "                : \"\",",
                    "              hardline,",
                    "              \"}\",",
                    "              isDetachedRulesetDeclarationNode(node) ? \";\" : \"\",",
                    "            ]",
                    "          : \";\",",
                    "      ];",
                    "",
                    "    case \"css-decl\": {",
                    "      const parentNode = path.parent;",
                    "",
                    "      const { between: rawBetween } = node.raws;",
                    "      const trimmedBetween = rawBetween.trim();",
                    "      const isColon = trimmedBetween === \":\";",
                    "      const isValueAllSpace =",
                    "        typeof node.value === \"string\" && /^ *$/.test(node.value);",
                    "      let value = typeof node.value === \"string\" ? node.value : print(\"value\");",
                    "",
                    "      value = hasComposesNode(node) ? removeLines(value) : value;",
                    "",
                    "      if (",
                    "        !isColon &&",
                    "        lastLineHasInlineComment(trimmedBetween) &&",
                    "        !(",
                    "          node.value?.group?.group &&",
                    "          path.call(() => shouldBreakList(path), \"value\", \"group\", \"group\")",
                    "        )",
                    "      ) {",
                    "        value = indent([hardline, dedent(value)]);",
                    "      }",
                    "",
                    "      return [",
                    "        node.raws.before.replaceAll(/[\\s;]/g, \"\"),",
                    "        // Less variable",
                    "        (parentNode.type === \"css-atrule\" && parentNode.variable) ||",
                    "        insideICSSRuleNode(path)",
                    "          ? node.prop",
                    "          : maybeToLowerCase(node.prop),",
                    "        trimmedBetween.startsWith(\"//\") ? \" \" : \"\",",
                    "        trimmedBetween,",
                    "        node.extend || isValueAllSpace ? \"\" : \" \",",
                    "        options.parser === \"less\" && node.extend && node.selector",
                    "          ? [\"extend(\", print(\"selector\"), \")\"]",
                    "          : \"\",",
                    "        value,",
                    "        node.raws.important",
                    "          ? node.raws.important.replace(/\\s*!\\s*important/i, \" !important\")",
                    "          : node.important",
                    "          ? \" !important\"",
                    "          : \"\",",
                    "        node.raws.scssDefault",
                    "          ? node.raws.scssDefault.replace(/\\s*!default/i, \" !default\")",
                    "          : node.scssDefault",
                    "          ? \" !default\"",
                    "          : \"\",",
                    "        node.raws.scssGlobal",
                    "          ? node.raws.scssGlobal.replace(/\\s*!global/i, \" !global\")",
                    "          : node.scssGlobal",
                    "          ? \" !global\"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              \" {\",",
                    "              indent([softline, printSequence(path, options, print)]),",
                    "              softline,",
                    "              \"}\",",
                    "            ]",
                    "          : isTemplatePropNode(node) &&",
                    "            !parentNode.raws.semicolon &&",
                    "            options.originalText[locEnd(node) - 1] !== \";\"",
                    "          ? \"\"",
                    "          : options.__isHTMLStyleAttribute && isLastNode(path, node)",
                    "          ? ifBreak(\";\")",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    case \"css-atrule\": {",
                    "      const parentNode = path.parent;",
                    "      const isTemplatePlaceholderNodeWithoutSemiColon =",
                    "        isTemplatePlaceholderNode(node) &&",
                    "        !parentNode.raws.semicolon &&",
                    "        options.originalText[locEnd(node) - 1] !== \";\";",
                    "",
                    "      if (options.parser === \"less\") {",
                    "        if (node.mixin) {",
                    "          return [",
                    "            print(\"selector\"),",
                    "            node.important ? \" !important\" : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "",
                    "        if (node.function) {",
                    "          return [",
                    "            node.name,",
                    "            typeof node.params === \"string\" ? node.params : print(\"params\"),",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "",
                    "        if (node.variable) {",
                    "          return [",
                    "            \"@\",",
                    "            node.name,",
                    "            \": \",",
                    "            node.value ? print(\"value\") : \"\",",
                    "            node.raws.between.trim() ? node.raws.between.trim() + \" \" : \"\",",
                    "            node.nodes",
                    "              ? [",
                    "                  \"{\",",
                    "                  indent([",
                    "                    node.nodes.length > 0 ? softline : \"\",",
                    "                    printSequence(path, options, print),",
                    "                  ]),",
                    "                  softline,",
                    "                  \"}\",",
                    "                ]",
                    "              : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "      }",
                    "      const isImportUnknownValueEndsWithSemiColon =",
                    "        node.name === \"import\" &&",
                    "        node.params?.type === \"value-unknown\" &&",
                    "        node.params.value.endsWith(\";\");",
                    "",
                    "      return [",
                    "        \"@\",",
                    "        // If a Less file ends up being parsed with the SCSS parser, Less",
                    "        // variable declarations will be parsed as at-rules with names ending",
                    "        // with a colon, so keep the original case then.",
                    "        isDetachedRulesetCallNode(node) || node.name.endsWith(\":\")",
                    "          ? node.name",
                    "          : maybeToLowerCase(node.name),",
                    "        node.params",
                    "          ? [",
                    "              isDetachedRulesetCallNode(node)",
                    "                ? \"\"",
                    "                : isTemplatePlaceholderNode(node)",
                    "                ? node.raws.afterName === \"\"",
                    "                  ? \"\"",
                    "                  : node.name.endsWith(\":\")",
                    "                  ? \" \"",
                    "                  : /^\\s*\\n\\s*\\n/.test(node.raws.afterName)",
                    "                  ? [hardline, hardline]",
                    "                  : /^\\s*\\n/.test(node.raws.afterName)",
                    "                  ? hardline",
                    "                  : \" \"",
                    "                : \" \",",
                    "              typeof node.params === \"string\" ? node.params : print(\"params\"),",
                    "            ]",
                    "          : \"\",",
                    "        node.selector ? indent([\" \", print(\"selector\")]) : \"\",",
                    "        node.value",
                    "          ? group([",
                    "              \" \",",
                    "              print(\"value\"),",
                    "              isSCSSControlDirectiveNode(node, options)",
                    "                ? hasParensAroundNode(node)",
                    "                  ? \" \"",
                    "                  : line",
                    "                : \"\",",
                    "            ])",
                    "          : node.name === \"else\"",
                    "          ? \" \"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              isSCSSControlDirectiveNode(node, options)",
                    "                ? \"\"",
                    "                : (node.selector &&",
                    "                    !node.selector.nodes &&",
                    "                    typeof node.selector.value === \"string\" &&",
                    "                    lastLineHasInlineComment(node.selector.value)) ||",
                    "                  (!node.selector &&",
                    "                    typeof node.params === \"string\" &&",
                    "                    lastLineHasInlineComment(node.params))",
                    "                ? line",
                    "                : \" \",",
                    "              \"{\",",
                    "              indent([",
                    "                node.nodes.length > 0 ? softline : \"\",",
                    "                printSequence(path, options, print),",
                    "              ]),",
                    "              softline,",
                    "              \"}\",",
                    "            ]",
                    "          : isTemplatePlaceholderNodeWithoutSemiColon ||",
                    "            isImportUnknownValueEndsWithSemiColon",
                    "          ? \"\"",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    // postcss-media-query-parser",
                    "    case \"media-query-list\": {",
                    "      const parts = [];",
                    "      path.each(({ node }) => {",
                    "        if (node.type === \"media-query\" && node.value === \"\") {",
                    "          return;",
                    "        }",
                    "        parts.push(print());",
                    "      }, \"nodes\");",
                    "",
                    "      return group(indent(join(line, parts)));",
                    "    }",
                    "    case \"media-query\":",
                    "      return [",
                    "        join(\" \", path.map(print, \"nodes\")),",
                    "        isLastNode(path, node) ? \"\" : \",\",",
                    "      ];",
                    "",
                    "    case \"media-type\":",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "",
                    "    case \"media-feature-expression\":",
                    "      if (!node.nodes) {",
                    "        return node.value;",
                    "      }",
                    "      return [\"(\", ...path.map(print, \"nodes\"), \")\"];",
                    "",
                    "    case \"media-feature\":",
                    "      return maybeToLowerCase(",
                    "        adjustStrings(node.value.replaceAll(/ +/g, \" \"), options)",
                    "      );",
                    "",
                    "    case \"media-colon\":",
                    "      return [node.value, \" \"];",
                    "",
                    "    case \"media-value\":",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "",
                    "    case \"media-keyword\":",
                    "      return adjustStrings(node.value, options);",
                    "",
                    "    case \"media-url\":",
                    "      return adjustStrings(",
                    "        node.value.replaceAll(/^url\\(\\s+/gi, \"url(\").replaceAll(/\\s+\\)$/g, \")\"),",
                    "        options",
                    "      );",
                    "",
                    "    case \"media-unknown\":",
                    "      return node.value;",
                    "",
                    "    // postcss-selector-parser",
                    "    case \"selector-root\":",
                    "      return group([",
                    "        insideAtRuleNode(path, \"custom-selector\")",
                    "          ? [",
                    "              path.findAncestor((node) => node.type === \"css-atrule\")",
                    "                .customSelector,",
                    "              line,",
                    "            ]",
                    "          : \"\",",
                    "        join(",
                    "          [",
                    "            \",\",",
                    "            insideAtRuleNode(path, [\"extend\", \"custom-selector\", \"nest\"])",
                    "              ? line",
                    "              : hardline,",
                    "          ],",
                    "          path.map(print, \"nodes\")",
                    "        ),",
                    "      ]);",
                    "",
                    "    case \"selector-selector\":",
                    "      return group(indent(path.map(print, \"nodes\")));",
                    "",
                    "    case \"selector-comment\":",
                    "      return node.value;",
                    "",
                    "    case \"selector-string\":",
                    "      return adjustStrings(node.value, options);",
                    "",
                    "    case \"selector-tag\":",
                    "      return [",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        path.previous?.type === \"selector-nesting\"",
                    "          ? node.value",
                    "          : adjustNumbers(",
                    "              isKeyframeAtRuleKeywords(path, node.value)",
                    "                ? node.value.toLowerCase()",
                    "                : node.value",
                    "            ),",
                    "      ];",
                    "",
                    "    case \"selector-id\":",
                    "      return [\"#\", node.value];",
                    "",
                    "    case \"selector-class\":",
                    "      return [\".\", adjustNumbers(adjustStrings(node.value, options))];",
                    "",
                    "    case \"selector-attribute\":",
                    "      return [",
                    "        \"[\",",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        node.attribute.trim(),",
                    "        node.operator ?? \"\",",
                    "        node.value",
                    "          ? quoteAttributeValue(",
                    "              adjustStrings(node.value.trim(), options),",
                    "              options",
                    "            )",
                    "          : \"\",",
                    "        node.insensitive ? \" i\" : \"\",",
                    "        \"]\",",
                    "      ];",
                    "",
                    "    case \"selector-combinator\": {",
                    "      if (",
                    "        node.value === \"+\" ||",
                    "        node.value === \">\" ||",
                    "        node.value === \"~\" ||",
                    "        node.value === \">>>\"",
                    "      ) {",
                    "        const parentNode = path.parent;",
                    "        const leading =",
                    "          parentNode.type === \"selector-selector\" &&",
                    "          parentNode.nodes[0] === node",
                    "            ? \"\"",
                    "            : line;",
                    "",
                    "        return [leading, node.value, isLastNode(path, node) ? \"\" : \" \"];",
                    "      }",
                    "",
                    "      const leading = node.value.trim().startsWith(\"(\") ? line : \"\";",
                    "      const value =",
                    "        adjustNumbers(adjustStrings(node.value.trim(), options)) || line;",
                    "",
                    "      return [leading, value];",
                    "    }",
                    "    case \"selector-universal\":",
                    "      return [",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        node.value,",
                    "      ];",
                    "",
                    "    case \"selector-pseudo\":",
                    "      return [",
                    "        maybeToLowerCase(node.value),",
                    "        isNonEmptyArray(node.nodes)",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([softline, join([\",\", line], path.map(print, \"nodes\"))]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "      ];",
                    "",
                    "    case \"selector-nesting\":",
                    "      return node.value;",
                    "",
                    "    case \"selector-unknown\": {",
                    "      const ruleAncestorNode = path.findAncestor(",
                    "        (node) => node.type === \"css-rule\"",
                    "      );",
                    "",
                    "      // Nested SCSS property",
                    "      if (ruleAncestorNode?.isSCSSNesterProperty) {",
                    "        return adjustNumbers(",
                    "          adjustStrings(maybeToLowerCase(node.value), options)",
                    "        );",
                    "      }",
                    "",
                    "      // originalText has to be used for Less, see replaceQuotesInInlineComments in loc.js",
                    "      const parentNode = path.parent;",
                    "      if (parentNode.raws?.selector) {",
                    "        const start = locStart(parentNode);",
                    "        const end = start + parentNode.raws.selector.length;",
                    "        return options.originalText.slice(start, end).trim();",
                    "      }",
                    "",
                    "      // Same reason above",
                    "      const grandParent = path.grandparent;",
                    "      if (",
                    "        parentNode.type === \"value-paren_group\" &&",
                    "        grandParent?.type === \"value-func\" &&",
                    "        grandParent.value === \"selector\"",
                    "      ) {",
                    "        const start = locEnd(parentNode.open) + 1;",
                    "        const end = locStart(parentNode.close);",
                    "        const selector = options.originalText.slice(start, end).trim();",
                    "",
                    "        return lastLineHasInlineComment(selector)",
                    "          ? [breakParent, selector]",
                    "          : selector;",
                    "      }",
                    "",
                    "      return node.value;",
                    "    }",
                    "    // postcss-values-parser",
                    "    case \"value-value\":",
                    "    case \"value-root\":",
                    "      return print(\"group\");",
                    "",
                    "    case \"value-comment\":",
                    "      return options.originalText.slice(locStart(node), locEnd(node));",
                    "",
                    "    case \"value-comma_group\":",
                    "      return printCommaSeparatedValueGroup(path, options, print);",
                    "",
                    "    case \"value-paren_group\":",
                    "      return printParenthesizedValueGroup(path, options, print);",
                    "",
                    "    case \"value-func\":",
                    "      return [",
                    "        node.value,",
                    "        insideAtRuleNode(path, \"supports\") && isMediaAndSupportsKeywords(node)",
                    "          ? \" \"",
                    "          : \"\",",
                    "        print(\"group\"),",
                    "      ];",
                    "",
                    "    case \"value-paren\":",
                    "      return node.value;",
                    "",
                    "    case \"value-number\":",
                    "      return [printCssNumber(node.value), printUnit(node.unit)];",
                    "",
                    "    case \"value-operator\":",
                    "      return node.value;",
                    "",
                    "    case \"value-word\":",
                    "      if ((node.isColor && node.isHex) || isWideKeywords(node.value)) {",
                    "        return node.value.toLowerCase();",
                    "      }",
                    "",
                    "      return node.value;",
                    "",
                    "    case \"value-colon\": {",
                    "      const { previous } = path;",
                    "      return [",
                    "        node.value,",
                    "        // Don't add spaces on escaped colon `:`, e.g: grid-template-rows: [row-1-00\\:00] auto;",
                    "        (typeof previous?.value === \"string\" &&",
                    "          previous.value.endsWith(\"\\\\\")) ||",
                    "        // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)",
                    "        insideValueFunctionNode(path, \"url\")",
                    "          ? \"\"",
                    "          : line,",
                    "      ];",
                    "    }",
                    "    case \"value-string\":",
                    "      return printString(",
                    "        node.raws.quote + node.value + node.raws.quote,",
                    "        options",
                    "      );",
                    "",
                    "    case \"value-atword\":",
                    "      return [\"@\", node.value];",
                    "",
                    "    case \"value-unicode-range\":",
                    "      return node.value;",
                    "",
                    "    case \"value-unknown\":",
                    "      return node.value;",
                    "",
                    "    case \"value-comma\": // Handled in `value-comma_group`",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"PostCSS\");",
                    "  }",
                    "}",
                    "",
                    "const printer = {",
                    "  print: genericPrint,",
                    "  embed,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = {",
                    "  \"front-matter\": [],",
                    "  \"css-root\": [\"frontMatter\", \"nodes\"],",
                    "  \"css-comment\": [],",
                    "  \"css-rule\": [\"selector\", \"nodes\"],",
                    "  \"css-decl\": [\"value\", \"selector\", \"nodes\"],",
                    "  \"css-atrule\": [\"selector\", \"params\", \"value\", \"nodes\"],",
                    "  \"media-query-list\": [\"nodes\"],",
                    "  \"media-query\": [\"nodes\"],",
                    "  \"media-type\": [],",
                    "  \"media-feature-expression\": [\"nodes\"],",
                    "  \"media-feature\": [],",
                    "  \"media-colon\": [],",
                    "  \"media-value\": [],",
                    "  \"media-keyword\": [],",
                    "  \"media-url\": [],",
                    "  \"media-unknown\": [],",
                    "  \"selector-root\": [\"nodes\"],",
                    "  \"selector-selector\": [\"nodes\"],",
                    "  \"selector-comment\": [],",
                    "  \"selector-string\": [],",
                    "  \"selector-tag\": [],",
                    "  \"selector-id\": [],",
                    "  \"selector-class\": [],",
                    "  \"selector-attribute\": [],",
                    "  \"selector-combinator\": [\"nodes\"],",
                    "  \"selector-universal\": [],",
                    "  \"selector-pseudo\": [\"nodes\"],",
                    "  \"selector-nesting\": [],",
                    "  \"selector-unknown\": [],",
                    "  \"value-value\": [\"group\"],",
                    "  \"value-root\": [\"group\"],",
                    "  \"value-comment\": [],",
                    "  \"value-comma_group\": [\"groups\"],",
                    "  \"value-paren_group\": [\"open\", \"groups\", \"close\"],",
                    "  \"value-func\": [\"group\"],",
                    "  \"value-paren\": [],",
                    "  \"value-number\": [],",
                    "  \"value-operator\": [],",
                    "  \"value-word\": [],",
                    "  \"value-colon\": [],",
                    "  \"value-comma\": [],",
                    "  \"value-string\": [],",
                    "  \"value-atword\": [],",
                    "  \"value-unicode-range\": [],",
                    "  \"value-unknown\": [],",
                    "};",
                    "",
                    "export default visitorKeys;"
                ]
            },
            "parse": {
                "parse-media-query.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import postcssMediaQueryParser from \"postcss-media-query-parser\";",
                        "import { addTypePrefix, addMissingType } from \"./utils.js\";",
                        "",
                        "const parse = postcssMediaQueryParser.default;",
                        "",
                        "function parseMediaQuery(params) {",
                        "  let result;",
                        "",
                        "  try {",
                        "    result = parse(params);",
                        "  } catch {",
                        "    // Ignore bad media queries",
                        "    /* c8 ignore next 4 */",
                        "    return {",
                        "      type: \"selector-unknown\",",
                        "      value: params,",
                        "    };",
                        "  }",
                        "",
                        "  return addTypePrefix(addMissingType(result), \"media-\");",
                        "}",
                        "",
                        "export default parseMediaQuery;"
                    ]
                },
                "parse-selector.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import PostcssSelectorParser from \"postcss-selector-parser/dist/processor.js\";",
                        "import { addTypePrefix } from \"./utils.js\";",
                        "",
                        "function parseSelector(selector) {",
                        "  // If there's a comment inside of a selector, the parser tries to parse",
                        "  // the content of the comment as selectors which turns it into complete",
                        "  // garbage. Better to print the whole selector as-is and not try to parse",
                        "  // and reformat it.",
                        "  if (/\\/\\/|\\/\\*/.test(selector)) {",
                        "    return {",
                        "      type: \"selector-unknown\",",
                        "      value: selector.trim(),",
                        "    };",
                        "  }",
                        "",
                        "  let result;",
                        "",
                        "  try {",
                        "    new PostcssSelectorParser((selectors) => {",
                        "      result = selectors;",
                        "    }).process(selector);",
                        "  } catch {",
                        "    // Fail silently. It's better to print it as is than to try and parse it",
                        "    // Note: A common failure is for SCSS nested properties. `background:",
                        "    // none { color: red; }` is parsed as a NestedDeclaration by",
                        "    // postcss-scss, while `background: { color: red; }` is parsed as a Rule",
                        "    // with a selector ending with a colon. See:",
                        "    // https://github.com/postcss/postcss-scss/issues/39",
                        "    return {",
                        "      type: \"selector-unknown\",",
                        "      value: selector,",
                        "    };",
                        "  }",
                        "",
                        "  return addTypePrefix(result, \"selector-\");",
                        "}",
                        "",
                        "export default parseSelector;"
                    ]
                },
                "parse-value.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import PostcssValuesParser from \"postcss-values-parser/lib/parser.js\";",
                        "import getFunctionArgumentsText from \"../utils/get-function-arguments-text.js\";",
                        "import getValueRoot from \"../utils/get-value-root.js\";",
                        "import hasSCSSInterpolation from \"../utils/has-scss-interpolation.js\";",
                        "import hasStringOrFunction from \"../utils/has-string-or-function.js\";",
                        "import isSCSSVariable from \"../utils/is-scss-variable.js\";",
                        "import parseSelector from \"./parse-selector.js\";",
                        "import { addTypePrefix } from \"./utils.js\";",
                        "",
                        "function parseValueNode(valueNode, options) {",
                        "  const { nodes } = valueNode;",
                        "  let parenGroup = {",
                        "    open: null,",
                        "    close: null,",
                        "    groups: [],",
                        "    type: \"paren_group\",",
                        "  };",
                        "  const parenGroupStack = [parenGroup];",
                        "  const rootParenGroup = parenGroup;",
                        "  let commaGroup = {",
                        "    groups: [],",
                        "    type: \"comma_group\",",
                        "  };",
                        "  const commaGroupStack = [commaGroup];",
                        "",
                        "  for (let i = 0; i < nodes.length; ++i) {",
                        "    const node = nodes[i];",
                        "",
                        "    if (",
                        "      options.parser === \"scss\" &&",
                        "      node.type === \"number\" &&",
                        "      node.unit === \"..\" &&",
                        "      node.value.endsWith(\".\")",
                        "    ) {",
                        "      // Work around postcss bug parsing `50...` as `50.` with unit `..`",
                        "      // Set the unit to `...` to \"accidentally\" have arbitrary arguments work in the same way that cases where the node already had a unit work.",
                        "      // For example, 50px... is parsed as `50` with unit `px...` already by postcss-values-parser.",
                        "      node.value = node.value.slice(0, -1);",
                        "      node.unit = \"...\";",
                        "    }",
                        "",
                        "    if (node.type === \"func\" && node.value === \"selector\") {",
                        "      node.group.groups = [",
                        "        parseSelector(",
                        "          getValueRoot(valueNode).text.slice(",
                        "            node.group.open.sourceIndex + 1,",
                        "            node.group.close.sourceIndex",
                        "          )",
                        "        ),",
                        "      ];",
                        "    }",
                        "",
                        "    if (node.type === \"func\" && node.value === \"url\") {",
                        "      const groups = node.group?.groups ?? [];",
                        "",
                        "      // Create a view with any top-level comma groups flattened.",
                        "      let groupList = [];",
                        "      for (let i = 0; i < groups.length; i++) {",
                        "        const group = groups[i];",
                        "        if (group.type === \"comma_group\") {",
                        "          groupList = [...groupList, ...group.groups];",
                        "        } else {",
                        "          groupList.push(group);",
                        "        }",
                        "      }",
                        "",
                        "      // Stringify if the value parser can't handle the content.",
                        "      if (",
                        "        hasSCSSInterpolation(groupList) ||",
                        "        (!hasStringOrFunction(groupList) &&",
                        "          !isSCSSVariable(groupList[0], options))",
                        "      ) {",
                        "        node.group.groups = [getFunctionArgumentsText(node)];",
                        "      }",
                        "    }",
                        "    if (node.type === \"paren\" && node.value === \"(\") {",
                        "      parenGroup = {",
                        "        open: node,",
                        "        close: null,",
                        "        groups: [],",
                        "        type: \"paren_group\",",
                        "      };",
                        "      parenGroupStack.push(parenGroup);",
                        "",
                        "      commaGroup = {",
                        "        groups: [],",
                        "        type: \"comma_group\",",
                        "      };",
                        "      commaGroupStack.push(commaGroup);",
                        "    } else if (node.type === \"paren\" && node.value === \")\") {",
                        "      if (commaGroup.groups.length > 0) {",
                        "        parenGroup.groups.push(commaGroup);",
                        "      }",
                        "      parenGroup.close = node;",
                        "",
                        "      /* c8 ignore next 3 */",
                        "      if (commaGroupStack.length === 1) {",
                        "        throw new Error(\"Unbalanced parenthesis\");",
                        "      }",
                        "",
                        "      commaGroupStack.pop();",
                        "      commaGroup = commaGroupStack.at(-1);",
                        "      commaGroup.groups.push(parenGroup);",
                        "",
                        "      parenGroupStack.pop();",
                        "      parenGroup = parenGroupStack.at(-1);",
                        "    } else if (node.type === \"comma\") {",
                        "      parenGroup.groups.push(commaGroup);",
                        "      commaGroup = {",
                        "        groups: [],",
                        "        type: \"comma_group\",",
                        "      };",
                        "      commaGroupStack[commaGroupStack.length - 1] = commaGroup;",
                        "    } else {",
                        "      commaGroup.groups.push(node);",
                        "    }",
                        "  }",
                        "  if (commaGroup.groups.length > 0) {",
                        "    parenGroup.groups.push(commaGroup);",
                        "  }",
                        "  return rootParenGroup;",
                        "}",
                        "",
                        "function flattenGroups(node) {",
                        "  if (",
                        "    node.type === \"paren_group\" &&",
                        "    !node.open &&",
                        "    !node.close &&",
                        "    node.groups.length === 1",
                        "  ) {",
                        "    return flattenGroups(node.groups[0]);",
                        "  }",
                        "",
                        "  if (node.type === \"comma_group\" && node.groups.length === 1) {",
                        "    return flattenGroups(node.groups[0]);",
                        "  }",
                        "",
                        "  if (node.type === \"paren_group\" || node.type === \"comma_group\") {",
                        "    return { ...node, groups: node.groups.map(flattenGroups) };",
                        "  }",
                        "",
                        "  return node;",
                        "}",
                        "",
                        "function parseNestedValue(node, options) {",
                        "  if (node && typeof node === \"object\") {",
                        "    for (const key in node) {",
                        "      if (key !== \"parent\") {",
                        "        parseNestedValue(node[key], options);",
                        "        if (key === \"nodes\") {",
                        "          node.group = flattenGroups(parseValueNode(node, options));",
                        "          delete node[key];",
                        "        }",
                        "      }",
                        "    }",
                        "  }",
                        "  return node;",
                        "}",
                        "",
                        "function parseValue(value, options) {",
                        "  // Inline javascript in Less",
                        "  if (options.parser === \"less\" && value.startsWith(\"~`\")) {",
                        "    return { type: \"value-unknown\", value };",
                        "  }",
                        "",
                        "  let result = null;",
                        "",
                        "  try {",
                        "    result = new PostcssValuesParser(value, { loose: true }).parse();",
                        "  } catch {",
                        "    return {",
                        "      type: \"value-unknown\",",
                        "      value,",
                        "    };",
                        "  }",
                        "",
                        "  result.text = value;",
                        "",
                        "  const parsedResult = parseNestedValue(result, options);",
                        "",
                        "  return addTypePrefix(parsedResult, \"value-\", /^selector-/);",
                        "}",
                        "",
                        "export default parseValue;"
                    ]
                },
                "utils.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function addTypePrefix(node, prefix, skipPrefix) {",
                        "  if (node && typeof node === \"object\") {",
                        "    delete node.parent;",
                        "    for (const key in node) {",
                        "      addTypePrefix(node[key], prefix, skipPrefix);",
                        "      if (",
                        "        key === \"type\" &&",
                        "        typeof node[key] === \"string\" &&",
                        "        !node[key].startsWith(prefix) &&",
                        "        (!skipPrefix || !skipPrefix.test(node[key]))",
                        "      ) {",
                        "        node[key] = prefix + node[key];",
                        "      }",
                        "    }",
                        "  }",
                        "  return node;",
                        "}",
                        "",
                        "function addMissingType(node) {",
                        "  if (node && typeof node === \"object\") {",
                        "    delete node.parent;",
                        "    for (const key in node) {",
                        "      addMissingType(node[key]);",
                        "    }",
                        "    if (!Array.isArray(node) && node.value && !node.type) {",
                        "      node.type = \"unknown\";",
                        "    }",
                        "  }",
                        "  return node;",
                        "}",
                        "",
                        "export { addTypePrefix, addMissingType };"
                    ]
                }
            },
            "print": {
                "comma-separated-value-group.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  fill,",
                        "  indent,",
                        "  dedent,",
                        "  breakParent,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  getPropOfDeclNode,",
                        "  insideValueFunctionNode,",
                        "  insideAtRuleNode,",
                        "  insideURLFunctionInImportAtRuleNode,",
                        "  isSCSSControlDirectiveNode,",
                        "  isRelationalOperatorNode,",
                        "  isEqualityOperatorNode,",
                        "  isMultiplicationNode,",
                        "  isDivisionNode,",
                        "  isAdditionNode,",
                        "  isSubtractionNode,",
                        "  isMathOperatorNode,",
                        "  isEachKeywordNode,",
                        "  isForKeywordNode,",
                        "  isIfElseKeywordNode,",
                        "  hasEmptyRawBefore,",
                        "  isPostcssSimpleVarNode,",
                        "  isInlineValueCommentNode,",
                        "  isHashNode,",
                        "  isLeftCurlyBraceNode,",
                        "  isRightCurlyBraceNode,",
                        "  isWordNode,",
                        "  isColonNode,",
                        "  isColorAdjusterFuncNode,",
                        "  isAtWordPlaceholderNode,",
                        "  isParenGroupNode,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "",
                        "function printCommaSeparatedValueGroup(path, options, print) {",
                        "  const { node } = path;",
                        "  const parentNode = path.parent;",
                        "  const parentParentNode = path.grandparent;",
                        "  const declAncestorProp = getPropOfDeclNode(path);",
                        "  const isGridValue =",
                        "    declAncestorProp &&",
                        "    parentNode.type === \"value-value\" &&",
                        "    (declAncestorProp === \"grid\" ||",
                        "      declAncestorProp.startsWith(\"grid-template\"));",
                        "  const atRuleAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"css-atrule\"",
                        "  );",
                        "  const isControlDirective =",
                        "    atRuleAncestorNode &&",
                        "    isSCSSControlDirectiveNode(atRuleAncestorNode, options);",
                        "  const hasInlineComment = node.groups.some((node) =>",
                        "    isInlineValueCommentNode(node)",
                        "  );",
                        "",
                        "  const printed = path.map(print, \"groups\");",
                        "  const parts = [];",
                        "  const insideURLFunction = insideValueFunctionNode(path, \"url\");",
                        "",
                        "  let insideSCSSInterpolationInString = false;",
                        "  let didBreak = false;",
                        "",
                        "  for (let i = 0; i < node.groups.length; ++i) {",
                        "    parts.push(printed[i]);",
                        "",
                        "    const iPrevNode = node.groups[i - 1];",
                        "    const iNode = node.groups[i];",
                        "    const iNextNode = node.groups[i + 1];",
                        "    const iNextNextNode = node.groups[i + 2];",
                        "",
                        "    if (insideURLFunction) {",
                        "      if ((iNextNode && isAdditionNode(iNextNode)) || isAdditionNode(iNode)) {",
                        "        parts.push(\" \");",
                        "      }",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore SCSS @forward wildcard suffix",
                        "    if (",
                        "      insideAtRuleNode(path, \"forward\") &&",
                        "      iNode.type === \"value-word\" &&",
                        "      iNode.value &&",
                        "      iPrevNode !== undefined &&",
                        "      iPrevNode.type === \"value-word\" &&",
                        "      iPrevNode.value === \"as\" &&",
                        "      iNextNode.type === \"value-operator\" &&",
                        "      iNextNode.value === \"*\"",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore after latest node (i.e. before semicolon)",
                        "    if (!iNextNode) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // styled.div` background: var(--${one}); `",
                        "    if (",
                        "      iNode.type === \"value-word\" &&",
                        "      iNode.value.endsWith(\"-\") &&",
                        "      isAtWordPlaceholderNode(iNextNode)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore spaces before/after string interpolation (i.e. `\"#{my-fn(\"_\")}\"`)",
                        "    if (iNode.type === \"value-string\" && iNode.quoted) {",
                        "      const positionOfOpeningInterpolation = iNode.value.lastIndexOf(\"#{\");",
                        "      const positionOfClosingInterpolation = iNode.value.lastIndexOf(\"}\");",
                        "      if (",
                        "        positionOfOpeningInterpolation !== -1 &&",
                        "        positionOfClosingInterpolation !== -1",
                        "      ) {",
                        "        insideSCSSInterpolationInString =",
                        "          positionOfOpeningInterpolation > positionOfClosingInterpolation;",
                        "      } else if (positionOfOpeningInterpolation !== -1) {",
                        "        insideSCSSInterpolationInString = true;",
                        "      } else if (positionOfClosingInterpolation !== -1) {",
                        "        insideSCSSInterpolationInString = false;",
                        "      }",
                        "    }",
                        "",
                        "    if (insideSCSSInterpolationInString) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore colon (i.e. `:`)",
                        "    if (isColonNode(iNode) || isColonNode(iNextNode)) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore `@` in Less (i.e. `@@var;`)",
                        "    if (",
                        "      iNode.type === \"value-atword\" &&",
                        "      (iNode.value === \"\" ||",
                        "        /*",
                        "            @var[ @notVarNested ][notVar]",
                        "            ^^^^^",
                        "            */",
                        "        iNode.value.endsWith(\"[\"))",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    /*",
                        "    @var[ @notVarNested ][notVar]",
                        "                        ^^^^^^^^^",
                        "    */",
                        "    if (iNextNode.type === \"value-word\" && iNextNode.value.startsWith(\"]\")) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore `~` in Less (i.e. `content: ~\"^//* some horrible but needed css hack\";`)",
                        "    if (iNode.value === \"~\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore escape `\\`",
                        "    if (",
                        "      iNode.type !== \"value-string\" &&",
                        "      iNode.value &&",
                        "      iNode.value.includes(\"\\\\\") &&",
                        "      iNextNode &&",
                        "      iNextNode.type !== \"value-comment\"",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore escaped `/`",
                        "    if (",
                        "      iPrevNode?.value &&",
                        "      iPrevNode.value.indexOf(\"\\\\\") === iPrevNode.value.length - 1 &&",
                        "      iNode.type === \"value-operator\" &&",
                        "      iNode.value === \"/\"",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore `\\` (i.e. `$variable: \\@small;`)",
                        "    if (iNode.value === \"\\\\\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore `$$` (i.e. `background-color: $$(style)Color;`)",
                        "    if (isPostcssSimpleVarNode(iNode, iNextNode)) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)",
                        "    if (",
                        "      isHashNode(iNode) ||",
                        "      isLeftCurlyBraceNode(iNode) ||",
                        "      isRightCurlyBraceNode(iNextNode) ||",
                        "      (isLeftCurlyBraceNode(iNextNode) && hasEmptyRawBefore(iNextNode)) ||",
                        "      (isRightCurlyBraceNode(iNode) && hasEmptyRawBefore(iNextNode))",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)",
                        "    if (iNode.value === \"--\" && isHashNode(iNextNode)) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Formatting math operations",
                        "    const isMathOperator = isMathOperatorNode(iNode);",
                        "    const isNextMathOperator = isMathOperatorNode(iNextNode);",
                        "",
                        "    // Print spaces before and after math operators beside SCSS interpolation as is",
                        "    // (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)",
                        "    // (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)",
                        "    if (",
                        "      ((isMathOperator && isHashNode(iNextNode)) ||",
                        "        (isNextMathOperator && isRightCurlyBraceNode(iNode))) &&",
                        "      hasEmptyRawBefore(iNextNode)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // absolute paths are only parsed as one token if they are part of url(/abs/path) call",
                        "    // but if you have custom -fb-url(/abs/path/) then it is parsed as \"division /\" and rest",
                        "    // of the path. We don't want to put a space after that first division in this case.",
                        "    if (!iPrevNode && isDivisionNode(iNode)) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Print spaces before and after addition and subtraction math operators as is in `calc` function",
                        "    // due to the fact that it is not valid syntax",
                        "    // (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)",
                        "    if (",
                        "      insideValueFunctionNode(path, \"calc\") &&",
                        "      (isAdditionNode(iNode) ||",
                        "        isAdditionNode(iNextNode) ||",
                        "        isSubtractionNode(iNode) ||",
                        "        isSubtractionNode(iNextNode)) &&",
                        "      hasEmptyRawBefore(iNextNode)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)",
                        "    // Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.",
                        "    const isColorAdjusterNode =",
                        "      (isAdditionNode(iNode) || isSubtractionNode(iNode)) &&",
                        "      i === 0 &&",
                        "      (iNextNode.type === \"value-number\" || iNextNode.isHex) &&",
                        "      parentParentNode &&",
                        "      isColorAdjusterFuncNode(parentParentNode) &&",
                        "      !hasEmptyRawBefore(iNextNode);",
                        "",
                        "    const requireSpaceBeforeOperator =",
                        "      iNextNextNode?.type === \"value-func\" ||",
                        "      (iNextNextNode && isWordNode(iNextNextNode)) ||",
                        "      iNode.type === \"value-func\" ||",
                        "      isWordNode(iNode);",
                        "    const requireSpaceAfterOperator =",
                        "      iNextNode.type === \"value-func\" ||",
                        "      isWordNode(iNextNode) ||",
                        "      iPrevNode?.type === \"value-func\" ||",
                        "      (iPrevNode && isWordNode(iPrevNode));",
                        "",
                        "    // Formatting `/`, `+`, `-` sign",
                        "    if (",
                        "      !(isMultiplicationNode(iNextNode) || isMultiplicationNode(iNode)) &&",
                        "      !insideValueFunctionNode(path, \"calc\") &&",
                        "      !isColorAdjusterNode &&",
                        "      ((isDivisionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                        "        (isDivisionNode(iNode) && !requireSpaceAfterOperator) ||",
                        "        (isAdditionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                        "        (isAdditionNode(iNode) && !requireSpaceAfterOperator) ||",
                        "        isSubtractionNode(iNextNode) ||",
                        "        isSubtractionNode(iNode)) &&",
                        "      (hasEmptyRawBefore(iNextNode) ||",
                        "        (isMathOperator &&",
                        "          (!iPrevNode || (iPrevNode && isMathOperatorNode(iPrevNode)))))",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // No space before unary minus followed by an opening parenthesis `-(`",
                        "    if (",
                        "      (options.parser === \"scss\" || options.parser === \"less\") &&",
                        "      isMathOperator &&",
                        "      iNode.value === \"-\" &&",
                        "      isParenGroupNode(iNextNode) &&",
                        "      locEnd(iNode) === locStart(iNextNode.open) &&",
                        "      iNextNode.open.value === \"(\"",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Add `hardline` after inline comment (i.e. `// comment\\n foo: bar;`)",
                        "    if (isInlineValueCommentNode(iNode)) {",
                        "      if (parentNode.type === \"value-paren_group\") {",
                        "        parts.push(dedent(hardline));",
                        "        continue;",
                        "      }",
                        "      parts.push(hardline);",
                        "      continue;",
                        "    }",
                        "",
                        "    // Handle keywords in SCSS control directive",
                        "    if (",
                        "      isControlDirective &&",
                        "      (isEqualityOperatorNode(iNextNode) ||",
                        "        isRelationalOperatorNode(iNextNode) ||",
                        "        isIfElseKeywordNode(iNextNode) ||",
                        "        isEachKeywordNode(iNode) ||",
                        "        isForKeywordNode(iNode))",
                        "    ) {",
                        "      parts.push(\" \");",
                        "",
                        "      continue;",
                        "    }",
                        "",
                        "    // At-rule `namespace` should be in one line",
                        "    if (",
                        "      atRuleAncestorNode &&",
                        "      atRuleAncestorNode.name.toLowerCase() === \"namespace\"",
                        "    ) {",
                        "      parts.push(\" \");",
                        "",
                        "      continue;",
                        "    }",
                        "",
                        "    // Formatting `grid` property",
                        "    if (isGridValue) {",
                        "      if (",
                        "        iNode.source &&",
                        "        iNextNode.source &&",
                        "        iNode.source.start.line !== iNextNode.source.start.line",
                        "      ) {",
                        "        parts.push(hardline);",
                        "",
                        "        didBreak = true;",
                        "      } else {",
                        "        parts.push(\" \");",
                        "      }",
                        "",
                        "      continue;",
                        "    }",
                        "",
                        "    // Add `space` before next math operation",
                        "    // Note: `grip` property have `/` delimiter and it is not math operation, so",
                        "    // `grid` property handles above",
                        "    if (isNextMathOperator) {",
                        "      parts.push(\" \");",
                        "",
                        "      continue;",
                        "    }",
                        "    // allow function(returns-list($list)...)",
                        "    if (iNextNode?.value === \"...\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (",
                        "      isAtWordPlaceholderNode(iNode) &&",
                        "      isAtWordPlaceholderNode(iNextNode) &&",
                        "      locEnd(iNode) === locStart(iNextNode)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (",
                        "      isAtWordPlaceholderNode(iNode) &&",
                        "      isParenGroupNode(iNextNode) &&",
                        "      locEnd(iNode) === locStart(iNextNode.open)",
                        "    ) {",
                        "      parts.push(softline);",
                        "      continue;",
                        "    }",
                        "",
                        "    if (iNode.value === \"with\" && isParenGroupNode(iNextNode)) {",
                        "      parts.push(\" \");",
                        "      continue;",
                        "    }",
                        "",
                        "    if (",
                        "      iNode.value?.endsWith(\"#\") &&",
                        "      iNextNode.value === \"{\" &&",
                        "      isParenGroupNode(iNextNode.group)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Be default all values go through `line`",
                        "    parts.push(line);",
                        "  }",
                        "",
                        "  if (hasInlineComment) {",
                        "    parts.push(breakParent);",
                        "  }",
                        "",
                        "  if (didBreak) {",
                        "    parts.unshift(hardline);",
                        "  }",
                        "",
                        "  if (isControlDirective) {",
                        "    return group(indent(parts));",
                        "  }",
                        "",
                        "  // Indent is not needed for import url when url is very long",
                        "  // and node has two groups",
                        "  // when type is value-comma_group",
                        "  // example @import url(\"verylongurl\") projection,tv",
                        "  if (insideURLFunctionInImportAtRuleNode(path)) {",
                        "    return group(fill(parts));",
                        "  }",
                        "",
                        "  return group(indent(fill(parts)));",
                        "}",
                        "",
                        "export default printCommaSeparatedValueGroup;"
                    ]
                },
                "css-units.evaluate.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import cssUnits from \"css-units-list\";",
                        "",
                        "const CSS_UNITS = new Map(cssUnits.map((unit) => [unit.toLowerCase(), unit]));",
                        "",
                        "export default CSS_UNITS;"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import printNumber from \"../../utils/print-number.js\";",
                        "import printString from \"../../utils/print-string.js\";",
                        "import { maybeToLowerCase } from \"../utils/index.js\";",
                        "import CSS_UNITS from \"./css-units.evaluate.js\";",
                        "",
                        "function printUnit(unit) {",
                        "  const lowercased = unit.toLowerCase();",
                        "  return CSS_UNITS.has(lowercased) ? CSS_UNITS.get(lowercased) : unit;",
                        "}",
                        "",
                        "const STRING_REGEX = /([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*\\1/gs;",
                        "const NUMBER_REGEX = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[Ee][+-]?\\d+)?/g;",
                        "const STANDARD_UNIT_REGEX = /[A-Za-z]+/g;",
                        "const WORD_PART_REGEX = /[$@]?[A-Z_a-z\\u0080-\\uFFFF][\\w\\u0080-\\uFFFF-]*/g;",
                        "const ADJUST_NUMBERS_REGEX = new RegExp(",
                        "  STRING_REGEX.source +",
                        "    \"|\" +",
                        "    `(${WORD_PART_REGEX.source})?` +",
                        "    `(${NUMBER_REGEX.source})` +",
                        "    `(${STANDARD_UNIT_REGEX.source})?`,",
                        "  \"g\"",
                        ");",
                        "",
                        "function adjustStrings(value, options) {",
                        "  return value.replaceAll(STRING_REGEX, (match) => printString(match, options));",
                        "}",
                        "",
                        "function quoteAttributeValue(value, options) {",
                        "  const quote = options.singleQuote ? \"'\" : '\"';",
                        "  return value.includes('\"') || value.includes(\"'\")",
                        "    ? value",
                        "    : quote + value + quote;",
                        "}",
                        "",
                        "function adjustNumbers(value) {",
                        "  return value.replace(",
                        "    ADJUST_NUMBERS_REGEX,",
                        "    (match, quote, wordPart, number, unit) =>",
                        "      !wordPart && number",
                        "        ? printCssNumber(number) + maybeToLowerCase(unit || \"\")",
                        "        : match",
                        "  );",
                        "}",
                        "",
                        "function printCssNumber(rawNumber) {",
                        "  return (",
                        "    printNumber(rawNumber)",
                        "      // Remove trailing `.0`.",
                        "      .replace(/\\.0(?=$|e)/, \"\")",
                        "  );",
                        "}",
                        "",
                        "function shouldPrintTrailingComma(options) {",
                        "  return options.trailingComma === \"es5\" || options.trailingComma === \"all\";",
                        "}",
                        "",
                        "export {",
                        "  adjustStrings,",
                        "  adjustNumbers,",
                        "  quoteAttributeValue,",
                        "  shouldPrintTrailingComma,",
                        "  printUnit,",
                        "  printCssNumber,",
                        "};"
                    ]
                },
                "parenthesized-value-group.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNextLineEmpty from \"../../utils/is-next-line-empty.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  join,",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  fill,",
                        "  indent,",
                        "  dedent,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import { getDocParts } from \"../../document/utils.js\";",
                        "import {",
                        "  isURLFunctionNode,",
                        "  isKeyValuePairNode,",
                        "  isKeyInValuePairNode,",
                        "  isSCSSMapItemNode,",
                        "  isConfigurationNode,",
                        "  isVarFunctionNode,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import { shouldPrintTrailingComma } from \"./misc.js\";",
                        "",
                        "function hasComma({ node, parent }, options) {",
                        "  return Boolean(",
                        "    node.source &&",
                        "      options.originalText",
                        "        .slice(locStart(node), locStart(parent.close))",
                        "        .trimEnd()",
                        "        .endsWith(\",\")",
                        "  );",
                        "}",
                        "",
                        "function printTrailingComma(path, options) {",
                        "  if (isVarFunctionNode(path.grandparent) && hasComma(path, options)) {",
                        "    return \",\";",
                        "  }",
                        "",
                        "  if (",
                        "    path.node.type !== \"value-comment\" &&",
                        "    shouldPrintTrailingComma(options) &&",
                        "    path.callParent(() => isSCSSMapItemNode(path, options))",
                        "  ) {",
                        "    return ifBreak(\",\");",
                        "  }",
                        "",
                        "  return \"\";",
                        "}",
                        "",
                        "function printParenthesizedValueGroup(path, options, print) {",
                        "  const { node, parent } = path;",
                        "  const groupDocs = path.map(",
                        "    ({ node }) => (typeof node === \"string\" ? node : print()),",
                        "    \"groups\"",
                        "  );",
                        "",
                        "  if (",
                        "    parent &&",
                        "    isURLFunctionNode(parent) &&",
                        "    (node.groups.length === 1 ||",
                        "      (node.groups.length > 0 &&",
                        "        node.groups[0].type === \"value-comma_group\" &&",
                        "        node.groups[0].groups.length > 0 &&",
                        "        node.groups[0].groups[0].type === \"value-word\" &&",
                        "        node.groups[0].groups[0].value.startsWith(\"data:\")))",
                        "  ) {",
                        "    return [",
                        "      node.open ? print(\"open\") : \"\",",
                        "      join(\",\", groupDocs),",
                        "      node.close ? print(\"close\") : \"\",",
                        "    ];",
                        "  }",
                        "",
                        "  if (!node.open) {",
                        "    const forceHardLine = shouldBreakList(path);",
                        "    const parts = join([\",\", forceHardLine ? hardline : line], groupDocs);",
                        "    return indent(forceHardLine ? [hardline, parts] : group(fill(parts)));",
                        "  }",
                        "",
                        "  const parts = path.map(({ node: child, isLast, index }) => {",
                        "    let doc = groupDocs[index];",
                        "",
                        "    // Key/Value pair in open paren already indented",
                        "    if (",
                        "      isKeyValuePairNode(child) &&",
                        "      child.type === \"value-comma_group\" &&",
                        "      child.groups &&",
                        "      child.groups[0].type !== \"value-paren_group\" &&",
                        "      child.groups[2]?.type === \"value-paren_group\"",
                        "    ) {",
                        "      const parts = getDocParts(doc.contents.contents);",
                        "      parts[1] = group(parts[1]);",
                        "      doc = group(dedent(doc));",
                        "    }",
                        "",
                        "    const parts = [doc, isLast ? printTrailingComma(path, options) : \",\"];",
                        "",
                        "    if (",
                        "      !isLast &&",
                        "      child.type === \"value-comma_group\" &&",
                        "      isNonEmptyArray(child.groups)",
                        "    ) {",
                        "      let last = child.groups.at(-1);",
                        "",
                        "      // `value-paren_group` does not have location info, but its closing parenthesis does.",
                        "      if (!last.source && last.close) {",
                        "        last = last.close;",
                        "      }",
                        "",
                        "      if (last.source && isNextLineEmpty(options.originalText, locEnd(last))) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "",
                        "    return parts;",
                        "  }, \"groups\");",
                        "  const isKey = isKeyInValuePairNode(node, parent);",
                        "  const isConfiguration = isConfigurationNode(node, parent);",
                        "  const isSCSSMapItem = isSCSSMapItemNode(path, options);",
                        "  const shouldBreak = isConfiguration || (isSCSSMapItem && !isKey);",
                        "  const shouldDedent = isConfiguration || isKey;",
                        "",
                        "  const doc = group(",
                        "    [",
                        "      node.open ? print(\"open\") : \"\",",
                        "      indent([softline, join(line, parts)]),",
                        "      softline,",
                        "      node.close ? print(\"close\") : \"\",",
                        "    ],",
                        "    {",
                        "      shouldBreak,",
                        "    }",
                        "  );",
                        "",
                        "  return shouldDedent ? dedent(doc) : doc;",
                        "}",
                        "",
                        "function shouldBreakList(path) {",
                        "  return path.match(",
                        "    (node) =>",
                        "      node.type === \"value-paren_group\" &&",
                        "      !node.open &&",
                        "      node.groups.some((node) => node.type === \"value-comma_group\"),",
                        "    (node, key) => key === \"group\" && node.type === \"value-value\",",
                        "    (node, key) => key === \"group\" && node.type === \"value-root\",",
                        "    (node, key) =>",
                        "      key === \"value\" &&",
                        "      ((node.type === \"css-decl\" && !node.prop.startsWith(\"--\")) ||",
                        "        (node.type === \"css-atrule\" && node.variable))",
                        "  );",
                        "}",
                        "",
                        "export { printParenthesizedValueGroup, shouldBreakList };"
                    ]
                },
                "sequence.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isNextLineEmpty from \"../../utils/is-next-line-empty.js\";",
                        "import isFrontMatter from \"../../utils/front-matter/is-front-matter.js\";",
                        "import { line, hardline } from \"../../document/builders.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "",
                        "function printSequence(path, options, print) {",
                        "  const parts = [];",
                        "  path.each(() => {",
                        "    const { node, previous } = path;",
                        "    if (",
                        "      previous?.type === \"css-comment\" &&",
                        "      previous.text.trim() === \"prettier-ignore\"",
                        "    ) {",
                        "      parts.push(options.originalText.slice(locStart(node), locEnd(node)));",
                        "    } else {",
                        "      parts.push(print());",
                        "    }",
                        "",
                        "    if (path.isLast) {",
                        "      return;",
                        "    }",
                        "",
                        "    const { next } = path;",
                        "    if (",
                        "      (next.type === \"css-comment\" &&",
                        "        !hasNewline(options.originalText, locStart(next), {",
                        "          backwards: true,",
                        "        }) &&",
                        "        !isFrontMatter(node)) ||",
                        "      (next.type === \"css-atrule\" &&",
                        "        next.name === \"else\" &&",
                        "        node.type !== \"css-comment\")",
                        "    ) {",
                        "      parts.push(\" \");",
                        "    } else {",
                        "      parts.push(options.__isHTMLStyleAttribute ? line : hardline);",
                        "      if (",
                        "        isNextLineEmpty(options.originalText, locEnd(node)) &&",
                        "        !isFrontMatter(node)",
                        "      ) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, \"nodes\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export default printSequence;"
                    ]
                }
            },
            "utils": {
                "get-function-arguments-text.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import getValueRoot from \"./get-value-root.js\";",
                        "",
                        "/**",
                        " * @param {*} node",
                        " * @returns {string}",
                        " */",
                        "function getFunctionArgumentsText(node) {",
                        "  return getValueRoot(node)",
                        "    .text.slice(node.group.open.sourceIndex + 1, node.group.close.sourceIndex)",
                        "    .trim();",
                        "}",
                        "",
                        "export default getFunctionArgumentsText;"
                    ]
                },
                "get-value-root.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const getValueRoot = (node) => {",
                        "  while (node.parent) {",
                        "    node = node.parent;",
                        "  }",
                        "",
                        "  return node;",
                        "};",
                        "",
                        "export default getValueRoot;"
                    ]
                },
                "has-scss-interpolation.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "",
                        "function hasSCSSInterpolation(groupList) {",
                        "  if (isNonEmptyArray(groupList)) {",
                        "    for (let i = groupList.length - 1; i > 0; i--) {",
                        "      // If we find `#{`, return true.",
                        "      if (",
                        "        groupList[i].type === \"word\" &&",
                        "        groupList[i].value === \"{\" &&",
                        "        groupList[i - 1].type === \"word\" &&",
                        "        groupList[i - 1].value.endsWith(\"#\")",
                        "      ) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "export default hasSCSSInterpolation;"
                    ]
                },
                "has-string-or-function.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function hasStringOrFunction(groupList) {",
                        "  return groupList.some(",
                        "    (group) =>",
                        "      group.type === \"string\" ||",
                        "      (group.type === \"func\" &&",
                        "        // workaround false-positive func",
                        "        !group.value.endsWith(\"\\\\\"))",
                        "  );",
                        "}",
                        "",
                        "export default hasStringOrFunction;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const colorAdjusterFunctions = new Set([",
                        "  \"red\",",
                        "  \"green\",",
                        "  \"blue\",",
                        "  \"alpha\",",
                        "  \"a\",",
                        "  \"rgb\",",
                        "  \"hue\",",
                        "  \"h\",",
                        "  \"saturation\",",
                        "  \"s\",",
                        "  \"lightness\",",
                        "  \"l\",",
                        "  \"whiteness\",",
                        "  \"w\",",
                        "  \"blackness\",",
                        "  \"b\",",
                        "  \"tint\",",
                        "  \"shade\",",
                        "  \"blend\",",
                        "  \"blenda\",",
                        "  \"contrast\",",
                        "  \"hsl\",",
                        "  \"hsla\",",
                        "  \"hwb\",",
                        "  \"hwba\",",
                        "]);",
                        "",
                        "function getPropOfDeclNode(path) {",
                        "  return path",
                        "    .findAncestor((node) => node.type === \"css-decl\")",
                        "    ?.prop?.toLowerCase();",
                        "}",
                        "",
                        "const wideKeywords = new Set([\"initial\", \"inherit\", \"unset\", \"revert\"]);",
                        "function isWideKeywords(value) {",
                        "  return wideKeywords.has(value.toLowerCase());",
                        "}",
                        "",
                        "function isKeyframeAtRuleKeywords(path, value) {",
                        "  const atRuleAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"css-atrule\"",
                        "  );",
                        "  return (",
                        "    atRuleAncestorNode?.name?.toLowerCase().endsWith(\"keyframes\") &&",
                        "    [\"from\", \"to\"].includes(value.toLowerCase())",
                        "  );",
                        "}",
                        "",
                        "function maybeToLowerCase(value) {",
                        "  return value.includes(\"$\") ||",
                        "    value.includes(\"@\") ||",
                        "    value.includes(\"#\") ||",
                        "    value.startsWith(\"%\") ||",
                        "    value.startsWith(\"--\") ||",
                        "    value.startsWith(\":--\") ||",
                        "    (value.includes(\"(\") && value.includes(\")\"))",
                        "    ? value",
                        "    : value.toLowerCase();",
                        "}",
                        "",
                        "function insideValueFunctionNode(path, functionName) {",
                        "  const funcAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"value-func\"",
                        "  );",
                        "  return funcAncestorNode?.value?.toLowerCase() === functionName;",
                        "}",
                        "",
                        "function insideICSSRuleNode(path) {",
                        "  const ruleAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"css-rule\"",
                        "  );",
                        "  const selector = ruleAncestorNode?.raws?.selector;",
                        "",
                        "  return (",
                        "    selector &&",
                        "    (selector.startsWith(\":import\") || selector.startsWith(\":export\"))",
                        "  );",
                        "}",
                        "",
                        "function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {",
                        "  const atRuleNames = Array.isArray(atRuleNameOrAtRuleNames)",
                        "    ? atRuleNameOrAtRuleNames",
                        "    : [atRuleNameOrAtRuleNames];",
                        "  const atRuleAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"css-atrule\"",
                        "  );",
                        "",
                        "  return (",
                        "    atRuleAncestorNode &&",
                        "    atRuleNames.includes(atRuleAncestorNode.name.toLowerCase())",
                        "  );",
                        "}",
                        "",
                        "function insideURLFunctionInImportAtRuleNode(path) {",
                        "  const { node } = path;",
                        "  return (",
                        "    node.groups[0].value === \"url\" &&",
                        "    node.groups.length === 2 &&",
                        "    path.findAncestor((node) => node.type === \"css-atrule\")?.name === \"import\"",
                        "  );",
                        "}",
                        "",
                        "function isURLFunctionNode(node) {",
                        "  return node.type === \"value-func\" && node.value.toLowerCase() === \"url\";",
                        "}",
                        "",
                        "function isVarFunctionNode(node) {",
                        "  return node.type === \"value-func\" && node.value.toLowerCase() === \"var\";",
                        "}",
                        "",
                        "function isLastNode(path, node) {",
                        "  const nodes = path.parent?.nodes;",
                        "  return nodes && nodes.indexOf(node) === nodes.length - 1;",
                        "}",
                        "",
                        "function isDetachedRulesetDeclarationNode(node) {",
                        "  const { selector } = node;",
                        "  // If a Less file ends up being parsed with the SCSS parser, Less",
                        "  // variable declarations will be parsed as atrules with names ending",
                        "  // with a colon, so keep the original case then.",
                        "  /* c8 ignore next 3 */",
                        "  if (!selector) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return (",
                        "    (typeof selector === \"string\" && /^@.+:.*$/.test(selector)) ||",
                        "    (selector.value && /^@.+:.*$/.test(selector.value))",
                        "  );",
                        "}",
                        "",
                        "function isForKeywordNode(node) {",
                        "  return (",
                        "    node.type === \"value-word\" &&",
                        "    [\"from\", \"through\", \"end\"].includes(node.value)",
                        "  );",
                        "}",
                        "",
                        "function isIfElseKeywordNode(node) {",
                        "  return (",
                        "    node.type === \"value-word\" && [\"and\", \"or\", \"not\"].includes(node.value)",
                        "  );",
                        "}",
                        "",
                        "function isEachKeywordNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"in\";",
                        "}",
                        "",
                        "function isMultiplicationNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"*\";",
                        "}",
                        "",
                        "function isDivisionNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"/\";",
                        "}",
                        "",
                        "function isAdditionNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"+\";",
                        "}",
                        "",
                        "function isSubtractionNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"-\";",
                        "}",
                        "",
                        "function isModuloNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"%\";",
                        "}",
                        "",
                        "function isMathOperatorNode(node) {",
                        "  return (",
                        "    isMultiplicationNode(node) ||",
                        "    isDivisionNode(node) ||",
                        "    isAdditionNode(node) ||",
                        "    isSubtractionNode(node) ||",
                        "    isModuloNode(node)",
                        "  );",
                        "}",
                        "",
                        "function isEqualityOperatorNode(node) {",
                        "  return node.type === \"value-word\" && [\"==\", \"!=\"].includes(node.value);",
                        "}",
                        "",
                        "function isRelationalOperatorNode(node) {",
                        "  return (",
                        "    node.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].includes(node.value)",
                        "  );",
                        "}",
                        "",
                        "function isSCSSControlDirectiveNode(node, options) {",
                        "  return (",
                        "    options.parser === \"scss\" &&",
                        "    node.type === \"css-atrule\" &&",
                        "    [\"if\", \"else\", \"for\", \"each\", \"while\"].includes(node.name)",
                        "  );",
                        "}",
                        "",
                        "function isDetachedRulesetCallNode(node) {",
                        "  return node.raws?.params && /^\\(\\s*\\)$/.test(node.raws.params);",
                        "}",
                        "",
                        "function isTemplatePlaceholderNode(node) {",
                        "  return node.name.startsWith(\"prettier-placeholder\");",
                        "}",
                        "",
                        "function isTemplatePropNode(node) {",
                        "  return node.prop.startsWith(\"@prettier-placeholder\");",
                        "}",
                        "",
                        "function isPostcssSimpleVarNode(currentNode, nextNode) {",
                        "  return (",
                        "    currentNode.value === \"$$\" &&",
                        "    currentNode.type === \"value-func\" &&",
                        "    nextNode?.type === \"value-word\" &&",
                        "    !nextNode.raws.before",
                        "  );",
                        "}",
                        "",
                        "function hasComposesNode(node) {",
                        "  return (",
                        "    node.value?.type === \"value-root\" &&",
                        "    node.value.group?.type === \"value-value\" &&",
                        "    node.prop.toLowerCase() === \"composes\"",
                        "  );",
                        "}",
                        "",
                        "function hasParensAroundNode(node) {",
                        "  return (",
                        "    node.value?.group?.group?.type === \"value-paren_group\" &&",
                        "    node.value.group.group.open !== null &&",
                        "    node.value.group.group.close !== null",
                        "  );",
                        "}",
                        "",
                        "function hasEmptyRawBefore(node) {",
                        "  return node.raws?.before === \"\";",
                        "}",
                        "",
                        "function isKeyValuePairNode(node) {",
                        "  return (",
                        "    node.type === \"value-comma_group\" &&",
                        "    node.groups?.[1]?.type === \"value-colon\"",
                        "  );",
                        "}",
                        "",
                        "function isKeyValuePairInParenGroupNode(node) {",
                        "  return (",
                        "    node.type === \"value-paren_group\" &&",
                        "    node.groups?.[0] &&",
                        "    isKeyValuePairNode(node.groups[0])",
                        "  );",
                        "}",
                        "",
                        "function isSCSSMapItemNode(path, options) {",
                        "  if (options.parser !== \"scss\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  const { node } = path;",
                        "",
                        "  // Ignore empty item (i.e. `$key: ()`)",
                        "  if (node.groups.length === 0) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const parentParentNode = path.grandparent;",
                        "",
                        "  // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)",
                        "  if (",
                        "    !isKeyValuePairInParenGroupNode(node) &&",
                        "    !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const declNode = path.findAncestor((node) => node.type === \"css-decl\");",
                        "",
                        "  // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)",
                        "  if (declNode?.prop?.startsWith(\"$\")) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)",
                        "  if (isKeyValuePairInParenGroupNode(parentParentNode)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)",
                        "  if (parentParentNode.type === \"value-func\") {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function isInlineValueCommentNode(node) {",
                        "  return node.type === \"value-comment\" && node.inline;",
                        "}",
                        "",
                        "function isHashNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"#\";",
                        "}",
                        "",
                        "function isLeftCurlyBraceNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"{\";",
                        "}",
                        "",
                        "function isRightCurlyBraceNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"}\";",
                        "}",
                        "",
                        "function isWordNode(node) {",
                        "  return [\"value-word\", \"value-atword\"].includes(node.type);",
                        "}",
                        "",
                        "function isColonNode(node) {",
                        "  return node?.type === \"value-colon\";",
                        "}",
                        "",
                        "function isKeyInValuePairNode(node, parentNode) {",
                        "  if (!isKeyValuePairNode(parentNode)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const { groups } = parentNode;",
                        "  const index = groups.indexOf(node);",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (index === -1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return isColonNode(groups[index + 1]);",
                        "}",
                        "",
                        "function isMediaAndSupportsKeywords(node) {",
                        "  return node.value && [\"not\", \"and\", \"or\"].includes(node.value.toLowerCase());",
                        "}",
                        "",
                        "function isColorAdjusterFuncNode(node) {",
                        "  if (node.type !== \"value-func\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  return colorAdjusterFunctions.has(node.value.toLowerCase());",
                        "}",
                        "",
                        "function lastLineHasInlineComment(text) {",
                        "  return /\\/\\//.test(text.split(/[\\n\\r]/).pop());",
                        "}",
                        "",
                        "function isAtWordPlaceholderNode(node) {",
                        "  return (",
                        "    node?.type === \"value-atword\" &&",
                        "    node.value.startsWith(\"prettier-placeholder-\")",
                        "  );",
                        "}",
                        "",
                        "function isConfigurationNode(node, parentNode) {",
                        "  if (",
                        "    node.open?.value !== \"(\" ||",
                        "    node.close?.value !== \")\" ||",
                        "    node.groups.some((group) => group.type !== \"value-comma_group\")",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "  if (parentNode.type === \"value-comma_group\") {",
                        "    const prevIdx = parentNode.groups.indexOf(node) - 1;",
                        "    const maybeWithNode = parentNode.groups[prevIdx];",
                        "    if (",
                        "      maybeWithNode?.type === \"value-word\" &&",
                        "      maybeWithNode.value === \"with\"",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function isParenGroupNode(node) {",
                        "  return (",
                        "    node.type === \"value-paren_group\" &&",
                        "    node.open?.value === \"(\" &&",
                        "    node.close?.value === \")\"",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  getPropOfDeclNode,",
                        "  maybeToLowerCase,",
                        "  insideValueFunctionNode,",
                        "  insideICSSRuleNode,",
                        "  insideAtRuleNode,",
                        "  insideURLFunctionInImportAtRuleNode,",
                        "  isKeyframeAtRuleKeywords,",
                        "  isWideKeywords,",
                        "  isLastNode,",
                        "  isSCSSControlDirectiveNode,",
                        "  isDetachedRulesetDeclarationNode,",
                        "  isRelationalOperatorNode,",
                        "  isEqualityOperatorNode,",
                        "  isMultiplicationNode,",
                        "  isDivisionNode,",
                        "  isAdditionNode,",
                        "  isSubtractionNode,",
                        "  isModuloNode,",
                        "  isMathOperatorNode,",
                        "  isEachKeywordNode,",
                        "  isForKeywordNode,",
                        "  isURLFunctionNode,",
                        "  isIfElseKeywordNode,",
                        "  hasComposesNode,",
                        "  hasParensAroundNode,",
                        "  hasEmptyRawBefore,",
                        "  isDetachedRulesetCallNode,",
                        "  isTemplatePlaceholderNode,",
                        "  isTemplatePropNode,",
                        "  isPostcssSimpleVarNode,",
                        "  isKeyValuePairNode,",
                        "  isKeyValuePairInParenGroupNode,",
                        "  isKeyInValuePairNode,",
                        "  isSCSSMapItemNode,",
                        "  isInlineValueCommentNode,",
                        "  isHashNode,",
                        "  isLeftCurlyBraceNode,",
                        "  isRightCurlyBraceNode,",
                        "  isWordNode,",
                        "  isColonNode,",
                        "  isMediaAndSupportsKeywords,",
                        "  isColorAdjusterFuncNode,",
                        "  lastLineHasInlineComment,",
                        "  isAtWordPlaceholderNode,",
                        "  isConfigurationNode,",
                        "  isParenGroupNode,",
                        "  isVarFunctionNode,",
                        "};"
                    ]
                },
                "is-module-rule-name.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const moduleRuleNames = new Set([\"import\", \"use\", \"forward\"]);",
                        "",
                        "function isModuleRuleName(name) {",
                        "  return moduleRuleNames.has(name);",
                        "}",
                        "",
                        "export default isModuleRuleName;"
                    ]
                },
                "is-scss-nested-property-node.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isSCSSNestedPropertyNode(node, options) {",
                        "  if (options.parser !== \"scss\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (!node.selector) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return node.selector",
                        "    .replace(/\\/\\*.*?\\*\\//, \"\")",
                        "    .replace(/\\/\\/.*\\n/, \"\")",
                        "    .trim()",
                        "    .endsWith(\":\");",
                        "}",
                        "",
                        "export default isSCSSNestedPropertyNode;"
                    ]
                },
                "is-scss-variable.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isSCSSVariable(node, options) {",
                        "  return Boolean(",
                        "    options.parser === \"scss\" &&",
                        "      node?.type === \"word\" &&",
                        "      node.value.startsWith(\"$\")",
                        "  );",
                        "}",
                        "",
                        "export default isSCSSVariable;"
                    ]
                },
                "stringify-node.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function stringifyNode(node) {",
                        "  if (node.groups) {",
                        "    const open = node.open?.value || \"\";",
                        "    const groups = node.groups",
                        "      .map((currentValue) => stringifyNode(currentValue))",
                        "      .join(node.groups[0]?.type === \"comma_group\" ? \",\" : \"\");",
                        "    const close = node.close?.value || \"\";",
                        "",
                        "    return open + groups + close;",
                        "  }",
                        "",
                        "  const before = node.raws?.before || \"\";",
                        "  const quote = node.raws?.quote || \"\";",
                        "  const atword = node.type === \"atword\" ? \"@\" : \"\";",
                        "  const value = node.value || \"\";",
                        "  const unit = node.unit || \"\";",
                        "  const group = node.group ? stringifyNode(node.group) : \"\";",
                        "  const after = node.raws?.after || \"\";",
                        "",
                        "  return before + quote + atword + value + quote + unit + group + after;",
                        "}",
                        "",
                        "export default stringifyNode;"
                    ]
                }
            }
        },
        "language-graphql": {
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys, \"kind\");",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-graphql.js\";",
                    "",
                    "export const printers = {",
                    "  graphql: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-graphql.js\"),",
                    "    parserNames: [\"graphql\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.GraphQL, () => ({",
                    "    parsers: [\"graphql\"],",
                    "    vscodeLanguageIds: [\"graphql\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(nodeOrToken) {",
                    "  return nodeOrToken.kind === \"Comment\"",
                    "    ? nodeOrToken.start",
                    "    : nodeOrToken.loc.start;",
                    "}",
                    "",
                    "function locEnd(nodeOrToken) {",
                    "  return nodeOrToken.kind === \"Comment\" ? nodeOrToken.end : nodeOrToken.loc.end;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { parse as parseGraphql } from \"graphql/language/parser.mjs\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "",
                    "function parseComments(ast) {",
                    "  const comments = [];",
                    "  const { startToken, endToken } = ast.loc;",
                    "  for (let token = startToken; token !== endToken; token = token.next) {",
                    "    if (token.kind === \"Comment\") {",
                    "      comments.push(token);",
                    "    }",
                    "  }",
                    "",
                    "  return comments;",
                    "}",
                    "",
                    "const parseOptions = {",
                    "  allowLegacyFragmentVariables: true,",
                    "};",
                    "",
                    "function createParseError(error) {",
                    "  if (error?.name === \"GraphQLError\") {",
                    "    const {",
                    "      message,",
                    "      locations: [start],",
                    "    } = error;",
                    "    return createError(message, { loc: { start }, cause: error });",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  return error;",
                    "}",
                    "",
                    "function parse(text /*, options */) {",
                    "  /** @type {any} */",
                    "  let ast;",
                    "  try {",
                    "    ast = parseGraphql(text, parseOptions);",
                    "  } catch (error) {",
                    "    throw createParseError(error);",
                    "  }",
                    "",
                    "  ast.comments = parseComments(ast);",
                    "  return ast;",
                    "}",
                    "",
                    "export const graphql = {",
                    "  parse,",
                    "  astFormat: \"graphql\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(?:format|prettier)\\s*(?:\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"# @format\\n\\n\" + text;",
                    "}",
                    "",
                    "export { hasPragma, insertPragma };"
                ]
            },
            "printer-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  join,",
                    "  hardline,",
                    "  line,",
                    "  softline,",
                    "  group,",
                    "  indent,",
                    "  ifBreak,",
                    "} from \"../document/builders.js\";",
                    "import isNextLineEmpty from \"../utils/is-next-line-empty.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import { insertPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "import printDescription from \"./print/description.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.kind) {",
                    "    case \"Document\":",
                    "      return [",
                    "        ...join(hardline, printSequence(path, options, print, \"definitions\")),",
                    "        hardline,",
                    "      ];",
                    "",
                    "    case \"OperationDefinition\": {",
                    "      const hasOperation = options.originalText[locStart(node)] !== \"{\";",
                    "      const hasName = Boolean(node.name);",
                    "      return [",
                    "        hasOperation ? node.operation : \"\",",
                    "        hasOperation && hasName ? [\" \", print(\"name\")] : \"\",",
                    "        hasOperation && !hasName && isNonEmptyArray(node.variableDefinitions)",
                    "          ? \" \"",
                    "          : \"\",",
                    "        printVariableDefinitions(path, print),",
                    "        printDirectives(path, print, node),",
                    "        !hasOperation && !hasName ? \"\" : \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "    }",
                    "    case \"FragmentDefinition\":",
                    "      return [",
                    "        \"fragment \",",
                    "        print(\"name\"),",
                    "        printVariableDefinitions(path, print),",
                    "        \" on \",",
                    "        print(\"typeCondition\"),",
                    "        printDirectives(path, print, node),",
                    "        \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "",
                    "    case \"SelectionSet\":",
                    "      return [",
                    "        \"{\",",
                    "        indent([",
                    "          hardline,",
                    "          join(hardline, printSequence(path, options, print, \"selections\")),",
                    "        ]),",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "",
                    "    case \"Field\":",
                    "      return group([",
                    "        node.alias ? [print(\"alias\"), \": \"] : \"\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.selectionSet ? \" \" : \"\",",
                    "        print(\"selectionSet\"),",
                    "      ]);",
                    "",
                    "    case \"Name\":",
                    "      return node.value;",
                    "",
                    "    case \"StringValue\":",
                    "      if (node.block) {",
                    "        const lines = node.value.replaceAll('\"\"\"', '\\\\\"\"\"').split(\"\\n\");",
                    "        if (lines.length === 1) {",
                    "          lines[0] = lines[0].trim();",
                    "        }",
                    "",
                    "        if (lines.every((line) => line === \"\")) {",
                    "          lines.length = 0;",
                    "        }",
                    "",
                    "        return join(hardline, ['\"\"\"', ...lines, '\"\"\"']);",
                    "      }",
                    "      return [",
                    "        '\"',",
                    "        node.value.replaceAll(/[\"\\\\]/g, \"\\\\$&\").replaceAll(\"\\n\", \"\\\\n\"),",
                    "        '\"',",
                    "      ];",
                    "",
                    "    case \"IntValue\":",
                    "    case \"FloatValue\":",
                    "    case \"EnumValue\":",
                    "      return node.value;",
                    "",
                    "    case \"BooleanValue\":",
                    "      return node.value ? \"true\" : \"false\";",
                    "",
                    "    case \"NullValue\":",
                    "      return \"null\";",
                    "",
                    "    case \"Variable\":",
                    "      return [\"$\", print(\"name\")];",
                    "",
                    "    case \"ListValue\":",
                    "      return group([",
                    "        \"[\",",
                    "        indent([",
                    "          softline,",
                    "          join([ifBreak(\"\", \", \"), softline], path.map(print, \"values\")),",
                    "        ]),",
                    "        softline,",
                    "        \"]\",",
                    "      ]);",
                    "",
                    "    case \"ObjectValue\": {",
                    "      const bracketSpace =",
                    "        options.bracketSpacing && node.fields.length > 0 ? \" \" : \"\";",
                    "      return group([",
                    "        \"{\",",
                    "        bracketSpace,",
                    "        indent([",
                    "          softline,",
                    "          join([ifBreak(\"\", \", \"), softline], path.map(print, \"fields\")),",
                    "        ]),",
                    "        softline,",
                    "        ifBreak(\"\", bracketSpace),",
                    "        \"}\",",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"ObjectField\":",
                    "    case \"Argument\":",
                    "      return [print(\"name\"), \": \", print(\"value\")];",
                    "",
                    "    case \"Directive\":",
                    "      return [",
                    "        \"@\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "      ];",
                    "",
                    "    case \"NamedType\":",
                    "      return print(\"name\");",
                    "",
                    "    case \"VariableDefinition\":",
                    "      return [",
                    "        print(\"variable\"),",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        node.defaultValue ? [\" = \", print(\"defaultValue\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"ObjectTypeExtension\":",
                    "    case \"ObjectTypeDefinition\":",
                    "    case \"InputObjectTypeExtension\":",
                    "    case \"InputObjectTypeDefinition\":",
                    "    case \"InterfaceTypeExtension\":",
                    "    case \"InterfaceTypeDefinition\": {",
                    "      const { kind } = node;",
                    "      const parts = [];",
                    "",
                    "      if (kind.endsWith(\"TypeDefinition\")) {",
                    "        parts.push(printDescription(path, options, print));",
                    "      } else {",
                    "        parts.push(\"extend \");",
                    "      }",
                    "",
                    "      if (kind.startsWith(\"ObjectType\")) {",
                    "        parts.push(\"type\");",
                    "      } else if (kind.startsWith(\"InputObjectType\")) {",
                    "        parts.push(\"input\");",
                    "      } else {",
                    "        parts.push(\"interface\");",
                    "      }",
                    "      parts.push(\" \", print(\"name\"));",
                    "",
                    "      if (!kind.startsWith(\"InputObjectType\") && node.interfaces.length > 0) {",
                    "        parts.push(\" implements \", ...printInterfaces(path, options, print));",
                    "      }",
                    "",
                    "      parts.push(printDirectives(path, print, node));",
                    "",
                    "      if (node.fields.length > 0) {",
                    "        parts.push([",
                    "          \" {\",",
                    "          indent([",
                    "            hardline,",
                    "            join(hardline, printSequence(path, options, print, \"fields\")),",
                    "          ]),",
                    "          hardline,",
                    "          \"}\",",
                    "        ]);",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "",
                    "    case \"FieldDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"DirectiveDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        \"directive \",",
                    "        \"@\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        node.repeatable ? \" repeatable\" : \"\",",
                    "        \" on \",",
                    "        ...join(\" | \", path.map(print, \"locations\")),",
                    "      ];",
                    "",
                    "    case \"EnumTypeExtension\":",
                    "    case \"EnumTypeDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        node.kind === \"EnumTypeExtension\" ? \"extend \" : \"\",",
                    "        \"enum \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "        node.values.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(hardline, printSequence(path, options, print, \"values\")),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "",
                    "    case \"EnumValueDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"InputValueDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        print(\"name\"),",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        node.defaultValue ? [\" = \", print(\"defaultValue\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"SchemaExtension\":",
                    "      return [",
                    "        \"extend schema\",",
                    "        printDirectives(path, print, node),",
                    "        ...(node.operationTypes.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  printSequence(path, options, print, \"operationTypes\")",
                    "                ),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : []),",
                    "      ];",
                    "",
                    "    case \"SchemaDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        \"schema\",",
                    "        printDirectives(path, print, node),",
                    "        \" {\",",
                    "        node.operationTypes.length > 0",
                    "          ? indent([",
                    "              hardline,",
                    "              join(",
                    "                hardline,",
                    "                printSequence(path, options, print, \"operationTypes\")",
                    "              ),",
                    "            ])",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "",
                    "    case \"OperationTypeDefinition\":",
                    "      return [node.operation, \": \", print(\"type\")];",
                    "",
                    "    case \"FragmentSpread\":",
                    "      return [\"...\", print(\"name\"), printDirectives(path, print, node)];",
                    "",
                    "    case \"InlineFragment\":",
                    "      return [",
                    "        \"...\",",
                    "        node.typeCondition ? [\" on \", print(\"typeCondition\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "        \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "",
                    "    case \"UnionTypeExtension\":",
                    "    case \"UnionTypeDefinition\":",
                    "      return group([",
                    "        printDescription(path, options, print),",
                    "        group([",
                    "          node.kind === \"UnionTypeExtension\" ? \"extend \" : \"\",",
                    "          \"union \",",
                    "          print(\"name\"),",
                    "          printDirectives(path, print, node),",
                    "          node.types.length > 0",
                    "            ? [",
                    "                \" =\",",
                    "                ifBreak(\"\", \" \"),",
                    "                indent([",
                    "                  ifBreak([line, \"  \"]),",
                    "                  join([line, \"| \"], path.map(print, \"types\")),",
                    "                ]),",
                    "              ]",
                    "            : \"\",",
                    "        ]),",
                    "      ]);",
                    "",
                    "    case \"ScalarTypeExtension\":",
                    "    case \"ScalarTypeDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        node.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\",",
                    "        \"scalar \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"NonNullType\":",
                    "      return [print(\"type\"), \"!\"];",
                    "",
                    "    case \"ListType\":",
                    "      return [\"[\", print(\"type\"), \"]\"];",
                    "",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"Graphql\", \"kind\");",
                    "  }",
                    "}",
                    "",
                    "function printDirectives(path, print, node) {",
                    "  if (node.directives.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const printed = join(line, path.map(print, \"directives\"));",
                    "",
                    "  if (",
                    "    node.kind === \"FragmentDefinition\" ||",
                    "    node.kind === \"OperationDefinition\"",
                    "  ) {",
                    "    return group([line, printed]);",
                    "  }",
                    "",
                    "  return [\" \", group(indent([softline, printed]))];",
                    "}",
                    "",
                    "function printSequence(path, options, print, property) {",
                    "  return path.map(({ isLast, node }) => {",
                    "    const printed = print();",
                    "",
                    "    if (!isLast && isNextLineEmpty(options.originalText, locEnd(node))) {",
                    "      return [printed, hardline];",
                    "    }",
                    "",
                    "    return printed;",
                    "  }, property);",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return node.kind !== \"Comment\";",
                    "}",
                    "",
                    "function printComment(commentPath) {",
                    "  const comment = commentPath.node;",
                    "  if (comment.kind === \"Comment\") {",
                    "    return \"#\" + comment.value.trimEnd();",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                    "}",
                    "",
                    "function printInterfaces(path, options, print) {",
                    "  const { node } = path;",
                    "  const parts = [];",
                    "  const { interfaces } = node;",
                    "  const printed = path.map(print, \"interfaces\");",
                    "",
                    "  for (let index = 0; index < interfaces.length; index++) {",
                    "    const interfaceNode = interfaces[index];",
                    "    parts.push(printed[index]);",
                    "    const nextInterfaceNode = interfaces[index + 1];",
                    "    if (nextInterfaceNode) {",
                    "      const textBetween = options.originalText.slice(",
                    "        interfaceNode.loc.end,",
                    "        nextInterfaceNode.loc.start",
                    "      );",
                    "      const hasComment = textBetween.includes(\"#\");",
                    "",
                    "      parts.push(\" &\", hasComment ? line : \" \");",
                    "    }",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printVariableDefinitions(path, print) {",
                    "  const { node } = path;",
                    "  if (!isNonEmptyArray(node.variableDefinitions)) {",
                    "    return \"\";",
                    "  }",
                    "  return group([",
                    "    \"(\",",
                    "    indent([",
                    "      softline,",
                    "      join(",
                    "        [ifBreak(\"\", \", \"), softline],",
                    "        path.map(print, \"variableDefinitions\")",
                    "      ),",
                    "    ]),",
                    "    softline,",
                    "    \")\",",
                    "  ]);",
                    "}",
                    "",
                    "function clean(node, newNode /* , parent */) {",
                    "  // We print single line `\"\"\" string \"\"\"` as multiple line string,",
                    "  // and the parser ignores space in multiple line string",
                    "  if (node.kind === \"StringValue\" && node.block && !node.value.includes(\"\\n\")) {",
                    "    newNode.value = newNode.value.trim();",
                    "  }",
                    "}",
                    "clean.ignoredProperties = new Set([\"loc\", \"comments\"]);",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const { node } = path;",
                    "  return node?.comments?.some(",
                    "    (comment) => comment.value.trim() === \"prettier-ignore\"",
                    "  );",
                    "}",
                    "",
                    "const printer = {",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  insertPragma,",
                    "  printComment,",
                    "  canAttachComment,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export { QueryDocumentKeys as default } from \"graphql/language/ast.mjs\";"
                ]
            },
            "print": {
                "description.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { hardline, line } from \"../../document/builders.js\";",
                        "",
                        "function printDescription(path, options, print) {",
                        "  const { node } = path;",
                        "  if (!node.description) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const parts = [print(\"description\")];",
                        "  if (node.kind === \"InputValueDefinition\" && !node.description.block) {",
                        "    parts.push(line);",
                        "  } else {",
                        "    parts.push(hardline);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export default printDescription;"
                    ]
                }
            }
        },
        "language-handlebars": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import htmlWhitespaceUtils from \"../utils/html-whitespace-utils.js\";",
                    "",
                    "function clean(ast, newNode /*, parent*/) {",
                    "  // (Glimmer/HTML) ignore TextNode",
                    "  if (ast.type === \"TextNode\") {",
                    "    const trimmed = ast.chars.trim();",
                    "    if (!trimmed) {",
                    "      return null;",
                    "    }",
                    "    newNode.chars = htmlWhitespaceUtils.split(trimmed).join(\" \");",
                    "  }",
                    "",
                    "  // `class` is reformatted",
                    "  if (ast.type === \"AttrNode\" && ast.name.toLowerCase() === \"class\") {",
                    "    delete newNode.value;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = new Set([\"loc\", \"selfClosing\"]);",
                    "",
                    "export default clean;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.evaluate.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "html-void-elements.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { voidMap } from \"@glimmer/syntax/dist/commonjs/es2017/lib/generation/printer.js\";",
                    "",
                    "export default Object.keys(voidMap);"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-glimmer.js\";",
                    "",
                    "export const printers = {",
                    "  glimmer: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-glimmer.js\"),",
                    "    parserNames: [\"glimmer\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.Handlebars, () => ({",
                    "    parsers: [\"glimmer\"],",
                    "    vscodeLanguageIds: [\"handlebars\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(node) {",
                    "  return node.loc.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.loc.end.offset;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "parser-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/*",
                    "  The module version `@glimmer/syntax/dist/modules/es2017/lib/parser/tokenizer-event-handlers.js`",
                    "  can't be be imported since it use `.js` extension, and don't have `type: module` in `package.json`",
                    "  We'll replace it during build",
                    "  */",
                    "import { preprocess as parseGlimmer } from \"@glimmer/syntax/dist/commonjs/es2017/lib/parser/tokenizer-event-handlers.js\";",
                    "import { LinesAndColumns } from \"lines-and-columns\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "",
                    "/* from the following template: `non-escaped mustache \\\\{{helper}}`",
                    " * glimmer parser will produce an AST missing a backslash",
                    " * so here we add it back",
                    " * */",
                    "function addBackslash(node) {",
                    "  const childrenOrBody = node.children ?? node.body;",
                    "  if (childrenOrBody) {",
                    "    for (let i = 0; i < childrenOrBody.length - 1; i++) {",
                    "      if (",
                    "        childrenOrBody[i].type === \"TextNode\" &&",
                    "        childrenOrBody[i + 1].type === \"MustacheStatement\"",
                    "      ) {",
                    "        childrenOrBody[i].chars = childrenOrBody[i].chars.replace(",
                    "          /\\\\$/,",
                    "          \"\\\\\\\\\"",
                    "        );",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "// Combine plugins to reduce traverse https://github.com/glimmerjs/glimmer-vm/blob/cdfb8f93d7ff0b504c8e9eab293f656a9b942025/packages/%40glimmer/syntax/lib/parser/tokenizer-event-handlers.ts#L442-L451",
                    "function createPlugin(text) {",
                    "  const lines = new LinesAndColumns(text);",
                    "  const calculateOffset = ({ line, column }) =>",
                    "    lines.indexForLocation({ line: line - 1, column });",
                    "",
                    "  // Add `loc.{start,end}.offset`",
                    "  const addOffset = (node) => {",
                    "    const { start, end } = node.loc;",
                    "    start.offset = calculateOffset(start);",
                    "    end.offset = calculateOffset(end);",
                    "  };",
                    "",
                    "  return (/* options*/) => ({",
                    "    name: \"prettierParsePlugin\",",
                    "    visitor: {",
                    "      All(node) {",
                    "        addOffset(node);",
                    "        addBackslash(node);",
                    "      },",
                    "    },",
                    "  });",
                    "}",
                    "",
                    "function parse(text /*, options */) {",
                    "  let ast;",
                    "  try {",
                    "    ast = parseGlimmer(text, {",
                    "      mode: \"codemod\",",
                    "      plugins: { ast: [createPlugin(text)] },",
                    "    });",
                    "  } catch (error) {",
                    "    const location = getErrorLocation(error);",
                    "",
                    "    if (location) {",
                    "      const message = getErrorMessage(error);",
                    "",
                    "      throw createError(message, { loc: location, cause: error });",
                    "    }",
                    "",
                    "    /* c8 ignore next */",
                    "    throw error;",
                    "  }",
                    "",
                    "  return ast;",
                    "}",
                    "",
                    "function getErrorMessage(error) {",
                    "  const { message } = error;",
                    "  const lines = message.split(\"\\n\");",
                    "",
                    "  /*",
                    "  This kind of errors are like:",
                    "",
                    "  ```",
                    "  Parse error on line 2:",
                    "  <A >x, {{@name}",
                    "  --------------^",
                    "  Expecting ...",
                    "  ```",
                    "  */",
                    "  if (",
                    "    lines.length >= 4 &&",
                    "    /^Parse error on line \\d+:$/.test(lines[0]) &&",
                    "    /^-*\\^$/.test(lines.at(-2))",
                    "  ) {",
                    "    return lines.at(-1);",
                    "  }",
                    "",
                    "  /*",
                    "  This kind of errors are like:",
                    "",
                    "  ```",
                    "  Unclosed element \\`@name\\`:",
                    "",
                    "  |",
                    "  |  <{@name>",
                    "  |",
                    "",
                    "  (error occurred in 'an unknown module' @ line 3 : column 0)",
                    "  ```",
                    "  */",
                    "  if (",
                    "    lines.length >= 4 &&",
                    "    /:\\s?$/.test(lines[0]) &&",
                    "    /^\\(error occurred in '.*?' @ line \\d+ : column \\d+\\)$/.test(",
                    "      lines.at(-1)",
                    "    ) &&",
                    "    lines[1] === \"\" &&",
                    "    lines.at(-2) === \"\" &&",
                    "    lines.slice(2, -2).every((line) => line.startsWith(\"|\"))",
                    "  ) {",
                    "    return lines[0].trim().slice(0, -1);",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  return message;",
                    "}",
                    "",
                    "function getErrorLocation(error) {",
                    "  const { location, hash } = error;",
                    "  if (location) {",
                    "    const { start, end } = location;",
                    "    if (typeof end.line !== \"number\") {",
                    "      return { start };",
                    "    }",
                    "    return location;",
                    "  }",
                    "",
                    "  if (hash) {",
                    "    const {",
                    "      loc: { last_line, last_column },",
                    "    } = hash;",
                    "    return { start: { line: last_line, column: last_column + 1 } };",
                    "  }",
                    "}",
                    "",
                    "export const glimmer = {",
                    "  parse,",
                    "  astFormat: \"glimmer\",",
                    "  locStart,",
                    "  locEnd,",
                    "};"
                ]
            },
            "printer-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  dedent,",
                    "  fill,",
                    "  group,",
                    "  hardline,",
                    "  ifBreak,",
                    "  indent,",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "} from \"../document/builders.js\";",
                    "import { replaceEndOfLine } from \"../document/utils.js\";",
                    "import getPreferredQuote from \"../utils/get-preferred-quote.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import htmlWhitespaceUtils from \"../utils/html-whitespace-utils.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import clean from \"./clean.js\";",
                    "import { hasPrettierIgnore, isVoidElement, isWhitespaceNode } from \"./utils.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                    " */",
                    "",
                    "const NEWLINES_TO_PRESERVE_MAX = 2;",
                    "",
                    "// Formatter based on @glimmerjs/syntax's built-in test formatter:",
                    "// https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts",
                    "",
                    "function print(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"Block\":",
                    "    case \"Program\":",
                    "    case \"Template\":",
                    "      return group(path.map(print, \"body\"));",
                    "",
                    "    case \"ElementNode\": {",
                    "      const startingTag = group(printStartingTag(path, print));",
                    "",
                    "      const escapeNextElementNode =",
                    "        options.htmlWhitespaceSensitivity === \"ignore\" &&",
                    "        path.next?.type === \"ElementNode\"",
                    "          ? softline",
                    "          : \"\";",
                    "",
                    "      if (isVoidElement(node)) {",
                    "        return [startingTag, escapeNextElementNode];",
                    "      }",
                    "",
                    "      const endingTag = [\"</\", node.tag, \">\"];",
                    "",
                    "      if (node.children.length === 0) {",
                    "        return [startingTag, indent(endingTag), escapeNextElementNode];",
                    "      }",
                    "",
                    "      if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "        return [",
                    "          startingTag,",
                    "          indent(printChildren(path, options, print)),",
                    "          hardline,",
                    "          indent(endingTag),",
                    "          escapeNextElementNode,",
                    "        ];",
                    "      }",
                    "",
                    "      return [",
                    "        startingTag,",
                    "        indent(group(printChildren(path, options, print))),",
                    "        indent(endingTag),",
                    "        escapeNextElementNode,",
                    "      ];",
                    "    }",
                    "",
                    "    case \"BlockStatement\":",
                    "      if (isElseIfLike(path)) {",
                    "        return [",
                    "          printElseIfLikeBlock(path, print),",
                    "          printProgram(path, print, options),",
                    "          printInverse(path, print, options),",
                    "        ];",
                    "      }",
                    "",
                    "      return [",
                    "        printOpenBlock(path, print),",
                    "        group([",
                    "          printProgram(path, print, options),",
                    "          printInverse(path, print, options),",
                    "          printCloseBlock(path, print, options),",
                    "        ]),",
                    "      ];",
                    "",
                    "    case \"ElementModifierStatement\":",
                    "      return group([\"{{\", printPathAndParams(path, print), \"}}\"]);",
                    "",
                    "    case \"MustacheStatement\":",
                    "      return group([",
                    "        printOpeningMustache(node),",
                    "        printPathAndParams(path, print),",
                    "        printClosingMustache(node),",
                    "      ]);",
                    "",
                    "    case \"SubExpression\":",
                    "      return group([",
                    "        \"(\",",
                    "        printSubExpressionPathAndParams(path, print),",
                    "        softline,",
                    "        \")\",",
                    "      ]);",
                    "",
                    "    case \"AttrNode\": {",
                    "      const { name, value } = node;",
                    "      const isText = value.type === \"TextNode\";",
                    "      const isEmptyText = isText && value.chars === \"\";",
                    "",
                    "      // If the text is empty and the value's loc start and end offsets are the",
                    "      // same, there is no value for this AttrNode and it should be printed",
                    "      // without the `=\"\"`. Example: `<img data-test>` -> `<img data-test>`",
                    "      if (isEmptyText && locStart(value) === locEnd(value)) {",
                    "        return name;",
                    "      }",
                    "",
                    "      // Let's assume quotes inside the content of text nodes are already",
                    "      // properly escaped with entities, otherwise the parse wouldn't have parsed them.",
                    "      const quote = isText",
                    "        ? getPreferredQuote(value.chars, options.singleQuote)",
                    "        : value.type === \"ConcatStatement\"",
                    "        ? getPreferredQuote(",
                    "            value.parts",
                    "              .map((part) => (part.type === \"TextNode\" ? part.chars : \"\"))",
                    "              .join(\"\"),",
                    "            options.singleQuote",
                    "          )",
                    "        : \"\";",
                    "",
                    "      const valueDoc = print(\"value\");",
                    "",
                    "      return [",
                    "        name,",
                    "        \"=\",",
                    "        quote,",
                    "        name === \"class\" && quote ? group(indent(valueDoc)) : valueDoc,",
                    "        quote,",
                    "      ];",
                    "    }",
                    "",
                    "    case \"ConcatStatement\":",
                    "      return path.map(print, \"parts\");",
                    "",
                    "    case \"Hash\":",
                    "      return join(line, path.map(print, \"pairs\"));",
                    "",
                    "    case \"HashPair\":",
                    "      return [node.key, \"=\", print(\"value\")];",
                    "",
                    "    case \"TextNode\": {",
                    "      /* if `{{my-component}}` (or any text containing \"{{\")",
                    "       * makes it to the TextNode, it means it was escaped,",
                    "       * so let's print it escaped, ie.; `\\{{my-component}}` */",
                    "      let text = node.chars.replaceAll(\"{{\", \"\\\\{{\");",
                    "",
                    "      const attrName = getCurrentAttributeName(path);",
                    "",
                    "      if (attrName) {",
                    "        // TODO: format style and srcset attributes",
                    "        if (attrName === \"class\") {",
                    "          const formattedClasses = text.trim().split(/\\s+/).join(\" \");",
                    "",
                    "          let leadingSpace = false;",
                    "          let trailingSpace = false;",
                    "",
                    "          if (path.parent.type === \"ConcatStatement\") {",
                    "            if (",
                    "              path.previous?.type === \"MustacheStatement\" &&",
                    "              /^\\s/.test(text)",
                    "            ) {",
                    "              leadingSpace = true;",
                    "            }",
                    "            if (",
                    "              path.next?.type === \"MustacheStatement\" &&",
                    "              /\\s$/.test(text) &&",
                    "              formattedClasses !== \"\"",
                    "            ) {",
                    "              trailingSpace = true;",
                    "            }",
                    "          }",
                    "",
                    "          return [",
                    "            leadingSpace ? line : \"\",",
                    "            formattedClasses,",
                    "            trailingSpace ? line : \"\",",
                    "          ];",
                    "        }",
                    "",
                    "        return replaceEndOfLine(text);",
                    "      }",
                    "",
                    "      const isWhitespaceOnly = htmlWhitespaceUtils.isWhitespaceOnly(text);",
                    "      const { isFirst, isLast } = path;",
                    "",
                    "      if (options.htmlWhitespaceSensitivity !== \"ignore\") {",
                    "        // let's remove the file's final newline",
                    "        // https://github.com/ember-cli/ember-new-output/blob/1a04c67ddd02ccb35e0ff41bb5cbce34b31173ef/.editorconfig#L16",
                    "        const shouldTrimTrailingNewlines =",
                    "          isLast && path.parent.type === \"Template\";",
                    "        const shouldTrimLeadingNewlines =",
                    "          isFirst && path.parent.type === \"Template\";",
                    "",
                    "        if (isWhitespaceOnly) {",
                    "          if (shouldTrimLeadingNewlines || shouldTrimTrailingNewlines) {",
                    "            return \"\";",
                    "          }",
                    "",
                    "          let breaks = [line];",
                    "",
                    "          const newlines = countNewLines(text);",
                    "          if (newlines) {",
                    "            breaks = generateHardlines(newlines);",
                    "          }",
                    "",
                    "          if (isLast) {",
                    "            breaks = breaks.map((newline) => dedent(newline));",
                    "          }",
                    "",
                    "          return breaks;",
                    "        }",
                    "",
                    "        const leadingWhitespace =",
                    "          htmlWhitespaceUtils.getLeadingWhitespace(text);",
                    "",
                    "        let leadBreaks = [];",
                    "        if (leadingWhitespace) {",
                    "          leadBreaks = [line];",
                    "",
                    "          const leadingNewlines = countNewLines(leadingWhitespace);",
                    "          if (leadingNewlines) {",
                    "            leadBreaks = generateHardlines(leadingNewlines);",
                    "          }",
                    "",
                    "          text = text.slice(leadingWhitespace.length);",
                    "        }",
                    "",
                    "        const tailingWhitespace =",
                    "          htmlWhitespaceUtils.getTrailingWhitespace(text);",
                    "        let trailBreaks = [];",
                    "        if (tailingWhitespace) {",
                    "          if (!shouldTrimTrailingNewlines) {",
                    "            trailBreaks = [line];",
                    "",
                    "            const trailingNewlines = countNewLines(tailingWhitespace);",
                    "            if (trailingNewlines) {",
                    "              trailBreaks = generateHardlines(trailingNewlines);",
                    "            }",
                    "",
                    "            if (isLast) {",
                    "              trailBreaks = trailBreaks.map((hardline) => dedent(hardline));",
                    "            }",
                    "          }",
                    "",
                    "          text = text.slice(0, -tailingWhitespace.length);",
                    "        }",
                    "",
                    "        return [...leadBreaks, fill(getTextValueParts(text)), ...trailBreaks];",
                    "      }",
                    "",
                    "      const lineBreaksCount = countNewLines(text);",
                    "",
                    "      let leadingLineBreaksCount = countLeadingNewLines(text);",
                    "      let trailingLineBreaksCount = countTrailingNewLines(text);",
                    "",
                    "      if (",
                    "        (isFirst || isLast) &&",
                    "        isWhitespaceOnly &&",
                    "        (path.parent.type === \"Block\" ||",
                    "          path.parent.type === \"ElementNode\" ||",
                    "          path.parent.type === \"Template\")",
                    "      ) {",
                    "        return \"\";",
                    "      }",
                    "",
                    "      if (isWhitespaceOnly && lineBreaksCount) {",
                    "        leadingLineBreaksCount = Math.min(",
                    "          lineBreaksCount,",
                    "          NEWLINES_TO_PRESERVE_MAX",
                    "        );",
                    "        trailingLineBreaksCount = 0;",
                    "      } else {",
                    "        if (",
                    "          path.next?.type === \"BlockStatement\" ||",
                    "          path.next?.type === \"ElementNode\"",
                    "        ) {",
                    "          trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);",
                    "        }",
                    "",
                    "        if (",
                    "          path.previous?.type === \"BlockStatement\" ||",
                    "          path.previous?.type === \"ElementNode\"",
                    "        ) {",
                    "          leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);",
                    "        }",
                    "      }",
                    "",
                    "      let leadingSpace = \"\";",
                    "      let trailingSpace = \"\";",
                    "",
                    "      if (",
                    "        trailingLineBreaksCount === 0 &&",
                    "        path.next?.type === \"MustacheStatement\"",
                    "      ) {",
                    "        trailingSpace = \" \";",
                    "      }",
                    "",
                    "      if (",
                    "        leadingLineBreaksCount === 0 &&",
                    "        path.previous?.type === \"MustacheStatement\"",
                    "      ) {",
                    "        leadingSpace = \" \";",
                    "      }",
                    "",
                    "      if (isFirst) {",
                    "        leadingLineBreaksCount = 0;",
                    "        leadingSpace = \"\";",
                    "      }",
                    "",
                    "      if (isLast) {",
                    "        trailingLineBreaksCount = 0;",
                    "        trailingSpace = \"\";",
                    "      }",
                    "",
                    "      if (htmlWhitespaceUtils.hasLeadingWhitespace(text)) {",
                    "        text = leadingSpace + htmlWhitespaceUtils.trimStart(text);",
                    "      }",
                    "",
                    "      if (htmlWhitespaceUtils.hasTrailingWhitespace(text)) {",
                    "        text = htmlWhitespaceUtils.trimEnd(text) + trailingSpace;",
                    "      }",
                    "",
                    "      return [",
                    "        ...generateHardlines(leadingLineBreaksCount),",
                    "        fill(getTextValueParts(text)),",
                    "        ...generateHardlines(trailingLineBreaksCount),",
                    "      ];",
                    "    }",
                    "    case \"MustacheCommentStatement\": {",
                    "      const start = locStart(node);",
                    "      const end = locEnd(node);",
                    "      // Starts with `{{~`",
                    "      const isLeftWhiteSpaceSensitive =",
                    "        options.originalText.charAt(start + 2) === \"~\";",
                    "      // Ends with `{{~`",
                    "      const isRightWhitespaceSensitive =",
                    "        options.originalText.charAt(end - 3) === \"~\";",
                    "",
                    "      const dashes = node.value.includes(\"}}\") ? \"--\" : \"\";",
                    "      return [",
                    "        \"{{\",",
                    "        isLeftWhiteSpaceSensitive ? \"~\" : \"\",",
                    "        \"!\",",
                    "        dashes,",
                    "        node.value,",
                    "        dashes,",
                    "        isRightWhitespaceSensitive ? \"~\" : \"\",",
                    "        \"}}\",",
                    "      ];",
                    "    }",
                    "    case \"PathExpression\":",
                    "      return node.original;",
                    "",
                    "    case \"BooleanLiteral\":",
                    "      return String(node.value);",
                    "",
                    "    case \"CommentStatement\":",
                    "      return [\"<!--\", node.value, \"-->\"];",
                    "",
                    "    case \"StringLiteral\":",
                    "      return printStringLiteral(path, options);",
                    "",
                    "    case \"NumberLiteral\":",
                    "      return String(node.value);",
                    "",
                    "    case \"UndefinedLiteral\":",
                    "      return \"undefined\";",
                    "",
                    "    case \"NullLiteral\":",
                    "      return \"null\";",
                    "",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"Handlebars\");",
                    "  }",
                    "}",
                    "",
                    "/* ElementNode print helpers */",
                    "",
                    "function sortByLoc(a, b) {",
                    "  return locStart(a) - locStart(b);",
                    "}",
                    "",
                    "function printStartingTag(path, print) {",
                    "  const { node } = path;",
                    "",
                    "  const types = [\"attributes\", \"modifiers\", \"comments\"].filter((property) =>",
                    "    isNonEmptyArray(node[property])",
                    "  );",
                    "  const attributes = types.flatMap((type) => node[type]).sort(sortByLoc);",
                    "",
                    "  for (const attributeType of types) {",
                    "    path.each(({ node }) => {",
                    "      const index = attributes.indexOf(node);",
                    "      attributes.splice(index, 1, [line, print()]);",
                    "    }, attributeType);",
                    "  }",
                    "",
                    "  if (isNonEmptyArray(node.blockParams)) {",
                    "    attributes.push(line, printBlockParams(node));",
                    "  }",
                    "",
                    "  return [\"<\", node.tag, indent(attributes), printStartingTagEndMarker(node)];",
                    "}",
                    "",
                    "function printChildren(path, options, print) {",
                    "  const { node } = path;",
                    "  const isEmpty = node.children.every((node) => isWhitespaceNode(node));",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\" && isEmpty) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return path.map(({ isFirst }) => {",
                    "    const printedChild = print();",
                    "",
                    "    if (isFirst && options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "      return [softline, printedChild];",
                    "    }",
                    "",
                    "    return printedChild;",
                    "  }, \"children\");",
                    "}",
                    "",
                    "function printStartingTagEndMarker(node) {",
                    "  if (isVoidElement(node)) {",
                    "    return ifBreak([softline, \"/>\"], [\" />\", softline]);",
                    "  }",
                    "",
                    "  return ifBreak([softline, \">\"], \">\");",
                    "}",
                    "",
                    "/* MustacheStatement print helpers */",
                    "",
                    "function printOpeningMustache(node) {",
                    "  const mustache = node.escaped === false ? \"{{{\" : \"{{\";",
                    "  const strip = node.strip?.open ? \"~\" : \"\";",
                    "  return [mustache, strip];",
                    "}",
                    "",
                    "function printClosingMustache(node) {",
                    "  const mustache = node.escaped === false ? \"}}}\" : \"}}\";",
                    "  const strip = node.strip?.close ? \"~\" : \"\";",
                    "  return [strip, mustache];",
                    "}",
                    "",
                    "/* BlockStatement print helpers */",
                    "",
                    "function printOpeningBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.openStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip, \"#\"];",
                    "}",
                    "",
                    "function printOpeningBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.openStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printClosingBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.closeStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip, \"/\"];",
                    "}",
                    "",
                    "function printClosingBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.closeStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printInverseBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.inverseStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip];",
                    "}",
                    "",
                    "function printInverseBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.inverseStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printOpenBlock(path, print) {",
                    "  const { node } = path;",
                    "  /** @type {Doc[]} */",
                    "  const parts = [];",
                    "",
                    "  const paramsDoc = printParams(path, print);",
                    "  if (paramsDoc) {",
                    "    parts.push(group(paramsDoc));",
                    "  }",
                    "",
                    "  if (isNonEmptyArray(node.program.blockParams)) {",
                    "    parts.push(printBlockParams(node.program));",
                    "  }",
                    "",
                    "  return group([",
                    "    printOpeningBlockOpeningMustache(node),",
                    "    printPath(path, print),",
                    "    parts.length > 0 ? indent([line, join(line, parts)]) : \"\",",
                    "    softline,",
                    "    printOpeningBlockClosingMustache(node),",
                    "  ]);",
                    "}",
                    "",
                    "function printElseBlock(node, options) {",
                    "  return [",
                    "    options.htmlWhitespaceSensitivity === \"ignore\" ? hardline : \"\",",
                    "    printInverseBlockOpeningMustache(node),",
                    "    \"else\",",
                    "    printInverseBlockClosingMustache(node),",
                    "  ];",
                    "}",
                    "",
                    "function isElseIfLike(path) {",
                    "  const { grandparent, node } = path;",
                    "  return (",
                    "    grandparent?.inverse?.body.length === 1 &&",
                    "    grandparent.inverse.body[0] === node &&",
                    "    grandparent.inverse.body[0].path.parts[0] === grandparent.path.parts[0]",
                    "  );",
                    "}",
                    "",
                    "function printElseIfLikeBlock(path, print) {",
                    "  const { node, grandparent } = path;",
                    "  return group([",
                    "    printInverseBlockOpeningMustache(grandparent),",
                    "    [\"else\", \" \", grandparent.inverse.body[0].path.parts[0]],",
                    "    indent([",
                    "      line,",
                    "      group(printParams(path, print)),",
                    "      ...(isNonEmptyArray(node.program.blockParams)",
                    "        ? [line, printBlockParams(node.program)]",
                    "        : []),",
                    "    ]),",
                    "    softline,",
                    "    printInverseBlockClosingMustache(grandparent),",
                    "  ]);",
                    "}",
                    "",
                    "function printCloseBlock(path, print, options) {",
                    "  const { node } = path;",
                    "",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "    const escape = blockStatementHasOnlyWhitespaceInProgram(node)",
                    "      ? softline",
                    "      : hardline;",
                    "",
                    "    return [",
                    "      escape,",
                    "      printClosingBlockOpeningMustache(node),",
                    "      print(\"path\"),",
                    "      printClosingBlockClosingMustache(node),",
                    "    ];",
                    "  }",
                    "",
                    "  return [",
                    "    printClosingBlockOpeningMustache(node),",
                    "    print(\"path\"),",
                    "    printClosingBlockClosingMustache(node),",
                    "  ];",
                    "}",
                    "",
                    "function blockStatementHasOnlyWhitespaceInProgram(node) {",
                    "  return (",
                    "    node.type === \"BlockStatement\" &&",
                    "    node.program.body.every((node) => isWhitespaceNode(node))",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElseIfLike(node) {",
                    "  return (",
                    "    blockStatementHasElse(node) &&",
                    "    node.inverse.body.length === 1 &&",
                    "    node.inverse.body[0].type === \"BlockStatement\" &&",
                    "    node.inverse.body[0].path.parts[0] === node.path.parts[0]",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElse(node) {",
                    "  return node.type === \"BlockStatement\" && node.inverse;",
                    "}",
                    "",
                    "function printProgram(path, print, options) {",
                    "  const { node } = path;",
                    "",
                    "  if (blockStatementHasOnlyWhitespaceInProgram(node)) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const program = print(\"program\");",
                    "",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "    return indent([hardline, program]);",
                    "  }",
                    "",
                    "  return indent(program);",
                    "}",
                    "",
                    "function printInverse(path, print, options) {",
                    "  const { node } = path;",
                    "",
                    "  const inverse = print(\"inverse\");",
                    "  const printed =",
                    "    options.htmlWhitespaceSensitivity === \"ignore\"",
                    "      ? [hardline, inverse]",
                    "      : inverse;",
                    "",
                    "  if (blockStatementHasElseIfLike(node)) {",
                    "    return printed;",
                    "  }",
                    "",
                    "  if (blockStatementHasElse(node)) {",
                    "    return [printElseBlock(node, options), indent(printed)];",
                    "  }",
                    "",
                    "  return \"\";",
                    "}",
                    "",
                    "/* TextNode print helpers */",
                    "",
                    "function getTextValueParts(value) {",
                    "  return join(line, htmlWhitespaceUtils.split(value));",
                    "}",
                    "",
                    "function getCurrentAttributeName(path) {",
                    "  for (let depth = 0; depth < 2; depth++) {",
                    "    const parentNode = path.getParentNode(depth);",
                    "    if (parentNode?.type === \"AttrNode\") {",
                    "      return parentNode.name.toLowerCase();",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function countNewLines(string) {",
                    "  /* c8 ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  return string.split(\"\\n\").length - 1;",
                    "}",
                    "",
                    "function countLeadingNewLines(string) {",
                    "  /* c8 ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/^([^\\S\\n\\r]*[\\n\\r])+/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function countTrailingNewLines(string) {",
                    "  /* c8 ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/([\\n\\r][^\\S\\n\\r]*)+$/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function generateHardlines(number = 0) {",
                    "  return Array.from({",
                    "    length: Math.min(number, NEWLINES_TO_PRESERVE_MAX),",
                    "  }).fill(hardline);",
                    "}",
                    "",
                    "/* StringLiteral print helpers */",
                    "",
                    "/** @typedef {import(\"../utils/get-preferred-quote.js\").Quote} Quote */",
                    "",
                    "/**",
                    " * Prints a string literal with the correct surrounding quotes based on",
                    " * `options.singleQuote` and the number of escaped quotes contained in",
                    " * the string literal. This function is the glimmer equivalent of `printString`",
                    " * in `common/util`, but has differences because of the way escaped characters",
                    " * are treated in hbs string literals.",
                    " */",
                    "function printStringLiteral(path, options) {",
                    "  const {",
                    "    node: { value },",
                    "  } = path;",
                    "",
                    "  const quote = getPreferredQuote(",
                    "    value,",
                    "    needsOppositeQuote(path) ? !options.singleQuote : options.singleQuote",
                    "  );",
                    "",
                    "  return [quote, value.replaceAll(quote, `\\\\${quote}`), quote];",
                    "}",
                    "",
                    "function needsOppositeQuote(path) {",
                    "  const { ancestors } = path;",
                    "  const level = ancestors.findIndex((node) => node.type !== \"SubExpression\");",
                    "",
                    "  return (",
                    "    level !== -1 &&",
                    "    ancestors[level + 1].type === \"ConcatStatement\" &&",
                    "    ancestors[level + 2].type === \"AttrNode\"",
                    "  );",
                    "}",
                    "",
                    "/* SubExpression print helpers */",
                    "",
                    "function printSubExpressionPathAndParams(path, print) {",
                    "  const printed = printPath(path, print);",
                    "  const params = printParams(path, print);",
                    "",
                    "  if (!params) {",
                    "    return printed;",
                    "  }",
                    "",
                    "  return indent([printed, line, group(params)]);",
                    "}",
                    "",
                    "/* misc. print helpers */",
                    "",
                    "function printPathAndParams(path, print) {",
                    "  const pathDoc = printPath(path, print);",
                    "  const paramsDoc = printParams(path, print);",
                    "",
                    "  if (!paramsDoc) {",
                    "    return pathDoc;",
                    "  }",
                    "",
                    "  return [indent([pathDoc, line, paramsDoc]), softline];",
                    "}",
                    "",
                    "function printPath(path, print) {",
                    "  return print(\"path\");",
                    "}",
                    "",
                    "function printParams(path, print) {",
                    "  const { node } = path;",
                    "  const parts = [];",
                    "",
                    "  if (node.params.length > 0) {",
                    "    parts.push(...path.map(print, \"params\"));",
                    "  }",
                    "",
                    "  if (node.hash?.pairs.length > 0) {",
                    "    parts.push(print(\"hash\"));",
                    "  }",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return join(line, parts);",
                    "}",
                    "",
                    "function printBlockParams(node) {",
                    "  return [\"as |\", node.blockParams.join(\" \"), \"|\"];",
                    "}",
                    "",
                    "const printer = {",
                    "  print,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import htmlVoidElements from \"./html-void-elements.evaluate.js\";",
                    "",
                    "function isUppercase(string) {",
                    "  return string.toUpperCase() === string;",
                    "}",
                    "",
                    "function isGlimmerComponent(node) {",
                    "  return (",
                    "    node.type === \"ElementNode\" &&",
                    "    typeof node.tag === \"string\" &&",
                    "    !node.tag.startsWith(\":\") &&",
                    "    (isUppercase(node.tag[0]) || node.tag.includes(\".\"))",
                    "  );",
                    "}",
                    "",
                    "const voidTags = new Set(htmlVoidElements);",
                    "// https://github.com/glimmerjs/glimmer-vm/blob/ec5648f3895b9ab8d085523be001553746221449/packages/%40glimmer/syntax/lib/generation/printer.ts#L44-L46",
                    "function isVoidTag(tag) {",
                    "  return voidTags.has(tag.toLowerCase()) && !isUppercase(tag[0]);",
                    "}",
                    "",
                    "function isVoidElement(node) {",
                    "  return (",
                    "    node.selfClosing === true ||",
                    "    isVoidTag(node.tag) ||",
                    "    (isGlimmerComponent(node) &&",
                    "      node.children.every((node) => isWhitespaceNode(node)))",
                    "  );",
                    "}",
                    "",
                    "function isWhitespaceNode(node) {",
                    "  return node.type === \"TextNode\" && !/\\S/.test(node.chars);",
                    "}",
                    "",
                    "function isPrettierIgnoreNode(node) {",
                    "  return (",
                    "    node?.type === \"MustacheCommentStatement\" &&",
                    "    typeof node.value === \"string\" &&",
                    "    node.value.trim() === \"prettier-ignore\"",
                    "  );",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  return (",
                    "    isPrettierIgnoreNode(path.node) ||",
                    "    (path.isInArray &&",
                    "      (path.key === \"children\" ||",
                    "        path.key === \"body\" ||",
                    "        path.key === \"parts\") &&",
                    "      isPrettierIgnoreNode(path.siblings[path.index - 2]))",
                    "  );",
                    "}",
                    "",
                    "export { hasPrettierIgnore, isVoidElement, isWhitespaceNode };"
                ]
            },
            "visitor-keys.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import visitorKeys from \"@glimmer/syntax/dist/commonjs/es2017/lib/v1/visitor-keys.js\";",
                    "",
                    "export default visitorKeys.default;"
                ]
            }
        },
        "language-html": {
            "ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const NODES_KEYS = {",
                    "  attrs: true,",
                    "  children: true,",
                    "};",
                    "",
                    "const NON_ENUMERABLE_PROPERTIES = new Set([\"parent\"]);",
                    "",
                    "// TODO: typechecking is problematic for this class because of this issue:",
                    "// https://github.com/microsoft/TypeScript/issues/26811",
                    "",
                    "class Node {",
                    "  constructor(nodeOrProperties = {}) {",
                    "    for (const property of new Set([",
                    "      ...NON_ENUMERABLE_PROPERTIES,",
                    "      ...Object.keys(nodeOrProperties),",
                    "    ])) {",
                    "      this.setProperty(property, nodeOrProperties[property]);",
                    "    }",
                    "  }",
                    "",
                    "  setProperty(property, value) {",
                    "    if (this[property] === value) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (property in NODES_KEYS) {",
                    "      value = value.map((node) => this.createChild(node));",
                    "    }",
                    "",
                    "    if (!NON_ENUMERABLE_PROPERTIES.has(property)) {",
                    "      this[property] = value;",
                    "      return;",
                    "    }",
                    "",
                    "    Object.defineProperty(this, property, {",
                    "      value,",
                    "      enumerable: false,",
                    "      configurable: true,",
                    "    });",
                    "  }",
                    "",
                    "  map(fn) {",
                    "    /** @type{any} */",
                    "    let newNode;",
                    "",
                    "    for (const NODES_KEY in NODES_KEYS) {",
                    "      const nodes = this[NODES_KEY];",
                    "      if (nodes) {",
                    "        const mappedNodes = mapNodesIfChanged(nodes, (node) => node.map(fn));",
                    "        if (newNode !== nodes) {",
                    "          if (!newNode) {",
                    "            // @ts-expect-error",
                    "            newNode = new Node({ parent: this.parent });",
                    "          }",
                    "          newNode.setProperty(NODES_KEY, mappedNodes);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (newNode) {",
                    "      for (const key in this) {",
                    "        if (!(key in NODES_KEYS)) {",
                    "          newNode[key] = this[key];",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return fn(newNode || this);",
                    "  }",
                    "",
                    "  walk(fn) {",
                    "    for (const NODES_KEY in NODES_KEYS) {",
                    "      const nodes = this[NODES_KEY];",
                    "      if (nodes) {",
                    "        for (let i = 0; i < nodes.length; i++) {",
                    "          nodes[i].walk(fn);",
                    "        }",
                    "      }",
                    "    }",
                    "    fn(this);",
                    "  }",
                    "",
                    "  createChild(nodeOrProperties) {",
                    "    const node =",
                    "      nodeOrProperties instanceof Node",
                    "        ? nodeOrProperties.clone()",
                    "        : new Node(nodeOrProperties);",
                    "    node.setProperty(\"parent\", this);",
                    "    return node;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [target]",
                    "   * @param {Object} [node]",
                    "   */",
                    "  insertChildBefore(target, node) {",
                    "    // @ts-expect-error",
                    "    this.children.splice(",
                    "      // @ts-expect-error",
                    "      this.children.indexOf(target),",
                    "      0,",
                    "      this.createChild(node)",
                    "    );",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [child]",
                    "   */",
                    "  removeChild(child) {",
                    "    // @ts-expect-error",
                    "    this.children.splice(this.children.indexOf(child), 1);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [target]",
                    "   * @param {Object} [node]",
                    "   */",
                    "  replaceChild(target, node) {",
                    "    // @ts-expect-error",
                    "    this.children[this.children.indexOf(target)] = this.createChild(node);",
                    "  }",
                    "",
                    "  clone() {",
                    "    return new Node(this);",
                    "  }",
                    "",
                    "  get firstChild() {",
                    "    // @ts-expect-error",
                    "    return this.children?.[0];",
                    "  }",
                    "",
                    "  get lastChild() {",
                    "    // @ts-expect-error",
                    "    return this.children?.[this.children.length - 1];",
                    "  }",
                    "",
                    "  get prev() {",
                    "    // @ts-expect-error",
                    "    return this.parent?.children[this.parent.children.indexOf(this) - 1];",
                    "  }",
                    "",
                    "  get next() {",
                    "    // @ts-expect-error",
                    "    return this.parent?.children[this.parent.children.indexOf(this) + 1];",
                    "  }",
                    "",
                    "  // for element and attribute",
                    "  get rawName() {",
                    "    // @ts-expect-error",
                    "    return this.hasExplicitNamespace ? this.fullName : this.name;",
                    "  }",
                    "",
                    "  get fullName() {",
                    "    // @ts-expect-error",
                    "    return this.namespace ? this.namespace + \":\" + this.name : this.name;",
                    "  }",
                    "",
                    "  get attrMap() {",
                    "    return Object.fromEntries(",
                    "      // @ts-expect-error",
                    "      this.attrs.map((attr) => [attr.fullName, attr.value])",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function mapNodesIfChanged(nodes, fn) {",
                    "  const newNodes = nodes.map(fn);",
                    "  return newNodes.some((newNode, index) => newNode !== nodes[index])",
                    "    ? newNodes",
                    "    : nodes;",
                    "}",
                    "",
                    "export { Node };"
                ]
            },
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isFrontMatter from \"../utils/front-matter/is-front-matter.js\";",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"sourceSpan\",",
                    "  \"startSourceSpan\",",
                    "  \"endSourceSpan\",",
                    "  \"nameSpan\",",
                    "  \"valueSpan\",",
                    "  \"keySpan\",",
                    "  \"tagDefinition\",",
                    "  \"tokens\",",
                    "  \"valueTokens\",",
                    "]);",
                    "",
                    "function clean(ast, newNode) {",
                    "  if (ast.type === \"text\" || ast.type === \"comment\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // may be formatted by multiparser",
                    "  if (isFrontMatter(ast) || ast.type === \"yaml\" || ast.type === \"toml\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"attribute\") {",
                    "    delete newNode.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"docType\") {",
                    "    delete newNode.value;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "export default clean;"
                ]
            },
            "conditional-comment.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { ParseSourceSpan } from \"angular-html-parser\";",
                    "",
                    "// https://css-tricks.com/how-to-create-an-ie-only-stylesheet",
                    "",
                    "const parseFunctions = [",
                    "  {",
                    "    // <!--[if ... ]> ... <![endif]-->",
                    "    regex: /^(\\[if([^\\]]*)]>)(.*?)<!\\s*\\[endif]$/s,",
                    "    parse: parseIeConditionalStartEndComment,",
                    "  },",
                    "  {",
                    "    // <!--[if ... ]><!-->",
                    "    regex: /^\\[if([^\\]]*)]><!$/,",
                    "    parse: parseIeConditionalStartComment,",
                    "  },",
                    "  {",
                    "    // <!--<![endif]-->",
                    "    regex: /^<!\\s*\\[endif]$/,",
                    "    parse: parseIeConditionalEndComment,",
                    "  },",
                    "];",
                    "",
                    "function parseIeConditionalComment(node, parseHtml) {",
                    "  if (node.value) {",
                    "    for (const { regex, parse } of parseFunctions) {",
                    "      const match = node.value.match(regex);",
                    "      if (match) {",
                    "        return parse(node, parseHtml, match);",
                    "      }",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function parseIeConditionalStartEndComment(node, parseHtml, match) {",
                    "  const [, openingTagSuffix, condition, data] = match;",
                    "  const offset = \"<!--\".length + openingTagSuffix.length;",
                    "  const contentStartSpan = node.sourceSpan.start.moveBy(offset);",
                    "  const contentEndSpan = contentStartSpan.moveBy(data.length);",
                    "  const [complete, children] = (() => {",
                    "    try {",
                    "      return [true, parseHtml(data, contentStartSpan).children];",
                    "    } catch {",
                    "      const text = {",
                    "        type: \"text\",",
                    "        value: data,",
                    "        sourceSpan: new ParseSourceSpan(contentStartSpan, contentEndSpan),",
                    "      };",
                    "      return [false, [text]];",
                    "    }",
                    "  })();",
                    "  return {",
                    "    type: \"ieConditionalComment\",",
                    "    complete,",
                    "    children,",
                    "    condition: condition.trim().replaceAll(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "    startSourceSpan: new ParseSourceSpan(",
                    "      node.sourceSpan.start,",
                    "      contentStartSpan",
                    "    ),",
                    "    endSourceSpan: new ParseSourceSpan(contentEndSpan, node.sourceSpan.end),",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalStartComment(node, parseHtml, match) {",
                    "  const [, condition] = match;",
                    "  return {",
                    "    type: \"ieConditionalStartComment\",",
                    "    condition: condition.trim().replaceAll(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalEndComment(node /*, parseHtml, match */) {",
                    "  return {",
                    "    type: \"ieConditionalEndComment\",",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "export { parseIeConditionalComment };"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import htmlStyles from \"html-styles\";",
                    "",
                    "const getCssStyleTags = (property) =>",
                    "  Object.fromEntries(",
                    "    htmlStyles",
                    "      .filter((htmlStyle) => htmlStyle.style[property])",
                    "      .flatMap((htmlStyle) =>",
                    "        htmlStyle.selectorText",
                    "          .split(\",\")",
                    "          .map((selector) => selector.trim())",
                    "          .filter((selector) => /^[\\dA-Za-z]+$/.test(selector))",
                    "          .map((tagName) => [tagName, htmlStyle.style[property]])",
                    "      )",
                    "  );",
                    "",
                    "const CSS_DISPLAY_TAGS = {",
                    "  ...getCssStyleTags(\"display\"),",
                    "",
                    "  // TODO: send PR to upstream",
                    "  button: \"inline-block\",",
                    "",
                    "  // special cases for some css display=none elements",
                    "  template: \"inline\",",
                    "  source: \"block\",",
                    "  track: \"block\",",
                    "  script: \"block\",",
                    "  param: \"block\",",
                    "",
                    "  // `noscript` is inline",
                    "  // noscript: \"inline\",",
                    "",
                    "  // there's no css display for these elements but they behave these ways",
                    "  details: \"block\",",
                    "  summary: \"block\",",
                    "  dialog: \"block\",",
                    "  meter: \"inline-block\",",
                    "  progress: \"inline-block\",",
                    "  object: \"inline-block\",",
                    "  video: \"inline-block\",",
                    "  audio: \"inline-block\",",
                    "  select: \"inline-block\",",
                    "  option: \"block\",",
                    "  optgroup: \"block\",",
                    "",
                    "  // Missing",
                    "  search: \"block\",",
                    "};",
                    "const CSS_DISPLAY_DEFAULT = \"inline\";",
                    "const CSS_WHITE_SPACE_TAGS = getCssStyleTags(\"white-space\");",
                    "const CSS_WHITE_SPACE_DEFAULT = \"normal\";",
                    "",
                    "export {",
                    "  CSS_DISPLAY_TAGS,",
                    "  CSS_DISPLAY_DEFAULT,",
                    "  CSS_WHITE_SPACE_TAGS,",
                    "  CSS_WHITE_SPACE_DEFAULT,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  breakParent,",
                    "  group,",
                    "  hardline,",
                    "  indent,",
                    "  line,",
                    "} from \"../document/builders.js\";",
                    "import printFrontMatter from \"../utils/front-matter/print.js\";",
                    "import {",
                    "  printClosingTag,",
                    "  printClosingTagSuffix,",
                    "  needsToBorrowPrevClosingTagEndMarker,",
                    "  printOpeningTagPrefix,",
                    "  printOpeningTag,",
                    "} from \"./print/tag.js\";",
                    "import {",
                    "  isScriptLikeTag,",
                    "  isVueNonHtmlBlock,",
                    "  inferElementParser,",
                    "  htmlTrimPreserveIndentation,",
                    "  dedentString,",
                    "} from \"./utils/index.js\";",
                    "import isVueSfcWithTypescriptScript from \"./utils/is-vue-sfc-with-typescript-script.js\";",
                    "import getNodeContent from \"./get-node-content.js\";",
                    "import printAttribute from \"./embed/attribute.js\";",
                    "",
                    "function embed(path, options) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"element\":",
                    "      if (isScriptLikeTag(node) || node.type === \"interpolation\") {",
                    "        // Fall through to \"text\"",
                    "        return;",
                    "      }",
                    "",
                    "      if (!node.isSelfClosing && isVueNonHtmlBlock(node, options)) {",
                    "        const parser = inferElementParser(node, options);",
                    "        if (!parser) {",
                    "          return;",
                    "        }",
                    "",
                    "        return async (textToDoc, print) => {",
                    "          const content = getNodeContent(node, options);",
                    "          let isEmpty = /^\\s*$/.test(content);",
                    "          let doc = \"\";",
                    "          if (!isEmpty) {",
                    "            doc = await textToDoc(htmlTrimPreserveIndentation(content), {",
                    "              parser,",
                    "              __embeddedInHtml: true,",
                    "            });",
                    "            isEmpty = doc === \"\";",
                    "          }",
                    "",
                    "          return [",
                    "            printOpeningTagPrefix(node, options),",
                    "            group(printOpeningTag(path, options, print)),",
                    "            isEmpty ? \"\" : hardline,",
                    "            doc,",
                    "            isEmpty ? \"\" : hardline,",
                    "            printClosingTag(node, options),",
                    "            printClosingTagSuffix(node, options),",
                    "          ];",
                    "        };",
                    "      }",
                    "      break;",
                    "",
                    "    case \"text\":",
                    "      if (isScriptLikeTag(node.parent)) {",
                    "        const parser = inferElementParser(node.parent, options);",
                    "        if (parser) {",
                    "          return async (textToDoc) => {",
                    "            const value =",
                    "              parser === \"markdown\"",
                    "                ? dedentString(node.value.replace(/^[^\\S\\n]*\\n/, \"\"))",
                    "                : node.value;",
                    "            const textToDocOptions = { parser, __embeddedInHtml: true };",
                    "            if (options.parser === \"html\" && parser === \"babel\") {",
                    "              let sourceType = \"script\";",
                    "              const { attrMap } = node.parent;",
                    "              if (",
                    "                attrMap &&",
                    "                (attrMap.type === \"module\" ||",
                    "                  (attrMap.type === \"text/babel\" &&",
                    "                    attrMap[\"data-type\"] === \"module\"))",
                    "              ) {",
                    "                sourceType = \"module\";",
                    "              }",
                    "              textToDocOptions.__babelSourceType = sourceType;",
                    "            }",
                    "",
                    "            return [",
                    "              breakParent,",
                    "              printOpeningTagPrefix(node, options),",
                    "              await textToDoc(value, textToDocOptions, {",
                    "                stripTrailingHardline: true,",
                    "              }),",
                    "              printClosingTagSuffix(node, options),",
                    "            ];",
                    "          };",
                    "        }",
                    "      } else if (node.parent.type === \"interpolation\") {",
                    "        return async (textToDoc) => {",
                    "          const textToDocOptions = {",
                    "            __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                    "            __embeddedInHtml: true,",
                    "          };",
                    "          if (options.parser === \"angular\") {",
                    "            textToDocOptions.parser = \"__ng_interpolation\";",
                    "            textToDocOptions.trailingComma = \"none\";",
                    "          } else if (options.parser === \"vue\") {",
                    "            textToDocOptions.parser = isVueSfcWithTypescriptScript(",
                    "              path,",
                    "              options",
                    "            )",
                    "              ? \"__vue_ts_expression\"",
                    "              : \"__vue_expression\";",
                    "          } else {",
                    "            textToDocOptions.parser = \"__js_expression\";",
                    "          }",
                    "",
                    "          return [",
                    "            indent([line, await textToDoc(node.value, textToDocOptions)]),",
                    "            node.parent.next &&",
                    "            needsToBorrowPrevClosingTagEndMarker(node.parent.next)",
                    "              ? \" \"",
                    "              : line,",
                    "          ];",
                    "        };",
                    "      }",
                    "      break;",
                    "",
                    "    case \"attribute\":",
                    "      return printAttribute(path, options);",
                    "",
                    "    case \"front-matter\":",
                    "      return (textToDoc) => printFrontMatter(node, textToDoc);",
                    "  }",
                    "}",
                    "",
                    "export default embed;"
                ]
            },
            "get-node-content.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  needsToBorrowParentClosingTagStartMarker,",
                    "  printClosingTagStartMarker,",
                    "  needsToBorrowLastChildClosingTagEndMarker,",
                    "  printClosingTagEndMarker,",
                    "  needsToBorrowParentOpeningTagEndMarker,",
                    "  printOpeningTagEndMarker,",
                    "} from \"./print/tag.js\";",
                    "",
                    "function getNodeContent(node, options) {",
                    "  if (!node.endSourceSpan) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  let start = node.startSourceSpan.end.offset;",
                    "  if (",
                    "    node.firstChild &&",
                    "    needsToBorrowParentOpeningTagEndMarker(node.firstChild)",
                    "  ) {",
                    "    start -= printOpeningTagEndMarker(node).length;",
                    "  }",
                    "",
                    "  let end = node.endSourceSpan.start.offset;",
                    "  if (",
                    "    node.lastChild &&",
                    "    needsToBorrowParentClosingTagStartMarker(node.lastChild)",
                    "  ) {",
                    "    end += printClosingTagStartMarker(node, options).length;",
                    "  } else if (needsToBorrowLastChildClosingTagEndMarker(node)) {",
                    "    end -= printClosingTagEndMarker(node.lastChild, options).length;",
                    "  }",
                    "",
                    "  return options.originalText.slice(start, end);",
                    "}",
                    "",
                    "export default getNodeContent;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-html.js\";",
                    "",
                    "export const printers = {",
                    "  html: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-html.js\"),",
                    "    parserNames: [\"html\", \"vue\", \"angular\", \"lwc\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.HTML, () => ({",
                    "    name: \"Angular\",",
                    "    parsers: [\"angular\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [\".component.html\"],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(linguistLanguages.HTML, (data) => ({",
                    "    parsers: [\"html\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [",
                    "      ...data.extensions,",
                    "      \".mjml\", // MJML is considered XML in Linguist but it should be formatted as HTML",
                    "    ],",
                    "  })),",
                    "  createLanguage(linguistLanguages.HTML, () => ({",
                    "    name: \"Lightning Web Components\",",
                    "    parsers: [\"lwc\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(linguistLanguages.Vue, () => ({",
                    "    parsers: [\"vue\"],",
                    "    vscodeLanguageIds: [\"vue\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(node) {",
                    "  return node.sourceSpan.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.sourceSpan.end.offset;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "const CATEGORY_HTML = \"HTML\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  bracketSameLine: commonOptions.bracketSameLine,",
                    "  htmlWhitespaceSensitivity: {",
                    "    category: CATEGORY_HTML,",
                    "    type: \"choice\",",
                    "    default: \"css\",",
                    "    description: \"How to handle whitespaces in HTML.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"css\",",
                    "        description: \"Respect the default value of CSS display property.\",",
                    "      },",
                    "      {",
                    "        value: \"strict\",",
                    "        description: \"Whitespaces are considered sensitive.\",",
                    "      },",
                    "      {",
                    "        value: \"ignore\",",
                    "        description: \"Whitespaces are considered insensitive.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  singleAttributePerLine: commonOptions.singleAttributePerLine,",
                    "  vueIndentScriptAndStyle: {",
                    "    category: CATEGORY_HTML,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent script and style tags in Vue files.\",",
                    "  },",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  ParseSourceFile,",
                    "  ParseLocation,",
                    "  ParseSourceSpan,",
                    "  parse as parseHtml,",
                    "  RecursiveVisitor,",
                    "  visitAll,",
                    "  getHtmlTagDefinition,",
                    "  TagContentType,",
                    "} from \"angular-html-parser\";",
                    "import parseFrontMatter from \"../utils/front-matter/parse.js\";",
                    "import inferParser from \"../utils/infer-parser.js\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import HTML_TAGS from \"./utils/html-tag-names.evaluate.js\";",
                    "import HTML_ELEMENT_ATTRIBUTES from \"./utils/html-elements-attributes.evaluate.js\";",
                    "import isUnknownNamespace from \"./utils/is-unknown-namespace.js\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import { Node } from \"./ast.js\";",
                    "import { parseIeConditionalComment } from \"./conditional-comment.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "",
                    "/**",
                    " * @typedef {import('angular-html-parser')} AngularHtmlParser",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast.js').Node} AstNode",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast.js').Attribute} Attribute",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast.js').Element} Element",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/parser.js').ParseTreeResult} ParserTreeResult",
                    " * @typedef {import('angular-html-parser').ParseOptions & {",
                    " *   name: 'html' | 'angular' | 'vue' | 'lwc';",
                    " *   normalizeTagName?: boolean;",
                    " *   normalizeAttributeName?: boolean;",
                    " *   shouldParseAsRawText?: (tagName: string, prefix: string, hasParent: boolean, attrs: Array<{",
                    " *      prefix: string;",
                    " *      name: string;",
                    " *      value?: string;",
                    " *   }>) => boolean;",
                    " * }} ParseOptions",
                    " * @typedef {{filepath?: string}} Options",
                    " */",
                    "",
                    "/**",
                    " * @param {string} input",
                    " * @param {ParseOptions} parseOptions",
                    " * @param {Options} options",
                    " */",
                    "function ngHtmlParser(input, parseOptions, options) {",
                    "  const {",
                    "    name,",
                    "    canSelfClose = true,",
                    "    normalizeTagName = false,",
                    "    normalizeAttributeName = false,",
                    "    allowHtmComponentClosingTags = false,",
                    "    isTagNameCaseSensitive = false,",
                    "    shouldParseAsRawText,",
                    "  } = parseOptions;",
                    "",
                    "  let { rootNodes, errors } = parseHtml(input, {",
                    "    canSelfClose,",
                    "    allowHtmComponentClosingTags,",
                    "    isTagNameCaseSensitive,",
                    "    getTagContentType: shouldParseAsRawText",
                    "      ? (...args) =>",
                    "          shouldParseAsRawText(...args) ? TagContentType.RAW_TEXT : undefined",
                    "      : undefined,",
                    "  });",
                    "",
                    "  if (name === \"vue\") {",
                    "    const isHtml = rootNodes.some(",
                    "      (node) =>",
                    "        (node.type === \"docType\" && node.value === \"html\") ||",
                    "        (node.type === \"element\" && node.name.toLowerCase() === \"html\")",
                    "    );",
                    "",
                    "    // If not Vue SFC, treat as html",
                    "    if (isHtml) {",
                    "      return ngHtmlParser(input, HTML_PARSE_OPTIONS, options);",
                    "    }",
                    "",
                    "    /** @type {ParserTreeResult | undefined} */",
                    "    let secondParseResult;",
                    "    const getHtmlParseResult = () =>",
                    "      (secondParseResult ??= parseHtml(input, {",
                    "        canSelfClose,",
                    "        allowHtmComponentClosingTags,",
                    "        isTagNameCaseSensitive,",
                    "      }));",
                    "",
                    "    const getNodeWithSameLocation = (node) =>",
                    "      getHtmlParseResult().rootNodes.find(",
                    "        ({ startSourceSpan }) =>",
                    "          startSourceSpan &&",
                    "          startSourceSpan.start.offset === node.startSourceSpan.start.offset",
                    "      ) ?? node;",
                    "    for (const [index, node] of rootNodes.entries()) {",
                    "      const { endSourceSpan, startSourceSpan } = node;",
                    "      const isVoidElement = endSourceSpan === null;",
                    "      if (isVoidElement) {",
                    "        errors = getHtmlParseResult().errors;",
                    "        rootNodes[index] = getNodeWithSameLocation(node);",
                    "      } else if (shouldParseVueRootNodeAsHtml(node, options)) {",
                    "        const error = getHtmlParseResult().errors.find(",
                    "          (error) =>",
                    "            error.span.start.offset > startSourceSpan.start.offset &&",
                    "            error.span.start.offset < endSourceSpan.end.offset",
                    "        );",
                    "        if (error) {",
                    "          throwParseError(error);",
                    "        }",
                    "        rootNodes[index] = getNodeWithSameLocation(node);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  if (errors.length > 0) {",
                    "    throwParseError(errors[0]);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Attribute | Element} node",
                    "   */",
                    "  const restoreName = (node) => {",
                    "    const namespace = node.name.startsWith(\":\")",
                    "      ? node.name.slice(1).split(\":\")[0]",
                    "      : null;",
                    "    const rawName = node.nameSpan.toString();",
                    "    const hasExplicitNamespace =",
                    "      namespace !== null && rawName.startsWith(`${namespace}:`);",
                    "    const name = hasExplicitNamespace",
                    "      ? rawName.slice(namespace.length + 1)",
                    "      : rawName;",
                    "",
                    "    node.name = name;",
                    "    node.namespace = namespace;",
                    "    node.hasExplicitNamespace = hasExplicitNamespace;",
                    "  };",
                    "",
                    "  /**",
                    "   * @param {AstNode} node",
                    "   */",
                    "  const restoreNameAndValue = (node) => {",
                    "    switch (node.type) {",
                    "      case \"element\":",
                    "        restoreName(node);",
                    "        for (const attr of node.attrs) {",
                    "          restoreName(attr);",
                    "          if (!attr.valueSpan) {",
                    "            attr.value = null;",
                    "          } else {",
                    "            attr.value = attr.valueSpan.toString();",
                    "            if (/[\"']/.test(attr.value[0])) {",
                    "              attr.value = attr.value.slice(1, -1);",
                    "            }",
                    "          }",
                    "        }",
                    "        break;",
                    "      case \"comment\":",
                    "        node.value = node.sourceSpan",
                    "          .toString()",
                    "          .slice(\"<!--\".length, -\"-->\".length);",
                    "        break;",
                    "      case \"text\":",
                    "        node.value = node.sourceSpan.toString();",
                    "        break;",
                    "      // No default",
                    "    }",
                    "  };",
                    "",
                    "  const lowerCaseIfFn = (text, fn) => {",
                    "    const lowerCasedText = text.toLowerCase();",
                    "    return fn(lowerCasedText) ? lowerCasedText : text;",
                    "  };",
                    "  const normalizeName = (node) => {",
                    "    if (node.type === \"element\") {",
                    "      if (",
                    "        normalizeTagName &&",
                    "        (!node.namespace ||",
                    "          node.namespace === node.tagDefinition.implicitNamespacePrefix ||",
                    "          isUnknownNamespace(node))",
                    "      ) {",
                    "        node.name = lowerCaseIfFn(node.name, (lowerCasedName) =>",
                    "          HTML_TAGS.has(lowerCasedName)",
                    "        );",
                    "      }",
                    "",
                    "      if (normalizeAttributeName) {",
                    "        for (const attr of node.attrs) {",
                    "          if (!attr.namespace) {",
                    "            attr.name = lowerCaseIfFn(",
                    "              attr.name,",
                    "              (lowerCasedAttrName) =>",
                    "                HTML_ELEMENT_ATTRIBUTES.has(node.name) &&",
                    "                (HTML_ELEMENT_ATTRIBUTES.get(\"*\").has(lowerCasedAttrName) ||",
                    "                  HTML_ELEMENT_ATTRIBUTES.get(node.name).has(",
                    "                    lowerCasedAttrName",
                    "                  ))",
                    "            );",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  const fixSourceSpan = (node) => {",
                    "    if (node.sourceSpan && node.endSourceSpan) {",
                    "      node.sourceSpan = new ParseSourceSpan(",
                    "        node.sourceSpan.start,",
                    "        node.endSourceSpan.end",
                    "      );",
                    "    }",
                    "  };",
                    "",
                    "  /**",
                    "   * @param {AstNode} node",
                    "   */",
                    "  const addTagDefinition = (node) => {",
                    "    if (node.type === \"element\") {",
                    "      const tagDefinition = getHtmlTagDefinition(",
                    "        isTagNameCaseSensitive ? node.name : node.name.toLowerCase()",
                    "      );",
                    "      if (",
                    "        !node.namespace ||",
                    "        node.namespace === tagDefinition.implicitNamespacePrefix ||",
                    "        isUnknownNamespace(node)",
                    "      ) {",
                    "        node.tagDefinition = tagDefinition;",
                    "      } else {",
                    "        node.tagDefinition = getHtmlTagDefinition(\"\"); // the default one",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  visitAll(",
                    "    new (class extends RecursiveVisitor {",
                    "      visit(node) {",
                    "        restoreNameAndValue(node);",
                    "        addTagDefinition(node);",
                    "        normalizeName(node);",
                    "        fixSourceSpan(node);",
                    "      }",
                    "    })(),",
                    "    rootNodes",
                    "  );",
                    "",
                    "  return rootNodes;",
                    "}",
                    "",
                    "function shouldParseVueRootNodeAsHtml(node, options) {",
                    "  if (node.type !== \"element\" || node.name !== \"template\") {",
                    "    return false;",
                    "  }",
                    "  const language = node.attrs.find((attr) => attr.name === \"lang\")?.value;",
                    "  return !language || inferParser(options, { language }) === \"html\";",
                    "}",
                    "",
                    "function throwParseError(error) {",
                    "  const {",
                    "    msg,",
                    "    span: { start, end },",
                    "  } = error;",
                    "  throw createError(msg, {",
                    "    loc: {",
                    "      start: { line: start.line + 1, column: start.col + 1 },",
                    "      end: { line: end.line + 1, column: end.col + 1 },",
                    "    },",
                    "    cause: error,",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {ParseOptions} parseOptions",
                    " * @param {Options} options",
                    " * @param {boolean} shouldParseFrontMatter",
                    " */",
                    "function parse(",
                    "  text,",
                    "  parseOptions,",
                    "  options = {},",
                    "  shouldParseFrontMatter = true",
                    ") {",
                    "  const { frontMatter, content } = shouldParseFrontMatter",
                    "    ? parseFrontMatter(text)",
                    "    : { frontMatter: null, content: text };",
                    "",
                    "  const file = new ParseSourceFile(text, options.filepath);",
                    "  const start = new ParseLocation(file, 0, 0, 0);",
                    "  const end = start.moveBy(text.length);",
                    "  const rawAst = {",
                    "    type: \"root\",",
                    "    sourceSpan: new ParseSourceSpan(start, end),",
                    "    children: ngHtmlParser(content, parseOptions, options),",
                    "  };",
                    "",
                    "  if (frontMatter) {",
                    "    const start = new ParseLocation(file, 0, 0, 0);",
                    "    const end = start.moveBy(frontMatter.raw.length);",
                    "    frontMatter.sourceSpan = new ParseSourceSpan(start, end);",
                    "    rawAst.children.unshift(frontMatter);",
                    "  }",
                    "",
                    "  const ast = new Node(rawAst);",
                    "",
                    "  const parseSubHtml = (subContent, startSpan) => {",
                    "    const { offset } = startSpan;",
                    "    const fakeContent = text.slice(0, offset).replaceAll(/[^\\n\\r]/g, \" \");",
                    "    const realContent = subContent;",
                    "    const subAst = parse(",
                    "      fakeContent + realContent,",
                    "      parseOptions,",
                    "      options,",
                    "      false",
                    "    );",
                    "    // @ts-expect-error",
                    "    subAst.sourceSpan = new ParseSourceSpan(",
                    "      startSpan,",
                    "      // @ts-expect-error",
                    "      subAst.children.at(-1).sourceSpan.end",
                    "    );",
                    "    // @ts-expect-error",
                    "    const firstText = subAst.children[0];",
                    "    if (firstText.length === offset) {",
                    "      /* c8 ignore next */ // @ts-expect-error",
                    "      subAst.children.shift();",
                    "    } else {",
                    "      firstText.sourceSpan = new ParseSourceSpan(",
                    "        firstText.sourceSpan.start.moveBy(offset),",
                    "        firstText.sourceSpan.end",
                    "      );",
                    "      firstText.value = firstText.value.slice(offset);",
                    "    }",
                    "    return subAst;",
                    "  };",
                    "",
                    "  ast.walk((node) => {",
                    "    if (node.type === \"comment\") {",
                    "      const ieConditionalComment = parseIeConditionalComment(",
                    "        node,",
                    "        parseSubHtml",
                    "      );",
                    "      if (ieConditionalComment) {",
                    "        node.parent.replaceChild(node, ieConditionalComment);",
                    "      }",
                    "    }",
                    "  });",
                    "",
                    "  return ast;",
                    "}",
                    "",
                    "/**",
                    " * @param {ParseOptions} parseOptions",
                    " */",
                    "function createParser(parseOptions) {",
                    "  return {",
                    "    parse: (text, options) => parse(text, parseOptions, options),",
                    "    hasPragma,",
                    "    astFormat: \"html\",",
                    "    locStart,",
                    "    locEnd,",
                    "  };",
                    "}",
                    "",
                    "/** @type {ParseOptions} */",
                    "const HTML_PARSE_OPTIONS = {",
                    "  name: \"html\",",
                    "  normalizeTagName: true,",
                    "  normalizeAttributeName: true,",
                    "  allowHtmComponentClosingTags: true,",
                    "};",
                    "",
                    "// HTML",
                    "export const html = createParser(HTML_PARSE_OPTIONS);",
                    "// Angular",
                    "export const angular = createParser({ name: \"angular\" });",
                    "// Vue",
                    "export const vue = createParser({",
                    "  name: \"vue\",",
                    "  isTagNameCaseSensitive: true,",
                    "  shouldParseAsRawText(tagName, prefix, hasParent, attrs) {",
                    "    return (",
                    "      tagName.toLowerCase() !== \"html\" &&",
                    "      !hasParent &&",
                    "      (tagName !== \"template\" ||",
                    "        attrs.some(",
                    "          ({ name, value }) =>",
                    "            name === \"lang\" &&",
                    "            value !== \"html\" &&",
                    "            value !== \"\" &&",
                    "            value !== undefined",
                    "        ))",
                    "    );",
                    "  },",
                    "});",
                    "// Lightning Web Components",
                    "export const lwc = createParser({ name: \"lwc\", canSelfClose: false });"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function hasPragma(text) {",
                    "  return /^\\s*<!--\\s*@(?:format|prettier)\\s*-->/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"<!-- @format -->\\n\\n\" + text;",
                    "}",
                    "",
                    "export { hasPragma, insertPragma };"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { ParseSourceSpan } from \"angular-html-parser/lib/compiler/src/parse_util.js\";",
                    "import htmlWhitespaceUtils from \"../utils/html-whitespace-utils.js\";",
                    "import {",
                    "  getLeadingAndTrailingHtmlWhitespace,",
                    "  canHaveInterpolation,",
                    "  getNodeCssStyleDisplay,",
                    "  isDanglingSpaceSensitiveNode,",
                    "  isIndentationSensitiveNode,",
                    "  isLeadingSpaceSensitiveNode,",
                    "  isTrailingSpaceSensitiveNode,",
                    "  isWhitespaceSensitiveNode,",
                    "} from \"./utils/index.js\";",
                    "",
                    "const PREPROCESS_PIPELINE = [",
                    "  removeIgnorableFirstLf,",
                    "  mergeIfConditionalStartEndCommentIntoElementOpeningTag,",
                    "  mergeCdataIntoText,",
                    "  extractInterpolation,",
                    "  extractWhitespaces,",
                    "  addCssDisplay,",
                    "  addIsSelfClosing,",
                    "  addHasHtmComponentClosingTag,",
                    "  addIsSpaceSensitive,",
                    "  mergeSimpleElementIntoText,",
                    "];",
                    "",
                    "function preprocess(ast, options) {",
                    "  for (const fn of PREPROCESS_PIPELINE) {",
                    "    fn(ast, options);",
                    "  }",
                    "  return ast;",
                    "}",
                    "",
                    "function removeIgnorableFirstLf(ast /*, options */) {",
                    "  ast.walk((node) => {",
                    "    if (",
                    "      node.type === \"element\" &&",
                    "      node.tagDefinition.ignoreFirstLf &&",
                    "      node.children.length > 0 &&",
                    "      node.children[0].type === \"text\" &&",
                    "      node.children[0].value[0] === \"\\n\"",
                    "    ) {",
                    "      const text = node.children[0];",
                    "      if (text.value.length === 1) {",
                    "        node.removeChild(text);",
                    "      } else {",
                    "        text.value = text.value.slice(1);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeIfConditionalStartEndCommentIntoElementOpeningTag(",
                    "  ast /*, options */",
                    ") {",
                    "  /**",
                    "   *     <!--[if ...]><!--><target><!--<![endif]-->",
                    "   */",
                    "  const isTarget = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.prev?.type === \"ieConditionalStartComment\" &&",
                    "    node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset &&",
                    "    node.firstChild?.type === \"ieConditionalEndComment\" &&",
                    "    node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (!isTarget(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const ieConditionalStartComment = child.prev;",
                    "        const ieConditionalEndComment = child.firstChild;",
                    "",
                    "        // ieConditionalStartComment",
                    "        node.removeChild(ieConditionalStartComment);",
                    "        i--; // because a node was removed",
                    "",
                    "        const startSourceSpan = new ParseSourceSpan(",
                    "          ieConditionalStartComment.sourceSpan.start,",
                    "          ieConditionalEndComment.sourceSpan.end",
                    "        );",
                    "        const sourceSpan = new ParseSourceSpan(",
                    "          startSourceSpan.start,",
                    "          child.sourceSpan.end",
                    "        );",
                    "",
                    "        child.condition = ieConditionalStartComment.condition;",
                    "        child.sourceSpan = sourceSpan;",
                    "        child.startSourceSpan = startSourceSpan;",
                    "        child.removeChild(ieConditionalEndComment);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeNodeIntoText(ast, shouldMerge, getValue) {",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "",
                    "        if (child.type !== \"text\" && !shouldMerge(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        if (child.type !== \"text\") {",
                    "          child.type = \"text\";",
                    "          child.value = getValue(child);",
                    "        }",
                    "",
                    "        const prevChild = child.prev;",
                    "        if (!prevChild || prevChild.type !== \"text\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        prevChild.value += child.value;",
                    "        prevChild.sourceSpan = new ParseSourceSpan(",
                    "          prevChild.sourceSpan.start,",
                    "          child.sourceSpan.end",
                    "        );",
                    "",
                    "        node.removeChild(child);",
                    "        i--; // because a node was removed",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeCdataIntoText(ast /*, options */) {",
                    "  return mergeNodeIntoText(",
                    "    ast,",
                    "    (node) => node.type === \"cdata\",",
                    "    (node) => `<![CDATA[${node.value}]]>`",
                    "  );",
                    "}",
                    "",
                    "function mergeSimpleElementIntoText(ast /*, options */) {",
                    "  const isSimpleElement = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.attrs.length === 0 &&",
                    "    node.children.length === 1 &&",
                    "    node.firstChild.type === \"text\" &&",
                    "    !htmlWhitespaceUtils.hasWhitespaceCharacter(node.children[0].value) &&",
                    "    !node.firstChild.hasLeadingSpaces &&",
                    "    !node.firstChild.hasTrailingSpaces &&",
                    "    node.isLeadingSpaceSensitive &&",
                    "    !node.hasLeadingSpaces &&",
                    "    node.isTrailingSpaceSensitive &&",
                    "    !node.hasTrailingSpaces &&",
                    "    node.prev?.type === \"text\" &&",
                    "    node.next?.type === \"text\";",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (!isSimpleElement(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const prevChild = child.prev;",
                    "        const nextChild = child.next;",
                    "        prevChild.value +=",
                    "          `<${child.rawName}>` +",
                    "          child.firstChild.value +",
                    "          `</${child.rawName}>` +",
                    "          nextChild.value;",
                    "        prevChild.sourceSpan = new ParseSourceSpan(",
                    "          prevChild.sourceSpan.start,",
                    "          nextChild.sourceSpan.end",
                    "        );",
                    "        prevChild.isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive;",
                    "        prevChild.hasTrailingSpaces = nextChild.hasTrailingSpaces;",
                    "",
                    "        node.removeChild(child);",
                    "        i--; // because a node was removed",
                    "        node.removeChild(nextChild);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function extractInterpolation(ast, options) {",
                    "  if (options.parser === \"html\") {",
                    "    return;",
                    "  }",
                    "",
                    "  const interpolationRegex = /{{(.+?)}}/s;",
                    "  ast.walk((node) => {",
                    "    if (!canHaveInterpolation(node)) {",
                    "      return;",
                    "    }",
                    "",
                    "    for (const child of node.children) {",
                    "      if (child.type !== \"text\") {",
                    "        continue;",
                    "      }",
                    "",
                    "      let startSourceSpan = child.sourceSpan.start;",
                    "      let endSourceSpan = null;",
                    "      const components = child.value.split(interpolationRegex);",
                    "      for (",
                    "        let i = 0;",
                    "        i < components.length;",
                    "        i++, startSourceSpan = endSourceSpan",
                    "      ) {",
                    "        const value = components[i];",
                    "",
                    "        if (i % 2 === 0) {",
                    "          endSourceSpan = startSourceSpan.moveBy(value.length);",
                    "          if (value.length > 0) {",
                    "            node.insertChildBefore(child, {",
                    "              type: \"text\",",
                    "              value,",
                    "              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "            });",
                    "          }",
                    "          continue;",
                    "        }",
                    "",
                    "        endSourceSpan = startSourceSpan.moveBy(value.length + 4); // `{{` + `}}`",
                    "        node.insertChildBefore(child, {",
                    "          type: \"interpolation\",",
                    "          sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "          children:",
                    "            value.length === 0",
                    "              ? []",
                    "              : [",
                    "                  {",
                    "                    type: \"text\",",
                    "                    value,",
                    "                    sourceSpan: new ParseSourceSpan(",
                    "                      startSourceSpan.moveBy(2),",
                    "                      endSourceSpan.moveBy(-2)",
                    "                    ),",
                    "                  },",
                    "                ],",
                    "        });",
                    "      }",
                    "",
                    "      node.removeChild(child);",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * - add `hasLeadingSpaces` field",
                    " * - add `hasTrailingSpaces` field",
                    " * - add `hasDanglingSpaces` field for parent nodes",
                    " * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes",
                    " * - remove insensitive whitespaces",
                    " */",
                    "function extractWhitespaces(ast /*, options*/) {",
                    "  ast.walk((node) => {",
                    "    if (!node.children) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (",
                    "      node.children.length === 0 ||",
                    "      (node.children.length === 1 &&",
                    "        node.children[0].type === \"text\" &&",
                    "        htmlWhitespaceUtils.trim(node.children[0].value).length === 0)",
                    "    ) {",
                    "      node.hasDanglingSpaces = node.children.length > 0;",
                    "      node.children = [];",
                    "      return;",
                    "    }",
                    "",
                    "    const isWhitespaceSensitive = isWhitespaceSensitiveNode(node);",
                    "    const isIndentationSensitive = isIndentationSensitiveNode(node);",
                    "",
                    "    if (!isWhitespaceSensitive) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (child.type !== \"text\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        const { leadingWhitespace, text, trailingWhitespace } =",
                    "          getLeadingAndTrailingHtmlWhitespace(child.value);",
                    "",
                    "        const prevChild = child.prev;",
                    "        const nextChild = child.next;",
                    "",
                    "        if (!text) {",
                    "          node.removeChild(child);",
                    "          i--; // because a node was removed",
                    "",
                    "          if (leadingWhitespace || trailingWhitespace) {",
                    "            if (prevChild) {",
                    "              prevChild.hasTrailingSpaces = true;",
                    "            }",
                    "            if (nextChild) {",
                    "              nextChild.hasLeadingSpaces = true;",
                    "            }",
                    "          }",
                    "        } else {",
                    "          child.value = text;",
                    "          child.sourceSpan = new ParseSourceSpan(",
                    "            child.sourceSpan.start.moveBy(leadingWhitespace.length),",
                    "            child.sourceSpan.end.moveBy(-trailingWhitespace.length)",
                    "          );",
                    "",
                    "          if (leadingWhitespace) {",
                    "            if (prevChild) {",
                    "              prevChild.hasTrailingSpaces = true;",
                    "            }",
                    "            child.hasLeadingSpaces = true;",
                    "          }",
                    "          if (trailingWhitespace) {",
                    "            child.hasTrailingSpaces = true;",
                    "            if (nextChild) {",
                    "              nextChild.hasLeadingSpaces = true;",
                    "            }",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    node.isWhitespaceSensitive = isWhitespaceSensitive;",
                    "    node.isIndentationSensitive = isIndentationSensitive;",
                    "  });",
                    "}",
                    "",
                    "function addIsSelfClosing(ast /*, options */) {",
                    "  ast.walk((node) => {",
                    "    node.isSelfClosing =",
                    "      !node.children ||",
                    "      (node.type === \"element\" &&",
                    "        (node.tagDefinition.isVoid ||",
                    "          // self-closing",
                    "          (node.endSourceSpan &&",
                    "            node.startSourceSpan.start === node.endSourceSpan.start &&",
                    "            node.startSourceSpan.end === node.endSourceSpan.end)));",
                    "  });",
                    "}",
                    "",
                    "function addHasHtmComponentClosingTag(ast, options) {",
                    "  ast.walk((node) => {",
                    "    if (node.type !== \"element\") {",
                    "      return;",
                    "    }",
                    "",
                    "    node.hasHtmComponentClosingTag =",
                    "      node.endSourceSpan &&",
                    "      /^<\\s*\\/\\s*\\/\\s*>$/.test(",
                    "        options.originalText.slice(",
                    "          node.endSourceSpan.start.offset,",
                    "          node.endSourceSpan.end.offset",
                    "        )",
                    "      );",
                    "  });",
                    "}",
                    "",
                    "function addCssDisplay(ast, options) {",
                    "  ast.walk((node) => {",
                    "    node.cssDisplay = getNodeCssStyleDisplay(node, options);",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * - add `isLeadingSpaceSensitive` field",
                    " * - add `isTrailingSpaceSensitive` field",
                    " * - add `isDanglingSpaceSensitive` field for parent nodes",
                    " */",
                    "function addIsSpaceSensitive(ast, options) {",
                    "  ast.walk((node) => {",
                    "    const { children } = node;",
                    "    if (!children) {",
                    "      return;",
                    "    }",
                    "    if (children.length === 0) {",
                    "      node.isDanglingSpaceSensitive = isDanglingSpaceSensitiveNode(node);",
                    "      return;",
                    "    }",
                    "    for (const child of children) {",
                    "      child.isLeadingSpaceSensitive = isLeadingSpaceSensitiveNode(",
                    "        child,",
                    "        options",
                    "      );",
                    "      child.isTrailingSpaceSensitive = isTrailingSpaceSensitiveNode(",
                    "        child,",
                    "        options",
                    "      );",
                    "    }",
                    "    for (let index = 0; index < children.length; index++) {",
                    "      const child = children[index];",
                    "      child.isLeadingSpaceSensitive =",
                    "        index === 0",
                    "          ? child.isLeadingSpaceSensitive",
                    "          : child.prev.isTrailingSpaceSensitive &&",
                    "            child.isLeadingSpaceSensitive;",
                    "      child.isTrailingSpaceSensitive =",
                    "        index === children.length - 1",
                    "          ? child.isTrailingSpaceSensitive",
                    "          : child.next.isLeadingSpaceSensitive &&",
                    "            child.isTrailingSpaceSensitive;",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "export default preprocess;"
                ]
            },
            "printer-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                    " */",
                    "",
                    "import { fill, group, hardline } from \"../document/builders.js\";",
                    "import { cleanDoc, replaceEndOfLine } from \"../document/utils.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import getPreferredQuote from \"../utils/get-preferred-quote.js\";",
                    "import clean from \"./clean.js\";",
                    "import { unescapeQuoteEntities, getTextValueParts } from \"./utils/index.js\";",
                    "import preprocess from \"./print-preprocess.js\";",
                    "import { insertPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import embed from \"./embed.js\";",
                    "import {",
                    "  printClosingTagSuffix,",
                    "  printClosingTagEnd,",
                    "  printOpeningTagPrefix,",
                    "  printOpeningTagStart,",
                    "} from \"./print/tag.js\";",
                    "import { printElement } from \"./print/element.js\";",
                    "import { printChildren } from \"./print/children.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return replaceEndOfLine(node.raw);",
                    "    case \"root\":",
                    "      if (options.__onHtmlRoot) {",
                    "        options.__onHtmlRoot(node);",
                    "      }",
                    "      return [group(printChildren(path, options, print)), hardline];",
                    "    case \"element\":",
                    "    case \"ieConditionalComment\":",
                    "      return printElement(path, options, print);",
                    "",
                    "    case \"ieConditionalStartComment\":",
                    "    case \"ieConditionalEndComment\":",
                    "      return [printOpeningTagStart(node), printClosingTagEnd(node)];",
                    "    case \"interpolation\":",
                    "      return [",
                    "        printOpeningTagStart(node, options),",
                    "        ...path.map(print, \"children\"),",
                    "        printClosingTagEnd(node, options),",
                    "      ];",
                    "    case \"text\": {",
                    "      if (node.parent.type === \"interpolation\") {",
                    "        // replace the trailing literalline with hardline for better readability",
                    "        const trailingNewlineRegex = /\\n[^\\S\\n]*$/;",
                    "        const hasTrailingNewline = trailingNewlineRegex.test(node.value);",
                    "        const value = hasTrailingNewline",
                    "          ? node.value.replace(trailingNewlineRegex, \"\")",
                    "          : node.value;",
                    "        return [replaceEndOfLine(value), hasTrailingNewline ? hardline : \"\"];",
                    "      }",
                    "",
                    "      const printed = cleanDoc([",
                    "        printOpeningTagPrefix(node, options),",
                    "        ...getTextValueParts(node),",
                    "        printClosingTagSuffix(node, options),",
                    "      ]);",
                    "",
                    "      if (Array.isArray(printed)) {",
                    "        return fill(printed);",
                    "      }",
                    "",
                    "      return printed;",
                    "    }",
                    "    case \"docType\":",
                    "      return [",
                    "        group([",
                    "          printOpeningTagStart(node, options),",
                    "          \" \",",
                    "          node.value.replace(/^html\\b/i, \"html\").replaceAll(/\\s+/g, \" \"),",
                    "        ]),",
                    "        printClosingTagEnd(node, options),",
                    "      ];",
                    "    case \"comment\":",
                    "      return [",
                    "        printOpeningTagPrefix(node, options),",
                    "        replaceEndOfLine(",
                    "          options.originalText.slice(locStart(node), locEnd(node))",
                    "        ),",
                    "        printClosingTagSuffix(node, options),",
                    "      ];",
                    "",
                    "    case \"attribute\": {",
                    "      if (node.value === null) {",
                    "        return node.rawName;",
                    "      }",
                    "      const value = unescapeQuoteEntities(node.value);",
                    "      const quote = getPreferredQuote(value, '\"');",
                    "      return [",
                    "        node.rawName,",
                    "        \"=\",",
                    "        quote,",
                    "        replaceEndOfLine(",
                    "          quote === '\"'",
                    "            ? value.replaceAll('\"', \"&quot;\")",
                    "            : value.replaceAll(\"'\", \"&apos;\")",
                    "        ),",
                    "        quote,",
                    "      ];",
                    "    }",
                    "    case \"cdata\": // Transformed into `text`",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"HTML\");",
                    "  }",
                    "}",
                    "",
                    "const printer = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  embed,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = {",
                    "  \"front-matter\": [],",
                    "  root: [\"children\"],",
                    "  element: [\"attrs\", \"children\"],",
                    "  ieConditionalComment: [\"children\"],",
                    "  ieConditionalStartComment: [],",
                    "  ieConditionalEndComment: [],",
                    "  interpolation: [\"children\"],",
                    "  text: [\"children\"],",
                    "  docType: [],",
                    "  comment: [],",
                    "  attribute: [],",
                    "  cdata: [],",
                    "};",
                    "",
                    "export default visitorKeys;"
                ]
            },
            "embed": {
                "angular-attributes.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  getUnescapedAttributeValue,",
                        "  getTextValueParts,",
                        "} from \"../utils/index.js\";",
                        "import { fill } from \"../../document/builders.js\";",
                        "import {",
                        "  formatAttributeValue,",
                        "  printExpand,",
                        "  shouldHugJsExpression,",
                        "} from \"./utils.js\";",
                        "import {",
                        "  interpolationRegex as angularInterpolationRegex,",
                        "  printAngularInterpolation,",
                        "} from \"./angular-interpolation.js\";",
                        "",
                        "function createAngularPrinter({ parser }) {",
                        "  return (textToDoc, print, path /*, options*/) =>",
                        "    formatAttributeValue(",
                        "      getUnescapedAttributeValue(path.node),",
                        "      textToDoc,",
                        "      {",
                        "        parser,",
                        "        // angular does not allow trailing comma",
                        "        trailingComma: \"none\",",
                        "      },",
                        "      shouldHugJsExpression",
                        "    );",
                        "}",
                        "",
                        "const printNgAction = createAngularPrinter({ parser: \"__ng_action\" });",
                        "const printNgBinding = createAngularPrinter({ parser: \"__ng_binding\" });",
                        "const printNgDirective = createAngularPrinter({ parser: \"__ng_directive\" });",
                        "",
                        "function printAngularAttribute(path, options) {",
                        "  if (options.parser !== \"angular\") {",
                        "    return;",
                        "  }",
                        "",
                        "  const { node } = path;",
                        "  const attributeName = node.fullName;",
                        "",
                        "  /**",
                        "   *     (click)=\"angularStatement\"",
                        "   *     on-click=\"angularStatement\"",
                        "   */",
                        "  if (",
                        "    (attributeName.startsWith(\"(\") && attributeName.endsWith(\")\")) ||",
                        "    attributeName.startsWith(\"on-\")",
                        "  ) {",
                        "    return printNgAction;",
                        "  }",
                        "",
                        "  /**",
                        "   *     [target]=\"angularExpression\"",
                        "   *     bind-target=\"angularExpression\"",
                        "   *     [(target)]=\"angularExpression\"",
                        "   *     bindon-target=\"angularExpression\"",
                        "   */",
                        "  if (",
                        "    (attributeName.startsWith(\"[\") && attributeName.endsWith(\"]\")) ||",
                        "    /^bind(?:on)?-/.test(attributeName) ||",
                        "    // Unofficial rudimentary support for some of the most used directives of AngularJS 1.x",
                        "    /^ng-(?:if|show|hide|class|style)$/.test(attributeName)",
                        "  ) {",
                        "    return printNgBinding;",
                        "  }",
                        "",
                        "  /**",
                        "   *     *directive=\"angularDirective\"",
                        "   */",
                        "  if (attributeName.startsWith(\"*\")) {",
                        "    return printNgDirective;",
                        "  }",
                        "",
                        "  const value = getUnescapedAttributeValue(node);",
                        "",
                        "  /**",
                        "   *     i18n=\"longDescription\"",
                        "   *     i18n-attr=\"longDescription\"",
                        "   */",
                        "  if (/^i18n(?:-.+)?$/.test(attributeName)) {",
                        "    return () =>",
                        "      printExpand(",
                        "        fill(getTextValueParts(node, value.trim())),",
                        "        !value.includes(\"@@\")",
                        "      );",
                        "  }",
                        "",
                        "  if (angularInterpolationRegex.test(value)) {",
                        "    return (textToDoc) => printAngularInterpolation(value, textToDoc);",
                        "  }",
                        "}",
                        "",
                        "export default printAngularAttribute;"
                    ]
                },
                "angular-interpolation.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { group, indent, line } from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import { formatAttributeValue } from \"./utils.js\";",
                        "",
                        "const interpolationRegex = /{{(.+?)}}/s;",
                        "",
                        "async function printAngularInterpolation(text, textToDoc) {",
                        "  const parts = [];",
                        "  for (const [index, part] of text.split(interpolationRegex).entries()) {",
                        "    if (index % 2 === 0) {",
                        "      parts.push(replaceEndOfLine(part));",
                        "    } else {",
                        "      try {",
                        "        parts.push(",
                        "          group([",
                        "            \"{{\",",
                        "            indent([",
                        "              line,",
                        "              await formatAttributeValue(part, textToDoc, {",
                        "                parser: \"__ng_interpolation\",",
                        "                __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                        "                trailingComma: \"none\",",
                        "              }),",
                        "            ]),",
                        "            line,",
                        "            \"}}\",",
                        "          ])",
                        "        );",
                        "      } catch {",
                        "        parts.push(\"{{\", replaceEndOfLine(part), \"}}\");",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export { interpolationRegex, printAngularInterpolation };"
                    ]
                },
                "attribute.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { group } from \"../../document/builders.js\";",
                        "import { mapDoc } from \"../../document/utils.js\";",
                        "import printSrcset from \"./srcset.js\";",
                        "import printClassNames from \"./class-names.js\";",
                        "import { printStyleAttribute } from \"./style.js\";",
                        "import printVueAttribute from \"./vue-attributes.js\";",
                        "import printAngularAttribute from \"./angular-attributes.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path.js\")} AstPath",
                        " */",
                        "",
                        "function printAttribute(path, options) {",
                        "  const { node } = path;",
                        "",
                        "  if (!node.value) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (",
                        "    // lit-html: html`<my-element obj=${obj}></my-element>`",
                        "    /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(",
                        "      options.originalText.slice(",
                        "        node.valueSpan.start.offset,",
                        "        node.valueSpan.end.offset",
                        "      )",
                        "    ) || // lwc: html`<my-element data-for={value}></my-element>`",
                        "    (options.parser === \"lwc\" &&",
                        "      node.value.startsWith(\"{\") &&",
                        "      node.value.endsWith(\"}\"))",
                        "  ) {",
                        "    return [node.rawName, \"=\", node.value];",
                        "  }",
                        "",
                        "  for (const getValuePrinter of [",
                        "    printSrcset,",
                        "    printStyleAttribute,",
                        "    printClassNames,",
                        "    printVueAttribute,",
                        "    printAngularAttribute,",
                        "  ]) {",
                        "    const printValue = getValuePrinter(path, options);",
                        "    if (printValue) {",
                        "      return printAttributeWithValuePrinter(printValue);",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {(textToDoc, print, path, options) => Promise<Doc>} printValue",
                        " * @returns {(textToDoc, print, path, options) => Promise<Doc>}",
                        " */",
                        "function printAttributeWithValuePrinter(printValue) {",
                        "  return async (textToDoc, print, path, options) => {",
                        "    let valueDoc = await printValue(textToDoc, print, path, options);",
                        "",
                        "    if (!valueDoc) {",
                        "      return;",
                        "    }",
                        "",
                        "    valueDoc = mapDoc(valueDoc, (doc) =>",
                        "      typeof doc === \"string\" ? doc.replaceAll('\"', \"&quot;\") : doc",
                        "    );",
                        "",
                        "    return [path.node.rawName, '=\"', group(valueDoc), '\"'];",
                        "  };",
                        "}",
                        "",
                        "export default printAttribute;"
                    ]
                },
                "class-names.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { getUnescapedAttributeValue } from \"../utils/index.js\";",
                        "",
                        "function printClassNames(path, options) {",
                        "  const { node } = path;",
                        "  const value = getUnescapedAttributeValue(node);",
                        "  if (",
                        "    node.fullName === \"class\" &&",
                        "    !options.parentParser &&",
                        "    !value.includes(\"{{\")",
                        "  ) {",
                        "    return () => value.trim().split(/\\s+/).join(\" \");",
                        "  }",
                        "}",
                        "",
                        "export default printClassNames;"
                    ]
                },
                "srcset.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import parseSrcset from \"@prettier/parse-srcset\";",
                        "import { ifBreak, join, line } from \"../../document/builders.js\";",
                        "import { getUnescapedAttributeValue } from \"../utils/index.js\";",
                        "import { printExpand } from \"./utils.js\";",
                        "",
                        "function printSrcset(path /*, options*/) {",
                        "  if (",
                        "    path.node.fullName === \"srcset\" &&",
                        "    (path.parent.fullName === \"img\" || path.parent.fullName === \"source\")",
                        "  ) {",
                        "    return () => printSrcsetValue(getUnescapedAttributeValue(path.node));",
                        "  }",
                        "}",
                        "",
                        "function printSrcsetValue(value) {",
                        "  const srcset = parseSrcset(value);",
                        "",
                        "  const hasW = srcset.some(({ width }) => width);",
                        "  const hasH = srcset.some(({ height }) => height);",
                        "  const hasX = srcset.some(({ density }) => density);",
                        "",
                        "  if (hasW + hasH + hasX > 1) {",
                        "    throw new Error(\"Mixed descriptor in srcset is not supported\");",
                        "  }",
                        "",
                        "  const key = hasW ? \"width\" : hasH ? \"height\" : \"density\";",
                        "  const unit = hasW ? \"w\" : hasH ? \"h\" : \"x\";",
                        "",
                        "  const urls = srcset.map((src) => src.source.value);",
                        "  const maxUrlLength = Math.max(...urls.map((url) => url.length));",
                        "",
                        "  const descriptors = srcset.map((src) =>",
                        "    src[key] ? String(src[key].value) : \"\"",
                        "  );",
                        "  const descriptorLeftLengths = descriptors.map((descriptor) => {",
                        "    const index = descriptor.indexOf(\".\");",
                        "    return index === -1 ? descriptor.length : index;",
                        "  });",
                        "  const maxDescriptorLeftLength = Math.max(...descriptorLeftLengths);",
                        "",
                        "  return printExpand(",
                        "    join(",
                        "      [\",\", line],",
                        "      urls.map((url, index) => {",
                        "        const parts = [url];",
                        "",
                        "        const descriptor = descriptors[index];",
                        "        if (descriptor) {",
                        "          const urlPadding = maxUrlLength - url.length + 1;",
                        "          const descriptorPadding =",
                        "            maxDescriptorLeftLength - descriptorLeftLengths[index];",
                        "",
                        "          const alignment = \" \".repeat(urlPadding + descriptorPadding);",
                        "          parts.push(ifBreak(alignment, \" \"), descriptor + unit);",
                        "        }",
                        "",
                        "        return parts;",
                        "      })",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "export default printSrcset;"
                    ]
                },
                "style.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { getUnescapedAttributeValue } from \"../utils/index.js\";",
                        "import { printExpand } from \"./utils.js\";",
                        "",
                        "function printStyleAttribute(path, options) {",
                        "  const { node } = path;",
                        "  const text = getUnescapedAttributeValue(path.node).trim();",
                        "  if (",
                        "    node.fullName === \"style\" &&",
                        "    !options.parentParser &&",
                        "    !text.includes(\"{{\")",
                        "  ) {",
                        "    return async (textToDoc) =>",
                        "      printExpand(",
                        "        await textToDoc(text, { parser: \"css\", __isHTMLStyleAttribute: true })",
                        "      );",
                        "  }",
                        "}",
                        "",
                        "export { printStyleAttribute };"
                    ]
                },
                "utils.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { group, indent, softline } from \"../../document/builders.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "function printExpand(doc, canHaveTrailingWhitespace = true) {",
                        "  return [indent([softline, doc]), canHaveTrailingWhitespace ? softline : \"\"];",
                        "}",
                        "",
                        "function shouldHugJsExpression(ast, options) {",
                        "  const rootNode =",
                        "    ast.type === \"NGRoot\"",
                        "      ? ast.node.type === \"NGMicrosyntax\" &&",
                        "        ast.node.body.length === 1 &&",
                        "        ast.node.body[0].type === \"NGMicrosyntaxExpression\"",
                        "        ? ast.node.body[0].expression",
                        "        : ast.node",
                        "      : ast.type === \"JsExpressionRoot\"",
                        "      ? ast.node",
                        "      : ast;",
                        "  return (",
                        "    rootNode &&",
                        "    (rootNode.type === \"ObjectExpression\" ||",
                        "      rootNode.type === \"ArrayExpression\" ||",
                        "      ((options.parser === \"__vue_expression\" ||",
                        "        options.parser === \"__vue_ts_expression\") &&",
                        "        (rootNode.type === \"TemplateLiteral\" ||",
                        "          rootNode.type === \"StringLiteral\")))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {string} code",
                        " * @param {Function} textToDoc",
                        " * @param {*} options",
                        " * @param {(ast: any, options: any) => boolean} [shouldHugJsExpression]",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "async function formatAttributeValue(",
                        "  code,",
                        "  textToDoc,",
                        "  options,",
                        "  shouldHugJsExpression",
                        ") {",
                        "  options = {",
                        "    // strictly prefer single quote to avoid unnecessary html entity escape",
                        "    __isInHtmlAttribute: true,",
                        "    __embeddedInHtml: true,",
                        "    ...options,",
                        "  };",
                        "",
                        "  let shouldHug = true;",
                        "  if (shouldHugJsExpression) {",
                        "    options.__onHtmlBindingRoot = (ast, options) => {",
                        "      shouldHug = shouldHugJsExpression(ast, options);",
                        "    };",
                        "  }",
                        "",
                        "  const doc = await textToDoc(code, options, textToDoc);",
                        "",
                        "  return shouldHug ? group(doc) : printExpand(doc);",
                        "}",
                        "",
                        "export { printExpand, formatAttributeValue, shouldHugJsExpression };"
                    ]
                },
                "vue-attributes.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  isVueSlotAttribute,",
                        "  isVueSfcBindingsAttribute,",
                        "  getUnescapedAttributeValue,",
                        "} from \"../utils/index.js\";",
                        "import isVueSfcWithTypescriptScript from \"../utils/is-vue-sfc-with-typescript-script.js\";",
                        "import { printVueVForDirective } from \"./vue-v-for-directive.js\";",
                        "import { formatAttributeValue, shouldHugJsExpression } from \"./utils.js\";",
                        "import {",
                        "  printVueBindings,",
                        "  isVueEventBindingExpression,",
                        "} from \"./vue-bindings.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path.js\")} AstPath",
                        " */",
                        "",
                        "function printVueAttribute(path, options) {",
                        "  if (options.parser !== \"vue\") {",
                        "    return;",
                        "  }",
                        "  const { node } = path;",
                        "  const attributeName = node.fullName;",
                        "",
                        "  if (attributeName === \"v-for\") {",
                        "    return printVueVForDirective;",
                        "  }",
                        "",
                        "  const value = getUnescapedAttributeValue(node);",
                        "  const parseWithTs = isVueSfcWithTypescriptScript(path, options);",
                        "",
                        "  if (isVueSlotAttribute(node) || isVueSfcBindingsAttribute(node, options)) {",
                        "    return (textToDoc) => printVueBindings(value, textToDoc, { parseWithTs });",
                        "  }",
                        "",
                        "  /**",
                        "   *     @click=\"jsStatement\"",
                        "   *     @click=\"jsExpression\"",
                        "   *     v-on:click=\"jsStatement\"",
                        "   *     v-on:click=\"jsExpression\"",
                        "   */",
                        "  if (attributeName.startsWith(\"@\") || attributeName.startsWith(\"v-on:\")) {",
                        "    return (textToDoc) =>",
                        "      printVueVOnDirective(value, textToDoc, { parseWithTs });",
                        "  }",
                        "",
                        "  /**",
                        "   *     :class=\"vueExpression\"",
                        "   *     v-bind:id=\"vueExpression\"",
                        "   */",
                        "  if (attributeName.startsWith(\":\") || attributeName.startsWith(\"v-bind:\")) {",
                        "    return (textToDoc) =>",
                        "      printVueVBindDirective(value, textToDoc, { parseWithTs });",
                        "  }",
                        "",
                        "  /**",
                        "   *     v-if=\"jsExpression\"",
                        "   */",
                        "  if (attributeName.startsWith(\"v-\")) {",
                        "    return (textToDoc) => printExpression(value, textToDoc, { parseWithTs });",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "function printVueVOnDirective(text, textToDoc, { parseWithTs }) {",
                        "  if (isVueEventBindingExpression(text)) {",
                        "    return printExpression(text, textToDoc, { parseWithTs });",
                        "  }",
                        "",
                        "  return formatAttributeValue(",
                        "    text,",
                        "    textToDoc,",
                        "    { parser: parseWithTs ? \"__vue_ts_event_binding\" : \"__vue_event_binding\" },",
                        "    shouldHugJsExpression",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "function printVueVBindDirective(text, textToDoc, { parseWithTs }) {",
                        "  return formatAttributeValue(",
                        "    text,",
                        "    textToDoc,",
                        "    { parser: parseWithTs ? \"__vue_ts_expression\" : \"__vue_expression\" },",
                        "    shouldHugJsExpression",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "function printExpression(text, textToDoc, { parseWithTs }) {",
                        "  return formatAttributeValue(",
                        "    text,",
                        "    textToDoc,",
                        "    { parser: parseWithTs ? \"__ts_expression\" : \"__js_expression\" },",
                        "    shouldHugJsExpression",
                        "  );",
                        "}",
                        "",
                        "export default printVueAttribute;"
                    ]
                },
                "vue-bindings.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { formatAttributeValue } from \"./utils.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "/**",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "function printVueBindings(text, textToDoc, { parseWithTs }) {",
                        "  return formatAttributeValue(`function _(${text}) {}`, textToDoc, {",
                        "    parser: parseWithTs ? \"babel-ts\" : \"babel\",",
                        "    __isVueBindings: true,",
                        "  });",
                        "}",
                        "",
                        "function isVueEventBindingExpression(eventBindingValue) {",
                        "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/codegen/events.js#L3-L4",
                        "  // arrow function or anonymous function",
                        "  const fnExpRE = /^(?:[\\w$]+|\\([^)]*\\))\\s*=>|^function\\s*\\(/;",
                        "  // simple member expression chain (a, a.b, a['b'], a[\"b\"], a[0], a[b])",
                        "  const simplePathRE =",
                        "    /^[$A-Z_a-z][\\w$]*(?:\\.[$A-Z_a-z][\\w$]*|\\['[^']*']|\\[\"[^\"]*\"]|\\[\\d+]|\\[[$A-Z_a-z][\\w$]*])*$/;",
                        "",
                        "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/helpers.js#L104",
                        "  const value = eventBindingValue.trim();",
                        "",
                        "  return fnExpRE.test(value) || simplePathRE.test(value);",
                        "}",
                        "",
                        "export { isVueEventBindingExpression, printVueBindings };"
                    ]
                },
                "vue-v-for-directive.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { group } from \"../../document/builders.js\";",
                        "import { getUnescapedAttributeValue } from \"../utils/index.js\";",
                        "import isVueSfcWithTypescriptScript from \"../utils/is-vue-sfc-with-typescript-script.js\";",
                        "import { formatAttributeValue } from \"./utils.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "/**",
                        " *     v-for=\"... in ...\"",
                        " *     v-for=\"... of ...\"",
                        " *     v-for=\"(..., ...) in ...\"",
                        " *     v-for=\"(..., ...) of ...\"",
                        " *",
                        " * @param {*} options",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "async function printVueVForDirective(textToDoc, print, path, options) {",
                        "  const value = getUnescapedAttributeValue(path.node);",
                        "  const { left, operator, right } = parseVueVForDirective(value);",
                        "  const parseWithTs = isVueSfcWithTypescriptScript(path, options);",
                        "  return [",
                        "    group(",
                        "      await formatAttributeValue(`function _(${left}) {}`, textToDoc, {",
                        "        parser: parseWithTs ? \"babel-ts\" : \"babel\",",
                        "        __isVueForBindingLeft: true,",
                        "      })",
                        "    ),",
                        "    \" \",",
                        "    operator,",
                        "    \" \",",
                        "    await formatAttributeValue(right, textToDoc, {",
                        "      parser: parseWithTs ? \"__ts_expression\" : \"__js_expression\",",
                        "    }),",
                        "  ];",
                        "}",
                        "",
                        "// modified from https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/parser/index.js#L370-L387",
                        "function parseVueVForDirective(value) {",
                        "  const forAliasRE = /(.*?)\\s+(in|of)\\s+(.*)/s;",
                        "  const forIteratorRE = /,([^,\\]}]*)(?:,([^,\\]}]*))?$/;",
                        "  const stripParensRE = /^\\(|\\)$/g;",
                        "",
                        "  const inMatch = value.match(forAliasRE);",
                        "  if (!inMatch) {",
                        "    return;",
                        "  }",
                        "",
                        "  const res = {};",
                        "  res.for = inMatch[3].trim();",
                        "  if (!res.for) {",
                        "    return;",
                        "  }",
                        "",
                        "  const alias = inMatch[1].trim().replaceAll(stripParensRE, \"\");",
                        "  const iteratorMatch = alias.match(forIteratorRE);",
                        "  if (iteratorMatch) {",
                        "    res.alias = alias.replace(forIteratorRE, \"\");",
                        "    res.iterator1 = iteratorMatch[1].trim();",
                        "    if (iteratorMatch[2]) {",
                        "      res.iterator2 = iteratorMatch[2].trim();",
                        "    }",
                        "  } else {",
                        "    res.alias = alias;",
                        "  }",
                        "",
                        "  const left = [res.alias, res.iterator1, res.iterator2];",
                        "  if (",
                        "    left.some(",
                        "      (part, index) =>",
                        "        !part && (index === 0 || left.slice(index + 1).some(Boolean))",
                        "    )",
                        "  ) {",
                        "    return;",
                        "  }",
                        "",
                        "  return {",
                        "    left: left.filter(Boolean).join(\",\"),",
                        "    operator: inMatch[2],",
                        "    right: res.for,",
                        "  };",
                        "}",
                        "",
                        "export { printVueVForDirective };"
                    ]
                }
            },
            "print": {
                "children.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  breakParent,",
                        "  group,",
                        "  ifBreak,",
                        "  line,",
                        "  softline,",
                        "  hardline,",
                        "} from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import {",
                        "  forceBreakChildren,",
                        "  forceNextEmptyLine,",
                        "  isTextLikeNode,",
                        "  hasPrettierIgnore,",
                        "  preferHardlineAsLeadingSpaces,",
                        "} from \"../utils/index.js\";",
                        "import {",
                        "  printOpeningTagPrefix,",
                        "  needsToBorrowNextOpeningTagStartMarker,",
                        "  printOpeningTagStartMarker,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  printClosingTagEndMarker,",
                        "  printClosingTagSuffix,",
                        "  needsToBorrowParentClosingTagStartMarker,",
                        "} from \"./tag.js\";",
                        "",
                        "function printChild(childPath, options, print) {",
                        "  const child = childPath.node;",
                        "",
                        "  if (hasPrettierIgnore(child)) {",
                        "    return [",
                        "      printOpeningTagPrefix(child, options),",
                        "      replaceEndOfLine(",
                        "        options.originalText.slice(",
                        "          locStart(child) +",
                        "            (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev)",
                        "              ? printOpeningTagStartMarker(child).length",
                        "              : 0),",
                        "          locEnd(child) -",
                        "            (child.next && needsToBorrowPrevClosingTagEndMarker(child.next)",
                        "              ? printClosingTagEndMarker(child, options).length",
                        "              : 0)",
                        "        )",
                        "      ),",
                        "      printClosingTagSuffix(child, options),",
                        "    ];",
                        "  }",
                        "",
                        "  return print();",
                        "}",
                        "",
                        "function printBetweenLine(prevNode, nextNode) {",
                        "  return isTextLikeNode(prevNode) && isTextLikeNode(nextNode)",
                        "    ? prevNode.isTrailingSpaceSensitive",
                        "      ? prevNode.hasTrailingSpaces",
                        "        ? preferHardlineAsLeadingSpaces(nextNode)",
                        "          ? hardline",
                        "          : line",
                        "        : \"\"",
                        "      : preferHardlineAsLeadingSpaces(nextNode)",
                        "      ? hardline",
                        "      : softline",
                        "    : (needsToBorrowNextOpeningTagStartMarker(prevNode) &&",
                        "        (hasPrettierIgnore(nextNode) ||",
                        "          /**",
                        "           *     123<a",
                        "           *          ~",
                        "           *       ><b>",
                        "           */",
                        "          nextNode.firstChild ||",
                        "          /**",
                        "           *     123<!--",
                        "           *            ~",
                        "           *     -->",
                        "           */",
                        "          nextNode.isSelfClosing ||",
                        "          /**",
                        "           *     123<span",
                        "           *             ~",
                        "           *       attr",
                        "           */",
                        "          (nextNode.type === \"element\" && nextNode.attrs.length > 0))) ||",
                        "      /**",
                        "       *     <img",
                        "       *       src=\"long\"",
                        "       *                 ~",
                        "       *     />123",
                        "       */",
                        "      (prevNode.type === \"element\" &&",
                        "        prevNode.isSelfClosing &&",
                        "        needsToBorrowPrevClosingTagEndMarker(nextNode))",
                        "    ? \"\"",
                        "    : !nextNode.isLeadingSpaceSensitive ||",
                        "      preferHardlineAsLeadingSpaces(nextNode) ||",
                        "      /**",
                        "       *       Want to write us a letter? Use our<a",
                        "       *         ><b><a>mailing address</a></b></a",
                        "       *                                          ~",
                        "       *       >.",
                        "       */",
                        "      (needsToBorrowPrevClosingTagEndMarker(nextNode) &&",
                        "        prevNode.lastChild &&",
                        "        needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) &&",
                        "        prevNode.lastChild.lastChild &&",
                        "        needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild))",
                        "    ? hardline",
                        "    : nextNode.hasLeadingSpaces",
                        "    ? line",
                        "    : softline;",
                        "}",
                        "",
                        "function printChildren(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (forceBreakChildren(node)) {",
                        "    return [",
                        "      breakParent,",
                        "",
                        "      ...path.map((childPath) => {",
                        "        const childNode = childPath.node;",
                        "        const prevBetweenLine = !childNode.prev",
                        "          ? \"\"",
                        "          : printBetweenLine(childNode.prev, childNode);",
                        "        return [",
                        "          !prevBetweenLine",
                        "            ? \"\"",
                        "            : [",
                        "                prevBetweenLine,",
                        "                forceNextEmptyLine(childNode.prev) ? hardline : \"\",",
                        "              ],",
                        "          printChild(childPath, options, print),",
                        "        ];",
                        "      }, \"children\"),",
                        "    ];",
                        "  }",
                        "",
                        "  const groupIds = node.children.map(() => Symbol(\"\"));",
                        "  return path.map((childPath, childIndex) => {",
                        "    const childNode = childPath.node;",
                        "",
                        "    if (isTextLikeNode(childNode)) {",
                        "      if (childNode.prev && isTextLikeNode(childNode.prev)) {",
                        "        const prevBetweenLine = printBetweenLine(childNode.prev, childNode);",
                        "        if (prevBetweenLine) {",
                        "          if (forceNextEmptyLine(childNode.prev)) {",
                        "            return [hardline, hardline, printChild(childPath, options, print)];",
                        "          }",
                        "          return [prevBetweenLine, printChild(childPath, options, print)];",
                        "        }",
                        "      }",
                        "      return printChild(childPath, options, print);",
                        "    }",
                        "",
                        "    const prevParts = [];",
                        "    const leadingParts = [];",
                        "    const trailingParts = [];",
                        "    const nextParts = [];",
                        "",
                        "    const prevBetweenLine = childNode.prev",
                        "      ? printBetweenLine(childNode.prev, childNode)",
                        "      : \"\";",
                        "",
                        "    const nextBetweenLine = childNode.next",
                        "      ? printBetweenLine(childNode, childNode.next)",
                        "      : \"\";",
                        "",
                        "    if (prevBetweenLine) {",
                        "      if (forceNextEmptyLine(childNode.prev)) {",
                        "        prevParts.push(hardline, hardline);",
                        "      } else if (prevBetweenLine === hardline) {",
                        "        prevParts.push(hardline);",
                        "      } else if (isTextLikeNode(childNode.prev)) {",
                        "        leadingParts.push(prevBetweenLine);",
                        "      } else {",
                        "        leadingParts.push(",
                        "          ifBreak(\"\", softline, {",
                        "            groupId: groupIds[childIndex - 1],",
                        "          })",
                        "        );",
                        "      }",
                        "    }",
                        "",
                        "    if (nextBetweenLine) {",
                        "      if (forceNextEmptyLine(childNode)) {",
                        "        if (isTextLikeNode(childNode.next)) {",
                        "          nextParts.push(hardline, hardline);",
                        "        }",
                        "      } else if (nextBetweenLine === hardline) {",
                        "        if (isTextLikeNode(childNode.next)) {",
                        "          nextParts.push(hardline);",
                        "        }",
                        "      } else {",
                        "        trailingParts.push(nextBetweenLine);",
                        "      }",
                        "    }",
                        "",
                        "    return [",
                        "      ...prevParts,",
                        "      group([",
                        "        ...leadingParts,",
                        "        group([printChild(childPath, options, print), ...trailingParts], {",
                        "          id: groupIds[childIndex],",
                        "        }),",
                        "      ]),",
                        "      ...nextParts,",
                        "    ];",
                        "  }, \"children\");",
                        "}",
                        "",
                        "export { printChildren };"
                    ]
                },
                "element.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  breakParent,",
                        "  dedentToRoot,",
                        "  group,",
                        "  ifBreak,",
                        "  indentIfBreak,",
                        "  indent,",
                        "  line,",
                        "  softline,",
                        "} from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import getNodeContent from \"../get-node-content.js\";",
                        "import {",
                        "  shouldPreserveContent,",
                        "  isScriptLikeTag,",
                        "  isVueCustomBlock,",
                        "  forceBreakContent,",
                        "} from \"../utils/index.js\";",
                        "import {",
                        "  printOpeningTagPrefix,",
                        "  printOpeningTag,",
                        "  printClosingTagSuffix,",
                        "  printClosingTag,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  needsToBorrowLastChildClosingTagEndMarker,",
                        "} from \"./tag.js\";",
                        "import { printChildren } from \"./children.js\";",
                        "",
                        "function printElement(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (shouldPreserveContent(node, options)) {",
                        "    return [",
                        "      printOpeningTagPrefix(node, options),",
                        "      group(printOpeningTag(path, options, print)),",
                        "      replaceEndOfLine(getNodeContent(node, options)),",
                        "      ...printClosingTag(node, options),",
                        "      printClosingTagSuffix(node, options),",
                        "    ];",
                        "  }",
                        "  /**",
                        "   * do not break:",
                        "   *",
                        "   *     <div>{{",
                        "   *         ~",
                        "   *       interpolation",
                        "   *     }}</div>",
                        "   *            ~",
                        "   *",
                        "   * exception: break if the opening tag breaks",
                        "   *",
                        "   *     <div",
                        "   *       long",
                        "   *           ~",
                        "   *       >{{",
                        "   *         interpolation",
                        "   *       }}</div",
                        "   *              ~",
                        "   *     >",
                        "   */",
                        "  const shouldHugContent =",
                        "    node.children.length === 1 &&",
                        "    node.firstChild.type === \"interpolation\" &&",
                        "    node.firstChild.isLeadingSpaceSensitive &&",
                        "    !node.firstChild.hasLeadingSpaces &&",
                        "    node.lastChild.isTrailingSpaceSensitive &&",
                        "    !node.lastChild.hasTrailingSpaces;",
                        "",
                        "  const attrGroupId = Symbol(\"element-attr-group-id\");",
                        "",
                        "  const printTag = (doc) =>",
                        "    group([",
                        "      group(printOpeningTag(path, options, print), { id: attrGroupId }),",
                        "      doc,",
                        "      printClosingTag(node, options),",
                        "    ]);",
                        "",
                        "  const printChildrenDoc = (childrenDoc) => {",
                        "    if (shouldHugContent) {",
                        "      return indentIfBreak(childrenDoc, { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      (isScriptLikeTag(node) || isVueCustomBlock(node, options)) &&",
                        "      node.parent.type === \"root\" &&",
                        "      options.parser === \"vue\" &&",
                        "      !options.vueIndentScriptAndStyle",
                        "    ) {",
                        "      return childrenDoc;",
                        "    }",
                        "    return indent(childrenDoc);",
                        "  };",
                        "",
                        "  const printLineBeforeChildren = () => {",
                        "    if (shouldHugContent) {",
                        "      return ifBreak(softline, \"\", { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      node.firstChild.hasLeadingSpaces &&",
                        "      node.firstChild.isLeadingSpaceSensitive",
                        "    ) {",
                        "      return line;",
                        "    }",
                        "    if (",
                        "      node.firstChild.type === \"text\" &&",
                        "      node.isWhitespaceSensitive &&",
                        "      node.isIndentationSensitive",
                        "    ) {",
                        "      return dedentToRoot(softline);",
                        "    }",
                        "    return softline;",
                        "  };",
                        "",
                        "  const printLineAfterChildren = () => {",
                        "    const needsToBorrow = node.next",
                        "      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                        "      : needsToBorrowLastChildClosingTagEndMarker(node.parent);",
                        "    if (needsToBorrow) {",
                        "      if (",
                        "        node.lastChild.hasTrailingSpaces &&",
                        "        node.lastChild.isTrailingSpaceSensitive",
                        "      ) {",
                        "        return \" \";",
                        "      }",
                        "      return \"\";",
                        "    }",
                        "    if (shouldHugContent) {",
                        "      return ifBreak(softline, \"\", { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      node.lastChild.hasTrailingSpaces &&",
                        "      node.lastChild.isTrailingSpaceSensitive",
                        "    ) {",
                        "      return line;",
                        "    }",
                        "    if (",
                        "      (node.lastChild.type === \"comment\" ||",
                        "        (node.lastChild.type === \"text\" &&",
                        "          node.isWhitespaceSensitive &&",
                        "          node.isIndentationSensitive)) &&",
                        "      new RegExp(",
                        "        `\\\\n[\\\\t ]{${options.tabWidth * (path.ancestors.length - 1)}}$`",
                        "      ).test(node.lastChild.value)",
                        "    ) {",
                        "      return \"\";",
                        "    }",
                        "    return softline;",
                        "  };",
                        "",
                        "  if (node.children.length === 0) {",
                        "    return printTag(",
                        "      node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line : \"\"",
                        "    );",
                        "  }",
                        "",
                        "  return printTag([",
                        "    forceBreakContent(node) ? breakParent : \"\",",
                        "    printChildrenDoc([",
                        "      printLineBeforeChildren(),",
                        "      printChildren(path, options, print),",
                        "    ]),",
                        "    printLineAfterChildren(),",
                        "  ]);",
                        "}",
                        "",
                        "export { printElement };"
                    ]
                },
                "tag.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "import assert from \"node:assert\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  indent,",
                        "  join,",
                        "  line,",
                        "  softline,",
                        "  hardline,",
                        "} from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import {",
                        "  isTextLikeNode,",
                        "  getLastDescendant,",
                        "  isPreLikeNode,",
                        "  hasPrettierIgnore,",
                        "  shouldPreserveContent,",
                        "  isVueSfcBlock,",
                        "} from \"../utils/index.js\";",
                        "",
                        "function printClosingTag(node, options) {",
                        "  return [",
                        "    node.isSelfClosing ? \"\" : printClosingTagStart(node, options),",
                        "    printClosingTagEnd(node, options),",
                        "  ];",
                        "}",
                        "",
                        "function printClosingTagStart(node, options) {",
                        "  return node.lastChild &&",
                        "    needsToBorrowParentClosingTagStartMarker(node.lastChild)",
                        "    ? \"\"",
                        "    : [",
                        "        printClosingTagPrefix(node, options),",
                        "        printClosingTagStartMarker(node, options),",
                        "      ];",
                        "}",
                        "",
                        "function printClosingTagEnd(node, options) {",
                        "  return (",
                        "    node.next",
                        "      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                        "      : needsToBorrowLastChildClosingTagEndMarker(node.parent)",
                        "  )",
                        "    ? \"\"",
                        "    : [",
                        "        printClosingTagEndMarker(node, options),",
                        "        printClosingTagSuffix(node, options),",
                        "      ];",
                        "}",
                        "",
                        "function printClosingTagPrefix(node, options) {",
                        "  return needsToBorrowLastChildClosingTagEndMarker(node)",
                        "    ? printClosingTagEndMarker(node.lastChild, options)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printClosingTagSuffix(node, options) {",
                        "  return needsToBorrowParentClosingTagStartMarker(node)",
                        "    ? printClosingTagStartMarker(node.parent, options)",
                        "    : needsToBorrowNextOpeningTagStartMarker(node)",
                        "    ? printOpeningTagStartMarker(node.next)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printClosingTagStartMarker(node, options) {",
                        "  assert(!node.isSelfClosing);",
                        "  /* c8 ignore next 3 */",
                        "  if (shouldNotPrintClosingTag(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "      return \"<!\";",
                        "    case \"element\":",
                        "      if (node.hasHtmComponentClosingTag) {",
                        "        return \"<//\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return `</${node.rawName}`;",
                        "  }",
                        "}",
                        "",
                        "function printClosingTagEndMarker(node, options) {",
                        "  if (shouldNotPrintClosingTag(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"ieConditionalEndComment\":",
                        "      return \"[endif]-->\";",
                        "    case \"ieConditionalStartComment\":",
                        "      return \"]><!-->\";",
                        "    case \"interpolation\":",
                        "      return \"}}\";",
                        "    case \"element\":",
                        "      if (node.isSelfClosing) {",
                        "        return \"/>\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return \">\";",
                        "  }",
                        "}",
                        "",
                        "function shouldNotPrintClosingTag(node, options) {",
                        "  return (",
                        "    !node.isSelfClosing &&",
                        "    !node.endSourceSpan &&",
                        "    (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options))",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowPrevClosingTagEndMarker(node) {",
                        "  /**",
                        "   *     <p></p",
                        "   *     >123",
                        "   *     ^",
                        "   *",
                        "   *     <p></p",
                        "   *     ><a",
                        "   *     ^",
                        "   */",
                        "  return (",
                        "    node.prev &&",
                        "    node.prev.type !== \"docType\" &&",
                        "    !isTextLikeNode(node.prev) &&",
                        "    node.isLeadingSpaceSensitive &&",
                        "    !node.hasLeadingSpaces",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowLastChildClosingTagEndMarker(node) {",
                        "  /**",
                        "   *     <p",
                        "   *       ><a></a",
                        "   *       ></p",
                        "   *       ^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    node.lastChild?.isTrailingSpaceSensitive &&",
                        "    !node.lastChild.hasTrailingSpaces &&",
                        "    !isTextLikeNode(getLastDescendant(node.lastChild)) &&",
                        "    !isPreLikeNode(node)",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowParentClosingTagStartMarker(node) {",
                        "  /**",
                        "   *     <p>",
                        "   *       123</p",
                        "   *          ^^^",
                        "   *     >",
                        "   *",
                        "   *         123</b",
                        "   *       ></a",
                        "   *        ^^^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    !node.next &&",
                        "    !node.hasTrailingSpaces &&",
                        "    node.isTrailingSpaceSensitive &&",
                        "    isTextLikeNode(getLastDescendant(node))",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowNextOpeningTagStartMarker(node) {",
                        "  /**",
                        "   *     123<p",
                        "   *        ^^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    node.next &&",
                        "    !isTextLikeNode(node.next) &&",
                        "    isTextLikeNode(node) &&",
                        "    node.isTrailingSpaceSensitive &&",
                        "    !node.hasTrailingSpaces",
                        "  );",
                        "}",
                        "",
                        "function getPrettierIgnoreAttributeCommentData(value) {",
                        "  const match = value.trim().match(/^prettier-ignore-attribute(?:\\s+(.+))?$/s);",
                        "",
                        "  if (!match) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!match[1]) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return match[1].split(/\\s+/);",
                        "}",
                        "",
                        "function needsToBorrowParentOpeningTagEndMarker(node) {",
                        "  /**",
                        "   *     <p",
                        "   *       >123",
                        "   *       ^",
                        "   *",
                        "   *     <p",
                        "   *       ><a",
                        "   *       ^",
                        "   */",
                        "  return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;",
                        "}",
                        "",
                        "function printAttributes(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (!isNonEmptyArray(node.attrs)) {",
                        "    return node.isSelfClosing",
                        "      ? /**",
                        "         *     <br />",
                        "         *        ^",
                        "         */",
                        "        \" \"",
                        "      : \"\";",
                        "  }",
                        "",
                        "  const ignoreAttributeData =",
                        "    node.prev?.type === \"comment\" &&",
                        "    getPrettierIgnoreAttributeCommentData(node.prev.value);",
                        "",
                        "  const hasPrettierIgnoreAttribute =",
                        "    typeof ignoreAttributeData === \"boolean\"",
                        "      ? () => ignoreAttributeData",
                        "      : Array.isArray(ignoreAttributeData)",
                        "      ? (attribute) => ignoreAttributeData.includes(attribute.rawName)",
                        "      : () => false;",
                        "",
                        "  const printedAttributes = path.map(",
                        "    ({ node: attribute }) =>",
                        "      hasPrettierIgnoreAttribute(attribute)",
                        "        ? replaceEndOfLine(",
                        "            options.originalText.slice(locStart(attribute), locEnd(attribute))",
                        "          )",
                        "        : print(),",
                        "    \"attrs\"",
                        "  );",
                        "",
                        "  const forceNotToBreakAttrContent =",
                        "    node.type === \"element\" &&",
                        "    node.fullName === \"script\" &&",
                        "    node.attrs.length === 1 &&",
                        "    node.attrs[0].fullName === \"src\" &&",
                        "    node.children.length === 0;",
                        "",
                        "  const shouldPrintAttributePerLine =",
                        "    options.singleAttributePerLine &&",
                        "    node.attrs.length > 1 &&",
                        "    !isVueSfcBlock(node, options);",
                        "  const attributeLine = shouldPrintAttributePerLine ? hardline : line;",
                        "",
                        "  /** @type {Doc[]} */",
                        "  const parts = [",
                        "    indent([",
                        "      forceNotToBreakAttrContent ? \" \" : line,",
                        "      join(attributeLine, printedAttributes),",
                        "    ]),",
                        "  ];",
                        "",
                        "  if (",
                        "    /**",
                        "     *     123<a",
                        "     *       attr",
                        "     *           ~",
                        "     *       >456",
                        "     */",
                        "    (node.firstChild &&",
                        "      needsToBorrowParentOpeningTagEndMarker(node.firstChild)) ||",
                        "    /**",
                        "     *     <span",
                        "     *       >123<meta",
                        "     *                ~",
                        "     *     /></span>",
                        "     */",
                        "    (node.isSelfClosing &&",
                        "      needsToBorrowLastChildClosingTagEndMarker(node.parent)) ||",
                        "    forceNotToBreakAttrContent",
                        "  ) {",
                        "    parts.push(node.isSelfClosing ? \" \" : \"\");",
                        "  } else {",
                        "    parts.push(",
                        "      options.bracketSameLine",
                        "        ? node.isSelfClosing",
                        "          ? \" \"",
                        "          : \"\"",
                        "        : node.isSelfClosing",
                        "        ? line",
                        "        : softline",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printOpeningTagEnd(node) {",
                        "  return node.firstChild &&",
                        "    needsToBorrowParentOpeningTagEndMarker(node.firstChild)",
                        "    ? \"\"",
                        "    : printOpeningTagEndMarker(node);",
                        "}",
                        "",
                        "function printOpeningTag(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  return [",
                        "    printOpeningTagStart(node, options),",
                        "    printAttributes(path, options, print),",
                        "    node.isSelfClosing ? \"\" : printOpeningTagEnd(node),",
                        "  ];",
                        "}",
                        "",
                        "function printOpeningTagStart(node, options) {",
                        "  return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev)",
                        "    ? \"\"",
                        "    : [printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)];",
                        "}",
                        "",
                        "function printOpeningTagPrefix(node, options) {",
                        "  return needsToBorrowParentOpeningTagEndMarker(node)",
                        "    ? printOpeningTagEndMarker(node.parent)",
                        "    : needsToBorrowPrevClosingTagEndMarker(node)",
                        "    ? printClosingTagEndMarker(node.prev, options)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printOpeningTagStartMarker(node) {",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"ieConditionalStartComment\":",
                        "      return `<!--[if ${node.condition}`;",
                        "    case \"ieConditionalEndComment\":",
                        "      return \"<!--<!\";",
                        "    case \"interpolation\":",
                        "      return \"{{\";",
                        "    case \"docType\":",
                        "      return node.value === \"html\" ? \"<!doctype\" : \"<!DOCTYPE\";",
                        "    case \"element\":",
                        "      if (node.condition) {",
                        "        return `<!--[if ${node.condition}]><!--><${node.rawName}`;",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return `<${node.rawName}`;",
                        "  }",
                        "}",
                        "",
                        "function printOpeningTagEndMarker(node) {",
                        "  assert(!node.isSelfClosing);",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "      return \"]>\";",
                        "    case \"element\":",
                        "      if (node.condition) {",
                        "        return \"><!--<![endif]-->\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return \">\";",
                        "  }",
                        "}",
                        "",
                        "export {",
                        "  printClosingTag,",
                        "  printClosingTagStart,",
                        "  printClosingTagStartMarker,",
                        "  printClosingTagEndMarker,",
                        "  printClosingTagSuffix,",
                        "  printClosingTagEnd,",
                        "  needsToBorrowLastChildClosingTagEndMarker,",
                        "  needsToBorrowParentClosingTagStartMarker,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  printOpeningTag,",
                        "  printOpeningTagStart,",
                        "  printOpeningTagPrefix,",
                        "  printOpeningTagStartMarker,",
                        "  printOpeningTagEndMarker,",
                        "  needsToBorrowNextOpeningTagStartMarker,",
                        "  needsToBorrowParentOpeningTagEndMarker,",
                        "};"
                    ]
                }
            },
            "utils": {
                "html-elements-attributes.evaluate.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { htmlElementAttributes } from \"html-element-attributes\";",
                        "",
                        "const HTML_ELEMENT_ATTRIBUTES = new Map(",
                        "  Object.entries(htmlElementAttributes).map(([tagName, attributes]) => [",
                        "    tagName,",
                        "    new Set(attributes),",
                        "  ])",
                        ");",
                        "",
                        "export default HTML_ELEMENT_ATTRIBUTES;"
                    ]
                },
                "html-tag-names.evaluate.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { htmlTagNames } from \"html-tag-names\";",
                        "",
                        "const HTML_TAGS = new Set(htmlTagNames);",
                        "",
                        "export default HTML_TAGS;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " */",
                        "",
                        "import isFrontMatter from \"../../utils/front-matter/is-front-matter.js\";",
                        "import inferParser from \"../../utils/infer-parser.js\";",
                        "import { line, hardline, join } from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import {",
                        "  CSS_DISPLAY_TAGS,",
                        "  CSS_DISPLAY_DEFAULT,",
                        "  CSS_WHITE_SPACE_TAGS,",
                        "  CSS_WHITE_SPACE_DEFAULT,",
                        "} from \"../constants.evaluate.js\";",
                        "import htmlWhitespaceUtils from \"../../utils/html-whitespace-utils.js\";",
                        "import isUnknownNamespace from \"./is-unknown-namespace.js\";",
                        "",
                        "const htmlTrimLeadingBlankLines = (string) =>",
                        "  string.replaceAll(/^[\\t\\f\\r ]*\\n/g, \"\");",
                        "const htmlTrimPreserveIndentation = (string) =>",
                        "  htmlTrimLeadingBlankLines(htmlWhitespaceUtils.trimEnd(string));",
                        "const getLeadingAndTrailingHtmlWhitespace = (string) => {",
                        "  let text = string;",
                        "  const leadingWhitespace = htmlWhitespaceUtils.getLeadingWhitespace(text);",
                        "  if (leadingWhitespace) {",
                        "    text = text.slice(leadingWhitespace.length);",
                        "  }",
                        "  const trailingWhitespace = htmlWhitespaceUtils.getTrailingWhitespace(text);",
                        "  if (trailingWhitespace) {",
                        "    text = text.slice(0, -trailingWhitespace.length);",
                        "  }",
                        "",
                        "  return {",
                        "    leadingWhitespace,",
                        "    trailingWhitespace,",
                        "    text,",
                        "  };",
                        "};",
                        "",
                        "function shouldPreserveContent(node, options) {",
                        "  // unterminated node in ie conditional comment",
                        "  // e.g. <!--[if lt IE 9]><html><![endif]-->",
                        "  if (",
                        "    node.type === \"ieConditionalComment\" &&",
                        "    node.lastChild &&",
                        "    !node.lastChild.isSelfClosing &&",
                        "    !node.lastChild.endSourceSpan",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // incomplete html in ie conditional comment",
                        "  // e.g. <!--[if lt IE 9]></div><![endif]-->",
                        "  if (node.type === \"ieConditionalComment\" && !node.complete) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // TODO: handle non-text children in <pre>",
                        "  if (",
                        "    isPreLikeNode(node) &&",
                        "    node.children.some(",
                        "      (child) => child.type !== \"text\" && child.type !== \"interpolation\"",
                        "    )",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    isVueNonHtmlBlock(node, options) &&",
                        "    !isScriptLikeTag(node) &&",
                        "    node.type !== \"interpolation\"",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function hasPrettierIgnore(node) {",
                        "  /* c8 ignore next 3 */",
                        "  if (node.type === \"attribute\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (!node.parent) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!node.prev) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return isPrettierIgnore(node.prev);",
                        "}",
                        "",
                        "function isPrettierIgnore(node) {",
                        "  return node.type === \"comment\" && node.value.trim() === \"prettier-ignore\";",
                        "}",
                        "",
                        "/** there's no opening/closing tag or it's considered not breakable */",
                        "function isTextLikeNode(node) {",
                        "  return node.type === \"text\" || node.type === \"comment\";",
                        "}",
                        "",
                        "function isScriptLikeTag(node) {",
                        "  return (",
                        "    node.type === \"element\" &&",
                        "    (node.fullName === \"script\" ||",
                        "      node.fullName === \"style\" ||",
                        "      node.fullName === \"svg:style\" ||",
                        "      node.fullName === \"svg:script\" ||",
                        "      (isUnknownNamespace(node) &&",
                        "        (node.name === \"script\" || node.name === \"style\")))",
                        "  );",
                        "}",
                        "",
                        "function canHaveInterpolation(node) {",
                        "  return node.children && !isScriptLikeTag(node);",
                        "}",
                        "",
                        "function isWhitespaceSensitiveNode(node) {",
                        "  return (",
                        "    isScriptLikeTag(node) ||",
                        "    node.type === \"interpolation\" ||",
                        "    isIndentationSensitiveNode(node)",
                        "  );",
                        "}",
                        "",
                        "function isIndentationSensitiveNode(node) {",
                        "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                        "}",
                        "",
                        "function isLeadingSpaceSensitiveNode(node, options) {",
                        "  const isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();",
                        "",
                        "  if (",
                        "    isLeadingSpaceSensitive &&",
                        "    !node.prev &&",
                        "    node.parent?.tagDefinition?.ignoreFirstLf",
                        "  ) {",
                        "    return node.type === \"interpolation\";",
                        "  }",
                        "",
                        "  return isLeadingSpaceSensitive;",
                        "",
                        "  function _isLeadingSpaceSensitiveNode() {",
                        "    if (isFrontMatter(node)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (",
                        "      (node.type === \"text\" || node.type === \"interpolation\") &&",
                        "      node.prev &&",
                        "      (node.prev.type === \"text\" || node.prev.type === \"interpolation\")",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "",
                        "    if (!node.parent || node.parent.cssDisplay === \"none\") {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (isPreLikeNode(node.parent)) {",
                        "      return true;",
                        "    }",
                        "",
                        "    if (",
                        "      !node.prev &&",
                        "      (node.parent.type === \"root\" ||",
                        "        (isPreLikeNode(node) && node.parent) ||",
                        "        isScriptLikeTag(node.parent) ||",
                        "        isVueCustomBlock(node.parent, options) ||",
                        "        !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (",
                        "      node.prev &&",
                        "      !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return true;",
                        "  }",
                        "}",
                        "",
                        "function isTrailingSpaceSensitiveNode(node, options) {",
                        "  if (isFrontMatter(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    (node.type === \"text\" || node.type === \"interpolation\") &&",
                        "    node.next &&",
                        "    (node.next.type === \"text\" || node.next.type === \"interpolation\")",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!node.parent || node.parent.cssDisplay === \"none\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isPreLikeNode(node.parent)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    !node.next &&",
                        "    (node.parent.type === \"root\" ||",
                        "      (isPreLikeNode(node) && node.parent) ||",
                        "      isScriptLikeTag(node.parent) ||",
                        "      isVueCustomBlock(node.parent, options) ||",
                        "      !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    node.next &&",
                        "    !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "function isDanglingSpaceSensitiveNode(node) {",
                        "  return (",
                        "    isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) &&",
                        "    !isScriptLikeTag(node)",
                        "  );",
                        "}",
                        "",
                        "function forceNextEmptyLine(node) {",
                        "  return (",
                        "    isFrontMatter(node) ||",
                        "    (node.next &&",
                        "      node.sourceSpan.end &&",
                        "      node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line)",
                        "  );",
                        "}",
                        "",
                        "/** firstChild leadingSpaces and lastChild trailingSpaces */",
                        "function forceBreakContent(node) {",
                        "  return (",
                        "    forceBreakChildren(node) ||",
                        "    (node.type === \"element\" &&",
                        "      node.children.length > 0 &&",
                        "      ([\"body\", \"script\", \"style\"].includes(node.name) ||",
                        "        node.children.some((child) => hasNonTextChild(child)))) ||",
                        "    (node.firstChild &&",
                        "      node.firstChild === node.lastChild &&",
                        "      node.firstChild.type !== \"text\" &&",
                        "      hasLeadingLineBreak(node.firstChild) &&",
                        "      (!node.lastChild.isTrailingSpaceSensitive ||",
                        "        hasTrailingLineBreak(node.lastChild)))",
                        "  );",
                        "}",
                        "",
                        "/** spaces between children */",
                        "function forceBreakChildren(node) {",
                        "  return (",
                        "    node.type === \"element\" &&",
                        "    node.children.length > 0 &&",
                        "    ([\"html\", \"head\", \"ul\", \"ol\", \"select\"].includes(node.name) ||",
                        "      (node.cssDisplay.startsWith(\"table\") && node.cssDisplay !== \"table-cell\"))",
                        "  );",
                        "}",
                        "",
                        "function preferHardlineAsLeadingSpaces(node) {",
                        "  return (",
                        "    preferHardlineAsSurroundingSpaces(node) ||",
                        "    (node.prev && preferHardlineAsTrailingSpaces(node.prev)) ||",
                        "    hasSurroundingLineBreak(node)",
                        "  );",
                        "}",
                        "",
                        "function preferHardlineAsTrailingSpaces(node) {",
                        "  return (",
                        "    preferHardlineAsSurroundingSpaces(node) ||",
                        "    (node.type === \"element\" && node.fullName === \"br\") ||",
                        "    hasSurroundingLineBreak(node)",
                        "  );",
                        "}",
                        "",
                        "function hasSurroundingLineBreak(node) {",
                        "  return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);",
                        "}",
                        "",
                        "function hasLeadingLineBreak(node) {",
                        "  return (",
                        "    node.hasLeadingSpaces &&",
                        "    (node.prev",
                        "      ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line",
                        "      : node.parent.type === \"root\" ||",
                        "        node.parent.startSourceSpan.end.line < node.sourceSpan.start.line)",
                        "  );",
                        "}",
                        "",
                        "function hasTrailingLineBreak(node) {",
                        "  return (",
                        "    node.hasTrailingSpaces &&",
                        "    (node.next",
                        "      ? node.next.sourceSpan.start.line > node.sourceSpan.end.line",
                        "      : node.parent.type === \"root\" ||",
                        "        (node.parent.endSourceSpan &&",
                        "          node.parent.endSourceSpan.start.line > node.sourceSpan.end.line))",
                        "  );",
                        "}",
                        "",
                        "function preferHardlineAsSurroundingSpaces(node) {",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"comment\":",
                        "    case \"directive\":",
                        "      return true;",
                        "    case \"element\":",
                        "      return [\"script\", \"select\"].includes(node.name);",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function getLastDescendant(node) {",
                        "  return node.lastChild ? getLastDescendant(node.lastChild) : node;",
                        "}",
                        "",
                        "function hasNonTextChild(node) {",
                        "  return node.children?.some((child) => child.type !== \"text\");",
                        "}",
                        "",
                        "function inferParserByTypeAttribute(type) {",
                        "  if (!type) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (type) {",
                        "    case \"module\":",
                        "    case \"text/javascript\":",
                        "    case \"text/babel\":",
                        "    case \"application/javascript\":",
                        "      return \"babel\";",
                        "",
                        "    case \"application/x-typescript\":",
                        "      return \"typescript\";",
                        "",
                        "    case \"text/markdown\":",
                        "      return \"markdown\";",
                        "",
                        "    case \"text/html\":",
                        "      return \"html\";",
                        "",
                        "    case \"text/x-handlebars-template\":",
                        "      return \"glimmer\";",
                        "",
                        "    default:",
                        "      if (",
                        "        type.endsWith(\"json\") ||",
                        "        type.endsWith(\"importmap\") ||",
                        "        type === \"speculationrules\"",
                        "      ) {",
                        "        return \"json\";",
                        "      }",
                        "  }",
                        "}",
                        "",
                        "function inferScriptParser(node, options) {",
                        "  const { name, attrMap } = node;",
                        "",
                        "  if (name !== \"script\" || Object.hasOwn(attrMap, \"src\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  const { type, lang } = node.attrMap;",
                        "",
                        "  if (!lang && !type) {",
                        "    return \"babel\";",
                        "  }",
                        "",
                        "  return (",
                        "    inferParser(options, { language: lang }) ?? inferParserByTypeAttribute(type)",
                        "  );",
                        "}",
                        "",
                        "function inferVueSfcBlockParser(node, options) {",
                        "  if (!isVueNonHtmlBlock(node, options)) {",
                        "    return;",
                        "  }",
                        "  const { attrMap } = node;",
                        "",
                        "  if (Object.hasOwn(attrMap, \"src\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  const { type, lang } = attrMap;",
                        "",
                        "  return (",
                        "    inferParser(options, { language: lang }) ?? inferParserByTypeAttribute(type)",
                        "  );",
                        "}",
                        "",
                        "function inferStyleParser(node, options) {",
                        "  if (node.name !== \"style\") {",
                        "    return;",
                        "  }",
                        "  const { lang } = node.attrMap;",
                        "  return lang ? inferParser(options, { language: lang }) : \"css\";",
                        "}",
                        "",
                        "function inferElementParser(node, options) {",
                        "  return (",
                        "    inferScriptParser(node, options) ??",
                        "    inferStyleParser(node, options) ??",
                        "    inferVueSfcBlockParser(node, options)",
                        "  );",
                        "}",
                        "",
                        "function isBlockLikeCssDisplay(cssDisplay) {",
                        "  return (",
                        "    cssDisplay === \"block\" ||",
                        "    cssDisplay === \"list-item\" ||",
                        "    cssDisplay.startsWith(\"table\")",
                        "  );",
                        "}",
                        "",
                        "function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                        "}",
                        "",
                        "function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                        "}",
                        "",
                        "function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay);",
                        "}",
                        "",
                        "function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay);",
                        "}",
                        "",
                        "function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                        "}",
                        "",
                        "function isPreLikeNode(node) {",
                        "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                        "}",
                        "",
                        "function hasParent(node, fn) {",
                        "  let current = node;",
                        "",
                        "  while (current) {",
                        "    if (fn(current)) {",
                        "      return true;",
                        "    }",
                        "",
                        "    current = current.parent;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function getNodeCssStyleDisplay(node, options) {",
                        "  // Every root block in Vue SFC is a block",
                        "  if (isVueSfcBlock(node, options)) {",
                        "    return \"block\";",
                        "  }",
                        "",
                        "  if (node.prev?.type === \"comment\") {",
                        "    // <!-- display: block -->",
                        "    const match = node.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);",
                        "    if (match) {",
                        "      return match[1];",
                        "    }",
                        "  }",
                        "",
                        "  let isInSvgForeignObject = false;",
                        "  if (node.type === \"element\" && node.namespace === \"svg\") {",
                        "    if (hasParent(node, (parent) => parent.fullName === \"svg:foreignObject\")) {",
                        "      isInSvgForeignObject = true;",
                        "    } else {",
                        "      return node.name === \"svg\" ? \"inline-block\" : \"block\";",
                        "    }",
                        "  }",
                        "",
                        "  switch (options.htmlWhitespaceSensitivity) {",
                        "    case \"strict\":",
                        "      return \"inline\";",
                        "    case \"ignore\":",
                        "      return \"block\";",
                        "    default:",
                        "      return (",
                        "        (node.type === \"element\" &&",
                        "          (!node.namespace ||",
                        "            isInSvgForeignObject ||",
                        "            isUnknownNamespace(node)) &&",
                        "          CSS_DISPLAY_TAGS[node.name]) ||",
                        "        CSS_DISPLAY_DEFAULT",
                        "      );",
                        "  }",
                        "}",
                        "",
                        "function getNodeCssStyleWhiteSpace(node) {",
                        "  return (",
                        "    (node.type === \"element\" &&",
                        "      (!node.namespace || isUnknownNamespace(node)) &&",
                        "      CSS_WHITE_SPACE_TAGS[node.name]) ||",
                        "    CSS_WHITE_SPACE_DEFAULT",
                        "  );",
                        "}",
                        "",
                        "function getMinIndentation(text) {",
                        "  let minIndentation = Number.POSITIVE_INFINITY;",
                        "",
                        "  for (const lineText of text.split(\"\\n\")) {",
                        "    if (lineText.length === 0) {",
                        "      continue;",
                        "    }",
                        "",
                        "    const indentation = htmlWhitespaceUtils.getLeadingWhitespaceCount(lineText);",
                        "    if (indentation === 0) {",
                        "      return 0;",
                        "    }",
                        "",
                        "    if (lineText.length === indentation) {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (indentation < minIndentation) {",
                        "      minIndentation = indentation;",
                        "    }",
                        "  }",
                        "",
                        "  return minIndentation === Number.POSITIVE_INFINITY ? 0 : minIndentation;",
                        "}",
                        "",
                        "function dedentString(text, minIndent = getMinIndentation(text)) {",
                        "  return minIndent === 0",
                        "    ? text",
                        "    : text",
                        "        .split(\"\\n\")",
                        "        .map((lineText) => lineText.slice(minIndent))",
                        "        .join(\"\\n\");",
                        "}",
                        "",
                        "function unescapeQuoteEntities(text) {",
                        "  return text.replaceAll(\"&apos;\", \"'\").replaceAll(\"&quot;\", '\"');",
                        "}",
                        "",
                        "function getUnescapedAttributeValue(node) {",
                        "  return unescapeQuoteEntities(node.value);",
                        "}",
                        "",
                        "// top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block",
                        "// See https://vue-loader.vuejs.org/spec.html for detail",
                        "const vueRootElementsSet = new Set([\"template\", \"style\", \"script\"]);",
                        "function isVueCustomBlock(node, options) {",
                        "  return isVueSfcBlock(node, options) && !vueRootElementsSet.has(node.fullName);",
                        "}",
                        "",
                        "function isVueSfcBlock(node, options) {",
                        "  return (",
                        "    options.parser === \"vue\" &&",
                        "    node.type === \"element\" &&",
                        "    node.parent.type === \"root\" &&",
                        "    node.fullName.toLowerCase() !== \"html\"",
                        "  );",
                        "}",
                        "",
                        "function isVueNonHtmlBlock(node, options) {",
                        "  return (",
                        "    isVueSfcBlock(node, options) &&",
                        "    (isVueCustomBlock(node, options) ||",
                        "      (node.attrMap.lang && node.attrMap.lang !== \"html\"))",
                        "  );",
                        "}",
                        "",
                        "function isVueSlotAttribute(attribute) {",
                        "  const attributeName = attribute.fullName;",
                        "  return (",
                        "    attributeName.charAt(0) === \"#\" ||",
                        "    attributeName === \"slot-scope\" ||",
                        "    attributeName === \"v-slot\" ||",
                        "    attributeName.startsWith(\"v-slot:\")",
                        "  );",
                        "}",
                        "",
                        "function isVueSfcBindingsAttribute(attribute, options) {",
                        "  const element = attribute.parent;",
                        "  if (!isVueSfcBlock(element, options)) {",
                        "    return false;",
                        "  }",
                        "  const tagName = element.fullName;",
                        "  const attributeName = attribute.fullName;",
                        "",
                        "  return (",
                        "    // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-script-setup.md",
                        "    (tagName === \"script\" && attributeName === \"setup\") ||",
                        "    // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-style-variables.md",
                        "    (tagName === \"style\" && attributeName === \"vars\")",
                        "  );",
                        "}",
                        "",
                        "function getTextValueParts(node, value = node.value) {",
                        "  return node.parent.isWhitespaceSensitive",
                        "    ? node.parent.isIndentationSensitive",
                        "      ? replaceEndOfLine(value)",
                        "      : replaceEndOfLine(",
                        "          dedentString(htmlTrimPreserveIndentation(value)),",
                        "          hardline",
                        "        )",
                        "    : join(line, htmlWhitespaceUtils.split(value));",
                        "}",
                        "",
                        "function isVueScriptTag(node, options) {",
                        "  return isVueSfcBlock(node, options) && node.name === \"script\";",
                        "}",
                        "",
                        "export {",
                        "  htmlTrimPreserveIndentation,",
                        "  getLeadingAndTrailingHtmlWhitespace,",
                        "  canHaveInterpolation,",
                        "  dedentString,",
                        "  forceBreakChildren,",
                        "  forceBreakContent,",
                        "  forceNextEmptyLine,",
                        "  getLastDescendant,",
                        "  getNodeCssStyleDisplay,",
                        "  getNodeCssStyleWhiteSpace,",
                        "  hasPrettierIgnore,",
                        "  inferElementParser,",
                        "  isVueCustomBlock,",
                        "  isVueNonHtmlBlock,",
                        "  isVueScriptTag,",
                        "  isVueSlotAttribute,",
                        "  isVueSfcBindingsAttribute,",
                        "  isVueSfcBlock,",
                        "  isDanglingSpaceSensitiveNode,",
                        "  isIndentationSensitiveNode,",
                        "  isLeadingSpaceSensitiveNode,",
                        "  isPreLikeNode,",
                        "  isScriptLikeTag,",
                        "  isTextLikeNode,",
                        "  isTrailingSpaceSensitiveNode,",
                        "  isWhitespaceSensitiveNode,",
                        "  isUnknownNamespace,",
                        "  preferHardlineAsLeadingSpaces,",
                        "  preferHardlineAsTrailingSpaces,",
                        "  shouldPreserveContent,",
                        "  unescapeQuoteEntities,",
                        "  getTextValueParts,",
                        "  htmlWhitespaceUtils,",
                        "  getUnescapedAttributeValue,",
                        "};"
                    ]
                },
                "is-unknown-namespace.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isUnknownNamespace(node) {",
                        "  return (",
                        "    node.type === \"element\" &&",
                        "    !node.hasExplicitNamespace &&",
                        "    ![\"html\", \"svg\"].includes(node.namespace)",
                        "  );",
                        "}",
                        "",
                        "export default isUnknownNamespace;"
                    ]
                },
                "is-vue-sfc-with-typescript-script.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { isVueScriptTag } from \"./index.js\";",
                        "",
                        "const cache = new WeakMap();",
                        "function isVueSfcWithTypescriptScript(path, options) {",
                        "  const { root } = path;",
                        "  if (!cache.has(root)) {",
                        "    cache.set(",
                        "      root,",
                        "      root.children.some(",
                        "        (child) =>",
                        "          isVueScriptTag(child, options) &&",
                        "          [\"ts\", \"typescript\"].includes(child.attrMap.lang)",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  return cache.get(root);",
                        "}",
                        "",
                        "export default isVueSfcWithTypescriptScript;"
                    ]
                }
            }
        },
        "language-js": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isBlockComment from \"./utils/is-block-comment.js\";",
                    "import { isArrayOrTupleExpression } from \"./utils/index.js\";",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"range\",",
                    "  \"raw\",",
                    "  \"comments\",",
                    "  \"leadingComments\",",
                    "  \"trailingComments\",",
                    "  \"innerComments\",",
                    "  \"extra\",",
                    "  \"start\",",
                    "  \"end\",",
                    "  \"loc\",",
                    "  \"flags\",",
                    "  \"errors\",",
                    "  \"tokens\",",
                    "]);",
                    "",
                    "const removeTemplateElementsValue = (node) => {",
                    "  for (const templateElement of node.quasis) {",
                    "    delete templateElement.value;",
                    "  }",
                    "};",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  if (ast.type === \"Program\") {",
                    "    delete newObj.sourceType;",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"BigIntLiteral\" ||",
                    "      ast.type === \"BigIntLiteralTypeAnnotation\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = newObj.value.toLowerCase();",
                    "  }",
                    "  if (",
                    "    (ast.type === \"BigIntLiteral\" || ast.type === \"Literal\") &&",
                    "    newObj.bigint",
                    "  ) {",
                    "    newObj.bigint = newObj.bigint.toLowerCase();",
                    "  }",
                    "",
                    "  if (ast.type === \"DecimalLiteral\") {",
                    "    newObj.value = Number(newObj.value);",
                    "  }",
                    "  if (ast.type === \"Literal\" && newObj.decimal) {",
                    "    newObj.decimal = Number(newObj.decimal);",
                    "  }",
                    "",
                    "  // We remove extra `;` and add them when needed",
                    "  if (ast.type === \"EmptyStatement\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We move text around, including whitespaces and add {\" \"}",
                    "  if (ast.type === \"JSXText\") {",
                    "    return null;",
                    "  }",
                    "  if (",
                    "    ast.type === \"JSXExpressionContainer\" &&",
                    "    (ast.expression.type === \"Literal\" ||",
                    "      ast.expression.type === \"StringLiteral\") &&",
                    "    ast.expression.value === \" \"",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We change {'key': value} into {key: value}.",
                    "  // And {key: value} into {'key': value}.",
                    "  // Also for (some) number keys.",
                    "  if (",
                    "    (ast.type === \"Property\" ||",
                    "      ast.type === \"ObjectProperty\" ||",
                    "      ast.type === \"MethodDefinition\" ||",
                    "      ast.type === \"ClassProperty\" ||",
                    "      ast.type === \"ClassMethod\" ||",
                    "      ast.type === \"PropertyDefinition\" ||",
                    "      ast.type === \"TSDeclareMethod\" ||",
                    "      ast.type === \"TSPropertySignature\" ||",
                    "      ast.type === \"ObjectTypeProperty\") &&",
                    "    typeof ast.key === \"object\" &&",
                    "    ast.key &&",
                    "    (ast.key.type === \"Literal\" ||",
                    "      ast.key.type === \"NumericLiteral\" ||",
                    "      ast.key.type === \"StringLiteral\" ||",
                    "      ast.key.type === \"Identifier\")",
                    "  ) {",
                    "    delete newObj.key;",
                    "  }",
                    "",
                    "  // Remove raw and cooked values from TemplateElement when it's CSS",
                    "  // styled-jsx",
                    "  if (",
                    "    ast.type === \"JSXElement\" &&",
                    "    ast.openingElement.name.name === \"style\" &&",
                    "    ast.openingElement.attributes.some((attr) => attr.name.name === \"jsx\")",
                    "  ) {",
                    "    for (const { type, expression } of newObj.children) {",
                    "      if (",
                    "        type === \"JSXExpressionContainer\" &&",
                    "        expression.type === \"TemplateLiteral\"",
                    "      ) {",
                    "        removeTemplateElementsValue(expression);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  // CSS template literals in css prop",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.name.name === \"css\" &&",
                    "    ast.value.type === \"JSXExpressionContainer\" &&",
                    "    ast.value.expression.type === \"TemplateLiteral\"",
                    "  ) {",
                    "    removeTemplateElementsValue(newObj.value.expression);",
                    "  }",
                    "",
                    "  // We change quotes",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.value?.type === \"Literal\" &&",
                    "    /[\"']|&quot;|&apos;/.test(ast.value.value)",
                    "  ) {",
                    "    newObj.value.value = newObj.value.value.replaceAll(",
                    "      /[\"']|&quot;|&apos;/g,",
                    "      '\"'",
                    "    );",
                    "  }",
                    "",
                    "  // Angular Components: Inline HTML template and Inline CSS styles",
                    "  const expression = ast.expression || ast.callee;",
                    "  if (",
                    "    ast.type === \"Decorator\" &&",
                    "    expression.type === \"CallExpression\" &&",
                    "    expression.callee.name === \"Component\" &&",
                    "    expression.arguments.length === 1",
                    "  ) {",
                    "    const astProps = ast.expression.arguments[0].properties;",
                    "    for (const [",
                    "      index,",
                    "      prop,",
                    "    ] of newObj.expression.arguments[0].properties.entries()) {",
                    "      switch (astProps[index].key.name) {",
                    "        case \"styles\":",
                    "          if (isArrayOrTupleExpression(prop.value)) {",
                    "            removeTemplateElementsValue(prop.value.elements[0]);",
                    "          }",
                    "          break;",
                    "        case \"template\":",
                    "          if (prop.value.type === \"TemplateLiteral\") {",
                    "            removeTemplateElementsValue(prop.value);",
                    "          }",
                    "          break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  // styled-components, graphql, markdown",
                    "  if (",
                    "    ast.type === \"TaggedTemplateExpression\" &&",
                    "    (ast.tag.type === \"MemberExpression\" ||",
                    "      (ast.tag.type === \"Identifier\" &&",
                    "        (ast.tag.name === \"gql\" ||",
                    "          ast.tag.name === \"graphql\" ||",
                    "          ast.tag.name === \"css\" ||",
                    "          ast.tag.name === \"md\" ||",
                    "          ast.tag.name === \"markdown\" ||",
                    "          ast.tag.name === \"html\")) ||",
                    "      ast.tag.type === \"CallExpression\")",
                    "  ) {",
                    "    removeTemplateElementsValue(newObj.quasi);",
                    "  }",
                    "  if (ast.type === \"TemplateLiteral\") {",
                    "    // This checks for a leading comment that is exactly `/* GraphQL */`",
                    "    // In order to be in line with other implementations of this comment tag",
                    "    // we will not trim the comment value and we will expect exactly one space on",
                    "    // either side of the GraphQL string",
                    "    // Also see ./embed.js",
                    "    const hasLanguageComment = ast.leadingComments?.some(",
                    "      (comment) =>",
                    "        isBlockComment(comment) &&",
                    "        [\"GraphQL\", \"HTML\"].some(",
                    "          (languageName) => comment.value === ` ${languageName} `",
                    "        )",
                    "    );",
                    "    if (",
                    "      hasLanguageComment ||",
                    "      (parent.type === \"CallExpression\" && parent.callee.name === \"graphql\") ||",
                    "      // TODO: check parser",
                    "      // `flow` and `typescript` don't have `leadingComments`",
                    "      !ast.leadingComments",
                    "    ) {",
                    "      removeTemplateElementsValue(newObj);",
                    "    }",
                    "  }",
                    "",
                    "  // Prettier removes degenerate union and intersection types with only one member.",
                    "  if (",
                    "    (ast.type === \"TSIntersectionType\" || ast.type === \"TSUnionType\") &&",
                    "    ast.types.length === 1",
                    "  ) {",
                    "    return newObj.types[0];",
                    "  }",
                    "",
                    "  // We print `(a?.b!).c` as `(a?.b)!.c`, but `typescript` parse them differently",
                    "  if (",
                    "    ast.type === \"ChainExpression\" &&",
                    "    ast.expression.type === \"TSNonNullExpression\"",
                    "  ) {",
                    "    // Ideally, we should swap these two nodes, but `type` is the only difference",
                    "    [newObj.type, newObj.expression.type] = [",
                    "      newObj.expression.type,",
                    "      newObj.type,",
                    "    ];",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "export default clean;"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.JavaScript, (data) => ({",
                    "    parsers: [",
                    "      \"babel\",",
                    "      \"acorn\",",
                    "      \"espree\",",
                    "      \"meriyah\",",
                    "      \"babel-flow\",",
                    "      \"babel-ts\",",
                    "      \"flow\",",
                    "      \"typescript\",",
                    "    ],",
                    "    vscodeLanguageIds: [\"javascript\", \"mongo\"],",
                    "    interpreters: [",
                    "      ...data.interpreters,",
                    "      // https://github.com/google/zx",
                    "      \"zx\",",
                    "    ],",
                    "    extensions: [",
                    "      ...data.extensions.filter((extension) => extension !== \".jsx\"),",
                    "      // WeiXin Script (Weixin Mini Programs)",
                    "      // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                    "      \".wxs\",",
                    "    ],",
                    "  })),",
                    "  createLanguage(linguistLanguages.JavaScript, () => ({",
                    "    name: \"Flow\",",
                    "    parsers: [\"flow\", \"babel-flow\"],",
                    "    vscodeLanguageIds: [\"javascript\"],",
                    "    aliases: [],",
                    "    filenames: [],",
                    "    extensions: [\".js.flow\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.JavaScript, () => ({",
                    "    name: \"JSX\",",
                    "    parsers: [",
                    "      \"babel\",",
                    "      \"babel-flow\",",
                    "      \"babel-ts\",",
                    "      \"flow\",",
                    "      \"typescript\",",
                    "      \"espree\",",
                    "      \"meriyah\",",
                    "    ],",
                    "    vscodeLanguageIds: [\"javascriptreact\"],",
                    "    aliases: undefined,",
                    "    filenames: undefined,",
                    "    extensions: [\".jsx\"],",
                    "    group: \"JavaScript\",",
                    "    interpreters: undefined,",
                    "    tmScope: \"source.js.jsx\",",
                    "    aceMode: \"javascript\",",
                    "    codemirrorMode: \"jsx\",",
                    "    codemirrorMimeType: \"text/jsx\",",
                    "    color: undefined,",
                    "  })),",
                    "  createLanguage(linguistLanguages.TypeScript, () => ({",
                    "    parsers: [\"typescript\", \"babel-ts\"],",
                    "    vscodeLanguageIds: [\"typescript\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.TSX, () => ({",
                    "    parsers: [\"typescript\", \"babel-ts\"],",
                    "    vscodeLanguageIds: [\"typescriptreact\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./types/estree.js\").Node} Node",
                    " */",
                    "",
                    "function locStart(node) {",
                    "  const start = node.range ? node.range[0] : node.start;",
                    "",
                    "  // Handle nodes with decorators. They should start at the first decorator",
                    "  const decorators = node.declaration?.decorators ?? node.decorators;",
                    "  if (isNonEmptyArray(decorators)) {",
                    "    return Math.min(locStart(decorators[0]), start);",
                    "  }",
                    "",
                    "  return start;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.range ? node.range[1] : node.end;",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLocStart(nodeA, nodeB) {",
                    "  const nodeAStart = locStart(nodeA);",
                    "  return Number.isInteger(nodeAStart) && nodeAStart === locStart(nodeB);",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLocEnd(nodeA, nodeB) {",
                    "  const nodeAEnd = locEnd(nodeA);",
                    "  return Number.isInteger(nodeAEnd) && nodeAEnd === locEnd(nodeB);",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLoc(nodeA, nodeB) {",
                    "  return hasSameLocStart(nodeA, nodeB) && hasSameLocEnd(nodeA, nodeB);",
                    "}",
                    "",
                    "export { locStart, locEnd, hasSameLocStart, hasSameLoc };"
                ]
            },
            "needs-parens.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import {",
                    "  getFunctionParameters,",
                    "  getLeftSidePathName,",
                    "  hasNakedLeftSide,",
                    "  hasNode,",
                    "  isBitwiseOperator,",
                    "  startsWithNoLookaheadToken,",
                    "  shouldFlatten,",
                    "  getPrecedence,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  isObjectProperty,",
                    "  isTSTypeExpression,",
                    "  isArrayOrTupleExpression,",
                    "  isObjectOrRecordExpression,",
                    "  createTypeCheckFunction,",
                    "} from \"./utils/index.js\";",
                    "",
                    "function needsParens(path, options) {",
                    "  if (path.isRoot) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const { node, key, parent } = path;",
                    "",
                    "  // to avoid unexpected `}}` in HTML interpolations",
                    "  if (",
                    "    options.__isInHtmlInterpolation &&",
                    "    !options.bracketSpacing &&",
                    "    endsWithRightBracket(node) &&",
                    "    isFollowedByRightBracket(path)",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Only statements don't need parentheses.",
                    "  if (isStatement(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Identifiers never need parentheses.",
                    "  if (node.type === \"Identifier\") {",
                    "    // ...unless those identifiers are embed placeholders. They might be substituted by complex",
                    "    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):",
                    "    //     let tpl = html`<script> f((${expr}) / 2); </script>`;",
                    "    // If the inner JS formatter removes the parens, the expression might change its meaning:",
                    "    //     f((a + b) / 2)  vs  f(a + b / 2)",
                    "    if (",
                    "      node.extra?.parenthesized &&",
                    "      /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    // `for ((async) of []);` and `for ((let) of []);`",
                    "    if (",
                    "      key === \"left\" &&",
                    "      ((node.name === \"async\" && !parent.await) || node.name === \"let\") &&",
                    "      parent.type === \"ForOfStatement\"",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    // `for ((let.a) of []);`",
                    "    if (node.name === \"let\") {",
                    "      const expression = path.findAncestor(",
                    "        (node) => node.type === \"ForOfStatement\"",
                    "      )?.left;",
                    "      if (",
                    "        expression &&",
                    "        startsWithNoLookaheadToken(",
                    "          expression,",
                    "          (leftmostNode) => leftmostNode === node",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "",
                    "    // `(let)[a] = 1`",
                    "    if (",
                    "      key === \"object\" &&",
                    "      node.name === \"let\" &&",
                    "      parent.type === \"MemberExpression\" &&",
                    "      parent.computed &&",
                    "      !parent.optional",
                    "    ) {",
                    "      const statement = path.findAncestor(",
                    "        (node) =>",
                    "          node.type === \"ExpressionStatement\" ||",
                    "          node.type === \"ForStatement\" ||",
                    "          node.type === \"ForInStatement\"",
                    "      );",
                    "      const expression = !statement",
                    "        ? undefined",
                    "        : statement.type === \"ExpressionStatement\"",
                    "        ? statement.expression",
                    "        : statement.type === \"ForStatement\"",
                    "        ? statement.init",
                    "        : statement.left;",
                    "      if (",
                    "        expression &&",
                    "        startsWithNoLookaheadToken(",
                    "          expression,",
                    "          (leftmostNode) => leftmostNode === node",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"ObjectExpression\" ||",
                    "    node.type === \"FunctionExpression\" ||",
                    "    node.type === \"ClassExpression\" ||",
                    "    node.type === \"DoExpression\"",
                    "  ) {",
                    "    const expression = path.findAncestor(",
                    "      (node) => node.type === \"ExpressionStatement\"",
                    "    )?.expression;",
                    "    if (",
                    "      expression &&",
                    "      startsWithNoLookaheadToken(",
                    "        expression,",
                    "        (leftmostNode) => leftmostNode === node",
                    "      )",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  if (node.type === \"ObjectExpression\") {",
                    "    const arrowFunctionBody = path.findAncestor(",
                    "      (node) => node.type === \"ArrowFunctionExpression\"",
                    "    )?.body;",
                    "    if (",
                    "      arrowFunctionBody &&",
                    "      arrowFunctionBody.type !== \"SequenceExpression\" && // these have parens added anyway",
                    "      arrowFunctionBody.type !== \"AssignmentExpression\" &&",
                    "      startsWithNoLookaheadToken(",
                    "        arrowFunctionBody,",
                    "        (leftmostNode) => leftmostNode === node",
                    "      )",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  switch (parent.type) {",
                    "    case \"ParenthesizedExpression\":",
                    "      return false;",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\":",
                    "      // Add parens around the extends clause of a class. It is needed for almost",
                    "      // all expressions.",
                    "      if (",
                    "        key === \"superClass\" &&",
                    "        (node.type === \"ArrowFunctionExpression\" ||",
                    "          node.type === \"AssignmentExpression\" ||",
                    "          node.type === \"AwaitExpression\" ||",
                    "          node.type === \"BinaryExpression\" ||",
                    "          node.type === \"ConditionalExpression\" ||",
                    "          node.type === \"LogicalExpression\" ||",
                    "          node.type === \"NewExpression\" ||",
                    "          node.type === \"ObjectExpression\" ||",
                    "          node.type === \"SequenceExpression\" ||",
                    "          node.type === \"TaggedTemplateExpression\" ||",
                    "          node.type === \"UnaryExpression\" ||",
                    "          node.type === \"UpdateExpression\" ||",
                    "          node.type === \"YieldExpression\" ||",
                    "          node.type === \"TSNonNullExpression\" ||",
                    "          (node.type === \"ClassExpression\" && isNonEmptyArray(node.decorators)))",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      break;",
                    "",
                    "    case \"ExportDefaultDeclaration\":",
                    "      return (",
                    "        // `export default function` or `export default class` can't be followed by",
                    "        // anything after. So an expression like `export default (function(){}).toString()`",
                    "        // needs to be followed by a parentheses",
                    "        shouldWrapFunctionForExportDefault(path, options) ||",
                    "        // `export default (foo, bar)` also needs parentheses",
                    "        node.type === \"SequenceExpression\"",
                    "      );",
                    "",
                    "    case \"Decorator\":",
                    "      if (key === \"expression\") {",
                    "        if (isMemberExpression(node) && node.computed) {",
                    "          return true;",
                    "        }",
                    "",
                    "        let hasCallExpression = false;",
                    "        let hasMemberExpression = false;",
                    "        let current = node;",
                    "        while (current) {",
                    "          switch (current.type) {",
                    "            case \"MemberExpression\":",
                    "              hasMemberExpression = true;",
                    "              current = current.object;",
                    "              break;",
                    "            case \"CallExpression\":",
                    "              if (",
                    "                /** @(x().y) */ hasMemberExpression ||",
                    "                /** @(x().y()) */ hasCallExpression",
                    "              ) {",
                    "                return options.parser !== \"typescript\";",
                    "              }",
                    "              hasCallExpression = true;",
                    "              current = current.callee;",
                    "              break;",
                    "            case \"Identifier\":",
                    "              return false;",
                    "            case \"TaggedTemplateExpression\":",
                    "              // babel-parser cannot parse",
                    "              //   @foo`bar`",
                    "              return options.parser !== \"typescript\";",
                    "            default:",
                    "              return true;",
                    "          }",
                    "        }",
                    "        return true;",
                    "      }",
                    "      break;",
                    "",
                    "    case \"TypeAnnotation\":",
                    "      if (",
                    "        path.match(",
                    "          undefined,",
                    "          undefined,",
                    "          (node, key) =>",
                    "            key === \"returnType\" && node.type === \"ArrowFunctionExpression\"",
                    "        ) &&",
                    "        includesFunctionTypeInObjectType(node)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      break;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"UpdateExpression\":",
                    "      if (parent.type === \"UnaryExpression\") {",
                    "        return (",
                    "          node.prefix &&",
                    "          ((node.operator === \"++\" && parent.operator === \"+\") ||",
                    "            (node.operator === \"--\" && parent.operator === \"-\"))",
                    "        );",
                    "      }",
                    "    // else fallthrough",
                    "    case \"UnaryExpression\":",
                    "      switch (parent.type) {",
                    "        case \"UnaryExpression\":",
                    "          return (",
                    "            node.operator === parent.operator &&",
                    "            (node.operator === \"+\" || node.operator === \"-\")",
                    "          );",
                    "",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"BinaryExpression\":",
                    "          return key === \"left\" && parent.operator === \"**\";",
                    "",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"BinaryExpression\":",
                    "      if (parent.type === \"UpdateExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      // We add parentheses to any `a in b` inside `ForStatement` initializer",
                    "      // https://github.com/prettier/prettier/issues/907#issuecomment-284304321",
                    "      if (node.operator === \"in\" && isPathInForStatementInitializer(path)) {",
                    "        return true;",
                    "      }",
                    "      if (node.operator === \"|>\" && node.extra?.parenthesized) {",
                    "        const grandParent = path.grandparent;",
                    "        if (",
                    "          grandParent.type === \"BinaryExpression\" &&",
                    "          grandParent.operator === \"|>\"",
                    "        ) {",
                    "          return true;",
                    "        }",
                    "      }",
                    "",
                    "    // fallthrough",
                    "    case \"TSTypeAssertion\":",
                    "    case \"TSAsExpression\":",
                    "    case \"TSSatisfiesExpression\":",
                    "    case \"LogicalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "          // examples:",
                    "          //   foo as unknown as Bar",
                    "          //   foo satisfies unknown satisfies Bar",
                    "          //   foo satisfies unknown as Bar",
                    "          //   foo as unknown satisfies Bar",
                    "          return !isTSTypeExpression(node);",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return isTSTypeExpression(node);",
                    "",
                    "        case \"CallExpression\":",
                    "        case \"NewExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"ClassExpression\":",
                    "        case \"ClassDeclaration\":",
                    "          return key === \"superClass\";",
                    "",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"SpreadElement\":",
                    "        case \"BindExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"UpdateExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        case \"AssignmentExpression\":",
                    "        case \"AssignmentPattern\":",
                    "          return (",
                    "            key === \"left\" &&",
                    "            (node.type === \"TSTypeAssertion\" || isTSTypeExpression(node))",
                    "          );",
                    "",
                    "        case \"LogicalExpression\":",
                    "          if (node.type === \"LogicalExpression\") {",
                    "            return parent.operator !== node.operator;",
                    "          }",
                    "        // else fallthrough",
                    "",
                    "        case \"BinaryExpression\": {",
                    "          const { operator, type } = node;",
                    "          if (!operator && type !== \"TSTypeAssertion\") {",
                    "            return true;",
                    "          }",
                    "",
                    "          const precedence = getPrecedence(operator);",
                    "          const parentOperator = parent.operator;",
                    "          const parentPrecedence = getPrecedence(parentOperator);",
                    "",
                    "          if (parentPrecedence > precedence) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (key === \"right\" && parentPrecedence === precedence) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (",
                    "            parentPrecedence === precedence &&",
                    "            !shouldFlatten(parentOperator, operator)",
                    "          ) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (parentPrecedence < precedence && operator === \"%\") {",
                    "            return parentOperator === \"+\" || parentOperator === \"-\";",
                    "          }",
                    "",
                    "          // Add parenthesis when working with bitwise operators",
                    "          // It's not strictly needed but helps with code understanding",
                    "          if (isBitwiseOperator(parentOperator)) {",
                    "            return true;",
                    "          }",
                    "",
                    "          return false;",
                    "        }",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"SequenceExpression\":",
                    "      switch (parent.type) {",
                    "        case \"ReturnStatement\":",
                    "          return false;",
                    "",
                    "        case \"ForStatement\":",
                    "          // Although parentheses wouldn't hurt around sequence",
                    "          // expressions in the head of for loops, traditional style",
                    "          // dictates that e.g. i++, j++ should not be wrapped with",
                    "          // parentheses.",
                    "          return false;",
                    "",
                    "        case \"ExpressionStatement\":",
                    "          return key !== \"expression\";",
                    "",
                    "        case \"ArrowFunctionExpression\":",
                    "          // We do need parentheses, but SequenceExpressions are handled",
                    "          // specially when printing bodies of arrow functions.",
                    "          return key !== \"body\";",
                    "",
                    "        default:",
                    "          // Otherwise err on the side of overparenthesization, adding",
                    "          // explicit exceptions above if this proves overzealous.",
                    "          return true;",
                    "      }",
                    "",
                    "    case \"YieldExpression\":",
                    "      if (parent.type === \"AwaitExpression\") {",
                    "        return true;",
                    "      }",
                    "    // else fallthrough",
                    "    case \"AwaitExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return key === \"test\";",
                    "",
                    "        case \"BinaryExpression\":",
                    "          if (!node.argument && parent.operator === \"|>\") {",
                    "            return false;",
                    "          }",
                    "",
                    "          return true;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"TSFunctionType\":",
                    "      if (",
                    "        path.match(",
                    "          (node) => node.type === \"TSFunctionType\",",
                    "          (node, key) =>",
                    "            key === \"typeAnnotation\" && node.type === \"TSTypeAnnotation\",",
                    "          (node, key) =>",
                    "            key === \"returnType\" && node.type === \"ArrowFunctionExpression\"",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSConditionalType\":",
                    "    case \"TSConstructorType\":",
                    "      if (key === \"extendsType\" && parent.type === \"TSConditionalType\") {",
                    "        if (node.type === \"TSConditionalType\") {",
                    "          return true;",
                    "        }",
                    "",
                    "        let { typeAnnotation } = node.returnType || node.typeAnnotation;",
                    "",
                    "        if (",
                    "          typeAnnotation.type === \"TSTypePredicate\" &&",
                    "          typeAnnotation.typeAnnotation",
                    "        ) {",
                    "          typeAnnotation = typeAnnotation.typeAnnotation.typeAnnotation;",
                    "        }",
                    "",
                    "        if (",
                    "          typeAnnotation.type === \"TSInferType\" &&",
                    "          typeAnnotation.typeParameter.constraint",
                    "        ) {",
                    "          return true;",
                    "        }",
                    "      }",
                    "",
                    "      if (key === \"checkType\" && parent.type === \"TSConditionalType\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSUnionType\":",
                    "    case \"TSIntersectionType\":",
                    "      if (",
                    "        (parent.type === \"TSUnionType\" ||",
                    "          parent.type === \"TSIntersectionType\") &&",
                    "        parent.types.length > 1 &&",
                    "        (!node.types || node.types.length > 1)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSInferType\":",
                    "      if (node.type === \"TSInferType\" && parent.type === \"TSRestType\") {",
                    "        return false;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSTypeOperator\":",
                    "      return (",
                    "        parent.type === \"TSArrayType\" ||",
                    "        parent.type === \"TSOptionalType\" ||",
                    "        parent.type === \"TSRestType\" ||",
                    "        (key === \"objectType\" && parent.type === \"TSIndexedAccessType\") ||",
                    "        parent.type === \"TSTypeOperator\" ||",
                    "        (parent.type === \"TSTypeAnnotation\" &&",
                    "          path.grandparent.type.startsWith(\"TSJSDoc\"))",
                    "      );",
                    "    case \"TSTypeQuery\":",
                    "      return (",
                    "        (key === \"objectType\" && parent.type === \"TSIndexedAccessType\") ||",
                    "        (key === \"elementType\" && parent.type === \"TSArrayType\")",
                    "      );",
                    "    // Same as `TSTypeQuery`, but for Flow syntax",
                    "    case \"TypeofTypeAnnotation\":",
                    "      return (",
                    "        (key === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\")) ||",
                    "        (key === \"elementType\" && parent.type === \"ArrayTypeAnnotation\")",
                    "      );",
                    "    case \"ArrayTypeAnnotation\":",
                    "      return parent.type === \"NullableTypeAnnotation\";",
                    "",
                    "    case \"IntersectionTypeAnnotation\":",
                    "    case \"UnionTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        parent.type === \"NullableTypeAnnotation\" ||",
                    "        parent.type === \"IntersectionTypeAnnotation\" ||",
                    "        parent.type === \"UnionTypeAnnotation\" ||",
                    "        (key === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\"))",
                    "      );",
                    "    case \"InferTypeAnnotation\":",
                    "    case \"NullableTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        (key === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\"))",
                    "      );",
                    "",
                    "    case \"FunctionTypeAnnotation\": {",
                    "      if (",
                    "        path.match(",
                    "          undefined,",
                    "          (node, key) =>",
                    "            key === \"typeAnnotation\" && node.type === \"TypeAnnotation\",",
                    "          (node, key) =>",
                    "            key === \"returnType\" && node.type === \"ArrowFunctionExpression\"",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "",
                    "      const ancestor =",
                    "        parent.type === \"NullableTypeAnnotation\" ? path.grandparent : parent;",
                    "",
                    "      return (",
                    "        ancestor.type === \"UnionTypeAnnotation\" ||",
                    "        ancestor.type === \"IntersectionTypeAnnotation\" ||",
                    "        ancestor.type === \"ArrayTypeAnnotation\" ||",
                    "        (key === \"objectType\" &&",
                    "          (ancestor.type === \"IndexedAccessType\" ||",
                    "            ancestor.type === \"OptionalIndexedAccessType\")) ||",
                    "        (key === \"checkType\" && parent.type === \"ConditionalTypeAnnotation\") ||",
                    "        (key === \"extendsType\" &&",
                    "          parent.type === \"ConditionalTypeAnnotation\" &&",
                    "          node.returnType.type === \"InferTypeAnnotation\" &&",
                    "          node.returnType.typeParameter.bound) ||",
                    "        // We should check ancestor's parent to know whether the parentheses",
                    "        // are really needed, but since ??T doesn't make sense this check",
                    "        // will almost never be true.",
                    "        ancestor.type === \"NullableTypeAnnotation\" ||",
                    "        // See #5283",
                    "        (parent.type === \"FunctionTypeParam\" &&",
                    "          parent.name === null &&",
                    "          getFunctionParameters(node).some(",
                    "            (param) => param.typeAnnotation?.type === \"NullableTypeAnnotation\"",
                    "          ))",
                    "      );",
                    "    }",
                    "",
                    "    case \"ConditionalTypeAnnotation\":",
                    "      if (",
                    "        key === \"extendsType\" &&",
                    "        parent.type === \"ConditionalTypeAnnotation\" &&",
                    "        node.type === \"ConditionalTypeAnnotation\"",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "",
                    "      if (key === \"checkType\" && parent.type === \"ConditionalTypeAnnotation\") {",
                    "        return true;",
                    "      }",
                    "",
                    "    // fallthrough",
                    "    case \"OptionalIndexedAccessType\":",
                    "      return key === \"objectType\" && parent.type === \"IndexedAccessType\";",
                    "",
                    "    case \"StringLiteral\":",
                    "    case \"NumericLiteral\":",
                    "    case \"Literal\":",
                    "      if (",
                    "        typeof node.value === \"string\" &&",
                    "        parent.type === \"ExpressionStatement\" &&",
                    "        !parent.directive",
                    "      ) {",
                    "        // To avoid becoming a directive",
                    "        const grandParent = path.grandparent;",
                    "",
                    "        return (",
                    "          grandParent.type === \"Program\" ||",
                    "          grandParent.type === \"BlockStatement\"",
                    "        );",
                    "      }",
                    "",
                    "      return (",
                    "        key === \"object\" &&",
                    "        parent.type === \"MemberExpression\" &&",
                    "        typeof node.value === \"number\"",
                    "      );",
                    "",
                    "    case \"AssignmentExpression\": {",
                    "      const grandParent = path.grandparent;",
                    "",
                    "      if (key === \"body\" && parent.type === \"ArrowFunctionExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      if (",
                    "        key === \"key\" &&",
                    "        (parent.type === \"ClassProperty\" ||",
                    "          parent.type === \"PropertyDefinition\") &&",
                    "        parent.computed",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        (key === \"init\" || key === \"update\") &&",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"ExpressionStatement\") {",
                    "        return node.left.type === \"ObjectPattern\";",
                    "      }",
                    "",
                    "      if (key === \"key\" && parent.type === \"TSPropertySignature\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"AssignmentExpression\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        parent.type === \"SequenceExpression\" &&",
                    "        grandParent.type === \"ForStatement\" &&",
                    "        (grandParent.init === parent || grandParent.update === parent)",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        key === \"value\" &&",
                    "        parent.type === \"Property\" &&",
                    "        grandParent.type === \"ObjectPattern\" &&",
                    "        grandParent.properties.includes(parent)",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"NGChainedExpression\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      return true;",
                    "    }",
                    "    case \"ConditionalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"BinaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"NGPipeExpression\":",
                    "        case \"ExportDefaultDeclaration\":",
                    "        case \"AwaitExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TypeCastExpression\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return key === \"test\";",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"FunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.",
                    "          // Is necessary if it is `expression` of `ExpressionStatement`.",
                    "          return key === \"callee\";",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true; // This is basically a kind of IIFE.",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ArrowFunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"BinaryExpression\":",
                    "          return parent.operator !== \"|>\" || node.extra?.parenthesized;",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"BindExpression\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSTypeAssertion\":",
                    "          return true;",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return key === \"test\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ClassExpression\":",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "          return key === \"callee\";",
                    "        default:",
                    "          return false;",
                    "      }",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"OptionalCallExpression\":",
                    "    case \"CallExpression\":",
                    "    case \"MemberExpression\":",
                    "      if (shouldAddParenthesesToChainElement(path)) {",
                    "        return true;",
                    "      }",
                    "",
                    "    // fallthrough",
                    "    case \"TaggedTemplateExpression\":",
                    "    case \"TSNonNullExpression\":",
                    "      if (",
                    "        key === \"callee\" &&",
                    "        (parent.type === \"BindExpression\" || parent.type === \"NewExpression\")",
                    "      ) {",
                    "        let object = node;",
                    "        while (object) {",
                    "          switch (object.type) {",
                    "            case \"CallExpression\":",
                    "            case \"OptionalCallExpression\":",
                    "              return true;",
                    "            case \"MemberExpression\":",
                    "            case \"OptionalMemberExpression\":",
                    "            case \"BindExpression\":",
                    "              object = object.object;",
                    "              break;",
                    "            // tagged templates are basically member expressions from a grammar perspective",
                    "            // see https://tc39.github.io/ecma262/#prod-MemberExpression",
                    "            case \"TaggedTemplateExpression\":",
                    "              object = object.tag;",
                    "              break;",
                    "            case \"TSNonNullExpression\":",
                    "              object = object.expression;",
                    "              break;",
                    "            default:",
                    "              return false;",
                    "          }",
                    "        }",
                    "      }",
                    "      return false;",
                    "",
                    "    case \"BindExpression\":",
                    "      return (",
                    "        (key === \"callee\" &&",
                    "          (parent.type === \"BindExpression\" ||",
                    "            parent.type === \"NewExpression\")) ||",
                    "        (key === \"object\" && isMemberExpression(parent))",
                    "      );",
                    "    case \"NGPipeExpression\":",
                    "      if (",
                    "        parent.type === \"NGRoot\" ||",
                    "        parent.type === \"NGMicrosyntaxExpression\" ||",
                    "        (parent.type === \"ObjectProperty\" &&",
                    "          // Preserve parens for compatibility with AngularJS expressions",
                    "          !node.extra?.parenthesized) ||",
                    "        isArrayOrTupleExpression(parent) ||",
                    "        (key === \"arguments\" && isCallExpression(parent)) ||",
                    "        (key === \"right\" && parent.type === \"NGPipeExpression\") ||",
                    "        (key === \"property\" && parent.type === \"MemberExpression\") ||",
                    "        parent.type === \"AssignmentExpression\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "      return true;",
                    "    case \"JSXFragment\":",
                    "    case \"JSXElement\":",
                    "      return (",
                    "        key === \"callee\" ||",
                    "        (key === \"left\" &&",
                    "          parent.type === \"BinaryExpression\" &&",
                    "          parent.operator === \"<\") ||",
                    "        (!isArrayOrTupleExpression(parent) &&",
                    "          parent.type !== \"ArrowFunctionExpression\" &&",
                    "          parent.type !== \"AssignmentExpression\" &&",
                    "          parent.type !== \"AssignmentPattern\" &&",
                    "          parent.type !== \"BinaryExpression\" &&",
                    "          parent.type !== \"NewExpression\" &&",
                    "          parent.type !== \"ConditionalExpression\" &&",
                    "          parent.type !== \"ExpressionStatement\" &&",
                    "          parent.type !== \"JsExpressionRoot\" &&",
                    "          parent.type !== \"JSXAttribute\" &&",
                    "          parent.type !== \"JSXElement\" &&",
                    "          parent.type !== \"JSXExpressionContainer\" &&",
                    "          parent.type !== \"JSXFragment\" &&",
                    "          parent.type !== \"LogicalExpression\" &&",
                    "          !isCallExpression(parent) &&",
                    "          !isObjectProperty(parent) &&",
                    "          parent.type !== \"ReturnStatement\" &&",
                    "          parent.type !== \"ThrowStatement\" &&",
                    "          parent.type !== \"TypeCastExpression\" &&",
                    "          parent.type !== \"VariableDeclarator\" &&",
                    "          parent.type !== \"YieldExpression\")",
                    "      );",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "const isStatement = createTypeCheckFunction([",
                    "  \"BlockStatement\",",
                    "  \"BreakStatement\",",
                    "  \"ClassBody\",",
                    "  \"ClassDeclaration\",",
                    "  \"ClassMethod\",",
                    "  \"ClassProperty\",",
                    "  \"PropertyDefinition\",",
                    "  \"ClassPrivateProperty\",",
                    "  \"ContinueStatement\",",
                    "  \"DebuggerStatement\",",
                    "  \"DeclareClass\",",
                    "  \"DeclareExportAllDeclaration\",",
                    "  \"DeclareExportDeclaration\",",
                    "  \"DeclareFunction\",",
                    "  \"DeclareInterface\",",
                    "  \"DeclareModule\",",
                    "  \"DeclareModuleExports\",",
                    "  \"DeclareVariable\",",
                    "  \"DeclareEnum\",",
                    "  \"DoWhileStatement\",",
                    "  \"EnumDeclaration\",",
                    "  \"ExportAllDeclaration\",",
                    "  \"ExportDefaultDeclaration\",",
                    "  \"ExportNamedDeclaration\",",
                    "  \"ExpressionStatement\",",
                    "  \"ForInStatement\",",
                    "  \"ForOfStatement\",",
                    "  \"ForStatement\",",
                    "  \"FunctionDeclaration\",",
                    "  \"IfStatement\",",
                    "  \"ImportDeclaration\",",
                    "  \"InterfaceDeclaration\",",
                    "  \"LabeledStatement\",",
                    "  \"MethodDefinition\",",
                    "  \"ReturnStatement\",",
                    "  \"SwitchStatement\",",
                    "  \"ThrowStatement\",",
                    "  \"TryStatement\",",
                    "  \"TSDeclareFunction\",",
                    "  \"TSEnumDeclaration\",",
                    "  \"TSImportEqualsDeclaration\",",
                    "  \"TSInterfaceDeclaration\",",
                    "  \"TSModuleDeclaration\",",
                    "  \"TSNamespaceExportDeclaration\",",
                    "  \"TypeAlias\",",
                    "  \"VariableDeclaration\",",
                    "  \"WhileStatement\",",
                    "  \"WithStatement\",",
                    "]);",
                    "",
                    "function isPathInForStatementInitializer(path) {",
                    "  let i = 0;",
                    "  let { node } = path;",
                    "  while (node) {",
                    "    const parent = path.getParentNode(i++);",
                    "    if (parent?.type === \"ForStatement\" && parent.init === node) {",
                    "      return true;",
                    "    }",
                    "    node = parent;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function includesFunctionTypeInObjectType(node) {",
                    "  return hasNode(",
                    "    node,",
                    "    (node) =>",
                    "      node.type === \"ObjectTypeAnnotation\" &&",
                    "      hasNode(node, (node) => node.type === \"FunctionTypeAnnotation\")",
                    "  );",
                    "}",
                    "",
                    "function endsWithRightBracket(node) {",
                    "  return isObjectOrRecordExpression(node);",
                    "}",
                    "",
                    "function isFollowedByRightBracket(path) {",
                    "  const { parent, key } = path;",
                    "  switch (parent.type) {",
                    "    case \"NGPipeExpression\":",
                    "      if (key === \"arguments\" && path.isLast) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ObjectProperty\":",
                    "      if (key === \"value\") {",
                    "        return path.callParent(() => path.key === \"properties\" && path.isLast);",
                    "      }",
                    "      break;",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "      if (key === \"right\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ConditionalExpression\":",
                    "      if (key === \"alternate\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"UnaryExpression\":",
                    "      if (parent.prefix) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function shouldWrapFunctionForExportDefault(path, options) {",
                    "  const { node, parent } = path;",
                    "",
                    "  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {",
                    "    return (",
                    "      parent.type === \"ExportDefaultDeclaration\" ||",
                    "      // in some cases the function is already wrapped",
                    "      // (e.g. `export default (function() {})();`)",
                    "      // in this case we don't need to add extra parens",
                    "      !needsParens(path, options)",
                    "    );",
                    "  }",
                    "",
                    "  if (",
                    "    !hasNakedLeftSide(node) ||",
                    "    (parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return path.call(",
                    "    () => shouldWrapFunctionForExportDefault(path, options),",
                    "    ...getLeftSidePathName(node)",
                    "  );",
                    "}",
                    "",
                    "/*",
                    "Matches following cases:",
                    "",
                    "```js",
                    "(a?.b).c;",
                    "(a?.()).b;",
                    "(a?.b!).c;",
                    "(a?.()!).b;",
                    "(a?.b)!.c;",
                    "(a?.())!.b;",
                    "",
                    "(a?.b)();",
                    "(a?.())();",
                    "",
                    "new (a?.b)();",
                    "new (a?.())();",
                    "```",
                    "*/",
                    "function shouldAddParenthesesToChainElement(path) {",
                    "  // Babel, this was implemented before #13735, can use `path.match` as estree does",
                    "  const { node, parent, grandparent, key } = path;",
                    "  if (",
                    "    (node.type === \"OptionalMemberExpression\" ||",
                    "      node.type === \"OptionalCallExpression\") &&",
                    "    ((key === \"object\" && parent.type === \"MemberExpression\") ||",
                    "      (key === \"callee\" &&",
                    "        (parent.type === \"CallExpression\" ||",
                    "          parent.type === \"NewExpression\")) ||",
                    "      (parent.type === \"TSNonNullExpression\" &&",
                    "        grandparent.type === \"MemberExpression\" &&",
                    "        grandparent.object === parent))",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // ESTree, same logic as babel",
                    "  if (",
                    "    path.match(",
                    "      () => node.type === \"CallExpression\" || node.type === \"MemberExpression\",",
                    "      (node, name) => name === \"expression\" && node.type === \"ChainExpression\"",
                    "    ) &&",
                    "    (path.match(",
                    "      undefined,",
                    "      undefined,",
                    "      (node, name) =>",
                    "        (name === \"callee\" &&",
                    "          ((node.type === \"CallExpression\" && !node.optional) ||",
                    "            node.type === \"NewExpression\")) ||",
                    "        (name === \"object\" &&",
                    "          node.type === \"MemberExpression\" &&",
                    "          !node.optional)",
                    "    ) ||",
                    "      path.match(",
                    "        undefined,",
                    "        undefined,",
                    "        (node, name) =>",
                    "          name === \"expression\" && node.type === \"TSNonNullExpression\",",
                    "        (node, name) => name === \"object\" && node.type === \"MemberExpression\"",
                    "      ))",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Babel treat `(a?.b!).c` and `(a?.b)!.c` the same, https://github.com/babel/babel/discussions/15077",
                    "  // Use this to align with babel",
                    "  if (",
                    "    path.match(",
                    "      () => node.type === \"CallExpression\" || node.type === \"MemberExpression\",",
                    "      (node, name) =>",
                    "        name === \"expression\" && node.type === \"TSNonNullExpression\",",
                    "      (node, name) => name === \"expression\" && node.type === \"ChainExpression\",",
                    "      (node, name) => name === \"object\" && node.type === \"MemberExpression\"",
                    "    )",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // This function only handle cases above",
                    "  return false;",
                    "}",
                    "",
                    "export default needsParens;"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "const CATEGORY_JAVASCRIPT = \"JavaScript\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  arrowParens: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"always\",",
                    "    description: \"Include parentheses around a sole arrow function parameter.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"always\",",
                    "        description: \"Always include parens. Example: `(x) => x`\",",
                    "      },",
                    "      {",
                    "        value: \"avoid\",",
                    "        description: \"Omit parens when possible. Example: `x => x`\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  bracketSameLine: commonOptions.bracketSameLine,",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  jsxBracketSameLine: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    description: \"Put > on the last line instead of at a new line.\",",
                    "    deprecated: \"2.4.0\",",
                    "  },",
                    "  semi: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print semicolons.\",",
                    "    oppositeDescription:",
                    "      \"Do not print semicolons, except at the beginning of lines which may need them.\",",
                    "  },",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  jsxSingleQuote: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes in JSX.\",",
                    "  },",
                    "  quoteProps: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"as-needed\",",
                    "    description: \"Change when properties in objects are quoted.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"as-needed\",",
                    "        description: \"Only add quotes around object properties where required.\",",
                    "      },",
                    "      {",
                    "        value: \"consistent\",",
                    "        description:",
                    "          \"If at least one property in an object requires quotes, quote all properties.\",",
                    "      },",
                    "      {",
                    "        value: \"preserve\",",
                    "        description: \"Respect the input use of quotes in object properties.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  trailingComma: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"all\",",
                    "    description: \"Print trailing commas wherever possible when multi-line.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"all\",",
                    "        description:",
                    "          \"Trailing commas wherever possible (including function arguments).\",",
                    "      },",
                    "      {",
                    "        value: \"es5\",",
                    "        description:",
                    "          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",",
                    "      },",
                    "      { value: \"none\", description: \"No trailing commas.\" },",
                    "    ],",
                    "  },",
                    "  singleAttributePerLine: commonOptions.singleAttributePerLine,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { parseWithComments, strip, extract, print } from \"jest-docblock\";",
                    "import { normalizeEndOfLine } from \"../common/end-of-line.js\";",
                    "import getShebang from \"./utils/get-shebang.js\";",
                    "",
                    "function parseDocBlock(text) {",
                    "  const shebang = getShebang(text);",
                    "  if (shebang) {",
                    "    text = text.slice(shebang.length + 1);",
                    "  }",
                    "",
                    "  const docBlock = extract(text);",
                    "  const { pragmas, comments } = parseWithComments(docBlock);",
                    "",
                    "  return { shebang, text, pragmas, comments };",
                    "}",
                    "",
                    "function hasPragma(text) {",
                    "  const { pragmas } = parseDocBlock(text);",
                    "  return Object.hasOwn(pragmas, \"prettier\") || Object.hasOwn(pragmas, \"format\");",
                    "}",
                    "",
                    "function insertPragma(originalText) {",
                    "  const { shebang, text, pragmas, comments } = parseDocBlock(originalText);",
                    "  const strippedText = strip(text);",
                    "",
                    "  let docBlock = print({",
                    "    pragmas: {",
                    "      format: \"\",",
                    "      ...pragmas,",
                    "    },",
                    "    comments: comments.trimStart(),",
                    "  });",
                    "",
                    "  // normalise newlines (mitigate use of os.EOL by jest-docblock)",
                    "  // Only needed in development version on Windows,",
                    "  // bundler will hack `jest-docblock` enforce it to use `\\n` in production",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    docBlock = normalizeEndOfLine(docBlock);",
                    "  }",
                    "",
                    "  return (",
                    "    (shebang ? `${shebang}\\n` : \"\") +",
                    "    docBlock +",
                    "    (strippedText.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\") +",
                    "    strippedText",
                    "  );",
                    "}",
                    "",
                    "export { hasPragma, insertPragma };"
                ]
            },
            "printer-estree.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
                    "import { printDanglingComments } from \"../main/comments/print.js\";",
                    "import printIgnored from \"../main/print-ignored.js\";",
                    "import hasNewline from \"../utils/has-newline.js\";",
                    "import {",
                    "  join,",
                    "  line,",
                    "  hardline,",
                    "  softline,",
                    "  group,",
                    "  indent,",
                    "} from \"../document/builders.js\";",
                    "import { replaceEndOfLine, inheritLabel } from \"../document/utils.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "",
                    "import pathNeedsParens from \"./needs-parens.js\";",
                    "import {",
                    "  hasComment,",
                    "  CommentCheckFlags,",
                    "  isNextLineEmpty,",
                    "  needsHardlineAfterDanglingComment,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  isArrayOrTupleExpression,",
                    "  isObjectOrRecordExpression,",
                    "  startsWithNoLookaheadToken,",
                    "  createTypeCheckFunction,",
                    "} from \"./utils/index.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import isBlockComment from \"./utils/is-block-comment.js\";",
                    "import isIgnored from \"./utils/is-ignored.js\";",
                    "",
                    "import { printHtmlBinding } from \"./print/html-binding.js\";",
                    "import { printAngular } from \"./print/angular.js\";",
                    "import { printJsx } from \"./print/jsx.js\";",
                    "import { printFlow } from \"./print/flow.js\";",
                    "import { printTypescript } from \"./print/typescript.js\";",
                    "import {",
                    "  printOptionalToken,",
                    "  printBindExpressionCallee,",
                    "  adjustClause,",
                    "  printRestSpread,",
                    "  printDefiniteToken,",
                    "  printDeclareToken,",
                    "} from \"./print/misc.js\";",
                    "import {",
                    "  printImportDeclaration,",
                    "  printExportDeclaration,",
                    "  printModuleSpecifier,",
                    "} from \"./print/module.js\";",
                    "import { printTernary } from \"./print/ternary.js\";",
                    "import {",
                    "  printTaggedTemplateLiteral,",
                    "  printTemplateLiteral,",
                    "} from \"./print/template-literal.js\";",
                    "import { printArray } from \"./print/array.js\";",
                    "import { printObject } from \"./print/object.js\";",
                    "import {",
                    "  printClass,",
                    "  printClassMethod,",
                    "  printClassProperty,",
                    "  printClassBody,",
                    "} from \"./print/class.js\";",
                    "import { printProperty } from \"./print/property.js\";",
                    "import {",
                    "  printFunction,",
                    "  printArrowFunction,",
                    "  printMethod,",
                    "  printReturnStatement,",
                    "  printThrowStatement,",
                    "} from \"./print/function.js\";",
                    "import { printCallExpression } from \"./print/call-expression.js\";",
                    "import {",
                    "  printVariableDeclarator,",
                    "  printAssignmentExpression,",
                    "} from \"./print/assignment.js\";",
                    "import { printBinaryishExpression } from \"./print/binaryish.js\";",
                    "import { printStatementSequence } from \"./print/statement.js\";",
                    "import { printMemberExpression } from \"./print/member.js\";",
                    "import { printBlock, printBlockBody } from \"./print/block.js\";",
                    "import { printLiteral } from \"./print/literal.js\";",
                    "import { printDecorators } from \"./print/decorators.js\";",
                    "import { printTypeAnnotationProperty } from \"./print/type-annotation.js\";",
                    "import { shouldPrintLeadingSemicolon } from \"./print/semicolon.js\";",
                    "import { printExpressionStatement } from \"./print/expression-statement.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"../common/ast-path.js\").default} AstPath",
                    " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                    " */",
                    "",
                    "// Their decorators are handled themselves, and they don't need parentheses or leading semicolons",
                    "const shouldPrintDirectly = createTypeCheckFunction([",
                    "  \"ClassMethod\",",
                    "  \"ClassPrivateMethod\",",
                    "  \"ClassProperty\",",
                    "  \"ClassAccessorProperty\",",
                    "  \"AccessorProperty\",",
                    "  \"TSAbstractAccessorProperty\",",
                    "  \"PropertyDefinition\",",
                    "  \"TSAbstractPropertyDefinition\",",
                    "  \"ClassPrivateProperty\",",
                    "  \"MethodDefinition\",",
                    "  \"TSAbstractMethodDefinition\",",
                    "  \"TSDeclareMethod\",",
                    "]);",
                    "",
                    "/**",
                    " * @param {AstPath} path",
                    " * @param {*} options",
                    " * @param {*} print",
                    " * @param {*} [args]",
                    " * @returns {Doc}",
                    " */",
                    "function genericPrint(path, options, print, args) {",
                    "  const doc = printPathNoParens(path, options, print, args);",
                    "  if (!doc) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const { node } = path;",
                    "  if (shouldPrintDirectly(node)) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  const hasDecorators = isNonEmptyArray(node.decorators);",
                    "  const decoratorsDoc = printDecorators(path, options, print);",
                    "  const isClassExpression = node.type === \"ClassExpression\";",
                    "  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons",
                    "  if (hasDecorators && !isClassExpression) {",
                    "    return inheritLabel(doc, (doc) => group([decoratorsDoc, doc]));",
                    "  }",
                    "",
                    "  const needsParens = pathNeedsParens(path, options);",
                    "  const needsSemi = shouldPrintLeadingSemicolon(path, options);",
                    "",
                    "  if (!decoratorsDoc && !needsParens && !needsSemi) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  return inheritLabel(doc, (doc) => [",
                    "    needsSemi ? \";\" : \"\",",
                    "    needsParens ? \"(\" : \"\",",
                    "    needsParens && isClassExpression && hasDecorators",
                    "      ? [indent([line, decoratorsDoc, doc]), line]",
                    "      : [decoratorsDoc, doc],",
                    "    needsParens ? \")\" : \"\",",
                    "  ]);",
                    "}",
                    "",
                    "/**",
                    " * @param {AstPath} path",
                    " * @param {*} options",
                    " * @param {*} print",
                    " * @param {*} [args]",
                    " * @returns {Doc}",
                    " */",
                    "function printPathNoParens(path, options, print, args) {",
                    "  if (isIgnored(path)) {",
                    "    return printIgnored(path, options);",
                    "  }",
                    "",
                    "  for (const printer of [",
                    "    printLiteral,",
                    "    printHtmlBinding,",
                    "    printAngular,",
                    "    printJsx,",
                    "    printFlow,",
                    "    printTypescript,",
                    "  ]) {",
                    "    const printed = printer(path, options, print);",
                    "    if (printed !== undefined) {",
                    "      return printed;",
                    "    }",
                    "  }",
                    "",
                    "  const { node } = path;",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "  /** @type{Doc[]} */",
                    "  let parts = [];",
                    "",
                    "  switch (node.type) {",
                    "    case \"JsExpressionRoot\":",
                    "      return print(\"node\");",
                    "    case \"JsonRoot\":",
                    "      return [print(\"node\"), hardline];",
                    "    case \"File\":",
                    "      return print(\"program\");",
                    "",
                    "    case \"Program\":",
                    "      return printBlockBody(path, options, print);",
                    "    // Babel extension.",
                    "    case \"EmptyStatement\":",
                    "      return \"\";",
                    "    case \"ExpressionStatement\":",
                    "      return printExpressionStatement(path, options, print);",
                    "",
                    "    case \"ChainExpression\":",
                    "      return print(\"expression\");",
                    "",
                    "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
                    "    case \"ParenthesizedExpression\": {",
                    "      const shouldHug =",
                    "        !hasComment(node.expression) &&",
                    "        (isObjectOrRecordExpression(node.expression) ||",
                    "          isArrayOrTupleExpression(node.expression));",
                    "      if (shouldHug) {",
                    "        return [\"(\", print(\"expression\"), \")\"];",
                    "      }",
                    "      return group([",
                    "        \"(\",",
                    "        indent([softline, print(\"expression\")]),",
                    "        softline,",
                    "        \")\",",
                    "      ]);",
                    "    }",
                    "    case \"AssignmentExpression\":",
                    "      return printAssignmentExpression(path, options, print);",
                    "    case \"VariableDeclarator\":",
                    "      return printVariableDeclarator(path, options, print);",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "      return printBinaryishExpression(path, options, print);",
                    "    case \"AssignmentPattern\":",
                    "      return [print(\"left\"), \" = \", print(\"right\")];",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"MemberExpression\":",
                    "      return printMemberExpression(path, options, print);",
                    "",
                    "    case \"MetaProperty\":",
                    "      return [print(\"meta\"), \".\", print(\"property\")];",
                    "    case \"BindExpression\":",
                    "      if (node.object) {",
                    "        parts.push(print(\"object\"));",
                    "      }",
                    "",
                    "      parts.push(",
                    "        group(",
                    "          indent([softline, printBindExpressionCallee(path, options, print)])",
                    "        )",
                    "      );",
                    "",
                    "      return parts;",
                    "    case \"Identifier\":",
                    "      return [",
                    "        node.name,",
                    "        printOptionalToken(path),",
                    "        printDefiniteToken(path),",
                    "        printTypeAnnotationProperty(path, print),",
                    "      ];",
                    "",
                    "    case \"V8IntrinsicIdentifier\":",
                    "      return [\"%\", node.name];",
                    "    case \"SpreadElement\":",
                    "    case \"SpreadElementPattern\":",
                    "    case \"SpreadPropertyPattern\":",
                    "    case \"RestElement\":",
                    "      return printRestSpread(path, print);",
                    "    case \"FunctionDeclaration\":",
                    "    case \"FunctionExpression\":",
                    "      return printFunction(path, print, options, args);",
                    "    case \"ArrowFunctionExpression\":",
                    "      return printArrowFunction(path, options, print, args);",
                    "    case \"YieldExpression\":",
                    "      parts.push(\"yield\");",
                    "",
                    "      if (node.delegate) {",
                    "        parts.push(\"*\");",
                    "      }",
                    "      if (node.argument) {",
                    "        parts.push(\" \", print(\"argument\"));",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"AwaitExpression\":",
                    "      parts.push(\"await\");",
                    "      if (node.argument) {",
                    "        parts.push(\" \", print(\"argument\"));",
                    "        const { parent } = path;",
                    "        if (",
                    "          (isCallExpression(parent) && parent.callee === node) ||",
                    "          (isMemberExpression(parent) && parent.object === node)",
                    "        ) {",
                    "          parts = [indent([softline, ...parts]), softline];",
                    "          // avoid printing `await (await` on one line",
                    "          const parentAwaitOrBlock = path.findAncestor(",
                    "            (node) =>",
                    "              node.type === \"AwaitExpression\" || node.type === \"BlockStatement\"",
                    "          );",
                    "          if (",
                    "            parentAwaitOrBlock?.type !== \"AwaitExpression\" ||",
                    "            !startsWithNoLookaheadToken(",
                    "              parentAwaitOrBlock.argument,",
                    "              (leftmostNode) => leftmostNode === node",
                    "            )",
                    "          ) {",
                    "            return group(parts);",
                    "          }",
                    "        }",
                    "      }",
                    "      return parts;",
                    "",
                    "    case \"ExportDefaultDeclaration\":",
                    "    case \"ExportNamedDeclaration\":",
                    "    case \"ExportAllDeclaration\":",
                    "      return printExportDeclaration(path, options, print);",
                    "    case \"ImportDeclaration\":",
                    "      return printImportDeclaration(path, options, print);",
                    "    case \"ImportSpecifier\":",
                    "    case \"ExportSpecifier\":",
                    "    case \"ImportNamespaceSpecifier\":",
                    "    case \"ExportNamespaceSpecifier\":",
                    "    case \"ImportDefaultSpecifier\":",
                    "    case \"ExportDefaultSpecifier\":",
                    "      return printModuleSpecifier(path, options, print);",
                    "    case \"ImportAttribute\":",
                    "      return [print(\"key\"), \": \", print(\"value\")];",
                    "    case \"Import\":",
                    "      return \"import\";",
                    "    case \"BlockStatement\":",
                    "    case \"StaticBlock\":",
                    "      return printBlock(path, options, print);",
                    "    case \"ClassBody\":",
                    "      return printClassBody(path, options, print);",
                    "    case \"ThrowStatement\":",
                    "      return printThrowStatement(path, options, print);",
                    "    case \"ReturnStatement\":",
                    "      return printReturnStatement(path, options, print);",
                    "    case \"NewExpression\":",
                    "    case \"ImportExpression\":",
                    "    case \"OptionalCallExpression\":",
                    "    case \"CallExpression\":",
                    "      return printCallExpression(path, options, print);",
                    "",
                    "    case \"ObjectExpression\":",
                    "    case \"ObjectPattern\":",
                    "    case \"RecordExpression\":",
                    "      return printObject(path, options, print);",
                    "    // Babel 6",
                    "    case \"ObjectProperty\": // Non-standard AST node type.",
                    "    case \"Property\":",
                    "      if (node.method || node.kind === \"get\" || node.kind === \"set\") {",
                    "        return printMethod(path, options, print);",
                    "      }",
                    "      return printProperty(path, options, print);",
                    "    case \"ObjectMethod\":",
                    "      return printMethod(path, options, print);",
                    "    case \"Decorator\":",
                    "      return [\"@\", print(\"expression\")];",
                    "    case \"ArrayExpression\":",
                    "    case \"ArrayPattern\":",
                    "    case \"TupleExpression\":",
                    "      return printArray(path, options, print);",
                    "    case \"SequenceExpression\": {",
                    "      const { parent } = path;",
                    "      if (",
                    "        parent.type === \"ExpressionStatement\" ||",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        // For ExpressionStatements and for-loop heads, which are among",
                    "        // the few places a SequenceExpression appears unparenthesized, we want",
                    "        // to indent expressions after the first.",
                    "        const parts = [];",
                    "        path.each(({ isFirst }) => {",
                    "          if (isFirst) {",
                    "            parts.push(print());",
                    "          } else {",
                    "            parts.push(\",\", indent([line, print()]));",
                    "          }",
                    "        }, \"expressions\");",
                    "        return group(parts);",
                    "      }",
                    "      return group(join([\",\", line], path.map(print, \"expressions\")));",
                    "    }",
                    "    case \"ThisExpression\":",
                    "      return \"this\";",
                    "    case \"Super\":",
                    "      return \"super\";",
                    "    case \"Directive\":",
                    "      return [print(\"value\"), semi]; // Babel 6",
                    "    case \"UnaryExpression\":",
                    "      parts.push(node.operator);",
                    "",
                    "      if (/[a-z]$/.test(node.operator)) {",
                    "        parts.push(\" \");",
                    "      }",
                    "",
                    "      if (hasComment(node.argument)) {",
                    "        parts.push(",
                    "          group([\"(\", indent([softline, print(\"argument\")]), softline, \")\"])",
                    "        );",
                    "      } else {",
                    "        parts.push(print(\"argument\"));",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"UpdateExpression\":",
                    "      parts.push(print(\"argument\"), node.operator);",
                    "",
                    "      if (node.prefix) {",
                    "        parts.reverse();",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"ConditionalExpression\":",
                    "      return printTernary(path, options, print);",
                    "    case \"VariableDeclaration\": {",
                    "      const printed = path.map(print, \"declarations\");",
                    "",
                    "      // We generally want to terminate all variable declarations with a",
                    "      // semicolon, except when they in the () part of for loops.",
                    "      const parentNode = path.parent;",
                    "",
                    "      const isParentForLoop =",
                    "        parentNode.type === \"ForStatement\" ||",
                    "        parentNode.type === \"ForInStatement\" ||",
                    "        parentNode.type === \"ForOfStatement\";",
                    "",
                    "      const hasValue = node.declarations.some((decl) => decl.init);",
                    "",
                    "      let firstVariable;",
                    "      if (printed.length === 1 && !hasComment(node.declarations[0])) {",
                    "        firstVariable = printed[0];",
                    "      } else if (printed.length > 0) {",
                    "        // Indent first var to comply with eslint one-var rule",
                    "        firstVariable = indent(printed[0]);",
                    "      }",
                    "",
                    "      parts = [",
                    "        printDeclareToken(path),",
                    "        node.kind,",
                    "        firstVariable ? [\" \", firstVariable] : \"\",",
                    "        indent(",
                    "          printed",
                    "            .slice(1)",
                    "            .map((p) => [",
                    "              \",\",",
                    "              hasValue && !isParentForLoop ? hardline : line,",
                    "              p,",
                    "            ])",
                    "        ),",
                    "      ];",
                    "",
                    "      if (!(isParentForLoop && parentNode.body !== node)) {",
                    "        parts.push(semi);",
                    "      }",
                    "",
                    "      return group(parts);",
                    "    }",
                    "    case \"WithStatement\":",
                    "      return group([",
                    "        \"with (\",",
                    "        print(\"object\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "    case \"IfStatement\": {",
                    "      const con = adjustClause(node.consequent, print(\"consequent\"));",
                    "      const opening = group([",
                    "        \"if (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        con,",
                    "      ]);",
                    "",
                    "      parts.push(opening);",
                    "",
                    "      if (node.alternate) {",
                    "        const commentOnOwnLine =",
                    "          hasComment(",
                    "            node.consequent,",
                    "            CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                    "          ) || needsHardlineAfterDanglingComment(node);",
                    "        const elseOnSameLine =",
                    "          node.consequent.type === \"BlockStatement\" && !commentOnOwnLine;",
                    "        parts.push(elseOnSameLine ? \" \" : hardline);",
                    "",
                    "        if (hasComment(node, CommentCheckFlags.Dangling)) {",
                    "          parts.push(",
                    "            printDanglingComments(path, options),",
                    "            commentOnOwnLine ? hardline : \" \"",
                    "          );",
                    "        }",
                    "",
                    "        parts.push(",
                    "          \"else\",",
                    "          group(",
                    "            adjustClause(",
                    "              node.alternate,",
                    "              print(\"alternate\"),",
                    "              node.alternate.type === \"IfStatement\"",
                    "            )",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    case \"ForStatement\": {",
                    "      const body = adjustClause(node.body, print(\"body\"));",
                    "",
                    "      // We want to keep dangling comments above the loop to stay consistent.",
                    "      // Any comment positioned between the for statement and the parentheses",
                    "      // is going to be printed before the statement.",
                    "      const dangling = printDanglingComments(path, options);",
                    "      const printedComments = dangling ? [dangling, softline] : \"\";",
                    "",
                    "      if (!node.init && !node.test && !node.update) {",
                    "        return [printedComments, group([\"for (;;)\", body])];",
                    "      }",
                    "",
                    "      return [",
                    "        printedComments,",
                    "        group([",
                    "          \"for (\",",
                    "          group([",
                    "            indent([",
                    "              softline,",
                    "              print(\"init\"),",
                    "              \";\",",
                    "              line,",
                    "              print(\"test\"),",
                    "              \";\",",
                    "              line,",
                    "              print(\"update\"),",
                    "            ]),",
                    "            softline,",
                    "          ]),",
                    "          \")\",",
                    "          body,",
                    "        ]),",
                    "      ];",
                    "    }",
                    "    case \"WhileStatement\":",
                    "      return group([",
                    "        \"while (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "    case \"ForInStatement\":",
                    "      return group([",
                    "        \"for (\",",
                    "        print(\"left\"),",
                    "        \" in \",",
                    "        print(\"right\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "",
                    "    case \"ForOfStatement\":",
                    "      return group([",
                    "        \"for\",",
                    "        node.await ? \" await\" : \"\",",
                    "        \" (\",",
                    "        print(\"left\"),",
                    "        \" of \",",
                    "        print(\"right\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "",
                    "    case \"DoWhileStatement\": {",
                    "      const clause = adjustClause(node.body, print(\"body\"));",
                    "      const doBody = group([\"do\", clause]);",
                    "      parts = [doBody];",
                    "",
                    "      if (node.body.type === \"BlockStatement\") {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(hardline);",
                    "      }",
                    "      parts.push(",
                    "        \"while (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        semi",
                    "      );",
                    "",
                    "      return parts;",
                    "    }",
                    "    case \"DoExpression\":",
                    "      return [node.async ? \"async \" : \"\", \"do \", print(\"body\")];",
                    "    case \"BreakStatement\":",
                    "    case \"ContinueStatement\":",
                    "      parts.push(node.type === \"BreakStatement\" ? \"break\" : \"continue\");",
                    "",
                    "      if (node.label) {",
                    "        parts.push(\" \", print(\"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return parts;",
                    "    case \"LabeledStatement\":",
                    "      if (node.body.type === \"EmptyStatement\") {",
                    "        return [print(\"label\"), \":;\"];",
                    "      }",
                    "",
                    "      return [print(\"label\"), \": \", print(\"body\")];",
                    "    case \"TryStatement\":",
                    "      return [",
                    "        \"try \",",
                    "        print(\"block\"),",
                    "        node.handler ? [\" \", print(\"handler\")] : \"\",",
                    "        node.finalizer ? [\" finally \", print(\"finalizer\")] : \"\",",
                    "      ];",
                    "    case \"CatchClause\":",
                    "      if (node.param) {",
                    "        const parameterHasComments = hasComment(",
                    "          node.param,",
                    "          (comment) =>",
                    "            !isBlockComment(comment) ||",
                    "            (comment.leading &&",
                    "              hasNewline(options.originalText, locEnd(comment))) ||",
                    "            (comment.trailing &&",
                    "              hasNewline(options.originalText, locStart(comment), {",
                    "                backwards: true,",
                    "              }))",
                    "        );",
                    "        const param = print(\"param\");",
                    "",
                    "        return [",
                    "          \"catch \",",
                    "          parameterHasComments",
                    "            ? [\"(\", indent([softline, param]), softline, \") \"]",
                    "            : [\"(\", param, \") \"],",
                    "          print(\"body\"),",
                    "        ];",
                    "      }",
                    "",
                    "      return [\"catch \", print(\"body\")];",
                    "    // Note: ignoring n.lexical because it has no printing consequences.",
                    "    case \"SwitchStatement\":",
                    "      return [",
                    "        group([",
                    "          \"switch (\",",
                    "          indent([softline, print(\"discriminant\")]),",
                    "          softline,",
                    "          \")\",",
                    "        ]),",
                    "        \" {\",",
                    "        node.cases.length > 0",
                    "          ? indent([",
                    "              hardline,",
                    "              join(",
                    "                hardline,",
                    "                path.map(",
                    "                  ({ node, isLast }) => [",
                    "                    print(),",
                    "                    !isLast && isNextLineEmpty(node, options) ? hardline : \"\",",
                    "                  ],",
                    "                  \"cases\"",
                    "                )",
                    "              ),",
                    "            ])",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "    case \"SwitchCase\": {",
                    "      if (node.test) {",
                    "        parts.push(\"case \", print(\"test\"), \":\");",
                    "      } else {",
                    "        parts.push(\"default:\");",
                    "      }",
                    "",
                    "      if (hasComment(node, CommentCheckFlags.Dangling)) {",
                    "        parts.push(\" \", printDanglingComments(path, options));",
                    "      }",
                    "",
                    "      const consequent = node.consequent.filter(",
                    "        (node) => node.type !== \"EmptyStatement\"",
                    "      );",
                    "",
                    "      if (consequent.length > 0) {",
                    "        const cons = printStatementSequence(path, options, print, \"consequent\");",
                    "",
                    "        parts.push(",
                    "          consequent.length === 1 && consequent[0].type === \"BlockStatement\"",
                    "            ? [\" \", cons]",
                    "            : indent([hardline, cons])",
                    "        );",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    // JSX extensions below.",
                    "    case \"DebuggerStatement\":",
                    "      return [\"debugger\", semi];",
                    "",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\":",
                    "      return printClass(path, options, print);",
                    "    case \"ClassMethod\":",
                    "    case \"ClassPrivateMethod\":",
                    "    case \"MethodDefinition\":",
                    "      return printClassMethod(path, options, print);",
                    "    case \"ClassProperty\":",
                    "    case \"PropertyDefinition\":",
                    "    case \"ClassPrivateProperty\":",
                    "    case \"ClassAccessorProperty\":",
                    "    case \"AccessorProperty\":",
                    "      return printClassProperty(path, options, print);",
                    "    case \"TemplateElement\":",
                    "      return replaceEndOfLine(node.value.raw);",
                    "    case \"TemplateLiteral\":",
                    "      return printTemplateLiteral(path, print, options);",
                    "    case \"TaggedTemplateExpression\":",
                    "      return printTaggedTemplateLiteral(print);",
                    "    case \"PrivateIdentifier\":",
                    "      return [\"#\", node.name];",
                    "    case \"PrivateName\":",
                    "      return [\"#\", print(\"id\")];",
                    "",
                    "    // For hack-style pipeline",
                    "    case \"TopicReference\":",
                    "      return \"%\";",
                    "",
                    "    case \"ArgumentPlaceholder\":",
                    "      return \"?\";",
                    "",
                    "    case \"ModuleExpression\": {",
                    "      parts.push(\"module {\");",
                    "      const printed = print(\"body\");",
                    "      if (printed) {",
                    "        parts.push(indent([hardline, printed]), hardline);",
                    "      }",
                    "      parts.push(\"}\");",
                    "      return parts;",
                    "    }",
                    "",
                    "    case \"InterpreterDirective\": // Printed as comment",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"ESTree\");",
                    "  }",
                    "}",
                    "",
                    "export const experimentalFeatures = {",
                    "  // TODO: Make this default behavior",
                    "  avoidAstMutation: true,",
                    "};",
                    "export { genericPrint as print };",
                    "export * from \"./comments/printer-methods.js\";",
                    "export { default as embed } from \"./embed/index.js\";",
                    "export { default as massageAstNode } from \"./clean.js\";",
                    "export { insertPragma } from \"./pragma.js\";",
                    "export { default as getVisitorKeys } from \"./traverse/get-visitor-keys.js\";"
                ]
            },
            "comments": {
                "handle-comments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import getNextNonSpaceNonCommentCharacter from \"../../utils/get-next-non-space-non-comment-character.js\";",
                        "import getNextNonSpaceNonCommentCharacterIndex from \"../../utils/get-next-non-space-non-comment-character-index.js\";",
                        "import hasNewlineInRange from \"../../utils/has-newline-in-range.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  addLeadingComment,",
                        "  addTrailingComment,",
                        "  addDanglingComment,",
                        "} from \"../../main/comments/utils.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  isPrettierIgnoreComment,",
                        "  isCallLikeExpression,",
                        "  getCallArguments,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isObjectProperty,",
                        "  isLineComment,",
                        "  markerForIfWithoutBlockAndSameLineComment,",
                        "  createTypeCheckFunction,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import isBlockComment from \"../utils/is-block-comment.js\";",
                        "import isTypeCastComment from \"../utils/is-type-cast-comment.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " * @typedef {import(\"../types/estree.js\").Comment} Comment",
                        " *",
                        " * @typedef {Object} CommentContext",
                        " * @property {Comment} comment",
                        " * @property {Node} precedingNode",
                        " * @property {Node} enclosingNode",
                        " * @property {Node} followingNode",
                        " * @property {string} text",
                        " * @property {any} options",
                        " * @property {Node} ast",
                        " * @property {boolean} isLastComment",
                        " */",
                        "",
                        "/**",
                        " * @param {CommentContext} context",
                        " * @returns {boolean}",
                        " */",
                        "function handleOwnLineComment(context) {",
                        "  return [",
                        "    handleIgnoreComments,",
                        "    handleLastFunctionArgComments,",
                        "    handleMemberExpressionComments,",
                        "    handleIfStatementComments,",
                        "    handleWhileComments,",
                        "    handleTryStatementComments,",
                        "    handleClassComments,",
                        "    handleForComments,",
                        "    handleUnionTypeComments,",
                        "    handleOnlyComments,",
                        "    handleModuleSpecifiersComments,",
                        "    handleAssignmentPatternComments,",
                        "    handleMethodNameComments,",
                        "    handleLabeledStatementComments,",
                        "    handleBreakAndContinueStatementComments,",
                        "  ].some((fn) => fn(context));",
                        "}",
                        "",
                        "/**",
                        " * @param {CommentContext} context",
                        " * @returns {boolean}",
                        " */",
                        "function handleEndOfLineComment(context) {",
                        "  return [",
                        "    handleClosureTypeCastComments,",
                        "    handleLastFunctionArgComments,",
                        "    handleConditionalExpressionComments,",
                        "    handleModuleSpecifiersComments,",
                        "    handleIfStatementComments,",
                        "    handleWhileComments,",
                        "    handleTryStatementComments,",
                        "    handleClassComments,",
                        "    handleLabeledStatementComments,",
                        "    handleCallExpressionComments,",
                        "    handlePropertyComments,",
                        "    handleOnlyComments,",
                        "    handleVariableDeclaratorComments,",
                        "    handleBreakAndContinueStatementComments,",
                        "    handleSwitchDefaultCaseComments,",
                        "  ].some((fn) => fn(context));",
                        "}",
                        "",
                        "/**",
                        " * @param {CommentContext} context",
                        " * @returns {boolean}",
                        " */",
                        "function handleRemainingComment(context) {",
                        "  return [",
                        "    handleIgnoreComments,",
                        "    handleIfStatementComments,",
                        "    handleWhileComments,",
                        "    handleObjectPropertyAssignment,",
                        "    handleCommentInEmptyParens,",
                        "    handleMethodNameComments,",
                        "    handleOnlyComments,",
                        "    handleCommentAfterArrowParams,",
                        "    handleFunctionNameComments,",
                        "    handleTSMappedTypeComments,",
                        "    handleBreakAndContinueStatementComments,",
                        "    handleTSFunctionTrailingComments,",
                        "  ].some((fn) => fn(context));",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {void}",
                        " */",
                        "function addBlockStatementFirstComment(node, comment) {",
                        "  // @ts-expect-error",
                        "  const firstNonEmptyNode = (node.body || node.properties).find(",
                        "    ({ type }) => type !== \"EmptyStatement\"",
                        "  );",
                        "  if (firstNonEmptyNode) {",
                        "    addLeadingComment(firstNonEmptyNode, comment);",
                        "  } else {",
                        "    addDanglingComment(node, comment);",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {void}",
                        " */",
                        "function addBlockOrNotComment(node, comment) {",
                        "  if (node.type === \"BlockStatement\") {",
                        "    addBlockStatementFirstComment(node, comment);",
                        "  } else {",
                        "    addLeadingComment(node, comment);",
                        "  }",
                        "}",
                        "",
                        "function handleClosureTypeCastComments({ comment, followingNode }) {",
                        "  if (followingNode && isTypeCastComment(comment)) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "// There are often comments before the else clause of if statements like",
                        "//",
                        "//   if (1) { ... }",
                        "//   // comment",
                        "//   else { ... }",
                        "//",
                        "// They are being attached as leading comments of the BlockExpression which",
                        "// is not well printed. What we want is to instead move the comment inside",
                        "// of the block and make it leadingComment of the first element of the block",
                        "// or dangling comment of the block if there is nothing inside",
                        "//",
                        "//   if (1) { ... }",
                        "//   else {",
                        "//     // comment",
                        "//     ...",
                        "//   }",
                        "function handleIfStatementComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  if (enclosingNode?.type !== \"IfStatement\" || !followingNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // We unfortunately have no way using the AST or location of nodes to know",
                        "  // if the comment is positioned before the condition parenthesis:",
                        "  //   if (a /* comment */) {}",
                        "  // The only workaround I found is to look at the next character to see if",
                        "  // it is a ).",
                        "  const nextCharacter = getNextNonSpaceNonCommentCharacter(",
                        "    text,",
                        "    locEnd(comment)",
                        "  );",
                        "  if (nextCharacter === \")\") {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  // Comments before `else`:",
                        "  // - treat as trailing comments of the consequent, if it's a BlockStatement",
                        "  // - treat as a dangling comment otherwise",
                        "  if (",
                        "    precedingNode === enclosingNode.consequent &&",
                        "    followingNode === enclosingNode.alternate",
                        "  ) {",
                        "    if (precedingNode.type === \"BlockStatement\") {",
                        "      addTrailingComment(precedingNode, comment);",
                        "    } else {",
                        "      const isSingleLineComment =",
                        "        comment.type === \"SingleLine\" ||",
                        "        comment.loc.start.line === comment.loc.end.line;",
                        "      const isSameLineComment =",
                        "        comment.loc.start.line === precedingNode.loc.start.line;",
                        "      if (isSingleLineComment && isSameLineComment) {",
                        "        // example:",
                        "        //   if (cond1) expr1; // comment A",
                        "        //   else if (cond2) expr2; // comment A",
                        "        //   else expr3;",
                        "        addDanglingComment(",
                        "          precedingNode,",
                        "          comment,",
                        "          markerForIfWithoutBlockAndSameLineComment",
                        "        );",
                        "      } else {",
                        "        addDanglingComment(enclosingNode, comment);",
                        "      }",
                        "    }",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"BlockStatement\") {",
                        "    addBlockStatementFirstComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"IfStatement\") {",
                        "    addBlockOrNotComment(followingNode.consequent, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  // For comments positioned after the condition parenthesis in an if statement",
                        "  // before the consequent without brackets on, such as",
                        "  // if (a) /* comment */ true,",
                        "  // we look at the next character to see if the following node",
                        "  // is the consequent for the if statement",
                        "  if (enclosingNode.consequent === followingNode) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleWhileComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  if (enclosingNode?.type !== \"WhileStatement\" || !followingNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // We unfortunately have no way using the AST or location of nodes to know",
                        "  // if the comment is positioned before the condition parenthesis:",
                        "  //   while (a /* comment */) {}",
                        "  // The only workaround I found is to look at the next character to see if",
                        "  // it is a ).",
                        "  const nextCharacter = getNextNonSpaceNonCommentCharacter(",
                        "    text,",
                        "    locEnd(comment)",
                        "  );",
                        "  if (nextCharacter === \")\") {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"BlockStatement\") {",
                        "    addBlockStatementFirstComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (enclosingNode.body === followingNode) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "// Same as IfStatement but for TryStatement",
                        "function handleTryStatementComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    (enclosingNode?.type !== \"TryStatement\" &&",
                        "      enclosingNode?.type !== \"CatchClause\") ||",
                        "    !followingNode",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (enclosingNode.type === \"CatchClause\" && precedingNode) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"BlockStatement\") {",
                        "    addBlockStatementFirstComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"TryStatement\") {",
                        "    addBlockOrNotComment(followingNode.finalizer, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"CatchClause\") {",
                        "    addBlockOrNotComment(followingNode.body, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleMemberExpressionComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    isMemberExpression(enclosingNode) &&",
                        "    followingNode?.type === \"Identifier\"",
                        "  ) {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleConditionalExpressionComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  const isSameLineAsPrecedingNode =",
                        "    precedingNode &&",
                        "    !hasNewlineInRange(text, locEnd(precedingNode), locStart(comment));",
                        "",
                        "  if (",
                        "    (!precedingNode || !isSameLineAsPrecedingNode) &&",
                        "    (enclosingNode?.type === \"ConditionalExpression\" ||",
                        "      enclosingNode?.type === \"TSConditionalType\") &&",
                        "    followingNode",
                        "  ) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleObjectPropertyAssignment({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "}) {",
                        "  if (",
                        "    isObjectProperty(enclosingNode) &&",
                        "    enclosingNode.shorthand &&",
                        "    enclosingNode.key === precedingNode &&",
                        "    enclosingNode.value.type === \"AssignmentPattern\"",
                        "  ) {",
                        "    addTrailingComment(enclosingNode.value.left, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "const classLikeNodeTypes = new Set([",
                        "  \"ClassDeclaration\",",
                        "  \"ClassExpression\",",
                        "  \"DeclareClass\",",
                        "  \"DeclareInterface\",",
                        "  \"InterfaceDeclaration\",",
                        "  \"TSInterfaceDeclaration\",",
                        "]);",
                        "function handleClassComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (classLikeNodeTypes.has(enclosingNode?.type)) {",
                        "    if (",
                        "      isNonEmptyArray(enclosingNode.decorators) &&",
                        "      !(followingNode?.type === \"Decorator\")",
                        "    ) {",
                        "      addTrailingComment(enclosingNode.decorators.at(-1), comment);",
                        "      return true;",
                        "    }",
                        "",
                        "    if (enclosingNode.body && followingNode === enclosingNode.body) {",
                        "      addBlockStatementFirstComment(enclosingNode.body, comment);",
                        "      return true;",
                        "    }",
                        "",
                        "    // Don't add leading comments to `implements`, `extends`, `mixins` to",
                        "    // avoid printing the comment after the keyword.",
                        "    if (followingNode) {",
                        "      if (",
                        "        enclosingNode.superClass &&",
                        "        followingNode === enclosingNode.superClass &&",
                        "        precedingNode &&",
                        "        (precedingNode === enclosingNode.id ||",
                        "          precedingNode === enclosingNode.typeParameters)",
                        "      ) {",
                        "        addTrailingComment(precedingNode, comment);",
                        "        return true;",
                        "      }",
                        "",
                        "      for (const prop of [\"implements\", \"extends\", \"mixins\"]) {",
                        "        if (enclosingNode[prop] && followingNode === enclosingNode[prop][0]) {",
                        "          if (",
                        "            precedingNode &&",
                        "            (precedingNode === enclosingNode.id ||",
                        "              precedingNode === enclosingNode.typeParameters ||",
                        "              precedingNode === enclosingNode.superClass)",
                        "          ) {",
                        "            addTrailingComment(precedingNode, comment);",
                        "          } else {",
                        "            addDanglingComment(enclosingNode, comment, prop);",
                        "          }",
                        "          return true;",
                        "        }",
                        "      }",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "const propertyLikeNodeTypes = new Set([",
                        "  \"ClassMethod\",",
                        "  \"ClassProperty\",",
                        "  \"PropertyDefinition\",",
                        "  \"TSAbstractPropertyDefinition\",",
                        "  \"TSAbstractMethodDefinition\",",
                        "  \"TSDeclareMethod\",",
                        "  \"MethodDefinition\",",
                        "  \"ClassAccessorProperty\",",
                        "  \"AccessorProperty\",",
                        "  \"TSAbstractAccessorProperty\",",
                        "]);",
                        "function handleMethodNameComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  text,",
                        "}) {",
                        "  // This is only needed for estree parsers (flow, typescript) to attach",
                        "  // after a method name:",
                        "  // obj = { fn /*comment*/() {} };",
                        "  if (",
                        "    enclosingNode &&",
                        "    precedingNode &&",
                        "    getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) === \"(\" &&",
                        "    // \"MethodDefinition\" is handled in getCommentChildNodes",
                        "    (enclosingNode.type === \"Property\" ||",
                        "      enclosingNode.type === \"TSDeclareMethod\" ||",
                        "      enclosingNode.type === \"TSAbstractMethodDefinition\") &&",
                        "    precedingNode.type === \"Identifier\" &&",
                        "    enclosingNode.key === precedingNode &&",
                        "    // special Property case: { key: /*comment*/(value) };",
                        "    // comment should be attached to value instead of key",
                        "    getNextNonSpaceNonCommentCharacter(text, locEnd(precedingNode)) !== \":\"",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  // Print comments between decorators and class methods as a trailing comment",
                        "  // on the decorator node instead of the method node",
                        "  if (",
                        "    precedingNode?.type === \"Decorator\" &&",
                        "    propertyLikeNodeTypes.has(enclosingNode?.type)",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "const functionLikeNodeTypes = new Set([",
                        "  \"FunctionDeclaration\",",
                        "  \"FunctionExpression\",",
                        "  \"ClassMethod\",",
                        "  \"MethodDefinition\",",
                        "  \"ObjectMethod\",",
                        "]);",
                        "function handleFunctionNameComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  text,",
                        "}) {",
                        "  if (getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) !== \"(\") {",
                        "    return false;",
                        "  }",
                        "  if (precedingNode && functionLikeNodeTypes.has(enclosingNode?.type)) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleCommentAfterArrowParams({ comment, enclosingNode, text }) {",
                        "  if (!(enclosingNode?.type === \"ArrowFunctionExpression\")) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const index = getNextNonSpaceNonCommentCharacterIndex(text, locEnd(comment));",
                        "  if (index !== false && text.slice(index, index + 2) === \"=>\") {",
                        "    addDanglingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleCommentInEmptyParens({ comment, enclosingNode, text }) {",
                        "  if (getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) !== \")\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  // Only add dangling comments to fix the case when no params are present,",
                        "  // i.e. a function without any argument.",
                        "  if (",
                        "    enclosingNode &&",
                        "    ((isRealFunctionLikeNode(enclosingNode) &&",
                        "      getFunctionParameters(enclosingNode).length === 0) ||",
                        "      (isCallLikeExpression(enclosingNode) &&",
                        "        getCallArguments(enclosingNode).length === 0))",
                        "  ) {",
                        "    addDanglingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  if (",
                        "    (enclosingNode?.type === \"MethodDefinition\" ||",
                        "      enclosingNode?.type === \"TSAbstractMethodDefinition\") &&",
                        "    getFunctionParameters(enclosingNode.value).length === 0",
                        "  ) {",
                        "    addDanglingComment(enclosingNode.value, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleLastFunctionArgComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  // Flow function type definitions",
                        "  if (",
                        "    precedingNode?.type === \"FunctionTypeParam\" &&",
                        "    enclosingNode?.type === \"FunctionTypeAnnotation\" &&",
                        "    followingNode?.type !== \"FunctionTypeParam\"",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  // Real functions and TypeScript function type definitions",
                        "  if (",
                        "    (precedingNode?.type === \"Identifier\" ||",
                        "      precedingNode?.type === \"AssignmentPattern\") &&",
                        "    enclosingNode &&",
                        "    isRealFunctionLikeNode(enclosingNode) &&",
                        "    getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) === \")\"",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    enclosingNode?.type === \"FunctionDeclaration\" &&",
                        "    followingNode?.type === \"BlockStatement\"",
                        "  ) {",
                        "    const functionParamRightParenIndex = (() => {",
                        "      const parameters = getFunctionParameters(enclosingNode);",
                        "      if (parameters.length > 0) {",
                        "        return getNextNonSpaceNonCommentCharacterIndex(",
                        "          text,",
                        "          locEnd(parameters.at(-1))",
                        "        );",
                        "      }",
                        "      const functionParamLeftParenIndex =",
                        "        getNextNonSpaceNonCommentCharacterIndex(text, locEnd(enclosingNode.id));",
                        "      return (",
                        "        functionParamLeftParenIndex !== false &&",
                        "        getNextNonSpaceNonCommentCharacterIndex(",
                        "          text,",
                        "          functionParamLeftParenIndex + 1",
                        "        )",
                        "      );",
                        "    })();",
                        "    if (locStart(comment) > functionParamRightParenIndex) {",
                        "      addBlockStatementFirstComment(followingNode, comment);",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleLabeledStatementComments({ comment, enclosingNode }) {",
                        "  if (enclosingNode?.type === \"LabeledStatement\") {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleBreakAndContinueStatementComments({ comment, enclosingNode }) {",
                        "  if (",
                        "    (enclosingNode?.type === \"ContinueStatement\" ||",
                        "      enclosingNode?.type === \"BreakStatement\") &&",
                        "    !enclosingNode.label",
                        "  ) {",
                        "    addTrailingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleCallExpressionComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "}) {",
                        "  if (",
                        "    isCallExpression(enclosingNode) &&",
                        "    precedingNode &&",
                        "    enclosingNode.callee === precedingNode &&",
                        "    enclosingNode.arguments.length > 0",
                        "  ) {",
                        "    addLeadingComment(enclosingNode.arguments[0], comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleUnionTypeComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    enclosingNode?.type === \"UnionTypeAnnotation\" ||",
                        "    enclosingNode?.type === \"TSUnionType\"",
                        "  ) {",
                        "    if (isPrettierIgnoreComment(comment)) {",
                        "      followingNode.prettierIgnore = true;",
                        "      comment.unignore = true;",
                        "    }",
                        "    if (precedingNode) {",
                        "      addTrailingComment(precedingNode, comment);",
                        "      return true;",
                        "    }",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    (followingNode?.type === \"UnionTypeAnnotation\" ||",
                        "      followingNode?.type === \"TSUnionType\") &&",
                        "    isPrettierIgnoreComment(comment)",
                        "  ) {",
                        "    followingNode.types[0].prettierIgnore = true;",
                        "    comment.unignore = true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handlePropertyComments({ comment, enclosingNode }) {",
                        "  if (isObjectProperty(enclosingNode)) {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleOnlyComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  ast,",
                        "  isLastComment,",
                        "}) {",
                        "  // With Flow the enclosingNode is undefined so use the AST instead.",
                        "  if (ast?.body?.length === 0) {",
                        "    if (isLastComment) {",
                        "      addDanglingComment(ast, comment);",
                        "    } else {",
                        "      addLeadingComment(ast, comment);",
                        "    }",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    enclosingNode?.type === \"Program\" &&",
                        "    enclosingNode.body.length === 0 &&",
                        "    !isNonEmptyArray(enclosingNode.directives)",
                        "  ) {",
                        "    if (isLastComment) {",
                        "      addDanglingComment(enclosingNode, comment);",
                        "    } else {",
                        "      addLeadingComment(enclosingNode, comment);",
                        "    }",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    followingNode?.type === \"Program\" &&",
                        "    followingNode.body.length === 0 &&",
                        "    enclosingNode?.type === \"ModuleExpression\"",
                        "  ) {",
                        "    addDanglingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleForComments({ comment, enclosingNode }) {",
                        "  if (",
                        "    enclosingNode?.type === \"ForInStatement\" ||",
                        "    enclosingNode?.type === \"ForOfStatement\"",
                        "  ) {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleModuleSpecifiersComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  text,",
                        "}) {",
                        "  if (",
                        "    enclosingNode?.type === \"ImportSpecifier\" ||",
                        "    enclosingNode?.type === \"ExportSpecifier\"",
                        "  ) {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  const isImportDeclaration =",
                        "    precedingNode?.type === \"ImportSpecifier\" &&",
                        "    enclosingNode?.type === \"ImportDeclaration\";",
                        "  const isExportDeclaration =",
                        "    precedingNode?.type === \"ExportSpecifier\" &&",
                        "    enclosingNode?.type === \"ExportNamedDeclaration\";",
                        "  if (",
                        "    (isImportDeclaration || isExportDeclaration) &&",
                        "    hasNewline(text, locEnd(comment))",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleAssignmentPatternComments({ comment, enclosingNode }) {",
                        "  if (enclosingNode?.type === \"AssignmentPattern\") {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "const assignmentLikeNodeTypes = new Set([",
                        "  \"VariableDeclarator\",",
                        "  \"AssignmentExpression\",",
                        "  \"TypeAlias\",",
                        "  \"TSTypeAliasDeclaration\",",
                        "]);",
                        "const complexExprNodeTypes = new Set([",
                        "  \"ObjectExpression\",",
                        "  \"RecordExpression\",",
                        "  \"ArrayExpression\",",
                        "  \"TupleExpression\",",
                        "  \"TemplateLiteral\",",
                        "  \"TaggedTemplateExpression\",",
                        "  \"ObjectTypeAnnotation\",",
                        "  \"TSTypeLiteral\",",
                        "]);",
                        "function handleVariableDeclaratorComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    assignmentLikeNodeTypes.has(enclosingNode?.type) &&",
                        "    followingNode &&",
                        "    (complexExprNodeTypes.has(followingNode.type) || isBlockComment(comment))",
                        "  ) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleTSFunctionTrailingComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  if (",
                        "    !followingNode &&",
                        "    (enclosingNode?.type === \"TSMethodSignature\" ||",
                        "      enclosingNode?.type === \"TSDeclareFunction\" ||",
                        "      enclosingNode?.type === \"TSAbstractMethodDefinition\") &&",
                        "    getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) === \";\"",
                        "  ) {",
                        "    addTrailingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleIgnoreComments({ comment, enclosingNode, followingNode }) {",
                        "  if (",
                        "    isPrettierIgnoreComment(comment) &&",
                        "    enclosingNode?.type === \"TSMappedType\" &&",
                        "    followingNode?.type === \"TSTypeParameter\" &&",
                        "    followingNode.constraint",
                        "  ) {",
                        "    enclosingNode.prettierIgnore = true;",
                        "    comment.unignore = true;",
                        "    return true;",
                        "  }",
                        "}",
                        "",
                        "function handleTSMappedTypeComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (enclosingNode?.type !== \"TSMappedType\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (followingNode?.type === \"TSTypeParameter\" && followingNode.name) {",
                        "    addLeadingComment(followingNode.name, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (precedingNode?.type === \"TSTypeParameter\" && precedingNode.constraint) {",
                        "    addTrailingComment(precedingNode.constraint, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleSwitchDefaultCaseComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    !enclosingNode ||",
                        "    enclosingNode.type !== \"SwitchCase\" ||",
                        "    enclosingNode.test ||",
                        "    !followingNode ||",
                        "    followingNode !== enclosingNode.consequent[0]",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"BlockStatement\" && isLineComment(comment)) {",
                        "    addBlockStatementFirstComment(followingNode, comment);",
                        "  } else {",
                        "    addDanglingComment(enclosingNode, comment);",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isRealFunctionLikeNode = createTypeCheckFunction([",
                        "  \"ArrowFunctionExpression\",",
                        "  \"FunctionExpression\",",
                        "  \"FunctionDeclaration\",",
                        "  \"ObjectMethod\",",
                        "  \"ClassMethod\",",
                        "  \"TSDeclareFunction\",",
                        "  \"TSCallSignatureDeclaration\",",
                        "  \"TSConstructSignatureDeclaration\",",
                        "  \"TSMethodSignature\",",
                        "  \"TSConstructorType\",",
                        "  \"TSFunctionType\",",
                        "  \"TSDeclareMethod\",",
                        "]);",
                        "",
                        "export {",
                        "  handleOwnLineComment as ownLine,",
                        "  handleEndOfLineComment as endOfLine,",
                        "  handleRemainingComment as remaining,",
                        "};"
                    ]
                },
                "printer-methods.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  hasNodeIgnoreComment,",
                        "  isJsxElement,",
                        "} from \"../utils/index.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " */",
                        "",
                        "const nodeTypesCanNotAttachComment = new Set([",
                        "  \"EmptyStatement\",",
                        "  \"TemplateElement\",",
                        "  // In ESTree `import` is a token, `import(\"foo\")`",
                        "  \"Import\",",
                        "  // There is no similar node in Babel AST",
                        "  // ```ts",
                        "  // class Foo {",
                        "  //   bar();",
                        "  //      ^^^ TSEmptyBodyFunctionExpression",
                        "  // }",
                        "  // ```",
                        "  \"TSEmptyBodyFunctionExpression\",",
                        "  // There is no similar node in Babel AST, `a?.b`",
                        "  \"ChainExpression\",",
                        "]);",
                        "function canAttachComment(node) {",
                        "  return !nodeTypesCanNotAttachComment.has(node.type);",
                        "}",
                        "",
                        "/**",
                        " * @param {any} node",
                        " * @returns {Node[] | void}",
                        " */",
                        "function getCommentChildNodes(node, options) {",
                        "  // Prevent attaching comments to FunctionExpression in this case:",
                        "  //     class Foo {",
                        "  //       bar() // comment",
                        "  //       {",
                        "  //         baz();",
                        "  //       }",
                        "  //     }",
                        "  if (",
                        "    (options.parser === \"typescript\" ||",
                        "      options.parser === \"flow\" ||",
                        "      options.parser === \"acorn\" ||",
                        "      options.parser === \"espree\" ||",
                        "      options.parser === \"meriyah\" ||",
                        "      options.parser === \"__babel_estree\") &&",
                        "    node.type === \"MethodDefinition\" &&",
                        "    node.value?.type === \"FunctionExpression\" &&",
                        "    getFunctionParameters(node.value).length === 0 &&",
                        "    !node.value.returnType &&",
                        "    !isNonEmptyArray(node.value.typeParameters) &&",
                        "    node.value.body",
                        "  ) {",
                        "    return [...(node.decorators || []), node.key, node.value.body];",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function willPrintOwnComments(path) {",
                        "  const { node, parent } = path;",
                        "  return (",
                        "    (isJsxElement(node) ||",
                        "      (parent &&",
                        "        (parent.type === \"JSXSpreadAttribute\" ||",
                        "          parent.type === \"JSXSpreadChild\" ||",
                        "          parent.type === \"UnionTypeAnnotation\" ||",
                        "          parent.type === \"TSUnionType\" ||",
                        "          ((parent.type === \"ClassDeclaration\" ||",
                        "            parent.type === \"ClassExpression\") &&",
                        "            parent.superClass === node)))) &&",
                        "    (!hasNodeIgnoreComment(node) ||",
                        "      parent.type === \"UnionTypeAnnotation\" ||",
                        "      parent.type === \"TSUnionType\")",
                        "  );",
                        "}",
                        "",
                        "function isGap(text, { parser }) {",
                        "  if (parser === \"flow\" || parser === \"babel-flow\") {",
                        "    // Example: (a /* b */ /* : c */)",
                        "    //                gap ^^^^",
                        "    text = text.replaceAll(/[\\s(]/g, \"\");",
                        "    return text === \"\" || text === \"/*\" || text === \"/*::\";",
                        "  }",
                        "}",
                        "",
                        "export * as handleComments from \"./handle-comments.js\";",
                        "export { printComment } from \"../print/comment.js\";",
                        "export { default as isBlockComment } from \"../utils/is-block-comment.js\";",
                        "export { canAttachComment, getCommentChildNodes, willPrintOwnComments, isGap };"
                    ]
                }
            },
            "embed": {
                "css.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import { indent, hardline, softline } from \"../../document/builders.js\";",
                        "import { mapDoc, replaceEndOfLine, cleanDoc } from \"../../document/utils.js\";",
                        "import { printTemplateExpressions } from \"../print/template-literal.js\";",
                        "import { isAngularComponentStyles } from \"./utils.js\";",
                        "",
                        "async function printEmbedCss(textToDoc, print, path /*, options*/) {",
                        "  const { node } = path;",
                        "",
                        "  // Get full template literal with expressions replaced by placeholders",
                        "  const rawQuasis = node.quasis.map((q) => q.value.raw);",
                        "  let placeholderID = 0;",
                        "  const text = rawQuasis.reduce(",
                        "    (prevVal, currVal, idx) =>",
                        "      idx === 0",
                        "        ? currVal",
                        "        : prevVal +",
                        "          \"@prettier-placeholder-\" +",
                        "          placeholderID++ +",
                        "          \"-id\" +",
                        "          currVal,",
                        "    \"\"",
                        "  );",
                        "  const quasisDoc = await textToDoc(text, { parser: \"scss\" });",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  const newDoc = replacePlaceholders(quasisDoc, expressionDocs);",
                        "  /* c8 ignore next 3 */",
                        "  if (!newDoc) {",
                        "    throw new Error(\"Couldn't insert all the expressions\");",
                        "  }",
                        "  return [\"`\", indent([hardline, newDoc]), softline, \"`\"];",
                        "}",
                        "",
                        "// Search all the placeholders in the quasisDoc tree",
                        "// and replace them with the expression docs one by one",
                        "// returns a new doc with all the placeholders replaced,",
                        "// or null if it couldn't replace any expression",
                        "function replacePlaceholders(quasisDoc, expressionDocs) {",
                        "  if (!isNonEmptyArray(expressionDocs)) {",
                        "    return quasisDoc;",
                        "  }",
                        "  let replaceCounter = 0;",
                        "  const newDoc = mapDoc(cleanDoc(quasisDoc), (doc) => {",
                        "    if (typeof doc !== \"string\" || !doc.includes(\"@prettier-placeholder\")) {",
                        "      return doc;",
                        "    }",
                        "    // When we have multiple placeholders in one line, like:",
                        "    // ${Child}${Child2}:not(:first-child)",
                        "    return doc.split(/@prettier-placeholder-(\\d+)-id/).map((component, idx) => {",
                        "      // The placeholder is always at odd indices",
                        "      if (idx % 2 === 0) {",
                        "        return replaceEndOfLine(component);",
                        "      }",
                        "",
                        "      // The component will always be a number at odd index",
                        "      replaceCounter++;",
                        "      return expressionDocs[component];",
                        "    });",
                        "  });",
                        "  return expressionDocs.length === replaceCounter ? newDoc : null;",
                        "}",
                        "",
                        "/**",
                        " * Template literal in these contexts:",
                        " * <style jsx>{`div{color:red}`}</style>",
                        " * css``",
                        " * css.global``",
                        " * css.resolve``",
                        " */",
                        "function isStyledJsx({ node, parent, grandparent }) {",
                        "  return (",
                        "    (grandparent &&",
                        "      node.quasis &&",
                        "      parent.type === \"JSXExpressionContainer\" &&",
                        "      grandparent.type === \"JSXElement\" &&",
                        "      grandparent.openingElement.name.name === \"style\" &&",
                        "      grandparent.openingElement.attributes.some(",
                        "        (attribute) => attribute.name.name === \"jsx\"",
                        "      )) ||",
                        "    (parent?.type === \"TaggedTemplateExpression\" &&",
                        "      parent.tag.type === \"Identifier\" &&",
                        "      parent.tag.name === \"css\") ||",
                        "    (parent?.type === \"TaggedTemplateExpression\" &&",
                        "      parent.tag.type === \"MemberExpression\" &&",
                        "      parent.tag.object.name === \"css\" &&",
                        "      (parent.tag.property.name === \"global\" ||",
                        "        parent.tag.property.name === \"resolve\"))",
                        "  );",
                        "}",
                        "",
                        "function isStyledIdentifier(node) {",
                        "  return node.type === \"Identifier\" && node.name === \"styled\";",
                        "}",
                        "",
                        "function isStyledExtend(node) {",
                        "  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";",
                        "}",
                        "",
                        "/**",
                        " * styled-components template literals",
                        " */",
                        "function isStyledComponents({ parent }) {",
                        "  if (!parent || parent.type !== \"TaggedTemplateExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  const tag =",
                        "    parent.tag.type === \"ParenthesizedExpression\"",
                        "      ? parent.tag.expression",
                        "      : parent.tag;",
                        "",
                        "  switch (tag.type) {",
                        "    case \"MemberExpression\":",
                        "      return (",
                        "        // styled.foo``",
                        "        isStyledIdentifier(tag.object) ||",
                        "        // Component.extend``",
                        "        isStyledExtend(tag)",
                        "      );",
                        "",
                        "    case \"CallExpression\":",
                        "      return (",
                        "        // styled(Component)``",
                        "        isStyledIdentifier(tag.callee) ||",
                        "        (tag.callee.type === \"MemberExpression\" &&",
                        "          ((tag.callee.object.type === \"MemberExpression\" &&",
                        "            // styled.foo.attrs({})``",
                        "            (isStyledIdentifier(tag.callee.object.object) ||",
                        "              // Component.extend.attrs({})``",
                        "              isStyledExtend(tag.callee.object))) ||",
                        "            // styled(Component).attrs({})``",
                        "            (tag.callee.object.type === \"CallExpression\" &&",
                        "              isStyledIdentifier(tag.callee.object.callee))))",
                        "      );",
                        "",
                        "    case \"Identifier\":",
                        "      // css``",
                        "      return tag.name === \"css\";",
                        "",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * JSX element with CSS prop",
                        " */",
                        "function isCssProp({ parent, grandparent }) {",
                        "  return (",
                        "    grandparent?.type === \"JSXAttribute\" &&",
                        "    parent.type === \"JSXExpressionContainer\" &&",
                        "    grandparent.name.type === \"JSXIdentifier\" &&",
                        "    grandparent.name.name === \"css\"",
                        "  );",
                        "}",
                        "",
                        "function printCss(path /*, options*/) {",
                        "  if (",
                        "    isStyledJsx(path) ||",
                        "    isStyledComponents(path) ||",
                        "    isCssProp(path) ||",
                        "    isAngularComponentStyles(path)",
                        "  ) {",
                        "    return printEmbedCss;",
                        "  }",
                        "}",
                        "",
                        "export default printCss;"
                    ]
                },
                "graphql.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { indent, join, hardline } from \"../../document/builders.js\";",
                        "import {",
                        "  escapeTemplateCharacters,",
                        "  printTemplateExpressions,",
                        "} from \"../print/template-literal.js\";",
                        "import { hasLanguageComment } from \"./utils.js\";",
                        "",
                        "async function printEmbedGraphQL(textToDoc, print, path /*, options*/) {",
                        "  const { node } = path;",
                        "",
                        "  const numQuasis = node.quasis.length;",
                        "",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  const parts = [];",
                        "",
                        "  for (let i = 0; i < numQuasis; i++) {",
                        "    const templateElement = node.quasis[i];",
                        "    const isFirst = i === 0;",
                        "    const isLast = i === numQuasis - 1;",
                        "    const text = templateElement.value.cooked;",
                        "",
                        "    const lines = text.split(\"\\n\");",
                        "    const numLines = lines.length;",
                        "    const expressionDoc = expressionDocs[i];",
                        "",
                        "    const startsWithBlankLine =",
                        "      numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";",
                        "    const endsWithBlankLine =",
                        "      numLines > 2 &&",
                        "      lines[numLines - 1].trim() === \"\" &&",
                        "      lines[numLines - 2].trim() === \"\";",
                        "",
                        "    const commentsAndWhitespaceOnly = lines.every((line) =>",
                        "      /^\\s*(?:#[^\\n\\r]*)?$/.test(line)",
                        "    );",
                        "",
                        "    // Bail out if an interpolation occurs within a comment.",
                        "    if (!isLast && /#[^\\n\\r]*$/.test(lines[numLines - 1])) {",
                        "      return null;",
                        "    }",
                        "",
                        "    let doc = null;",
                        "",
                        "    if (commentsAndWhitespaceOnly) {",
                        "      doc = printGraphqlComments(lines);",
                        "    } else {",
                        "      doc = await textToDoc(text, { parser: \"graphql\" });",
                        "    }",
                        "",
                        "    if (doc) {",
                        "      doc = escapeTemplateCharacters(doc, false);",
                        "      if (!isFirst && startsWithBlankLine) {",
                        "        parts.push(\"\");",
                        "      }",
                        "      parts.push(doc);",
                        "      if (!isLast && endsWithBlankLine) {",
                        "        parts.push(\"\");",
                        "      }",
                        "    } else if (!isFirst && !isLast && startsWithBlankLine) {",
                        "      parts.push(\"\");",
                        "    }",
                        "",
                        "    if (expressionDoc) {",
                        "      parts.push(expressionDoc);",
                        "    }",
                        "  }",
                        "",
                        "  return [\"`\", indent([hardline, join(hardline, parts)]), hardline, \"`\"];",
                        "}",
                        "",
                        "function printGraphqlComments(lines) {",
                        "  const parts = [];",
                        "  let seenComment = false;",
                        "",
                        "  const array = lines.map((textLine) => textLine.trim());",
                        "  for (const [i, textLine] of array.entries()) {",
                        "    // Lines are either whitespace only, or a comment (with potential whitespace",
                        "    // around it). Drop whitespace-only lines.",
                        "    if (textLine === \"\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (array[i - 1] === \"\" && seenComment) {",
                        "      // If a non-first comment is preceded by a blank (whitespace only) line,",
                        "      // add in a blank line.",
                        "      parts.push([hardline, textLine]);",
                        "    } else {",
                        "      parts.push(textLine);",
                        "    }",
                        "",
                        "    seenComment = true;",
                        "  }",
                        "",
                        "  // If `lines` was whitespace only, return `null`.",
                        "  return parts.length === 0 ? null : join(hardline, parts);",
                        "}",
                        "",
                        "/*",
                        " * react-relay and graphql-tag",
                        " * graphql`...`",
                        " * graphql.experimental`...`",
                        " * gql`...`",
                        " * GraphQL comment block",
                        " *",
                        " * This intentionally excludes Relay Classic tags, as Prettier does not",
                        " * support Relay Classic formatting.",
                        " */",
                        "function isGraphQL({ node, parent }) {",
                        "  return (",
                        "    hasLanguageComment(node, \"GraphQL\") ||",
                        "    (parent &&",
                        "      ((parent.type === \"TaggedTemplateExpression\" &&",
                        "        ((parent.tag.type === \"MemberExpression\" &&",
                        "          parent.tag.object.name === \"graphql\" &&",
                        "          parent.tag.property.name === \"experimental\") ||",
                        "          (parent.tag.type === \"Identifier\" &&",
                        "            (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")))) ||",
                        "        (parent.type === \"CallExpression\" &&",
                        "          parent.callee.type === \"Identifier\" &&",
                        "          parent.callee.name === \"graphql\")))",
                        "  );",
                        "}",
                        "",
                        "function printGraphql(path /*, options*/) {",
                        "  if (isGraphQL(path)) {",
                        "    return printEmbedGraphQL;",
                        "  }",
                        "}",
                        "",
                        "export default printGraphql;"
                    ]
                },
                "html.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  indent,",
                        "  line,",
                        "  hardline,",
                        "  group,",
                        "  label,",
                        "} from \"../../document/builders.js\";",
                        "import { mapDoc } from \"../../document/utils.js\";",
                        "import {",
                        "  printTemplateExpressions,",
                        "  uncookTemplateElementValue,",
                        "} from \"../print/template-literal.js\";",
                        "import { isAngularComponentTemplate, hasLanguageComment } from \"./utils.js\";",
                        "",
                        "// The counter is needed to distinguish nested embeds.",
                        "let htmlTemplateLiteralCounter = 0;",
                        "async function printEmbedHtmlLike(parser, textToDoc, print, path, options) {",
                        "  const { node } = path;",
                        "  const counter = htmlTemplateLiteralCounter;",
                        "  htmlTemplateLiteralCounter = (htmlTemplateLiteralCounter + 1) >>> 0;",
                        "",
                        "  const composePlaceholder = (index) =>",
                        "    `PRETTIER_HTML_PLACEHOLDER_${index}_${counter}_IN_JS`;",
                        "",
                        "  const text = node.quasis",
                        "    .map((quasi, index, quasis) =>",
                        "      index === quasis.length - 1",
                        "        ? quasi.value.cooked",
                        "        : quasi.value.cooked + composePlaceholder(index)",
                        "    )",
                        "    .join(\"\");",
                        "",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "",
                        "  const placeholderRegex = new RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");",
                        "  let topLevelCount = 0;",
                        "  const doc = await textToDoc(text, {",
                        "    parser,",
                        "    __onHtmlRoot(root) {",
                        "      topLevelCount = root.children.length;",
                        "    },",
                        "  });",
                        "",
                        "  const contentDoc = mapDoc(doc, (doc) => {",
                        "    if (typeof doc !== \"string\") {",
                        "      return doc;",
                        "    }",
                        "",
                        "    const parts = [];",
                        "",
                        "    const components = doc.split(placeholderRegex);",
                        "    for (let i = 0; i < components.length; i++) {",
                        "      let component = components[i];",
                        "",
                        "      if (i % 2 === 0) {",
                        "        if (component) {",
                        "          component = uncookTemplateElementValue(component);",
                        "          if (options.__embeddedInHtml) {",
                        "            component = component.replaceAll(/<\\/(?=script\\b)/gi, \"<\\\\/\");",
                        "          }",
                        "          parts.push(component);",
                        "        }",
                        "        continue;",
                        "      }",
                        "",
                        "      const placeholderIndex = Number(component);",
                        "      parts.push(expressionDocs[placeholderIndex]);",
                        "    }",
                        "",
                        "    return parts;",
                        "  });",
                        "",
                        "  const leadingWhitespace = /^\\s/.test(text) ? \" \" : \"\";",
                        "  const trailingWhitespace = /\\s$/.test(text) ? \" \" : \"\";",
                        "",
                        "  const linebreak =",
                        "    options.htmlWhitespaceSensitivity === \"ignore\"",
                        "      ? hardline",
                        "      : leadingWhitespace && trailingWhitespace",
                        "      ? line",
                        "      : null;",
                        "",
                        "  if (linebreak) {",
                        "    return group([\"`\", indent([linebreak, group(contentDoc)]), linebreak, \"`\"]);",
                        "  }",
                        "",
                        "  return label(",
                        "    { hug: false },",
                        "    group([",
                        "      \"`\",",
                        "      leadingWhitespace,",
                        "      topLevelCount > 1 ? indent(group(contentDoc)) : group(contentDoc),",
                        "      trailingWhitespace,",
                        "      \"`\",",
                        "    ])",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " *     - html`...`",
                        " *     - HTML comment block",
                        " */",
                        "function isHtml(path) {",
                        "  return (",
                        "    hasLanguageComment(path.node, \"HTML\") ||",
                        "    path.match(",
                        "      (node) => node.type === \"TemplateLiteral\",",
                        "      (node, name) =>",
                        "        node.type === \"TaggedTemplateExpression\" &&",
                        "        node.tag.type === \"Identifier\" &&",
                        "        node.tag.name === \"html\" &&",
                        "        name === \"quasi\"",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "const printEmbedHtml = printEmbedHtmlLike.bind(undefined, \"html\");",
                        "const printEmbedAngular = printEmbedHtmlLike.bind(undefined, \"angular\");",
                        "",
                        "function printHtml(path /*, options*/) {",
                        "  if (isHtml(path)) {",
                        "    return printEmbedHtml;",
                        "  }",
                        "",
                        "  if (isAngularComponentTemplate(path)) {",
                        "    return printEmbedAngular;",
                        "  }",
                        "}",
                        "",
                        "export default printHtml;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { label } from \"../../document/builders.js\";",
                        "import printCss from \"./css.js\";",
                        "import printGraphQL from \"./graphql.js\";",
                        "import printHtml from \"./html.js\";",
                        "import printMarkdown from \"./markdown.js\";",
                        "",
                        "function embed(path) {",
                        "  const { node } = path;",
                        "",
                        "  if (",
                        "    node.type !== \"TemplateLiteral\" ||",
                        "    // Bail out if any of the quasis have an invalid escape sequence",
                        "    // (which would make the `cooked` value be `null`)",
                        "    hasInvalidCookedValue(node)",
                        "  ) {",
                        "    return;",
                        "  }",
                        "",
                        "  let embedder;",
                        "  for (const getEmbedder of [",
                        "    printCss,",
                        "    printGraphQL,",
                        "    printHtml,",
                        "    printMarkdown,",
                        "  ]) {",
                        "    embedder = getEmbedder(path);",
                        "",
                        "    if (!embedder) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Special case: whitespace-only template literals",
                        "    if (node.quasis.length === 1 && node.quasis[0].value.raw.trim() === \"\") {",
                        "      return \"``\";",
                        "    }",
                        "",
                        "    return async (...args) => {",
                        "      const doc = await embedder(...args);",
                        "      return doc && label({ embed: true, ...doc.label }, doc);",
                        "    };",
                        "  }",
                        "}",
                        "",
                        "function hasInvalidCookedValue({ quasis }) {",
                        "  return quasis.some(({ value: { cooked } }) => cooked === null);",
                        "}",
                        "",
                        "export default embed;"
                    ]
                },
                "markdown.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  indent,",
                        "  softline,",
                        "  literalline,",
                        "  dedentToRoot,",
                        "} from \"../../document/builders.js\";",
                        "import { escapeTemplateCharacters } from \"../print/template-literal.js\";",
                        "",
                        "async function printEmbedMarkdown(textToDoc, print, path /*, options*/) {",
                        "  const { node } = path;",
                        "  let text = node.quasis[0].value.raw.replaceAll(",
                        "    /((?:\\\\\\\\)*)\\\\`/g,",
                        "    (_, backslashes) => \"\\\\\".repeat(backslashes.length / 2) + \"`\"",
                        "  );",
                        "  const indentation = getIndentation(text);",
                        "  const hasIndent = indentation !== \"\";",
                        "  if (hasIndent) {",
                        "    text = text.replaceAll(new RegExp(`^${indentation}`, \"gm\"), \"\");",
                        "  }",
                        "  const doc = escapeTemplateCharacters(",
                        "    await textToDoc(text, { parser: \"markdown\", __inJsTemplate: true }),",
                        "    true",
                        "  );",
                        "  return [",
                        "    \"`\",",
                        "    hasIndent ? indent([softline, doc]) : [literalline, dedentToRoot(doc)],",
                        "    softline,",
                        "    \"`\",",
                        "  ];",
                        "}",
                        "",
                        "function getIndentation(str) {",
                        "  const firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);",
                        "  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];",
                        "}",
                        "",
                        "function printMarkdown(path /*, options*/) {",
                        "  if (isMarkdown(path)) {",
                        "    return printEmbedMarkdown;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * md`...`",
                        " * markdown`...`",
                        " */",
                        "function isMarkdown({ node, parent }) {",
                        "  return (",
                        "    parent?.type === \"TaggedTemplateExpression\" &&",
                        "    node.quasis.length === 1 &&",
                        "    parent.tag.type === \"Identifier\" &&",
                        "    (parent.tag.name === \"md\" || parent.tag.name === \"markdown\")",
                        "  );",
                        "}",
                        "",
                        "export default printMarkdown;"
                    ]
                },
                "utils.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isObjectProperty,",
                        "  isArrayOrTupleExpression,",
                        "} from \"../utils/index.js\";",
                        "",
                        "const angularComponentObjectExpressionPredicates = [",
                        "  (node, name) => node.type === \"ObjectExpression\" && name === \"properties\",",
                        "  (node, name) =>",
                        "    node.type === \"CallExpression\" &&",
                        "    node.callee.type === \"Identifier\" &&",
                        "    node.callee.name === \"Component\" &&",
                        "    name === \"arguments\",",
                        "  (node, name) => node.type === \"Decorator\" && name === \"expression\",",
                        "];",
                        "",
                        "/**",
                        " * Angular Components can have:",
                        " * - Inline HTML template",
                        " * - Inline CSS styles",
                        " *",
                        " * ...which are both within template literals somewhere",
                        " * inside of the Component decorator factory.",
                        " *",
                        " * E.g.",
                        " * @Component({",
                        " *  template: `<div>...</div>`,",
                        " *  styles: [`h1 { color: blue; }`]",
                        " * })",
                        " */",
                        "function isAngularComponentStyles(path) {",
                        "  return path.match(",
                        "    (node) => node.type === \"TemplateLiteral\",",
                        "    (node, name) => isArrayOrTupleExpression(node) && name === \"elements\",",
                        "    (node, name) =>",
                        "      isObjectProperty(node) &&",
                        "      node.key.type === \"Identifier\" &&",
                        "      node.key.name === \"styles\" &&",
                        "      name === \"value\",",
                        "    ...angularComponentObjectExpressionPredicates",
                        "  );",
                        "}",
                        "function isAngularComponentTemplate(path) {",
                        "  return path.match(",
                        "    (node) => node.type === \"TemplateLiteral\",",
                        "    (node, name) =>",
                        "      isObjectProperty(node) &&",
                        "      node.key.type === \"Identifier\" &&",
                        "      node.key.name === \"template\" &&",
                        "      name === \"value\",",
                        "    ...angularComponentObjectExpressionPredicates",
                        "  );",
                        "}",
                        "",
                        "function hasLanguageComment(node, languageName) {",
                        "  // This checks for a leading comment that is exactly `/* GraphQL */`",
                        "  // In order to be in line with other implementations of this comment tag",
                        "  // we will not trim the comment value and we will expect exactly one space on",
                        "  // either side of the GraphQL string",
                        "  // Also see ./clean.js",
                        "  return hasComment(",
                        "    node,",
                        "    CommentCheckFlags.Block | CommentCheckFlags.Leading,",
                        "    ({ value }) => value === ` ${languageName} `",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  isAngularComponentStyles,",
                        "  isAngularComponentTemplate,",
                        "  hasLanguageComment,",
                        "};"
                    ]
                }
            },
            "parse": {
                "acorn.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { createRequire } from \"node:module\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import getSourceType from \"./utils/get-source-type.js\";",
                        "",
                        "const require = createRequire(import.meta.url);",
                        "",
                        "/** @type {import(\"acorn\").Options} */",
                        "const parseOptions = {",
                        "  ecmaVersion: \"latest\",",
                        "  // sourceType: \"module\",",
                        "  allowReturnOutsideFunction: true,",
                        "  // allowImportExportEverywhere: true,",
                        "  allowSuperOutsideMethod: true,",
                        "  locations: true,",
                        "  ranges: true,",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, loc } = error;",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (!loc) {",
                        "    return error;",
                        "  }",
                        "",
                        "  const { line, column } = loc;",
                        "",
                        "  return createError(message.replace(/ \\(\\d+:\\d+\\)$/, \"\"), {",
                        "    loc: {",
                        "      start: { line, column: column + 1 },",
                        "    },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "let parser;",
                        "const getParser = () => {",
                        "  if (!parser) {",
                        "    const { Parser: AcornParser } = require(\"acorn\");",
                        "    const acornJsx = require(\"acorn-jsx\");",
                        "    parser = AcornParser.extend(acornJsx());",
                        "  }",
                        "  return parser;",
                        "};",
                        "",
                        "function parseWithOptions(text, sourceType) {",
                        "  const parser = getParser();",
                        "",
                        "  const comments = [];",
                        "  const tokens = [];",
                        "",
                        "  /** @type {any} */",
                        "  const ast = parser.parse(text, {",
                        "    ...parseOptions,",
                        "    sourceType,",
                        "    allowImportExportEverywhere: sourceType === \"module\",",
                        "    onComment: comments,",
                        "    onToken: tokens,",
                        "  });",
                        "  ast.comments = comments;",
                        "  ast.tokens = tokens;",
                        "",
                        "  return ast;",
                        "}",
                        "",
                        "function parse(text, options = {}) {",
                        "  const sourceType = getSourceType(options);",
                        "  const combinations = (sourceType ? [sourceType] : [\"module\", \"script\"]).map(",
                        "    (sourceType) => () => parseWithOptions(text, sourceType)",
                        "  );",
                        "",
                        "  let ast;",
                        "  try {",
                        "    ast = tryCombinations(combinations);",
                        "  } catch ({ errors: [error] }) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  return postprocess(ast, { text });",
                        "}",
                        "",
                        "export const acorn = createParser(parse);"
                    ]
                },
                "angular.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  parseAction,",
                        "  parseBinding,",
                        "  parseInterpolationExpression,",
                        "  parseTemplateBindings,",
                        "} from \"angular-estree-parser\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "",
                        "/**",
                        " * @param {parseAction | parseBinding | parseInterpolationExpression | parseTemplateBindings} parseMethod",
                        " */",
                        "function createParser(parseMethod) {",
                        "  return {",
                        "    astFormat: \"estree\",",
                        "    parse(text) {",
                        "      const node = parseMethod(text);",
                        "",
                        "      return {",
                        "        type: \"NGRoot\",",
                        "        node:",
                        "          parseMethod === parseAction && node.type !== \"NGChainedExpression\"",
                        "            ? { ...node, type: \"NGChainedExpression\", expressions: [node] }",
                        "            : node,",
                        "      };",
                        "    },",
                        "    locStart,",
                        "    locEnd,",
                        "  };",
                        "}",
                        "",
                        "export const __ng_action = createParser(parseAction);",
                        "export const __ng_binding = createParser(parseBinding);",
                        "export const __ng_interpolation = createParser(parseInterpolationExpression);",
                        "export const __ng_directive = createParser(parseTemplateBindings);"
                    ]
                },
                "babel.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { parse as babelParse, parseExpression } from \"@babel/parser\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import getShebang from \"../utils/get-shebang.js\";",
                        "import getNextNonSpaceNonCommentCharacterIndex from \"../../utils/get-next-non-space-non-comment-character-index.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import createBabelParseError from \"./utils/create-babel-parse-error.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import getSourceType from \"./utils/get-source-type.js\";",
                        "import wrapBabelExpression from \"./utils/wrap-babel-expression.js\";",
                        "",
                        "const createBabelParser = (options) => createParser(createParse(options));",
                        "",
                        "/**",
                        " * @typedef {import(\"@babel/parser\").parse | import(\"@babel/parser\").parseExpression} Parse",
                        " * @typedef {import(\"@babel/parser\").ParserOptions} ParserOptions",
                        " * @typedef {import(\"@babel/parser\").ParserPlugin} ParserPlugin",
                        " */",
                        "",
                        "/** @type {ParserOptions} */",
                        "const parseOptions = {",
                        "  sourceType: \"module\",",
                        "  allowImportExportEverywhere: true,",
                        "  allowReturnOutsideFunction: true,",
                        "  allowNewTargetOutsideFunction: true,",
                        "  allowSuperOutsideMethod: true,",
                        "  allowUndeclaredExports: true,",
                        "  errorRecovery: true,",
                        "  createParenthesizedExpressions: true,",
                        "  plugins: [",
                        "    // When adding a plugin, please add a test in `tests/format/js/babel-plugins`,",
                        "    // To remove plugins, remove it here and run `yarn test tests/format/js/babel-plugins` to verify",
                        "    \"doExpressions\",",
                        "    \"exportDefaultFrom\",",
                        "    \"functionBind\",",
                        "    \"functionSent\",",
                        "    \"throwExpressions\",",
                        "    \"partialApplication\",",
                        "    \"decorators\",",
                        "    \"importAssertions\",",
                        "    \"decimal\",",
                        "    \"moduleBlocks\",",
                        "    \"asyncDoExpressions\",",
                        "    \"regexpUnicodeSets\",",
                        "    \"destructuringPrivate\",",
                        "    \"decoratorAutoAccessors\",",
                        "    \"importReflection\",",
                        "    \"explicitResourceManagement\",",
                        "  ],",
                        "  tokens: true,",
                        "  ranges: true,",
                        "};",
                        "",
                        "/** @type {ParserPlugin} */",
                        "const recordAndTuplePlugin = [\"recordAndTuple\", { syntaxType: \"hash\" }];",
                        "",
                        "/** @type {ParserPlugin} */",
                        "const v8intrinsicPlugin = \"v8intrinsic\";",
                        "",
                        "/** @type {Array<ParserPlugin>} */",
                        "const pipelineOperatorPlugins = [",
                        "  [\"pipelineOperator\", { proposal: \"hack\", topicToken: \"%\" }],",
                        "  [\"pipelineOperator\", { proposal: \"minimal\" }],",
                        "  [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                        "];",
                        "const appendPlugins = (plugins, options = parseOptions) => ({",
                        "  ...options,",
                        "  plugins: [...options.plugins, ...plugins],",
                        "});",
                        "",
                        "// Similar to babel",
                        "// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67",
                        "const FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;",
                        "function isFlowFile(text, options) {",
                        "  if (options.filepath?.endsWith(\".js.flow\")) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const shebang = getShebang(text);",
                        "  if (shebang) {",
                        "    text = text.slice(shebang.length);",
                        "  }",
                        "",
                        "  const firstNonSpaceNonCommentCharacterIndex =",
                        "    getNextNonSpaceNonCommentCharacterIndex(text, 0);",
                        "",
                        "  if (firstNonSpaceNonCommentCharacterIndex !== false) {",
                        "    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);",
                        "  }",
                        "",
                        "  return FLOW_PRAGMA_REGEX.test(text);",
                        "}",
                        "",
                        "function parseWithOptions(parse, text, options) {",
                        "  const ast = parse(text, options);",
                        "  const error = ast.errors.find(",
                        "    (error) => !allowedMessageCodes.has(error.reasonCode)",
                        "  );",
                        "  if (error) {",
                        "    throw error;",
                        "  }",
                        "  return ast;",
                        "}",
                        "",
                        "function createParse({ isExpression = false, optionsCombinations }) {",
                        "  return (text, options = {}) => {",
                        "    if (",
                        "      (options.parser === \"babel\" || options.parser === \"__babel_estree\") &&",
                        "      isFlowFile(text, options)",
                        "    ) {",
                        "      options.parser = \"babel-flow\";",
                        "      return babelFlow.parse(text, options);",
                        "    }",
                        "",
                        "    let combinations = optionsCombinations;",
                        "    const sourceType = options.__babelSourceType ?? getSourceType(options);",
                        "    if (sourceType === \"script\") {",
                        "      combinations = combinations.map((options) => ({",
                        "        ...options,",
                        "        sourceType: \"script\",",
                        "      }));",
                        "    }",
                        "",
                        "    if (/#[[{]/.test(text)) {",
                        "      combinations = combinations.map((options) =>",
                        "        appendPlugins([recordAndTuplePlugin], options)",
                        "      );",
                        "    }",
                        "",
                        "    const shouldEnableV8intrinsicPlugin = /%[A-Z]/.test(text);",
                        "    if (text.includes(\"|>\")) {",
                        "      const conflictsPlugins = shouldEnableV8intrinsicPlugin",
                        "        ? [...pipelineOperatorPlugins, v8intrinsicPlugin]",
                        "        : pipelineOperatorPlugins;",
                        "      combinations = conflictsPlugins.flatMap((pipelineOperatorPlugin) =>",
                        "        combinations.map((options) =>",
                        "          appendPlugins([pipelineOperatorPlugin], options)",
                        "        )",
                        "      );",
                        "    } else if (shouldEnableV8intrinsicPlugin) {",
                        "      combinations = combinations.map((options) =>",
                        "        appendPlugins([v8intrinsicPlugin], options)",
                        "      );",
                        "    }",
                        "",
                        "    /** @type {Parse} */",
                        "    const parseFunction = isExpression ? parseExpression : babelParse;",
                        "",
                        "    let ast;",
                        "    try {",
                        "      ast = tryCombinations(",
                        "        combinations.map(",
                        "          (options) => () => parseWithOptions(parseFunction, text, options)",
                        "        )",
                        "      );",
                        "    } catch ({ errors: [error] }) {",
                        "      throw createBabelParseError(error);",
                        "    }",
                        "",
                        "    if (isExpression) {",
                        "      ast = wrapBabelExpression(ast, { text, rootMarker: options.rootMarker });",
                        "    }",
                        "",
                        "    return postprocess(ast, { parser: \"babel\", text });",
                        "  };",
                        "}",
                        "",
                        "// Error codes are defined in",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/parser/error-message.js",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/typescript/index.js#L69-L153",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/flow/index.js#L51-L140",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/jsx/index.js#L23-L39",
                        "const allowedMessageCodes = new Set([",
                        "  \"StrictNumericEscape\",",
                        "  \"StrictWith\",",
                        "  \"StrictOctalLiteral\",",
                        "  \"StrictDelete\",",
                        "  \"StrictEvalArguments\",",
                        "  \"StrictEvalArgumentsBinding\",",
                        "  \"StrictFunction\",",
                        "",
                        "  \"EmptyTypeArguments\",",
                        "  \"EmptyTypeParameters\",",
                        "  \"ConstructorHasTypeParameters\",",
                        "",
                        "  \"UnsupportedParameterPropertyKind\",",
                        "",
                        "  \"MixedLabeledAndUnlabeledElements\",",
                        "",
                        "  \"DuplicateAccessibilityModifier\",",
                        "",
                        "  \"DecoratorExportClass\",",
                        "  \"ParamDupe\",",
                        "  \"InvalidDecimal\",",
                        "  \"RestTrailingComma\",",
                        "  \"UnsupportedParameterDecorator\",",
                        "  \"UnterminatedJsxContent\",",
                        "  \"UnexpectedReservedWord\",",
                        "  \"ModuleAttributesWithDuplicateKeys\",",
                        "  \"LineTerminatorBeforeArrow\",",
                        "  \"InvalidEscapeSequenceTemplate\",",
                        "  \"NonAbstractClassHasAbstractMethod\",",
                        "  \"OptionalTypeBeforeRequired\",",
                        "  \"PatternIsOptional\",",
                        "  \"OptionalBindingPattern\",",
                        "  \"DeclareClassFieldHasInitializer\",",
                        "  \"TypeImportCannotSpecifyDefaultAndNamed\",",
                        "  \"DeclareFunctionHasImplementation\",",
                        "  \"ConstructorClassField\",",
                        "",
                        "  \"VarRedeclaration\",",
                        "  \"InvalidPrivateFieldResolution\",",
                        "  \"DuplicateExport\",",
                        "]);",
                        "",
                        "const babelParserOptionsCombinations = [appendPlugins([\"jsx\"])];",
                        "const babel = createBabelParser({",
                        "  optionsCombinations: babelParserOptionsCombinations,",
                        "});",
                        "const babelTs = createBabelParser({",
                        "  optionsCombinations: [",
                        "    appendPlugins([\"jsx\", \"typescript\"]),",
                        "    appendPlugins([\"typescript\"]),",
                        "  ],",
                        "});",
                        "const babelExpression = createBabelParser({",
                        "  isExpression: true,",
                        "  optionsCombinations: [appendPlugins([\"jsx\"])],",
                        "});",
                        "const babelTSExpression = createBabelParser({",
                        "  isExpression: true,",
                        "  optionsCombinations: [appendPlugins([\"typescript\"])],",
                        "});",
                        "const babelFlow = createBabelParser({",
                        "  optionsCombinations: [",
                        "    appendPlugins([",
                        "      \"jsx\",",
                        "      [\"flow\", { all: true, enums: true }],",
                        "      \"flowComments\",",
                        "    ]),",
                        "  ],",
                        "});",
                        "const babelEstree = createBabelParser({",
                        "  optionsCombinations: babelParserOptionsCombinations.map((options) =>",
                        "    appendPlugins([\"estree\"], options)",
                        "  ),",
                        "});",
                        "",
                        "export default {",
                        "  babel,",
                        "  \"babel-flow\": babelFlow,",
                        "  \"babel-ts\": babelTs,",
                        "  /** @internal */",
                        "  __js_expression: babelExpression,",
                        "  __ts_expression: babelTSExpression,",
                        "  /** for vue filter */",
                        "  __vue_expression: babelExpression,",
                        "  /** for vue filter written in TS */",
                        "  __vue_ts_expression: babelTSExpression,",
                        "  /** for vue event binding to handle semicolon */",
                        "  __vue_event_binding: babel,",
                        "  /** for vue event binding written in TS to handle semicolon */",
                        "  __vue_ts_event_binding: babelTs,",
                        "  /** verify that we can print this AST */",
                        "  __babel_estree: babelEstree,",
                        "};"
                    ]
                },
                "espree.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { createRequire } from \"node:module\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import getSourceType from \"./utils/get-source-type.js\";",
                        "",
                        "const require = createRequire(import.meta.url);",
                        "",
                        "/** @type {import(\"espree\").Options} */",
                        "const parseOptions = {",
                        "  ecmaVersion: \"latest\",",
                        "  range: true,",
                        "  loc: true,",
                        "  comment: true,",
                        "  tokens: true,",
                        "  sourceType: \"module\",",
                        "  ecmaFeatures: {",
                        "    jsx: true,",
                        "    globalReturn: true,",
                        "    impliedStrict: false,",
                        "  },",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, lineNumber, column } = error;",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (typeof lineNumber !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, {",
                        "    loc: { start: { line: lineNumber, column } },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "function parse(text, options = {}) {",
                        "  const { parse: espreeParse } = require(\"espree\");",
                        "",
                        "  const sourceType = getSourceType(options);",
                        "  const combinations = (sourceType ? [sourceType] : [\"module\", \"script\"]).map(",
                        "    (/** @type {\"module\"|\"script\"} */ sourceType) => () =>",
                        "      espreeParse(text, { ...parseOptions, sourceType })",
                        "  );",
                        "",
                        "  let ast;",
                        "  try {",
                        "    ast = tryCombinations(combinations);",
                        "  } catch ({ errors: [error] }) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  return postprocess(ast, { text });",
                        "}",
                        "",
                        "export const espree = createParser(parse);"
                    ]
                },
                "flow.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import flowParser from \"flow-parser\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import replaceHashbang from \"./utils/replace-hashbang.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "",
                        "// https://github.com/facebook/flow/tree/main/packages/flow-parser#options",
                        "// Keep this sync with `/scripts/sync-flow-test.js`",
                        "const parseOptions = {",
                        "  // `all_comments` (boolean, default `true`) - include a list of all comments from the whole program",
                        "  // all_comments: true,",
                        "  // `comments` (boolean, default `true`) - attach comments to AST nodes (`leadingComments` and `trailingComments`)",
                        "  comments: false,",
                        "  // `enums` (boolean, default `false`) - enable parsing of Flow enums",
                        "  enums: true,",
                        "  // `esproposal_decorators` (boolean, default `false`) - enable parsing of decorators",
                        "  esproposal_decorators: true,",
                        "  // `esproposal_export_star_as` (boolean, default `false`) - enable parsing of `export * as` syntax",
                        "  esproposal_export_star_as: true,",
                        "  // `types` (boolean, default `true`) - enable parsing of Flow types",
                        "  // types: true,",
                        "  // `use_strict` (boolean, default `false`) - treat the file as strict, without needing a \"use strict\" directive",
                        "  // use_strict: false,",
                        "  // `tokens` (boolean, default `false`) - include a list of all parsed tokens in a top-level `tokens` property",
                        "  tokens: true,",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const {",
                        "    message,",
                        "    loc: { start, end },",
                        "  } = error;",
                        "",
                        "  return createError(message, {",
                        "    loc: {",
                        "      start: { line: start.line, column: start.column + 1 },",
                        "      end: { line: end.line, column: end.column + 1 },",
                        "    },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "function parse(text) {",
                        "  const ast = flowParser.parse(replaceHashbang(text), parseOptions);",
                        "  const [error] = ast.errors;",
                        "  if (error) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  return postprocess(ast, { text });",
                        "}",
                        "",
                        "export const flow = createParser(parse);"
                    ]
                },
                "meriyah.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { parse as meriyahParse } from \"meriyah\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import getSourceType from \"./utils/get-source-type.js\";",
                        "",
                        "// https://github.com/meriyah/meriyah/blob/4676f60b6c149d7082bde2c9147f9ae2359c8075/src/parser.ts#L185",
                        "const parseOptions = {",
                        "  // Allow module code",
                        "  // module: true,",
                        "  // Enable stage 3 support (ESNext)",
                        "  next: true,",
                        "  // Enable start and end offsets to each node",
                        "  ranges: true,",
                        "  // Enable web compatibility",
                        "  webcompat: true,",
                        "  // Enable line/column location information to each node",
                        "  loc: true,",
                        "  // Attach raw property to each literal and identifier node",
                        "  raw: true,",
                        "  // Enabled directives",
                        "  directives: true,",
                        "  // Allow return in the global scope",
                        "  globalReturn: true,",
                        "  // Enable implied strict mode",
                        "  impliedStrict: false,",
                        "  // Enable non-standard parenthesized expression node",
                        "  preserveParens: false,",
                        "  // Enable lexical binding and scope tracking",
                        "  lexical: false,",
                        "  // Adds a source attribute in every node’s loc object when the locations option is `true`",
                        "  // source: '',",
                        "  // Distinguish Identifier from IdentifierPattern",
                        "  identifierPattern: false,",
                        "  // Enable React JSX parsing",
                        "  jsx: true,",
                        "  // Allow edge cases that deviate from the spec",
                        "  specDeviation: true,",
                        "  // Creates unique key for in ObjectPattern when key value are same",
                        "  uniqueKeyInPattern: false,",
                        "};",
                        "",
                        "function parseWithOptions(text, sourceType) {",
                        "  const comments = [];",
                        "  const tokens = [];",
                        "",
                        "  /** @type {any} */",
                        "  const ast = meriyahParse(text, {",
                        "    ...parseOptions,",
                        "    module: sourceType === \"module\",",
                        "    onComment: comments,",
                        "    onToken: tokens,",
                        "  });",
                        "  ast.comments = comments;",
                        "  ast.tokens = tokens;",
                        "",
                        "  return ast;",
                        "}",
                        "",
                        "function createParseError(error) {",
                        "  let { message, line, column } = error;",
                        "",
                        "  const matches = message.match(",
                        "    /^\\[(?<line>\\d+):(?<column>\\d+)]: (?<message>.*)$/",
                        "  )?.groups;",
                        "",
                        "  if (matches) {",
                        "    message = matches.message;",
                        "",
                        "    /* c8 ignore next 4 */",
                        "    if (typeof line !== \"number\") {",
                        "      line = Number(matches.line);",
                        "      column = Number(matches.column);",
                        "    }",
                        "  }",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (typeof line !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, {",
                        "    loc: { start: { line, column } },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "function parse(text, options = {}) {",
                        "  const sourceType = getSourceType(options);",
                        "  const combinations = (sourceType ? [sourceType] : [\"module\", \"script\"]).map(",
                        "    (sourceType) => () => parseWithOptions(text, sourceType)",
                        "  );",
                        "",
                        "  let ast;",
                        "  try {",
                        "    ast = tryCombinations(combinations);",
                        "  } catch ({ errors: [error] }) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  return postprocess(ast, { parser: \"meriyah\", text });",
                        "}",
                        "",
                        "export const meriyah = createParser(parse);"
                    ]
                },
                "typescript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { parseWithNodeMaps } from \"@typescript-eslint/typescript-estree/dist/parser.js\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import replaceHashbang from \"./utils/replace-hashbang.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import { throwErrorForInvalidNodes } from \"./postprocess/typescript.js\";",
                        "",
                        "/** @type {import(\"@typescript-eslint/typescript-estree\").TSESTreeOptions} */",
                        "const parseOptions = {",
                        "  // `jest@<=26.4.2` rely on `loc`",
                        "  // https://github.com/facebook/jest/issues/10444",
                        "  // Set `loc` and `range` to `true` also prevent AST traverse",
                        "  // https://github.com/typescript-eslint/typescript-eslint/blob/733b3598c17d3a712cf6f043115587f724dbe3ef/packages/typescript-estree/src/ast-converter.ts#L38",
                        "  loc: true,",
                        "  range: true,",
                        "  comment: true,",
                        "  jsx: true,",
                        "  tokens: true,",
                        "  loggerFn: false,",
                        "  project: [],",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, lineNumber, column } = error;",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (typeof lineNumber !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, {",
                        "    loc: {",
                        "      start: { line: lineNumber, column: column + 1 },",
                        "    },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "function parse(text) {",
                        "  const textToParse = replaceHashbang(text);",
                        "  const jsx = isProbablyJsx(text);",
                        "",
                        "  let result;",
                        "  try {",
                        "    result = tryCombinations([",
                        "      // Try passing with our best guess first.",
                        "      () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx }),",
                        "      // But if we get it wrong, try the opposite.",
                        "      () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx: !jsx }),",
                        "    ]);",
                        "  } catch ({",
                        "    errors: [",
                        "      // Suppose our guess is correct, throw the first error",
                        "      error,",
                        "    ],",
                        "  }) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  throwErrorForInvalidNodes(result, text);",
                        "",
                        "  return postprocess(result.ast, { parser: \"typescript\", text });",
                        "}",
                        "",
                        "/**",
                        " * Use a naive regular expression to detect JSX",
                        " */",
                        "function isProbablyJsx(text) {",
                        "  return new RegExp(",
                        "    [",
                        "      \"(?:^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string",
                        "      \"|\",",
                        "      \"(?:^[^/]{2}.*/>)\", // Contains \"/>\" on line not starting with \"//\"",
                        "    ].join(\"\"),",
                        "    \"m\"",
                        "  ).test(text);",
                        "}",
                        "",
                        "export const typescript = createParser(parse);"
                    ]
                },
                "postprocess": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { locStart, locEnd } from \"../../loc.js\";",
                            "import isTypeCastComment from \"../../utils/is-type-cast-comment.js\";",
                            "import isNonEmptyArray from \"../../../utils/is-non-empty-array.js\";",
                            "import isBlockComment from \"../../utils/is-block-comment.js\";",
                            "import isIndentableBlockComment from \"../../utils/is-indentable-block-comment.js\";",
                            "import visitNode from \"./visit-node.js\";",
                            "import throwSyntaxError from \"./throw-ts-syntax-error.js\";",
                            "",
                            "/**",
                            " * @param {{",
                            " *   text: string,",
                            " *   parser?: string,",
                            " * }} options",
                            " */",
                            "function postprocess(ast, options) {",
                            "  const { parser, text } = options;",
                            "",
                            "  // `InterpreterDirective` from babel parser",
                            "  // Other parsers parse it as comment, babel treat it as comment too",
                            "  // https://github.com/babel/babel/issues/15116",
                            "  if (ast.type === \"File\" && ast.program.interpreter) {",
                            "    const {",
                            "      program: { interpreter },",
                            "      comments,",
                            "    } = ast;",
                            "    delete ast.program.interpreter;",
                            "    comments.unshift(interpreter);",
                            "  }",
                            "",
                            "  // Keep Babel's non-standard ParenthesizedExpression nodes only if they have Closure-style type cast comments.",
                            "  if (parser === \"babel\") {",
                            "    const startOffsetsOfTypeCastedNodes = new Set();",
                            "",
                            "    // Comments might be attached not directly to ParenthesizedExpression but to its ancestor.",
                            "    // E.g.: /** @type {Foo} */ (foo).bar();",
                            "    // Let's use the fact that those ancestors and ParenthesizedExpression have the same start offset.",
                            "",
                            "    ast = visitNode(ast, (node) => {",
                            "      if (node.leadingComments?.some(isTypeCastComment)) {",
                            "        startOffsetsOfTypeCastedNodes.add(locStart(node));",
                            "      }",
                            "    });",
                            "",
                            "    ast = visitNode(ast, (node) => {",
                            "      if (node.type === \"ParenthesizedExpression\") {",
                            "        const { expression } = node;",
                            "",
                            "        // Align range with `flow`",
                            "        if (expression.type === \"TypeCastExpression\") {",
                            "          expression.range = node.range;",
                            "          return expression;",
                            "        }",
                            "",
                            "        const start = locStart(node);",
                            "        if (!startOffsetsOfTypeCastedNodes.has(start)) {",
                            "          expression.extra = { ...expression.extra, parenthesized: true };",
                            "          return expression;",
                            "        }",
                            "      }",
                            "    });",
                            "  }",
                            "",
                            "  ast = visitNode(ast, (node) => {",
                            "    switch (node.type) {",
                            "      case \"LogicalExpression\":",
                            "        // We remove unneeded parens around same-operator LogicalExpressions",
                            "        if (isUnbalancedLogicalTree(node)) {",
                            "          return rebalanceLogicalTree(node);",
                            "        }",
                            "        break;",
                            "",
                            "      // fix unexpected locEnd caused by --no-semi style",
                            "      case \"VariableDeclaration\": {",
                            "        const lastDeclaration = node.declarations.at(-1);",
                            "        if (lastDeclaration?.init) {",
                            "          overrideLocEnd(node, lastDeclaration);",
                            "        }",
                            "        break;",
                            "      }",
                            "      // remove redundant TypeScript nodes",
                            "      case \"TSParenthesizedType\":",
                            "        return node.typeAnnotation;",
                            "",
                            "      case \"TSTypeParameter\":",
                            "        // babel-ts",
                            "        if (typeof node.name === \"string\") {",
                            "          const start = locStart(node);",
                            "          node.name = {",
                            "            type: \"Identifier\",",
                            "            name: node.name,",
                            "            range: [start, start + node.name.length],",
                            "          };",
                            "        }",
                            "        break;",
                            "      case \"ObjectExpression\":",
                            "        // #12963",
                            "        if (parser === \"typescript\") {",
                            "          const invalidProperty = node.properties.find(",
                            "            (property) =>",
                            "              property.type === \"Property\" &&",
                            "              property.value.type === \"TSEmptyBodyFunctionExpression\"",
                            "          );",
                            "          if (invalidProperty) {",
                            "            throwSyntaxError(invalidProperty.value, \"Unexpected token.\");",
                            "          }",
                            "        }",
                            "        break;",
                            "      case \"TSInterfaceDeclaration\":",
                            "        if (isNonEmptyArray(node.implements)) {",
                            "          throwSyntaxError(",
                            "            node.implements[0],",
                            "            \"Interface declaration cannot have 'implements' clause.\"",
                            "          );",
                            "        }",
                            "        break;",
                            "",
                            "      case \"TSPropertySignature\":",
                            "        if (node.initializer) {",
                            "          throwSyntaxError(",
                            "            node.initializer,",
                            "            \"An interface property cannot have an initializer.\"",
                            "          );",
                            "        }",
                            "        break;",
                            "",
                            "      // For hack-style pipeline",
                            "      case \"TopicReference\":",
                            "        ast.extra = { ...ast.extra, __isUsingHackPipeline: true };",
                            "        break;",
                            "",
                            "      // TODO: Remove this when https://github.com/meriyah/meriyah/issues/200 get fixed",
                            "      case \"ExportAllDeclaration\": {",
                            "        const { exported } = node;",
                            "        if (parser === \"meriyah\" && exported?.type === \"Identifier\") {",
                            "          const raw = text.slice(locStart(exported), locEnd(exported));",
                            "          if (raw.startsWith('\"') || raw.startsWith(\"'\")) {",
                            "            node.exported = {",
                            "              ...node.exported,",
                            "              type: \"Literal\",",
                            "              value: node.exported.name,",
                            "              raw,",
                            "            };",
                            "          }",
                            "        }",
                            "        break;",
                            "      }",
                            "      // In Flow parser, it doesn't generate union/intersection types for single type",
                            "      case \"TSUnionType\":",
                            "      case \"TSIntersectionType\":",
                            "        if (node.types.length === 1) {",
                            "          return node.types[0];",
                            "        }",
                            "        break;",
                            "    }",
                            "  });",
                            "",
                            "  if (isNonEmptyArray(ast.comments)) {",
                            "    let followingComment = ast.comments.at(-1);",
                            "    for (let i = ast.comments.length - 2; i >= 0; i--) {",
                            "      const comment = ast.comments[i];",
                            "      if (",
                            "        locEnd(comment) === locStart(followingComment) &&",
                            "        isBlockComment(comment) &&",
                            "        isBlockComment(followingComment) &&",
                            "        isIndentableBlockComment(comment) &&",
                            "        isIndentableBlockComment(followingComment)",
                            "      ) {",
                            "        ast.comments.splice(i + 1, 1);",
                            "        comment.value += \"*//*\" + followingComment.value;",
                            "        comment.range = [locStart(comment), locEnd(followingComment)];",
                            "      }",
                            "      followingComment = comment;",
                            "    }",
                            "  }",
                            "",
                            "  // In `typescript`/`espree`/`flow`, `Program` doesn't count whitespace and comments",
                            "  // See https://github.com/eslint/espree/issues/488",
                            "  if (ast.type === \"Program\") {",
                            "    ast.range = [0, text.length];",
                            "  }",
                            "  return ast;",
                            "",
                            "  /**",
                            "   * - `toOverrideNode` must be the last thing in `toBeOverriddenNode`",
                            "   * - do nothing if there's a semicolon on `toOverrideNode.end` (no need to fix)",
                            "   */",
                            "  function overrideLocEnd(toBeOverriddenNode, toOverrideNode) {",
                            "    if (text[locEnd(toOverrideNode)] === \";\") {",
                            "      return;",
                            "    }",
                            "    toBeOverriddenNode.range = [",
                            "      locStart(toBeOverriddenNode),",
                            "      locEnd(toOverrideNode),",
                            "    ];",
                            "  }",
                            "}",
                            "",
                            "function isUnbalancedLogicalTree(node) {",
                            "  return (",
                            "    node.type === \"LogicalExpression\" &&",
                            "    node.right.type === \"LogicalExpression\" &&",
                            "    node.operator === node.right.operator",
                            "  );",
                            "}",
                            "",
                            "function rebalanceLogicalTree(node) {",
                            "  if (!isUnbalancedLogicalTree(node)) {",
                            "    return node;",
                            "  }",
                            "",
                            "  return rebalanceLogicalTree({",
                            "    type: \"LogicalExpression\",",
                            "    operator: node.operator,",
                            "    left: rebalanceLogicalTree({",
                            "      type: \"LogicalExpression\",",
                            "      operator: node.operator,",
                            "      left: node.left,",
                            "      right: node.right.left,",
                            "      range: [locStart(node.left), locEnd(node.right.left)],",
                            "    }),",
                            "    right: node.right.right,",
                            "    range: [locStart(node), locEnd(node)],",
                            "  });",
                            "}",
                            "",
                            "export default postprocess;"
                        ]
                    },
                    "throw-ts-syntax-error.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import createError from \"../../../common/parser-create-error.js\";",
                            "",
                            "function throwSyntaxError(node, message) {",
                            "  const { start, end } = node.loc;",
                            "  throw createError(message, {",
                            "    loc: {",
                            "      start: { line: start.line, column: start.column + 1 },",
                            "      end: { line: end.line, column: end.column + 1 },",
                            "    },",
                            "  });",
                            "}",
                            "",
                            "export default throwSyntaxError;"
                        ]
                    },
                    "typescript.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import ts from \"typescript\";",
                            "import isNonEmptyArray from \"../../../utils/is-non-empty-array.js\";",
                            "import visitNode from \"./visit-node.js\";",
                            "import throwTsSyntaxError from \"./throw-ts-syntax-error.js\";",
                            "",
                            "function getTsNodeLocation(nodeOrToken) {",
                            "  const sourceFile =",
                            "    // @ts-expect-error -- internal?",
                            "    ts.getSourceFileOfNode(nodeOrToken);",
                            "  const position =",
                            "    // @ts-expect-error -- internal?",
                            "    ts.rangeOfNode(nodeOrToken);",
                            "  const [start, end] = [position.pos, position.end].map((position) => {",
                            "    const { line, character: column } =",
                            "      sourceFile.getLineAndCharacterOfPosition(position);",
                            "    return { line: line + 1, column };",
                            "  });",
                            "",
                            "  return { start, end };",
                            "}",
                            "",
                            "function throwErrorOnTsNode(node, message) {",
                            "  throwTsSyntaxError({ loc: getTsNodeLocation(node) }, message);",
                            "}",
                            "",
                            "// Values of abstract property is removed since `@typescript-eslint/typescript-estree` v5",
                            "// https://github.com/typescript-eslint/typescript-eslint/releases/tag/v5.0.0",
                            "function throwErrorForInvalidAbstractProperty(tsNode, esTreeNode) {",
                            "  if (",
                            "    !(",
                            "      tsNode.kind === ts.SyntaxKind.PropertyDeclaration &&",
                            "      tsNode.initializer &&",
                            "      esTreeNode.value === null &&",
                            "      tsNode.modifiers?.some(",
                            "        (modifier) => modifier.kind === ts.SyntaxKind.AbstractKeyword",
                            "      )",
                            "    )",
                            "  ) {",
                            "    return;",
                            "  }",
                            "",
                            "  throwTsSyntaxError(",
                            "    esTreeNode,",
                            "    \"Abstract property cannot have an initializer\"",
                            "  );",
                            "}",
                            "",
                            "function nodeCanBeDecorated(node) {",
                            "  return [true, false].some((useLegacyDecorators) =>",
                            "    // @ts-expect-error -- internal?",
                            "    ts.nodeCanBeDecorated(",
                            "      useLegacyDecorators,",
                            "      node,",
                            "      node.parent,",
                            "      node.parent.parent",
                            "    )",
                            "  );",
                            "}",
                            "",
                            "// Based on `checkGrammarModifiers` function in `typescript`",
                            "function throwErrorForInvalidModifier(node) {",
                            "  const { modifiers } = node;",
                            "  if (!isNonEmptyArray(modifiers)) {",
                            "    return;",
                            "  }",
                            "",
                            "  const { SyntaxKind } = ts;",
                            "",
                            "  for (const modifier of modifiers) {",
                            "    if (ts.isDecorator(modifier) && !nodeCanBeDecorated(node)) {",
                            "      if (",
                            "        node.kind === SyntaxKind.MethodDeclaration &&",
                            "        // @ts-expect-error -- internal?",
                            "        !ts.nodeIsPresent(node.body)",
                            "      ) {",
                            "        throwErrorOnTsNode(",
                            "          modifier,",
                            "          \"A decorator can only decorate a method implementation, not an overload.\"",
                            "        );",
                            "      }",
                            "",
                            "      throwErrorOnTsNode(modifier, \"Decorators are not valid here.\");",
                            "    }",
                            "",
                            "    if (modifier.kind !== SyntaxKind.ReadonlyKeyword) {",
                            "      if (",
                            "        node.kind === SyntaxKind.PropertySignature ||",
                            "        node.kind === SyntaxKind.MethodSignature",
                            "      ) {",
                            "        throwErrorOnTsNode(",
                            "          modifier,",
                            "          `'${ts.tokenToString(",
                            "            modifier.kind",
                            "          )}' modifier cannot appear on a type member`",
                            "        );",
                            "      }",
                            "",
                            "      if (",
                            "        node.kind === SyntaxKind.IndexSignature &&",
                            "        (modifier.kind !== SyntaxKind.StaticKeyword ||",
                            "          !ts.isClassLike(node.parent))",
                            "      ) {",
                            "        throwErrorOnTsNode(",
                            "          modifier,",
                            "          `'${ts.tokenToString(",
                            "            modifier.kind",
                            "          )}' modifier cannot appear on an index signature`",
                            "        );",
                            "      }",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind !== SyntaxKind.InKeyword &&",
                            "      modifier.kind !== SyntaxKind.OutKeyword &&",
                            "      modifier.kind !== SyntaxKind.ConstKeyword &&",
                            "      node.kind === SyntaxKind.TypeParameter",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier cannot appear on a type parameter`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      (modifier.kind === SyntaxKind.InKeyword ||",
                            "        modifier.kind === SyntaxKind.OutKeyword) &&",
                            "      (node.kind !== SyntaxKind.TypeParameter ||",
                            "        !(",
                            "          ts.isInterfaceDeclaration(node.parent) ||",
                            "          ts.isClassLike(node.parent) ||",
                            "          ts.isTypeAliasDeclaration(node.parent)",
                            "        ))",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier can only appear on a type parameter of a class, interface or type alias`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind === SyntaxKind.ReadonlyKeyword &&",
                            "      node.kind !== SyntaxKind.PropertyDeclaration &&",
                            "      node.kind !== SyntaxKind.PropertySignature &&",
                            "      node.kind !== SyntaxKind.IndexSignature &&",
                            "      node.kind !== SyntaxKind.Parameter",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        \"'readonly' modifier can only appear on a property declaration or index signature.\"",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind === SyntaxKind.DeclareKeyword &&",
                            "      ts.isClassLike(node.parent) &&",
                            "      !ts.isPropertyDeclaration(node)",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier cannot appear on class elements of this kind.`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind === SyntaxKind.AbstractKeyword &&",
                            "      node.kind !== SyntaxKind.ClassDeclaration &&",
                            "      node.kind !== SyntaxKind.ConstructorType &&",
                            "      node.kind !== SyntaxKind.MethodDeclaration &&",
                            "      node.kind !== SyntaxKind.PropertyDeclaration &&",
                            "      node.kind !== SyntaxKind.GetAccessor &&",
                            "      node.kind !== SyntaxKind.SetAccessor",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier can only appear on a class, method, or property declaration.`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      (modifier.kind === SyntaxKind.StaticKeyword ||",
                            "        modifier.kind === SyntaxKind.PublicKeyword ||",
                            "        modifier.kind === SyntaxKind.ProtectedKeyword ||",
                            "        modifier.kind === SyntaxKind.PrivateKeyword) &&",
                            "      (node.parent.kind === SyntaxKind.ModuleBlock ||",
                            "        node.parent.kind === SyntaxKind.SourceFile)",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier cannot appear on a module or namespace element.`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind === SyntaxKind.AccessorKeyword &&",
                            "      node.kind !== SyntaxKind.PropertyDeclaration",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        \"'accessor' modifier can only appear on a property declaration.\"",
                            "      );",
                            "    }",
                            "",
                            "    // `checkGrammarAsyncModifier` function in `typescript`",
                            "    if (",
                            "      modifier.kind === SyntaxKind.AsyncKeyword &&",
                            "      node.kind !== SyntaxKind.MethodDeclaration &&",
                            "      node.kind !== SyntaxKind.FunctionDeclaration &&",
                            "      node.kind !== SyntaxKind.FunctionExpression &&",
                            "      node.kind !== SyntaxKind.ArrowFunction",
                            "    ) {",
                            "      throwErrorOnTsNode(modifier, \"'async' modifier cannot be used here.\");",
                            "    }",
                            "",
                            "    // `checkGrammarModifiers` function in `typescript`",
                            "    if (",
                            "      node.kind === SyntaxKind.Parameter &&",
                            "      (modifier.kind === SyntaxKind.StaticKeyword ||",
                            "        modifier.kind === SyntaxKind.ExportKeyword ||",
                            "        modifier.kind === SyntaxKind.DeclareKeyword ||",
                            "        modifier.kind === SyntaxKind.AsyncKeyword)",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier cannot appear on a parameter.`",
                            "      );",
                            "    }",
                            "",
                            "    // `checkParameter` function in `typescript`",
                            "    if (",
                            "      node.kind === SyntaxKind.Parameter &&",
                            "      // @ts-expect-error -- internal?",
                            "      ts.hasSyntacticModifier(node, ts.ModifierFlags.ParameterPropertyModifier)",
                            "    ) {",
                            "      const func =",
                            "        // @ts-expect-error -- internal?",
                            "        ts.getContainingFunction(node);",
                            "      if (",
                            "        !(",
                            "          func.kind === SyntaxKind.Constructor &&",
                            "          // @ts-expect-error -- internal?",
                            "          ts.nodeIsPresent(func.body)",
                            "        )",
                            "      ) {",
                            "        throwErrorOnTsNode(",
                            "          modifier,",
                            "          \"A parameter property is only allowed in a constructor implementation.\"",
                            "        );",
                            "      }",
                            "    }",
                            "  }",
                            "}",
                            "",
                            "function getTsNode(node, tsParseResult) {",
                            "  const { esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap } = tsParseResult;",
                            "  const tsNode = esTreeNodeToTSNodeMap.get(node);",
                            "  if (!tsNode) {",
                            "    return;",
                            "  }",
                            "",
                            "  const esTreeNode = tsNodeToESTreeNodeMap.get(tsNode);",
                            "  if (esTreeNode !== node) {",
                            "    return;",
                            "  }",
                            "",
                            "  return tsNode;",
                            "}",
                            "",
                            "// `isModifierKind` in `typescript`",
                            "const POSSIBLE_MODIFIERS = [",
                            "  \"abstract\",",
                            "  \"accessor\",",
                            "  \"async\",",
                            "  \"const\",",
                            "  \"declare\",",
                            "  \"default\",",
                            "  \"export\",",
                            "  \"in\",",
                            "  \"out\",",
                            "  \"override\",",
                            "  \"private\",",
                            "  \"protected\",",
                            "  \"public\",",
                            "  \"readonly\",",
                            "  \"static\",",
                            "];",
                            "",
                            "const decoratorOrModifierRegExp = new RegExp(",
                            "  [\"@\", ...POSSIBLE_MODIFIERS].join(\"|\")",
                            ");",
                            "",
                            "function throwErrorForInvalidNodes(tsParseResult, text) {",
                            "  if (!decoratorOrModifierRegExp.test(text)) {",
                            "    return;",
                            "  }",
                            "",
                            "  visitNode(tsParseResult.ast, (esTreeNode) => {",
                            "    const tsNode = getTsNode(esTreeNode, tsParseResult);",
                            "    if (!tsNode) {",
                            "      return;",
                            "    }",
                            "",
                            "    throwErrorForInvalidAbstractProperty(tsNode, esTreeNode);",
                            "    throwErrorForInvalidModifier(tsNode);",
                            "  });",
                            "}",
                            "",
                            "export {",
                            "  throwErrorForInvalidNodes,",
                            "  // For test",
                            "  POSSIBLE_MODIFIERS,",
                            "};"
                        ]
                    },
                    "visit-node.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import getVisitorKeys from \"../../traverse/get-visitor-keys.js\";",
                            "",
                            "function visitNode(node, fn) {",
                            "  if (!(node !== null && typeof node === \"object\")) {",
                            "    return node;",
                            "  }",
                            "",
                            "  if (Array.isArray(node)) {",
                            "    // As of Node.js 16 using raw for loop over Array.entries provides a",
                            "    // measurable difference in performance. Array.entries returns an iterator",
                            "    // of arrays.",
                            "    for (let i = 0; i < node.length; i++) {",
                            "      node[i] = visitNode(node[i], fn);",
                            "    }",
                            "    return node;",
                            "  }",
                            "",
                            "  const keys = getVisitorKeys(node);",
                            "  for (let i = 0; i < keys.length; i++) {",
                            "    node[keys[i]] = visitNode(node[keys[i]], fn);",
                            "  }",
                            "",
                            "  return fn(node) || node;",
                            "}",
                            "",
                            "export default visitNode;"
                        ]
                    }
                },
                "utils": {
                    "create-babel-parse-error.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import createError from \"../../../common/parser-create-error.js\";",
                            "",
                            "function createBabelParseError(error) {",
                            "  // babel error prints (line:column) with cols that are zero indexed",
                            "  // so we need our custom error",
                            "  const { message, loc } = error;",
                            "",
                            "  return createError(message.replace(/ \\(.*\\)$/, \"\"), {",
                            "    loc: {",
                            "      start: {",
                            "        line: loc ? loc.line : 0,",
                            "        column: loc ? loc.column + 1 : 0,",
                            "      },",
                            "    },",
                            "    cause: error,",
                            "  });",
                            "}",
                            "",
                            "export default createBabelParseError;"
                        ]
                    },
                    "create-parser.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { hasPragma } from \"../../pragma.js\";",
                            "import { locStart, locEnd } from \"../../loc.js\";",
                            "",
                            "function createParser(options) {",
                            "  options = typeof options === \"function\" ? { parse: options } : options;",
                            "",
                            "  return {",
                            "    astFormat: \"estree\",",
                            "    hasPragma,",
                            "    locStart,",
                            "    locEnd,",
                            "    ...options,",
                            "  };",
                            "}",
                            "",
                            "export default createParser;"
                        ]
                    },
                    "get-source-type.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "/** @returns {\"module\" | \"script\" | undefined} */",
                            "function getSourceType(options) {",
                            "  let { filepath } = options;",
                            "  if (!filepath) {",
                            "    return;",
                            "  }",
                            "  filepath = filepath.toLowerCase();",
                            "",
                            "  if (filepath.endsWith(\".cjs\")) {",
                            "    return \"script\";",
                            "  }",
                            "",
                            "  if (filepath.endsWith(\".mjs\")) {",
                            "    return \"module\";",
                            "  }",
                            "}",
                            "",
                            "export default getSourceType;"
                        ]
                    },
                    "replace-hashbang.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "// Replace `#!` with `//` so `typescript`, `flow`, and `espree` can parse it as line comment",
                            "// Inspired by ESLint parse function https://github.com/eslint/eslint/blob/9d6063add931f0803cae1676d5df307baf114360/lib/linter/linter.js#L635",
                            "function replaceHashbang(text) {",
                            "  if (text.charAt(0) === \"#\" && text.charAt(1) === \"!\") {",
                            "    return \"//\" + text.slice(2);",
                            "  }",
                            "",
                            "  return text;",
                            "}",
                            "",
                            "export default replaceHashbang;"
                        ]
                    },
                    "wrap-babel-expression.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "/**",
                            " * @param {{",
                            " *   text: string,",
                            " *   type?: string,",
                            " *   rootMarker?: string,",
                            " * }} options",
                            " */",
                            "function wrapBabelExpression(expression, options) {",
                            "  const { type = \"JsExpressionRoot\", rootMarker, text } = options;",
                            "",
                            "  const { tokens, comments } = expression;",
                            "  delete expression.tokens;",
                            "  delete expression.comments;",
                            "",
                            "  return {",
                            "    tokens,",
                            "    comments,",
                            "    type,",
                            "    node: expression,",
                            "    range: [0, text.length],",
                            "    rootMarker,",
                            "  };",
                            "}",
                            "",
                            "export default wrapBabelExpression;"
                        ]
                    }
                }
            },
            "print": {
                "angular.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { join, line, group } from \"../../document/builders.js\";",
                        "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                        "import {",
                        "  hasNode,",
                        "  hasComment,",
                        "  getComments,",
                        "  createTypeCheckFunction,",
                        "} from \"../utils/index.js\";",
                        "import { printBinaryishExpression } from \"./binaryish.js\";",
                        "",
                        "/** @typedef {import(\"../../common/ast-path.js\").default} AstPath */",
                        "",
                        "function printAngular(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  // Angular nodes always starts with `NG`",
                        "  if (!node.type.startsWith(\"NG\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"NGRoot\":",
                        "      return [",
                        "        print(\"node\"),",
                        "        hasComment(node.node)",
                        "          ? \" //\" + getComments(node.node)[0].value.trimEnd()",
                        "          : \"\",",
                        "      ];",
                        "    case \"NGPipeExpression\":",
                        "      return printBinaryishExpression(path, options, print);",
                        "    case \"NGChainedExpression\":",
                        "      return group(",
                        "        join(",
                        "          [\";\", line],",
                        "          path.map(",
                        "            () => (hasNgSideEffect(path) ? print() : [\"(\", print(), \")\"]),",
                        "            \"expressions\"",
                        "          )",
                        "        )",
                        "      );",
                        "    case \"NGEmptyExpression\":",
                        "      return \"\";",
                        "    case \"NGMicrosyntax\":",
                        "      return path.map(",
                        "        () => [",
                        "          path.isFirst ? \"\" : isNgForOf(path) ? \" \" : [\";\", line],",
                        "          print(),",
                        "        ],",
                        "        \"body\"",
                        "      );",
                        "    case \"NGMicrosyntaxKey\":",
                        "      return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(node.name)",
                        "        ? node.name",
                        "        : JSON.stringify(node.name);",
                        "    case \"NGMicrosyntaxExpression\":",
                        "      return [",
                        "        print(\"expression\"),",
                        "        node.alias === null ? \"\" : [\" as \", print(\"alias\")],",
                        "      ];",
                        "    case \"NGMicrosyntaxKeyedExpression\": {",
                        "      const { index, parent } = path;",
                        "      const shouldNotPrintColon =",
                        "        isNgForOf(path) ||",
                        "        (((index === 1 &&",
                        "          (node.key.name === \"then\" || node.key.name === \"else\")) ||",
                        "          (index === 2 &&",
                        "            node.key.name === \"else\" &&",
                        "            parent.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" &&",
                        "            parent.body[index - 1].key.name === \"then\")) &&",
                        "          parent.body[0].type === \"NGMicrosyntaxExpression\");",
                        "      return [",
                        "        print(\"key\"),",
                        "        shouldNotPrintColon ? \" \" : \": \",",
                        "        print(\"expression\"),",
                        "      ];",
                        "    }",
                        "    case \"NGMicrosyntaxLet\":",
                        "      return [",
                        "        \"let \",",
                        "        print(\"key\"),",
                        "        node.value === null ? \"\" : [\" = \", print(\"value\")],",
                        "      ];",
                        "    case \"NGMicrosyntaxAs\":",
                        "      return [print(\"key\"), \" as \", print(\"alias\")];",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      throw new UnexpectedNodeError(node, \"Angular\");",
                        "  }",
                        "}",
                        "",
                        "function isNgForOf({ node, index, parent }) {",
                        "  return (",
                        "    node.type === \"NGMicrosyntaxKeyedExpression\" &&",
                        "    node.key.name === \"of\" &&",
                        "    index === 1 &&",
                        "    parent.body[0].type === \"NGMicrosyntaxLet\" &&",
                        "    parent.body[0].value === null",
                        "  );",
                        "}",
                        "",
                        "const hasSideEffect = createTypeCheckFunction([",
                        "  \"CallExpression\",",
                        "  \"OptionalCallExpression\",",
                        "  \"AssignmentExpression\",",
                        "]);",
                        "/** identify if an angular expression seems to have side effects */",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function hasNgSideEffect({ node }) {",
                        "  return hasNode(node, hasSideEffect);",
                        "}",
                        "",
                        "export { printAngular };"
                    ]
                },
                "array.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  line,",
                        "  softline,",
                        "  hardline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "  fill,",
                        "} from \"../../document/builders.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import {",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "  isNumericLiteral,",
                        "  isSignedNumericLiteral,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import { locStart } from \"../loc.js\";",
                        "",
                        "import { printOptionalToken } from \"./misc.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "function printEmptyArray(path, options, openBracket, closeBracket) {",
                        "  const { node } = path;",
                        "  if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    return [openBracket, closeBracket];",
                        "  }",
                        "  return group([",
                        "    openBracket,",
                        "    printDanglingComments(path, options, { indent: true }),",
                        "    softline,",
                        "    closeBracket,",
                        "  ]);",
                        "}",
                        "",
                        "/*",
                        "- `ArrayExpression`",
                        "- `TupleExpression`",
                        "- `ArrayPattern`",
                        "- `TSTupleType`(TypeScript)",
                        "- `TupleTypeAnnotation`(Flow)",
                        "*/",
                        "function printArray(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  const openBracket = node.type === \"TupleExpression\" ? \"#[\" : \"[\";",
                        "  const closeBracket = \"]\";",
                        "  const elementsProperty =",
                        "    // TODO: Remove `types` when babel changes AST of `TupleTypeAnnotation`",
                        "    node.type === \"TupleTypeAnnotation\" && node.types",
                        "      ? \"types\"",
                        "      : node.type === \"TSTupleType\" || node.type === \"TupleTypeAnnotation\"",
                        "      ? \"elementTypes\"",
                        "      : \"elements\";",
                        "  const elements = node[elementsProperty];",
                        "  if (elements.length === 0) {",
                        "    parts.push(printEmptyArray(path, options, openBracket, closeBracket));",
                        "  } else {",
                        "    const lastElem = elements.at(-1);",
                        "    const canHaveTrailingComma = lastElem?.type !== \"RestElement\";",
                        "",
                        "    // JavaScript allows you to have empty elements in an array which",
                        "    // changes its length based on the number of commas. The algorithm",
                        "    // is that if the last argument is null, we need to force insert",
                        "    // a comma to ensure JavaScript recognizes it.",
                        "    //   [,].length === 1",
                        "    //   [1,].length === 1",
                        "    //   [1,,].length === 2",
                        "    //",
                        "    // Note that getLast returns null if the array is empty, but",
                        "    // we already check for an empty array just above so we are safe",
                        "    const needsForcedTrailingComma = lastElem === null;",
                        "",
                        "    const groupId = Symbol(\"array\");",
                        "",
                        "    const shouldBreak =",
                        "      !options.__inJestEach &&",
                        "      elements.length > 1 &&",
                        "      elements.every((element, i, elements) => {",
                        "        const elementType = element?.type;",
                        "        if (",
                        "          !isArrayOrTupleExpression(element) &&",
                        "          !isObjectOrRecordExpression(element)",
                        "        ) {",
                        "          return false;",
                        "        }",
                        "",
                        "        const nextElement = elements[i + 1];",
                        "        if (nextElement && elementType !== nextElement.type) {",
                        "          return false;",
                        "        }",
                        "",
                        "        const itemsKey = isArrayOrTupleExpression(element)",
                        "          ? \"elements\"",
                        "          : \"properties\";",
                        "",
                        "        return element[itemsKey] && element[itemsKey].length > 1;",
                        "      });",
                        "",
                        "    const shouldUseConciseFormatting = isConciselyPrintedArray(node, options);",
                        "",
                        "    const trailingComma = !canHaveTrailingComma",
                        "      ? \"\"",
                        "      : needsForcedTrailingComma",
                        "      ? \",\"",
                        "      : !shouldPrintComma(options)",
                        "      ? \"\"",
                        "      : shouldUseConciseFormatting",
                        "      ? ifBreak(\",\", \"\", { groupId })",
                        "      : ifBreak(\",\");",
                        "",
                        "    parts.push(",
                        "      group(",
                        "        [",
                        "          openBracket,",
                        "          indent([",
                        "            softline,",
                        "            shouldUseConciseFormatting",
                        "              ? printArrayItemsConcisely(path, options, print, trailingComma)",
                        "              : [",
                        "                  printArrayItems(path, options, elementsProperty, print),",
                        "                  trailingComma,",
                        "                ],",
                        "            printDanglingComments(path, options),",
                        "          ]),",
                        "          softline,",
                        "          closeBracket,",
                        "        ],",
                        "        { shouldBreak, id: groupId }",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printOptionalToken(path),",
                        "    printTypeAnnotationProperty(path, print)",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function isConciselyPrintedArray(node, options) {",
                        "  return (",
                        "    isArrayOrTupleExpression(node) &&",
                        "    node.elements.length > 1 &&",
                        "    node.elements.every(",
                        "      (element) =>",
                        "        element &&",
                        "        (isNumericLiteral(element) ||",
                        "          (isSignedNumericLiteral(element) && !hasComment(element.argument))) &&",
                        "        !hasComment(",
                        "          element,",
                        "          CommentCheckFlags.Trailing | CommentCheckFlags.Line,",
                        "          (comment) =>",
                        "            !hasNewline(options.originalText, locStart(comment), {",
                        "              backwards: true,",
                        "            })",
                        "        )",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function printArrayItems(path, options, elementsProperty, print) {",
                        "  const parts = [];",
                        "",
                        "  path.each(({ node, isLast }) => {",
                        "    parts.push(node ? group(print()) : \"\");",
                        "",
                        "    if (!isLast) {",
                        "      parts.push([",
                        "        \",\",",
                        "        line,",
                        "        node && isNextLineEmpty(node, options) ? softline : \"\",",
                        "      ]);",
                        "    }",
                        "  }, elementsProperty);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrayItemsConcisely(path, options, print, trailingComma) {",
                        "  const parts = [];",
                        "",
                        "  path.each(({ node, isLast, next }) => {",
                        "    parts.push([print(), isLast ? trailingComma : \",\"]);",
                        "",
                        "    if (!isLast) {",
                        "      parts.push(",
                        "        isNextLineEmpty(node, options)",
                        "          ? [hardline, hardline]",
                        "          : hasComment(next, CommentCheckFlags.Leading | CommentCheckFlags.Line)",
                        "          ? hardline",
                        "          : line",
                        "      );",
                        "    }",
                        "  }, \"elements\");",
                        "",
                        "  return fill(parts);",
                        "}",
                        "",
                        "export { printArray, isConciselyPrintedArray };"
                    ]
                },
                "assignment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import getStringWidth from \"../../utils/get-string-width.js\";",
                        "import {",
                        "  line,",
                        "  group,",
                        "  indent,",
                        "  indentIfBreak,",
                        "  lineSuffixBoundary,",
                        "} from \"../../document/builders.js\";",
                        "import { cleanDoc, willBreak, canBreak } from \"../../document/utils.js\";",
                        "import {",
                        "  hasLeadingOwnLineComment,",
                        "  isBinaryish,",
                        "  isStringLiteral,",
                        "  isNumericLiteral,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  getCallArguments,",
                        "  rawText,",
                        "  hasComment,",
                        "  isSignedNumericLiteral,",
                        "  isObjectProperty,",
                        "  createTypeCheckFunction,",
                        "} from \"../utils/index.js\";",
                        "import { shouldInlineLogicalExpression } from \"./binaryish.js\";",
                        "import { printCallExpression } from \"./call-expression.js\";",
                        "import { isLiteral } from \"./literal.js\";",
                        "",
                        "function printAssignment(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  leftDoc,",
                        "  operator,",
                        "  rightPropertyName",
                        ") {",
                        "  const layout = chooseLayout(path, options, print, leftDoc, rightPropertyName);",
                        "",
                        "  const rightDoc = rightPropertyName",
                        "    ? print(rightPropertyName, { assignmentLayout: layout })",
                        "    : \"\";",
                        "",
                        "  switch (layout) {",
                        "    // First break after operator, then the sides are broken independently on their own lines",
                        "    case \"break-after-operator\":",
                        "      return group([group(leftDoc), operator, group(indent([line, rightDoc]))]);",
                        "",
                        "    // First break right-hand side, then left-hand side",
                        "    case \"never-break-after-operator\":",
                        "      return group([group(leftDoc), operator, \" \", rightDoc]);",
                        "",
                        "    // First break right-hand side, then after operator",
                        "    case \"fluid\": {",
                        "      const groupId = Symbol(\"assignment\");",
                        "      return group([",
                        "        group(leftDoc),",
                        "        operator,",
                        "        group(indent(line), { id: groupId }),",
                        "        lineSuffixBoundary,",
                        "        indentIfBreak(rightDoc, { groupId }),",
                        "      ]);",
                        "    }",
                        "",
                        "    case \"break-lhs\":",
                        "      return group([leftDoc, operator, \" \", group(rightDoc)]);",
                        "",
                        "    // Parts of assignment chains aren't wrapped in groups.",
                        "    // Once one of them breaks, the chain breaks too.",
                        "    case \"chain\":",
                        "      return [group(leftDoc), operator, line, rightDoc];",
                        "",
                        "    case \"chain-tail\":",
                        "      return [group(leftDoc), operator, indent([line, rightDoc])];",
                        "",
                        "    case \"chain-tail-arrow-chain\":",
                        "      return [group(leftDoc), operator, rightDoc];",
                        "",
                        "    case \"only-left\":",
                        "      return leftDoc;",
                        "  }",
                        "}",
                        "",
                        "function printAssignmentExpression(path, options, print) {",
                        "  const { node } = path;",
                        "  return printAssignment(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    print(\"left\"),",
                        "    [\" \", node.operator],",
                        "    \"right\"",
                        "  );",
                        "}",
                        "",
                        "function printVariableDeclarator(path, options, print) {",
                        "  return printAssignment(path, options, print, print(\"id\"), \" =\", \"init\");",
                        "}",
                        "",
                        "function chooseLayout(path, options, print, leftDoc, rightPropertyName) {",
                        "  const { node } = path;",
                        "  const rightNode = node[rightPropertyName];",
                        "",
                        "  if (!rightNode) {",
                        "    return \"only-left\";",
                        "  }",
                        "",
                        "  // Short assignment chains (only 2 segments) are NOT formatted as chains.",
                        "  //   1) a = b = c; (expression statements)",
                        "  //   2) var/let/const a = b = c;",
                        "",
                        "  const isTail = !isAssignment(rightNode);",
                        "  const shouldUseChainFormatting = path.match(",
                        "    isAssignment,",
                        "    isAssignmentOrVariableDeclarator,",
                        "    (node) =>",
                        "      !isTail ||",
                        "      (node.type !== \"ExpressionStatement\" &&",
                        "        node.type !== \"VariableDeclaration\")",
                        "  );",
                        "  if (shouldUseChainFormatting) {",
                        "    return !isTail",
                        "      ? \"chain\"",
                        "      : rightNode.type === \"ArrowFunctionExpression\" &&",
                        "        rightNode.body.type === \"ArrowFunctionExpression\"",
                        "      ? \"chain-tail-arrow-chain\"",
                        "      : \"chain-tail\";",
                        "  }",
                        "  const isHeadOfLongChain = !isTail && isAssignment(rightNode.right);",
                        "",
                        "  if (",
                        "    isHeadOfLongChain ||",
                        "    hasLeadingOwnLineComment(options.originalText, rightNode)",
                        "  ) {",
                        "    return \"break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    (rightNode.type === \"CallExpression\" &&",
                        "      rightNode.callee.name === \"require\") ||",
                        "    // do not put values on a separate line from the key in json",
                        "    options.parser === \"json5\" ||",
                        "    options.parser === \"json\"",
                        "  ) {",
                        "    return \"never-break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    isComplexDestructuring(node) ||",
                        "    isComplexTypeAliasParams(node) ||",
                        "    hasComplexTypeAnnotation(node) ||",
                        "    (isArrowFunctionVariableDeclarator(node) && canBreak(leftDoc))",
                        "  ) {",
                        "    return \"break-lhs\";",
                        "  }",
                        "",
                        "  // wrapping object properties with very short keys usually doesn't add much value",
                        "  const hasShortKey = isObjectPropertyWithShortKey(node, leftDoc, options);",
                        "",
                        "  if (",
                        "    path.call(",
                        "      () => shouldBreakAfterOperator(path, options, print, hasShortKey),",
                        "      rightPropertyName",
                        "    )",
                        "  ) {",
                        "    return \"break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    hasShortKey ||",
                        "    rightNode.type === \"TemplateLiteral\" ||",
                        "    rightNode.type === \"TaggedTemplateExpression\" ||",
                        "    rightNode.type === \"BooleanLiteral\" ||",
                        "    isNumericLiteral(rightNode) ||",
                        "    rightNode.type === \"ClassExpression\"",
                        "  ) {",
                        "    return \"never-break-after-operator\";",
                        "  }",
                        "",
                        "  return \"fluid\";",
                        "}",
                        "",
                        "function shouldBreakAfterOperator(path, options, print, hasShortKey) {",
                        "  const rightNode = path.node;",
                        "",
                        "  if (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (rightNode.type) {",
                        "    case \"StringLiteralTypeAnnotation\":",
                        "    case \"SequenceExpression\":",
                        "      return true;",
                        "    case \"ConditionalExpression\": {",
                        "      const { test } = rightNode;",
                        "      return isBinaryish(test) && !shouldInlineLogicalExpression(test);",
                        "    }",
                        "    case \"ClassExpression\":",
                        "      return isNonEmptyArray(rightNode.decorators);",
                        "  }",
                        "",
                        "  if (hasShortKey) {",
                        "    return false;",
                        "  }",
                        "",
                        "  let node = rightNode;",
                        "  const propertiesForPath = [];",
                        "  for (;;) {",
                        "    if (node.type === \"UnaryExpression\") {",
                        "      node = node.argument;",
                        "      propertiesForPath.push(\"argument\");",
                        "    } else if (node.type === \"TSNonNullExpression\") {",
                        "      node = node.expression;",
                        "      propertiesForPath.push(\"expression\");",
                        "    } else {",
                        "      break;",
                        "    }",
                        "  }",
                        "  if (",
                        "    isStringLiteral(node) ||",
                        "    path.call(",
                        "      () => isPoorlyBreakableMemberOrCallChain(path, options, print),",
                        "      ...propertiesForPath",
                        "    )",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "// prefer to break destructuring assignment",
                        "// if it includes default values or non-shorthand properties",
                        "function isComplexDestructuring(node) {",
                        "  if (isAssignmentOrVariableDeclarator(node)) {",
                        "    const leftNode = node.left || node.id;",
                        "    return (",
                        "      leftNode.type === \"ObjectPattern\" &&",
                        "      leftNode.properties.length > 2 &&",
                        "      leftNode.properties.some(",
                        "        (property) =>",
                        "          isObjectProperty(property) &&",
                        "          (!property.shorthand || property.value?.type === \"AssignmentPattern\")",
                        "      )",
                        "    );",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function isAssignment(node) {",
                        "  return node.type === \"AssignmentExpression\";",
                        "}",
                        "",
                        "function isAssignmentOrVariableDeclarator(node) {",
                        "  return isAssignment(node) || node.type === \"VariableDeclarator\";",
                        "}",
                        "",
                        "function isComplexTypeAliasParams(node) {",
                        "  const typeParams = getTypeParametersFromTypeAlias(node);",
                        "  if (isNonEmptyArray(typeParams)) {",
                        "    const constraintPropertyName =",
                        "      node.type === \"TSTypeAliasDeclaration\" ? \"constraint\" : \"bound\";",
                        "    if (",
                        "      typeParams.length > 1 &&",
                        "      typeParams.some((param) => param[constraintPropertyName] || param.default)",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "const isTypeAlias = createTypeCheckFunction([",
                        "  \"TSTypeAliasDeclaration\",",
                        "  \"TypeAlias\",",
                        "]);",
                        "function getTypeParametersFromTypeAlias(node) {",
                        "  if (isTypeAlias(node)) {",
                        "    return node.typeParameters?.params;",
                        "  }",
                        "}",
                        "",
                        "function hasComplexTypeAnnotation(node) {",
                        "  if (node.type !== \"VariableDeclarator\") {",
                        "    return false;",
                        "  }",
                        "  const { typeAnnotation } = node.id;",
                        "  if (!typeAnnotation || !typeAnnotation.typeAnnotation) {",
                        "    return false;",
                        "  }",
                        "  const typeParams = getTypeParametersFromTypeReference(",
                        "    typeAnnotation.typeAnnotation",
                        "  );",
                        "  return (",
                        "    isNonEmptyArray(typeParams) &&",
                        "    typeParams.length > 1 &&",
                        "    typeParams.some(",
                        "      (param) =>",
                        "        isNonEmptyArray(getTypeParametersFromTypeReference(param)) ||",
                        "        param.type === \"TSConditionalType\"",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function isArrowFunctionVariableDeclarator(node) {",
                        "  return (",
                        "    node.type === \"VariableDeclarator\" &&",
                        "    node.init?.type === \"ArrowFunctionExpression\"",
                        "  );",
                        "}",
                        "",
                        "const isTypeReference = createTypeCheckFunction([",
                        "  \"TSTypeReference\",",
                        "  \"GenericTypeAnnotation\",",
                        "]);",
                        "function getTypeParametersFromTypeReference(node) {",
                        "  if (isTypeReference(node)) {",
                        "    return node.typeParameters?.params;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * A chain with no calls at all or whose calls are all without arguments or with lone short arguments,",
                        " * excluding chains printed by `printMemberChain`",
                        " */",
                        "function isPoorlyBreakableMemberOrCallChain(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  deep = false",
                        ") {",
                        "  const { node } = path;",
                        "  const goDeeper = () =>",
                        "    isPoorlyBreakableMemberOrCallChain(path, options, print, true);",
                        "",
                        "  if (node.type === \"ChainExpression\" || node.type === \"TSNonNullExpression\") {",
                        "    return path.call(goDeeper, \"expression\");",
                        "  }",
                        "",
                        "  if (isCallExpression(node)) {",
                        "    /** @type {any} TODO */",
                        "    const doc = printCallExpression(path, options, print);",
                        "    if (doc.label?.memberChain) {",
                        "      return false;",
                        "    }",
                        "",
                        "    const args = getCallArguments(node);",
                        "    const isPoorlyBreakableCall =",
                        "      args.length === 0 ||",
                        "      (args.length === 1 && isLoneShortArgument(args[0], options));",
                        "    if (!isPoorlyBreakableCall) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (isCallExpressionWithComplexTypeArguments(node, print)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return path.call(goDeeper, \"callee\");",
                        "  }",
                        "",
                        "  if (isMemberExpression(node)) {",
                        "    return path.call(goDeeper, \"object\");",
                        "  }",
                        "",
                        "  return deep && (node.type === \"Identifier\" || node.type === \"ThisExpression\");",
                        "}",
                        "",
                        "const LONE_SHORT_ARGUMENT_THRESHOLD_RATE = 0.25;",
                        "",
                        "function isLoneShortArgument(node, { printWidth }) {",
                        "  if (hasComment(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const threshold = printWidth * LONE_SHORT_ARGUMENT_THRESHOLD_RATE;",
                        "",
                        "  if (",
                        "    node.type === \"ThisExpression\" ||",
                        "    (node.type === \"Identifier\" && node.name.length <= threshold) ||",
                        "    (isSignedNumericLiteral(node) && !hasComment(node.argument))",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const regexpPattern =",
                        "    (node.type === \"Literal\" && \"regex\" in node && node.regex.pattern) ||",
                        "    (node.type === \"RegExpLiteral\" && node.pattern);",
                        "",
                        "  if (regexpPattern) {",
                        "    return regexpPattern.length <= threshold;",
                        "  }",
                        "",
                        "  if (isStringLiteral(node)) {",
                        "    return rawText(node).length <= threshold;",
                        "  }",
                        "",
                        "  if (node.type === \"TemplateLiteral\") {",
                        "    return (",
                        "      node.expressions.length === 0 &&",
                        "      node.quasis[0].value.raw.length <= threshold &&",
                        "      !node.quasis[0].value.raw.includes(\"\\n\")",
                        "    );",
                        "  }",
                        "",
                        "  return isLiteral(node);",
                        "}",
                        "",
                        "function isObjectPropertyWithShortKey(node, keyDoc, options) {",
                        "  if (!isObjectProperty(node)) {",
                        "    return false;",
                        "  }",
                        "  // TODO: for performance, it might make sense to use a more lightweight",
                        "  // version of cleanDoc, such that it would stop once it detects that",
                        "  // the doc can't be reduced to a string.",
                        "  keyDoc = cleanDoc(keyDoc);",
                        "  const MIN_OVERLAP_FOR_BREAK = 3;",
                        "  //   ↓↓ - insufficient overlap for a line break",
                        "  // key1: longValue1,",
                        "  //   ↓↓↓↓↓↓ - overlap is long enough to break",
                        "  // key2abcd:",
                        "  //   longValue2",
                        "  return (",
                        "    typeof keyDoc === \"string\" &&",
                        "    getStringWidth(keyDoc) < options.tabWidth + MIN_OVERLAP_FOR_BREAK",
                        "  );",
                        "}",
                        "",
                        "function isCallExpressionWithComplexTypeArguments(node, print) {",
                        "  const typeArgs = getTypeArgumentsFromCallExpression(node);",
                        "  if (isNonEmptyArray(typeArgs)) {",
                        "    if (typeArgs.length > 1) {",
                        "      return true;",
                        "    }",
                        "    if (typeArgs.length === 1) {",
                        "      const firstArg = typeArgs[0];",
                        "      if (",
                        "        firstArg.type === \"TSUnionType\" ||",
                        "        firstArg.type === \"UnionTypeAnnotation\" ||",
                        "        firstArg.type === \"TSIntersectionType\" ||",
                        "        firstArg.type === \"IntersectionTypeAnnotation\" ||",
                        "        firstArg.type === \"TSTypeLiteral\" ||",
                        "        firstArg.type === \"ObjectTypeAnnotation\"",
                        "      ) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "    const typeArgsKeyName = node.typeParameters",
                        "      ? \"typeParameters\"",
                        "      : \"typeArguments\";",
                        "    if (willBreak(print(typeArgsKeyName))) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function getTypeArgumentsFromCallExpression(node) {",
                        "  return (node.typeParameters ?? node.typeArguments)?.params;",
                        "}",
                        "",
                        "export {",
                        "  printVariableDeclarator,",
                        "  printAssignmentExpression,",
                        "  printAssignment,",
                        "  isArrowFunctionVariableDeclarator,",
                        "};"
                    ]
                },
                "binaryish.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printComments } from \"../../main/comments/print.js\";",
                        "import { DOC_TYPE_FILL, DOC_TYPE_GROUP } from \"../../document/constants.js\";",
                        "import {",
                        "  join,",
                        "  line,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  align,",
                        "  indentIfBreak,",
                        "} from \"../../document/builders.js\";",
                        "import { cleanDoc, getDocParts } from \"../../document/utils.js\";",
                        "import {",
                        "  hasLeadingOwnLineComment,",
                        "  isBinaryish,",
                        "  isJsxElement,",
                        "  shouldFlatten,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isObjectProperty,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "",
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "let uid = 0;",
                        "function printBinaryishExpression(path, options, print) {",
                        "  const { node, parent, grandparent, key } = path;",
                        "  const isInsideParenthesis =",
                        "    key !== \"body\" &&",
                        "    (parent.type === \"IfStatement\" ||",
                        "      parent.type === \"WhileStatement\" ||",
                        "      parent.type === \"SwitchStatement\" ||",
                        "      parent.type === \"DoWhileStatement\");",
                        "  const isHackPipeline =",
                        "    node.operator === \"|>\" && path.root.extra?.__isUsingHackPipeline;",
                        "",
                        "  const parts = printBinaryishExpressions(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    /* isNested */ false,",
                        "    isInsideParenthesis",
                        "  );",
                        "",
                        "  //   if (",
                        "  //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft",
                        "  //   ) {",
                        "  //",
                        "  // looks super weird, we want to break the children if the parent breaks",
                        "  //",
                        "  //   if (",
                        "  //     this.hasPlugin(\"dynamicImports\") &&",
                        "  //     this.lookahead().type === tt.parenLeft",
                        "  //   ) {",
                        "  if (isInsideParenthesis) {",
                        "    return parts;",
                        "  }",
                        "",
                        "  if (isHackPipeline) {",
                        "    return group(parts);",
                        "  }",
                        "",
                        "  // Break between the parens in",
                        "  // unaries or in a member or specific call expression, i.e.",
                        "  //",
                        "  //   (",
                        "  //     a &&",
                        "  //     b &&",
                        "  //     c",
                        "  //   ).call()",
                        "  if (",
                        "    (isCallExpression(parent) && parent.callee === node) ||",
                        "    parent.type === \"UnaryExpression\" ||",
                        "    (isMemberExpression(parent) && !parent.computed)",
                        "  ) {",
                        "    return group([indent([softline, ...parts]), softline]);",
                        "  }",
                        "",
                        "  // Avoid indenting sub-expressions in some cases where the first sub-expression is already",
                        "  // indented accordingly. We should indent sub-expressions where the first case isn't indented.",
                        "  const shouldNotIndent =",
                        "    parent.type === \"ReturnStatement\" ||",
                        "    parent.type === \"ThrowStatement\" ||",
                        "    (parent.type === \"JSXExpressionContainer\" &&",
                        "      grandparent.type === \"JSXAttribute\") ||",
                        "    (node.operator !== \"|\" && parent.type === \"JsExpressionRoot\") ||",
                        "    (node.type !== \"NGPipeExpression\" &&",
                        "      ((parent.type === \"NGRoot\" && options.parser === \"__ng_binding\") ||",
                        "        (parent.type === \"NGMicrosyntaxExpression\" &&",
                        "          grandparent.type === \"NGMicrosyntax\" &&",
                        "          grandparent.body.length === 1))) ||",
                        "    (node === parent.body && parent.type === \"ArrowFunctionExpression\") ||",
                        "    (node !== parent.body && parent.type === \"ForStatement\") ||",
                        "    (parent.type === \"ConditionalExpression\" &&",
                        "      grandparent.type !== \"ReturnStatement\" &&",
                        "      grandparent.type !== \"ThrowStatement\" &&",
                        "      !isCallExpression(grandparent)) ||",
                        "    parent.type === \"TemplateLiteral\";",
                        "",
                        "  const shouldIndentIfInlining =",
                        "    parent.type === \"AssignmentExpression\" ||",
                        "    parent.type === \"VariableDeclarator\" ||",
                        "    parent.type === \"ClassProperty\" ||",
                        "    parent.type === \"PropertyDefinition\" ||",
                        "    parent.type === \"TSAbstractPropertyDefinition\" ||",
                        "    parent.type === \"ClassPrivateProperty\" ||",
                        "    isObjectProperty(parent);",
                        "",
                        "  const samePrecedenceSubExpression =",
                        "    isBinaryish(node.left) && shouldFlatten(node.operator, node.left.operator);",
                        "",
                        "  if (",
                        "    shouldNotIndent ||",
                        "    (shouldInlineLogicalExpression(node) && !samePrecedenceSubExpression) ||",
                        "    (!shouldInlineLogicalExpression(node) && shouldIndentIfInlining)",
                        "  ) {",
                        "    return group(parts);",
                        "  }",
                        "",
                        "  if (parts.length === 0) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // If the right part is a JSX node, we include it in a separate group to",
                        "  // prevent it breaking the whole chain, so we can print the expression like:",
                        "  //",
                        "  //   foo && bar && (",
                        "  //     <Foo>",
                        "  //       <Bar />",
                        "  //     </Foo>",
                        "  //   )",
                        "",
                        "  const hasJsx = isJsxElement(node.right);",
                        "",
                        "  const firstGroupIndex = parts.findIndex(",
                        "    (part) =>",
                        "      typeof part !== \"string\" &&",
                        "      !Array.isArray(part) &&",
                        "      part.type === DOC_TYPE_GROUP",
                        "  );",
                        "",
                        "  // Separate the leftmost expression, possibly with its leading comments.",
                        "  const headParts = parts.slice(",
                        "    0,",
                        "    firstGroupIndex === -1 ? 1 : firstGroupIndex + 1",
                        "  );",
                        "",
                        "  const rest = parts.slice(headParts.length, hasJsx ? -1 : undefined);",
                        "",
                        "  const groupId = Symbol(\"logicalChain-\" + ++uid);",
                        "",
                        "  const chain = group(",
                        "    [",
                        "      // Don't include the initial expression in the indentation",
                        "      // level. The first item is guaranteed to be the first",
                        "      // left-most expression.",
                        "      ...headParts,",
                        "      indent(rest),",
                        "    ],",
                        "    { id: groupId }",
                        "  );",
                        "",
                        "  if (!hasJsx) {",
                        "    return chain;",
                        "  }",
                        "",
                        "  const jsxPart = parts.at(-1);",
                        "  return group([chain, indentIfBreak(jsxPart, { groupId })]);",
                        "}",
                        "",
                        "// For binary expressions to be consistent, we need to group",
                        "// subsequent operators with the same precedence level under a single",
                        "// group. Otherwise they will be nested such that some of them break",
                        "// onto new lines but not all. Operators with the same precedence",
                        "// level should either all break or not. Because we group them by",
                        "// precedence level and the AST is structured based on precedence",
                        "// level, things are naturally broken up correctly, i.e. `&&` is",
                        "// broken before `+`.",
                        "function printBinaryishExpressions(",
                        "  path,",
                        "  print,",
                        "  options,",
                        "  isNested,",
                        "  isInsideParenthesis",
                        ") {",
                        "  const { node } = path;",
                        "",
                        "  // Simply print the node normally.",
                        "  if (!isBinaryish(node)) {",
                        "    return [group(print())];",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  let parts = [];",
                        "",
                        "  // We treat BinaryExpression and LogicalExpression nodes the same.",
                        "",
                        "  // Put all operators with the same precedence level in the same",
                        "  // group. The reason we only need to do this with the `left`",
                        "  // expression is because given an expression like `1 + 2 - 3`, it",
                        "  // is always parsed like `((1 + 2) - 3)`, meaning the `left` side",
                        "  // is where the rest of the expression will exist. Binary",
                        "  // expressions on the right side mean they have a difference",
                        "  // precedence level and should be treated as a separate group, so",
                        "  // print them normally. (This doesn't hold for the `**` operator,",
                        "  // which is unique in that it is right-associative.)",
                        "  if (shouldFlatten(node.operator, node.left.operator)) {",
                        "    // Flatten them out by recursively calling this function.",
                        "    parts = path.call(",
                        "      (left) =>",
                        "        printBinaryishExpressions(",
                        "          left,",
                        "          print,",
                        "          options,",
                        "          /* isNested */ true,",
                        "          isInsideParenthesis",
                        "        ),",
                        "      \"left\"",
                        "    );",
                        "  } else {",
                        "    parts.push(group(print(\"left\")));",
                        "  }",
                        "",
                        "  const shouldInline = shouldInlineLogicalExpression(node);",
                        "  const lineBeforeOperator =",
                        "    (node.operator === \"|>\" ||",
                        "      node.type === \"NGPipeExpression\" ||",
                        "      isVueFilterSequenceExpression(path, options)) &&",
                        "    !hasLeadingOwnLineComment(options.originalText, node.right);",
                        "",
                        "  const operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;",
                        "  const rightSuffix =",
                        "    node.type === \"NGPipeExpression\" && node.arguments.length > 0",
                        "      ? group(",
                        "          indent([",
                        "            line,",
                        "            \": \",",
                        "            join(",
                        "              [line, \": \"],",
                        "              path.map(() => align(2, group(print())), \"arguments\")",
                        "            ),",
                        "          ])",
                        "        )",
                        "      : \"\";",
                        "",
                        "  /** @type {Doc} */",
                        "  let right;",
                        "  if (shouldInline) {",
                        "    right = [operator, \" \", print(\"right\"), rightSuffix];",
                        "  } else {",
                        "    const isHackPipeline =",
                        "      operator === \"|>\" && path.root.extra?.__isUsingHackPipeline;",
                        "    const rightContent = isHackPipeline",
                        "      ? path.call(",
                        "          (left) =>",
                        "            printBinaryishExpressions(",
                        "              left,",
                        "              print,",
                        "              options,",
                        "              /* isNested */ true,",
                        "              isInsideParenthesis",
                        "            ),",
                        "          \"right\"",
                        "        )",
                        "      : print(\"right\");",
                        "    right = [",
                        "      lineBeforeOperator ? line : \"\",",
                        "      operator,",
                        "      lineBeforeOperator ? \" \" : line,",
                        "      rightContent,",
                        "      rightSuffix,",
                        "    ];",
                        "  }",
                        "",
                        "  // If there's only a single binary expression, we want to create a group",
                        "  // in order to avoid having a small right part like -1 be on its own line.",
                        "  const { parent } = path;",
                        "  const shouldBreak = hasComment(",
                        "    node.left,",
                        "    CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "  );",
                        "  const shouldGroup =",
                        "    shouldBreak ||",
                        "    (!(isInsideParenthesis && node.type === \"LogicalExpression\") &&",
                        "      parent.type !== node.type &&",
                        "      node.left.type !== node.type &&",
                        "      node.right.type !== node.type);",
                        "",
                        "  parts.push(",
                        "    lineBeforeOperator ? \"\" : \" \",",
                        "    shouldGroup ? group(right, { shouldBreak }) : right",
                        "  );",
                        "",
                        "  // The root comments are already printed, but we need to manually print",
                        "  // the other ones since we don't call the normal print on BinaryExpression,",
                        "  // only for the left and right parts",
                        "  if (isNested && hasComment(node)) {",
                        "    const printed = cleanDoc(printComments(path, parts, options));",
                        "    /* c8 ignore next 3 */",
                        "    if (Array.isArray(printed) || printed.type === DOC_TYPE_FILL) {",
                        "      return getDocParts(printed);",
                        "    }",
                        "",
                        "    return [printed];",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldInlineLogicalExpression(node) {",
                        "  if (node.type !== \"LogicalExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    isObjectOrRecordExpression(node.right) &&",
                        "    node.right.properties.length > 0",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (isArrayOrTupleExpression(node.right) && node.right.elements.length > 0) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (isJsxElement(node.right)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "const isBitwiseOrExpression = (node) =>",
                        "  node.type === \"BinaryExpression\" && node.operator === \"|\";",
                        "",
                        "function isVueFilterSequenceExpression(path, options) {",
                        "  return (",
                        "    (options.parser === \"__vue_expression\" ||",
                        "      options.parser === \"__vue_ts_expression\") &&",
                        "    isBitwiseOrExpression(path.node) &&",
                        "    !path.hasAncestor(",
                        "      (node) => !isBitwiseOrExpression(node) && node.type !== \"JsExpressionRoot\"",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "export { printBinaryishExpression, shouldInlineLogicalExpression };"
                    ]
                },
                "block.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import { hardline, indent } from \"../../document/builders.js\";",
                        "import {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} from \"../utils/index.js\";",
                        "import { printStatementSequence } from \"./statement.js\";",
                        "",
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "/*",
                        "- `BlockStatement`",
                        "- `StaticBlock`",
                        "- `TSModuleBlock` (TypeScript)",
                        "*/",
                        "function printBlock(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  if (node.type === \"StaticBlock\") {",
                        "    parts.push(\"static \");",
                        "  }",
                        "",
                        "  parts.push(\"{\");",
                        "  const printed = printBlockBody(path, options, print);",
                        "  if (printed) {",
                        "    parts.push(indent([hardline, printed]), hardline);",
                        "  } else {",
                        "    const { parent } = path;",
                        "    const parentParent = path.grandparent;",
                        "    if (",
                        "      !(",
                        "        parent.type === \"ArrowFunctionExpression\" ||",
                        "        parent.type === \"FunctionExpression\" ||",
                        "        parent.type === \"FunctionDeclaration\" ||",
                        "        parent.type === \"ObjectMethod\" ||",
                        "        parent.type === \"ClassMethod\" ||",
                        "        parent.type === \"ClassPrivateMethod\" ||",
                        "        parent.type === \"ForStatement\" ||",
                        "        parent.type === \"WhileStatement\" ||",
                        "        parent.type === \"DoWhileStatement\" ||",
                        "        parent.type === \"DoExpression\" ||",
                        "        (parent.type === \"CatchClause\" && !parentParent.finalizer) ||",
                        "        parent.type === \"TSModuleDeclaration\" ||",
                        "        parent.type === \"TSDeclareFunction\" ||",
                        "        node.type === \"StaticBlock\"",
                        "      )",
                        "    ) {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  parts.push(\"}\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "/*",
                        "- `Program`",
                        "- `BlockStatement`",
                        "- `StaticBlock`",
                        "- `TSModuleBlock` (TypeScript)",
                        "*/",
                        "function printBlockBody(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  const hasDirectives = isNonEmptyArray(node.directives);",
                        "  const hasBody = node.body.some((node) => node.type !== \"EmptyStatement\");",
                        "  const hasDanglingComments = hasComment(node, CommentCheckFlags.Dangling);",
                        "",
                        "  if (!hasDirectives && !hasBody && !hasDanglingComments) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const parts = [];",
                        "  // Babel",
                        "  if (hasDirectives) {",
                        "    parts.push(printStatementSequence(path, options, print, \"directives\"));",
                        "",
                        "    if (hasBody || hasDanglingComments) {",
                        "      parts.push(hardline);",
                        "      if (isNextLineEmpty(node.directives.at(-1), options)) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  if (hasBody) {",
                        "    parts.push(printStatementSequence(path, options, print, \"body\"));",
                        "  }",
                        "",
                        "  if (hasDanglingComments) {",
                        "    parts.push(printDanglingComments(path, options));",
                        "  }",
                        "",
                        "  if (node.type === \"Program\" && path.parent?.type !== \"ModuleExpression\") {",
                        "    parts.push(hardline);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export { printBlock, printBlockBody };"
                    ]
                },
                "call-arguments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isFunctionCompositionArgs,",
                        "  isJsxElement,",
                        "  isLongCurriedCallExpression,",
                        "  shouldPrintComma,",
                        "  getCallArguments,",
                        "  iterateCallArgumentsPath,",
                        "  isNextLineEmpty,",
                        "  isCallExpression,",
                        "  isStringLiteral,",
                        "  isObjectProperty,",
                        "  getCallArgumentSelector,",
                        "  isSimpleCallArgument,",
                        "  isBinaryish,",
                        "  isRegExpLiteral,",
                        "  isSimpleType,",
                        "  isCallLikeExpression,",
                        "  isTSTypeExpression,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "",
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  conditionalGroup,",
                        "  ifBreak,",
                        "  breakParent,",
                        "} from \"../../document/builders.js\";",
                        "import { willBreak } from \"../../document/utils.js\";",
                        "",
                        "import { ArgExpansionBailout } from \"../../common/errors.js\";",
                        "import { isConciselyPrintedArray } from \"./array.js\";",
                        "",
                        "function printCallArguments(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  const args = getCallArguments(node);",
                        "  if (args.length === 0) {",
                        "    return [\"(\", printDanglingComments(path, options), \")\"];",
                        "  }",
                        "",
                        "  // useEffect(() => { ... }, [foo, bar, baz])",
                        "  if (isReactHookCallWithDepsArray(args)) {",
                        "    return [\"(\", print([\"arguments\", 0]), \", \", print([\"arguments\", 1]), \")\"];",
                        "  }",
                        "",
                        "  let anyArgEmptyLine = false;",
                        "  const lastArgIndex = args.length - 1;",
                        "  const printedArguments = [];",
                        "  iterateCallArgumentsPath(path, ({ node: arg }, index) => {",
                        "    let argDoc = print();",
                        "",
                        "    if (index === lastArgIndex) {",
                        "      // do nothing",
                        "    } else if (isNextLineEmpty(arg, options)) {",
                        "      anyArgEmptyLine = true;",
                        "      argDoc = [argDoc, \",\", hardline, hardline];",
                        "    } else {",
                        "      argDoc = [argDoc, \",\", line];",
                        "    }",
                        "",
                        "    printedArguments.push(argDoc);",
                        "  });",
                        "",
                        "  // Dynamic imports cannot have trailing commas",
                        "  const isDynamicImport =",
                        "    node.type === \"ImportExpression\" || node.callee.type === \"Import\";",
                        "  const maybeTrailingComma =",
                        "    !isDynamicImport && shouldPrintComma(options, \"all\") ? \",\" : \"\";",
                        "",
                        "  function allArgsBrokenOut() {",
                        "    return group(",
                        "      [\"(\", indent([line, ...printedArguments]), maybeTrailingComma, line, \")\"],",
                        "      { shouldBreak: true }",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    anyArgEmptyLine ||",
                        "    (path.parent.type !== \"Decorator\" && isFunctionCompositionArgs(args))",
                        "  ) {",
                        "    return allArgsBrokenOut();",
                        "  }",
                        "",
                        "  if (shouldExpandFirstArg(args)) {",
                        "    const tailArgs = printedArguments.slice(1);",
                        "    if (tailArgs.some(willBreak)) {",
                        "      return allArgsBrokenOut();",
                        "    }",
                        "    let firstArg;",
                        "    try {",
                        "      firstArg = print(getCallArgumentSelector(node, 0), {",
                        "        expandFirstArg: true,",
                        "      });",
                        "    } catch (caught) {",
                        "      if (caught instanceof ArgExpansionBailout) {",
                        "        return allArgsBrokenOut();",
                        "      }",
                        "      /* c8 ignore next */",
                        "      throw caught;",
                        "    }",
                        "",
                        "    if (willBreak(firstArg)) {",
                        "      return [",
                        "        breakParent,",
                        "        conditionalGroup([",
                        "          [\"(\", group(firstArg, { shouldBreak: true }), \", \", ...tailArgs, \")\"],",
                        "          allArgsBrokenOut(),",
                        "        ]),",
                        "      ];",
                        "    }",
                        "",
                        "    return conditionalGroup([",
                        "      [\"(\", firstArg, \", \", ...tailArgs, \")\"],",
                        "      [\"(\", group(firstArg, { shouldBreak: true }), \", \", ...tailArgs, \")\"],",
                        "      allArgsBrokenOut(),",
                        "    ]);",
                        "  }",
                        "",
                        "  if (shouldExpandLastArg(args, printedArguments, options)) {",
                        "    const headArgs = printedArguments.slice(0, -1);",
                        "    if (headArgs.some(willBreak)) {",
                        "      return allArgsBrokenOut();",
                        "    }",
                        "    let lastArg;",
                        "    try {",
                        "      lastArg = print(getCallArgumentSelector(node, -1), {",
                        "        expandLastArg: true,",
                        "      });",
                        "    } catch (caught) {",
                        "      if (caught instanceof ArgExpansionBailout) {",
                        "        return allArgsBrokenOut();",
                        "      }",
                        "      /* c8 ignore next */",
                        "      throw caught;",
                        "    }",
                        "",
                        "    if (willBreak(lastArg)) {",
                        "      return [",
                        "        breakParent,",
                        "        conditionalGroup([",
                        "          [\"(\", ...headArgs, group(lastArg, { shouldBreak: true }), \")\"],",
                        "          allArgsBrokenOut(),",
                        "        ]),",
                        "      ];",
                        "    }",
                        "",
                        "    return conditionalGroup([",
                        "      [\"(\", ...headArgs, lastArg, \")\"],",
                        "      [\"(\", ...headArgs, group(lastArg, { shouldBreak: true }), \")\"],",
                        "      allArgsBrokenOut(),",
                        "    ]);",
                        "  }",
                        "",
                        "  const contents = [",
                        "    \"(\",",
                        "    indent([softline, ...printedArguments]),",
                        "    ifBreak(maybeTrailingComma),",
                        "    softline,",
                        "    \")\",",
                        "  ];",
                        "  if (isLongCurriedCallExpression(path)) {",
                        "    // By not wrapping the arguments in a group, the printer prioritizes",
                        "    // breaking up these arguments rather than the args of the parent call.",
                        "    return contents;",
                        "  }",
                        "",
                        "  return group(contents, {",
                        "    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine,",
                        "  });",
                        "}",
                        "",
                        "function couldExpandArg(arg, arrowChainRecursion = false) {",
                        "  return (",
                        "    (isObjectOrRecordExpression(arg) &&",
                        "      (arg.properties.length > 0 || hasComment(arg))) ||",
                        "    (isArrayOrTupleExpression(arg) &&",
                        "      (arg.elements.length > 0 || hasComment(arg))) ||",
                        "    (arg.type === \"TSTypeAssertion\" && couldExpandArg(arg.expression)) ||",
                        "    (isTSTypeExpression(arg) && couldExpandArg(arg.expression)) ||",
                        "    arg.type === \"FunctionExpression\" ||",
                        "    (arg.type === \"ArrowFunctionExpression\" &&",
                        "      // we want to avoid breaking inside composite return types but not simple keywords",
                        "      // https://github.com/prettier/prettier/issues/4070",
                        "      // export class Thing implements OtherThing {",
                        "      //   do: (type: Type) => Provider<Prop> = memoize(",
                        "      //     (type: ObjectType): Provider<Opts> => {}",
                        "      //   );",
                        "      // }",
                        "      // https://github.com/prettier/prettier/issues/6099",
                        "      // app.get(\"/\", (req, res): void => {",
                        "      //   res.send(\"Hello World!\");",
                        "      // });",
                        "      (!arg.returnType ||",
                        "        !arg.returnType.typeAnnotation ||",
                        "        arg.returnType.typeAnnotation.type !== \"TSTypeReference\" ||",
                        "        // https://github.com/prettier/prettier/issues/7542",
                        "        isNonEmptyBlockStatement(arg.body)) &&",
                        "      (arg.body.type === \"BlockStatement\" ||",
                        "        (arg.body.type === \"ArrowFunctionExpression\" &&",
                        "          couldExpandArg(arg.body, true)) ||",
                        "        isObjectOrRecordExpression(arg.body) ||",
                        "        isArrayOrTupleExpression(arg.body) ||",
                        "        (!arrowChainRecursion &&",
                        "          (isCallExpression(arg.body) ||",
                        "            arg.body.type === \"ConditionalExpression\")) ||",
                        "        isJsxElement(arg.body))) ||",
                        "    arg.type === \"DoExpression\" ||",
                        "    arg.type === \"ModuleExpression\"",
                        "  );",
                        "}",
                        "",
                        "function shouldExpandLastArg(args, argDocs, options) {",
                        "  const lastArg = args.at(-1);",
                        "",
                        "  if (args.length === 1) {",
                        "    const lastArgDoc = argDocs.at(-1);",
                        "    if (lastArgDoc.label?.embed && lastArgDoc.label?.hug !== false) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  const penultimateArg = args.at(-2);",
                        "  return (",
                        "    !hasComment(lastArg, CommentCheckFlags.Leading) &&",
                        "    !hasComment(lastArg, CommentCheckFlags.Trailing) &&",
                        "    couldExpandArg(lastArg) &&",
                        "    // If the last two arguments are of the same type,",
                        "    // disable last element expansion.",
                        "    (!penultimateArg || penultimateArg.type !== lastArg.type) &&",
                        "    // useMemo(() => func(), [foo, bar, baz])",
                        "    (args.length !== 2 ||",
                        "      penultimateArg.type !== \"ArrowFunctionExpression\" ||",
                        "      !isArrayOrTupleExpression(lastArg)) &&",
                        "    !(args.length > 1 && isConciselyPrintedArray(lastArg, options))",
                        "  );",
                        "}",
                        "",
                        "function shouldExpandFirstArg(args) {",
                        "  if (args.length !== 2) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const [firstArg, secondArg] = args;",
                        "",
                        "  if (",
                        "    firstArg.type === \"ModuleExpression\" &&",
                        "    isTypeModuleObjectExpression(secondArg)",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return (",
                        "    !hasComment(firstArg) &&",
                        "    (firstArg.type === \"FunctionExpression\" ||",
                        "      (firstArg.type === \"ArrowFunctionExpression\" &&",
                        "        firstArg.body.type === \"BlockStatement\")) &&",
                        "    secondArg.type !== \"FunctionExpression\" &&",
                        "    secondArg.type !== \"ArrowFunctionExpression\" &&",
                        "    secondArg.type !== \"ConditionalExpression\" &&",
                        "    isHopefullyShortCallArgument(secondArg) &&",
                        "    !couldExpandArg(secondArg)",
                        "  );",
                        "}",
                        "",
                        "// A hack to fix most manifestations of",
                        "// https://github.com/prettier/prettier/issues/2456",
                        "// https://github.com/prettier/prettier/issues/5172",
                        "// https://github.com/prettier/prettier/issues/12892",
                        "// A proper (printWidth-aware) fix for those would require a complex change in the doc printer.",
                        "function isHopefullyShortCallArgument(node) {",
                        "  if (node.type === \"ParenthesizedExpression\") {",
                        "    return isHopefullyShortCallArgument(node.expression);",
                        "  }",
                        "",
                        "  if (isTSTypeExpression(node)) {",
                        "    let { typeAnnotation } = node;",
                        "    if (typeAnnotation.type === \"TSArrayType\") {",
                        "      typeAnnotation = typeAnnotation.elementType;",
                        "      if (typeAnnotation.type === \"TSArrayType\") {",
                        "        typeAnnotation = typeAnnotation.elementType;",
                        "      }",
                        "    }",
                        "    if (",
                        "      (typeAnnotation.type === \"GenericTypeAnnotation\" ||",
                        "        typeAnnotation.type === \"TSTypeReference\") &&",
                        "      typeAnnotation.typeParameters?.params.length === 1",
                        "    ) {",
                        "      typeAnnotation = typeAnnotation.typeParameters.params[0];",
                        "    }",
                        "    return (",
                        "      isSimpleType(typeAnnotation) && isSimpleCallArgument(node.expression, 1)",
                        "    );",
                        "  }",
                        "",
                        "  if (isCallLikeExpression(node) && getCallArguments(node).length > 1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isBinaryish(node)) {",
                        "    return (",
                        "      isSimpleCallArgument(node.left, 1) && isSimpleCallArgument(node.right, 1)",
                        "    );",
                        "  }",
                        "",
                        "  return isRegExpLiteral(node) || isSimpleCallArgument(node);",
                        "}",
                        "",
                        "function isReactHookCallWithDepsArray(args) {",
                        "  return (",
                        "    args.length === 2 &&",
                        "    args[0].type === \"ArrowFunctionExpression\" &&",
                        "    getFunctionParameters(args[0]).length === 0 &&",
                        "    args[0].body.type === \"BlockStatement\" &&",
                        "    args[1].type === \"ArrayExpression\" &&",
                        "    !args.some((arg) => hasComment(arg))",
                        "  );",
                        "}",
                        "",
                        "function isNonEmptyBlockStatement(node) {",
                        "  return (",
                        "    node.type === \"BlockStatement\" &&",
                        "    (node.body.some((node) => node.type !== \"EmptyStatement\") ||",
                        "      hasComment(node, CommentCheckFlags.Dangling))",
                        "  );",
                        "}",
                        "",
                        "// { type: \"module\" }",
                        "function isTypeModuleObjectExpression(node) {",
                        "  return (",
                        "    node.type === \"ObjectExpression\" &&",
                        "    node.properties.length === 1 &&",
                        "    isObjectProperty(node.properties[0]) &&",
                        "    node.properties[0].key.type === \"Identifier\" &&",
                        "    node.properties[0].key.name === \"type\" &&",
                        "    isStringLiteral(node.properties[0].value) &&",
                        "    node.properties[0].value.value === \"module\"",
                        "  );",
                        "}",
                        "",
                        "export default printCallArguments;"
                    ]
                },
                "call-expression.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { join, group } from \"../../document/builders.js\";",
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import {",
                        "  getCallArguments,",
                        "  isCallExpression,",
                        "  isMemberish,",
                        "  isStringLiteral,",
                        "  isTemplateOnItsOwnLine,",
                        "  isTestCall,",
                        "  iterateCallArgumentsPath,",
                        "} from \"../utils/index.js\";",
                        "import printMemberChain from \"./member-chain.js\";",
                        "import printCallArguments from \"./call-arguments.js\";",
                        "import { printOptionalToken, printFunctionTypeParameters } from \"./misc.js\";",
                        "",
                        "function printCallExpression(path, options, print) {",
                        "  const { node, parent } = path;",
                        "  const isNew = node.type === \"NewExpression\";",
                        "  const isDynamicImport = node.type === \"ImportExpression\";",
                        "",
                        "  const optional = printOptionalToken(path);",
                        "  const args = getCallArguments(node);",
                        "",
                        "  const isTemplateLiteralSingleArg =",
                        "    args.length === 1 && isTemplateOnItsOwnLine(args[0], options.originalText);",
                        "",
                        "  if (",
                        "    isTemplateLiteralSingleArg ||",
                        "    // Dangling comments are not handled, all these special cases should have arguments #9668",
                        "    (args.length > 0 &&",
                        "      !isNew &&",
                        "      !isDynamicImport &&",
                        "      // We want to keep CommonJS- and AMD-style require calls, and AMD-style",
                        "      // define calls, as a unit.",
                        "      // e.g. `define([\"some/lib\"], (lib) => {`",
                        "      (isCommonsJsOrAmdCall(node, parent) ||",
                        "        // Keep test declarations on a single line",
                        "        // e.g. `it('long name', () => {`",
                        "        isTestCall(node, parent)))",
                        "  ) {",
                        "    const printed = [];",
                        "    iterateCallArgumentsPath(path, () => {",
                        "      printed.push(print());",
                        "    });",
                        "    if (!(isTemplateLiteralSingleArg && printed[0].label?.embed)) {",
                        "      return [",
                        "        isNew ? \"new \" : \"\",",
                        "        print(\"callee\"),",
                        "        optional,",
                        "        printFunctionTypeParameters(path, options, print),",
                        "        \"(\",",
                        "        join(\", \", printed),",
                        "        \")\",",
                        "      ];",
                        "    }",
                        "  }",
                        "",
                        "  // We detect calls on member lookups and possibly print them in a",
                        "  // special chain format. See `printMemberChain` for more info.",
                        "  if (",
                        "    !isDynamicImport &&",
                        "    !isNew &&",
                        "    isMemberish(node.callee) &&",
                        "    !path.call((path) => pathNeedsParens(path, options), \"callee\")",
                        "  ) {",
                        "    return printMemberChain(path, options, print);",
                        "  }",
                        "",
                        "  const contents = [",
                        "    isNew ? \"new \" : \"\",",
                        "    isDynamicImport ? \"import\" : print(\"callee\"),",
                        "    optional,",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    printCallArguments(path, options, print),",
                        "  ];",
                        "",
                        "  // We group here when the callee is itself a call expression.",
                        "  // See `isLongCurriedCallExpression` for more info.",
                        "  if (isDynamicImport || isCallExpression(node.callee)) {",
                        "    return group(contents);",
                        "  }",
                        "",
                        "  return contents;",
                        "}",
                        "",
                        "function isCommonsJsOrAmdCall(node, parentNode) {",
                        "  if (node.callee.type !== \"Identifier\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (node.callee.name === \"require\") {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.callee.name === \"define\") {",
                        "    const args = getCallArguments(node);",
                        "    return (",
                        "      parentNode.type === \"ExpressionStatement\" &&",
                        "      (args.length === 1 ||",
                        "        (args.length === 2 && args[0].type === \"ArrayExpression\") ||",
                        "        (args.length === 3 &&",
                        "          isStringLiteral(args[0]) &&",
                        "          args[1].type === \"ArrayExpression\"))",
                        "    );",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "export { printCallExpression };"
                    ]
                },
                "class.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import createGroupIdMapper from \"../../utils/create-group-id-mapper.js\";",
                        "import {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "} from \"../../main/comments/print.js\";",
                        "import {",
                        "  join,",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  createTypeCheckFunction,",
                        "  isNextLineEmpty,",
                        "} from \"../utils/index.js\";",
                        "import { getTypeParametersGroupId } from \"./type-parameters.js\";",
                        "import { printMethod } from \"./function.js\";",
                        "import {",
                        "  printOptionalToken,",
                        "  printDefiniteToken,",
                        "  printDeclareToken,",
                        "  printAbstractToken,",
                        "  printTypeScriptAccessibilityToken,",
                        "} from \"./misc.js\";",
                        "import { printPropertyKey } from \"./property.js\";",
                        "import { printAssignment } from \"./assignment.js\";",
                        "import { printClassMemberDecorators } from \"./decorators.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "const isClassProperty = createTypeCheckFunction([",
                        "  \"ClassProperty\",",
                        "  \"PropertyDefinition\",",
                        "  \"ClassPrivateProperty\",",
                        "  \"ClassAccessorProperty\",",
                        "  \"AccessorProperty\",",
                        "  \"TSAbstractPropertyDefinition\",",
                        "  \"TSAbstractAccessorProperty\",",
                        "]);",
                        "",
                        "/*",
                        "- `ClassDeclaration`",
                        "- `ClassExpression`",
                        "- `DeclareClass`(flow)",
                        "*/",
                        "function printClass(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type {Doc[]} */",
                        "  const parts = [printDeclareToken(path), printAbstractToken(path), \"class\"];",
                        "",
                        "  // Keep old behaviour of extends in same line",
                        "  // If there is only on extends and there are not comments",
                        "  const groupMode =",
                        "    hasComment(node.id, CommentCheckFlags.Trailing) ||",
                        "    hasComment(node.typeParameters, CommentCheckFlags.Trailing) ||",
                        "    hasComment(node.superClass) ||",
                        "    isNonEmptyArray(node.extends) || // DeclareClass",
                        "    isNonEmptyArray(node.mixins) ||",
                        "    isNonEmptyArray(node.implements);",
                        "",
                        "  const partsGroup = [];",
                        "  const extendsParts = [];",
                        "",
                        "  if (node.id) {",
                        "    partsGroup.push(\" \", print(\"id\"));",
                        "  }",
                        "",
                        "  partsGroup.push(print(\"typeParameters\"));",
                        "",
                        "  if (node.superClass) {",
                        "    const printed = [",
                        "      printSuperClass(path, options, print),",
                        "      print(\"superTypeParameters\"),",
                        "    ];",
                        "    const printedWithComments = path.call(",
                        "      (superClass) => [\"extends \", printComments(superClass, printed, options)],",
                        "      \"superClass\"",
                        "    );",
                        "    if (groupMode) {",
                        "      extendsParts.push(line, group(printedWithComments));",
                        "    } else {",
                        "      extendsParts.push(\" \", printedWithComments);",
                        "    }",
                        "  } else {",
                        "    extendsParts.push(printHeritageClauses(path, options, print, \"extends\"));",
                        "  }",
                        "",
                        "  extendsParts.push(",
                        "    printHeritageClauses(path, options, print, \"mixins\"),",
                        "    printHeritageClauses(path, options, print, \"implements\")",
                        "  );",
                        "",
                        "  if (groupMode) {",
                        "    let printedPartsGroup;",
                        "    if (shouldIndentOnlyHeritageClauses(node)) {",
                        "      printedPartsGroup = [...partsGroup, indent(extendsParts)];",
                        "    } else {",
                        "      printedPartsGroup = indent([...partsGroup, extendsParts]);",
                        "    }",
                        "    parts.push(group(printedPartsGroup, { id: getHeritageGroupId(node) }));",
                        "  } else {",
                        "    parts.push(...partsGroup, ...extendsParts);",
                        "  }",
                        "",
                        "  parts.push(\" \", print(\"body\"));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "const getHeritageGroupId = createGroupIdMapper(\"heritageGroup\");",
                        "",
                        "function printHardlineAfterHeritage(node) {",
                        "  return ifBreak(hardline, \"\", { groupId: getHeritageGroupId(node) });",
                        "}",
                        "",
                        "function hasMultipleHeritage(node) {",
                        "  return (",
                        "    [\"extends\", \"mixins\", \"implements\"].reduce(",
                        "      (count, key) => count + (Array.isArray(node[key]) ? node[key].length : 0),",
                        "      node.superClass ? 1 : 0",
                        "    ) > 1",
                        "  );",
                        "}",
                        "",
                        "function shouldIndentOnlyHeritageClauses(node) {",
                        "  return (",
                        "    node.typeParameters &&",
                        "    !hasComment(",
                        "      node.typeParameters,",
                        "      CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "    ) &&",
                        "    !hasMultipleHeritage(node)",
                        "  );",
                        "}",
                        "",
                        "function printHeritageClauses(path, options, print, listName) {",
                        "  const { node } = path;",
                        "  if (!isNonEmptyArray(node[listName])) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const printedLeadingComments = printDanglingComments(path, options, {",
                        "    marker: listName,",
                        "  });",
                        "  return [",
                        "    shouldIndentOnlyHeritageClauses(node)",
                        "      ? ifBreak(\" \", line, {",
                        "          groupId: getTypeParametersGroupId(node.typeParameters),",
                        "        })",
                        "      : line,",
                        "    printedLeadingComments,",
                        "    printedLeadingComments && hardline,",
                        "    listName,",
                        "    group(indent([line, join([\",\", line], path.map(print, listName))])),",
                        "  ];",
                        "}",
                        "",
                        "function printSuperClass(path, options, print) {",
                        "  const printed = print(\"superClass\");",
                        "  const { parent } = path;",
                        "  if (parent.type === \"AssignmentExpression\") {",
                        "    return group(",
                        "      ifBreak([\"(\", indent([softline, printed]), softline, \")\"], printed)",
                        "    );",
                        "  }",
                        "  return printed;",
                        "}",
                        "",
                        "function printClassMethod(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  if (isNonEmptyArray(node.decorators)) {",
                        "    parts.push(printClassMemberDecorators(path, options, print));",
                        "  }",
                        "",
                        "  parts.push(printTypeScriptAccessibilityToken(node));",
                        "",
                        "  if (node.static) {",
                        "    parts.push(\"static \");",
                        "  }",
                        "",
                        "  parts.push(printAbstractToken(path));",
                        "",
                        "  if (node.override) {",
                        "    parts.push(\"override \");",
                        "  }",
                        "",
                        "  parts.push(printMethod(path, options, print));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printClassProperty(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "",
                        "  if (isNonEmptyArray(node.decorators)) {",
                        "    parts.push(printClassMemberDecorators(path, options, print));",
                        "  }",
                        "",
                        "  parts.push(printTypeScriptAccessibilityToken(node), printDeclareToken(path));",
                        "",
                        "  if (node.static) {",
                        "    parts.push(\"static \");",
                        "  }",
                        "",
                        "  parts.push(printAbstractToken(path));",
                        "",
                        "  if (node.override) {",
                        "    parts.push(\"override \");",
                        "  }",
                        "  if (node.readonly) {",
                        "    parts.push(\"readonly \");",
                        "  }",
                        "  if (node.variance) {",
                        "    parts.push(print(\"variance\"));",
                        "  }",
                        "  if (",
                        "    node.type === \"ClassAccessorProperty\" ||",
                        "    node.type === \"AccessorProperty\" ||",
                        "    node.type === \"TSAbstractAccessorProperty\"",
                        "  ) {",
                        "    parts.push(\"accessor \");",
                        "  }",
                        "  parts.push(",
                        "    printPropertyKey(path, options, print),",
                        "    printOptionalToken(path),",
                        "    printDefiniteToken(path),",
                        "    printTypeAnnotationProperty(path, print)",
                        "  );",
                        "",
                        "  const isAbstractProperty =",
                        "    node.type === \"TSAbstractPropertyDefinition\" ||",
                        "    node.type === \"TSAbstractAccessorProperty\";",
                        "",
                        "  return [",
                        "    printAssignment(",
                        "      path,",
                        "      options,",
                        "      print,",
                        "      parts,",
                        "      \" =\",",
                        "      isAbstractProperty ? undefined : \"value\"",
                        "    ),",
                        "    semi,",
                        "  ];",
                        "}",
                        "",
                        "function printClassBody(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  path.each(({ node, next, isLast }) => {",
                        "    parts.push(print());",
                        "",
                        "    if (",
                        "      !options.semi &&",
                        "      isClassProperty(node) &&",
                        "      shouldPrintSemicolonAfterClassProperty(node, next)",
                        "    ) {",
                        "      parts.push(\";\");",
                        "    }",
                        "",
                        "    if (!isLast) {",
                        "      parts.push(hardline);",
                        "",
                        "      if (isNextLineEmpty(node, options)) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, \"body\");",
                        "",
                        "  if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    parts.push(printDanglingComments(path, options));",
                        "  }",
                        "",
                        "  return [",
                        "    isNonEmptyArray(node.body) ? printHardlineAfterHeritage(path.parent) : \"\",",
                        "    \"{\",",
                        "    parts.length > 0 ? [indent([hardline, parts]), hardline] : \"\",",
                        "    \"}\",",
                        "  ];",
                        "}",
                        "",
                        "/**",
                        " * @returns {boolean}",
                        " */",
                        "function shouldPrintSemicolonAfterClassProperty(node, nextNode) {",
                        "  const { type, name } = node.key;",
                        "  if (",
                        "    !node.computed &&",
                        "    type === \"Identifier\" &&",
                        "    (name === \"static\" || name === \"get\" || name === \"set\") &&",
                        "    !node.value &&",
                        "    !node.typeAnnotation",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!nextNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    nextNode.static ||",
                        "    nextNode.accessibility // TypeScript",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!nextNode.computed) {",
                        "    const name = nextNode.key?.name;",
                        "    if (name === \"in\" || name === \"instanceof\") {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  // Flow variance sigil +/- requires semi if there's no",
                        "  // \"declare\" or \"static\" keyword before it.",
                        "  if (",
                        "    isClassProperty(nextNode) &&",
                        "    nextNode.variance &&",
                        "    !nextNode.static &&",
                        "    !nextNode.declare",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (nextNode.type) {",
                        "    case \"ClassProperty\":",
                        "    case \"PropertyDefinition\":",
                        "    case \"TSAbstractPropertyDefinition\":",
                        "      return nextNode.computed;",
                        "    case \"MethodDefinition\":",
                        "    case \"TSAbstractMethodDefinition\":",
                        "    case \"ClassMethod\":",
                        "    case \"ClassPrivateMethod\": {",
                        "      // Babel",
                        "      const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;",
                        "      if (isAsync || nextNode.kind === \"get\" || nextNode.kind === \"set\") {",
                        "        return false;",
                        "      }",
                        "",
                        "      const isGenerator = nextNode.value",
                        "        ? nextNode.value.generator",
                        "        : nextNode.generator;",
                        "      if (nextNode.computed || isGenerator) {",
                        "        return true;",
                        "      }",
                        "",
                        "      return false;",
                        "    }",
                        "",
                        "    case \"TSIndexSignature\":",
                        "      return true;",
                        "  }",
                        "",
                        "  /* c8 ignore next */",
                        "  return false;",
                        "}",
                        "",
                        "export {",
                        "  printClass,",
                        "  printClassMethod,",
                        "  printClassProperty,",
                        "  printHardlineAfterHeritage,",
                        "  printClassBody,",
                        "};"
                    ]
                },
                "comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { join, hardline } from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "",
                        "import { isLineComment } from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import isBlockComment from \"../utils/is-block-comment.js\";",
                        "import isIndentableBlockComment from \"../utils/is-indentable-block-comment.js\";",
                        "",
                        "function printComment(commentPath, options) {",
                        "  const comment = commentPath.node;",
                        "",
                        "  if (isLineComment(comment)) {",
                        "    // Supports `//`, `#!`, `<!--`, and `-->`",
                        "    return options.originalText",
                        "      .slice(locStart(comment), locEnd(comment))",
                        "      .trimEnd();",
                        "  }",
                        "",
                        "  if (isBlockComment(comment)) {",
                        "    if (isIndentableBlockComment(comment)) {",
                        "      return printIndentableBlockComment(comment);",
                        "    }",
                        "",
                        "    return [\"/*\", replaceEndOfLine(comment.value), \"*/\"];",
                        "  }",
                        "",
                        "  /* c8 ignore next */",
                        "  throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                        "}",
                        "",
                        "function printIndentableBlockComment(comment) {",
                        "  const lines = comment.value.split(\"\\n\");",
                        "",
                        "  return [",
                        "    \"/*\",",
                        "    join(",
                        "      hardline,",
                        "      lines.map((line, index) =>",
                        "        index === 0",
                        "          ? line.trimEnd()",
                        "          : \" \" + (index < lines.length - 1 ? line.trim() : line.trimStart())",
                        "      )",
                        "    ),",
                        "    \"*/\",",
                        "  ];",
                        "}",
                        "",
                        "export { printComment, isIndentableBlockComment };"
                    ]
                },
                "decorators.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isIgnored from \"../utils/is-ignored.js\";",
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  join,",
                        "  breakParent,",
                        "  group,",
                        "} from \"../../document/builders.js\";",
                        "import { locEnd, hasSameLocStart } from \"../loc.js\";",
                        "import { isExportDeclaration } from \"../utils/index.js\";",
                        "",
                        "function printClassMemberDecorators(path, options, print) {",
                        "  const { node } = path;",
                        "  return group([",
                        "    join(line, path.map(print, \"decorators\")),",
                        "    hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line,",
                        "  ]);",
                        "}",
                        "",
                        "function printDecoratorsBeforeExport(path, options, print) {",
                        "  // Only print decorators here if they were written before the export,",
                        "  // otherwise they are printed by the node.declaration",
                        "  if (!hasDecoratorsBeforeExport(path.node)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // Export declarations are responsible for printing any decorators",
                        "  // that logically apply to node.declaration.",
                        "  return [",
                        "    join(hardline, path.map(print, \"declaration\", \"decorators\")),",
                        "    hardline,",
                        "  ];",
                        "}",
                        "",
                        "function printDecorators(path, options, print) {",
                        "  const { node, parent } = path;",
                        "  const { decorators } = node;",
                        "",
                        "  if (",
                        "    !isNonEmptyArray(decorators) ||",
                        "    // If the parent node is an export declaration and the decorator",
                        "    // was written before the export, the export will be responsible",
                        "    // for printing the decorators.",
                        "    hasDecoratorsBeforeExport(parent) ||",
                        "    // Decorators already printed in ignored node",
                        "    isIgnored(path)",
                        "  ) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const shouldBreak =",
                        "    node.type === \"ClassExpression\" ||",
                        "    node.type === \"ClassDeclaration\" ||",
                        "    hasNewlineBetweenOrAfterDecorators(node, options);",
                        "",
                        "  return [",
                        "    path.key === \"declaration\" && isExportDeclaration(parent)",
                        "      ? hardline",
                        "      : shouldBreak",
                        "      ? breakParent",
                        "      : \"\",",
                        "    join(line, path.map(print, \"decorators\")),",
                        "    line,",
                        "  ];",
                        "}",
                        "",
                        "function hasNewlineBetweenOrAfterDecorators(node, options) {",
                        "  return node.decorators.some((decorator) =>",
                        "    hasNewline(options.originalText, locEnd(decorator))",
                        "  );",
                        "}",
                        "",
                        "function hasDecoratorsBeforeExport(node) {",
                        "  if (",
                        "    node.type !== \"ExportDefaultDeclaration\" &&",
                        "    node.type !== \"ExportNamedDeclaration\" &&",
                        "    node.type !== \"DeclareExportDeclaration\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const decorators = node.declaration?.decorators;",
                        "",
                        "  return isNonEmptyArray(decorators) && hasSameLocStart(node, decorators[0]);",
                        "}",
                        "",
                        "export {",
                        "  printDecorators,",
                        "  printClassMemberDecorators,",
                        "  printDecoratorsBeforeExport,",
                        "  hasDecoratorsBeforeExport,",
                        "};"
                    ]
                },
                "enum.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDeclareToken } from \"./misc.js\";",
                        "import { printObject } from \"./object.js\";",
                        "",
                        "function printEnumMembers(path, print, options) {",
                        "  return printObject(path, options, print);",
                        "}",
                        "",
                        "/*",
                        "- `EnumBooleanMember`(flow)",
                        "- `EnumNumberMember`(flow)",
                        "- `EnumStringMember`(flow)",
                        "- `EnumDefaultedMember`(flow)",
                        "- `TSEnumMember`(TypeScript)",
                        "*/",
                        "function printEnumMember(path, print) {",
                        "  const { node } = path;",
                        "",
                        "  let idDoc = print(\"id\");",
                        "",
                        "  if (node.computed) {",
                        "    idDoc = [\"[\", idDoc, \"]\"];",
                        "  }",
                        "",
                        "  let initializerDoc = \"\";",
                        "",
                        "  // `TSEnumMember`",
                        "  if (node.initializer) {",
                        "    initializerDoc = print(\"initializer\");",
                        "  }",
                        "",
                        "  // Flow",
                        "  if (node.init) {",
                        "    initializerDoc = print(\"init\");",
                        "  }",
                        "",
                        "  if (!initializerDoc) {",
                        "    return idDoc;",
                        "  }",
                        "",
                        "  return [idDoc, \" = \", initializerDoc];",
                        "}",
                        "",
                        "/*",
                        "- `EnumBooleanBody`(flow)",
                        "- `EnumNumberBody`(flow)",
                        "- `EnumStringBody`(flow)",
                        "- `EnumSymbolBody`(flow)",
                        "*/",
                        "function printEnumBody(path, print, options) {",
                        "  const { node } = path;",
                        "  let type;",
                        "",
                        "  if (node.type === \"EnumSymbolBody\" || node.explicitType) {",
                        "    switch (node.type) {",
                        "      case \"EnumBooleanBody\":",
                        "        type = \"boolean\";",
                        "        break;",
                        "      case \"EnumNumberBody\":",
                        "        type = \"number\";",
                        "        break;",
                        "      case \"EnumStringBody\":",
                        "        type = \"string\";",
                        "        break;",
                        "      case \"EnumSymbolBody\":",
                        "        type = \"symbol\";",
                        "        break;",
                        "    }",
                        "  }",
                        "",
                        "  return [type ? `of ${type} ` : \"\", printEnumMembers(path, print, options)];",
                        "}",
                        "",
                        "/*",
                        "- `DeclareEnum`(flow)",
                        "- `EnumDeclaration`(flow)",
                        "- `TSEnumDeclaration`(TypeScript)",
                        "*/",
                        "function printEnumDeclaration(path, print, options) {",
                        "  const { node } = path;",
                        "  return [",
                        "    printDeclareToken(path),",
                        "    node.const ? \"const \" : \"\",",
                        "    \"enum \",",
                        "    print(\"id\"),",
                        "    \" \",",
                        "    node.type === \"TSEnumDeclaration\"",
                        "      ? printEnumMembers(path, print, options)",
                        "      : print(\"body\"),",
                        "  ];",
                        "}",
                        "",
                        "export { printEnumDeclaration, printEnumMember, printEnumBody };"
                    ]
                },
                "expression-statement.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  markerForIfWithoutBlockAndSameLineComment,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "} from \"../utils/index.js\";",
                        "import {",
                        "  isSingleJsxExpressionStatementInMarkdown,",
                        "  isSingleVueEventBindingExpressionStatement,",
                        "  isVueEventBindingExpression,",
                        "} from \"./semicolon.js\";",
                        "",
                        "function printExpressionStatement(path, options, print) {",
                        "  const parts = [print(\"expression\")];",
                        "",
                        "  if (isSingleVueEventBindingExpressionStatement(path, options)) {",
                        "    if (isVueEventBindingExpression(path.node.expression)) {",
                        "      parts.push(\";\");",
                        "    }",
                        "  } else if (isSingleJsxExpressionStatementInMarkdown(path, options)) {",
                        "    // Do not append semicolon after the only JSX element in a program",
                        "  } else if (options.semi) {",
                        "    parts.push(\";\");",
                        "  }",
                        "",
                        "  if (",
                        "    hasComment(",
                        "      path.node,",
                        "      CommentCheckFlags.Dangling,",
                        "      ({ marker }) => marker === markerForIfWithoutBlockAndSameLineComment",
                        "    )",
                        "  ) {",
                        "    parts.push(",
                        "      \" \",",
                        "      printDanglingComments(path, options, {",
                        "        marker: markerForIfWithoutBlockAndSameLineComment,",
                        "      })",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export { printExpressionStatement };"
                    ]
                },
                "flow.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "import assert from \"node:assert\";",
                        "import printString from \"../../utils/print-string.js\";",
                        "import printNumber from \"../../utils/print-number.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import {",
                        "  isFunctionNotation,",
                        "  isGetterOrSetter,",
                        "  rawText,",
                        "} from \"../utils/index.js\";",
                        "import isFlowKeywordType from \"../utils/is-flow-keyword-type.js\";",
                        "import { printClass } from \"./class.js\";",
                        "import {",
                        "  printOpaqueType,",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printInferType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printIndexedAccessType,",
                        "  printRestType,",
                        "  printNamedTupleMember,",
                        "  printTypeAnnotation,",
                        "  printTypeAnnotationProperty,",
                        "  printArrayType,",
                        "  printTypeQuery,",
                        "} from \"./type-annotation.js\";",
                        "import { printInterface } from \"./interface.js\";",
                        "import { printTypeParameter, printTypeParameters } from \"./type-parameters.js\";",
                        "import { printExportDeclaration } from \"./module.js\";",
                        "import { printArray } from \"./array.js\";",
                        "import { printObject } from \"./object.js\";",
                        "import { printPropertyKey } from \"./property.js\";",
                        "import {",
                        "  printEnumDeclaration,",
                        "  printEnumBody,",
                        "  printEnumMember,",
                        "} from \"./enum.js\";",
                        "import { printBigInt } from \"./literal.js\";",
                        "import {",
                        "  printOptionalToken,",
                        "  printRestSpread,",
                        "  printDeclareToken,",
                        "} from \"./misc.js\";",
                        "import { printTernary } from \"./ternary.js\";",
                        "import { printFlowMappedTypeProperty } from \"./mapped-type.js\";",
                        "",
                        "function printFlow(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (isFlowKeywordType(node)) {",
                        "    // Flow keyword types ends with `TypeAnnotation`",
                        "    return node.type.slice(0, -14).toLowerCase();",
                        "  }",
                        "",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "",
                        "  switch (node.type) {",
                        "    case \"DeclareClass\":",
                        "      return printClass(path, options, print);",
                        "    case \"DeclareFunction\":",
                        "      return [",
                        "        printDeclareToken(path),",
                        "        \"function \",",
                        "        print(\"id\"),",
                        "        node.predicate ? \" \" : \"\",",
                        "        print(\"predicate\"),",
                        "        semi,",
                        "      ];",
                        "    case \"DeclareModule\":",
                        "      return [\"declare module \", print(\"id\"), \" \", print(\"body\")];",
                        "    case \"DeclareModuleExports\":",
                        "      return [",
                        "        \"declare module.exports\",",
                        "        printTypeAnnotationProperty(path, print),",
                        "        semi,",
                        "      ];",
                        "    case \"DeclareVariable\":",
                        "      return [",
                        "        printDeclareToken(path),",
                        "        // TODO: Only use `node.kind` when babel update AST",
                        "        node.kind ?? \"var\",",
                        "        \" \",",
                        "        print(\"id\"),",
                        "        semi,",
                        "      ];",
                        "    case \"DeclareExportDeclaration\":",
                        "    case \"DeclareExportAllDeclaration\":",
                        "      return printExportDeclaration(path, options, print);",
                        "    case \"DeclareOpaqueType\":",
                        "    case \"OpaqueType\":",
                        "      return printOpaqueType(path, options, print);",
                        "",
                        "    case \"DeclareTypeAlias\":",
                        "    case \"TypeAlias\":",
                        "      return printTypeAlias(path, options, print);",
                        "",
                        "    case \"IntersectionTypeAnnotation\":",
                        "      return printIntersectionType(path, options, print);",
                        "    case \"UnionTypeAnnotation\":",
                        "      return printUnionType(path, options, print);",
                        "    case \"ConditionalTypeAnnotation\":",
                        "      return printTernary(path, options, print);",
                        "    case \"InferTypeAnnotation\":",
                        "      return printInferType(path, options, print);",
                        "    case \"FunctionTypeAnnotation\":",
                        "      return printFunctionType(path, options, print);",
                        "    case \"TupleTypeAnnotation\":",
                        "      return printArray(path, options, print);",
                        "    case \"TupleTypeLabeledElement\":",
                        "      return printNamedTupleMember(path, options, print);",
                        "    case \"TupleTypeSpreadElement\":",
                        "      return printRestType(path, options, print);",
                        "    case \"GenericTypeAnnotation\":",
                        "      return [",
                        "        print(\"id\"),",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"IndexedAccessType\":",
                        "    case \"OptionalIndexedAccessType\":",
                        "      return printIndexedAccessType(path, options, print);",
                        "    // Type Annotations for Facebook Flow, typically stripped out or",
                        "    // transformed away before printing.",
                        "    case \"TypeAnnotation\":",
                        "      return printTypeAnnotation(path, options, print);",
                        "    case \"TypeParameter\":",
                        "      return printTypeParameter(path, options, print);",
                        "    case \"TypeofTypeAnnotation\":",
                        "      return printTypeQuery(path, print);",
                        "    case \"ExistsTypeAnnotation\":",
                        "      return \"*\";",
                        "    case \"ArrayTypeAnnotation\":",
                        "      return printArrayType(print);",
                        "",
                        "    case \"DeclareEnum\":",
                        "    case \"EnumDeclaration\":",
                        "      return printEnumDeclaration(path, print, options);",
                        "",
                        "    case \"EnumBooleanBody\":",
                        "    case \"EnumNumberBody\":",
                        "    case \"EnumStringBody\":",
                        "    case \"EnumSymbolBody\":",
                        "      return printEnumBody(path, print, options);",
                        "",
                        "    case \"EnumBooleanMember\":",
                        "    case \"EnumNumberMember\":",
                        "    case \"EnumStringMember\":",
                        "    case \"EnumDefaultedMember\":",
                        "      return printEnumMember(path, print);",
                        "",
                        "    case \"FunctionTypeParam\": {",
                        "      const name = node.name",
                        "        ? print(\"name\")",
                        "        : path.parent.this === node",
                        "        ? \"this\"",
                        "        : \"\";",
                        "      return [",
                        "        name,",
                        "        printOptionalToken(path),",
                        "        // `flow` doesn't wrap the `typeAnnotation` with `TypeAnnotation`, so the colon",
                        "        // needs to be added separately.",
                        "        name ? \": \" : \"\",",
                        "        print(\"typeAnnotation\"),",
                        "      ];",
                        "    }",
                        "",
                        "    case \"DeclareInterface\":",
                        "    case \"InterfaceDeclaration\":",
                        "    case \"InterfaceTypeAnnotation\":",
                        "      return printInterface(path, options, print);",
                        "    case \"ClassImplements\":",
                        "    case \"InterfaceExtends\":",
                        "      return [print(\"id\"), print(\"typeParameters\")];",
                        "    case \"NullableTypeAnnotation\":",
                        "      return [\"?\", print(\"typeAnnotation\")];",
                        "    case \"Variance\": {",
                        "      const { kind } = node;",
                        "      assert.ok(kind === \"plus\" || kind === \"minus\");",
                        "      return kind === \"plus\" ? \"+\" : \"-\";",
                        "    }",
                        "    case \"KeyofTypeAnnotation\":",
                        "      return [\"keyof \", print(\"argument\")];",
                        "    case \"ObjectTypeCallProperty\":",
                        "      return [node.static ? \"static \" : \"\", print(\"value\")];",
                        "    case \"ObjectTypeMappedTypeProperty\":",
                        "      return printFlowMappedTypeProperty(path, options, print);",
                        "    case \"ObjectTypeIndexer\":",
                        "      return [",
                        "        node.static ? \"static \" : \"\",",
                        "        node.variance ? print(\"variance\") : \"\",",
                        "        \"[\",",
                        "        print(\"id\"),",
                        "        node.id ? \": \" : \"\",",
                        "        print(\"key\"),",
                        "        \"]: \",",
                        "        print(\"value\"),",
                        "      ];",
                        "",
                        "    case \"ObjectTypeProperty\": {",
                        "      let modifier = \"\";",
                        "",
                        "      if (node.proto) {",
                        "        modifier = \"proto \";",
                        "      } else if (node.static) {",
                        "        modifier = \"static \";",
                        "      }",
                        "",
                        "      return [",
                        "        modifier,",
                        "        isGetterOrSetter(node) ? node.kind + \" \" : \"\",",
                        "        node.variance ? print(\"variance\") : \"\",",
                        "        printPropertyKey(path, options, print),",
                        "        printOptionalToken(path),",
                        "        isFunctionNotation(node) ? \"\" : \": \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    }",
                        "    case \"ObjectTypeAnnotation\":",
                        "      return printObject(path, options, print);",
                        "    case \"ObjectTypeInternalSlot\":",
                        "      return [",
                        "        node.static ? \"static \" : \"\",",
                        "        \"[[\",",
                        "        print(\"id\"),",
                        "        \"]]\",",
                        "        printOptionalToken(path),",
                        "        node.method ? \"\" : \": \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    // Same as `RestElement`",
                        "    case \"ObjectTypeSpreadProperty\":",
                        "      return printRestSpread(path, print);",
                        "    case \"QualifiedTypeofIdentifier\":",
                        "    case \"QualifiedTypeIdentifier\":",
                        "      return [print(\"qualification\"), \".\", print(\"id\")];",
                        "",
                        "    case \"NullLiteralTypeAnnotation\":",
                        "      return \"null\";",
                        "    case \"BooleanLiteralTypeAnnotation\":",
                        "      return String(node.value);",
                        "    case \"StringLiteralTypeAnnotation\":",
                        "      return replaceEndOfLine(printString(rawText(node), options));",
                        "    case \"NumberLiteralTypeAnnotation\":",
                        "      return printNumber(node.raw ?? node.extra.raw);",
                        "    case \"BigIntLiteralTypeAnnotation\":",
                        "      return printBigInt(node.raw ?? node.extra.raw);",
                        "    case \"TypeCastExpression\":",
                        "      return [",
                        "        \"(\",",
                        "        print(\"expression\"),",
                        "        printTypeAnnotationProperty(path, print),",
                        "        \")\",",
                        "      ];",
                        "",
                        "    case \"TypeParameterDeclaration\":",
                        "    case \"TypeParameterInstantiation\":",
                        "      return printTypeParameters(path, options, print, \"params\");",
                        "",
                        "    case \"InferredPredicate\":",
                        "      return \"%checks\";",
                        "    case \"DeclaredPredicate\":",
                        "      return [\"%checks(\", print(\"value\"), \")\"];",
                        "  }",
                        "}",
                        "",
                        "export { printFlow };"
                    ]
                },
                "function-parameters.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import getNextNonSpaceNonCommentCharacter from \"../../utils/get-next-non-space-non-comment-character.js\";",
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import { removeLines, willBreak } from \"../../document/utils.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  iterateFunctionParametersPath,",
                        "  isSimpleType,",
                        "  isTestCall,",
                        "  isTypeAnnotationAFunction,",
                        "  isObjectType,",
                        "  isObjectTypePropertyAFunction,",
                        "  hasRestParameter,",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  isNextLineEmpty,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import { locEnd } from \"../loc.js\";",
                        "import { ArgExpansionBailout } from \"../../common/errors.js\";",
                        "import { printFunctionTypeParameters } from \"./misc.js\";",
                        "",
                        "/** @typedef {import(\"../../common/ast-path.js\").default} AstPath */",
                        "",
                        "function printFunctionParameters(",
                        "  path,",
                        "  print,",
                        "  options,",
                        "  expandArg,",
                        "  printTypeParams",
                        ") {",
                        "  const functionNode = path.node;",
                        "  const parameters = getFunctionParameters(functionNode);",
                        "  const typeParams = printTypeParams",
                        "    ? printFunctionTypeParameters(path, options, print)",
                        "    : \"\";",
                        "",
                        "  if (parameters.length === 0) {",
                        "    return [",
                        "      typeParams,",
                        "      \"(\",",
                        "      printDanglingComments(path, options, {",
                        "        filter: (comment) =>",
                        "          getNextNonSpaceNonCommentCharacter(",
                        "            options.originalText,",
                        "            locEnd(comment)",
                        "          ) === \")\",",
                        "      }),",
                        "      \")\",",
                        "    ];",
                        "  }",
                        "",
                        "  const { parent } = path;",
                        "  const isParametersInTestCall = isTestCall(parent);",
                        "  const shouldHugParameters = shouldHugTheOnlyFunctionParameter(functionNode);",
                        "  const printed = [];",
                        "  iterateFunctionParametersPath(path, (parameterPath, index) => {",
                        "    const isLastParameter = index === parameters.length - 1;",
                        "    if (isLastParameter && functionNode.rest) {",
                        "      printed.push(\"...\");",
                        "    }",
                        "    printed.push(print());",
                        "    if (isLastParameter) {",
                        "      return;",
                        "    }",
                        "    printed.push(\",\");",
                        "    if (isParametersInTestCall || shouldHugParameters) {",
                        "      printed.push(\" \");",
                        "    } else if (isNextLineEmpty(parameters[index], options)) {",
                        "      printed.push(hardline, hardline);",
                        "    } else {",
                        "      printed.push(line);",
                        "    }",
                        "  });",
                        "",
                        "  // If the parent is a call with the first/last argument expansion and this is the",
                        "  // params of the first/last argument, we don't want the arguments to break and instead",
                        "  // want the whole expression to be on a new line.",
                        "  //",
                        "  // Good:                 Bad:",
                        "  //   verylongcall(         verylongcall((",
                        "  //     (a, b) => {           a,",
                        "  //     }                     b,",
                        "  //   )                     ) => {",
                        "  //                         })",
                        "  if (expandArg && !isDecoratedFunction(path)) {",
                        "    if (willBreak(typeParams) || willBreak(printed)) {",
                        "      // Removing lines in this case leads to broken or ugly output",
                        "      throw new ArgExpansionBailout();",
                        "    }",
                        "    return group([removeLines(typeParams), \"(\", removeLines(printed), \")\"]);",
                        "  }",
                        "",
                        "  // Single object destructuring should hug",
                        "  //",
                        "  // function({",
                        "  //   a,",
                        "  //   b,",
                        "  //   c",
                        "  // }) {}",
                        "  const hasNotParameterDecorator = parameters.every((node) => !node.decorators);",
                        "  if (shouldHugParameters && hasNotParameterDecorator) {",
                        "    return [typeParams, \"(\", ...printed, \")\"];",
                        "  }",
                        "",
                        "  // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`",
                        "  if (isParametersInTestCall) {",
                        "    return [typeParams, \"(\", ...printed, \")\"];",
                        "  }",
                        "",
                        "  const isFlowShorthandWithOneArg =",
                        "    (isObjectTypePropertyAFunction(parent) ||",
                        "      isTypeAnnotationAFunction(parent) ||",
                        "      parent.type === \"TypeAlias\" ||",
                        "      parent.type === \"UnionTypeAnnotation\" ||",
                        "      parent.type === \"TSUnionType\" ||",
                        "      parent.type === \"IntersectionTypeAnnotation\" ||",
                        "      (parent.type === \"FunctionTypeAnnotation\" &&",
                        "        parent.returnType === functionNode)) &&",
                        "    parameters.length === 1 &&",
                        "    parameters[0].name === null &&",
                        "    // `type q = (this: string) => void;`",
                        "    functionNode.this !== parameters[0] &&",
                        "    parameters[0].typeAnnotation &&",
                        "    functionNode.typeParameters === null &&",
                        "    isSimpleType(parameters[0].typeAnnotation) &&",
                        "    !functionNode.rest;",
                        "",
                        "  if (isFlowShorthandWithOneArg) {",
                        "    if (options.arrowParens === \"always\") {",
                        "      return [\"(\", ...printed, \")\"];",
                        "    }",
                        "    return printed;",
                        "  }",
                        "",
                        "  return [",
                        "    typeParams,",
                        "    \"(\",",
                        "    indent([softline, ...printed]),",
                        "    ifBreak(",
                        "      !hasRestParameter(functionNode) && shouldPrintComma(options, \"all\")",
                        "        ? \",\"",
                        "        : \"\"",
                        "    ),",
                        "    softline,",
                        "    \")\",",
                        "  ];",
                        "}",
                        "",
                        "function shouldHugTheOnlyFunctionParameter(node) {",
                        "  if (!node) {",
                        "    return false;",
                        "  }",
                        "  const parameters = getFunctionParameters(node);",
                        "  if (parameters.length !== 1) {",
                        "    return false;",
                        "  }",
                        "  const [parameter] = parameters;",
                        "  return (",
                        "    !hasComment(parameter) &&",
                        "    (parameter.type === \"ObjectPattern\" ||",
                        "      parameter.type === \"ArrayPattern\" ||",
                        "      (parameter.type === \"Identifier\" &&",
                        "        parameter.typeAnnotation &&",
                        "        (parameter.typeAnnotation.type === \"TypeAnnotation\" ||",
                        "          parameter.typeAnnotation.type === \"TSTypeAnnotation\") &&",
                        "        isObjectType(parameter.typeAnnotation.typeAnnotation)) ||",
                        "      (parameter.type === \"FunctionTypeParam\" &&",
                        "        isObjectType(parameter.typeAnnotation) &&",
                        "        parameter !== node.rest) ||",
                        "      (parameter.type === \"AssignmentPattern\" &&",
                        "        (parameter.left.type === \"ObjectPattern\" ||",
                        "          parameter.left.type === \"ArrayPattern\") &&",
                        "        (parameter.right.type === \"Identifier\" ||",
                        "          (isObjectOrRecordExpression(parameter.right) &&",
                        "            parameter.right.properties.length === 0) ||",
                        "          (isArrayOrTupleExpression(parameter.right) &&",
                        "            parameter.right.elements.length === 0))))",
                        "  );",
                        "}",
                        "",
                        "function getReturnTypeNode(functionNode) {",
                        "  let returnTypeNode;",
                        "  if (functionNode.returnType) {",
                        "    returnTypeNode = functionNode.returnType;",
                        "    if (returnTypeNode.typeAnnotation) {",
                        "      returnTypeNode = returnTypeNode.typeAnnotation;",
                        "    }",
                        "  } else if (functionNode.typeAnnotation) {",
                        "    returnTypeNode = functionNode.typeAnnotation;",
                        "  }",
                        "  return returnTypeNode;",
                        "}",
                        "",
                        "// When parameters are grouped, the return type annotation breaks first.",
                        "function shouldGroupFunctionParameters(functionNode, returnTypeDoc) {",
                        "  const returnTypeNode = getReturnTypeNode(functionNode);",
                        "  if (!returnTypeNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const typeParameters = functionNode.typeParameters?.params;",
                        "  if (typeParameters) {",
                        "    if (typeParameters.length > 1) {",
                        "      return false;",
                        "    }",
                        "    if (typeParameters.length === 1) {",
                        "      const typeParameter = typeParameters[0];",
                        "      if (typeParameter.constraint || typeParameter.default) {",
                        "        return false;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return (",
                        "    getFunctionParameters(functionNode).length === 1 &&",
                        "    (isObjectType(returnTypeNode) || willBreak(returnTypeDoc))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * The \"decorated function\" pattern.",
                        " * The arrow function should be kept hugged even if its signature breaks.",
                        " *",
                        " * ```",
                        " * const decoratedFn = decorator(param1, param2)((",
                        " *   ...",
                        " * ) => {",
                        " *   ...",
                        " * });",
                        " * ```",
                        " * @param {AstPath} path",
                        " */",
                        "function isDecoratedFunction(path) {",
                        "  return path.match(",
                        "    (node) =>",
                        "      node.type === \"ArrowFunctionExpression\" &&",
                        "      node.body.type === \"BlockStatement\",",
                        "    (node, name) => {",
                        "      if (",
                        "        node.type === \"CallExpression\" &&",
                        "        name === \"arguments\" &&",
                        "        node.arguments.length === 1 &&",
                        "        node.callee.type === \"CallExpression\"",
                        "      ) {",
                        "        const decorator = node.callee.callee;",
                        "        return (",
                        "          decorator.type === \"Identifier\" ||",
                        "          (decorator.type === \"MemberExpression\" &&",
                        "            !decorator.computed &&",
                        "            decorator.object.type === \"Identifier\" &&",
                        "            decorator.property.type === \"Identifier\")",
                        "        );",
                        "      }",
                        "      return false;",
                        "    },",
                        "    (node, name) =>",
                        "      (node.type === \"VariableDeclarator\" && name === \"init\") ||",
                        "      (node.type === \"ExportDefaultDeclaration\" && name === \"declaration\") ||",
                        "      (node.type === \"TSExportAssignment\" && name === \"expression\") ||",
                        "      (node.type === \"AssignmentExpression\" &&",
                        "        name === \"right\" &&",
                        "        node.left.type === \"MemberExpression\" &&",
                        "        node.left.object.type === \"Identifier\" &&",
                        "        node.left.object.name === \"module\" &&",
                        "        node.left.property.type === \"Identifier\" &&",
                        "        node.left.property.name === \"exports\"),",
                        "    (node) =>",
                        "      node.type !== \"VariableDeclaration\" ||",
                        "      (node.kind === \"const\" && node.declarations.length === 1)",
                        "  );",
                        "}",
                        "",
                        "function shouldBreakFunctionParameters(functionNode) {",
                        "  const parameters = getFunctionParameters(functionNode);",
                        "  return (",
                        "    parameters.length > 1 &&",
                        "    parameters.some((parameter) => parameter.type === \"TSParameterProperty\")",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  printFunctionParameters,",
                        "  shouldHugTheOnlyFunctionParameter,",
                        "  shouldGroupFunctionParameters,",
                        "  shouldBreakFunctionParameters,",
                        "};"
                    ]
                },
                "function.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "import assert from \"node:assert\";",
                        "import {",
                        "  printDanglingComments,",
                        "  printCommentsSeparately,",
                        "} from \"../../main/comments/print.js\";",
                        "import getNextNonSpaceNonCommentCharacterIndex from \"../../utils/get-next-non-space-non-comment-character-index.js\";",
                        "import {",
                        "  line,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  dedent,",
                        "  ifBreak,",
                        "  hardline,",
                        "  join,",
                        "  indentIfBreak,",
                        "} from \"../../document/builders.js\";",
                        "import { removeLines, willBreak } from \"../../document/utils.js\";",
                        "import { ArgExpansionBailout } from \"../../common/errors.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  hasLeadingOwnLineComment,",
                        "  isJsxElement,",
                        "  isTemplateOnItsOwnLine,",
                        "  shouldPrintComma,",
                        "  startsWithNoLookaheadToken,",
                        "  isBinaryish,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isCallLikeExpression,",
                        "  isCallExpression,",
                        "  getCallArguments,",
                        "  hasNakedLeftSide,",
                        "  getLeftSide,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import { locEnd } from \"../loc.js\";",
                        "import {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "  shouldBreakFunctionParameters,",
                        "} from \"./function-parameters.js\";",
                        "import { printPropertyKey } from \"./property.js\";",
                        "import { printFunctionTypeParameters, printDeclareToken } from \"./misc.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "const isMethod = (node) =>",
                        "  node.type === \"ObjectMethod\" ||",
                        "  node.type === \"ClassMethod\" ||",
                        "  node.type === \"ClassPrivateMethod\" ||",
                        "  node.type === \"MethodDefinition\" ||",
                        "  node.type === \"TSAbstractMethodDefinition\" ||",
                        "  node.type === \"TSDeclareMethod\" ||",
                        "  ((node.type === \"Property\" || node.type === \"ObjectProperty\") &&",
                        "    (node.method || node.kind === \"get\" || node.kind === \"set\"));",
                        "",
                        "const isMethodValue = (path) =>",
                        "  path.node.type === \"FunctionExpression\" &&",
                        "  path.key === \"value\" &&",
                        "  isMethod(path.parent);",
                        "",
                        "/*",
                        "- \"FunctionDeclaration\"",
                        "- \"FunctionExpression\"",
                        "- `TSDeclareFunction`(TypeScript)",
                        "*/",
                        "function printFunction(path, print, options, args) {",
                        "  if (isMethodValue(path)) {",
                        "    return printMethodValue(path, options, print);",
                        "  }",
                        "",
                        "  const { node } = path;",
                        "",
                        "  let expandArg = false;",
                        "  if (",
                        "    (node.type === \"FunctionDeclaration\" ||",
                        "      node.type === \"FunctionExpression\") &&",
                        "    args?.expandLastArg",
                        "  ) {",
                        "    const { parent } = path;",
                        "    if (",
                        "      isCallExpression(parent) &&",
                        "      (getCallArguments(parent).length > 1 ||",
                        "        getFunctionParameters(node).every(",
                        "          (param) => param.type === \"Identifier\" && !param.typeAnnotation",
                        "        ))",
                        "    ) {",
                        "      expandArg = true;",
                        "    }",
                        "  }",
                        "",
                        "  const parts = [",
                        "    printDeclareToken(path),",
                        "    node.async ? \"async \" : \"\",",
                        "    `function${node.generator ? \"*\" : \"\"} `,",
                        "    node.id ? print(\"id\") : \"\",",
                        "  ];",
                        "",
                        "  const parametersDoc = printFunctionParameters(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    expandArg",
                        "  );",
                        "  const returnTypeDoc = printReturnType(path, print);",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "",
                        "  parts.push(",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    group([",
                        "      shouldGroupParameters ? group(parametersDoc) : parametersDoc,",
                        "      returnTypeDoc,",
                        "    ]),",
                        "    node.body ? \" \" : \"\",",
                        "    print(\"body\")",
                        "  );",
                        "",
                        "  if (options.semi && (node.declare || !node.body)) {",
                        "    parts.push(\";\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "/*",
                        "- `ObjectMethod`",
                        "- `Property`",
                        "- `ObjectProperty`",
                        "- `ClassMethod`",
                        "- `ClassPrivateMethod`",
                        "- `MethodDefinition",
                        "- `TSAbstractMethodDefinition` (TypeScript)",
                        "- `TSDeclareMethod` (TypeScript)",
                        "*/",
                        "function printMethod(path, options, print) {",
                        "  const { node } = path;",
                        "  const { kind } = node;",
                        "  const value = node.value || node;",
                        "  const parts = [];",
                        "",
                        "  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {",
                        "    if (value.async) {",
                        "      parts.push(\"async \");",
                        "    }",
                        "  } else {",
                        "    assert.ok(kind === \"get\" || kind === \"set\");",
                        "",
                        "    parts.push(kind, \" \");",
                        "  }",
                        "",
                        "  // A `getter`/`setter` can't be a generator, but it's recoverable",
                        "  if (value.generator) {",
                        "    parts.push(\"*\");",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printPropertyKey(path, options, print),",
                        "    node.optional || node.key.optional ? \"?\" : \"\",",
                        "    node === value ? printMethodValue(path, options, print) : print(\"value\")",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printMethodValue(path, options, print) {",
                        "  const { node } = path;",
                        "  const parametersDoc = printFunctionParameters(path, print, options);",
                        "  const returnTypeDoc = printReturnType(path, print);",
                        "  const shouldBreakParameters = shouldBreakFunctionParameters(node);",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "  const parts = [",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    group([",
                        "      shouldBreakParameters",
                        "        ? group(parametersDoc, { shouldBreak: true })",
                        "        : shouldGroupParameters",
                        "        ? group(parametersDoc)",
                        "        : parametersDoc,",
                        "      returnTypeDoc,",
                        "    ]),",
                        "  ];",
                        "",
                        "  if (node.body) {",
                        "    parts.push(\" \", print(\"body\"));",
                        "  } else {",
                        "    parts.push(options.semi ? \";\" : \"\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrowFunctionSignature(path, options, print, args) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  if (node.async) {",
                        "    parts.push(\"async \");",
                        "  }",
                        "",
                        "  if (shouldPrintParamsWithoutParens(path, options)) {",
                        "    parts.push(print([\"params\", 0]));",
                        "  } else {",
                        "    const expandArg = args?.expandLastArg || args?.expandFirstArg;",
                        "    let returnTypeDoc = printReturnType(path, print);",
                        "    if (expandArg) {",
                        "      if (willBreak(returnTypeDoc)) {",
                        "        throw new ArgExpansionBailout();",
                        "      }",
                        "      returnTypeDoc = group(removeLines(returnTypeDoc));",
                        "    }",
                        "    parts.push(",
                        "      group([",
                        "        printFunctionParameters(",
                        "          path,",
                        "          print,",
                        "          options,",
                        "          expandArg,",
                        "          /* printTypeParams */ true",
                        "        ),",
                        "        returnTypeDoc,",
                        "      ])",
                        "    );",
                        "  }",
                        "",
                        "  const dangling = printDanglingComments(path, options, {",
                        "    filter(comment) {",
                        "      const nextCharacter = getNextNonSpaceNonCommentCharacterIndex(",
                        "        options.originalText,",
                        "        locEnd(comment)",
                        "      );",
                        "      return (",
                        "        nextCharacter !== false &&",
                        "        options.originalText.slice(nextCharacter, nextCharacter + 2) === \"=>\"",
                        "      );",
                        "    },",
                        "  });",
                        "  if (dangling) {",
                        "    parts.push(\" \", dangling);",
                        "  }",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrowChain(",
                        "  path,",
                        "  args,",
                        "  signatures,",
                        "  shouldBreak,",
                        "  bodyDoc,",
                        "  tailNode",
                        ") {",
                        "  const { parent, key } = path;",
                        "  const isCallee = isCallLikeExpression(parent) && key === \"callee\";",
                        "  const isAssignmentRhs = Boolean(args?.assignmentLayout);",
                        "  const shouldPutBodyOnSeparateLine =",
                        "    tailNode.body.type !== \"BlockStatement\" &&",
                        "    !isObjectOrRecordExpression(tailNode.body) &&",
                        "    tailNode.body.type !== \"SequenceExpression\";",
                        "  const shouldBreakBeforeChain =",
                        "    (isCallee && shouldPutBodyOnSeparateLine) ||",
                        "    args?.assignmentLayout === \"chain-tail-arrow-chain\";",
                        "",
                        "  const groupId = Symbol(\"arrow-chain\");",
                        "",
                        "  if ((isCallLikeExpression(parent) && !isCallee) || isBinaryish(parent)) {",
                        "    signatures = [dedent(signatures[0]), ...signatures.slice(1)];",
                        "  }",
                        "",
                        "  // We handle sequence expressions as the body of arrows specially,",
                        "  // so that the required parentheses end up on their own lines.",
                        "  if (tailNode.body.type === \"SequenceExpression\") {",
                        "    bodyDoc = group([\"(\", indent([softline, bodyDoc]), softline, \")\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    group(",
                        "      indent([",
                        "        isCallee || isAssignmentRhs ? softline : \"\",",
                        "        group(join([\" =>\", line], signatures), { shouldBreak }),",
                        "      ]),",
                        "      { id: groupId, shouldBreak: shouldBreakBeforeChain }",
                        "    ),",
                        "    \" =>\",",
                        "    indentIfBreak(",
                        "      shouldPutBodyOnSeparateLine ? indent([line, bodyDoc]) : [\" \", bodyDoc],",
                        "      { groupId }",
                        "    ),",
                        "    isCallee ? ifBreak(softline, \"\", { groupId }) : \"\",",
                        "  ]);",
                        "}",
                        "",
                        "function printArrowFunction(path, options, print, args) {",
                        "  let { node } = path;",
                        "  /** @type {Doc[]} */",
                        "  const signatures = [];",
                        "  const body = [];",
                        "  let chainShouldBreak = false;",
                        "",
                        "  (function rec() {",
                        "    const doc = printArrowFunctionSignature(path, options, print, args);",
                        "    if (signatures.length === 0) {",
                        "      signatures.push(doc);",
                        "    } else {",
                        "      const { leading, trailing } = printCommentsSeparately(path, options);",
                        "      signatures.push([leading, doc]);",
                        "      body.unshift(trailing);",
                        "    }",
                        "",
                        "    chainShouldBreak =",
                        "      chainShouldBreak ||",
                        "      // Always break the chain if:",
                        "      (node.returnType && getFunctionParameters(node).length > 0) ||",
                        "      node.typeParameters ||",
                        "      getFunctionParameters(node).some((param) => param.type !== \"Identifier\");",
                        "",
                        "    if (node.body.type !== \"ArrowFunctionExpression\" || args?.expandLastArg) {",
                        "      body.unshift(print(\"body\", args));",
                        "    } else {",
                        "      node = node.body;",
                        "      path.call(rec, \"body\");",
                        "    }",
                        "  })();",
                        "",
                        "  if (signatures.length > 1) {",
                        "    return printArrowChain(",
                        "      path,",
                        "      args,",
                        "      signatures,",
                        "      chainShouldBreak,",
                        "      body,",
                        "      node",
                        "    );",
                        "  }",
                        "",
                        "  const parts = signatures;",
                        "  parts.push(\" =>\");",
                        "",
                        "  // We want to always keep these types of nodes on the same line",
                        "  // as the arrow.",
                        "  if (",
                        "    !hasLeadingOwnLineComment(options.originalText, node.body) &&",
                        "    (isArrayOrTupleExpression(node.body) ||",
                        "      isObjectOrRecordExpression(node.body) ||",
                        "      node.body.type === \"BlockStatement\" ||",
                        "      isJsxElement(node.body) ||",
                        "      (body[0].label?.hug !== false &&",
                        "        (body[0].label?.embed ||",
                        "          isTemplateOnItsOwnLine(node.body, options.originalText))) ||",
                        "      node.body.type === \"ArrowFunctionExpression\" ||",
                        "      node.body.type === \"DoExpression\")",
                        "  ) {",
                        "    return group([...parts, \" \", body]);",
                        "  }",
                        "",
                        "  // We handle sequence expressions as the body of arrows specially,",
                        "  // so that the required parentheses end up on their own lines.",
                        "  if (node.body.type === \"SequenceExpression\") {",
                        "    return group([",
                        "      ...parts,",
                        "      group([\" (\", indent([softline, body]), softline, \")\"]),",
                        "    ]);",
                        "  }",
                        "",
                        "  // if the arrow function is expanded as last argument, we are adding a",
                        "  // level of indentation and need to add a softline to align the closing )",
                        "  // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)",
                        "  // we should align the expression's closing } with the line with the opening {.",
                        "  const shouldAddSoftLine =",
                        "    (args?.expandLastArg || path.parent.type === \"JSXExpressionContainer\") &&",
                        "    !hasComment(node);",
                        "",
                        "  const printTrailingComma =",
                        "    args?.expandLastArg && shouldPrintComma(options, \"all\");",
                        "",
                        "  // In order to avoid confusion between",
                        "  // a => a ? a : a",
                        "  // a <= a ? a : a",
                        "  const shouldAddParens =",
                        "    node.body.type === \"ConditionalExpression\" &&",
                        "    !startsWithNoLookaheadToken(",
                        "      node.body,",
                        "      (node) => node.type === \"ObjectExpression\"",
                        "    );",
                        "",
                        "  return group([",
                        "    ...parts,",
                        "    group([",
                        "      indent([",
                        "        line,",
                        "        shouldAddParens ? ifBreak(\"\", \"(\") : \"\",",
                        "        body,",
                        "        shouldAddParens ? ifBreak(\"\", \")\") : \"\",",
                        "      ]),",
                        "      shouldAddSoftLine",
                        "        ? [ifBreak(printTrailingComma ? \",\" : \"\"), softline]",
                        "        : \"\",",
                        "    ]),",
                        "  ]);",
                        "}",
                        "",
                        "function canPrintParamsWithoutParens(node) {",
                        "  const parameters = getFunctionParameters(node);",
                        "  return (",
                        "    parameters.length === 1 &&",
                        "    !node.typeParameters &&",
                        "    !hasComment(node, CommentCheckFlags.Dangling) &&",
                        "    parameters[0].type === \"Identifier\" &&",
                        "    !parameters[0].typeAnnotation &&",
                        "    !hasComment(parameters[0]) &&",
                        "    !parameters[0].optional &&",
                        "    !node.predicate &&",
                        "    !node.returnType",
                        "  );",
                        "}",
                        "",
                        "function shouldPrintParamsWithoutParens(path, options) {",
                        "  if (options.arrowParens === \"always\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (options.arrowParens === \"avoid\") {",
                        "    const { node } = path;",
                        "    return canPrintParamsWithoutParens(node);",
                        "  }",
                        "",
                        "  // Fallback default; should be unreachable",
                        "  /* c8 ignore next */",
                        "  return false;",
                        "}",
                        "",
                        "/** @returns {Doc} */",
                        "function printReturnType(path, print) {",
                        "  const { node } = path;",
                        "  const returnType = printTypeAnnotationProperty(path, print, \"returnType\");",
                        "",
                        "  const parts = [returnType];",
                        "",
                        "  if (node.predicate) {",
                        "    // The return type will already add the colon, but otherwise we",
                        "    // need to do it ourselves",
                        "    parts.push(node.returnType ? \" \" : \": \", print(\"predicate\"));",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "// `ReturnStatement` and `ThrowStatement`",
                        "function printReturnOrThrowArgument(path, options, print) {",
                        "  const { node } = path;",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const parts = [];",
                        "",
                        "  if (node.argument) {",
                        "    let argumentDoc = print(\"argument\");",
                        "",
                        "    if (returnArgumentHasLeadingComment(options, node.argument)) {",
                        "      argumentDoc = [\"(\", indent([hardline, argumentDoc]), hardline, \")\"];",
                        "    } else if (",
                        "      isBinaryish(node.argument) ||",
                        "      node.argument.type === \"SequenceExpression\"",
                        "    ) {",
                        "      argumentDoc = group([",
                        "        ifBreak(\"(\"),",
                        "        indent([softline, argumentDoc]),",
                        "        softline,",
                        "        ifBreak(\")\"),",
                        "      ]);",
                        "    }",
                        "",
                        "    parts.push(\" \", argumentDoc);",
                        "  }",
                        "",
                        "  const hasDanglingComments = hasComment(node, CommentCheckFlags.Dangling);",
                        "  const shouldPrintSemiBeforeComments =",
                        "    semi &&",
                        "    hasDanglingComments &&",
                        "    hasComment(node, CommentCheckFlags.Last | CommentCheckFlags.Line);",
                        "",
                        "  if (shouldPrintSemiBeforeComments) {",
                        "    parts.push(semi);",
                        "  }",
                        "",
                        "  if (hasDanglingComments) {",
                        "    parts.push(\" \", printDanglingComments(path, options));",
                        "  }",
                        "",
                        "  if (!shouldPrintSemiBeforeComments) {",
                        "    parts.push(semi);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printReturnStatement(path, options, print) {",
                        "  return [\"return\", printReturnOrThrowArgument(path, options, print)];",
                        "}",
                        "",
                        "function printThrowStatement(path, options, print) {",
                        "  return [\"throw\", printReturnOrThrowArgument(path, options, print)];",
                        "}",
                        "",
                        "// This recurses the return argument, looking for the first token",
                        "// (the leftmost leaf node) and, if it (or its parents) has any",
                        "// leadingComments, returns true (so it can be wrapped in parens).",
                        "function returnArgumentHasLeadingComment(options, argument) {",
                        "  if (hasLeadingOwnLineComment(options.originalText, argument)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (hasNakedLeftSide(argument)) {",
                        "    let leftMost = argument;",
                        "    let newLeftMost;",
                        "    while ((newLeftMost = getLeftSide(leftMost))) {",
                        "      leftMost = newLeftMost;",
                        "",
                        "      if (hasLeadingOwnLineComment(options.originalText, leftMost)) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "export {",
                        "  printFunction,",
                        "  printArrowFunction,",
                        "  printMethod,",
                        "  printReturnStatement,",
                        "  printThrowStatement,",
                        "  printMethodValue,",
                        "  shouldPrintParamsWithoutParens,",
                        "};"
                    ]
                },
                "html-binding.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  join,",
                        "  line,",
                        "  group,",
                        "  softline,",
                        "  indent,",
                        "} from \"../../document/builders.js\";",
                        "",
                        "function printHtmlBinding(path, options, print) {",
                        "  const { node, isRoot } = path;",
                        "",
                        "  if (isRoot) {",
                        "    options.__onHtmlBindingRoot?.(node, options);",
                        "  }",
                        "",
                        "  if (node.type !== \"File\") {",
                        "    return;",
                        "  }",
                        "",
                        "  if (options.__isVueBindings || options.__isVueForBindingLeft) {",
                        "    const parameterDocs = path.map(print, \"program\", \"body\", 0, \"params\");",
                        "",
                        "    if (parameterDocs.length === 1) {",
                        "      return parameterDocs[0];",
                        "    }",
                        "",
                        "    const doc = join([\",\", line], parameterDocs);",
                        "",
                        "    return options.__isVueForBindingLeft",
                        "      ? [\"(\", indent([softline, group(doc)]), softline, \")\"]",
                        "      : doc;",
                        "  }",
                        "}",
                        "",
                        "export { printHtmlBinding };"
                    ]
                },
                "interface.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import { join, line, group, indent, ifBreak } from \"../../document/builders.js\";",
                        "import { hasComment, identity, CommentCheckFlags } from \"../utils/index.js\";",
                        "import { getTypeParametersGroupId } from \"./type-parameters.js\";",
                        "import { printDeclareToken } from \"./misc.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "/*",
                        "- `TSInterfaceDeclaration`(TypeScript)",
                        "- `DeclareInterface`(flow)",
                        "- `InterfaceDeclaration`(flow)",
                        "- `InterfaceTypeAnnotation`(flow)",
                        "*/",
                        "function printInterface(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type {Doc[]} */",
                        "  const parts = [printDeclareToken(path), \"interface\"];",
                        "",
                        "  const partsGroup = [];",
                        "  const extendsParts = [];",
                        "",
                        "  if (node.type !== \"InterfaceTypeAnnotation\") {",
                        "    partsGroup.push(\" \", print(\"id\"), print(\"typeParameters\"));",
                        "  }",
                        "",
                        "  const shouldIndentOnlyHeritageClauses =",
                        "    node.typeParameters &&",
                        "    !hasComment(",
                        "      node.typeParameters,",
                        "      CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "    );",
                        "",
                        "  if (isNonEmptyArray(node.extends)) {",
                        "    extendsParts.push(",
                        "      shouldIndentOnlyHeritageClauses",
                        "        ? ifBreak(\" \", line, {",
                        "            groupId: getTypeParametersGroupId(node.typeParameters),",
                        "          })",
                        "        : line,",
                        "      \"extends \",",
                        "      (node.extends.length === 1 ? identity : indent)(",
                        "        join([\",\", line], path.map(print, \"extends\"))",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    hasComment(node.id, CommentCheckFlags.Trailing) ||",
                        "    isNonEmptyArray(node.extends)",
                        "  ) {",
                        "    if (shouldIndentOnlyHeritageClauses) {",
                        "      parts.push(group([...partsGroup, indent(extendsParts)]));",
                        "    } else {",
                        "      parts.push(group(indent([...partsGroup, ...extendsParts])));",
                        "    }",
                        "  } else {",
                        "    parts.push(...partsGroup, ...extendsParts);",
                        "  }",
                        "",
                        "  parts.push(\" \", print(\"body\"));",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "export { printInterface };"
                    ]
                },
                "jsx.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "} from \"../../main/comments/print.js\";",
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  conditionalGroup,",
                        "  fill,",
                        "  ifBreak,",
                        "  lineSuffixBoundary,",
                        "  join,",
                        "  cursor,",
                        "} from \"../../document/builders.js\";",
                        "import { willBreak, replaceEndOfLine } from \"../../document/utils.js\";",
                        "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                        "import getPreferredQuote from \"../../utils/get-preferred-quote.js\";",
                        "import WhitespaceUtils from \"../../utils/whitespace-utils.js\";",
                        "import {",
                        "  isJsxElement,",
                        "  rawText,",
                        "  isCallExpression,",
                        "  isStringLiteral,",
                        "  isBinaryish,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  hasNodeIgnoreComment,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import { willPrintOwnComments } from \"../comments/printer-methods.js\";",
                        "",
                        "/*",
                        "Only the following are treated as whitespace inside JSX.",
                        "",
                        "- U+0020 SPACE",
                        "- U+000A LF",
                        "- U+000D CR",
                        "- U+0009 TAB",
                        "*/",
                        "const jsxWhitespaceUtils = new WhitespaceUtils(\" \\n\\r\\t\");",
                        "",
                        "const isEmptyStringOrAnyLine = (doc) =>",
                        "  doc === \"\" || doc === line || doc === hardline || doc === softline;",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " * @typedef {import(\"../types/estree.js\").JSXElement} JSXElement",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "// JSX expands children from the inside-out, instead of the outside-in.",
                        "// This is both to break children before attributes,",
                        "// and to ensure that when children break, their parents do as well.",
                        "//",
                        "// Any element that is written without any newlines and fits on a single line",
                        "// is left that way.",
                        "// Not only that, any user-written-line containing multiple JSX siblings",
                        "// should also be kept on one line if possible,",
                        "// so each user-written-line is wrapped in its own group.",
                        "//",
                        "// Elements that contain newlines or don't fit on a single line (recursively)",
                        "// are fully-split, using hardline and shouldBreak: true.",
                        "//",
                        "// To support that case properly, all leading and trailing spaces",
                        "// are stripped from the list of children, and replaced with a single hardline.",
                        "function printJsxElementInternal(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (node.type === \"JSXElement\" && isEmptyJsxElement(node)) {",
                        "    return [print(\"openingElement\"), print(\"closingElement\")];",
                        "  }",
                        "",
                        "  const openingLines =",
                        "    node.type === \"JSXElement\"",
                        "      ? print(\"openingElement\")",
                        "      : print(\"openingFragment\");",
                        "  const closingLines =",
                        "    node.type === \"JSXElement\"",
                        "      ? print(\"closingElement\")",
                        "      : print(\"closingFragment\");",
                        "",
                        "  if (",
                        "    node.children.length === 1 &&",
                        "    node.children[0].type === \"JSXExpressionContainer\" &&",
                        "    (node.children[0].expression.type === \"TemplateLiteral\" ||",
                        "      node.children[0].expression.type === \"TaggedTemplateExpression\")",
                        "  ) {",
                        "    return [openingLines, ...path.map(print, \"children\"), closingLines];",
                        "  }",
                        "",
                        "  // Convert `{\" \"}` to text nodes containing a space.",
                        "  // This makes it easy to turn them into `jsxWhitespace` which",
                        "  // can then print as either a space or `{\" \"}` when breaking.",
                        "  node.children = node.children.map((child) => {",
                        "    if (isJsxWhitespaceExpression(child)) {",
                        "      return {",
                        "        type: \"JSXText\",",
                        "        value: \" \",",
                        "        raw: \" \",",
                        "      };",
                        "    }",
                        "    return child;",
                        "  });",
                        "",
                        "  const containsTag = node.children.some(isJsxElement);",
                        "  const containsMultipleExpressions =",
                        "    node.children.filter((child) => child.type === \"JSXExpressionContainer\")",
                        "      .length > 1;",
                        "  const containsMultipleAttributes =",
                        "    node.type === \"JSXElement\" && node.openingElement.attributes.length > 1;",
                        "",
                        "  // Record any breaks. Should never go from true to false, only false to true.",
                        "  let forcedBreak =",
                        "    willBreak(openingLines) ||",
                        "    containsTag ||",
                        "    containsMultipleAttributes ||",
                        "    containsMultipleExpressions;",
                        "",
                        "  const isMdxBlock = path.parent.rootMarker === \"mdx\";",
                        "",
                        "  const rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';",
                        "  const jsxWhitespace = isMdxBlock",
                        "    ? \" \"",
                        "    : ifBreak([rawJsxWhitespace, softline], \" \");",
                        "",
                        "  const isFacebookTranslationTag = node.openingElement?.name?.name === \"fbt\";",
                        "",
                        "  const children = printJsxChildren(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    jsxWhitespace,",
                        "    isFacebookTranslationTag",
                        "  );",
                        "",
                        "  const containsText = node.children.some((child) =>",
                        "    isMeaningfulJsxText(child)",
                        "  );",
                        "",
                        "  // We can end up we multiple whitespace elements with empty string",
                        "  // content between them.",
                        "  // We need to remove empty whitespace and softlines before JSX whitespace",
                        "  // to get the correct output.",
                        "  for (let i = children.length - 2; i >= 0; i--) {",
                        "    const isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";",
                        "    const isPairOfHardlines =",
                        "      children[i] === hardline &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === hardline;",
                        "    const isLineFollowedByJsxWhitespace =",
                        "      (children[i] === softline || children[i] === hardline) &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === jsxWhitespace;",
                        "    const isJsxWhitespaceFollowedByLine =",
                        "      children[i] === jsxWhitespace &&",
                        "      children[i + 1] === \"\" &&",
                        "      (children[i + 2] === softline || children[i + 2] === hardline);",
                        "    const isDoubleJsxWhitespace =",
                        "      children[i] === jsxWhitespace &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === jsxWhitespace;",
                        "    const isPairOfHardOrSoftLines =",
                        "      (children[i] === softline &&",
                        "        children[i + 1] === \"\" &&",
                        "        children[i + 2] === hardline) ||",
                        "      (children[i] === hardline &&",
                        "        children[i + 1] === \"\" &&",
                        "        children[i + 2] === softline);",
                        "",
                        "    if (",
                        "      (isPairOfHardlines && containsText) ||",
                        "      isPairOfEmptyStrings ||",
                        "      isLineFollowedByJsxWhitespace ||",
                        "      isDoubleJsxWhitespace ||",
                        "      isPairOfHardOrSoftLines",
                        "    ) {",
                        "      children.splice(i, 2);",
                        "    } else if (isJsxWhitespaceFollowedByLine) {",
                        "      children.splice(i + 1, 2);",
                        "    }",
                        "  }",
                        "",
                        "  // Trim trailing lines (or empty strings)",
                        "  while (children.length > 0 && isEmptyStringOrAnyLine(children.at(-1))) {",
                        "    children.pop();",
                        "  }",
                        "",
                        "  // Trim leading lines (or empty strings)",
                        "  while (",
                        "    children.length > 1 &&",
                        "    isEmptyStringOrAnyLine(children[0]) &&",
                        "    isEmptyStringOrAnyLine(children[1])",
                        "  ) {",
                        "    children.shift();",
                        "    children.shift();",
                        "  }",
                        "",
                        "  // Tweak how we format children if outputting this element over multiple lines.",
                        "  // Also detect whether we will force this element to output over multiple lines.",
                        "  const multilineChildren = [];",
                        "  for (const [i, child] of children.entries()) {",
                        "    // There are a number of situations where we need to ensure we display",
                        "    // whitespace as `{\" \"}` when outputting this element over multiple lines.",
                        "    if (child === jsxWhitespace) {",
                        "      if (i === 1 && children[i - 1] === \"\") {",
                        "        if (children.length === 2) {",
                        "          // Solitary whitespace",
                        "          multilineChildren.push(rawJsxWhitespace);",
                        "          continue;",
                        "        }",
                        "        // Leading whitespace",
                        "        multilineChildren.push([rawJsxWhitespace, hardline]);",
                        "        continue;",
                        "      } else if (i === children.length - 1) {",
                        "        // Trailing whitespace",
                        "        multilineChildren.push(rawJsxWhitespace);",
                        "        continue;",
                        "      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {",
                        "        // Whitespace after line break",
                        "        multilineChildren.push(rawJsxWhitespace);",
                        "        continue;",
                        "      }",
                        "    }",
                        "",
                        "    multilineChildren.push(child);",
                        "",
                        "    if (willBreak(child)) {",
                        "      forcedBreak = true;",
                        "    }",
                        "  }",
                        "",
                        "  // If there is text we use `fill` to fit as much onto each line as possible.",
                        "  // When there is no text (just tags and expressions) we use `group`",
                        "  // to output each on a separate line.",
                        "  /** @type {Doc} */",
                        "  let content = containsText",
                        "    ? fill(multilineChildren)",
                        "    : group(multilineChildren, { shouldBreak: true });",
                        "",
                        "  /*",
                        "  `printJsxChildren` won't call `print` on `JSXText`",
                        "  When the cursorNode is inside `cursor` won't get print.",
                        "  */",
                        "  if (",
                        "    options.cursorNode?.type === \"JSXText\" &&",
                        "    node.children.includes(options.cursorNode)",
                        "  ) {",
                        "    content = [cursor, content, cursor];",
                        "  }",
                        "",
                        "  if (isMdxBlock) {",
                        "    return content;",
                        "  }",
                        "",
                        "  const multiLineElem = group([",
                        "    openingLines,",
                        "    indent([hardline, content]),",
                        "    hardline,",
                        "    closingLines,",
                        "  ]);",
                        "",
                        "  if (forcedBreak) {",
                        "    return multiLineElem;",
                        "  }",
                        "",
                        "  return conditionalGroup([",
                        "    group([openingLines, ...children, closingLines]),",
                        "    multiLineElem,",
                        "  ]);",
                        "}",
                        "",
                        "// JSX Children are strange, mostly for two reasons:",
                        "// 1. JSX reads newlines into string values, instead of skipping them like JS",
                        "// 2. up to one whitespace between elements within a line is significant,",
                        "//    but not between lines.",
                        "//",
                        "// Leading, trailing, and lone whitespace all need to",
                        "// turn themselves into the rather ugly `{' '}` when breaking.",
                        "//",
                        "// We print JSX using the `fill` doc primitive.",
                        "// This requires that we give it an array of alternating",
                        "// content and whitespace elements.",
                        "// To ensure this we add dummy `\"\"` content elements as needed.",
                        "function printJsxChildren(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  jsxWhitespace,",
                        "  isFacebookTranslationTag",
                        ") {",
                        "  const parts = [];",
                        "  path.each(({ node, next }) => {",
                        "    if (node.type === \"JSXText\") {",
                        "      const text = rawText(node);",
                        "",
                        "      // Contains a non-whitespace character",
                        "      if (isMeaningfulJsxText(node)) {",
                        "        const words = jsxWhitespaceUtils.split(",
                        "          text,",
                        "          /* captureWhitespace */ true",
                        "        );",
                        "",
                        "        // Starts with whitespace",
                        "        if (words[0] === \"\") {",
                        "          parts.push(\"\");",
                        "          words.shift();",
                        "          if (/\\n/.test(words[0])) {",
                        "            parts.push(",
                        "              separatorWithWhitespace(",
                        "                isFacebookTranslationTag,",
                        "                words[1],",
                        "                node,",
                        "                next",
                        "              )",
                        "            );",
                        "          } else {",
                        "            parts.push(jsxWhitespace);",
                        "          }",
                        "          words.shift();",
                        "        }",
                        "",
                        "        let endWhitespace;",
                        "        // Ends with whitespace",
                        "        if (words.at(-1) === \"\") {",
                        "          words.pop();",
                        "          endWhitespace = words.pop();",
                        "        }",
                        "",
                        "        // This was whitespace only without a new line.",
                        "        if (words.length === 0) {",
                        "          return;",
                        "        }",
                        "",
                        "        for (const [i, word] of words.entries()) {",
                        "          if (i % 2 === 1) {",
                        "            parts.push(line);",
                        "          } else {",
                        "            parts.push(word);",
                        "          }",
                        "        }",
                        "",
                        "        if (endWhitespace !== undefined) {",
                        "          if (/\\n/.test(endWhitespace)) {",
                        "            parts.push(",
                        "              separatorWithWhitespace(",
                        "                isFacebookTranslationTag,",
                        "                parts.at(-1),",
                        "                node,",
                        "                next",
                        "              )",
                        "            );",
                        "          } else {",
                        "            parts.push(jsxWhitespace);",
                        "          }",
                        "        } else {",
                        "          parts.push(",
                        "            separatorNoWhitespace(",
                        "              isFacebookTranslationTag,",
                        "              parts.at(-1),",
                        "              node,",
                        "              next",
                        "            )",
                        "          );",
                        "        }",
                        "      } else if (/\\n/.test(text)) {",
                        "        // Keep (up to one) blank line between tags/expressions/text.",
                        "        // Note: We don't keep blank lines between text elements.",
                        "        if (text.match(/\\n/g).length > 1) {",
                        "          parts.push(\"\", hardline);",
                        "        }",
                        "      } else {",
                        "        parts.push(\"\", jsxWhitespace);",
                        "      }",
                        "    } else {",
                        "      const printedChild = print();",
                        "      parts.push(printedChild);",
                        "",
                        "      const directlyFollowedByMeaningfulText =",
                        "        next && isMeaningfulJsxText(next);",
                        "      if (directlyFollowedByMeaningfulText) {",
                        "        const trimmed = jsxWhitespaceUtils.trim(rawText(next));",
                        "        const [firstWord] = jsxWhitespaceUtils.split(trimmed);",
                        "        parts.push(",
                        "          separatorNoWhitespace(isFacebookTranslationTag, firstWord, node, next)",
                        "        );",
                        "      } else {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, \"children\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function separatorNoWhitespace(",
                        "  isFacebookTranslationTag,",
                        "  child,",
                        "  childNode,",
                        "  nextNode",
                        ") {",
                        "  if (isFacebookTranslationTag) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  if (",
                        "    (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                        "    (nextNode?.type === \"JSXElement\" && !nextNode.closingElement)",
                        "  ) {",
                        "    return child.length === 1 ? softline : hardline;",
                        "  }",
                        "",
                        "  return softline;",
                        "}",
                        "",
                        "function separatorWithWhitespace(",
                        "  isFacebookTranslationTag,",
                        "  child,",
                        "  childNode,",
                        "  nextNode",
                        ") {",
                        "  if (isFacebookTranslationTag) {",
                        "    return hardline;",
                        "  }",
                        "",
                        "  if (child.length === 1) {",
                        "    return (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                        "      (nextNode?.type === \"JSXElement\" && !nextNode.closingElement)",
                        "      ? hardline",
                        "      : softline;",
                        "  }",
                        "",
                        "  return hardline;",
                        "}",
                        "",
                        "const NO_WRAP_PARENTS = new Set([",
                        "  \"ArrayExpression\",",
                        "  \"TupleExpression\",",
                        "  \"JSXAttribute\",",
                        "  \"JSXElement\",",
                        "  \"JSXExpressionContainer\",",
                        "  \"JSXFragment\",",
                        "  \"ExpressionStatement\",",
                        "  \"CallExpression\",",
                        "  \"OptionalCallExpression\",",
                        "  \"ConditionalExpression\",",
                        "  \"JsExpressionRoot\",",
                        "]);",
                        "function maybeWrapJsxElementInParens(path, elem, options) {",
                        "  const { parent } = path;",
                        "",
                        "  if (NO_WRAP_PARENTS.has(parent.type)) {",
                        "    return elem;",
                        "  }",
                        "",
                        "  const shouldBreak = path.match(",
                        "    undefined,",
                        "    (node) => node.type === \"ArrowFunctionExpression\",",
                        "    isCallExpression,",
                        "    (node) => node.type === \"JSXExpressionContainer\"",
                        "  );",
                        "",
                        "  const needsParens = pathNeedsParens(path, options);",
                        "",
                        "  return group(",
                        "    [",
                        "      needsParens ? \"\" : ifBreak(\"(\"),",
                        "      indent([softline, elem]),",
                        "      softline,",
                        "      needsParens ? \"\" : ifBreak(\")\"),",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "function printJsxAttribute(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "  parts.push(print(\"name\"));",
                        "",
                        "  if (node.value) {",
                        "    let res;",
                        "    if (isStringLiteral(node.value)) {",
                        "      const raw = rawText(node.value);",
                        "      // Remove enclosing quotes and unescape",
                        "      // all quotes so we get an accurate preferred quote",
                        "      let final = raw",
                        "        .slice(1, -1)",
                        "        .replaceAll(\"&apos;\", \"'\")",
                        "        .replaceAll(\"&quot;\", '\"');",
                        "      const quote = getPreferredQuote(final, options.jsxSingleQuote);",
                        "      final =",
                        "        quote === '\"'",
                        "          ? final.replaceAll('\"', \"&quot;\")",
                        "          : final.replaceAll(\"'\", \"&apos;\");",
                        "      res = path.call(",
                        "        () =>",
                        "          printComments(path, replaceEndOfLine(quote + final + quote), options),",
                        "        \"value\"",
                        "      );",
                        "    } else {",
                        "      res = print(\"value\");",
                        "    }",
                        "    parts.push(\"=\", res);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJsxExpressionContainer(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  const shouldInline = (node, parent) =>",
                        "    node.type === \"JSXEmptyExpression\" ||",
                        "    (!hasComment(node) &&",
                        "      (isArrayOrTupleExpression(node) ||",
                        "        isObjectOrRecordExpression(node) ||",
                        "        node.type === \"ArrowFunctionExpression\" ||",
                        "        (node.type === \"AwaitExpression\" &&",
                        "          (shouldInline(node.argument, node) ||",
                        "            node.argument.type === \"JSXElement\")) ||",
                        "        isCallExpression(node) ||",
                        "        (node.type === \"ChainExpression\" &&",
                        "          isCallExpression(node.expression)) ||",
                        "        node.type === \"FunctionExpression\" ||",
                        "        node.type === \"TemplateLiteral\" ||",
                        "        node.type === \"TaggedTemplateExpression\" ||",
                        "        node.type === \"DoExpression\" ||",
                        "        (isJsxElement(parent) &&",
                        "          (node.type === \"ConditionalExpression\" || isBinaryish(node)))));",
                        "",
                        "  if (shouldInline(node.expression, path.parent)) {",
                        "    return group([\"{\", print(\"expression\"), lineSuffixBoundary, \"}\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    \"{\",",
                        "    indent([softline, print(\"expression\")]),",
                        "    softline,",
                        "    lineSuffixBoundary,",
                        "    \"}\",",
                        "  ]);",
                        "}",
                        "",
                        "function printJsxOpeningElement(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  const nameHasComments =",
                        "    hasComment(node.name) || hasComment(node.typeParameters);",
                        "",
                        "  // Don't break self-closing elements with no attributes and no comments",
                        "  if (node.selfClosing && node.attributes.length === 0 && !nameHasComments) {",
                        "    return [\"<\", print(\"name\"), print(\"typeParameters\"), \" />\"];",
                        "  }",
                        "",
                        "  // don't break up opening elements with a single long text attribute",
                        "  if (",
                        "    node.attributes?.length === 1 &&",
                        "    node.attributes[0].value &&",
                        "    isStringLiteral(node.attributes[0].value) &&",
                        "    !node.attributes[0].value.value.includes(\"\\n\") &&",
                        "    // We should break for the following cases:",
                        "    // <div",
                        "    //   // comment",
                        "    //   attr=\"value\"",
                        "    // >",
                        "    // <div",
                        "    //   attr=\"value\"",
                        "    //   // comment",
                        "    // >",
                        "    !nameHasComments &&",
                        "    !hasComment(node.attributes[0])",
                        "  ) {",
                        "    return group([",
                        "      \"<\",",
                        "      print(\"name\"),",
                        "      print(\"typeParameters\"),",
                        "      \" \",",
                        "      ...path.map(print, \"attributes\"),",
                        "      node.selfClosing ? \" />\" : \">\",",
                        "    ]);",
                        "  }",
                        "",
                        "  // We should print the opening element expanded if any prop value is a",
                        "  // string literal with newlines",
                        "  const shouldBreak = node.attributes?.some(",
                        "    (attr) =>",
                        "      attr.value &&",
                        "      isStringLiteral(attr.value) &&",
                        "      attr.value.value.includes(\"\\n\")",
                        "  );",
                        "",
                        "  const attributeLine =",
                        "    options.singleAttributePerLine && node.attributes.length > 1",
                        "      ? hardline",
                        "      : line;",
                        "",
                        "  return group(",
                        "    [",
                        "      \"<\",",
                        "      print(\"name\"),",
                        "      print(\"typeParameters\"),",
                        "      indent(path.map(() => [attributeLine, print()], \"attributes\")),",
                        "      ...printEndOfOpeningTag(node, options, nameHasComments),",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "function printEndOfOpeningTag(node, options, nameHasComments) {",
                        "  if (node.selfClosing) {",
                        "    return [line, \"/>\"];",
                        "  }",
                        "  const bracketSameLine = shouldPrintBracketSameLine(",
                        "    node,",
                        "    options,",
                        "    nameHasComments",
                        "  );",
                        "  if (bracketSameLine) {",
                        "    return [\">\"];",
                        "  }",
                        "  return [softline, \">\"];",
                        "}",
                        "",
                        "function shouldPrintBracketSameLine(node, options, nameHasComments) {",
                        "  const lastAttrHasTrailingComments =",
                        "    node.attributes.length > 0 &&",
                        "    hasComment(node.attributes.at(-1), CommentCheckFlags.Trailing);",
                        "  return (",
                        "    // Simple tags (no attributes and no comment in tag name) should be",
                        "    // kept unbroken regardless of `bracketSameLine`.",
                        "    // jsxBracketSameLine is deprecated in favour of bracketSameLine,",
                        "    // but is still needed for backwards compatibility.",
                        "    (node.attributes.length === 0 && !nameHasComments) ||",
                        "    ((options.bracketSameLine || options.jsxBracketSameLine) &&",
                        "      // We should print the bracket in a new line for the following cases:",
                        "      // <div",
                        "      //   // comment",
                        "      // >",
                        "      // <div",
                        "      //   attr // comment",
                        "      // >",
                        "      (!nameHasComments || node.attributes.length > 0) &&",
                        "      !lastAttrHasTrailingComments)",
                        "  );",
                        "}",
                        "",
                        "function printJsxClosingElement(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  parts.push(\"</\");",
                        "",
                        "  const printed = print(\"name\");",
                        "  if (",
                        "    hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Line)",
                        "  ) {",
                        "    parts.push(indent([hardline, printed]), hardline);",
                        "  } else if (",
                        "    hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Block)",
                        "  ) {",
                        "    parts.push(\" \", printed);",
                        "  } else {",
                        "    parts.push(printed);",
                        "  }",
                        "",
                        "  parts.push(\">\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJsxOpeningClosingFragment(path, options /*, print*/) {",
                        "  const { node } = path;",
                        "  const nodeHasComment = hasComment(node);",
                        "  const hasOwnLineComment = hasComment(node, CommentCheckFlags.Line);",
                        "  const isOpeningFragment = node.type === \"JSXOpeningFragment\";",
                        "  return [",
                        "    isOpeningFragment ? \"<\" : \"</\",",
                        "    indent([",
                        "      hasOwnLineComment",
                        "        ? hardline",
                        "        : nodeHasComment && !isOpeningFragment",
                        "        ? \" \"",
                        "        : \"\",",
                        "      printDanglingComments(path, options),",
                        "    ]),",
                        "    hasOwnLineComment ? hardline : \"\",",
                        "    \">\",",
                        "  ];",
                        "}",
                        "",
                        "function printJsxElement(path, options, print) {",
                        "  const elem = printComments(",
                        "    path,",
                        "    printJsxElementInternal(path, options, print),",
                        "    options",
                        "  );",
                        "  return maybeWrapJsxElementInParens(path, elem, options);",
                        "}",
                        "",
                        "function printJsxEmptyExpression(path, options /*, print*/) {",
                        "  const { node } = path;",
                        "  const requiresHardline = hasComment(node, CommentCheckFlags.Line);",
                        "",
                        "  return [",
                        "    printDanglingComments(path, options, { indent: requiresHardline }),",
                        "    requiresHardline ? hardline : \"\",",
                        "  ];",
                        "}",
                        "",
                        "// `JSXSpreadAttribute` and `JSXSpreadChild`",
                        "function printJsxSpreadAttributeOrChild(path, options, print) {",
                        "  const { node } = path;",
                        "  return [",
                        "    \"{\",",
                        "    path.call(",
                        "      ({ node }) => {",
                        "        const printed = [\"...\", print()];",
                        "        if (!hasComment(node) || !willPrintOwnComments(path)) {",
                        "          return printed;",
                        "        }",
                        "        return [",
                        "          indent([softline, printComments(path, printed, options)]),",
                        "          softline,",
                        "        ];",
                        "      },",
                        "      node.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"",
                        "    ),",
                        "    \"}\",",
                        "  ];",
                        "}",
                        "",
                        "function printJsx(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  // JSX nodes always starts with `JSX`",
                        "  if (!node.type.startsWith(\"JSX\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"JSXAttribute\":",
                        "      return printJsxAttribute(path, options, print);",
                        "    case \"JSXIdentifier\":",
                        "      return node.name;",
                        "    case \"JSXNamespacedName\":",
                        "      return join(\":\", [print(\"namespace\"), print(\"name\")]);",
                        "    case \"JSXMemberExpression\":",
                        "      return join(\".\", [print(\"object\"), print(\"property\")]);",
                        "    case \"JSXSpreadAttribute\":",
                        "    case \"JSXSpreadChild\":",
                        "      return printJsxSpreadAttributeOrChild(path, options, print);",
                        "    case \"JSXExpressionContainer\":",
                        "      return printJsxExpressionContainer(path, options, print);",
                        "    case \"JSXFragment\":",
                        "    case \"JSXElement\":",
                        "      return printJsxElement(path, options, print);",
                        "    case \"JSXOpeningElement\":",
                        "      return printJsxOpeningElement(path, options, print);",
                        "    case \"JSXClosingElement\":",
                        "      return printJsxClosingElement(path, options, print);",
                        "    case \"JSXOpeningFragment\":",
                        "    case \"JSXClosingFragment\":",
                        "      return printJsxOpeningClosingFragment(path, options /*, print*/);",
                        "    case \"JSXEmptyExpression\":",
                        "      return printJsxEmptyExpression(path, options /*, print*/);",
                        "    case \"JSXText\":",
                        "      /* c8 ignore next */",
                        "      throw new Error(\"JSXText should be handled by JSXElement\");",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      throw new UnexpectedNodeError(node, \"JSX\");",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {JSXElement} node",
                        " * @returns {boolean}",
                        " */",
                        "function isEmptyJsxElement(node) {",
                        "  if (node.children.length === 0) {",
                        "    return true;",
                        "  }",
                        "  if (node.children.length > 1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // if there is one text child and does not contain any meaningful text",
                        "  // we can treat the element as empty.",
                        "  const child = node.children[0];",
                        "  return child.type === \"JSXText\" && !isMeaningfulJsxText(child);",
                        "}",
                        "",
                        "// Meaningful if it contains non-whitespace characters,",
                        "// or it contains whitespace without a new line.",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isMeaningfulJsxText(node) {",
                        "  return (",
                        "    node.type === \"JSXText\" &&",
                        "    (jsxWhitespaceUtils.hasNonWhitespaceCharacter(rawText(node)) ||",
                        "      !/\\n/.test(rawText(node)))",
                        "  );",
                        "}",
                        "",
                        "// Detect an expression node representing `{\" \"}`",
                        "function isJsxWhitespaceExpression(node) {",
                        "  return (",
                        "    node.type === \"JSXExpressionContainer\" &&",
                        "    isStringLiteral(node.expression) &&",
                        "    node.expression.value === \" \" &&",
                        "    !hasComment(node.expression)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function hasJsxIgnoreComment(path) {",
                        "  const { node, parent } = path;",
                        "  if (!isJsxElement(node) || !isJsxElement(parent)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // TODO: Use `Array#findLast` when we drop support for Node.js<18",
                        "  // Lookup the previous sibling, ignoring any empty JSXText elements",
                        "  const { index, siblings } = path;",
                        "  let prevSibling;",
                        "  for (let i = index; i > 0; i--) {",
                        "    const candidate = siblings[i - 1];",
                        "    if (candidate.type === \"JSXText\" && !isMeaningfulJsxText(candidate)) {",
                        "      continue;",
                        "    }",
                        "    prevSibling = candidate;",
                        "    break;",
                        "  }",
                        "",
                        "  return (",
                        "    prevSibling?.type === \"JSXExpressionContainer\" &&",
                        "    prevSibling.expression.type === \"JSXEmptyExpression\" &&",
                        "    hasNodeIgnoreComment(prevSibling.expression)",
                        "  );",
                        "}",
                        "",
                        "export { hasJsxIgnoreComment, printJsx };"
                    ]
                },
                "literal.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import printString from \"../../utils/print-string.js\";",
                        "import printNumber from \"../../utils/print-number.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import { createTypeCheckFunction } from \"../utils/index.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " */",
                        "",
                        "function printLiteral(path, options /*, print*/) {",
                        "  const { node } = path;",
                        "",
                        "  switch (node.type) {",
                        "    case \"RegExpLiteral\": // Babel 6 Literal split",
                        "      return printRegex(node);",
                        "    case \"BigIntLiteral\":",
                        "      return printBigInt(node.extra.raw);",
                        "    case \"NumericLiteral\": // Babel 6 Literal split",
                        "      return printNumber(node.extra.raw);",
                        "    case \"StringLiteral\": // Babel 6 Literal split",
                        "      return replaceEndOfLine(printString(node.extra.raw, options));",
                        "    case \"NullLiteral\": // Babel 6 Literal split",
                        "      return \"null\";",
                        "    case \"BooleanLiteral\": // Babel 6 Literal split",
                        "      return String(node.value);",
                        "    case \"DecimalLiteral\":",
                        "      return printNumber(node.value) + \"m\";",
                        "    case \"DirectiveLiteral\":",
                        "      return printDirective(node.extra.raw, options);",
                        "    case \"Literal\": {",
                        "      if (node.regex) {",
                        "        return printRegex(node.regex);",
                        "      }",
                        "",
                        "      if (node.bigint) {",
                        "        return printBigInt(node.raw);",
                        "      }",
                        "",
                        "      if (node.decimal) {",
                        "        return printNumber(node.decimal) + \"m\";",
                        "      }",
                        "",
                        "      const { value } = node;",
                        "",
                        "      if (typeof value === \"number\") {",
                        "        return printNumber(node.raw);",
                        "      }",
                        "",
                        "      if (typeof value === \"string\") {",
                        "        return isDirective(path)",
                        "          ? printDirective(node.raw, options)",
                        "          : replaceEndOfLine(printString(node.raw, options));",
                        "      }",
                        "      return String(value);",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "function isDirective(path) {",
                        "  if (path.key !== \"expression\") {",
                        "    return;",
                        "  }",
                        "",
                        "  const { parent } = path;",
                        "  return parent.type === \"ExpressionStatement\" && parent.directive;",
                        "}",
                        "",
                        "function printBigInt(raw) {",
                        "  return raw.toLowerCase();",
                        "}",
                        "",
                        "function printRegex({ pattern, flags }) {",
                        "  flags = [...flags].sort().join(\"\");",
                        "  return `/${pattern}/${flags}`;",
                        "}",
                        "",
                        "function printDirective(rawText, options) {",
                        "  const rawContent = rawText.slice(1, -1);",
                        "",
                        "  // Check for the alternate quote, to determine if we're allowed to swap",
                        "  // the quotes on a DirectiveLiteral.",
                        "  if (rawContent.includes('\"') || rawContent.includes(\"'\")) {",
                        "    return rawText;",
                        "  }",
                        "",
                        "  const enclosingQuote = options.singleQuote ? \"'\" : '\"';",
                        "",
                        "  // Directives are exact code unit sequences, which means that you can't",
                        "  // change the escape sequences they use.",
                        "  // See https://github.com/prettier/prettier/issues/1555",
                        "  // and https://tc39.github.io/ecma262/#directive-prologue",
                        "  return enclosingQuote + rawContent + enclosingQuote;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isLiteral = createTypeCheckFunction([",
                        "  \"Literal\",",
                        "  // Babel, flow uses `BigIntLiteral` too",
                        "  \"BigIntLiteral\",",
                        "  \"BooleanLiteral\",",
                        "  \"DecimalLiteral\",",
                        "  \"DirectiveLiteral\",",
                        "  \"NullLiteral\",",
                        "  \"NumericLiteral\",",
                        "  \"RegExpLiteral\",",
                        "  \"StringLiteral\",",
                        "]);",
                        "",
                        "export { printLiteral, printBigInt, isLiteral };"
                    ]
                },
                "mapped-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import hasNewlineInRange from \"../../utils/has-newline-in-range.js\";",
                        "import { locStart } from \"../loc.js\";",
                        "import {",
                        "  group,",
                        "  softline,",
                        "  indent,",
                        "  ifBreak,",
                        "  line,",
                        "} from \"../../document/builders.js\";",
                        "",
                        "/**",
                        " * @param {string | null} optional",
                        " * @returns {string}",
                        " */",
                        "function printFlowMappedTypeOptionalModifier(optional) {",
                        "  switch (optional) {",
                        "    case null:",
                        "      return \"\";",
                        "    case \"PlusOptional\":",
                        "      return \"+?\";",
                        "    case \"MinusOptional\":",
                        "      return \"-?\";",
                        "    case \"Optional\":",
                        "      return \"?\";",
                        "  }",
                        "}",
                        "",
                        "function printFlowMappedTypeProperty(path, options, print) {",
                        "  const { node } = path;",
                        "  return group([",
                        "    node.variance ? print(\"variance\") : \"\",",
                        "    \"[\",",
                        "    indent([print(\"keyTparam\"), \" in \", print(\"sourceType\")]),",
                        "    \"]\",",
                        "    printFlowMappedTypeOptionalModifier(node.optional),",
                        "    \": \",",
                        "    print(\"propType\"),",
                        "  ]);",
                        "}",
                        "",
                        "/**",
                        " * @param {string} tokenNode",
                        " * @param {string} keyword",
                        " * @returns {string}",
                        " */",
                        "function printTypeScriptMappedTypeModifier(tokenNode, keyword) {",
                        "  if (tokenNode === \"+\" || tokenNode === \"-\") {",
                        "    return tokenNode + keyword;",
                        "  }",
                        "",
                        "  return keyword;",
                        "}",
                        "",
                        "function printTypescriptMappedType(path, options, print) {",
                        "  const { node } = path;",
                        "  // Break after `{` like `printObject`",
                        "  const shouldBreak = hasNewlineInRange(",
                        "    options.originalText,",
                        "    locStart(node),",
                        "    // Ideally, this should be the next token after `{`, but there is no node starts with it.",
                        "    locStart(node.typeParameter)",
                        "  );",
                        "",
                        "  return group(",
                        "    [",
                        "      \"{\",",
                        "      indent([",
                        "        options.bracketSpacing ? line : softline,",
                        "        group([",
                        "          print(\"typeParameter\"),",
                        "          node.optional",
                        "            ? printTypeScriptMappedTypeModifier(node.optional, \"?\")",
                        "            : \"\",",
                        "          node.typeAnnotation ? \": \" : \"\",",
                        "          print(\"typeAnnotation\"),",
                        "        ]),",
                        "        options.semi ? ifBreak(\";\") : \"\",",
                        "      ]),",
                        "      printDanglingComments(path, options),",
                        "      options.bracketSpacing ? line : softline,",
                        "      \"}\",",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  printFlowMappedTypeProperty,",
                        "  printTypeScriptMappedTypeModifier,",
                        "  printTypescriptMappedType,",
                        "};"
                    ]
                },
                "member-chain.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printComments } from \"../../main/comments/print.js\";",
                        "import isNextLineEmptyAfterIndex from \"../../utils/is-next-line-empty.js\";",
                        "import getNextNonSpaceNonCommentCharacterIndex from \"../../utils/get-next-non-space-non-comment-character-index.js\";",
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import {",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isFunctionOrArrowExpression,",
                        "  isLongCurriedCallExpression,",
                        "  isMemberish,",
                        "  isNumericLiteral,",
                        "  isSimpleCallArgument,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} from \"../utils/index.js\";",
                        "import { locEnd } from \"../loc.js\";",
                        "",
                        "import {",
                        "  join,",
                        "  hardline,",
                        "  group,",
                        "  indent,",
                        "  conditionalGroup,",
                        "  breakParent,",
                        "  label,",
                        "} from \"../../document/builders.js\";",
                        "import { willBreak } from \"../../document/utils.js\";",
                        "import printCallArguments from \"./call-arguments.js\";",
                        "import { printMemberLookup } from \"./member.js\";",
                        "import {",
                        "  printOptionalToken,",
                        "  printFunctionTypeParameters,",
                        "  printBindExpressionCallee,",
                        "} from \"./misc.js\";",
                        "",
                        "// We detect calls on member expressions specially to format a",
                        "// common pattern better. The pattern we are looking for is this:",
                        "//",
                        "// arr",
                        "//   .map(x => x + 1)",
                        "//   .filter(x => x > 10)",
                        "//   .some(x => x % 2)",
                        "//",
                        "// The way it is structured in the AST is via a nested sequence of",
                        "// MemberExpression and CallExpression. We need to traverse the AST",
                        "// and make groups out of it to print it in the desired way.",
                        "function printMemberChain(path, options, print) {",
                        "  const { parent } = path;",
                        "  const isExpressionStatement =",
                        "    !parent || parent.type === \"ExpressionStatement\";",
                        "",
                        "  // The first phase is to linearize the AST by traversing it down.",
                        "  //",
                        "  //   a().b()",
                        "  // has the following AST structure:",
                        "  //   CallExpression(MemberExpression(CallExpression(Identifier)))",
                        "  // and we transform it into",
                        "  //   [Identifier, CallExpression, MemberExpression, CallExpression]",
                        "  const printedNodes = [];",
                        "",
                        "  // Here we try to retain one typed empty line after each call expression or",
                        "  // the first group whether it is in parentheses or not",
                        "  function shouldInsertEmptyLineAfter(node) {",
                        "    const { originalText } = options;",
                        "    const nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(",
                        "      originalText,",
                        "      locEnd(node)",
                        "    );",
                        "    const nextChar = originalText.charAt(nextCharIndex);",
                        "",
                        "    // if it is cut off by a parenthesis, we only account for one typed empty",
                        "    // line after that parenthesis",
                        "    if (nextChar === \")\") {",
                        "      return (",
                        "        nextCharIndex !== false &&",
                        "        isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1)",
                        "      );",
                        "    }",
                        "",
                        "    return isNextLineEmpty(node, options);",
                        "  }",
                        "",
                        "  function rec(path) {",
                        "    const { node } = path;",
                        "    if (",
                        "      isCallExpression(node) &&",
                        "      (isMemberish(node.callee) || isCallExpression(node.callee))",
                        "    ) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: [",
                        "          printComments(",
                        "            path,",
                        "            [",
                        "              printOptionalToken(path),",
                        "              printFunctionTypeParameters(path, options, print),",
                        "              printCallArguments(path, options, print),",
                        "            ],",
                        "            options",
                        "          ),",
                        "          shouldInsertEmptyLineAfter(node) ? hardline : \"\",",
                        "        ],",
                        "      });",
                        "      path.call((callee) => rec(callee), \"callee\");",
                        "    } else if (isMemberish(node)) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        needsParens: pathNeedsParens(path, options),",
                        "        printed: printComments(",
                        "          path,",
                        "          isMemberExpression(node)",
                        "            ? printMemberLookup(path, options, print)",
                        "            : printBindExpressionCallee(path, options, print),",
                        "          options",
                        "        ),",
                        "      });",
                        "      path.call((object) => rec(object), \"object\");",
                        "    } else if (node.type === \"TSNonNullExpression\") {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: printComments(path, \"!\", options),",
                        "      });",
                        "      path.call((expression) => rec(expression), \"expression\");",
                        "    } else {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: print(),",
                        "      });",
                        "    }",
                        "  }",
                        "  // Note: the comments of the root node have already been printed, so we",
                        "  // need to extract this first call without printing them as they would",
                        "  // if handled inside of the recursive call.",
                        "  const { node } = path;",
                        "  printedNodes.unshift({",
                        "    node,",
                        "    printed: [",
                        "      printOptionalToken(path),",
                        "      printFunctionTypeParameters(path, options, print),",
                        "      printCallArguments(path, options, print),",
                        "    ],",
                        "  });",
                        "",
                        "  if (node.callee) {",
                        "    path.call((callee) => rec(callee), \"callee\");",
                        "  }",
                        "",
                        "  // Once we have a linear list of printed nodes, we want to create groups out",
                        "  // of it.",
                        "  //",
                        "  //   a().b.c().d().e",
                        "  // will be grouped as",
                        "  //   [",
                        "  //     [Identifier, CallExpression],",
                        "  //     [MemberExpression, MemberExpression, CallExpression],",
                        "  //     [MemberExpression, CallExpression],",
                        "  //     [MemberExpression],",
                        "  //   ]",
                        "  // so that we can print it as",
                        "  //   a()",
                        "  //     .b.c()",
                        "  //     .d()",
                        "  //     .e",
                        "",
                        "  // The first group is the first node followed by",
                        "  //   - as many CallExpression as possible",
                        "  //       < fn()()() >.something()",
                        "  //   - as many array accessors as possible",
                        "  //       < fn()[0][1][2] >.something()",
                        "  //   - then, as many MemberExpression as possible but the last one",
                        "  //       < this.items >.something()",
                        "  const groups = [];",
                        "  let currentGroup = [printedNodes[0]];",
                        "  let i = 1;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (",
                        "      printedNodes[i].node.type === \"TSNonNullExpression\" ||",
                        "      isCallExpression(printedNodes[i].node) ||",
                        "      (isMemberExpression(printedNodes[i].node) &&",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property))",
                        "    ) {",
                        "      currentGroup.push(printedNodes[i]);",
                        "    } else {",
                        "      break;",
                        "    }",
                        "  }",
                        "  if (!isCallExpression(printedNodes[0].node)) {",
                        "    for (; i + 1 < printedNodes.length; ++i) {",
                        "      if (",
                        "        isMemberish(printedNodes[i].node) &&",
                        "        isMemberish(printedNodes[i + 1].node)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "      } else {",
                        "        break;",
                        "      }",
                        "    }",
                        "  }",
                        "  groups.push(currentGroup);",
                        "  currentGroup = [];",
                        "",
                        "  // Then, each following group is a sequence of MemberExpression followed by",
                        "  // a sequence of CallExpression. To compute it, we keep adding things to the",
                        "  // group until we has seen a CallExpression in the past and reach a",
                        "  // MemberExpression",
                        "  let hasSeenCallExpression = false;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {",
                        "      // [0] should be appended at the end of the group instead of the",
                        "      // beginning of the next one",
                        "      if (",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "        continue;",
                        "      }",
                        "",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "",
                        "    if (",
                        "      isCallExpression(printedNodes[i].node) ||",
                        "      printedNodes[i].node.type === \"ImportExpression\"",
                        "    ) {",
                        "      hasSeenCallExpression = true;",
                        "    }",
                        "    currentGroup.push(printedNodes[i]);",
                        "",
                        "    if (hasComment(printedNodes[i].node, CommentCheckFlags.Trailing)) {",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "  }",
                        "  if (currentGroup.length > 0) {",
                        "    groups.push(currentGroup);",
                        "  }",
                        "",
                        "  // There are cases like Object.keys(), Observable.of(), _.values() where",
                        "  // they are the subject of all the chained calls and therefore should",
                        "  // be kept on the same line:",
                        "  //",
                        "  //   Object.keys(items)",
                        "  //     .filter(x => x)",
                        "  //     .map(x => x)",
                        "  //",
                        "  // In order to detect those cases, we use an heuristic: if the first",
                        "  // node is an identifier with the name starting with a capital",
                        "  // letter or just a sequence of _$. The rationale is that they are",
                        "  // likely to be factories.",
                        "  function isFactory(name) {",
                        "    return /^[A-Z]|^[$_]+$/.test(name);",
                        "  }",
                        "",
                        "  // In case the Identifier is shorter than tab width, we can keep the",
                        "  // first call in a single line, if it's an ExpressionStatement.",
                        "  //",
                        "  //   d3.scaleLinear()",
                        "  //     .domain([0, 100])",
                        "  //     .range([0, width]);",
                        "  //",
                        "  function isShort(name) {",
                        "    return name.length <= options.tabWidth;",
                        "  }",
                        "",
                        "  function shouldNotWrap(groups) {",
                        "    const hasComputed = groups[1][0]?.node.computed;",
                        "",
                        "    if (groups[0].length === 1) {",
                        "      const firstNode = groups[0][0].node;",
                        "      return (",
                        "        firstNode.type === \"ThisExpression\" ||",
                        "        (firstNode.type === \"Identifier\" &&",
                        "          (isFactory(firstNode.name) ||",
                        "            (isExpressionStatement && isShort(firstNode.name)) ||",
                        "            hasComputed))",
                        "      );",
                        "    }",
                        "",
                        "    const lastNode = groups[0].at(-1).node;",
                        "    return (",
                        "      isMemberExpression(lastNode) &&",
                        "      lastNode.property.type === \"Identifier\" &&",
                        "      (isFactory(lastNode.property.name) || hasComputed)",
                        "    );",
                        "  }",
                        "",
                        "  const shouldMerge =",
                        "    groups.length >= 2 &&",
                        "    !hasComment(groups[1][0].node) &&",
                        "    shouldNotWrap(groups);",
                        "",
                        "  function printGroup(printedGroup) {",
                        "    const printed = printedGroup.map((tuple) => tuple.printed);",
                        "    // Checks if the last node (i.e. the parent node) needs parens and print",
                        "    // accordingly",
                        "    if (printedGroup.length > 0 && printedGroup.at(-1).needsParens) {",
                        "      return [\"(\", ...printed, \")\"];",
                        "    }",
                        "    return printed;",
                        "  }",
                        "",
                        "  function printIndentedGroup(groups) {",
                        "    /* c8 ignore next 3 */",
                        "    if (groups.length === 0) {",
                        "      return \"\";",
                        "    }",
                        "    return indent(group([hardline, join(hardline, groups.map(printGroup))]));",
                        "  }",
                        "",
                        "  const printedGroups = groups.map(printGroup);",
                        "  const oneLine = printedGroups;",
                        "",
                        "  const cutoff = shouldMerge ? 3 : 2;",
                        "  const flatGroups = groups.flat();",
                        "",
                        "  const nodeHasComment =",
                        "    flatGroups",
                        "      .slice(1, -1)",
                        "      .some((node) => hasComment(node.node, CommentCheckFlags.Leading)) ||",
                        "    flatGroups",
                        "      .slice(0, -1)",
                        "      .some((node) => hasComment(node.node, CommentCheckFlags.Trailing)) ||",
                        "    (groups[cutoff] &&",
                        "      hasComment(groups[cutoff][0].node, CommentCheckFlags.Leading));",
                        "",
                        "  // If we only have a single `.`, we shouldn't do anything fancy and just",
                        "  // render everything concatenated together.",
                        "  if (groups.length <= cutoff && !nodeHasComment) {",
                        "    if (isLongCurriedCallExpression(path)) {",
                        "      return oneLine;",
                        "    }",
                        "    return group(oneLine);",
                        "  }",
                        "",
                        "  // Find out the last node in the first group and check if it has an",
                        "  // empty line after",
                        "  const lastNodeBeforeIndent = groups[shouldMerge ? 1 : 0].at(-1).node;",
                        "  const shouldHaveEmptyLineBeforeIndent =",
                        "    !isCallExpression(lastNodeBeforeIndent) &&",
                        "    shouldInsertEmptyLineAfter(lastNodeBeforeIndent);",
                        "",
                        "  const expanded = [",
                        "    printGroup(groups[0]),",
                        "    shouldMerge ? groups.slice(1, 2).map(printGroup) : \"\",",
                        "    shouldHaveEmptyLineBeforeIndent ? hardline : \"\",",
                        "    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1)),",
                        "  ];",
                        "",
                        "  const callExpressions = printedNodes",
                        "    .map(({ node }) => node)",
                        "    .filter(isCallExpression);",
                        "",
                        "  function lastGroupWillBreakAndOtherCallsHaveFunctionArguments() {",
                        "    const lastGroupNode = groups.at(-1).at(-1).node;",
                        "    const lastGroupDoc = printedGroups.at(-1);",
                        "    return (",
                        "      isCallExpression(lastGroupNode) &&",
                        "      willBreak(lastGroupDoc) &&",
                        "      callExpressions",
                        "        .slice(0, -1)",
                        "        .some((node) => node.arguments.some(isFunctionOrArrowExpression))",
                        "    );",
                        "  }",
                        "",
                        "  let result;",
                        "",
                        "  // We don't want to print in one line if at least one of these conditions occurs:",
                        "  //  * the chain has comments,",
                        "  //  * the chain is an expression statement and all the arguments are literal-like (\"fluent configuration\" pattern),",
                        "  //  * the chain is longer than 2 calls and has non-trivial arguments or more than 2 arguments in any call but the first one,",
                        "  //  * any group but the last one has a hard line,",
                        "  //  * the last call's arguments have a hard line and other calls have non-trivial arguments.",
                        "  if (",
                        "    nodeHasComment ||",
                        "    (callExpressions.length > 2 &&",
                        "      callExpressions.some(",
                        "        (expr) => !expr.arguments.every((arg) => isSimpleCallArgument(arg))",
                        "      )) ||",
                        "    printedGroups.slice(0, -1).some(willBreak) ||",
                        "    lastGroupWillBreakAndOtherCallsHaveFunctionArguments()",
                        "  ) {",
                        "    result = group(expanded);",
                        "  } else {",
                        "    result = [",
                        "      // We only need to check `oneLine` because if `expanded` is chosen",
                        "      // that means that the parent group has already been broken",
                        "      // naturally",
                        "      willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\",",
                        "      conditionalGroup([oneLine, expanded]),",
                        "    ];",
                        "  }",
                        "",
                        "  return label({ memberChain: true }, result);",
                        "}",
                        "",
                        "export default printMemberChain;"
                    ]
                },
                "member.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { softline, group, indent, label } from \"../../document/builders.js\";",
                        "import {",
                        "  isNumericLiteral,",
                        "  isMemberExpression,",
                        "  isCallExpression,",
                        "} from \"../utils/index.js\";",
                        "import { printOptionalToken } from \"./misc.js\";",
                        "",
                        "function printMemberExpression(path, options, print) {",
                        "  const objectDoc = print(\"object\");",
                        "  const lookupDoc = printMemberLookup(path, options, print);",
                        "  const { node, parent } = path;",
                        "  const firstNonMemberParent = path.findAncestor(",
                        "    (node) => !(isMemberExpression(node) || node.type === \"TSNonNullExpression\")",
                        "  );",
                        "",
                        "  const shouldInline =",
                        "    (firstNonMemberParent &&",
                        "      (firstNonMemberParent.type === \"NewExpression\" ||",
                        "        firstNonMemberParent.type === \"BindExpression\" ||",
                        "        (firstNonMemberParent.type === \"AssignmentExpression\" &&",
                        "          firstNonMemberParent.left.type !== \"Identifier\"))) ||",
                        "    node.computed ||",
                        "    (node.object.type === \"Identifier\" &&",
                        "      node.property.type === \"Identifier\" &&",
                        "      !isMemberExpression(parent)) ||",
                        "    ((parent.type === \"AssignmentExpression\" ||",
                        "      parent.type === \"VariableDeclarator\") &&",
                        "      ((isCallExpression(node.object) && node.object.arguments.length > 0) ||",
                        "        (node.object.type === \"TSNonNullExpression\" &&",
                        "          isCallExpression(node.object.expression) &&",
                        "          node.object.expression.arguments.length > 0) ||",
                        "        objectDoc.label?.memberChain));",
                        "",
                        "  return label(objectDoc.label, [",
                        "    objectDoc,",
                        "    shouldInline ? lookupDoc : group(indent([softline, lookupDoc])),",
                        "  ]);",
                        "}",
                        "",
                        "function printMemberLookup(path, options, print) {",
                        "  const property = print(\"property\");",
                        "  const { node } = path;",
                        "  const optional = printOptionalToken(path);",
                        "",
                        "  if (!node.computed) {",
                        "    return [optional, \".\", property];",
                        "  }",
                        "",
                        "  if (!node.property || isNumericLiteral(node.property)) {",
                        "    return [optional, \"[\", property, \"]\"];",
                        "  }",
                        "",
                        "  return group([optional, \"[\", indent([softline, property]), softline, \"]\"]);",
                        "}",
                        "",
                        "export { printMemberExpression, printMemberLookup };"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { indent, line } from \"../../document/builders.js\";",
                        "import { isCallExpression, isMemberExpression } from \"../utils/index.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {Doc}",
                        " */",
                        "function printOptionalToken(path) {",
                        "  const { node } = path;",
                        "  if (",
                        "    !node.optional ||",
                        "    // It's an optional computed method parsed by typescript-estree.",
                        "    // \"?\" is printed in `printMethod`.",
                        "    (node.type === \"Identifier\" && node === path.parent.key)",
                        "  ) {",
                        "    return \"\";",
                        "  }",
                        "  if (",
                        "    isCallExpression(node) ||",
                        "    (isMemberExpression(node) && node.computed) ||",
                        "    node.type === \"OptionalIndexedAccessType\"",
                        "  ) {",
                        "    return \"?.\";",
                        "  }",
                        "  return \"?\";",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {Doc}",
                        " */",
                        "function printDefiniteToken(path) {",
                        "  return path.node.definite ||",
                        "    path.match(",
                        "      undefined,",
                        "      (node, name) =>",
                        "        name === \"id\" && node.type === \"VariableDeclarator\" && node.definite",
                        "    )",
                        "    ? \"!\"",
                        "    : \"\";",
                        "}",
                        "",
                        "const flowDeclareNodeTypes = new Set([",
                        "  \"DeclareClass\",",
                        "  \"DeclareFunction\",",
                        "  \"DeclareVariable\",",
                        "  \"DeclareExportDeclaration\",",
                        "  \"DeclareExportAllDeclaration\",",
                        "  \"DeclareOpaqueType\",",
                        "  \"DeclareTypeAlias\",",
                        "  \"DeclareEnum\",",
                        "  \"DeclareInterface\",",
                        "]);",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {Doc}",
                        " */",
                        "function printDeclareToken(path) {",
                        "  const { node } = path;",
                        "",
                        "  return (",
                        "    // TypeScript",
                        "    node.declare ||",
                        "      // Flow",
                        "      (flowDeclareNodeTypes.has(node.type) &&",
                        "        path.parent.type !== \"DeclareExportDeclaration\")",
                        "      ? \"declare \"",
                        "      : \"\"",
                        "  );",
                        "}",
                        "",
                        "const tsAbstractNodeTypes = new Set([",
                        "  \"TSAbstractMethodDefinition\",",
                        "  \"TSAbstractPropertyDefinition\",",
                        "  \"TSAbstractAccessorProperty\",",
                        "]);",
                        "/**",
                        " * @param {AstPath} param0",
                        " * @returns {Doc}",
                        " */",
                        "function printAbstractToken({ node }) {",
                        "  return node.abstract || tsAbstractNodeTypes.has(node.type) ? \"abstract \" : \"\";",
                        "}",
                        "",
                        "function printFunctionTypeParameters(path, options, print) {",
                        "  const fun = path.node;",
                        "  if (fun.typeArguments) {",
                        "    return print(\"typeArguments\");",
                        "  }",
                        "  if (fun.typeParameters) {",
                        "    return print(\"typeParameters\");",
                        "  }",
                        "  return \"\";",
                        "}",
                        "",
                        "function printBindExpressionCallee(path, options, print) {",
                        "  return [\"::\", print(\"callee\")];",
                        "}",
                        "",
                        "function adjustClause(node, clause, forceSpace) {",
                        "  if (node.type === \"EmptyStatement\") {",
                        "    return \";\";",
                        "  }",
                        "",
                        "  if (node.type === \"BlockStatement\" || forceSpace) {",
                        "    return [\" \", clause];",
                        "  }",
                        "",
                        "  return indent([line, clause]);",
                        "}",
                        "",
                        "function printRestSpread(path, print) {",
                        "  return [\"...\", print(\"argument\"), printTypeAnnotationProperty(path, print)];",
                        "}",
                        "",
                        "function printTypeScriptAccessibilityToken(node) {",
                        "  return node.accessibility ? node.accessibility + \" \" : \"\";",
                        "}",
                        "",
                        "export {",
                        "  printOptionalToken,",
                        "  printDefiniteToken,",
                        "  printDeclareToken,",
                        "  printAbstractToken,",
                        "  printFunctionTypeParameters,",
                        "  printBindExpressionCallee,",
                        "  printRestSpread,",
                        "  adjustClause,",
                        "  printTypeScriptAccessibilityToken,",
                        "};"
                    ]
                },
                "module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                        "import {",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  join,",
                        "  line,",
                        "  ifBreak,",
                        "  hardline,",
                        "} from \"../../document/builders.js\";",
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "",
                        "import {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  shouldPrintComma,",
                        "  needsHardlineAfterDanglingComment,",
                        "  isStringLiteral,",
                        "  rawText,",
                        "  createTypeCheckFunction,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, hasSameLoc } from \"../loc.js\";",
                        "import { printDecoratorsBeforeExport } from \"./decorators.js\";",
                        "import { printDeclareToken } from \"./misc.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "function printImportDeclaration(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type{Doc[]} */",
                        "  return [",
                        "    \"import\",",
                        "    node.module ? \" module\" : \"\",",
                        "    printImportKind(node),",
                        "    printModuleSpecifiers(path, options, print),",
                        "    printModuleSource(path, options, print),",
                        "    printImportAssertions(path, options, print),",
                        "    options.semi ? \";\" : \"\",",
                        "  ];",
                        "}",
                        "",
                        "const isDefaultExport = (node) =>",
                        "  node.type === \"ExportDefaultDeclaration\" ||",
                        "  (node.type === \"DeclareExportDeclaration\" && node.default);",
                        "",
                        "/*",
                        "- `ExportDefaultDeclaration`",
                        "- `ExportNamedDeclaration`",
                        "- `DeclareExportDeclaration`(flow)",
                        "- `ExportAllDeclaration`",
                        "- `DeclareExportAllDeclaration`(flow)",
                        "*/",
                        "function printExportDeclaration(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [",
                        "    printDecoratorsBeforeExport(path, options, print),",
                        "    printDeclareToken(path),",
                        "    \"export\",",
                        "    isDefaultExport(node) ? \" default\" : \"\",",
                        "  ];",
                        "",
                        "  const { declaration, exported } = node;",
                        "",
                        "  if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    parts.push(\" \", printDanglingComments(path, options));",
                        "",
                        "    if (needsHardlineAfterDanglingComment(node)) {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  if (declaration) {",
                        "    parts.push(\" \", print(\"declaration\"));",
                        "  } else {",
                        "    parts.push(printExportKind(node));",
                        "",
                        "    if (",
                        "      node.type === \"ExportAllDeclaration\" ||",
                        "      node.type === \"DeclareExportAllDeclaration\"",
                        "    ) {",
                        "      parts.push(\" *\");",
                        "      if (exported) {",
                        "        parts.push(\" as \", print(\"exported\"));",
                        "      }",
                        "    } else {",
                        "      parts.push(printModuleSpecifiers(path, options, print));",
                        "    }",
                        "",
                        "    parts.push(",
                        "      printModuleSource(path, options, print),",
                        "      printImportAssertions(path, options, print)",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(printSemicolonAfterExportDeclaration(node, options));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "const shouldOmitSemicolon = createTypeCheckFunction([",
                        "  \"ClassDeclaration\",",
                        "  \"FunctionDeclaration\",",
                        "  \"TSInterfaceDeclaration\",",
                        "  \"DeclareClass\",",
                        "  \"DeclareFunction\",",
                        "  \"TSDeclareFunction\",",
                        "  \"EnumDeclaration\",",
                        "]);",
                        "function printSemicolonAfterExportDeclaration(node, options) {",
                        "  if (",
                        "    options.semi &&",
                        "    (!node.declaration ||",
                        "      (isDefaultExport(node) && !shouldOmitSemicolon(node.declaration)))",
                        "  ) {",
                        "    return \";\";",
                        "  }",
                        "",
                        "  return \"\";",
                        "}",
                        "",
                        "function printImportOrExportKind(kind, spaceBeforeKind = true) {",
                        "  return kind && kind !== \"value\"",
                        "    ? `${spaceBeforeKind ? \" \" : \"\"}${kind}${spaceBeforeKind ? \"\" : \" \"}`",
                        "    : \"\";",
                        "}",
                        "",
                        "function printImportKind(node, spaceBeforeKind) {",
                        "  return printImportOrExportKind(node.importKind, spaceBeforeKind);",
                        "}",
                        "",
                        "function printExportKind(node) {",
                        "  return printImportOrExportKind(node.exportKind);",
                        "}",
                        "",
                        "function printModuleSource(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (!node.source) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "  if (!shouldNotPrintSpecifiers(node, options)) {",
                        "    parts.push(\" from\");",
                        "  }",
                        "  parts.push(\" \", print(\"source\"));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printModuleSpecifiers(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (shouldNotPrintSpecifiers(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [\" \"];",
                        "",
                        "  if (isNonEmptyArray(node.specifiers)) {",
                        "    const standaloneSpecifiers = [];",
                        "    const groupedSpecifiers = [];",
                        "",
                        "    path.each(() => {",
                        "      const specifierType = path.node.type;",
                        "      if (",
                        "        specifierType === \"ExportNamespaceSpecifier\" ||",
                        "        specifierType === \"ExportDefaultSpecifier\" ||",
                        "        specifierType === \"ImportNamespaceSpecifier\" ||",
                        "        specifierType === \"ImportDefaultSpecifier\"",
                        "      ) {",
                        "        standaloneSpecifiers.push(print());",
                        "      } else if (",
                        "        specifierType === \"ExportSpecifier\" ||",
                        "        specifierType === \"ImportSpecifier\"",
                        "      ) {",
                        "        groupedSpecifiers.push(print());",
                        "      } else {",
                        "        /* c8 ignore next 3 */",
                        "        throw new UnexpectedNodeError(node, \"specifier\");",
                        "      }",
                        "    }, \"specifiers\");",
                        "",
                        "    parts.push(join(\", \", standaloneSpecifiers));",
                        "",
                        "    if (groupedSpecifiers.length > 0) {",
                        "      if (standaloneSpecifiers.length > 0) {",
                        "        parts.push(\", \");",
                        "      }",
                        "",
                        "      const canBreak =",
                        "        groupedSpecifiers.length > 1 ||",
                        "        standaloneSpecifiers.length > 0 ||",
                        "        node.specifiers.some((node) => hasComment(node));",
                        "",
                        "      if (canBreak) {",
                        "        parts.push(",
                        "          group([",
                        "            \"{\",",
                        "            indent([",
                        "              options.bracketSpacing ? line : softline,",
                        "              join([\",\", line], groupedSpecifiers),",
                        "            ]),",
                        "            ifBreak(shouldPrintComma(options) ? \",\" : \"\"),",
                        "            options.bracketSpacing ? line : softline,",
                        "            \"}\",",
                        "          ])",
                        "        );",
                        "      } else {",
                        "        parts.push([",
                        "          \"{\",",
                        "          options.bracketSpacing ? \" \" : \"\",",
                        "          ...groupedSpecifiers,",
                        "          options.bracketSpacing ? \" \" : \"\",",
                        "          \"}\",",
                        "        ]);",
                        "      }",
                        "    }",
                        "  } else {",
                        "    parts.push(\"{}\");",
                        "  }",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldNotPrintSpecifiers(node, options) {",
                        "  const { type, importKind, source, specifiers } = node;",
                        "",
                        "  if (",
                        "    type !== \"ImportDeclaration\" ||",
                        "    isNonEmptyArray(specifiers) ||",
                        "    importKind === \"type\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // TODO: check tokens",
                        "  return !/{\\s*}/.test(",
                        "    options.originalText.slice(locStart(node), locStart(source))",
                        "  );",
                        "}",
                        "",
                        "function printImportAssertions(path, options, print) {",
                        "  const { node } = path;",
                        "  if (!isNonEmptyArray(node.assertions)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  return [",
                        "    \" assert {\",",
                        "    options.bracketSpacing ? \" \" : \"\",",
                        "    join(\", \", path.map(print, \"assertions\")),",
                        "    options.bracketSpacing ? \" \" : \"\",",
                        "    \"}\",",
                        "  ];",
                        "}",
                        "",
                        "function printModuleSpecifier(path, options, print) {",
                        "  const { node } = path;",
                        "  const { type } = node;",
                        "",
                        "  const isImportSpecifier = type.startsWith(\"Import\");",
                        "  const leftSideProperty = isImportSpecifier ? \"imported\" : \"local\";",
                        "  const rightSideProperty = isImportSpecifier ? \"local\" : \"exported\";",
                        "  const leftSideNode = node[leftSideProperty];",
                        "  const rightSideNode = node[rightSideProperty];",
                        "  let left = \"\";",
                        "  let right = \"\";",
                        "  if (",
                        "    type === \"ExportNamespaceSpecifier\" ||",
                        "    type === \"ImportNamespaceSpecifier\"",
                        "  ) {",
                        "    left = \"*\";",
                        "  } else if (leftSideNode) {",
                        "    left = print(leftSideProperty);",
                        "  }",
                        "",
                        "  if (rightSideNode && !isShorthandSpecifier(node)) {",
                        "    right = print(rightSideProperty);",
                        "  }",
                        "",
                        "  return [",
                        "    printImportOrExportKind(",
                        "      type === \"ImportSpecifier\" ? node.importKind : node.exportKind,",
                        "      /* spaceBeforeKind */ false",
                        "    ),",
                        "    left,",
                        "    left && right ? \" as \" : \"\",",
                        "    right,",
                        "  ];",
                        "}",
                        "",
                        "function isShorthandSpecifier(specifier) {",
                        "  if (",
                        "    specifier.type !== \"ImportSpecifier\" &&",
                        "    specifier.type !== \"ExportSpecifier\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const {",
                        "    local,",
                        "    [specifier.type === \"ImportSpecifier\" ? \"imported\" : \"exported\"]:",
                        "      importedOrExported,",
                        "  } = specifier;",
                        "",
                        "  if (",
                        "    local.type !== importedOrExported.type ||",
                        "    !hasSameLoc(local, importedOrExported)",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isStringLiteral(local)) {",
                        "    return (",
                        "      local.value === importedOrExported.value &&",
                        "      rawText(local) === rawText(importedOrExported)",
                        "    );",
                        "  }",
                        "",
                        "  switch (local.type) {",
                        "    case \"Identifier\":",
                        "      return local.name === importedOrExported.name;",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "export {",
                        "  printImportDeclaration,",
                        "  printExportDeclaration,",
                        "  printModuleSpecifier,",
                        "  printImportKind,",
                        "};"
                    ]
                },
                "object.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  line,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "  hardline,",
                        "} from \"../../document/builders.js\";",
                        "import hasNewlineInRange from \"../../utils/has-newline-in-range.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "  isObjectType,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "",
                        "import { printOptionalToken } from \"./misc.js\";",
                        "import { shouldHugTheOnlyFunctionParameter } from \"./function-parameters.js\";",
                        "import { printHardlineAfterHeritage } from \"./class.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "function printObject(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const { node } = path;",
                        "",
                        "  const isTypeAnnotation = node.type === \"ObjectTypeAnnotation\";",
                        "  const isEnumBody =",
                        "    node.type === \"TSEnumDeclaration\" ||",
                        "    node.type === \"EnumBooleanBody\" ||",
                        "    node.type === \"EnumNumberBody\" ||",
                        "    node.type === \"EnumStringBody\" ||",
                        "    node.type === \"EnumSymbolBody\";",
                        "  const fields = [",
                        "    node.type === \"TSTypeLiteral\" || isEnumBody",
                        "      ? \"members\"",
                        "      : node.type === \"TSInterfaceBody\"",
                        "      ? \"body\"",
                        "      : \"properties\",",
                        "  ];",
                        "  if (isTypeAnnotation) {",
                        "    fields.push(\"indexers\", \"callProperties\", \"internalSlots\");",
                        "  }",
                        "",
                        "  // Unfortunately, things grouped together in the ast can be",
                        "  // interleaved in the source code. So we need to reorder them before",
                        "  // printing them.",
                        "  const propsAndLoc = fields.flatMap((field) =>",
                        "    path.map(",
                        "      ({ node }) => ({",
                        "        node,",
                        "        printed: print(),",
                        "        loc: locStart(node),",
                        "      }),",
                        "      field",
                        "    )",
                        "  );",
                        "",
                        "  if (fields.length > 1) {",
                        "    propsAndLoc.sort((a, b) => a.loc - b.loc);",
                        "  }",
                        "",
                        "  const { parent, key } = path;",
                        "  const isFlowInterfaceLikeBody =",
                        "    isTypeAnnotation &&",
                        "    key === \"body\" &&",
                        "    (parent.type === \"InterfaceDeclaration\" ||",
                        "      parent.type === \"DeclareInterface\" ||",
                        "      parent.type === \"DeclareClass\");",
                        "  const shouldBreak =",
                        "    node.type === \"TSInterfaceBody\" ||",
                        "    isEnumBody ||",
                        "    isFlowInterfaceLikeBody ||",
                        "    (node.type === \"ObjectPattern\" &&",
                        "      parent.type !== \"FunctionDeclaration\" &&",
                        "      parent.type !== \"FunctionExpression\" &&",
                        "      parent.type !== \"ArrowFunctionExpression\" &&",
                        "      parent.type !== \"ObjectMethod\" &&",
                        "      parent.type !== \"ClassMethod\" &&",
                        "      parent.type !== \"ClassPrivateMethod\" &&",
                        "      parent.type !== \"AssignmentPattern\" &&",
                        "      parent.type !== \"CatchClause\" &&",
                        "      node.properties.some(",
                        "        (property) =>",
                        "          property.value &&",
                        "          (property.value.type === \"ObjectPattern\" ||",
                        "            property.value.type === \"ArrayPattern\")",
                        "      )) ||",
                        "    (node.type !== \"ObjectPattern\" &&",
                        "      propsAndLoc.length > 0 &&",
                        "      hasNewlineInRange(",
                        "        options.originalText,",
                        "        locStart(node),",
                        "        propsAndLoc[0].loc",
                        "      ));",
                        "",
                        "  const separator = isFlowInterfaceLikeBody",
                        "    ? \";\"",
                        "    : node.type === \"TSInterfaceBody\" || node.type === \"TSTypeLiteral\"",
                        "    ? ifBreak(semi, \";\")",
                        "    : \",\";",
                        "  const leftBrace =",
                        "    node.type === \"RecordExpression\" ? \"#{\" : node.exact ? \"{|\" : \"{\";",
                        "  const rightBrace = node.exact ? \"|}\" : \"}\";",
                        "",
                        "  /** @type {Doc[]} */",
                        "  let separatorParts = [];",
                        "  const props = propsAndLoc.map((prop) => {",
                        "    const result = [...separatorParts, group(prop.printed)];",
                        "    separatorParts = [separator, line];",
                        "    if (",
                        "      (prop.node.type === \"TSPropertySignature\" ||",
                        "        prop.node.type === \"TSMethodSignature\" ||",
                        "        prop.node.type === \"TSConstructSignatureDeclaration\") &&",
                        "      hasComment(prop.node, CommentCheckFlags.PrettierIgnore)",
                        "    ) {",
                        "      separatorParts.shift();",
                        "    }",
                        "    if (isNextLineEmpty(prop.node, options)) {",
                        "      separatorParts.push(hardline);",
                        "    }",
                        "    return result;",
                        "  });",
                        "",
                        "  if (node.inexact || node.hasUnknownMembers) {",
                        "    let printed;",
                        "    if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      const hasLineComments = hasComment(node, CommentCheckFlags.Line);",
                        "      const printedDanglingComments = printDanglingComments(path, options);",
                        "      printed = [",
                        "        printedDanglingComments,",
                        "        hasLineComments ||",
                        "        hasNewline(options.originalText, locEnd(getComments(node).at(-1)))",
                        "          ? hardline",
                        "          : line,",
                        "        \"...\",",
                        "      ];",
                        "    } else {",
                        "      printed = [\"...\"];",
                        "    }",
                        "    props.push([...separatorParts, ...printed]);",
                        "  }",
                        "",
                        "  const lastElem = propsAndLoc.at(-1)?.node;",
                        "",
                        "  const canHaveTrailingSeparator = !(",
                        "    node.inexact ||",
                        "    node.hasUnknownMembers ||",
                        "    (lastElem &&",
                        "      (lastElem.type === \"RestElement\" ||",
                        "        ((lastElem.type === \"TSPropertySignature\" ||",
                        "          lastElem.type === \"TSCallSignatureDeclaration\" ||",
                        "          lastElem.type === \"TSMethodSignature\" ||",
                        "          lastElem.type === \"TSConstructSignatureDeclaration\") &&",
                        "          hasComment(lastElem, CommentCheckFlags.PrettierIgnore))))",
                        "  );",
                        "",
                        "  let content;",
                        "  if (props.length === 0) {",
                        "    if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      return [leftBrace, rightBrace, printTypeAnnotationProperty(path, print)];",
                        "    }",
                        "",
                        "    content = group([",
                        "      leftBrace,",
                        "      printDanglingComments(path, options, { indent: true }),",
                        "      softline,",
                        "      rightBrace,",
                        "      printOptionalToken(path),",
                        "      printTypeAnnotationProperty(path, print),",
                        "    ]);",
                        "  } else {",
                        "    content = [",
                        "      isFlowInterfaceLikeBody && isNonEmptyArray(node.properties)",
                        "        ? printHardlineAfterHeritage(parent)",
                        "        : \"\",",
                        "      leftBrace,",
                        "      indent([options.bracketSpacing ? line : softline, ...props]),",
                        "      ifBreak(",
                        "        canHaveTrailingSeparator &&",
                        "          (separator !== \",\" || shouldPrintComma(options))",
                        "          ? separator",
                        "          : \"\"",
                        "      ),",
                        "      options.bracketSpacing ? line : softline,",
                        "      rightBrace,",
                        "      printOptionalToken(path),",
                        "      printTypeAnnotationProperty(path, print),",
                        "    ];",
                        "  }",
                        "",
                        "  // If we inline the object as first argument of the parent, we don't want",
                        "  // to create another group so that the object breaks before the return",
                        "  // type",
                        "  if (",
                        "    path.match(",
                        "      (node) => node.type === \"ObjectPattern\" && !node.decorators,",
                        "      shouldHugTheOnlyParameter",
                        "    ) ||",
                        "    (isObjectType(node) &&",
                        "      (path.match(",
                        "        undefined,",
                        "        (node, name) => name === \"typeAnnotation\",",
                        "        (node, name) => name === \"typeAnnotation\",",
                        "        shouldHugTheOnlyParameter",
                        "      ) ||",
                        "        path.match(",
                        "          undefined,",
                        "          (node, name) =>",
                        "            node.type === \"FunctionTypeParam\" && name === \"typeAnnotation\",",
                        "          shouldHugTheOnlyParameter",
                        "        ))) ||",
                        "    // Assignment printing logic (printAssignment) is responsible",
                        "    // for adding a group if needed",
                        "    (!shouldBreak &&",
                        "      path.match(",
                        "        (node) => node.type === \"ObjectPattern\",",
                        "        (node) =>",
                        "          node.type === \"AssignmentExpression\" ||",
                        "          node.type === \"VariableDeclarator\"",
                        "      ))",
                        "  ) {",
                        "    return content;",
                        "  }",
                        "",
                        "  return group(content, { shouldBreak });",
                        "}",
                        "",
                        "function shouldHugTheOnlyParameter(node, name) {",
                        "  return (",
                        "    (name === \"params\" ||",
                        "      name === \"parameters\" ||",
                        "      name === \"this\" ||",
                        "      name === \"rest\") &&",
                        "    shouldHugTheOnlyFunctionParameter(node)",
                        "  );",
                        "}",
                        "",
                        "export { printObject };"
                    ]
                },
                "property.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printComments } from \"../../main/comments/print.js\";",
                        "import printString from \"../../utils/print-string.js\";",
                        "import printNumber from \"../../utils/print-number.js\";",
                        "import {",
                        "  isNumericLiteral,",
                        "  isSimpleNumber,",
                        "  isStringLiteral,",
                        "  isStringPropSafeToUnquote,",
                        "  rawText,",
                        "} from \"../utils/index.js\";",
                        "import { printAssignment } from \"./assignment.js\";",
                        "",
                        "const needsQuoteProps = new WeakMap();",
                        "",
                        "function printPropertyKey(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (node.computed) {",
                        "    return [\"[\", print(\"key\"), \"]\"];",
                        "  }",
                        "",
                        "  const { parent } = path;",
                        "  const { key } = node;",
                        "",
                        "  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {",
                        "    const objectHasStringProp = (",
                        "      parent.properties ||",
                        "      parent.body ||",
                        "      parent.members",
                        "    ).some(",
                        "      (prop) =>",
                        "        !prop.computed &&",
                        "        prop.key &&",
                        "        isStringLiteral(prop.key) &&",
                        "        !isStringPropSafeToUnquote(prop, options)",
                        "    );",
                        "    needsQuoteProps.set(parent, objectHasStringProp);",
                        "  }",
                        "",
                        "  if (",
                        "    (key.type === \"Identifier\" ||",
                        "      (isNumericLiteral(key) &&",
                        "        isSimpleNumber(printNumber(rawText(key))) &&",
                        "        // Avoid converting 999999999999999999999 to 1e+21, 0.99999999999999999 to 1 and 1.0 to 1.",
                        "        String(key.value) === printNumber(rawText(key)) &&",
                        "        // Quoting number keys is safe in JS and Flow, but not in TypeScript (as",
                        "        // mentioned in `isStringPropSafeToUnquote`).",
                        "        !(options.parser === \"typescript\" || options.parser === \"babel-ts\"))) &&",
                        "    (options.parser === \"json\" ||",
                        "      (options.quoteProps === \"consistent\" && needsQuoteProps.get(parent)))",
                        "  ) {",
                        "    // a -> \"a\"",
                        "    // 1 -> \"1\"",
                        "    // 1.5 -> \"1.5\"",
                        "    const prop = printString(",
                        "      JSON.stringify(",
                        "        key.type === \"Identifier\" ? key.name : key.value.toString()",
                        "      ),",
                        "      options",
                        "    );",
                        "    return path.call((keyPath) => printComments(keyPath, prop, options), \"key\");",
                        "  }",
                        "",
                        "  if (",
                        "    isStringPropSafeToUnquote(node, options) &&",
                        "    (options.quoteProps === \"as-needed\" ||",
                        "      (options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent)))",
                        "  ) {",
                        "    // 'a' -> a",
                        "    // '1' -> 1",
                        "    // '1.5' -> 1.5",
                        "    return path.call(",
                        "      (keyPath) =>",
                        "        printComments(",
                        "          keyPath,",
                        "          /^\\d/.test(key.value) ? printNumber(key.value) : key.value,",
                        "          options",
                        "        ),",
                        "      \"key\"",
                        "    );",
                        "  }",
                        "",
                        "  return print(\"key\");",
                        "}",
                        "",
                        "function printProperty(path, options, print) {",
                        "  const { node } = path;",
                        "  if (node.shorthand) {",
                        "    return print(\"value\");",
                        "  }",
                        "",
                        "  return printAssignment(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    printPropertyKey(path, options, print),",
                        "    \":\",",
                        "    \"value\"",
                        "  );",
                        "}",
                        "",
                        "export { printProperty, printPropertyKey };"
                    ]
                },
                "semicolon.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import {",
                        "  getLeftSidePathName,",
                        "  hasNakedLeftSide,",
                        "  isJsxElement,",
                        "} from \"../utils/index.js\";",
                        "import { shouldPrintParamsWithoutParens } from \"./function.js\";",
                        "",
                        "function shouldPrintLeadingSemicolon(path, options) {",
                        "  if (",
                        "    options.semi ||",
                        "    isSingleJsxExpressionStatementInMarkdown(path, options) ||",
                        "    isSingleVueEventBindingExpressionStatement(path, options)",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const { node, key, parent } = path;",
                        "  if (",
                        "    node.type === \"ExpressionStatement\" &&",
                        "    // `Program.directives` don't need leading semicolon",
                        "    ((key === \"body\" &&",
                        "      (parent.type === \"Program\" ||",
                        "        parent.type === \"BlockStatement\" ||",
                        "        parent.type === \"StaticBlock\" ||",
                        "        parent.type === \"TSModuleBlock\")) ||",
                        "      (key === \"consequent\" && parent.type === \"SwitchCase\")) &&",
                        "    path.call(() => expressionNeedsASIProtection(path, options), \"expression\")",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function expressionNeedsASIProtection(path, options) {",
                        "  const { node } = path;",
                        "  switch (node.type) {",
                        "    case \"ParenthesizedExpression\":",
                        "    case \"TypeCastExpression\":",
                        "    case \"ArrayExpression\":",
                        "    case \"ArrayPattern\":",
                        "    case \"TemplateLiteral\":",
                        "    case \"TemplateElement\":",
                        "    case \"RegExpLiteral\":",
                        "      return true;",
                        "    case \"ArrowFunctionExpression\":",
                        "      if (!shouldPrintParamsWithoutParens(path, options)) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "",
                        "    case \"UnaryExpression\": {",
                        "      const { prefix, operator } = node;",
                        "      if (prefix && (operator === \"+\" || operator === \"-\")) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    case \"BindExpression\":",
                        "      if (!node.object) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "",
                        "    case \"Literal\":",
                        "      if (node.regex) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "",
                        "    default:",
                        "      if (isJsxElement(node)) {",
                        "        return true;",
                        "      }",
                        "  }",
                        "",
                        "  if (pathNeedsParens(path, options)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!hasNakedLeftSide(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return path.call(",
                        "    () => expressionNeedsASIProtection(path, options),",
                        "    ...getLeftSidePathName(node)",
                        "  );",
                        "}",
                        "",
                        "function isSingleJsxExpressionStatementInMarkdown({ node, parent }, options) {",
                        "  return (",
                        "    (options.parentParser === \"markdown\" || options.parentParser === \"mdx\") &&",
                        "    node.type === \"ExpressionStatement\" &&",
                        "    isJsxElement(node.expression) &&",
                        "    parent.type === \"Program\" &&",
                        "    parent.body.length === 1",
                        "  );",
                        "}",
                        "",
                        "// based on /src/language-html/syntax-vue.js isVueEventBindingExpression()",
                        "function isVueEventBindingExpression(node) {",
                        "  switch (node.type) {",
                        "    case \"MemberExpression\":",
                        "      switch (node.property.type) {",
                        "        case \"Identifier\":",
                        "        case \"NumericLiteral\":",
                        "        case \"StringLiteral\":",
                        "          return isVueEventBindingExpression(node.object);",
                        "      }",
                        "      return false;",
                        "    case \"Identifier\":",
                        "      return true;",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "function isSingleVueEventBindingExpressionStatement({ node, parent }, options) {",
                        "  return (",
                        "    (options.parser === \"__vue_event_binding\" ||",
                        "      options.parser === \"__vue_ts_event_binding\") &&",
                        "    node.type === \"ExpressionStatement\" &&",
                        "    parent.type === \"Program\" &&",
                        "    parent.body.length === 1",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  shouldPrintLeadingSemicolon,",
                        "  isSingleJsxExpressionStatementInMarkdown,",
                        "  isSingleVueEventBindingExpressionStatement,",
                        "  isVueEventBindingExpression,",
                        "};"
                    ]
                },
                "statement.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { hardline } from \"../../document/builders.js\";",
                        "import { isNextLineEmpty } from \"../utils/index.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path.js\")} AstPath",
                        " */",
                        "",
                        "/*",
                        "- `Program` (\"directives\" and \"body\")",
                        "- `BlockStatement`",
                        "- `StaticBlock`",
                        "- `SwitchCase` (\"consequent\")",
                        "- `TSModuleBlock` (TypeScript)",
                        "*/",
                        "function printStatementSequence(path, options, print, property) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "  const lastStatement = getLastStatement(node[property]);",
                        "",
                        "  path.each(({ node }) => {",
                        "    // Skip printing EmptyStatement nodes to avoid leaving stray",
                        "    // semicolons lying around.",
                        "    if (node.type === \"EmptyStatement\") {",
                        "      return;",
                        "    }",
                        "",
                        "    parts.push(print());",
                        "",
                        "    if (node !== lastStatement) {",
                        "      parts.push(hardline);",
                        "",
                        "      if (isNextLineEmpty(node, options)) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, property);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function getLastStatement(statements) {",
                        "  for (let i = statements.length - 1; i >= 0; i--) {",
                        "    const statement = statements[i];",
                        "    if (statement.type !== \"EmptyStatement\") {",
                        "      return statement;",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "export { printStatementSequence };"
                    ]
                },
                "template-literal.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import getStringWidth from \"../../utils/get-string-width.js\";",
                        "import getIndentSize from \"../../utils/get-indent-size.js\";",
                        "import {",
                        "  join,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  align,",
                        "  lineSuffixBoundary,",
                        "  addAlignmentToDoc,",
                        "  label,",
                        "} from \"../../document/builders.js\";",
                        "import { printDocToString } from \"../../document/printer.js\";",
                        "import { mapDoc } from \"../../document/utils.js\";",
                        "import {",
                        "  isBinaryish,",
                        "  isSimpleTemplateLiteral,",
                        "  hasComment,",
                        "  isMemberExpression,",
                        "  isTSTypeExpression,",
                        "} from \"../utils/index.js\";",
                        "",
                        "function printTemplateLiteral(path, print, options) {",
                        "  const { node } = path;",
                        "  const isTemplateLiteral = node.type === \"TemplateLiteral\";",
                        "",
                        "  if (isTemplateLiteral && isJestEachTemplateLiteral(path)) {",
                        "    const printed = printJestEachTemplateLiteral(path, options, print);",
                        "    if (printed) {",
                        "      return printed;",
                        "    }",
                        "  }",
                        "  let expressionsKey = \"expressions\";",
                        "  if (node.type === \"TSTemplateLiteralType\") {",
                        "    expressionsKey = \"types\";",
                        "  }",
                        "  const parts = [];",
                        "",
                        "  let expressionDocs = path.map(print, expressionsKey);",
                        "  const isSimple = isSimpleTemplateLiteral(node);",
                        "",
                        "  if (isSimple) {",
                        "    expressionDocs = expressionDocs.map(",
                        "      (doc) =>",
                        "        printDocToString(doc, {",
                        "          ...options,",
                        "          printWidth: Number.POSITIVE_INFINITY,",
                        "        }).formatted",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(lineSuffixBoundary, \"`\");",
                        "",
                        "  let previousQuasiIndentSize = 0;",
                        "  path.each(({ index, node: quasi }) => {",
                        "    parts.push(print());",
                        "",
                        "    if (quasi.tail) {",
                        "      return;",
                        "    }",
                        "",
                        "    // For a template literal of the following form:",
                        "    //   `someQuery {",
                        "    //     ${call({",
                        "    //       a,",
                        "    //       b,",
                        "    //     })}",
                        "    //   }`",
                        "    // the expression is on its own line (there is a \\n in the previous",
                        "    // quasi literal), therefore we want to indent the JavaScript",
                        "    // expression inside at the beginning of ${ instead of the beginning",
                        "    // of the `.",
                        "    const { tabWidth } = options;",
                        "    const text = quasi.value.raw;",
                        "    const indentSize = text.includes(\"\\n\")",
                        "      ? getIndentSize(text, tabWidth)",
                        "      : previousQuasiIndentSize;",
                        "    previousQuasiIndentSize = indentSize;",
                        "",
                        "    let expressionDoc = expressionDocs[index];",
                        "",
                        "    if (!isSimple) {",
                        "      const expression = node[expressionsKey][index];",
                        "      // Breaks at the template element boundaries (${ and }) are preferred to breaking",
                        "      // in the middle of a MemberExpression",
                        "      if (",
                        "        hasComment(expression) ||",
                        "        isMemberExpression(expression) ||",
                        "        expression.type === \"ConditionalExpression\" ||",
                        "        expression.type === \"SequenceExpression\" ||",
                        "        isTSTypeExpression(expression) ||",
                        "        isBinaryish(expression)",
                        "      ) {",
                        "        expressionDoc = [indent([softline, expressionDoc]), softline];",
                        "      }",
                        "    }",
                        "",
                        "    const aligned =",
                        "      indentSize === 0 && text.endsWith(\"\\n\")",
                        "        ? align(Number.NEGATIVE_INFINITY, expressionDoc)",
                        "        : addAlignmentToDoc(expressionDoc, indentSize, tabWidth);",
                        "",
                        "    parts.push(group([\"${\", aligned, lineSuffixBoundary, \"}\"]));",
                        "  }, \"quasis\");",
                        "",
                        "  parts.push(\"`\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printTaggedTemplateLiteral(print) {",
                        "  const quasiDoc = print(\"quasi\");",
                        "  return label(quasiDoc.label && { tagged: true, ...quasiDoc.label }, [",
                        "    print(\"tag\"),",
                        "    print(\"typeParameters\"),",
                        "    lineSuffixBoundary,",
                        "    quasiDoc,",
                        "  ]);",
                        "}",
                        "",
                        "function printJestEachTemplateLiteral(path, options, print) {",
                        "  /**",
                        "   * a    | b    | expected",
                        "   * ${1} | ${1} | ${2}",
                        "   * ${1} | ${2} | ${3}",
                        "   * ${2} | ${1} | ${3}",
                        "   */",
                        "  const { node } = path;",
                        "  const headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);",
                        "  if (",
                        "    headerNames.length > 1 ||",
                        "    headerNames.some((headerName) => headerName.length > 0)",
                        "  ) {",
                        "    options.__inJestEach = true;",
                        "    const expressions = path.map(print, \"expressions\");",
                        "    options.__inJestEach = false;",
                        "    const parts = [];",
                        "    const stringifiedExpressions = expressions.map(",
                        "      (doc) =>",
                        "        \"${\" +",
                        "        printDocToString(doc, {",
                        "          ...options,",
                        "          printWidth: Number.POSITIVE_INFINITY,",
                        "          endOfLine: \"lf\",",
                        "        }).formatted +",
                        "        \"}\"",
                        "    );",
                        "",
                        "    const tableBody = [{ hasLineBreak: false, cells: [] }];",
                        "    for (let i = 1; i < node.quasis.length; i++) {",
                        "      const row = tableBody.at(-1);",
                        "      const correspondingExpression = stringifiedExpressions[i - 1];",
                        "",
                        "      row.cells.push(correspondingExpression);",
                        "      if (correspondingExpression.includes(\"\\n\")) {",
                        "        row.hasLineBreak = true;",
                        "      }",
                        "",
                        "      if (node.quasis[i].value.raw.includes(\"\\n\")) {",
                        "        tableBody.push({ hasLineBreak: false, cells: [] });",
                        "      }",
                        "    }",
                        "",
                        "    const maxColumnCount = Math.max(",
                        "      headerNames.length,",
                        "      ...tableBody.map((row) => row.cells.length)",
                        "    );",
                        "",
                        "    const maxColumnWidths = Array.from({ length: maxColumnCount }).fill(0);",
                        "    const table = [",
                        "      { cells: headerNames },",
                        "      ...tableBody.filter((row) => row.cells.length > 0),",
                        "    ];",
                        "    for (const { cells } of table.filter((row) => !row.hasLineBreak)) {",
                        "      for (const [index, cell] of cells.entries()) {",
                        "        maxColumnWidths[index] = Math.max(",
                        "          maxColumnWidths[index],",
                        "          getStringWidth(cell)",
                        "        );",
                        "      }",
                        "    }",
                        "",
                        "    parts.push(",
                        "      lineSuffixBoundary,",
                        "      \"`\",",
                        "      indent([",
                        "        hardline,",
                        "        join(",
                        "          hardline,",
                        "          table.map((row) =>",
                        "            join(",
                        "              \" | \",",
                        "              row.cells.map((cell, index) =>",
                        "                row.hasLineBreak",
                        "                  ? cell",
                        "                  : cell +",
                        "                    \" \".repeat(maxColumnWidths[index] - getStringWidth(cell))",
                        "              )",
                        "            )",
                        "          )",
                        "        ),",
                        "      ]),",
                        "      hardline,",
                        "      \"`\"",
                        "    );",
                        "    return parts;",
                        "  }",
                        "}",
                        "",
                        "function printTemplateExpression(path, print) {",
                        "  const { node } = path;",
                        "  let printed = print();",
                        "  if (hasComment(node)) {",
                        "    printed = group([indent([softline, printed]), softline]);",
                        "  }",
                        "  return [\"${\", printed, lineSuffixBoundary, \"}\"];",
                        "}",
                        "",
                        "function printTemplateExpressions(path, print) {",
                        "  return path.map(",
                        "    (path) => printTemplateExpression(path, print),",
                        "    \"expressions\"",
                        "  );",
                        "}",
                        "",
                        "function escapeTemplateCharacters(doc, raw) {",
                        "  return mapDoc(doc, (currentDoc) => {",
                        "    if (typeof currentDoc === \"string\") {",
                        "      return raw",
                        "        ? currentDoc.replaceAll(/(\\\\*)`/g, \"$1$1\\\\`\")",
                        "        : uncookTemplateElementValue(currentDoc);",
                        "    }",
                        "",
                        "    return currentDoc;",
                        "  });",
                        "}",
                        "",
                        "function uncookTemplateElementValue(cookedValue) {",
                        "  return cookedValue.replaceAll(/([\\\\`]|\\${)/g, \"\\\\$1\");",
                        "}",
                        "",
                        "function isJestEachTemplateLiteral({ node, parent }) {",
                        "  /**",
                        "   * describe.each`table`(name, fn)",
                        "   * describe.only.each`table`(name, fn)",
                        "   * describe.skip.each`table`(name, fn)",
                        "   * test.each`table`(name, fn)",
                        "   * test.only.each`table`(name, fn)",
                        "   * test.skip.each`table`(name, fn)",
                        "   *",
                        "   * Ref: https://github.com/facebook/jest/pull/6102",
                        "   */",
                        "  const jestEachTriggerRegex = /^[fx]?(?:describe|it|test)$/;",
                        "  return (",
                        "    parent.type === \"TaggedTemplateExpression\" &&",
                        "    parent.quasi === node &&",
                        "    parent.tag.type === \"MemberExpression\" &&",
                        "    parent.tag.property.type === \"Identifier\" &&",
                        "    parent.tag.property.name === \"each\" &&",
                        "    ((parent.tag.object.type === \"Identifier\" &&",
                        "      jestEachTriggerRegex.test(parent.tag.object.name)) ||",
                        "      (parent.tag.object.type === \"MemberExpression\" &&",
                        "        parent.tag.object.property.type === \"Identifier\" &&",
                        "        (parent.tag.object.property.name === \"only\" ||",
                        "          parent.tag.object.property.name === \"skip\") &&",
                        "        parent.tag.object.object.type === \"Identifier\" &&",
                        "        jestEachTriggerRegex.test(parent.tag.object.object.name)))",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  printTemplateLiteral,",
                        "  printTaggedTemplateLiteral,",
                        "  printTemplateExpressions,",
                        "  escapeTemplateCharacters,",
                        "  uncookTemplateElementValue,",
                        "};"
                    ]
                },
                "ternary.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import hasNewlineInRange from \"../../utils/has-newline-in-range.js\";",
                        "import {",
                        "  isJsxElement,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isTSTypeExpression,",
                        "  hasComment,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import isBlockComment from \"../utils/is-block-comment.js\";",
                        "import {",
                        "  line,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  align,",
                        "  ifBreak,",
                        "  dedent,",
                        "  breakParent,",
                        "} from \"../../document/builders.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " *",
                        " * @typedef {any} Options - Prettier options (TBD ...)",
                        " */",
                        "",
                        "// If we have nested conditional expressions, we want to print them in JSX mode",
                        "// if there's at least one JSXElement somewhere in the tree.",
                        "//",
                        "// A conditional expression chain like this should be printed in normal mode,",
                        "// because there aren't JSXElements anywhere in it:",
                        "//",
                        "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";",
                        "//",
                        "// But a conditional expression chain like this should be printed in JSX mode,",
                        "// because there is a JSXElement in the last ConditionalExpression:",
                        "//",
                        "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;",
                        "//",
                        "// This type of ConditionalExpression chain is structured like this in the AST:",
                        "//",
                        "// ConditionalExpression {",
                        "//   test: ...,",
                        "//   consequent: ...,",
                        "//   alternate: ConditionalExpression {",
                        "//     test: ...,",
                        "//     consequent: ...,",
                        "//     alternate: ConditionalExpression {",
                        "//       test: ...,",
                        "//       consequent: ...,",
                        "//       alternate: ...,",
                        "//     }",
                        "//   }",
                        "// }",
                        "function conditionalExpressionChainContainsJsx(node) {",
                        "  // Given this code:",
                        "  //",
                        "  // // Using a ConditionalExpression as the consequent is uncommon, but should",
                        "  // // be handled.",
                        "  // A ? B : C ? D : E ? F ? G : H : I",
                        "  //",
                        "  // which has this AST:",
                        "  //",
                        "  // ConditionalExpression {",
                        "  //   test: Identifier(A),",
                        "  //   consequent: Identifier(B),",
                        "  //   alternate: ConditionalExpression {",
                        "  //     test: Identifier(C),",
                        "  //     consequent: Identifier(D),",
                        "  //     alternate: ConditionalExpression {",
                        "  //       test: Identifier(E),",
                        "  //       consequent: ConditionalExpression {",
                        "  //         test: Identifier(F),",
                        "  //         consequent: Identifier(G),",
                        "  //         alternate: Identifier(H),",
                        "  //       },",
                        "  //       alternate: Identifier(I),",
                        "  //     }",
                        "  //   }",
                        "  // }",
                        "  //",
                        "  // We don't care about whether each node was the test, consequent, or alternate",
                        "  // We are only checking if there's any JSXElements inside.",
                        "  const conditionalExpressions = [node];",
                        "  for (let index = 0; index < conditionalExpressions.length; index++) {",
                        "    const conditionalExpression = conditionalExpressions[index];",
                        "    for (const property of [\"test\", \"consequent\", \"alternate\"]) {",
                        "      const node = conditionalExpression[property];",
                        "",
                        "      if (isJsxElement(node)) {",
                        "        return true;",
                        "      }",
                        "",
                        "      if (node.type === \"ConditionalExpression\") {",
                        "        conditionalExpressions.push(node);",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function printTernaryTest(path, options, print) {",
                        "  const { node } = path;",
                        "  const isConditionalExpression = node.type === \"ConditionalExpression\";",
                        "  const alternateNodePropertyName = isConditionalExpression",
                        "    ? \"alternate\"",
                        "    : \"falseType\";",
                        "",
                        "  const { parent } = path;",
                        "",
                        "  const printed = isConditionalExpression",
                        "    ? print(\"test\")",
                        "    : [print(\"checkType\"), \" \", \"extends\", \" \", print(\"extendsType\")];",
                        "  /**",
                        "   *     a",
                        "   *       ? b",
                        "   *       : multiline",
                        "   *         test",
                        "   *         node",
                        "   *       ^^ align(2)",
                        "   *       ? d",
                        "   *       : e",
                        "   */",
                        "  if (parent.type === node.type && parent[alternateNodePropertyName] === node) {",
                        "    return align(2, printed);",
                        "  }",
                        "  return printed;",
                        "}",
                        "",
                        "const ancestorNameMap = new Map([",
                        "  [\"AssignmentExpression\", \"right\"],",
                        "  [\"VariableDeclarator\", \"init\"],",
                        "  [\"ReturnStatement\", \"argument\"],",
                        "  [\"ThrowStatement\", \"argument\"],",
                        "  [\"UnaryExpression\", \"argument\"],",
                        "  [\"YieldExpression\", \"argument\"],",
                        "]);",
                        "function shouldExtraIndentForConditionalExpression(path) {",
                        "  const { node } = path;",
                        "  if (node.type !== \"ConditionalExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  let parent;",
                        "  let child = node;",
                        "  for (let ancestorCount = 0; !parent; ancestorCount++) {",
                        "    const node = path.getParentNode(ancestorCount);",
                        "",
                        "    if (",
                        "      (node.type === \"ChainExpression\" && node.expression === child) ||",
                        "      (isCallExpression(node) && node.callee === child) ||",
                        "      (isMemberExpression(node) && node.object === child) ||",
                        "      (node.type === \"TSNonNullExpression\" && node.expression === child)",
                        "    ) {",
                        "      child = node;",
                        "      continue;",
                        "    }",
                        "",
                        "    // Reached chain root",
                        "",
                        "    if (",
                        "      (node.type === \"NewExpression\" && node.callee === child) ||",
                        "      (isTSTypeExpression(node) && node.expression === child)",
                        "    ) {",
                        "      parent = path.getParentNode(ancestorCount + 1);",
                        "      child = node;",
                        "    } else {",
                        "      parent = node;",
                        "    }",
                        "  }",
                        "",
                        "  // Do not add indent to direct `ConditionalExpression`",
                        "  if (child === node) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return parent[ancestorNameMap.get(parent.type)] === child;",
                        "}",
                        "",
                        "/**",
                        " * The following is the shared logic for",
                        " * ternary operators, namely ConditionalExpression,",
                        " * ConditionalTypeAnnotation and TSConditionalType",
                        " * @param {AstPath} path - The path to the ConditionalExpression/TSConditionalType node.",
                        " * @param {Options} options - Prettier options",
                        " * @param {Function} print - Print function to call recursively",
                        " * @returns {Doc}",
                        " */",
                        "function printTernary(path, options, print) {",
                        "  const { node } = path;",
                        "  const isConditionalExpression = node.type === \"ConditionalExpression\";",
                        "  const consequentNodePropertyName = isConditionalExpression",
                        "    ? \"consequent\"",
                        "    : \"trueType\";",
                        "  const alternateNodePropertyName = isConditionalExpression",
                        "    ? \"alternate\"",
                        "    : \"falseType\";",
                        "  const testNodePropertyNames = isConditionalExpression",
                        "    ? [\"test\"]",
                        "    : [\"checkType\", \"extendsType\"];",
                        "  const consequentNode = node[consequentNodePropertyName];",
                        "  const alternateNode = node[alternateNodePropertyName];",
                        "  const parts = [];",
                        "",
                        "  // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".",
                        "  // See `tests/format/jsx/conditional-expression.js` for more info.",
                        "  let jsxMode = false;",
                        "  const { parent } = path;",
                        "  const isParentTest =",
                        "    parent.type === node.type &&",
                        "    testNodePropertyNames.some((prop) => parent[prop] === node);",
                        "  let forceNoIndent = parent.type === node.type && !isParentTest;",
                        "",
                        "  // Find the outermost non-ConditionalExpression parent, and the outermost",
                        "  // ConditionalExpression parent. We'll use these to determine if we should",
                        "  // print in JSX mode.",
                        "  let currentParent;",
                        "  let previousParent;",
                        "  let i = 0;",
                        "  do {",
                        "    previousParent = currentParent || node;",
                        "    currentParent = path.getParentNode(i);",
                        "    i++;",
                        "  } while (",
                        "    currentParent &&",
                        "    currentParent.type === node.type &&",
                        "    testNodePropertyNames.every(",
                        "      (prop) => currentParent[prop] !== previousParent",
                        "    )",
                        "  );",
                        "  const firstNonConditionalParent = currentParent || parent;",
                        "  const lastConditionalParent = previousParent;",
                        "",
                        "  if (",
                        "    isConditionalExpression &&",
                        "    (isJsxElement(node[testNodePropertyNames[0]]) ||",
                        "      isJsxElement(consequentNode) ||",
                        "      isJsxElement(alternateNode) ||",
                        "      conditionalExpressionChainContainsJsx(lastConditionalParent))",
                        "  ) {",
                        "    jsxMode = true;",
                        "    forceNoIndent = true;",
                        "",
                        "    // Even though they don't need parens, we wrap (almost) everything in",
                        "    // parens when using ?: within JSX, because the parens are analogous to",
                        "    // curly braces in an if statement.",
                        "    const wrap = (doc) => [",
                        "      ifBreak(\"(\"),",
                        "      indent([softline, doc]),",
                        "      softline,",
                        "      ifBreak(\")\"),",
                        "    ];",
                        "",
                        "    // The only things we don't wrap are:",
                        "    // * Nested conditional expressions in alternates",
                        "    // * null",
                        "    // * undefined",
                        "    const isNil = (node) =>",
                        "      node.type === \"NullLiteral\" ||",
                        "      (node.type === \"Literal\" && node.value === null) ||",
                        "      (node.type === \"Identifier\" && node.name === \"undefined\");",
                        "",
                        "    parts.push(",
                        "      \" ? \",",
                        "      isNil(consequentNode)",
                        "        ? print(consequentNodePropertyName)",
                        "        : wrap(print(consequentNodePropertyName)),",
                        "      \" : \",",
                        "      alternateNode.type === node.type || isNil(alternateNode)",
                        "        ? print(alternateNodePropertyName)",
                        "        : wrap(print(alternateNodePropertyName))",
                        "    );",
                        "  } else {",
                        "    // normal mode",
                        "    const part = [",
                        "      line,",
                        "      \"? \",",
                        "      consequentNode.type === node.type ? ifBreak(\"\", \"(\") : \"\",",
                        "      align(2, print(consequentNodePropertyName)),",
                        "      consequentNode.type === node.type ? ifBreak(\"\", \")\") : \"\",",
                        "      line,",
                        "      \": \",",
                        "      alternateNode.type === node.type",
                        "        ? print(alternateNodePropertyName)",
                        "        : align(2, print(alternateNodePropertyName)),",
                        "    ];",
                        "    parts.push(",
                        "      parent.type !== node.type ||",
                        "        parent[alternateNodePropertyName] === node ||",
                        "        isParentTest",
                        "        ? part",
                        "        : options.useTabs",
                        "        ? dedent(indent(part))",
                        "        : align(Math.max(0, options.tabWidth - 2), part)",
                        "    );",
                        "  }",
                        "",
                        "  // We want a whole chain of ConditionalExpressions to all",
                        "  // break if any of them break. That means we should only group around the",
                        "  // outer-most ConditionalExpression.",
                        "  const shouldBreak = [",
                        "    consequentNodePropertyName,",
                        "    alternateNodePropertyName,",
                        "    ...testNodePropertyNames,",
                        "  ].some((property) =>",
                        "    hasComment(",
                        "      node[property],",
                        "      (comment) =>",
                        "        isBlockComment(comment) &&",
                        "        hasNewlineInRange(",
                        "          options.originalText,",
                        "          locStart(comment),",
                        "          locEnd(comment)",
                        "        )",
                        "    )",
                        "  );",
                        "  const maybeGroup = (doc) =>",
                        "    parent === firstNonConditionalParent",
                        "      ? group(doc, { shouldBreak })",
                        "      : shouldBreak",
                        "      ? [doc, breakParent]",
                        "      : doc;",
                        "",
                        "  // Break the closing paren to keep the chain right after it:",
                        "  // (a",
                        "  //   ? b",
                        "  //   : c",
                        "  // ).call()",
                        "  const breakClosingParen =",
                        "    !jsxMode &&",
                        "    (isMemberExpression(parent) ||",
                        "      (parent.type === \"NGPipeExpression\" && parent.left === node)) &&",
                        "    !parent.computed;",
                        "",
                        "  const shouldExtraIndent = shouldExtraIndentForConditionalExpression(path);",
                        "",
                        "  const result = maybeGroup([",
                        "    printTernaryTest(path, options, print),",
                        "    forceNoIndent ? parts : indent(parts),",
                        "    isConditionalExpression && breakClosingParen && !shouldExtraIndent",
                        "      ? softline",
                        "      : \"\",",
                        "  ]);",
                        "",
                        "  return isParentTest || shouldExtraIndent",
                        "    ? group([indent([softline, result]), softline])",
                        "    : result;",
                        "}",
                        "",
                        "export { printTernary };"
                    ]
                },
                "type-annotation.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  group,",
                        "  join,",
                        "  line,",
                        "  softline,",
                        "  indent,",
                        "  align,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import { hasSameLocStart } from \"../loc.js\";",
                        "import {",
                        "  isSimpleType,",
                        "  isObjectType,",
                        "  hasLeadingOwnLineComment,",
                        "  isObjectTypePropertyAFunction,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "} from \"../utils/index.js\";",
                        "import { printAssignment } from \"./assignment.js\";",
                        "import {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} from \"./function-parameters.js\";",
                        "import {",
                        "  printOptionalToken,",
                        "  printDeclareToken,",
                        "  printAbstractToken,",
                        "} from \"./misc.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "function shouldHugType(node) {",
                        "  if (isSimpleType(node) || isObjectType(node)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {",
                        "    const voidCount = node.types.filter(",
                        "      (node) =>",
                        "        node.type === \"VoidTypeAnnotation\" ||",
                        "        node.type === \"TSVoidKeyword\" ||",
                        "        node.type === \"NullLiteralTypeAnnotation\" ||",
                        "        node.type === \"TSNullKeyword\"",
                        "    ).length;",
                        "",
                        "    const hasObject = node.types.some(",
                        "      (node) =>",
                        "        node.type === \"ObjectTypeAnnotation\" ||",
                        "        node.type === \"TSTypeLiteral\" ||",
                        "        // This is a bit aggressive but captures Array<{x}>",
                        "        node.type === \"GenericTypeAnnotation\" ||",
                        "        node.type === \"TSTypeReference\"",
                        "    );",
                        "",
                        "    const hasComments = node.types.some((node) => hasComment(node));",
                        "",
                        "    if (node.types.length - 1 === voidCount && hasObject && !hasComments) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "/*",
                        "- `DeclareOpaqueType`(flow)",
                        "- `OpaqueType`(flow)",
                        "*/",
                        "function printOpaqueType(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const { node } = path;",
                        "  const parts = [",
                        "    printDeclareToken(path),",
                        "    \"opaque type \",",
                        "    print(\"id\"),",
                        "    print(\"typeParameters\"),",
                        "  ];",
                        "",
                        "  if (node.supertype) {",
                        "    parts.push(\": \", print(\"supertype\"));",
                        "  }",
                        "",
                        "  if (node.impltype) {",
                        "    parts.push(\" = \", print(\"impltype\"));",
                        "  }",
                        "",
                        "  parts.push(semi);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "/*",
                        "- `DeclareTypeAlias`(flow)",
                        "- `TypeAlias`(flow)",
                        "- `TSTypeAliasDeclaration`(TypeScript)",
                        "*/",
                        "function printTypeAlias(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const { node } = path;",
                        "  const parts = [printDeclareToken(path)];",
                        "",
                        "  parts.push(\"type \", print(\"id\"), print(\"typeParameters\"));",
                        "  const rightPropertyName =",
                        "    node.type === \"TSTypeAliasDeclaration\" ? \"typeAnnotation\" : \"right\";",
                        "  return [",
                        "    printAssignment(path, options, print, parts, \" =\", rightPropertyName),",
                        "    semi,",
                        "  ];",
                        "}",
                        "",
                        "// `TSIntersectionType` and `IntersectionTypeAnnotation`",
                        "function printIntersectionType(path, options, print) {",
                        "  const { node } = path;",
                        "  const types = path.map(print, \"types\");",
                        "  const result = [];",
                        "  let wasIndented = false;",
                        "  for (let i = 0; i < types.length; ++i) {",
                        "    if (i === 0) {",
                        "      result.push(types[i]);",
                        "    } else if (isObjectType(node.types[i - 1]) && isObjectType(node.types[i])) {",
                        "      // If both are objects, don't indent",
                        "      result.push([\" & \", wasIndented ? indent(types[i]) : types[i]]);",
                        "    } else if (",
                        "      !isObjectType(node.types[i - 1]) &&",
                        "      !isObjectType(node.types[i])",
                        "    ) {",
                        "      // If no object is involved, go to the next line if it breaks",
                        "      result.push(indent([\" &\", line, types[i]]));",
                        "    } else {",
                        "      // If you go from object to non-object or vis-versa, then inline it",
                        "      if (i > 1) {",
                        "        wasIndented = true;",
                        "      }",
                        "      result.push(\" & \", i > 1 ? indent(types[i]) : types[i]);",
                        "    }",
                        "  }",
                        "  return group(result);",
                        "}",
                        "",
                        "// `TSUnionType` and `UnionTypeAnnotation`",
                        "function printUnionType(path, options, print) {",
                        "  const { node } = path;",
                        "  // single-line variation",
                        "  // A | B | C",
                        "",
                        "  // multi-line variation",
                        "  // | A",
                        "  // | B",
                        "  // | C",
                        "",
                        "  const { parent } = path;",
                        "",
                        "  // If there's a leading comment, the parent is doing the indentation",
                        "  const shouldIndent =",
                        "    parent.type !== \"TypeParameterInstantiation\" &&",
                        "    parent.type !== \"TSTypeParameterInstantiation\" &&",
                        "    parent.type !== \"GenericTypeAnnotation\" &&",
                        "    parent.type !== \"TSTypeReference\" &&",
                        "    parent.type !== \"TSTypeAssertion\" &&",
                        "    parent.type !== \"TupleTypeAnnotation\" &&",
                        "    parent.type !== \"TSTupleType\" &&",
                        "    !(",
                        "      parent.type === \"FunctionTypeParam\" &&",
                        "      !parent.name &&",
                        "      path.grandparent.this !== parent",
                        "    ) &&",
                        "    !(",
                        "      (parent.type === \"TypeAlias\" ||",
                        "        parent.type === \"VariableDeclarator\" ||",
                        "        parent.type === \"TSTypeAliasDeclaration\") &&",
                        "      hasLeadingOwnLineComment(options.originalText, node)",
                        "    );",
                        "",
                        "  // {",
                        "  //   a: string",
                        "  // } | null | void",
                        "  // should be inlined and not be printed in the multi-line variant",
                        "  const shouldHug = shouldHugType(node);",
                        "",
                        "  // We want to align the children but without its comment, so it looks like",
                        "  // | child1",
                        "  // // comment",
                        "  // | child2",
                        "  const printed = path.map((typePath) => {",
                        "    let printedType = print();",
                        "    if (!shouldHug) {",
                        "      printedType = align(2, printedType);",
                        "    }",
                        "    return printComments(typePath, printedType, options);",
                        "  }, \"types\");",
                        "",
                        "  if (shouldHug) {",
                        "    return join(\" | \", printed);",
                        "  }",
                        "",
                        "  const shouldAddStartLine =",
                        "    shouldIndent && !hasLeadingOwnLineComment(options.originalText, node);",
                        "",
                        "  const code = [",
                        "    ifBreak([shouldAddStartLine ? line : \"\", \"| \"]),",
                        "    join([line, \"| \"], printed),",
                        "  ];",
                        "",
                        "  if (pathNeedsParens(path, options)) {",
                        "    return group([indent(code), softline]);",
                        "  }",
                        "",
                        "  if (parent.type === \"TupleTypeAnnotation\" || parent.type === \"TSTupleType\") {",
                        "    const elementTypes =",
                        "      parent[",
                        "        // TODO: Remove `types` when babel changes AST of `TupleTypeAnnotation`",
                        "        parent.type === \"TupleTypeAnnotation\" && parent.types",
                        "          ? \"types\"",
                        "          : \"elementTypes\"",
                        "      ];",
                        "",
                        "    if (elementTypes.length > 1) {",
                        "      return group([",
                        "        indent([ifBreak([\"(\", softline]), code]),",
                        "        softline,",
                        "        ifBreak(\")\"),",
                        "      ]);",
                        "    }",
                        "  }",
                        "",
                        "  return group(shouldIndent ? indent(code) : code);",
                        "}",
                        "",
                        "/*",
                        "`FunctionTypeAnnotation` is ambiguous:",
                        "- `declare function foo(a: B): void;`",
                        "- `var A: (a: B) => void;`",
                        "*/",
                        "function isFlowArrowFunctionTypeAnnotation(path) {",
                        "  const { node, parent } = path;",
                        "  return (",
                        "    node.type === \"FunctionTypeAnnotation\" &&",
                        "    (isObjectTypePropertyAFunction(parent) ||",
                        "      !(",
                        "        ((parent.type === \"ObjectTypeProperty\" ||",
                        "          parent.type === \"ObjectTypeInternalSlot\") &&",
                        "          !parent.variance &&",
                        "          !parent.optional &&",
                        "          hasSameLocStart(parent, node)) ||",
                        "        parent.type === \"ObjectTypeCallProperty\" ||",
                        "        path.getParentNode(2)?.type === \"DeclareFunction\"",
                        "      ))",
                        "  );",
                        "}",
                        "",
                        "/*",
                        "- `TSFunctionType` (TypeScript)",
                        "- `TSCallSignatureDeclaration` (TypeScript)",
                        "- `TSConstructorType` (TypeScript)",
                        "- `TSConstructSignatureDeclaration` (TypeScript)",
                        "- `FunctionTypeAnnotation` (Flow)",
                        "*/",
                        "function printFunctionType(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type {Doc[]} */",
                        "  const parts = [",
                        "    // `TSConstructorType` only",
                        "    printAbstractToken(path),",
                        "  ];",
                        "",
                        "  if (",
                        "    node.type === \"TSConstructorType\" ||",
                        "    node.type === \"TSConstructSignatureDeclaration\"",
                        "  ) {",
                        "    parts.push(\"new \");",
                        "  }",
                        "",
                        "  let parametersDoc = printFunctionParameters(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    /* expandArg */ false,",
                        "    /* printTypeParams */ true",
                        "  );",
                        "",
                        "  const returnTypeDoc = [];",
                        "  // `flow` doesn't wrap the `returnType` with `TypeAnnotation`, so the colon",
                        "  // needs to be added separately.",
                        "  if (node.type === \"FunctionTypeAnnotation\") {",
                        "    returnTypeDoc.push(",
                        "      isFlowArrowFunctionTypeAnnotation(path) ? \" => \" : \": \",",
                        "      print(\"returnType\")",
                        "    );",
                        "  } else {",
                        "    returnTypeDoc.push(",
                        "      printTypeAnnotationProperty(",
                        "        path,",
                        "        print,",
                        "        node.returnType ? \"returnType\" : \"typeAnnotation\"",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  if (shouldGroupFunctionParameters(node, returnTypeDoc)) {",
                        "    parametersDoc = group(parametersDoc);",
                        "  }",
                        "",
                        "  parts.push(parametersDoc, returnTypeDoc);",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "/*",
                        "- `TSIndexedAccessType`(TypeScript)",
                        "- `IndexedAccessType`(flow)",
                        "- `OptionalIndexedAccessType`(flow)",
                        "*/",
                        "function printIndexedAccessType(path, options, print) {",
                        "  return [",
                        "    print(\"objectType\"),",
                        "    printOptionalToken(path),",
                        "    \"[\",",
                        "    print(\"indexType\"),",
                        "    \"]\",",
                        "  ];",
                        "}",
                        "",
                        "/*",
                        "- `TSInferType`(TypeScript)",
                        "- `InferTypeAnnotation`(flow)",
                        "*/",
                        "function printInferType(path, options, print) {",
                        "  return [\"infer \", print(\"typeParameter\")];",
                        "}",
                        "",
                        "// `TSJSDocNullableType`, `TSJSDocNonNullableType`",
                        "function printJSDocType(path, print, token) {",
                        "  const { node } = path;",
                        "  return [",
                        "    node.postfix ? \"\" : token,",
                        "    printTypeAnnotationProperty(path, print),",
                        "    node.postfix ? token : \"\",",
                        "  ];",
                        "}",
                        "",
                        "/*",
                        "- `TSRestType`(TypeScript)",
                        "- `TupleTypeSpreadElement`(flow)",
                        "*/",
                        "function printRestType(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  return [",
                        "    \"...\",",
                        "    ...(node.type === \"TupleTypeSpreadElement\" && node.label",
                        "      ? [print(\"label\"), \": \"]",
                        "      : []),",
                        "    print(\"typeAnnotation\"),",
                        "  ];",
                        "}",
                        "",
                        "/*",
                        "- `TSNamedTupleMember`(TypeScript)",
                        "- `TupleTypeLabeledElement`(flow)",
                        "*/",
                        "function printNamedTupleMember(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  return [",
                        "    // `TupleTypeLabeledElement` only",
                        "    node.variance ? print(\"variance\") : \"\",",
                        "    print(\"label\"),",
                        "    node.optional ? \"?\" : \"\",",
                        "    \": \",",
                        "    print(\"elementType\"),",
                        "  ];",
                        "}",
                        "",
                        "/*",
                        "Normally the `(TS)TypeAnnotation` node starts with `:` token.",
                        "If we print `:` in parent node, `cursorNodeDiff` in `/src/main/core.js` will consider `:` is removed, cause cursor moves, see #12491.",
                        "Token *before* `(TS)TypeAnnotation.typeAnnotation` should be printed in `getTypeAnnotationFirstToken` function.",
                        "*/",
                        "const typeAnnotationNodesCheckedLeadingComments = new WeakSet();",
                        "function printTypeAnnotationProperty(",
                        "  path,",
                        "  print,",
                        "  propertyName = \"typeAnnotation\"",
                        ") {",
                        "  const {",
                        "    node: { [propertyName]: typeAnnotation },",
                        "  } = path;",
                        "",
                        "  if (!typeAnnotation) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  let shouldPrintLeadingSpace = false;",
                        "",
                        "  if (",
                        "    typeAnnotation.type === \"TSTypeAnnotation\" ||",
                        "    typeAnnotation.type === \"TypeAnnotation\"",
                        "  ) {",
                        "    const firstToken = path.call(getTypeAnnotationFirstToken, propertyName);",
                        "",
                        "    if (",
                        "      firstToken === \"=>\" ||",
                        "      (firstToken === \":\" &&",
                        "        hasComment(typeAnnotation, CommentCheckFlags.Leading))",
                        "    ) {",
                        "      shouldPrintLeadingSpace = true;",
                        "    }",
                        "",
                        "    typeAnnotationNodesCheckedLeadingComments.add(typeAnnotation);",
                        "  }",
                        "",
                        "  return shouldPrintLeadingSpace",
                        "    ? [\" \", print(propertyName)]",
                        "    : print(propertyName);",
                        "}",
                        "",
                        "const getTypeAnnotationFirstToken = (path) => {",
                        "  if (",
                        "    // TypeScript",
                        "    path.match(",
                        "      (node) => node.type === \"TSTypeAnnotation\",",
                        "      (node, key) =>",
                        "        (key === \"returnType\" || key === \"typeAnnotation\") &&",
                        "        (node.type === \"TSFunctionType\" || node.type === \"TSConstructorType\")",
                        "    )",
                        "  ) {",
                        "    return \"=>\";",
                        "  }",
                        "",
                        "  if (",
                        "    // TypeScript",
                        "    path.match(",
                        "      (node) => node.type === \"TSTypeAnnotation\",",
                        "      (node, key) =>",
                        "        key === \"typeAnnotation\" &&",
                        "        (node.type === \"TSJSDocNullableType\" ||",
                        "          node.type === \"TSJSDocNonNullableType\" ||",
                        "          node.type === \"TSTypePredicate\")",
                        "    ) ||",
                        "    /*",
                        "    Flow",
                        "",
                        "    ```js",
                        "    declare function foo(): void;",
                        "                        ^^^^^^^^ `TypeAnnotation`",
                        "    ```",
                        "    */",
                        "    path.match(",
                        "      (node) => node.type === \"TypeAnnotation\",",
                        "      (node, key) => key === \"typeAnnotation\" && node.type === \"Identifier\",",
                        "      (node, key) => key === \"id\" && node.type === \"DeclareFunction\"",
                        "    ) ||",
                        "    /*",
                        "    Flow",
                        "",
                        "    ```js",
                        "    type A = () => infer R extends string;",
                        "                                   ^^^^^^ `TypeAnnotation`",
                        "    ```",
                        "    */",
                        "    path.match(",
                        "      (node) => node.type === \"TypeAnnotation\",",
                        "      (node, key) =>",
                        "        key === \"bound\" &&",
                        "        node.type === \"TypeParameter\" &&",
                        "        node.usesExtendsBound",
                        "    )",
                        "  ) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  return \":\";",
                        "};",
                        "",
                        "/*",
                        "- `TSTypeAnnotation` (TypeScript)",
                        "- `TypeAnnotation` (Flow)",
                        "*/",
                        "function printTypeAnnotation(path, options, print) {",
                        "  // We need print space before leading comments,",
                        "  // `printTypeAnnotationProperty` is responsible for it.",
                        "  /* c8 ignore start */",
                        "  if (process.env.NODE_ENV !== \"production\") {",
                        "    const { node } = path;",
                        "",
                        "    if (!typeAnnotationNodesCheckedLeadingComments.has(node)) {",
                        "      throw Object.assign(",
                        "        new Error(",
                        "          `'${node.type}' should be printed by '${printTypeAnnotationProperty.name}' function.`",
                        "        ),",
                        "        { parentNode: path.parent, propertyName: path.key }",
                        "      );",
                        "    }",
                        "  }",
                        "  /* c8 ignore stop */",
                        "",
                        "  const token = getTypeAnnotationFirstToken(path);",
                        "  return token",
                        "    ? [token, \" \", print(\"typeAnnotation\")]",
                        "    : print(\"typeAnnotation\");",
                        "}",
                        "",
                        "/*",
                        "- `TSArrayType`",
                        "- `ArrayTypeAnnotation`",
                        "*/",
                        "function printArrayType(print) {",
                        "  return [print(\"elementType\"), \"[]\"];",
                        "}",
                        "",
                        "/*",
                        "- `TSTypeQuery`",
                        "- `TypeofTypeAnnotation`",
                        "*/",
                        "function printTypeQuery({ node }, print) {",
                        "  return [",
                        "    \"typeof \",",
                        "    ...(node.type === \"TSTypeQuery\"",
                        "      ? [print(\"exprName\"), print(\"typeParameters\")]",
                        "      : [print(\"argument\")]),",
                        "  ];",
                        "}",
                        "",
                        "export {",
                        "  printOpaqueType,",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printIndexedAccessType,",
                        "  printInferType,",
                        "  shouldHugType,",
                        "  printJSDocType,",
                        "  printRestType,",
                        "  printNamedTupleMember,",
                        "  printTypeAnnotationProperty,",
                        "  printTypeAnnotation,",
                        "  printArrayType,",
                        "  printTypeQuery,",
                        "};"
                    ]
                },
                "type-parameters.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  join,",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  isTestCall,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isTSXFile,",
                        "  shouldPrintComma,",
                        "  getFunctionParameters,",
                        "  isObjectType,",
                        "} from \"../utils/index.js\";",
                        "import createGroupIdMapper from \"../../utils/create-group-id-mapper.js\";",
                        "import {",
                        "  printTypeAnnotationProperty,",
                        "  shouldHugType,",
                        "} from \"./type-annotation.js\";",
                        "import { isArrowFunctionVariableDeclarator } from \"./assignment.js\";",
                        "import { printTypeScriptMappedTypeModifier } from \"./mapped-type.js\";",
                        "",
                        "const getTypeParametersGroupId = createGroupIdMapper(\"typeParameters\");",
                        "",
                        "function printTypeParameters(path, options, print, paramsKey) {",
                        "  const { node } = path;",
                        "",
                        "  if (!node[paramsKey]) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // for TypeParameterDeclaration typeParameters is a single node",
                        "  if (!Array.isArray(node[paramsKey])) {",
                        "    return print(paramsKey);",
                        "  }",
                        "",
                        "  const grandparent = path.getNode(2);",
                        "  const isParameterInTestCall = grandparent && isTestCall(grandparent);",
                        "",
                        "  const isArrowFunctionVariable = path.match(",
                        "    (node) =>",
                        "      !(node[paramsKey].length === 1 && isObjectType(node[paramsKey][0])),",
                        "    undefined,",
                        "    (node, name) => name === \"typeAnnotation\",",
                        "    (node) => node.type === \"Identifier\",",
                        "    isArrowFunctionVariableDeclarator",
                        "  );",
                        "",
                        "  const shouldInline =",
                        "    node[paramsKey].length === 0 ||",
                        "    (!isArrowFunctionVariable &&",
                        "      (isParameterInTestCall ||",
                        "        (node[paramsKey].length === 1 &&",
                        "          (node[paramsKey][0].type === \"NullableTypeAnnotation\" ||",
                        "            shouldHugType(node[paramsKey][0])))));",
                        "",
                        "  if (shouldInline) {",
                        "    return [",
                        "      \"<\",",
                        "      join(\", \", path.map(print, paramsKey)),",
                        "      printDanglingCommentsForInline(path, options),",
                        "      \">\",",
                        "    ];",
                        "  }",
                        "",
                        "  // Keep comma if the file extension is .tsx and",
                        "  // has one type parameter that isn't extend with any types.",
                        "  // Because, otherwise formatted result will be invalid as tsx.",
                        "  const trailingComma =",
                        "    node.type === \"TSTypeParameterInstantiation\" // https://github.com/microsoft/TypeScript/issues/21984",
                        "      ? \"\"",
                        "      : getFunctionParameters(node).length === 1 &&",
                        "        isTSXFile(options) &&",
                        "        !node[paramsKey][0].constraint &&",
                        "        path.parent.type === \"ArrowFunctionExpression\"",
                        "      ? \",\"",
                        "      : shouldPrintComma(options)",
                        "      ? ifBreak(\",\")",
                        "      : \"\";",
                        "",
                        "  return group(",
                        "    [",
                        "      \"<\",",
                        "      indent([softline, join([\",\", line], path.map(print, paramsKey))]),",
                        "      trailingComma,",
                        "      softline,",
                        "      \">\",",
                        "    ],",
                        "    { id: getTypeParametersGroupId(node) }",
                        "  );",
                        "}",
                        "",
                        "function printDanglingCommentsForInline(path, options) {",
                        "  const { node } = path;",
                        "  if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    return \"\";",
                        "  }",
                        "  const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);",
                        "  const printed = printDanglingComments(path, options, {",
                        "    indent: !hasOnlyBlockComments,",
                        "  });",
                        "  if (hasOnlyBlockComments) {",
                        "    return printed;",
                        "  }",
                        "  return [printed, hardline];",
                        "}",
                        "",
                        "function printTypeParameter(path, options, print) {",
                        "  const { node, parent } = path;",
                        "",
                        "  /**",
                        "   * @type {import(\"../../document/builders.js\").Doc[]}",
                        "   */",
                        "  const parts = [node.type === \"TSTypeParameter\" && node.const ? \"const \" : \"\"];",
                        "",
                        "  const name = node.type === \"TSTypeParameter\" ? print(\"name\") : node.name;",
                        "",
                        "  if (parent.type === \"TSMappedType\") {",
                        "    if (parent.readonly) {",
                        "      parts.push(",
                        "        printTypeScriptMappedTypeModifier(parent.readonly, \"readonly\"),",
                        "        \" \"",
                        "      );",
                        "    }",
                        "    parts.push(\"[\", name);",
                        "    if (node.constraint) {",
                        "      parts.push(\" in \", print(\"constraint\"));",
                        "    }",
                        "    if (parent.nameType) {",
                        "      parts.push(",
                        "        \" as \",",
                        "        path.callParent(() => print(\"nameType\"))",
                        "      );",
                        "    }",
                        "    parts.push(\"]\");",
                        "    return parts;",
                        "  }",
                        "",
                        "  if (node.variance) {",
                        "    parts.push(print(\"variance\"));",
                        "  }",
                        "",
                        "  if (node.in) {",
                        "    parts.push(\"in \");",
                        "  }",
                        "",
                        "  if (node.out) {",
                        "    parts.push(\"out \");",
                        "  }",
                        "",
                        "  parts.push(name);",
                        "",
                        "  if (node.bound) {",
                        "    if (node.usesExtendsBound) {",
                        "      parts.push(\" extends \");",
                        "    }",
                        "",
                        "    parts.push(printTypeAnnotationProperty(path, print, \"bound\"));",
                        "  }",
                        "",
                        "  if (node.constraint) {",
                        "    parts.push(\" extends\", indent([line, print(\"constraint\")]));",
                        "  }",
                        "",
                        "  if (node.default) {",
                        "    parts.push(\" = \", print(\"default\"));",
                        "  }",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "export { printTypeParameter, printTypeParameters, getTypeParametersGroupId };"
                    ]
                },
                "typescript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  join,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  conditionalGroup,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                        "import {",
                        "  isStringLiteral,",
                        "  shouldPrintComma,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import isTsKeywordType from \"../utils/is-ts-keyword-type.js\";",
                        "import { locStart } from \"../loc.js\";",
                        "",
                        "import {",
                        "  printOptionalToken,",
                        "  printDeclareToken,",
                        "  printTypeScriptAccessibilityToken,",
                        "} from \"./misc.js\";",
                        "import { printTernary } from \"./ternary.js\";",
                        "import {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} from \"./function-parameters.js\";",
                        "import { printTemplateLiteral } from \"./template-literal.js\";",
                        "import { printArray } from \"./array.js\";",
                        "import { printObject } from \"./object.js\";",
                        "import { printClassProperty, printClassMethod } from \"./class.js\";",
                        "import { printTypeParameter, printTypeParameters } from \"./type-parameters.js\";",
                        "import { printPropertyKey } from \"./property.js\";",
                        "import { printFunction, printMethodValue } from \"./function.js\";",
                        "import { printInterface } from \"./interface.js\";",
                        "import { printBlock } from \"./block.js\";",
                        "import {",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printIndexedAccessType,",
                        "  printInferType,",
                        "  printJSDocType,",
                        "  printRestType,",
                        "  printNamedTupleMember,",
                        "  printTypeAnnotation,",
                        "  printTypeAnnotationProperty,",
                        "  printArrayType,",
                        "  printTypeQuery,",
                        "} from \"./type-annotation.js\";",
                        "import { printEnumDeclaration, printEnumMember } from \"./enum.js\";",
                        "import { printImportKind } from \"./module.js\";",
                        "import { printTypescriptMappedType } from \"./mapped-type.js\";",
                        "",
                        "function printTypescript(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  // TypeScript nodes always starts with `TS`",
                        "  if (!node.type.startsWith(\"TS\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (isTsKeywordType(node)) {",
                        "    // TS keyword types stars with `TS`, ends with `Keyword`",
                        "    return node.type.slice(2, -7).toLowerCase();",
                        "  }",
                        "",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const parts = [];",
                        "",
                        "  switch (node.type) {",
                        "    case \"TSThisType\":",
                        "      return \"this\";",
                        "    case \"TSTypeAssertion\": {",
                        "      const shouldBreakAfterCast = !(",
                        "        isArrayOrTupleExpression(node.expression) ||",
                        "        isObjectOrRecordExpression(node.expression)",
                        "      );",
                        "",
                        "      const castGroup = group([",
                        "        \"<\",",
                        "        indent([softline, print(\"typeAnnotation\")]),",
                        "        softline,",
                        "        \">\",",
                        "      ]);",
                        "",
                        "      const exprContents = [",
                        "        ifBreak(\"(\"),",
                        "        indent([softline, print(\"expression\")]),",
                        "        softline,",
                        "        ifBreak(\")\"),",
                        "      ];",
                        "",
                        "      if (shouldBreakAfterCast) {",
                        "        return conditionalGroup([",
                        "          [castGroup, print(\"expression\")],",
                        "          [castGroup, group(exprContents, { shouldBreak: true })],",
                        "          [castGroup, print(\"expression\")],",
                        "        ]);",
                        "      }",
                        "      return group([castGroup, print(\"expression\")]);",
                        "    }",
                        "    case \"TSDeclareFunction\":",
                        "      return printFunction(path, print, options);",
                        "    case \"TSExportAssignment\":",
                        "      return [\"export = \", print(\"expression\"), semi];",
                        "    case \"TSModuleBlock\":",
                        "      return printBlock(path, options, print);",
                        "    case \"TSInterfaceBody\":",
                        "    case \"TSTypeLiteral\":",
                        "      return printObject(path, options, print);",
                        "    case \"TSTypeAliasDeclaration\":",
                        "      return printTypeAlias(path, options, print);",
                        "    case \"TSQualifiedName\":",
                        "      return [print(\"left\"), \".\", print(\"right\")];",
                        "    case \"TSAbstractMethodDefinition\":",
                        "    case \"TSDeclareMethod\":",
                        "      return printClassMethod(path, options, print);",
                        "    case \"TSAbstractAccessorProperty\":",
                        "    case \"TSAbstractPropertyDefinition\":",
                        "      return printClassProperty(path, options, print);",
                        "    case \"TSInterfaceHeritage\":",
                        "    case \"TSClassImplements\":",
                        "    case \"TSExpressionWithTypeArguments\": // Babel AST",
                        "    case \"TSInstantiationExpression\":",
                        "      return [print(\"expression\"), print(\"typeParameters\")];",
                        "    case \"TSTemplateLiteralType\":",
                        "      return printTemplateLiteral(path, print, options);",
                        "    case \"TSNamedTupleMember\":",
                        "      return printNamedTupleMember(path, options, print);",
                        "    case \"TSRestType\":",
                        "      return printRestType(path, options, print);",
                        "    case \"TSOptionalType\":",
                        "      return [print(\"typeAnnotation\"), \"?\"];",
                        "    case \"TSInterfaceDeclaration\":",
                        "      return printInterface(path, options, print);",
                        "    case \"TSTypeParameterDeclaration\":",
                        "    case \"TSTypeParameterInstantiation\":",
                        "      return printTypeParameters(path, options, print, \"params\");",
                        "    case \"TSTypeParameter\":",
                        "      return printTypeParameter(path, options, print);",
                        "    case \"TSAsExpression\":",
                        "    case \"TSSatisfiesExpression\": {",
                        "      const operator = node.type === \"TSAsExpression\" ? \"as\" : \"satisfies\";",
                        "      parts.push(print(\"expression\"), ` ${operator} `, print(\"typeAnnotation\"));",
                        "      const { parent } = path;",
                        "      if (",
                        "        (isCallExpression(parent) && parent.callee === node) ||",
                        "        (isMemberExpression(parent) && parent.object === node)",
                        "      ) {",
                        "        return group([indent([softline, ...parts]), softline]);",
                        "      }",
                        "      return parts;",
                        "    }",
                        "    case \"TSArrayType\":",
                        "      return printArrayType(print);",
                        "    case \"TSPropertySignature\":",
                        "      return [",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        printPropertyKey(path, options, print),",
                        "        printOptionalToken(path),",
                        "        printTypeAnnotationProperty(path, print),",
                        "      ];",
                        "",
                        "    case \"TSParameterProperty\":",
                        "      return [",
                        "        printTypeScriptAccessibilityToken(node),",
                        "        node.static ? \"static \" : \"\",",
                        "        node.override ? \"override \" : \"\",",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        print(\"parameter\"),",
                        "      ];",
                        "",
                        "    case \"TSTypeQuery\":",
                        "      return printTypeQuery(path, print);",
                        "    case \"TSIndexSignature\": {",
                        "      // The typescript parser accepts multiple parameters here. If you're",
                        "      // using them, it makes sense to have a trailing comma. But if you",
                        "      // aren't, this is more like a computed property name than an array.",
                        "      // So we leave off the trailing comma when there's just one parameter.",
                        "      const trailingComma =",
                        "        node.parameters.length > 1",
                        "          ? ifBreak(shouldPrintComma(options) ? \",\" : \"\")",
                        "          : \"\";",
                        "",
                        "      const parametersGroup = group([",
                        "        indent([",
                        "          softline,",
                        "          join([\", \", softline], path.map(print, \"parameters\")),",
                        "        ]),",
                        "        trailingComma,",
                        "        softline,",
                        "      ]);",
                        "",
                        "      const isClassMember =",
                        "        path.parent.type === \"ClassBody\" && path.key === \"body\";",
                        "",
                        "      return [",
                        "        // `static` only allowed in class member",
                        "        isClassMember && node.static ? \"static \" : \"\",",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        \"[\",",
                        "        node.parameters ? parametersGroup : \"\",",
                        "        \"]\",",
                        "        printTypeAnnotationProperty(path, print),",
                        "        isClassMember ? semi : \"\",",
                        "      ];",
                        "    }",
                        "    case \"TSTypePredicate\":",
                        "      return [",
                        "        node.asserts ? \"asserts \" : \"\",",
                        "        print(\"parameterName\"),",
                        "        node.typeAnnotation",
                        "          ? [\" is \", printTypeAnnotationProperty(path, print)]",
                        "          : \"\",",
                        "      ];",
                        "    case \"TSNonNullExpression\":",
                        "      return [print(\"expression\"), \"!\"];",
                        "    case \"TSImportType\":",
                        "      return [",
                        "        !node.isTypeOf ? \"\" : \"typeof \",",
                        "        \"import(\",",
                        "        print(node.parameter ? \"parameter\" : \"argument\"),",
                        "        \")\",",
                        "        !node.qualifier ? \"\" : [\".\", print(\"qualifier\")],",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"TSLiteralType\":",
                        "      return print(\"literal\");",
                        "    case \"TSIndexedAccessType\":",
                        "      return printIndexedAccessType(path, options, print);",
                        "",
                        "    case \"TSTypeOperator\":",
                        "      return [node.operator, \" \", print(\"typeAnnotation\")];",
                        "",
                        "    case \"TSMappedType\":",
                        "      return printTypescriptMappedType(path, options, print);",
                        "",
                        "    case \"TSMethodSignature\": {",
                        "      const kind = node.kind && node.kind !== \"method\" ? `${node.kind} ` : \"\";",
                        "      parts.push(",
                        "        printTypeScriptAccessibilityToken(node),",
                        "        kind,",
                        "        node.computed ? \"[\" : \"\",",
                        "        print(\"key\"),",
                        "        node.computed ? \"]\" : \"\",",
                        "        printOptionalToken(path)",
                        "      );",
                        "",
                        "      const parametersDoc = printFunctionParameters(",
                        "        path,",
                        "        print,",
                        "        options,",
                        "        /* expandArg */ false,",
                        "        /* printTypeParams */ true",
                        "      );",
                        "",
                        "      const returnTypePropertyName = node.returnType",
                        "        ? \"returnType\"",
                        "        : \"typeAnnotation\";",
                        "      const returnTypeNode = node[returnTypePropertyName];",
                        "      const returnTypeDoc = returnTypeNode",
                        "        ? printTypeAnnotationProperty(path, print, returnTypePropertyName)",
                        "        : \"\";",
                        "      const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "        node,",
                        "        returnTypeDoc",
                        "      );",
                        "",
                        "      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);",
                        "",
                        "      if (returnTypeNode) {",
                        "        parts.push(group(returnTypeDoc));",
                        "      }",
                        "",
                        "      return group(parts);",
                        "    }",
                        "    case \"TSNamespaceExportDeclaration\":",
                        "      return [\"export as namespace \", print(\"id\"), options.semi ? \";\" : \"\"];",
                        "    case \"TSEnumDeclaration\":",
                        "      return printEnumDeclaration(path, print, options);",
                        "",
                        "    case \"TSEnumMember\":",
                        "      return printEnumMember(path, print);",
                        "",
                        "    case \"TSImportEqualsDeclaration\":",
                        "      return [",
                        "        node.isExport ? \"export \" : \"\",",
                        "        \"import \",",
                        "        printImportKind(node, /* spaceBeforeKind */ false),",
                        "        print(\"id\"),",
                        "        \" = \",",
                        "        print(\"moduleReference\"),",
                        "        options.semi ? \";\" : \"\",",
                        "      ];",
                        "    case \"TSExternalModuleReference\":",
                        "      return [\"require(\", print(\"expression\"), \")\"];",
                        "    case \"TSModuleDeclaration\": {",
                        "      const { parent } = path;",
                        "      const parentIsDeclaration = parent.type === \"TSModuleDeclaration\";",
                        "      const bodyIsDeclaration = node.body?.type === \"TSModuleDeclaration\";",
                        "",
                        "      if (parentIsDeclaration) {",
                        "        parts.push(\".\");",
                        "      } else {",
                        "        parts.push(printDeclareToken(path));",
                        "",
                        "        // Global declaration looks like this:",
                        "        // (declare)? global { ... }",
                        "        const isGlobal =",
                        "          node.kind === \"global\" ||",
                        "          // TODO: Use `node.kind` when babel update AST",
                        "          // https://github.com/typescript-eslint/typescript-eslint/pull/6443",
                        "          node.global;",
                        "",
                        "        if (!isGlobal) {",
                        "          const kind =",
                        "            node.kind ??",
                        "            // TODO: Use `node.kind` when babel update AST",
                        "            (isStringLiteral(node.id) ||",
                        "            /(?:^|\\s)module(?:\\s|$)/.test(",
                        "              options.originalText.slice(locStart(node), locStart(node.id))",
                        "            )",
                        "              ? \"module\"",
                        "              : \"namespace\");",
                        "          parts.push(kind, \" \");",
                        "        }",
                        "      }",
                        "",
                        "      parts.push(print(\"id\"));",
                        "",
                        "      if (bodyIsDeclaration) {",
                        "        parts.push(print(\"body\"));",
                        "      } else if (node.body) {",
                        "        parts.push(\" \", group(print(\"body\")));",
                        "      } else {",
                        "        parts.push(semi);",
                        "      }",
                        "",
                        "      return parts;",
                        "    }",
                        "",
                        "    case \"TSConditionalType\":",
                        "      return printTernary(path, options, print);",
                        "",
                        "    case \"TSInferType\":",
                        "      return printInferType(path, options, print);",
                        "    case \"TSIntersectionType\":",
                        "      return printIntersectionType(path, options, print);",
                        "    case \"TSUnionType\":",
                        "      return printUnionType(path, options, print);",
                        "    case \"TSFunctionType\":",
                        "    case \"TSCallSignatureDeclaration\":",
                        "    case \"TSConstructorType\":",
                        "    case \"TSConstructSignatureDeclaration\":",
                        "      return printFunctionType(path, options, print);",
                        "    case \"TSTupleType\":",
                        "      return printArray(path, options, print);",
                        "    case \"TSTypeReference\":",
                        "      return [",
                        "        print(\"typeName\"),",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"TSTypeAnnotation\":",
                        "      return printTypeAnnotation(path, options, print);",
                        "    case \"TSEmptyBodyFunctionExpression\":",
                        "      return printMethodValue(path, options, print);",
                        "",
                        "    // These are not valid TypeScript. Printing them just for the sake of error recovery.",
                        "    case \"TSJSDocAllType\":",
                        "      return \"*\";",
                        "    case \"TSJSDocUnknownType\":",
                        "      return \"?\";",
                        "    case \"TSJSDocNullableType\":",
                        "      return printJSDocType(path, print, /* token */ \"?\");",
                        "    case \"TSJSDocNonNullableType\":",
                        "      return printJSDocType(path, print, /* token */ \"!\");",
                        "    case \"TSParenthesizedType\": // Removed in `../parse/postprocess.js`",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      throw new UnexpectedNodeError(node, \"TypeScript\");",
                        "  }",
                        "}",
                        "",
                        "export { printTypescript };"
                    ]
                }
            },
            "traverse": {
                "get-visitor-keys.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import createGetVisitorKeys from \"../../utils/create-get-visitor-keys.js\";",
                        "import visitorKeys from \"./visitor-keys.evaluate.js\";",
                        "",
                        "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                        "",
                        "export default getVisitorKeys;"
                    ]
                },
                "union-visitor-keys.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function unionVisitorKeys(all) {",
                        "  const result = {};",
                        "",
                        "  for (const [type, keys] of all.flatMap((keys) => Object.entries(keys))) {",
                        "    result[type] = [...new Set([...(result[type] ?? []), ...keys])];",
                        "  }",
                        "",
                        "  return result;",
                        "}",
                        "",
                        "export default unionVisitorKeys;"
                    ]
                },
                "visitor-keys.evaluate.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { VISITOR_KEYS as babelVisitorKeys } from \"@babel/types\";",
                        "import { visitorKeys as tsVisitorKeys } from \"@typescript-eslint/visitor-keys\";",
                        "import { VisitorKeys as flowVisitorKeys } from \"hermes-eslint\";",
                        "import unionVisitorKeys from \"./union-visitor-keys.js\";",
                        "",
                        "const angularVisitorKeys = {",
                        "  NGRoot: [\"node\"],",
                        "  NGPipeExpression: [\"left\", \"right\", \"arguments\"],",
                        "  NGChainedExpression: [\"expressions\"],",
                        "  NGEmptyExpression: [],",
                        "  NGMicrosyntax: [\"body\"],",
                        "  NGMicrosyntaxKey: [],",
                        "  NGMicrosyntaxExpression: [\"expression\", \"alias\"],",
                        "  NGMicrosyntaxKeyedExpression: [\"key\", \"expression\"],",
                        "  NGMicrosyntaxLet: [\"key\", \"value\"],",
                        "  NGMicrosyntaxAs: [\"key\", \"alias\"],",
                        "};",
                        "",
                        "const additionalVisitorKeys = {",
                        "  // Prettier",
                        "  JsExpressionRoot: [\"node\"],",
                        "  JsonRoot: [\"node\"],",
                        "",
                        "  // TypeScript",
                        "  TSJSDocAllType: [],",
                        "  TSJSDocUnknownType: [],",
                        "  TSJSDocNullableType: [\"typeAnnotation\"],",
                        "  TSJSDocNonNullableType: [\"typeAnnotation\"],",
                        "",
                        "  // Flow",
                        "  ClassProperty: [\"variance\"],",
                        "  ClassPrivateProperty: [\"variance\"],",
                        "  ConditionalTypeAnnotation: [",
                        "    \"checkType\",",
                        "    \"extendsType\",",
                        "    \"trueType\",",
                        "    \"falseType\",",
                        "  ],",
                        "  DeclareEnum: flowVisitorKeys.EnumDeclaration,",
                        "  InferTypeAnnotation: [\"typeParameter\"],",
                        "  KeyofTypeAnnotation: [\"argument\"],",
                        "  ObjectTypeMappedTypeProperty: [",
                        "    \"keyTparam\",",
                        "    \"propType\",",
                        "    \"sourceType\",",
                        "    \"variance\",",
                        "  ],",
                        "  QualifiedTypeofIdentifier: [\"id\", \"qualification\"],",
                        "  TupleTypeAnnotation: [\"elementTypes\"],",
                        "  TupleTypeSpreadElement: [\"label\", \"typeAnnotation\"],",
                        "  TupleTypeLabeledElement: [\"label\", \"elementType\", \"variance\"],",
                        "  NeverTypeAnnotation: [],",
                        "  UndefinedTypeAnnotation: [],",
                        "  UnknownTypeAnnotation: [],",
                        "};",
                        "",
                        "const excludeKeys = {",
                        "  // From `tsVisitorKeys`",
                        "  MethodDefinition: [\"typeParameters\"],",
                        "  TSPropertySignature: [\"initializer\"],",
                        "",
                        "  // From `flowVisitorKeys`",
                        "  ArrowFunctionExpression: [\"id\"],",
                        "  DeclareOpaqueType: [\"impltype\"],",
                        "  FunctionExpression: [\"predicate\"],",
                        "  // TODO: Remove `types` when babel changes AST of `TupleTypeAnnotation`",
                        "  // Flow parser changed `.types` to `.elementTypes` https://github.com/facebook/flow/commit/5b60e6a81dc277dfab2e88fa3737a4dc9aafdcab",
                        "  // TupleTypeAnnotation: [\"types\"],",
                        "  PropertyDefinition: [\"tsModifiers\"],",
                        "",
                        "  // From `babelVisitorKeys`",
                        "  DeclareInterface: [\"mixins\", \"implements\"],",
                        "  InterfaceDeclaration: [\"mixins\", \"implements\"],",
                        "};",
                        "",
                        "const visitorKeys = Object.fromEntries(",
                        "  Object.entries(",
                        "    unionVisitorKeys([",
                        "      babelVisitorKeys,",
                        "      tsVisitorKeys,",
                        "      flowVisitorKeys,",
                        "      angularVisitorKeys,",
                        "      additionalVisitorKeys,",
                        "    ])",
                        "  ).map(([type, keys]) => [",
                        "    type,",
                        "    excludeKeys[type]",
                        "      ? keys.filter((key) => !excludeKeys[type].includes(key))",
                        "      : keys,",
                        "  ])",
                        ");",
                        "",
                        "export default visitorKeys;"
                    ]
                }
            },
            "types": {
                "estree.d.ts": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as ESTree from \"estree\";",
                        "import * as Babel from \"@babel/types\";",
                        "import { TSESTree } from \"@typescript-eslint/typescript-estree\";",
                        "import { ESTree as Meriyah } from \"meriyah\";",
                        "import * as NGTree from \"angular-estree-parser/lib/types.js\";",
                        "",
                        "type AdditionalFields = {",
                        "  extra?: {",
                        "    parenthesized?: boolean;",
                        "    raw?: string;",
                        "  };",
                        "  comments?: Comment[];",
                        "  trailingComments?: ReadonlyArray<Comment> | Comment[];",
                        "  leadingComments?: ReadonlyArray<Comment> | Comment[];",
                        "};",
                        "",
                        "export type Comment = (",
                        "  | ESTree.Comment",
                        "  | Babel.Comment",
                        "  | TSESTree.Comment",
                        "  | Meriyah.Comment",
                        ") & {",
                        "  printed?: boolean;",
                        "  trailing?: boolean;",
                        "  leading?: boolean;",
                        "};",
                        "",
                        "export type Node = (ESTree.Node | Babel.Node | TSESTree.Node | NGTree.NGNode) &",
                        "  AdditionalFields;",
                        "",
                        "export type TemplateLiteral = (",
                        "  | ESTree.TemplateLiteral",
                        "  | Babel.TemplateLiteral",
                        "  | TSESTree.TemplateLiteral",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type CallExpression = (",
                        "  | ESTree.CallExpression",
                        "  | Babel.CallExpression",
                        "  | TSESTree.CallExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type OptionalCallExpression = Babel.OptionalCallExpression &",
                        "  AdditionalFields;",
                        "",
                        "export type MemberExpression = (",
                        "  | ESTree.MemberExpression",
                        "  | Babel.MemberExpression",
                        "  | TSESTree.MemberExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type OptionalMemberExpression = Babel.OptionalMemberExpression &",
                        "  AdditionalFields;",
                        "",
                        "export type Expression = (",
                        "  | ESTree.Expression",
                        "  | Babel.Expression",
                        "  | TSESTree.Expression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type BindExpression = Babel.BindExpression & AdditionalFields;",
                        "",
                        "export type Property = (ESTree.Property | Babel.Property | TSESTree.Property) &",
                        "  AdditionalFields;",
                        "",
                        "export type ClassPrivateProperty = Babel.ClassPrivateProperty &",
                        "  AdditionalFields;",
                        "",
                        "export type ObjectTypeProperty = Babel.ObjectTypeProperty & AdditionalFields;",
                        "",
                        "export type JSXElement = (Babel.JSXElement | TSESTree.JSXElement) &",
                        "  AdditionalFields;",
                        "",
                        "export type TaggedTemplateExpression = (",
                        "  | ESTree.TaggedTemplateExpression",
                        "  | Babel.TaggedTemplateExpression",
                        "  | TSESTree.TaggedTemplateExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type Literal = (ESTree.Literal | Babel.Literal | TSESTree.Literal) &",
                        "  AdditionalFields;",
                        "",
                        "export { ESTree, Babel, TSESTree, NGTree };"
                    ]
                }
            },
            "utils": {
                "create-type-check-function.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function createTypeCheckFunction(types) {",
                        "  types = new Set(types);",
                        "  return (node) => types.has(node?.type);",
                        "}",
                        "",
                        "export default createTypeCheckFunction;"
                    ]
                },
                "get-shebang.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function getShebang(text) {",
                        "  if (!text.startsWith(\"#!\")) {",
                        "    return \"\";",
                        "  }",
                        "  const index = text.indexOf(\"\\n\");",
                        "  if (index === -1) {",
                        "    return text;",
                        "  }",
                        "  return text.slice(0, index);",
                        "}",
                        "",
                        "export default getShebang;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isEs5IdentifierName from \"@prettier/is-es5-identifier-name\";",
                        "import { hasDescendant } from \"../../utils/ast-utils.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import isNextLineEmptyAfterIndex from \"../../utils/is-next-line-empty.js\";",
                        "import getStringWidth from \"../../utils/get-string-width.js\";",
                        "import { locStart, locEnd, hasSameLocStart } from \"../loc.js\";",
                        "import getVisitorKeys from \"../traverse/get-visitor-keys.js\";",
                        "import createTypeCheckFunction from \"./create-type-check-function.js\";",
                        "import isBlockComment from \"./is-block-comment.js\";",
                        "import isNodeMatches from \"./is-node-matches.js\";",
                        "import isFlowKeywordType from \"./is-flow-keyword-type.js\";",
                        "import isTsKeywordType from \"./is-ts-keyword-type.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " * @typedef {import(\"../types/estree.js\").TemplateLiteral} TemplateLiteral",
                        " * @typedef {import(\"../types/estree.js\").Comment} Comment",
                        " * @typedef {import(\"../types/estree.js\").MemberExpression} MemberExpression",
                        " * @typedef {import(\"../types/estree.js\").OptionalMemberExpression} OptionalMemberExpression",
                        " * @typedef {import(\"../types/estree.js\").CallExpression} CallExpression",
                        " * @typedef {import(\"../types/estree.js\").OptionalCallExpression} OptionalCallExpression",
                        " * @typedef {import(\"../types/estree.js\").Expression} Expression",
                        " * @typedef {import(\"../types/estree.js\").Property} Property",
                        " * @typedef {import(\"../types/estree.js\").ObjectTypeProperty} ObjectTypeProperty",
                        " * @typedef {import(\"../types/estree.js\").TaggedTemplateExpression} TaggedTemplateExpression",
                        " * @typedef {import(\"../types/estree.js\").Literal} Literal",
                        " *",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " */",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {(Node) => boolean} predicate",
                        " * @returns {boolean}",
                        " */",
                        "function hasNode(node, predicate) {",
                        "  return predicate(node) || hasDescendant(node, { getVisitorKeys, predicate });",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasNakedLeftSide(node) {",
                        "  return (",
                        "    node.type === \"AssignmentExpression\" ||",
                        "    node.type === \"BinaryExpression\" ||",
                        "    node.type === \"LogicalExpression\" ||",
                        "    node.type === \"NGPipeExpression\" ||",
                        "    node.type === \"ConditionalExpression\" ||",
                        "    isCallExpression(node) ||",
                        "    isMemberExpression(node) ||",
                        "    node.type === \"SequenceExpression\" ||",
                        "    node.type === \"TaggedTemplateExpression\" ||",
                        "    node.type === \"BindExpression\" ||",
                        "    (node.type === \"UpdateExpression\" && !node.prefix) ||",
                        "    isTSTypeExpression(node) ||",
                        "    node.type === \"TSNonNullExpression\" ||",
                        "    node.type === \"ChainExpression\"",
                        "  );",
                        "}",
                        "",
                        "function getLeftSide(node) {",
                        "  if (node.expressions) {",
                        "    return node.expressions[0];",
                        "  }",
                        "  return (",
                        "    node.left ??",
                        "    node.test ??",
                        "    node.callee ??",
                        "    node.object ??",
                        "    node.tag ??",
                        "    node.argument ??",
                        "    node.expression",
                        "  );",
                        "}",
                        "",
                        "function getLeftSidePathName(node) {",
                        "  if (node.expressions) {",
                        "    return [\"expressions\", 0];",
                        "  }",
                        "  if (node.left) {",
                        "    return [\"left\"];",
                        "  }",
                        "  if (node.test) {",
                        "    return [\"test\"];",
                        "  }",
                        "  if (node.object) {",
                        "    return [\"object\"];",
                        "  }",
                        "  if (node.callee) {",
                        "    return [\"callee\"];",
                        "  }",
                        "  if (node.tag) {",
                        "    return [\"tag\"];",
                        "  }",
                        "  if (node.argument) {",
                        "    return [\"argument\"];",
                        "  }",
                        "  if (node.expression) {",
                        "    return [\"expression\"];",
                        "  }",
                        "  throw new Error(\"Unexpected node has no left side.\");",
                        "}",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "const isLineComment = createTypeCheckFunction([",
                        "  \"Line\",",
                        "  \"CommentLine\",",
                        "  // `meriyah` has `SingleLine`, `HashbangComment`, `HTMLOpen`, and `HTMLClose`",
                        "  \"SingleLine\",",
                        "  \"HashbangComment\",",
                        "  \"HTMLOpen\",",
                        "  \"HTMLClose\",",
                        "  // `espree`",
                        "  \"Hashbang\",",
                        "  // Babel hashbang",
                        "  \"InterpreterDirective\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isExportDeclaration = createTypeCheckFunction([",
                        "  \"ExportDefaultDeclaration\",",
                        "  \"DeclareExportDeclaration\",",
                        "  \"ExportNamedDeclaration\",",
                        "  \"ExportAllDeclaration\",",
                        "  \"DeclareExportAllDeclaration\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isArrayOrTupleExpression = createTypeCheckFunction([",
                        "  \"ArrayExpression\",",
                        "  \"TupleExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isObjectOrRecordExpression = createTypeCheckFunction([",
                        "  \"ObjectExpression\",",
                        "  \"RecordExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isNumericLiteral(node) {",
                        "  return (",
                        "    node.type === \"NumericLiteral\" ||",
                        "    (node.type === \"Literal\" && typeof node.value === \"number\")",
                        "  );",
                        "}",
                        "",
                        "function isSignedNumericLiteral(node) {",
                        "  return (",
                        "    node.type === \"UnaryExpression\" &&",
                        "    (node.operator === \"+\" || node.operator === \"-\") &&",
                        "    isNumericLiteral(node.argument)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isStringLiteral(node) {",
                        "  return (",
                        "    node.type === \"StringLiteral\" ||",
                        "    (node.type === \"Literal\" && typeof node.value === \"string\")",
                        "  );",
                        "}",
                        "",
                        "function isRegExpLiteral(node) {",
                        "  return (",
                        "    node.type === \"RegExpLiteral\" ||",
                        "    (node.type === \"Literal\" && Boolean(node.regex))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isObjectType = createTypeCheckFunction([",
                        "  \"ObjectTypeAnnotation\",",
                        "  \"TSTypeLiteral\",",
                        "  \"TSMappedType\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isFunctionOrArrowExpression = createTypeCheckFunction([",
                        "  \"FunctionExpression\",",
                        "  \"ArrowFunctionExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isFunctionOrArrowExpressionWithBody(node) {",
                        "  return (",
                        "    node.type === \"FunctionExpression\" ||",
                        "    (node.type === \"ArrowFunctionExpression\" &&",
                        "      node.body.type === \"BlockStatement\")",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * Note: `inject` is used in AngularJS 1.x, `async` and `fakeAsync` in",
                        " * Angular 2+, although `async` is deprecated and replaced by `waitForAsync`",
                        " * since Angular 12.",
                        " *",
                        " * example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-",
                        " *",
                        " * @param {CallExpression} node",
                        " * @returns {boolean}",
                        " */",
                        "function isAngularTestWrapper(node) {",
                        "  return (",
                        "    isCallExpression(node) &&",
                        "    node.callee.type === \"Identifier\" &&",
                        "    [\"async\", \"inject\", \"fakeAsync\", \"waitForAsync\"].includes(node.callee.name)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isJsxElement = createTypeCheckFunction([\"JSXElement\", \"JSXFragment\"]);",
                        "",
                        "function isGetterOrSetter(node) {",
                        "  return node.kind === \"get\" || node.kind === \"set\";",
                        "}",
                        "",
                        "// TODO: This is a bad hack and we need a better way to distinguish between",
                        "// arrow functions and otherwise",
                        "function isFunctionNotation(node) {",
                        "  return isGetterOrSetter(node) || hasSameLocStart(node, node.value);",
                        "}",
                        "",
                        "// Hack to differentiate between the following two which have the same ast",
                        "// type T = { method: () => void };",
                        "// type T = { method(): void };",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isObjectTypePropertyAFunction(node) {",
                        "  return (",
                        "    (node.type === \"ObjectTypeProperty\" ||",
                        "      node.type === \"ObjectTypeInternalSlot\") &&",
                        "    node.value.type === \"FunctionTypeAnnotation\" &&",
                        "    !node.static &&",
                        "    !isFunctionNotation(node)",
                        "  );",
                        "}",
                        "",
                        "// Hack to differentiate between the following two which have the same ast",
                        "// declare function f(a): void;",
                        "// var f: (a) => void;",
                        "function isTypeAnnotationAFunction(node) {",
                        "  return (",
                        "    (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") &&",
                        "    node.typeAnnotation.type === \"FunctionTypeAnnotation\" &&",
                        "    !node.static &&",
                        "    !hasSameLocStart(node, node.typeAnnotation)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isBinaryish = createTypeCheckFunction([",
                        "  \"BinaryExpression\",",
                        "  \"LogicalExpression\",",
                        "  \"NGPipeExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isMemberish(node) {",
                        "  return (",
                        "    isMemberExpression(node) ||",
                        "    (node.type === \"BindExpression\" && Boolean(node.object))",
                        "  );",
                        "}",
                        "",
                        "const isSimpleTypeAnnotation = createTypeCheckFunction([",
                        "  \"TSThisType\",",
                        "  // literals",
                        "  \"NullLiteralTypeAnnotation\",",
                        "  \"BooleanLiteralTypeAnnotation\",",
                        "  \"StringLiteralTypeAnnotation\",",
                        "  \"BigIntLiteralTypeAnnotation\",",
                        "  \"NumberLiteralTypeAnnotation\",",
                        "  \"TSLiteralType\",",
                        "  \"TSTemplateLiteralType\",",
                        "]);",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleType(node) {",
                        "  return (",
                        "    isTsKeywordType(node) ||",
                        "    isFlowKeywordType(node) ||",
                        "    isSimpleTypeAnnotation(node) ||",
                        "    ((node.type === \"GenericTypeAnnotation\" ||",
                        "      node.type === \"TSTypeReference\") &&",
                        "      !node.typeParameters)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {CallExpression} node",
                        " * @returns {boolean}",
                        " */",
                        "function isUnitTestSetUp(node) {",
                        "  const unitTestSetUpRe = /^(?:before|after)(?:Each|All)$/;",
                        "  return (",
                        "    node.callee.type === \"Identifier\" &&",
                        "    node.arguments.length === 1 &&",
                        "    unitTestSetUpRe.test(node.callee.name)",
                        "  );",
                        "}",
                        "",
                        "const testCallCalleePatterns = [",
                        "  \"it\",",
                        "  \"it.only\",",
                        "  \"it.skip\",",
                        "  \"describe\",",
                        "  \"describe.only\",",
                        "  \"describe.skip\",",
                        "  \"test\",",
                        "  \"test.only\",",
                        "  \"test.skip\",",
                        "  \"test.step\",",
                        "  \"test.describe\",",
                        "  \"test.describe.only\",",
                        "  \"test.describe.parallel\",",
                        "  \"test.describe.parallel.only\",",
                        "  \"test.describe.serial\",",
                        "  \"test.describe.serial.only\",",
                        "  \"skip\",",
                        "  \"xit\",",
                        "  \"xdescribe\",",
                        "  \"xtest\",",
                        "  \"fit\",",
                        "  \"fdescribe\",",
                        "  \"ftest\",",
                        "];",
                        "",
                        "function isTestCallCallee(node) {",
                        "  return isNodeMatches(node, testCallCalleePatterns);",
                        "}",
                        "",
                        "// eg; `describe(\"some string\", (done) => {})`",
                        "function isTestCall(node, parent) {",
                        "  if (node.type !== \"CallExpression\") {",
                        "    return false;",
                        "  }",
                        "  if (node.arguments.length === 1) {",
                        "    if (isAngularTestWrapper(node) && parent && isTestCall(parent)) {",
                        "      return isFunctionOrArrowExpression(node.arguments[0]);",
                        "    }",
                        "",
                        "    if (isUnitTestSetUp(node)) {",
                        "      return isAngularTestWrapper(node.arguments[0]);",
                        "    }",
                        "  } else if (",
                        "    (node.arguments.length === 2 || node.arguments.length === 3) &&",
                        "    (node.arguments[0].type === \"TemplateLiteral\" ||",
                        "      isStringLiteral(node.arguments[0])) &&",
                        "    isTestCallCallee(node.callee)",
                        "  ) {",
                        "    // it(\"name\", () => { ... }, 2500)",
                        "    if (node.arguments[2] && !isNumericLiteral(node.arguments[2])) {",
                        "      return false;",
                        "    }",
                        "    return (",
                        "      (node.arguments.length === 2",
                        "        ? isFunctionOrArrowExpression(node.arguments[1])",
                        "        : isFunctionOrArrowExpressionWithBody(node.arguments[1]) &&",
                        "          getFunctionParameters(node.arguments[1]).length <= 1) ||",
                        "      isAngularTestWrapper(node.arguments[1])",
                        "    );",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isCallExpression = createTypeCheckFunction([",
                        "  \"CallExpression\",",
                        "  \"OptionalCallExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isMemberExpression = createTypeCheckFunction([",
                        "  \"MemberExpression\",",
                        "  \"OptionalMemberExpression\",",
                        "]);",
                        "",
                        "/**",
                        " *",
                        " * @param {any} node",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleTemplateLiteral(node) {",
                        "  let expressionsKey = \"expressions\";",
                        "  if (node.type === \"TSTemplateLiteralType\") {",
                        "    expressionsKey = \"types\";",
                        "  }",
                        "  const expressions = node[expressionsKey];",
                        "",
                        "  if (expressions.length === 0) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return expressions.every((expr) => {",
                        "    // Disallow comments since printDocToString can't print them here",
                        "    if (hasComment(expr)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    // Allow `x` and `this`",
                        "    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {",
                        "      return true;",
                        "    }",
                        "",
                        "    if (expr.type === \"ChainExpression\") {",
                        "      expr = expr.expression;",
                        "    }",
                        "",
                        "    // Allow `a.b.c`, `a.b[c]`, and `this.x.y`",
                        "    if (isMemberExpression(expr)) {",
                        "      let head = expr;",
                        "      while (isMemberExpression(head)) {",
                        "        if (",
                        "          head.property.type !== \"Identifier\" &&",
                        "          head.property.type !== \"Literal\" &&",
                        "          head.property.type !== \"StringLiteral\" &&",
                        "          head.property.type !== \"NumericLiteral\"",
                        "        ) {",
                        "          return false;",
                        "        }",
                        "        head = head.object;",
                        "        if (hasComment(head)) {",
                        "          return false;",
                        "        }",
                        "      }",
                        "",
                        "      if (head.type === \"Identifier\" || head.type === \"ThisExpression\") {",
                        "        return true;",
                        "      }",
                        "",
                        "      return false;",
                        "    }",
                        "",
                        "    return false;",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasLeadingOwnLineComment(text, node) {",
                        "  if (isJsxElement(node)) {",
                        "    return hasNodeIgnoreComment(node);",
                        "  }",
                        "",
                        "  return hasComment(node, CommentCheckFlags.Leading, (comment) =>",
                        "    hasNewline(text, locEnd(comment))",
                        "  );",
                        "}",
                        "",
                        "// Note: Quoting/unquoting numbers in TypeScript is not safe.",
                        "//",
                        "// let a = { 1: 1, 2: 2 }",
                        "// let b = { '1': 1, '2': 2 }",
                        "//",
                        "// declare let aa: keyof typeof a;",
                        "// declare let bb: keyof typeof b;",
                        "//",
                        "// aa = bb;",
                        "// ^^",
                        "// Type '\"1\" | \"2\"' is not assignable to type '1 | 2'.",
                        "//   Type '\"1\"' is not assignable to type '1 | 2'.(2322)",
                        "//",
                        "// And in Flow, you get:",
                        "//",
                        "// const x = {",
                        "//   0: 1",
                        "//   ^ Non-string literal property keys not supported. [unsupported-syntax]",
                        "// }",
                        "//",
                        "// Angular does not support unquoted numbers in expressions.",
                        "//",
                        "// So we play it safe and only unquote numbers for the JavaScript parsers.",
                        "// (Vue supports unquoted numbers in expressions, but let’s keep it simple.)",
                        "//",
                        "// Identifiers can be unquoted in more circumstances, though.",
                        "function isStringPropSafeToUnquote(node, options) {",
                        "  return (",
                        "    options.parser !== \"json\" &&",
                        "    isStringLiteral(node.key) &&",
                        "    rawText(node.key).slice(1, -1) === node.key.value &&",
                        "    ((isEs5IdentifierName(node.key.value) &&",
                        "      // With `--strictPropertyInitialization`, TS treats properties with quoted names differently than unquoted ones.",
                        "      // See https://github.com/microsoft/TypeScript/pull/20075",
                        "      !(",
                        "        (options.parser === \"babel-ts\" && node.type === \"ClassProperty\") ||",
                        "        (options.parser === \"typescript\" && node.type === \"PropertyDefinition\")",
                        "      )) ||",
                        "      (isSimpleNumber(node.key.value) &&",
                        "        String(Number(node.key.value)) === node.key.value &&",
                        "        (options.parser === \"babel\" ||",
                        "          options.parser === \"acorn\" ||",
                        "          options.parser === \"espree\" ||",
                        "          options.parser === \"meriyah\" ||",
                        "          options.parser === \"__babel_estree\")))",
                        "  );",
                        "}",
                        "",
                        "// Matches “simple” numbers like `123` and `2.5` but not `1_000`, `1e+100` or `0b10`.",
                        "function isSimpleNumber(numberString) {",
                        "  return /^(?:\\d+|\\d+\\.\\d+)$/.test(numberString);",
                        "}",
                        "",
                        "/**",
                        " * @param {TemplateLiteral} template",
                        " * @returns {boolean}",
                        " */",
                        "function templateLiteralHasNewLines(template) {",
                        "  return template.quasis.some((quasi) => quasi.value.raw.includes(\"\\n\"));",
                        "}",
                        "",
                        "/**",
                        " * @param {TemplateLiteral | TaggedTemplateExpression} node",
                        " * @param {string} text",
                        " * @returns {boolean}",
                        " */",
                        "function isTemplateOnItsOwnLine(node, text) {",
                        "  return (",
                        "    ((node.type === \"TemplateLiteral\" && templateLiteralHasNewLines(node)) ||",
                        "      (node.type === \"TaggedTemplateExpression\" &&",
                        "        templateLiteralHasNewLines(node.quasi))) &&",
                        "    !hasNewline(text, locStart(node), { backwards: true })",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function needsHardlineAfterDanglingComment(node) {",
                        "  if (!hasComment(node)) {",
                        "    return false;",
                        "  }",
                        "  const lastDanglingComment = getComments(node, CommentCheckFlags.Dangling).at(",
                        "    -1",
                        "  );",
                        "  return lastDanglingComment && !isBlockComment(lastDanglingComment);",
                        "}",
                        "",
                        "// Logic to check for args with multiple anonymous functions. For instance,",
                        "// the following call should be split on multiple lines for readability:",
                        "// source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))",
                        "function isFunctionCompositionArgs(args) {",
                        "  if (args.length <= 1) {",
                        "    return false;",
                        "  }",
                        "  let count = 0;",
                        "  for (const arg of args) {",
                        "    if (isFunctionOrArrowExpression(arg)) {",
                        "      count += 1;",
                        "      if (count > 1) {",
                        "        return true;",
                        "      }",
                        "    } else if (isCallExpression(arg)) {",
                        "      for (const childArg of arg.arguments) {",
                        "        if (isFunctionOrArrowExpression(childArg)) {",
                        "          return true;",
                        "        }",
                        "      }",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "// Logic to determine if a call is a “long curried function call”.",
                        "// See https://github.com/prettier/prettier/issues/1420.",
                        "//",
                        "// `connect(a, b, c)(d)`",
                        "// In the above call expression, the second call is the parent node and the",
                        "// first call is the current node.",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function isLongCurriedCallExpression(path) {",
                        "  const { node, parent, key } = path;",
                        "  return (",
                        "    key === \"callee\" &&",
                        "    isCallExpression(node) &&",
                        "    isCallExpression(parent) &&",
                        "    parent.arguments.length > 0 &&",
                        "    node.arguments.length > parent.arguments.length",
                        "  );",
                        "}",
                        "",
                        "const simpleCallArgumentUnaryOperators = new Set([\"!\", \"-\", \"+\", \"~\"]);",
                        "",
                        "/**",
                        " * @param {any} node",
                        " * @param {number} depth",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleCallArgument(node, depth = 2) {",
                        "  if (depth <= 0) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const isChildSimple = (child) => isSimpleCallArgument(child, depth - 1);",
                        "",
                        "  if (isRegExpLiteral(node)) {",
                        "    return getStringWidth(node.pattern ?? node.regex.pattern) <= 5;",
                        "  }",
                        "",
                        "  if (",
                        "    node.type === \"Literal\" ||",
                        "    node.type === \"BigIntLiteral\" ||",
                        "    node.type === \"DecimalLiteral\" ||",
                        "    node.type === \"BooleanLiteral\" ||",
                        "    node.type === \"NullLiteral\" ||",
                        "    node.type === \"NumericLiteral\" ||",
                        "    node.type === \"StringLiteral\" ||",
                        "    node.type === \"Identifier\" ||",
                        "    node.type === \"ThisExpression\" ||",
                        "    node.type === \"Super\" ||",
                        "    node.type === \"PrivateName\" ||",
                        "    node.type === \"PrivateIdentifier\" ||",
                        "    node.type === \"ArgumentPlaceholder\" ||",
                        "    node.type === \"Import\"",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.type === \"TemplateLiteral\") {",
                        "    return (",
                        "      node.quasis.every((element) => !element.value.raw.includes(\"\\n\")) &&",
                        "      node.expressions.every(isChildSimple)",
                        "    );",
                        "  }",
                        "",
                        "  if (isObjectOrRecordExpression(node)) {",
                        "    return node.properties.every(",
                        "      (p) => !p.computed && (p.shorthand || (p.value && isChildSimple(p.value)))",
                        "    );",
                        "  }",
                        "",
                        "  if (isArrayOrTupleExpression(node)) {",
                        "    return node.elements.every((x) => x === null || isChildSimple(x));",
                        "  }",
                        "",
                        "  if (isCallLikeExpression(node)) {",
                        "    if (",
                        "      node.type === \"ImportExpression\" ||",
                        "      isSimpleCallArgument(node.callee, depth)",
                        "    ) {",
                        "      const args = getCallArguments(node);",
                        "      return args.length <= depth && args.every(isChildSimple);",
                        "    }",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isMemberExpression(node)) {",
                        "    return (",
                        "      isSimpleCallArgument(node.object, depth) &&",
                        "      isSimpleCallArgument(node.property, depth)",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    (node.type === \"UnaryExpression\" &&",
                        "      simpleCallArgumentUnaryOperators.has(node.operator)) ||",
                        "    node.type === \"UpdateExpression\"",
                        "  ) {",
                        "    return isSimpleCallArgument(node.argument, depth);",
                        "  }",
                        "",
                        "  if (node.type === \"TSNonNullExpression\") {",
                        "    return isSimpleCallArgument(node.expression, depth);",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function rawText(node) {",
                        "  return node.extra?.raw ?? node.raw;",
                        "}",
                        "",
                        "function identity(x) {",
                        "  return x;",
                        "}",
                        "",
                        "function isTSXFile(options) {",
                        "  return options.filepath && /\\.tsx$/i.test(options.filepath);",
                        "}",
                        "",
                        "/**",
                        " * @param {any} options",
                        " * @param {(\"es5\" | \"all\")} [level]",
                        " * @returns {boolean}",
                        " */",
                        "function shouldPrintComma(options, level = \"es5\") {",
                        "  return (",
                        "    (options.trailingComma === \"es5\" && level === \"es5\") ||",
                        "    (options.trailingComma === \"all\" && (level === \"all\" || level === \"es5\"))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * Tests if the leftmost node of the expression matches the predicate. E.g.,",
                        " * used to check whether an expression statement needs to be wrapped in extra",
                        " * parentheses because it starts with:",
                        " *",
                        " * - `{`",
                        " * - `function`, `class`, or `do {}`",
                        " * - `let[`",
                        " *",
                        " * Will be overzealous if there already are necessary grouping parentheses.",
                        " *",
                        " * @param {Node} node",
                        " * @param {(leftmostNode: Node) => boolean} predicate",
                        " * @returns {boolean}",
                        " */",
                        "function startsWithNoLookaheadToken(node, predicate) {",
                        "  switch (node.type) {",
                        "    case \"BinaryExpression\":",
                        "    case \"LogicalExpression\":",
                        "    case \"AssignmentExpression\":",
                        "    case \"NGPipeExpression\":",
                        "      return startsWithNoLookaheadToken(node.left, predicate);",
                        "    case \"MemberExpression\":",
                        "    case \"OptionalMemberExpression\":",
                        "      return startsWithNoLookaheadToken(node.object, predicate);",
                        "    case \"TaggedTemplateExpression\":",
                        "      if (node.tag.type === \"FunctionExpression\") {",
                        "        // IIFEs are always already parenthesized",
                        "        return false;",
                        "      }",
                        "      return startsWithNoLookaheadToken(node.tag, predicate);",
                        "    case \"CallExpression\":",
                        "    case \"OptionalCallExpression\":",
                        "      if (node.callee.type === \"FunctionExpression\") {",
                        "        // IIFEs are always already parenthesized",
                        "        return false;",
                        "      }",
                        "      return startsWithNoLookaheadToken(node.callee, predicate);",
                        "    case \"ConditionalExpression\":",
                        "      return startsWithNoLookaheadToken(node.test, predicate);",
                        "    case \"UpdateExpression\":",
                        "      return (",
                        "        !node.prefix && startsWithNoLookaheadToken(node.argument, predicate)",
                        "      );",
                        "    case \"BindExpression\":",
                        "      return node.object && startsWithNoLookaheadToken(node.object, predicate);",
                        "    case \"SequenceExpression\":",
                        "      return startsWithNoLookaheadToken(node.expressions[0], predicate);",
                        "    case \"ChainExpression\":",
                        "    case \"TSSatisfiesExpression\":",
                        "    case \"TSAsExpression\":",
                        "    case \"TSNonNullExpression\":",
                        "      return startsWithNoLookaheadToken(node.expression, predicate);",
                        "    default:",
                        "      return predicate(node);",
                        "  }",
                        "}",
                        "",
                        "const equalityOperators = {",
                        "  \"==\": true,",
                        "  \"!=\": true,",
                        "  \"===\": true,",
                        "  \"!==\": true,",
                        "};",
                        "const multiplicativeOperators = {",
                        "  \"*\": true,",
                        "  \"/\": true,",
                        "  \"%\": true,",
                        "};",
                        "const bitshiftOperators = {",
                        "  \">>\": true,",
                        "  \">>>\": true,",
                        "  \"<<\": true,",
                        "};",
                        "",
                        "function shouldFlatten(parentOp, nodeOp) {",
                        "  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // ** is right-associative",
                        "  // x ** y ** z --> x ** (y ** z)",
                        "  if (parentOp === \"**\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x == y == z --> (x == y) == z",
                        "  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x * y % z --> (x * y) % z",
                        "  if (",
                        "    (nodeOp === \"%\" && multiplicativeOperators[parentOp]) ||",
                        "    (parentOp === \"%\" && multiplicativeOperators[nodeOp])",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x * y / z --> (x * y) / z",
                        "  // x / y * z --> (x / y) * z",
                        "  if (",
                        "    nodeOp !== parentOp &&",
                        "    multiplicativeOperators[nodeOp] &&",
                        "    multiplicativeOperators[parentOp]",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x << y << z --> (x << y) << z",
                        "  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "const PRECEDENCE = new Map(",
                        "  [",
                        "    [\"|>\"],",
                        "    [\"??\"],",
                        "    [\"||\"],",
                        "    [\"&&\"],",
                        "    [\"|\"],",
                        "    [\"^\"],",
                        "    [\"&\"],",
                        "    [\"==\", \"===\", \"!=\", \"!==\"],",
                        "    [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],",
                        "    [\">>\", \"<<\", \">>>\"],",
                        "    [\"+\", \"-\"],",
                        "    [\"*\", \"/\", \"%\"],",
                        "    [\"**\"],",
                        "  ].flatMap((operators, index) =>",
                        "    operators.map((operator) => [operator, index])",
                        "  )",
                        ");",
                        "function getPrecedence(operator) {",
                        "  return PRECEDENCE.get(operator);",
                        "}",
                        "",
                        "function isBitwiseOperator(operator) {",
                        "  return (",
                        "    Boolean(bitshiftOperators[operator]) ||",
                        "    operator === \"|\" ||",
                        "    operator === \"^\" ||",
                        "    operator === \"&\"",
                        "  );",
                        "}",
                        "",
                        "function hasRestParameter(node) {",
                        "  if (node.rest) {",
                        "    return true;",
                        "  }",
                        "  const parameters = getFunctionParameters(node);",
                        "  return parameters.at(-1)?.type === \"RestElement\";",
                        "}",
                        "",
                        "const functionParametersCache = new WeakMap();",
                        "function getFunctionParameters(node) {",
                        "  if (functionParametersCache.has(node)) {",
                        "    return functionParametersCache.get(node);",
                        "  }",
                        "  const parameters = [];",
                        "  if (node.this) {",
                        "    parameters.push(node.this);",
                        "  }",
                        "  // `params` vs `parameters` - see https://github.com/babel/babel/issues/9231",
                        "  if (Array.isArray(node.parameters)) {",
                        "    parameters.push(...node.parameters);",
                        "  } else if (Array.isArray(node.params)) {",
                        "    parameters.push(...node.params);",
                        "  }",
                        "  if (node.rest) {",
                        "    parameters.push(node.rest);",
                        "  }",
                        "  functionParametersCache.set(node, parameters);",
                        "  return parameters;",
                        "}",
                        "",
                        "function iterateFunctionParametersPath(path, iteratee) {",
                        "  const { node } = path;",
                        "  let index = 0;",
                        "  const callback = (childPath) => iteratee(childPath, index++);",
                        "  if (node.this) {",
                        "    path.call(callback, \"this\");",
                        "  }",
                        "  if (Array.isArray(node.parameters)) {",
                        "    path.each(callback, \"parameters\");",
                        "  } else if (Array.isArray(node.params)) {",
                        "    path.each(callback, \"params\");",
                        "  }",
                        "  if (node.rest) {",
                        "    path.call(callback, \"rest\");",
                        "  }",
                        "}",
                        "",
                        "const callArgumentsCache = new WeakMap();",
                        "function getCallArguments(node) {",
                        "  if (callArgumentsCache.has(node)) {",
                        "    return callArgumentsCache.get(node);",
                        "  }",
                        "",
                        "  let args = node.arguments;",
                        "  if (node.type === \"ImportExpression\") {",
                        "    args = [node.source];",
                        "",
                        "    if (node.attributes) {",
                        "      args.push(node.attributes);",
                        "    }",
                        "  }",
                        "",
                        "  callArgumentsCache.set(node, args);",
                        "  return args;",
                        "}",
                        "",
                        "function iterateCallArgumentsPath(path, iteratee) {",
                        "  const { node } = path;",
                        "  if (node.type === \"ImportExpression\") {",
                        "    path.call((sourcePath) => iteratee(sourcePath, 0), \"source\");",
                        "",
                        "    if (node.attributes) {",
                        "      path.call((sourcePath) => iteratee(sourcePath, 1), \"attributes\");",
                        "    }",
                        "  } else {",
                        "    path.each(iteratee, \"arguments\");",
                        "  }",
                        "}",
                        "",
                        "function getCallArgumentSelector(node, index) {",
                        "  if (node.type === \"ImportExpression\") {",
                        "    if (index === 0 || index === (node.attributes ? -2 : -1)) {",
                        "      return \"source\";",
                        "    }",
                        "    if (node.attributes && (index === 1 || index === -1)) {",
                        "      return \"attributes\";",
                        "    }",
                        "    throw new RangeError(\"Invalid argument index\");",
                        "  }",
                        "  if (index < 0) {",
                        "    index = node.arguments.length + index;",
                        "  }",
                        "  /* c8 ignore next 3 */",
                        "  if (index < 0 || index >= node.arguments.length) {",
                        "    throw new RangeError(\"Invalid argument index\");",
                        "  }",
                        "  return [\"arguments\", index];",
                        "}",
                        "",
                        "function isPrettierIgnoreComment(comment) {",
                        "  return comment.value.trim() === \"prettier-ignore\" && !comment.unignore;",
                        "}",
                        "",
                        "function hasNodeIgnoreComment(node) {",
                        "  return (",
                        "    node?.prettierIgnore || hasComment(node, CommentCheckFlags.PrettierIgnore)",
                        "  );",
                        "}",
                        "",
                        "/** @enum {number} */",
                        "const CommentCheckFlags = {",
                        "  /** Check comment is a leading comment */",
                        "  Leading: 1 << 1,",
                        "  /** Check comment is a trailing comment */",
                        "  Trailing: 1 << 2,",
                        "  /** Check comment is a dangling comment */",
                        "  Dangling: 1 << 3,",
                        "  /** Check comment is a block comment */",
                        "  Block: 1 << 4,",
                        "  /** Check comment is a line comment */",
                        "  Line: 1 << 5,",
                        "  /** Check comment is a `prettier-ignore` comment */",
                        "  PrettierIgnore: 1 << 6,",
                        "  /** Check comment is the first attached comment */",
                        "  First: 1 << 7,",
                        "  /** Check comment is the last attached comment */",
                        "  Last: 1 << 8,",
                        "};",
                        "",
                        "const getCommentTestFunction = (flags, fn) => {",
                        "  if (typeof flags === \"function\") {",
                        "    fn = flags;",
                        "    flags = 0;",
                        "  }",
                        "  if (flags || fn) {",
                        "    return (comment, index, comments) =>",
                        "      !(",
                        "        (flags & CommentCheckFlags.Leading && !comment.leading) ||",
                        "        (flags & CommentCheckFlags.Trailing && !comment.trailing) ||",
                        "        (flags & CommentCheckFlags.Dangling &&",
                        "          (comment.leading || comment.trailing)) ||",
                        "        (flags & CommentCheckFlags.Block && !isBlockComment(comment)) ||",
                        "        (flags & CommentCheckFlags.Line && !isLineComment(comment)) ||",
                        "        (flags & CommentCheckFlags.First && index !== 0) ||",
                        "        (flags & CommentCheckFlags.Last && index !== comments.length - 1) ||",
                        "        (flags & CommentCheckFlags.PrettierIgnore &&",
                        "          !isPrettierIgnoreComment(comment)) ||",
                        "        (fn && !fn(comment))",
                        "      );",
                        "  }",
                        "};",
                        "/**",
                        " * @param {Node} node",
                        " * @param {number | function} [flags]",
                        " * @param {function} [fn]",
                        " * @returns {boolean}",
                        " */",
                        "function hasComment(node, flags, fn) {",
                        "  if (!isNonEmptyArray(node?.comments)) {",
                        "    return false;",
                        "  }",
                        "  const test = getCommentTestFunction(flags, fn);",
                        "  return test ? node.comments.some(test) : true;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {number | function} [flags]",
                        " * @param {function} [fn]",
                        " * @returns {Comment[]}",
                        " */",
                        "function getComments(node, flags, fn) {",
                        "  if (!Array.isArray(node?.comments)) {",
                        "    return [];",
                        "  }",
                        "  const test = getCommentTestFunction(flags, fn);",
                        "  return test ? node.comments.filter(test) : node.comments;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isNextLineEmpty = (node, { originalText }) =>",
                        "  isNextLineEmptyAfterIndex(originalText, locEnd(node));",
                        "",
                        "function isCallLikeExpression(node) {",
                        "  return (",
                        "    isCallExpression(node) ||",
                        "    node.type === \"NewExpression\" ||",
                        "    node.type === \"ImportExpression\"",
                        "  );",
                        "}",
                        "",
                        "function isObjectProperty(node) {",
                        "  return (",
                        "    node &&",
                        "    (node.type === \"ObjectProperty\" ||",
                        "      (node.type === \"Property\" && !node.method && node.kind === \"init\"))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * This is used as a marker for dangling comments.",
                        " */",
                        "const markerForIfWithoutBlockAndSameLineComment = Symbol(",
                        "  \"ifWithoutBlockAndSameLineComment\"",
                        ");",
                        "",
                        "const isTSTypeExpression = createTypeCheckFunction([",
                        "  \"TSAsExpression\",",
                        "  \"TSSatisfiesExpression\",",
                        "]);",
                        "",
                        "export {",
                        "  getFunctionParameters,",
                        "  iterateFunctionParametersPath,",
                        "  getCallArguments,",
                        "  iterateCallArgumentsPath,",
                        "  getCallArgumentSelector,",
                        "  hasRestParameter,",
                        "  getLeftSide,",
                        "  getLeftSidePathName,",
                        "  hasLeadingOwnLineComment,",
                        "  hasNakedLeftSide,",
                        "  hasNode,",
                        "  hasNodeIgnoreComment,",
                        "  identity,",
                        "  isBinaryish,",
                        "  isCallLikeExpression,",
                        "  isLineComment,",
                        "  isPrettierIgnoreComment,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isExportDeclaration,",
                        "  isFunctionCompositionArgs,",
                        "  isFunctionNotation,",
                        "  isFunctionOrArrowExpression,",
                        "  isGetterOrSetter,",
                        "  isJsxElement,",
                        "  isLongCurriedCallExpression,",
                        "  isSimpleCallArgument,",
                        "  isMemberish,",
                        "  isNumericLiteral,",
                        "  isSignedNumericLiteral,",
                        "  isObjectProperty,",
                        "  isObjectType,",
                        "  isObjectTypePropertyAFunction,",
                        "  isRegExpLiteral,",
                        "  isSimpleType,",
                        "  isSimpleNumber,",
                        "  isSimpleTemplateLiteral,",
                        "  isStringLiteral,",
                        "  isStringPropSafeToUnquote,",
                        "  isTemplateOnItsOwnLine,",
                        "  isTestCall,",
                        "  isTSXFile,",
                        "  isTypeAnnotationAFunction,",
                        "  isNextLineEmpty,",
                        "  needsHardlineAfterDanglingComment,",
                        "  rawText,",
                        "  shouldPrintComma,",
                        "  isBitwiseOperator,",
                        "  shouldFlatten,",
                        "  startsWithNoLookaheadToken,",
                        "  getPrecedence,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  markerForIfWithoutBlockAndSameLineComment,",
                        "  isTSTypeExpression,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "  createTypeCheckFunction,",
                        "};"
                    ]
                },
                "is-block-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import createTypeCheckFunction from \"./create-type-check-function.js\";",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Comment} Comment",
                        " */",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "const isBlockComment = createTypeCheckFunction([",
                        "  \"Block\",",
                        "  \"CommentBlock\",",
                        "  // `meriyah`",
                        "  \"MultiLine\",",
                        "]);",
                        "",
                        "export default isBlockComment;"
                    ]
                },
                "is-flow-keyword-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import createTypeCheckFunction from \"./create-type-check-function.js\";",
                        "",
                        "const isFlowKeywordType = createTypeCheckFunction([",
                        "  \"AnyTypeAnnotation\",",
                        "  \"ThisTypeAnnotation\",",
                        "  \"NumberTypeAnnotation\",",
                        "  \"VoidTypeAnnotation\",",
                        "  \"BooleanTypeAnnotation\",",
                        "  \"BigIntTypeAnnotation\",",
                        "  \"SymbolTypeAnnotation\",",
                        "  \"StringTypeAnnotation\",",
                        "  \"NeverTypeAnnotation\",",
                        "  \"UndefinedTypeAnnotation\",",
                        "  \"UnknownTypeAnnotation\",",
                        "  // FLow only",
                        "  \"EmptyTypeAnnotation\",",
                        "  \"MixedTypeAnnotation\",",
                        "]);",
                        "",
                        "export default isFlowKeywordType;"
                    ]
                },
                "is-ignored.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { hasJsxIgnoreComment } from \"../print/jsx.js\";",
                        "import { hasNodeIgnoreComment } from \"../utils/index.js\";",
                        "",
                        "function isIgnored(path) {",
                        "  return hasNodeIgnoreComment(path.node) || hasJsxIgnoreComment(path);",
                        "}",
                        "",
                        "export default isIgnored;"
                    ]
                },
                "is-indentable-block-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isIndentableBlockComment(comment) {",
                        "  // If the comment has multiple lines and every line starts with a star",
                        "  // we can fix the indentation of each line. The stars in the `/*` and",
                        "  // `*/` delimiters are not included in the comment value, so add them",
                        "  // back first.",
                        "  const lines = `*${comment.value}*`.split(\"\\n\");",
                        "  return lines.length > 1 && lines.every((line) => line.trimStart()[0] === \"*\");",
                        "}",
                        "",
                        "export default isIndentableBlockComment;"
                    ]
                },
                "is-node-matches.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Copied from https://github.com/sindresorhus/eslint-plugin-unicorn/blob/d53d935951aa815c763fc9441aa452c763294715/rules/utils/is-node-matches.js",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " */",
                        "",
                        "/**",
                        "Check if node matches object name or key path.",
                        "",
                        "@param {Node} node - The AST node to check.",
                        "@param {string} nameOrPath - The object name or key path.",
                        "@returns {boolean}",
                        "*/",
                        "function isNodeMatchesNameOrPath(node, nameOrPath) {",
                        "  const names = nameOrPath.split(\".\");",
                        "  for (let index = names.length - 1; index >= 0; index--) {",
                        "    const name = names[index];",
                        "",
                        "    if (index === 0) {",
                        "      return node.type === \"Identifier\" && node.name === name;",
                        "    }",
                        "",
                        "    if (",
                        "      node.type !== \"MemberExpression\" ||",
                        "      node.optional ||",
                        "      node.computed ||",
                        "      node.property.type !== \"Identifier\" ||",
                        "      node.property.name !== name",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    node = node.object;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        "Check if node matches any object name or key path.",
                        "",
                        "@param {Node} node - The AST node to check.",
                        "@param {string[]} nameOrPaths - The object name or key paths.",
                        "@returns {boolean}",
                        "*/",
                        "function isNodeMatches(node, nameOrPaths) {",
                        "  return nameOrPaths.some((nameOrPath) =>",
                        "    isNodeMatchesNameOrPath(node, nameOrPath)",
                        "  );",
                        "}",
                        "",
                        "export default isNodeMatches;"
                    ]
                },
                "is-ts-keyword-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/**",
                        " * @returns {boolean}",
                        " */",
                        "function isTsKeywordType({ type }) {",
                        "  return type.startsWith(\"TS\") && type.endsWith(\"Keyword\");",
                        "}",
                        "",
                        "export default isTsKeywordType;"
                    ]
                },
                "is-type-cast-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isBlockComment from \"./is-block-comment.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Comment} Comment",
                        " */",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "function isTypeCastComment(comment) {",
                        "  return (",
                        "    isBlockComment(comment) &&",
                        "    comment.value[0] === \"*\" &&",
                        "    // TypeScript expects the type to be enclosed in curly brackets, however",
                        "    // Closure Compiler accepts types in parens and even without any delimiters at all.",
                        "    // That's why we just search for \"@type\" and \"@satisfies\".",
                        "    /@(?:type|satisfies)\\b/.test(comment.value)",
                        "  );",
                        "}",
                        "",
                        "export default isTypeCastComment;"
                    ]
                }
            }
        },
        "language-json": {
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.JSON, () => ({",
                    "    name: \"JSON.stringify\",",
                    "    parsers: [\"json-stringify\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    extensions: [\".importmap\"], // .json file defaults to json instead of json-stringify",
                    "    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.JSON, (data) => ({",
                    "    parsers: [\"json\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    extensions: data.extensions.filter((extension) => extension !== \".jsonl\"),",
                    "  })),",
                    "  createLanguage(linguistLanguages[\"JSON with Comments\"], (data) => ({",
                    "    parsers: [\"json\"],",
                    "    vscodeLanguageIds: [\"jsonc\"],",
                    "    filenames: [...data.filenames, \".eslintrc\", \".swcrc\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.JSON5, () => ({",
                    "    parsers: [\"json5\"],",
                    "    vscodeLanguageIds: [\"json5\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "parser-json.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { parseExpression } from \"@babel/parser\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import createParser from \"../language-js/parse/utils/create-parser.js\";",
                    "import createBabelParseError from \"../language-js/parse/utils/create-babel-parse-error.js\";",
                    "import wrapBabelExpression from \"../language-js/parse/utils/wrap-babel-expression.js\";",
                    "",
                    "function createJsonParse(options = {}) {",
                    "  const { allowComments = true } = options;",
                    "",
                    "  return function parse(text) {",
                    "    let ast;",
                    "    try {",
                    "      ast = parseExpression(text, {",
                    "        tokens: true,",
                    "        ranges: true,",
                    "      });",
                    "    } catch (error) {",
                    "      if (",
                    "        error?.reasonCode === \"MissingPlugin\" ||",
                    "        error?.reasonCode === \"MissingOneOfPlugins\"",
                    "      ) {",
                    "        throw createBabelParseError({",
                    "          message: \"Unexpected token\",",
                    "          loc: error.loc,",
                    "        });",
                    "      }",
                    "",
                    "      throw createBabelParseError(error);",
                    "    }",
                    "",
                    "    // @ts-expect-error",
                    "    if (!allowComments && isNonEmptyArray(ast.comments)) {",
                    "      // @ts-expect-error",
                    "      throw createJsonError(ast.comments[0], \"Comment\");",
                    "    }",
                    "",
                    "    assertJsonNode(ast);",
                    "",
                    "    return wrapBabelExpression(ast, { type: \"JsonRoot\", text });",
                    "  };",
                    "}",
                    "",
                    "function createJsonError(node, description) {",
                    "  const [start, end] = [node.loc.start, node.loc.end].map(",
                    "    ({ line, column }) => ({",
                    "      line,",
                    "      column: column + 1,",
                    "    })",
                    "  );",
                    "  return createError(`${description} is not allowed in JSON.`, {",
                    "    loc: { start, end },",
                    "  });",
                    "}",
                    "",
                    "function assertJsonNode(node) {",
                    "  switch (node.type) {",
                    "    case \"ArrayExpression\":",
                    "      for (const element of node.elements) {",
                    "        if (element !== null) {",
                    "          assertJsonNode(element);",
                    "        }",
                    "      }",
                    "",
                    "      return;",
                    "    case \"ObjectExpression\":",
                    "      for (const property of node.properties) {",
                    "        assertJsonNode(property);",
                    "      }",
                    "",
                    "      return;",
                    "    case \"ObjectProperty\":",
                    "      if (node.computed) {",
                    "        throw createJsonError(node.key, \"Computed key\");",
                    "      }",
                    "",
                    "      if (node.shorthand) {",
                    "        throw createJsonError(node.key, \"Shorthand property\");",
                    "      }",
                    "",
                    "      if (node.key.type !== \"Identifier\") {",
                    "        assertJsonNode(node.key);",
                    "      }",
                    "",
                    "      assertJsonNode(node.value);",
                    "",
                    "      return;",
                    "    case \"UnaryExpression\": {",
                    "      const { operator, argument } = node;",
                    "      if (operator !== \"+\" && operator !== \"-\") {",
                    "        throw createJsonError(node, `Operator '${node.operator}'`);",
                    "      }",
                    "",
                    "      if (",
                    "        argument.type === \"NumericLiteral\" ||",
                    "        (argument.type === \"Identifier\" &&",
                    "          (argument.name === \"Infinity\" || argument.name === \"NaN\"))",
                    "      ) {",
                    "        return;",
                    "      }",
                    "",
                    "      throw createJsonError(",
                    "        argument,",
                    "        `Operator '${operator}' before '${argument.type}'`",
                    "      );",
                    "    }",
                    "    case \"Identifier\":",
                    "      if (",
                    "        // JSON5 https://spec.json5.org/#numbers",
                    "        node.name !== \"Infinity\" &&",
                    "        node.name !== \"NaN\" &&",
                    "        // JSON6 https://github.com/d3x0r/JSON6",
                    "        node.name !== \"undefined\"",
                    "      ) {",
                    "        throw createJsonError(node, `Identifier '${node.name}'`);",
                    "      }",
                    "",
                    "      return;",
                    "    case \"TemplateLiteral\":",
                    "      if (isNonEmptyArray(node.expressions)) {",
                    "        throw createJsonError(",
                    "          node.expressions[0],",
                    "          \"'TemplateLiteral' with expression\"",
                    "        );",
                    "      }",
                    "",
                    "      for (const element of node.quasis) {",
                    "        assertJsonNode(element);",
                    "      }",
                    "",
                    "      return;",
                    "    case \"NullLiteral\":",
                    "    case \"BooleanLiteral\":",
                    "    case \"NumericLiteral\":",
                    "    case \"StringLiteral\":",
                    "    case \"TemplateElement\":",
                    "      return;",
                    "    default:",
                    "      throw createJsonError(node, `'${node.type}'`);",
                    "  }",
                    "}",
                    "",
                    "const parseJson = createJsonParse();",
                    "",
                    "const jsonParsers = {",
                    "  json: createParser({",
                    "    parse: parseJson,",
                    "    hasPragma() {",
                    "      return true;",
                    "    },",
                    "  }),",
                    "  json5: createParser(parseJson),",
                    "  \"json-stringify\": createParser({",
                    "    parse: createJsonParse({ allowComments: false }),",
                    "    astFormat: \"estree-json\",",
                    "  }),",
                    "};",
                    "",
                    "export default jsonParsers;"
                ]
            },
            "printer-estree-json.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { hardline, indent, join } from \"../document/builders.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "  switch (node.type) {",
                    "    case \"JsonRoot\":",
                    "      return [print(\"node\"), hardline];",
                    "    case \"ArrayExpression\": {",
                    "      if (node.elements.length === 0) {",
                    "        return \"[]\";",
                    "      }",
                    "",
                    "      const printed = path.map(",
                    "        () => (path.node === null ? \"null\" : print()),",
                    "        \"elements\"",
                    "      );",
                    "",
                    "      return [",
                    "        \"[\",",
                    "        indent([hardline, join([\",\", hardline], printed)]),",
                    "        hardline,",
                    "        \"]\",",
                    "      ];",
                    "    }",
                    "    case \"ObjectExpression\":",
                    "      return node.properties.length === 0",
                    "        ? \"{}\"",
                    "        : [",
                    "            \"{\",",
                    "            indent([",
                    "              hardline,",
                    "              join([\",\", hardline], path.map(print, \"properties\")),",
                    "            ]),",
                    "            hardline,",
                    "            \"}\",",
                    "          ];",
                    "    case \"ObjectProperty\":",
                    "      return [print(\"key\"), \": \", print(\"value\")];",
                    "    case \"UnaryExpression\":",
                    "      return [node.operator === \"+\" ? \"\" : node.operator, print(\"argument\")];",
                    "    case \"NullLiteral\":",
                    "      return \"null\";",
                    "    case \"BooleanLiteral\":",
                    "      return node.value ? \"true\" : \"false\";",
                    "    case \"StringLiteral\":",
                    "      return JSON.stringify(node.value);",
                    "    case \"NumericLiteral\":",
                    "      return isObjectKey(path)",
                    "        ? JSON.stringify(String(node.value))",
                    "        : JSON.stringify(node.value);",
                    "    case \"Identifier\":",
                    "      return isObjectKey(path) ? JSON.stringify(node.name) : node.name;",
                    "    case \"TemplateLiteral\":",
                    "      // There is only one `TemplateElement`",
                    "      return print([\"quasis\", 0]);",
                    "    case \"TemplateElement\":",
                    "      return JSON.stringify(node.value.cooked);",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"JSON\");",
                    "  }",
                    "}",
                    "",
                    "function isObjectKey(path) {",
                    "  return path.key === \"key\" && path.parent.type === \"ObjectProperty\";",
                    "}",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"start\",",
                    "  \"end\",",
                    "  \"extra\",",
                    "  \"loc\",",
                    "  \"comments\",",
                    "  \"leadingComments\",",
                    "  \"trailingComments\",",
                    "  \"innerComments\",",
                    "  \"errors\",",
                    "  \"range\",",
                    "  \"tokens\",",
                    "]);",
                    "",
                    "function clean(node, newNode /*, parent*/) {",
                    "  const { type } = node;",
                    "  // We print quoted key",
                    "  if (type === \"ObjectProperty\") {",
                    "    const { key } = node;",
                    "    if (key.type === \"Identifier\") {",
                    "      newNode.key = { type: \"StringLiteral\", value: key.name };",
                    "    } else if (key.type === \"NumericLiteral\") {",
                    "      newNode.key = { type: \"StringLiteral\", value: String(key.value) };",
                    "    }",
                    "    return;",
                    "  }",
                    "  if (type === \"UnaryExpression\" && node.operator === \"+\") {",
                    "    return newNode.argument;",
                    "  }",
                    "  // We print holes in array as `null`",
                    "  if (type === \"ArrayExpression\") {",
                    "    for (const [index, element] of node.elements.entries()) {",
                    "      if (element === null) {",
                    "        newNode.elements.splice(index, 0, { type: \"NullLiteral\" });",
                    "      }",
                    "    }",
                    "    return;",
                    "  }",
                    "  // We print `TemplateLiteral` as string",
                    "  if (type === \"TemplateLiteral\") {",
                    "    return { type: \"StringLiteral\", value: node.quasis[0].value.cooked };",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "export { genericPrint as print, clean as massageAstNode };",
                    "export { default as getVisitorKeys } from \"./get-visitor-keys.js\";"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = {",
                    "  JsonRoot: [\"node\"],",
                    "  ArrayExpression: [\"elements\"],",
                    "  ObjectExpression: [\"properties\"],",
                    "  ObjectProperty: [\"key\", \"value\"],",
                    "  UnaryExpression: [\"argument\"],",
                    "  NullLiteral: [],",
                    "  BooleanLiteral: [],",
                    "  StringLiteral: [],",
                    "  NumericLiteral: [],",
                    "  Identifier: [],",
                    "  TemplateLiteral: [\"quasis\"],",
                    "  TemplateElement: [],",
                    "};",
                    "",
                    "export default visitorKeys;"
                ]
            }
        },
        "language-markdown": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import collapseWhiteSpace from \"collapse-white-space\";",
                    "import isFrontMatter from \"../utils/front-matter/is-front-matter.js\";",
                    "import { startWithPragma } from \"./pragma.js\";",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"position\",",
                    "  \"raw\", // front-matter",
                    "]);",
                    "function clean(ast, newObj, parent) {",
                    "  // for codeblock",
                    "  if (",
                    "    ast.type === \"front-matter\" ||",
                    "    ast.type === \"code\" ||",
                    "    ast.type === \"yaml\" ||",
                    "    ast.type === \"import\" ||",
                    "    ast.type === \"export\" ||",
                    "    ast.type === \"jsx\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"list\") {",
                    "    delete newObj.isAligned;",
                    "  }",
                    "",
                    "  if (ast.type === \"list\" || ast.type === \"listItem\") {",
                    "    delete newObj.spread;",
                    "  }",
                    "",
                    "  // texts can be splitted or merged",
                    "  if (ast.type === \"text\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"inlineCode\") {",
                    "    newObj.value = ast.value.replaceAll(\"\\n\", \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"wikiLink\") {",
                    "    newObj.value = ast.value.trim().replaceAll(/[\\t\\n]+/g, \" \");",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"definition\" ||",
                    "    ast.type === \"linkReference\" ||",
                    "    ast.type === \"imageReference\"",
                    "  ) {",
                    "    newObj.label = collapseWhiteSpace(ast.label);",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"definition\" ||",
                    "      ast.type === \"link\" ||",
                    "      ast.type === \"image\") &&",
                    "    ast.title",
                    "  ) {",
                    "    newObj.title = ast.title.replaceAll(/\\\\(?=[\"')])/g, \"\");",
                    "  }",
                    "",
                    "  // for insert pragma",
                    "  if (",
                    "    parent?.type === \"root\" &&",
                    "    parent.children.length > 0 &&",
                    "    (parent.children[0] === ast ||",
                    "      (isFrontMatter(parent.children[0]) && parent.children[1] === ast)) &&",
                    "    ast.type === \"html\" &&",
                    "    startWithPragma(ast.value)",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "export default clean;"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import cjkRegex from \"cjk-regex\";",
                    "import regexpUtil from \"regexp-util\";",
                    "import unicodeRegex from \"unicode-regex\";",
                    "",
                    "const cjkPattern = `(?:${cjkRegex()",
                    "  .union(",
                    "    unicodeRegex({",
                    "      Script_Extensions: [\"Han\", \"Katakana\", \"Hiragana\", \"Hangul\", \"Bopomofo\"],",
                    "      General_Category: [",
                    "        \"Other_Letter\",",
                    "        \"Letter_Number\",",
                    "        \"Other_Symbol\",",
                    "        \"Modifier_Letter\",",
                    "        \"Modifier_Symbol\",",
                    "        \"Nonspacing_Mark\",",
                    "      ],",
                    "    })",
                    "  )",
                    "  .toString()})(?:${unicodeRegex({",
                    "  Block: [\"Variation_Selectors\", \"Variation_Selectors_Supplement\"],",
                    "}).toString()})?`;",
                    "",
                    "const kRegex = unicodeRegex({ Script: [\"Hangul\"] })",
                    "  .union(unicodeRegex({ Script_Extensions: [\"Hangul\"] }))",
                    "  .toRegExp();",
                    "",
                    "// http://spec.commonmark.org/0.25/#ascii-punctuation-character",
                    "const asciiPunctuationCharset =",
                    "  /* prettier-ignore */ regexpUtil.charset(",
                    "  \"!\", '\"', \"#\",  \"$\", \"%\", \"&\", \"'\", \"(\", \")\", \"*\",",
                    "  \"+\", \",\", \"-\",  \".\", \"/\", \":\", \";\", \"<\", \"=\", \">\",",
                    "  \"?\", \"@\", \"[\", \"\\\\\", \"]\", \"^\", \"_\", \"`\", \"{\", \"|\",",
                    "  \"}\", \"~\"",
                    ");",
                    "",
                    "// http://spec.commonmark.org/0.25/#punctuation-character",
                    "const punctuationCharset = unicodeRegex({",
                    "  // http://unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values",
                    "  General_Category: [",
                    "    /* Pc */ \"Connector_Punctuation\",",
                    "    /* Pd */ \"Dash_Punctuation\",",
                    "    /* Pe */ \"Close_Punctuation\",",
                    "    /* Pf */ \"Final_Punctuation\",",
                    "    /* Pi */ \"Initial_Punctuation\",",
                    "    /* Po */ \"Other_Punctuation\",",
                    "    /* Ps */ \"Open_Punctuation\",",
                    "  ],",
                    "}).union(asciiPunctuationCharset);",
                    "",
                    "const punctuationPattern = punctuationCharset.toString();",
                    "",
                    "export { cjkPattern, kRegex, punctuationPattern };"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getMaxContinuousCount from \"../utils/get-max-continuous-count.js\";",
                    "import { hardline, markAsRoot } from \"../document/builders.js\";",
                    "import { replaceEndOfLine } from \"../document/utils.js\";",
                    "import printFrontMatter from \"../utils/front-matter/print.js\";",
                    "import inferParser from \"../utils/infer-parser.js\";",
                    "import { getFencedCodeBlockValue } from \"./utils.js\";",
                    "",
                    "function embed(path, options) {",
                    "  const { node } = path;",
                    "",
                    "  if (node.type === \"code\" && node.lang !== null) {",
                    "    const parser = inferParser(options, { language: node.lang });",
                    "    if (parser) {",
                    "      return async (textToDoc) => {",
                    "        const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "        const style = styleUnit.repeat(",
                    "          Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "        );",
                    "        const newOptions = { parser };",
                    "        if (node.lang === \"tsx\") {",
                    "          newOptions.filepath = \"dummy.tsx\";",
                    "        }",
                    "",
                    "        const doc = await textToDoc(",
                    "          getFencedCodeBlockValue(node, options.originalText),",
                    "          newOptions",
                    "        );",
                    "",
                    "        return markAsRoot([",
                    "          style,",
                    "          node.lang,",
                    "          node.meta ? \" \" + node.meta : \"\",",
                    "          hardline,",
                    "          replaceEndOfLine(doc),",
                    "          hardline,",
                    "          style,",
                    "        ]);",
                    "      };",
                    "    }",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return (textToDoc) => printFrontMatter(node, textToDoc);",
                    "",
                    "    // MDX",
                    "    case \"import\":",
                    "    case \"export\":",
                    "      return (textToDoc) => textToDoc(node.value, { parser: \"babel\" });",
                    "    case \"jsx\":",
                    "      return (textToDoc) =>",
                    "        textToDoc(`<$>${node.value}</$>`, {",
                    "          parser: \"__js_expression\",",
                    "          rootMarker: \"mdx\",",
                    "        });",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "export default embed;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-markdown.js\";",
                    "",
                    "export const printers = {",
                    "  mdast: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-markdown.js\"),",
                    "    parserNames: [\"remark\", \"markdown\", \"mdx\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.Markdown, (data) => ({",
                    "    parsers: [\"markdown\"],",
                    "    vscodeLanguageIds: [\"markdown\"],",
                    "    filenames: [...data.filenames, \"README\"],",
                    "    extensions: data.extensions.filter((extension) => extension !== \".mdx\"),",
                    "  })),",
                    "  createLanguage(linguistLanguages.Markdown, () => ({",
                    "    name: \"MDX\",",
                    "    parsers: [\"mdx\"],",
                    "    vscodeLanguageIds: [\"mdx\"],",
                    "    filenames: [],",
                    "    extensions: [\".mdx\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(node) {",
                    "  return node.position.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.position.end.offset;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "mdx.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * modified from https://github.com/mdx-js/mdx/blob/master/packages/mdx",
                    " *",
                    " * The MIT License (MIT)",
                    " *",
                    " * Copyright (c) 2017-2018 Compositor and Zeit, Inc.",
                    " *",
                    " * Permission is hereby granted, free of charge, to any person obtaining a copy",
                    " * of this software and associated documentation files (the \"Software\"), to deal",
                    " * in the Software without restriction, including without limitation the rights",
                    " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
                    " * copies of the Software, and to permit persons to whom the Software is",
                    " * furnished to do so, subject to the following conditions:",
                    " * The above copyright notice and this permission notice shall be included in",
                    " * all copies or substantial portions of the Software.",
                    " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
                    " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
                    " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
                    " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
                    " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
                    " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
                    " * THE SOFTWARE.",
                    " */",
                    "",
                    "const IMPORT_REGEX = /^import\\s/;",
                    "const EXPORT_REGEX = /^export\\s/;",
                    "const BLOCKS_REGEX = \"[a-z][a-z0-9]*(\\\\.[a-z][a-z0-9]*)*|\";",
                    "const COMMENT_REGEX = /<!---->|<!---?[^>-](?:-?[^-])*-->/;",
                    "const ES_COMMENT_REGEX = /^{\\s*\\/\\*(.*)\\*\\/\\s*}/;",
                    "const EMPTY_NEWLINE = \"\\n\\n\";",
                    "",
                    "const isImport = (text) => IMPORT_REGEX.test(text);",
                    "const isExport = (text) => EXPORT_REGEX.test(text);",
                    "",
                    "const tokenizeEsSyntax = (eat, value) => {",
                    "  const index = value.indexOf(EMPTY_NEWLINE);",
                    "  const subvalue = value.slice(0, index);",
                    "",
                    "  if (isExport(subvalue) || isImport(subvalue)) {",
                    "    return eat(subvalue)({",
                    "      type: isExport(subvalue) ? \"export\" : \"import\",",
                    "      value: subvalue,",
                    "    });",
                    "  }",
                    "};",
                    "",
                    "const tokenizeEsComment = (eat, value) => {",
                    "  const match = ES_COMMENT_REGEX.exec(value);",
                    "",
                    "  if (match) {",
                    "    return eat(match[0])({",
                    "      type: \"esComment\",",
                    "      value: match[1].trim(),",
                    "    });",
                    "  }",
                    "};",
                    "",
                    "/* c8 ignore next 2 */",
                    "tokenizeEsSyntax.locator = (value /*, fromIndex*/) =>",
                    "  isExport(value) || isImport(value) ? -1 : 1;",
                    "",
                    "tokenizeEsComment.locator = (value, fromIndex) => value.indexOf(\"{\", fromIndex);",
                    "",
                    "function esSyntax() {",
                    "  const { Parser } = this;",
                    "  const { blockTokenizers, blockMethods, inlineTokenizers, inlineMethods } =",
                    "    Parser.prototype;",
                    "",
                    "  blockTokenizers.esSyntax = tokenizeEsSyntax;",
                    "  inlineTokenizers.esComment = tokenizeEsComment;",
                    "",
                    "  blockMethods.splice(blockMethods.indexOf(\"paragraph\"), 0, \"esSyntax\");",
                    "  inlineMethods.splice(inlineMethods.indexOf(\"text\"), 0, \"esComment\");",
                    "}",
                    "",
                    "export { esSyntax, BLOCKS_REGEX, COMMENT_REGEX };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  proseWrap: commonOptions.proseWrap,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import remarkParse from \"remark-parse\";",
                    "import unified from \"unified\";",
                    "import remarkMath from \"remark-math\";",
                    "import footnotes from \"remark-footnotes\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import { BLOCKS_REGEX, esSyntax } from \"./mdx.js\";",
                    "import htmlToJsx from \"./unified-plugins/html-to-jsx.js\";",
                    "import frontMatter from \"./unified-plugins/front-matter.js\";",
                    "import liquid from \"./unified-plugins/liquid.js\";",
                    "import wikiLink from \"./unified-plugins/wiki-link.js\";",
                    "",
                    "/**",
                    " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                    " *",
                    " * 1. restore unescaped character (Text)",
                    " * 2. merge continuous Texts",
                    " * 3. replace whitespaces in InlineCode#value with one whitespace",
                    " *    reference: http://spec.commonmark.org/0.25/#example-605",
                    " * 4. split Text into Sentence",
                    " *",
                    " * interface Word { value: string }",
                    " * interface Whitespace { value: string }",
                    " * interface Sentence { children: Array<Word | Whitespace> }",
                    " * interface InlineCode { children: Array<Sentence> }",
                    " */",
                    "function createParse({ isMDX }) {",
                    "  return (text) => {",
                    "    const processor = unified()",
                    "      .use(remarkParse, {",
                    "        commonmark: true,",
                    "        ...(isMDX && { blocks: [BLOCKS_REGEX] }),",
                    "      })",
                    "      .use(footnotes)",
                    "      .use(frontMatter)",
                    "      .use(remarkMath)",
                    "      .use(isMDX ? esSyntax : identity)",
                    "      .use(liquid)",
                    "      .use(isMDX ? htmlToJsx : identity)",
                    "      .use(wikiLink);",
                    "    return processor.run(processor.parse(text));",
                    "  };",
                    "}",
                    "",
                    "function identity(x) {",
                    "  return x;",
                    "}",
                    "",
                    "const baseParser = {",
                    "  astFormat: \"mdast\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "export const markdown = { ...baseParser, parse: createParse({ isMDX: false }) };",
                    "export const mdx = { ...baseParser, parse: createParse({ isMDX: true }) };",
                    "export { markdown as remark };"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import parseFrontMatter from \"../utils/front-matter/parse.js\";",
                    "",
                    "const pragmas = [\"format\", \"prettier\"];",
                    "",
                    "function startWithPragma(text) {",
                    "  const pragma = `@(${pragmas.join(\"|\")})`;",
                    "  const regex = new RegExp(",
                    "    [",
                    "      `<!--\\\\s*${pragma}\\\\s*-->`,",
                    "      `{\\\\s*\\\\/\\\\*\\\\s*${pragma}\\\\s*\\\\*\\\\/\\\\s*}`,",
                    "      `<!--.*\\r?\\n[\\\\s\\\\S]*(^|\\n)[^\\\\S\\n]*${pragma}[^\\\\S\\n]*($|\\n)[\\\\s\\\\S]*\\n.*-->`,",
                    "    ].join(\"|\"),",
                    "    \"m\"",
                    "  );",
                    "  const matched = text.match(regex);",
                    "  return matched?.index === 0;",
                    "}",
                    "",
                    "const hasPragma = (text) =>",
                    "  startWithPragma(parseFrontMatter(text).content.trimStart());",
                    "",
                    "const insertPragma = (text) => {",
                    "  const extracted = parseFrontMatter(text);",
                    "  const pragma = `<!-- @${pragmas[0]} -->`;",
                    "  return extracted.frontMatter",
                    "    ? `${extracted.frontMatter.raw}\\n\\n${pragma}\\n\\n${extracted.content}`",
                    "    : `${pragma}\\n\\n${extracted.content}`;",
                    "};",
                    "",
                    "export { startWithPragma, hasPragma, insertPragma };"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { getOrderedListItemInfo, mapAst, splitText } from \"./utils.js\";",
                    "",
                    "// 0x0 ~ 0x10ffff",
                    "const isSingleCharRegex = /^.$/su;",
                    "",
                    "function preprocess(ast, options) {",
                    "  ast = restoreUnescapedCharacter(ast, options);",
                    "  ast = mergeContinuousTexts(ast);",
                    "  ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);",
                    "  ast = markAlignedList(ast, options);",
                    "  ast = splitTextIntoSentences(ast);",
                    "  return ast;",
                    "}",
                    "",
                    "function restoreUnescapedCharacter(ast, options) {",
                    "  return mapAst(ast, (node) =>",
                    "    node.type !== \"text\" ||",
                    "    node.value === \"*\" ||",
                    "    node.value === \"_\" || // handle these cases in printer",
                    "    !isSingleCharRegex.test(node.value) ||",
                    "    node.position.end.offset - node.position.start.offset === node.value.length",
                    "      ? node",
                    "      : {",
                    "          ...node,",
                    "          value: options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          ),",
                    "        }",
                    "  );",
                    "}",
                    "",
                    "function mergeChildren(ast, shouldMerge, mergeNode) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (!node.children) {",
                    "      return node;",
                    "    }",
                    "    const children = node.children.reduce((current, child) => {",
                    "      const lastChild = current.at(-1);",
                    "      if (lastChild && shouldMerge(lastChild, child)) {",
                    "        current.splice(-1, 1, mergeNode(lastChild, child));",
                    "      } else {",
                    "        current.push(child);",
                    "      }",
                    "      return current;",
                    "    }, []);",
                    "    return { ...node, children };",
                    "  });",
                    "}",
                    "",
                    "function mergeContinuousTexts(ast) {",
                    "  return mergeChildren(",
                    "    ast,",
                    "    (prevNode, node) => prevNode.type === \"text\" && node.type === \"text\",",
                    "    (prevNode, node) => ({",
                    "      type: \"text\",",
                    "      value: prevNode.value + node.value,",
                    "      position: {",
                    "        start: prevNode.position.start,",
                    "        end: node.position.end,",
                    "      },",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function splitTextIntoSentences(ast) {",
                    "  return mapAst(ast, (node, index, [parentNode]) => {",
                    "    if (node.type !== \"text\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    let { value } = node;",
                    "",
                    "    if (parentNode.type === \"paragraph\") {",
                    "      if (index === 0) {",
                    "        value = value.trimStart();",
                    "      }",
                    "      if (index === parentNode.children.length - 1) {",
                    "        value = value.trimEnd();",
                    "      }",
                    "    }",
                    "",
                    "    return {",
                    "      type: \"sentence\",",
                    "      position: node.position,",
                    "      children: splitText(value),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "function transformIndentedCodeblockAndMarkItsParentList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"code\") {",
                    "      // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it",
                    "      const isIndented = /^\\n?(?: {4,}|\\t)/.test(",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        )",
                    "      );",
                    "",
                    "      node.isIndented = isIndented;",
                    "",
                    "      if (isIndented) {",
                    "        for (let i = 0; i < parentStack.length; i++) {",
                    "          const parent = parentStack[i];",
                    "",
                    "          // no need to check checked items",
                    "          if (parent.hasIndentedCodeblock) {",
                    "            break;",
                    "          }",
                    "",
                    "          if (parent.type === \"list\") {",
                    "            parent.hasIndentedCodeblock = true;",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function markAlignedList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"list\" && node.children.length > 0) {",
                    "      // if one of its parents is not aligned, it's not possible to be aligned in sub-lists",
                    "      for (let i = 0; i < parentStack.length; i++) {",
                    "        const parent = parentStack[i];",
                    "        if (parent.type === \"list\" && !parent.isAligned) {",
                    "          node.isAligned = false;",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      node.isAligned = isAligned(node);",
                    "    }",
                    "",
                    "    return node;",
                    "  });",
                    "",
                    "  function getListItemStart(listItem) {",
                    "    return listItem.children.length === 0",
                    "      ? -1",
                    "      : listItem.children[0].position.start.column - 1;",
                    "  }",
                    "",
                    "  function isAligned(list) {",
                    "    if (!list.ordered) {",
                    "      /**",
                    "       * - 123",
                    "       * - 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const [firstItem, secondItem] = list.children;",
                    "",
                    "    const firstInfo = getOrderedListItemInfo(firstItem, options.originalText);",
                    "",
                    "    if (firstInfo.leadingSpaces.length > 1) {",
                    "      /**",
                    "       * 1.   123",
                    "       *",
                    "       * 1.   123",
                    "       * 1. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const firstStart = getListItemStart(firstItem);",
                    "",
                    "    if (firstStart === -1) {",
                    "      /**",
                    "       * 1.",
                    "       *",
                    "       * 1.",
                    "       * 1.",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (list.children.length === 1) {",
                    "      /**",
                    "       * aligned:",
                    "       *",
                    "       * 11. 123",
                    "       *",
                    "       * not aligned:",
                    "       *",
                    "       * 1. 123",
                    "       */",
                    "      return firstStart % options.tabWidth === 0;",
                    "    }",
                    "",
                    "    const secondStart = getListItemStart(secondItem);",
                    "",
                    "    if (firstStart !== secondStart) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 1. 123",
                    "       *",
                    "       * 1. 123",
                    "       * 11. 123",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (firstStart % options.tabWidth === 0) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 12. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    /**",
                    "     * aligned:",
                    "     *",
                    "     * 11. 123",
                    "     * 1.  123",
                    "     *",
                    "     * not aligned:",
                    "     *",
                    "     * 1. 123",
                    "     * 2. 123",
                    "     */",
                    "    const secondInfo = getOrderedListItemInfo(secondItem, options.originalText);",
                    "    return secondInfo.leadingSpaces.length > 1;",
                    "  }",
                    "}",
                    "",
                    "export default preprocess;"
                ]
            },
            "print-whitespace.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { hardline, line, softline } from \"../document/builders.js\";",
                    "import {",
                    "  KIND_CJK_PUNCTUATION,",
                    "  KIND_CJ_LETTER,",
                    "  KIND_K_LETTER,",
                    "  KIND_NON_CJK,",
                    "} from \"./utils.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./utils.js\").WordNode} WordNode",
                    " * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue",
                    " * @typedef {import(\"./utils.js\").WordKind} WordKind",
                    " * @typedef {import(\"../common/ast-path.js\").default} AstPath",
                    " * @typedef {\"always\" | \"never\" | \"preserve\"} ProseWrap",
                    " * @typedef {{ next?: WordNode | null, previous?: WordNode | null }}",
                    " * AdjacentNodes Nodes adjacent to a `whitespace` node. Are always of type",
                    " * `word`.",
                    " */",
                    "",
                    "const SINGLE_LINE_NODE_TYPES = new Set([",
                    "  \"heading\",",
                    "  \"tableCell\",",
                    "  \"link\",",
                    "  \"wikiLink\",",
                    "]);",
                    "",
                    "/**",
                    " * These characters must not immediately precede a line break.",
                    " *",
                    " * e.g. `\"（\"`:",
                    " *",
                    " * - Bad:  `\"檜原村（\\nひのはらむら）\"`",
                    " * - Good: `\"檜原村\\n（ひのはらむら）\"` or",
                    " *         `\"檜原村（ひ\\nのはらむら）\"`",
                    " */",
                    "const noBreakAfter = new Set(",
                    "  \"$(£¥·'\\\"〈《「『【〔〖〝﹙﹛＄（［｛￡￥[{‵︴︵︷︹︻︽︿﹁﹃﹏〘｟«\"",
                    ");",
                    "",
                    "/**",
                    " * These characters must not immediately follow a line break.",
                    " *",
                    " * e.g. `\"）\"`:",
                    " *",
                    " * - Bad:  `\"檜原村（ひのはらむら\\n）以外には、\"`",
                    " * - Good: `\"檜原村（ひのはらむ\\nら）以外には、\"` or",
                    " *         `\"檜原村（ひのはらむら）\\n以外には、\"`",
                    " */",
                    "const noBreakBefore = new Set(",
                    "  \"!%),.:;?]}¢°·'\\\"†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？］｝～–—•〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘︶︸︺︼︾﹀﹂﹗｜､』】〙〟｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠〜～‼⁇⁈⁉・\"",
                    ");",
                    "",
                    "/**",
                    " * A line break between a character from this set and CJ can be converted to a",
                    " * space. Includes only ASCII punctuation marks for now.",
                    " */",
                    "const lineBreakBetweenTheseAndCJConvertsToSpace = new Set(",
                    "  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"",
                    ");",
                    "",
                    "/**",
                    " * Determine the preferred style of spacing between Chinese or Japanese and non-CJK",
                    " * characters in the parent `sentence` node.",
                    " *",
                    " * @param {AstPath} path",
                    " * @returns {boolean} `true` if Space tends to be inserted between CJ and",
                    " * non-CJK, `false` otherwise.",
                    " */",
                    "function isInSentenceWithCJSpaces({ parent: sentenceNode }) {",
                    "  if (sentenceNode.usesCJSpaces === undefined) {",
                    "    const stats = { \" \": 0, \"\": 0 };",
                    "    const { children } = sentenceNode;",
                    "",
                    "    for (let i = 1; i < children.length - 1; ++i) {",
                    "      const node = children[i];",
                    "      if (",
                    "        node.type === \"whitespace\" &&",
                    "        (node.value === \" \" || node.value === \"\")",
                    "      ) {",
                    "        const previousKind = children[i - 1].kind;",
                    "        const nextKind = children[i + 1].kind;",
                    "        if (",
                    "          (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||",
                    "          (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)",
                    "        ) {",
                    "          ++stats[node.value];",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    // Inject a property to cache the result.",
                    "    sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];",
                    "  }",
                    "",
                    "  return sentenceNode.usesCJSpaces;",
                    "}",
                    "",
                    "/**",
                    " * Check whether the given `\"\\n\"` node can be converted to a space.",
                    " *",
                    " * For example, if you would like to squash English text",
                    " *",
                    " *     \"You might want\\nto use Prettier.\"",
                    " *",
                    " * into a single line, you would replace `\"\\n\"` with `\" \"`:",
                    " *",
                    " *     \"You might want to use Prettier.\"",
                    " *",
                    " * However, Chinese and Japanese don't use U+0020 Space to divide words, so line",
                    " * breaks shouldn't be replaced with spaces for those languages.",
                    " *",
                    " * PRs are welcome to support line breaking rules for other languages.",
                    " *",
                    " * @param {AstPath} path",
                    " * @param {boolean} isLink",
                    " * @returns {boolean}",
                    " */",
                    "function lineBreakCanBeConvertedToSpace(path, isLink) {",
                    "  if (isLink) {",
                    "    return true;",
                    "  }",
                    "",
                    "  /** @type {AdjacentNodes} */",
                    "  const { previous, next } = path;",
                    "",
                    "  // e.g. \" \\nletter\"",
                    "  if (!previous || !next) {",
                    "    return true;",
                    "  }",
                    "",
                    "  const previousKind = previous.kind;",
                    "  const nextKind = next.kind;",
                    "",
                    "  if (",
                    "    // \"\\n\" between non-CJK or Korean characters always can be converted to a",
                    "    // space. Korean Hangul simulates Latin words. See",
                    "    // https://github.com/prettier/prettier/issues/6516",
                    "    (isNonCJKOrKoreanLetter(previousKind) &&",
                    "      isNonCJKOrKoreanLetter(nextKind)) ||",
                    "    // Han & Hangul: same way preferred",
                    "    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||",
                    "    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Do not convert \\n to a space:",
                    "  if (",
                    "    // around CJK punctuation",
                    "    previousKind === KIND_CJK_PUNCTUATION ||",
                    "    nextKind === KIND_CJK_PUNCTUATION ||",
                    "    // between CJ",
                    "    (previousKind === KIND_CJ_LETTER && nextKind === KIND_CJ_LETTER)",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // The rest of this function deals only with line breaks between CJ and",
                    "  // non-CJK characters.",
                    "",
                    "  // Convert a line break between CJ and certain non-letter characters (e.g.",
                    "  // ASCII punctuation) to a space.",
                    "  //",
                    "  // E.g. :::\\n句子句子句子\\n::: → ::: 句子句子句子 :::",
                    "  //",
                    "  // Note: line breaks like \"(\\n句子句子\\n)\" or \"句子\\n.\" are suppressed in",
                    "  // `isBreakable(...)`.",
                    "  if (",
                    "    lineBreakBetweenTheseAndCJConvertsToSpace.has(next.value[0]) ||",
                    "    lineBreakBetweenTheseAndCJConvertsToSpace.has(previous.value.at(-1))",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Converting a line break between CJ and non-ASCII punctuation to a space is",
                    "  // undesired in many cases. PRs are welcome to fine-tune this logic.",
                    "  //",
                    "  // Examples where \\n must not be converted to a space:",
                    "  //",
                    "  // 1. \"〜\" (U+301C, belongs to Pd) in",
                    "  //",
                    "  //     \"ア〜\\nエの中から1つ選べ。\"",
                    "  //",
                    "  // 2. \"…\" (U+2026, belongs to Po) in",
                    "  //",
                    "  //     \"これはひどい……\\nなんと汚いコミットログなんだ……\"",
                    "  if (previous.hasTrailingPunctuation || next.hasLeadingPunctuation) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // If the sentence uses the style with spaces between CJ and non-CJK, \"\\n\" can",
                    "  // be converted to a space.",
                    "  return isInSentenceWithCJSpaces(path);",
                    "}",
                    "",
                    "/**",
                    " * @param {WordKind | undefined} kind",
                    " * @returns {boolean} `true` if `kind` is defined and not CJK punctuation",
                    " */",
                    "function isLetter(kind) {",
                    "  return (",
                    "    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {WordKind | undefined} kind",
                    " * @returns {boolean} `true` if `kind` is Korean letter or non-CJK",
                    " */",
                    "function isNonCJKOrKoreanLetter(kind) {",
                    "  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;",
                    "}",
                    "",
                    "/**",
                    " * Check whether whitespace can be printed as a line break.",
                    " *",
                    " * @param {AstPath} path",
                    " * @param {WhitespaceValue} value",
                    " * @param {ProseWrap} proseWrap",
                    " * @param {boolean} isLink",
                    " * @param {boolean} canBeSpace",
                    " * @returns {boolean}",
                    " */",
                    "function isBreakable(path, value, proseWrap, isLink, canBeSpace) {",
                    "  if (",
                    "    proseWrap !== \"always\" ||",
                    "    path.hasAncestor((node) => SINGLE_LINE_NODE_TYPES.has(node.type))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (isLink) {",
                    "    return value !== \"\";",
                    "  }",
                    "",
                    "  // Spaces are always breakable",
                    "  if (value === \" \") {",
                    "    return true;",
                    "  }",
                    "",
                    "  /** @type {AdjacentNodes} */",
                    "  const { previous, next } = path;",
                    "",
                    "  // Simulates Latin words; see https://github.com/prettier/prettier/issues/6516",
                    "  // [Latin][\"\"][Hangul] & vice versa => Don't break",
                    "  // [Han & Kana][\"\"][Hangul], either",
                    "  if (",
                    "    value === \"\" &&",
                    "    ((previous?.kind === KIND_K_LETTER && isLetter(next?.kind)) ||",
                    "      (next?.kind === KIND_K_LETTER && isLetter(previous?.kind)))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages",
                    "  const violatesCJKLineBreakingRules =",
                    "    !canBeSpace &&",
                    "    ((next && noBreakBefore.has(next.value[0])) ||",
                    "      (previous && noBreakAfter.has(previous.value.at(-1))));",
                    "",
                    "  if (violatesCJKLineBreakingRules) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "/**",
                    " * @param {AstPath} path",
                    " * @param {WhitespaceValue} value",
                    " * @param {ProseWrap} proseWrap",
                    " * @param {boolean} [isLink] Special mode of (un)wrapping that preserves the",
                    " * normalized form of link labels. https://spec.commonmark.org/0.30/#matches",
                    " */",
                    "function printWhitespace(path, value, proseWrap, isLink) {",
                    "  if (proseWrap === \"preserve\" && value === \"\\n\") {",
                    "    return hardline;",
                    "  }",
                    "",
                    "  const canBeSpace =",
                    "    value === \" \" ||",
                    "    (value === \"\\n\" && lineBreakCanBeConvertedToSpace(path, isLink));",
                    "",
                    "  if (isBreakable(path, value, proseWrap, isLink, canBeSpace)) {",
                    "    return canBeSpace ? line : softline;",
                    "  }",
                    "",
                    "  return canBeSpace ? \" \" : \"\";",
                    "}",
                    "",
                    "export { printWhitespace };"
                ]
            },
            "printer-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import collapseWhiteSpace from \"collapse-white-space\";",
                    "import getMinNotPresentContinuousCount from \"../utils/get-min-not-present-continuous-count.js\";",
                    "import getMaxContinuousCount from \"../utils/get-max-continuous-count.js\";",
                    "import getStringWidth from \"../utils/get-string-width.js\";",
                    "import getPreferredQuote from \"../utils/get-preferred-quote.js\";",
                    "import {",
                    "  breakParent,",
                    "  join,",
                    "  line,",
                    "  literalline,",
                    "  markAsRoot,",
                    "  hardline,",
                    "  softline,",
                    "  ifBreak,",
                    "  fill,",
                    "  align,",
                    "  indent,",
                    "  group,",
                    "  hardlineWithoutBreakParent,",
                    "} from \"../document/builders.js\";",
                    "import { normalizeDoc, replaceEndOfLine } from \"../document/utils.js\";",
                    "import { printDocToString } from \"../document/printer.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import embed from \"./embed.js\";",
                    "import { insertPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import preprocess from \"./print-preprocess.js\";",
                    "import clean from \"./clean.js\";",
                    "import {",
                    "  getFencedCodeBlockValue,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "  isAutolink,",
                    "} from \"./utils.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "import { printWhitespace } from \"./print-whitespace.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                    " */",
                    "",
                    "const SIBLING_NODE_TYPES = new Set([",
                    "  \"listItem\",",
                    "  \"definition\",",
                    "  \"footnoteDefinition\",",
                    "]);",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  if (shouldRemainTheSameContent(path)) {",
                    "    return splitText(",
                    "      options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      )",
                    "    ).map((node) =>",
                    "      node.type === \"word\"",
                    "        ? node.value",
                    "        : printWhitespace(path, node.value, options.proseWrap, true)",
                    "    );",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"root\":",
                    "      /* c8 ignore next 3 */",
                    "      if (node.children.length === 0) {",
                    "        return \"\";",
                    "      }",
                    "      return [normalizeDoc(printRoot(path, options, print)), hardline];",
                    "    case \"paragraph\":",
                    "      return printChildren(path, options, print, {",
                    "        postprocessor: fill,",
                    "      });",
                    "    case \"sentence\":",
                    "      return printChildren(path, options, print);",
                    "    case \"word\": {",
                    "      let escapedValue = node.value",
                    "        .replaceAll(\"*\", \"\\\\*\") // escape all `*`",
                    "        .replaceAll(",
                    "          new RegExp(",
                    "            [",
                    "              `(^|${punctuationPattern})(_+)`,",
                    "              `(_+)(${punctuationPattern}|$)`,",
                    "            ].join(\"|\"),",
                    "            \"g\"",
                    "          ),",
                    "          (_, text1, underscore1, underscore2, text2) =>",
                    "            (underscore1",
                    "              ? `${text1}${underscore1}`",
                    "              : `${underscore2}${text2}`",
                    "            ).replaceAll(\"_\", \"\\\\_\")",
                    "        ); // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis",
                    "",
                    "      const isFirstSentence = (node, name, index) =>",
                    "        node.type === \"sentence\" && index === 0;",
                    "      const isLastChildAutolink = (node, name, index) =>",
                    "        isAutolink(node.children[index - 1]);",
                    "",
                    "      if (",
                    "        escapedValue !== node.value &&",
                    "        (path.match(undefined, isFirstSentence, isLastChildAutolink) ||",
                    "          path.match(",
                    "            undefined,",
                    "            isFirstSentence,",
                    "            (node, name, index) => node.type === \"emphasis\" && index === 0,",
                    "            isLastChildAutolink",
                    "          ))",
                    "      ) {",
                    "        // backslash is parsed as part of autolinks, so we need to remove it",
                    "        escapedValue = escapedValue.replace(/^(\\\\?[*_])+/, (prefix) =>",
                    "          prefix.replaceAll(\"\\\\\", \"\")",
                    "        );",
                    "      }",
                    "",
                    "      return escapedValue;",
                    "    }",
                    "    case \"whitespace\": {",
                    "      const { next } = path;",
                    "",
                    "      const proseWrap =",
                    "        // leading char that may cause different syntax",
                    "        next && /^>|^(?:[*+-]|#{1,6}|\\d+[).])$/.test(next.value)",
                    "          ? \"never\"",
                    "          : options.proseWrap;",
                    "",
                    "      return printWhitespace(path, node.value, proseWrap);",
                    "    }",
                    "    case \"emphasis\": {",
                    "      let style;",
                    "      if (isAutolink(node.children[0])) {",
                    "        style = options.originalText[node.position.start.offset];",
                    "      } else {",
                    "        const { previous, next } = path;",
                    "        const hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not",
                    "          (previous?.type === \"sentence\" &&",
                    "            previous.children.at(-1)?.type === \"word\" &&",
                    "            !previous.children.at(-1).hasTrailingPunctuation) ||",
                    "          (next?.type === \"sentence\" &&",
                    "            next.children[0]?.type === \"word\" &&",
                    "            !next.children[0].hasLeadingPunctuation);",
                    "        style =",
                    "          hasPrevOrNextWord ||",
                    "          path.hasAncestor((node) => node.type === \"emphasis\")",
                    "            ? \"*\"",
                    "            : \"_\";",
                    "      }",
                    "      return [style, printChildren(path, options, print), style];",
                    "    }",
                    "    case \"strong\":",
                    "      return [\"**\", printChildren(path, options, print), \"**\"];",
                    "    case \"delete\":",
                    "      return [\"~~\", printChildren(path, options, print), \"~~\"];",
                    "    case \"inlineCode\": {",
                    "      const code =",
                    "        options.proseWrap === \"preserve\"",
                    "          ? node.value",
                    "          : node.value.replaceAll(\"\\n\", \" \");",
                    "      const backtickCount = getMinNotPresentContinuousCount(code, \"`\");",
                    "      const backtickString = \"`\".repeat(backtickCount || 1);",
                    "      const padding =",
                    "        code.startsWith(\"`\") ||",
                    "        code.endsWith(\"`\") ||",
                    "        (/^[\\n ]/.test(code) && /[\\n ]$/.test(code) && /[^\\n ]/.test(code))",
                    "          ? \" \"",
                    "          : \"\";",
                    "      return [backtickString, padding, code, padding, backtickString];",
                    "    }",
                    "    case \"wikiLink\": {",
                    "      let contents = \"\";",
                    "      if (options.proseWrap === \"preserve\") {",
                    "        contents = node.value;",
                    "      } else {",
                    "        contents = node.value.replaceAll(/[\\t\\n]+/g, \" \");",
                    "      }",
                    "",
                    "      return [\"[[\", contents, \"]]\"];",
                    "    }",
                    "    case \"link\":",
                    "      switch (options.originalText[node.position.start.offset]) {",
                    "        case \"<\": {",
                    "          const mailto = \"mailto:\";",
                    "          const url =",
                    "            // <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }",
                    "            node.url.startsWith(mailto) &&",
                    "            options.originalText.slice(",
                    "              node.position.start.offset + 1,",
                    "              node.position.start.offset + 1 + mailto.length",
                    "            ) !== mailto",
                    "              ? node.url.slice(mailto.length)",
                    "              : node.url;",
                    "          return [\"<\", url, \">\"];",
                    "        }",
                    "        case \"[\":",
                    "          return [",
                    "            \"[\",",
                    "            printChildren(path, options, print),",
                    "            \"](\",",
                    "            printUrl(node.url, \")\"),",
                    "            printTitle(node.title, options),",
                    "            \")\",",
                    "          ];",
                    "        default:",
                    "          return options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          );",
                    "      }",
                    "    case \"image\":",
                    "      return [",
                    "        \"![\",",
                    "        node.alt || \"\",",
                    "        \"](\",",
                    "        printUrl(node.url, \")\"),",
                    "        printTitle(node.title, options),",
                    "        \")\",",
                    "      ];",
                    "    case \"blockquote\":",
                    "      return [\"> \", align(\"> \", printChildren(path, options, print))];",
                    "    case \"heading\":",
                    "      return [",
                    "        \"#\".repeat(node.depth) + \" \",",
                    "        printChildren(path, options, print),",
                    "      ];",
                    "    case \"code\": {",
                    "      if (node.isIndented) {",
                    "        // indented code block",
                    "        const alignment = \" \".repeat(4);",
                    "        return align(alignment, [",
                    "          alignment,",
                    "          replaceEndOfLine(node.value, hardline),",
                    "        ]);",
                    "      }",
                    "",
                    "      // fenced code block",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "      );",
                    "      return [",
                    "        style,",
                    "        node.lang || \"\",",
                    "        node.meta ? \" \" + node.meta : \"\",",
                    "        hardline,",
                    "        replaceEndOfLine(",
                    "          getFencedCodeBlockValue(node, options.originalText),",
                    "          hardline",
                    "        ),",
                    "        hardline,",
                    "        style,",
                    "      ];",
                    "    }",
                    "    case \"html\": {",
                    "      const { parent, isLast } = path;",
                    "      const value =",
                    "        parent.type === \"root\" && isLast ? node.value.trimEnd() : node.value;",
                    "      const isHtmlComment = /^<!--.*-->$/s.test(value);",
                    "",
                    "      return replaceEndOfLine(",
                    "        value,",
                    "        // @ts-expect-error",
                    "        isHtmlComment ? hardline : markAsRoot(literalline)",
                    "      );",
                    "    }",
                    "    case \"list\": {",
                    "      const nthSiblingIndex = getNthListSiblingIndex(node, path.parent);",
                    "",
                    "      const isGitDiffFriendlyOrderedList = hasGitDiffFriendlyOrderedList(",
                    "        node,",
                    "        options",
                    "      );",
                    "",
                    "      return printChildren(path, options, print, {",
                    "        processor(childPath) {",
                    "          const prefix = getPrefix();",
                    "          const childNode = childPath.node;",
                    "",
                    "          if (",
                    "            childNode.children.length === 2 &&",
                    "            childNode.children[1].type === \"html\" &&",
                    "            childNode.children[0].position.start.column !==",
                    "              childNode.children[1].position.start.column",
                    "          ) {",
                    "            return [prefix, printListItem(childPath, options, print, prefix)];",
                    "          }",
                    "",
                    "          return [",
                    "            prefix,",
                    "            align(",
                    "              \" \".repeat(prefix.length),",
                    "              printListItem(childPath, options, print, prefix)",
                    "            ),",
                    "          ];",
                    "",
                    "          function getPrefix() {",
                    "            const rawPrefix = node.ordered",
                    "              ? (childPath.isFirst",
                    "                  ? node.start",
                    "                  : isGitDiffFriendlyOrderedList",
                    "                  ? 1",
                    "                  : node.start + childPath.index) +",
                    "                (nthSiblingIndex % 2 === 0 ? \". \" : \") \")",
                    "              : nthSiblingIndex % 2 === 0",
                    "              ? \"- \"",
                    "              : \"* \";",
                    "",
                    "            return node.isAligned ||",
                    "              /* workaround for https://github.com/remarkjs/remark/issues/315 */ node.hasIndentedCodeblock",
                    "              ? alignListPrefix(rawPrefix, options)",
                    "              : rawPrefix;",
                    "          }",
                    "        },",
                    "      });",
                    "    }",
                    "    case \"thematicBreak\": {",
                    "      const { ancestors } = path;",
                    "      const counter = ancestors.findIndex((node) => node.type === \"list\");",
                    "      if (counter === -1) {",
                    "        return \"---\";",
                    "      }",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        ancestors[counter],",
                    "        ancestors[counter + 1]",
                    "      );",
                    "      return nthSiblingIndex % 2 === 0 ? \"***\" : \"---\";",
                    "    }",
                    "    case \"linkReference\":",
                    "      return [",
                    "        \"[\",",
                    "        printChildren(path, options, print),",
                    "        \"]\",",
                    "        node.referenceType === \"full\"",
                    "          ? printLinkReference(node)",
                    "          : node.referenceType === \"collapsed\"",
                    "          ? \"[]\"",
                    "          : \"\",",
                    "      ];",
                    "    case \"imageReference\":",
                    "      switch (node.referenceType) {",
                    "        case \"full\":",
                    "          return [\"![\", node.alt || \"\", \"]\", printLinkReference(node)];",
                    "        default:",
                    "          return [",
                    "            \"![\",",
                    "            node.alt,",
                    "            \"]\",",
                    "            node.referenceType === \"collapsed\" ? \"[]\" : \"\",",
                    "          ];",
                    "      }",
                    "    case \"definition\": {",
                    "      const lineOrSpace = options.proseWrap === \"always\" ? line : \" \";",
                    "      return group([",
                    "        printLinkReference(node),",
                    "        \":\",",
                    "        indent([",
                    "          lineOrSpace,",
                    "          printUrl(node.url),",
                    "          node.title === null",
                    "            ? \"\"",
                    "            : [lineOrSpace, printTitle(node.title, options, false)],",
                    "        ]),",
                    "      ]);",
                    "    }",
                    "    // `footnote` requires `.use(footnotes, {inlineNotes: true})`, we are not using this option",
                    "    // https://github.com/remarkjs/remark-footnotes#optionsinlinenotes",
                    "    /* c8 ignore next 2 */",
                    "    case \"footnote\":",
                    "      return [\"[^\", printChildren(path, options, print), \"]\"];",
                    "    case \"footnoteReference\":",
                    "      return printFootnoteReference(node);",
                    "    case \"footnoteDefinition\": {",
                    "      const shouldInlineFootnote =",
                    "        node.children.length === 1 &&",
                    "        node.children[0].type === \"paragraph\" &&",
                    "        (options.proseWrap === \"never\" ||",
                    "          (options.proseWrap === \"preserve\" &&",
                    "            node.children[0].position.start.line ===",
                    "              node.children[0].position.end.line));",
                    "      return [",
                    "        printFootnoteReference(node),",
                    "        \": \",",
                    "        shouldInlineFootnote",
                    "          ? printChildren(path, options, print)",
                    "          : group([",
                    "              align(",
                    "                \" \".repeat(4),",
                    "                printChildren(path, options, print, {",
                    "                  processor: ({ isFirst }) =>",
                    "                    isFirst ? group([softline, print()]) : print(),",
                    "                })",
                    "              ),",
                    "              path.next?.type === \"footnoteDefinition\" ? softline : \"\",",
                    "            ]),",
                    "      ];",
                    "    }",
                    "    case \"table\":",
                    "      return printTable(path, options, print);",
                    "    case \"tableCell\":",
                    "      return printChildren(path, options, print);",
                    "    case \"break\":",
                    "      return /\\s/.test(options.originalText[node.position.start.offset])",
                    "        ? [\"  \", markAsRoot(literalline)]",
                    "        : [\"\\\\\", hardline];",
                    "    case \"liquidNode\":",
                    "      return replaceEndOfLine(node.value, hardline);",
                    "    // MDX",
                    "    // fallback to the original text if multiparser failed",
                    "    // or `embeddedLanguageFormatting: \"off\"`",
                    "    case \"import\":",
                    "    case \"export\":",
                    "    case \"jsx\":",
                    "      return node.value;",
                    "    case \"esComment\":",
                    "      return [\"{/* \", node.value, \" */}\"];",
                    "    case \"math\":",
                    "      return [",
                    "        \"$$\",",
                    "        hardline,",
                    "        node.value ? [replaceEndOfLine(node.value, hardline), hardline] : \"\",",
                    "        \"$$\",",
                    "      ];",
                    "    case \"inlineMath\":",
                    "      // remark-math trims content but we don't want to remove whitespaces",
                    "      // since it's very possible that it's recognized as math accidentally",
                    "      return options.originalText.slice(locStart(node), locEnd(node));",
                    "",
                    "    case \"tableRow\": // handled in \"table\"",
                    "    case \"listItem\": // handled in \"list\"",
                    "    case \"text\": // handled in other types",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"Markdown\");",
                    "  }",
                    "}",
                    "",
                    "function printListItem(path, options, print, listPrefix) {",
                    "  const { node } = path;",
                    "  const prefix = node.checked === null ? \"\" : node.checked ? \"[x] \" : \"[ ] \";",
                    "  return [",
                    "    prefix,",
                    "    printChildren(path, options, print, {",
                    "      processor({ node, isFirst }) {",
                    "        if (isFirst && node.type !== \"list\") {",
                    "          return align(\" \".repeat(prefix.length), print());",
                    "        }",
                    "",
                    "        const alignment = \" \".repeat(",
                    "          clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block",
                    "        );",
                    "        return [alignment, align(alignment, print())];",
                    "      },",
                    "    }),",
                    "  ];",
                    "}",
                    "",
                    "function alignListPrefix(prefix, options) {",
                    "  const additionalSpaces = getAdditionalSpaces();",
                    "  return (",
                    "    prefix +",
                    "    \" \".repeat(",
                    "      additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block",
                    "    )",
                    "  );",
                    "",
                    "  function getAdditionalSpaces() {",
                    "    const restSpaces = prefix.length % options.tabWidth;",
                    "    return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;",
                    "  }",
                    "}",
                    "",
                    "function getNthListSiblingIndex(node, parentNode) {",
                    "  return getNthSiblingIndex(",
                    "    node,",
                    "    parentNode,",
                    "    (siblingNode) => siblingNode.ordered === node.ordered",
                    "  );",
                    "}",
                    "",
                    "function getNthSiblingIndex(node, parentNode, condition) {",
                    "  let index = -1;",
                    "",
                    "  for (const childNode of parentNode.children) {",
                    "    if (childNode.type === node.type && condition(childNode)) {",
                    "      index++;",
                    "    } else {",
                    "      index = -1;",
                    "    }",
                    "",
                    "    if (childNode === node) {",
                    "      return index;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function printTable(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  const columnMaxWidths = [];",
                    "  // { [rowIndex: number]: { [columnIndex: number]: {text: string, width: number} } }",
                    "  const contents = path.map(",
                    "    () =>",
                    "      path.map(({ index: columnIndex }) => {",
                    "        const text = printDocToString(print(), options).formatted;",
                    "        const width = getStringWidth(text);",
                    "        columnMaxWidths[columnIndex] = Math.max(",
                    "          columnMaxWidths[columnIndex] || 3, // minimum width = 3 (---, :--, :-:, --:)",
                    "          width",
                    "        );",
                    "        return { text, width };",
                    "      }, \"children\"),",
                    "    \"children\"",
                    "  );",
                    "",
                    "  const alignedTable = printTableContents(/* isCompact */ false);",
                    "  if (options.proseWrap !== \"never\") {",
                    "    return [breakParent, alignedTable];",
                    "  }",
                    "",
                    "  // Only if the --prose-wrap never is set and it exceeds the print width.",
                    "  const compactTable = printTableContents(/* isCompact */ true);",
                    "  return [breakParent, group(ifBreak(compactTable, alignedTable))];",
                    "",
                    "  function printTableContents(isCompact) {",
                    "    /** @type{Doc[]} */",
                    "    const parts = [printRow(contents[0], isCompact), printAlign(isCompact)];",
                    "    if (contents.length > 1) {",
                    "      parts.push(",
                    "        join(",
                    "          hardlineWithoutBreakParent,",
                    "          contents",
                    "            .slice(1)",
                    "            .map((rowContents) => printRow(rowContents, isCompact))",
                    "        )",
                    "      );",
                    "    }",
                    "    return join(hardlineWithoutBreakParent, parts);",
                    "  }",
                    "",
                    "  function printAlign(isCompact) {",
                    "    const align = columnMaxWidths.map((width, index) => {",
                    "      const align = node.align[index];",
                    "      const first = align === \"center\" || align === \"left\" ? \":\" : \"-\";",
                    "      const last = align === \"center\" || align === \"right\" ? \":\" : \"-\";",
                    "      const middle = isCompact ? \"-\" : \"-\".repeat(width - 2);",
                    "      return `${first}${middle}${last}`;",
                    "    });",
                    "",
                    "    return `| ${align.join(\" | \")} |`;",
                    "  }",
                    "",
                    "  function printRow(rowContents, isCompact) {",
                    "    const columns = rowContents.map(({ text, width }, columnIndex) => {",
                    "      if (isCompact) {",
                    "        return text;",
                    "      }",
                    "      const spaces = columnMaxWidths[columnIndex] - width;",
                    "      const align = node.align[columnIndex];",
                    "      let before = 0;",
                    "      if (align === \"right\") {",
                    "        before = spaces;",
                    "      } else if (align === \"center\") {",
                    "        before = Math.floor(spaces / 2);",
                    "      }",
                    "      const after = spaces - before;",
                    "      return `${\" \".repeat(before)}${text}${\" \".repeat(after)}`;",
                    "    });",
                    "",
                    "    return `| ${columns.join(\" | \")} |`;",
                    "  }",
                    "}",
                    "",
                    "function printRoot(path, options, print) {",
                    "  /** @typedef {{ index: number, offset: number }} IgnorePosition */",
                    "  /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */",
                    "  const ignoreRanges = [];",
                    "",
                    "  /** @type {IgnorePosition | null} */",
                    "  let ignoreStart = null;",
                    "",
                    "  const { children } = path.node;",
                    "  for (const [index, childNode] of children.entries()) {",
                    "    switch (isPrettierIgnore(childNode)) {",
                    "      case \"start\":",
                    "        if (ignoreStart === null) {",
                    "          ignoreStart = { index, offset: childNode.position.end.offset };",
                    "        }",
                    "        break;",
                    "      case \"end\":",
                    "        if (ignoreStart !== null) {",
                    "          ignoreRanges.push({",
                    "            start: ignoreStart,",
                    "            end: { index, offset: childNode.position.start.offset },",
                    "          });",
                    "          ignoreStart = null;",
                    "        }",
                    "        break;",
                    "      default:",
                    "        // do nothing",
                    "        break;",
                    "    }",
                    "  }",
                    "",
                    "  return printChildren(path, options, print, {",
                    "    processor({ index }) {",
                    "      if (ignoreRanges.length > 0) {",
                    "        const ignoreRange = ignoreRanges[0];",
                    "",
                    "        if (index === ignoreRange.start.index) {",
                    "          return [",
                    "            printIgnoreComment(children[ignoreRange.start.index]),",
                    "            options.originalText.slice(",
                    "              ignoreRange.start.offset,",
                    "              ignoreRange.end.offset",
                    "            ),",
                    "            printIgnoreComment(children[ignoreRange.end.index]),",
                    "          ];",
                    "        }",
                    "",
                    "        if (ignoreRange.start.index < index && index < ignoreRange.end.index) {",
                    "          return false;",
                    "        }",
                    "",
                    "        if (index === ignoreRange.end.index) {",
                    "          ignoreRanges.shift();",
                    "          return false;",
                    "        }",
                    "      }",
                    "",
                    "      return print();",
                    "    },",
                    "  });",
                    "}",
                    "",
                    "function printChildren(path, options, print, events = {}) {",
                    "  const { postprocessor = (parts) => parts, processor = () => print() } =",
                    "    events;",
                    "",
                    "  const parts = [];",
                    "",
                    "  path.each(() => {",
                    "    const result = processor(path);",
                    "    if (result !== false) {",
                    "      if (parts.length > 0 && shouldPrePrintHardline(path)) {",
                    "        parts.push(hardline);",
                    "",
                    "        if (",
                    "          shouldPrePrintDoubleHardline(path, options) ||",
                    "          shouldPrePrintTripleHardline(path)",
                    "        ) {",
                    "          parts.push(hardline);",
                    "        }",
                    "",
                    "        if (shouldPrePrintTripleHardline(path)) {",
                    "          parts.push(hardline);",
                    "        }",
                    "      }",
                    "",
                    "      parts.push(result);",
                    "    }",
                    "  }, \"children\");",
                    "",
                    "  return postprocessor(parts);",
                    "}",
                    "",
                    "function printIgnoreComment(node) {",
                    "  if (node.type === \"html\") {",
                    "    return node.value;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"paragraph\" &&",
                    "    Array.isArray(node.children) &&",
                    "    node.children.length === 1 &&",
                    "    node.children[0].type === \"esComment\"",
                    "  ) {",
                    "    return [\"{/* \", node.children[0].value, \" */}\"];",
                    "  }",
                    "}",
                    "",
                    "/** @return {false | 'next' | 'start' | 'end'} */",
                    "function isPrettierIgnore(node) {",
                    "  let match;",
                    "",
                    "  if (node.type === \"html\") {",
                    "    match = node.value.match(/^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/);",
                    "  } else {",
                    "    let comment;",
                    "",
                    "    if (node.type === \"esComment\") {",
                    "      comment = node;",
                    "    } else if (",
                    "      node.type === \"paragraph\" &&",
                    "      node.children.length === 1 &&",
                    "      node.children[0].type === \"esComment\"",
                    "    ) {",
                    "      comment = node.children[0];",
                    "    }",
                    "",
                    "    if (comment) {",
                    "      match = comment.value.match(/^prettier-ignore(?:-(start|end))?$/);",
                    "    }",
                    "  }",
                    "",
                    "  return match ? match[1] || \"next\" : false;",
                    "}",
                    "",
                    "function shouldPrePrintHardline({ node, parent }) {",
                    "  const isInlineNode = INLINE_NODE_TYPES.has(node.type);",
                    "",
                    "  const isInlineHTML =",
                    "    node.type === \"html\" && INLINE_NODE_WRAPPER_TYPES.has(parent.type);",
                    "",
                    "  return !isInlineNode && !isInlineHTML;",
                    "}",
                    "",
                    "function isLooseListItem(node, options) {",
                    "  return (",
                    "    node.type === \"listItem\" &&",
                    "    (node.spread ||",
                    "      // Check if `listItem` ends with `\\n`",
                    "      // since it can't be empty, so we only need check the last character",
                    "      options.originalText.charAt(node.position.end.offset - 1) === \"\\n\")",
                    "  );",
                    "}",
                    "",
                    "function shouldPrePrintDoubleHardline({ node, previous, parent }, options) {",
                    "  const isPrevNodeLooseListItem = isLooseListItem(previous, options);",
                    "",
                    "  if (isPrevNodeLooseListItem) {",
                    "    return true;",
                    "  }",
                    "",
                    "  const isSequence = previous.type === node.type;",
                    "  const isSiblingNode = isSequence && SIBLING_NODE_TYPES.has(node.type);",
                    "  const isInTightListItem =",
                    "    parent.type === \"listItem\" && !isLooseListItem(parent, options);",
                    "  const isPrevNodePrettierIgnore = isPrettierIgnore(previous) === \"next\";",
                    "  const isBlockHtmlWithoutBlankLineBetweenPrevHtml =",
                    "    node.type === \"html\" &&",
                    "    previous.type === \"html\" &&",
                    "    previous.position.end.line + 1 === node.position.start.line;",
                    "  const isHtmlDirectAfterListItem =",
                    "    node.type === \"html\" &&",
                    "    parent.type === \"listItem\" &&",
                    "    previous.type === \"paragraph\" &&",
                    "    previous.position.end.line + 1 === node.position.start.line;",
                    "",
                    "  return !(",
                    "    isSiblingNode ||",
                    "    isInTightListItem ||",
                    "    isPrevNodePrettierIgnore ||",
                    "    isBlockHtmlWithoutBlankLineBetweenPrevHtml ||",
                    "    isHtmlDirectAfterListItem",
                    "  );",
                    "}",
                    "",
                    "function shouldPrePrintTripleHardline({ node, previous }) {",
                    "  const isPrevNodeList = previous.type === \"list\";",
                    "  const isIndentedCode = node.type === \"code\" && node.isIndented;",
                    "",
                    "  return isPrevNodeList && isIndentedCode;",
                    "}",
                    "",
                    "function shouldRemainTheSameContent(path) {",
                    "  const node = path.findAncestor(",
                    "    (node) => node.type === \"linkReference\" || node.type === \"imageReference\"",
                    "  );",
                    "  return (",
                    "    node && (node.type !== \"linkReference\" || node.referenceType !== \"full\")",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} url",
                    " * @param {string[] | string} [dangerousCharOrChars]",
                    " * @returns {string}",
                    " */",
                    "function printUrl(url, dangerousCharOrChars = []) {",
                    "  const dangerousChars = [",
                    "    \" \",",
                    "    ...(Array.isArray(dangerousCharOrChars)",
                    "      ? dangerousCharOrChars",
                    "      : [dangerousCharOrChars]),",
                    "  ];",
                    "  return new RegExp(dangerousChars.map((x) => `\\\\${x}`).join(\"|\")).test(url)",
                    "    ? `<${url}>`",
                    "    : url;",
                    "}",
                    "",
                    "function printTitle(title, options, printSpace = true) {",
                    "  if (!title) {",
                    "    return \"\";",
                    "  }",
                    "  if (printSpace) {",
                    "    return \" \" + printTitle(title, options, false);",
                    "  }",
                    "",
                    "  // title is escaped after `remark-parse` v7",
                    "  title = title.replaceAll(/\\\\(?=[\"')])/g, \"\");",
                    "",
                    "  if (title.includes('\"') && title.includes(\"'\") && !title.includes(\")\")) {",
                    "    return `(${title})`; // avoid escaped quotes",
                    "  }",
                    "  const quote = getPreferredQuote(title, options.singleQuote);",
                    "  title = title.replaceAll(\"\\\\\", \"\\\\\\\\\");",
                    "  title = title.replaceAll(quote, `\\\\${quote}`);",
                    "  return `${quote}${title}${quote}`;",
                    "}",
                    "",
                    "function clamp(value, min, max) {",
                    "  return value < min ? min : value > max ? max : value;",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  return path.index > 0 && isPrettierIgnore(path.previous) === \"next\";",
                    "}",
                    "",
                    "// `remark-parse` lowercase the `label` as `identifier`, we don't want do that",
                    "// https://github.com/remarkjs/remark/blob/daddcb463af2d5b2115496c395d0571c0ff87d15/packages/remark-parse/lib/tokenize/reference.js",
                    "function printLinkReference(node) {",
                    "  return `[${collapseWhiteSpace(node.label)}]`;",
                    "}",
                    "",
                    "function printFootnoteReference(node) {",
                    "  return `[^${node.label}]`;",
                    "}",
                    "",
                    "const printer = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  embed,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  insertPragma,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import assert from \"node:assert\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import {",
                    "  cjkPattern,",
                    "  kRegex,",
                    "  punctuationPattern,",
                    "} from \"./constants.evaluate.js\";",
                    "",
                    "const INLINE_NODE_TYPES = new Set([",
                    "  \"liquidNode\",",
                    "  \"inlineCode\",",
                    "  \"emphasis\",",
                    "  \"esComment\",",
                    "  \"strong\",",
                    "  \"delete\",",
                    "  \"wikiLink\",",
                    "  \"link\",",
                    "  \"linkReference\",",
                    "  \"image\",",
                    "  \"imageReference\",",
                    "  \"footnote\",",
                    "  \"footnoteReference\",",
                    "  \"sentence\",",
                    "  \"whitespace\",",
                    "  \"word\",",
                    "  \"break\",",
                    "  \"inlineMath\",",
                    "]);",
                    "",
                    "const INLINE_NODE_WRAPPER_TYPES = new Set([",
                    "  ...INLINE_NODE_TYPES,",
                    "  \"tableCell\",",
                    "  \"paragraph\",",
                    "  \"heading\",",
                    "]);",
                    "",
                    "const punctuationRegex = new RegExp(punctuationPattern);",
                    "",
                    "const KIND_NON_CJK = \"non-cjk\";",
                    "const KIND_CJ_LETTER = \"cj-letter\";",
                    "const KIND_K_LETTER = \"k-letter\";",
                    "const KIND_CJK_PUNCTUATION = \"cjk-punctuation\";",
                    "",
                    "/**",
                    " * @typedef {\" \" | \"\\n\" | \"\"} WhitespaceValue",
                    " * @typedef { KIND_NON_CJK | KIND_CJ_LETTER | KIND_K_LETTER | KIND_CJK_PUNCTUATION } WordKind",
                    " * @typedef {{",
                    " *   type: \"whitespace\",",
                    " *   value: WhitespaceValue,",
                    " *   kind?: never",
                    " * }} WhitespaceNode",
                    " * @typedef {{",
                    " *   type: \"word\",",
                    " *   value: string,",
                    " *   kind: WordKind,",
                    " *   hasLeadingPunctuation: boolean,",
                    " *   hasTrailingPunctuation: boolean,",
                    " * }} WordNode",
                    " * Node for a single CJK character or a sequence of non-CJK characters",
                    " * @typedef {WhitespaceNode | WordNode} TextNode",
                    " */",
                    "",
                    "/**",
                    " * split text into whitespaces and words",
                    " * @param {string} text",
                    " */",
                    "function splitText(text) {",
                    "  /** @type {Array<TextNode>} */",
                    "  const nodes = [];",
                    "",
                    "  const tokens = text.split(/([\\t\\n ]+)/);",
                    "  for (const [index, token] of tokens.entries()) {",
                    "    // whitespace",
                    "    if (index % 2 === 1) {",
                    "      nodes.push({",
                    "        type: \"whitespace\",",
                    "        value: /\\n/.test(token) ? \"\\n\" : \" \",",
                    "      });",
                    "      continue;",
                    "    }",
                    "",
                    "    // word separated by whitespace",
                    "",
                    "    if ((index === 0 || index === tokens.length - 1) && token === \"\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    const innerTokens = token.split(new RegExp(`(${cjkPattern})`));",
                    "    for (const [innerIndex, innerToken] of innerTokens.entries()) {",
                    "      if (",
                    "        (innerIndex === 0 || innerIndex === innerTokens.length - 1) &&",
                    "        innerToken === \"\"",
                    "      ) {",
                    "        continue;",
                    "      }",
                    "",
                    "      // non-CJK word",
                    "      if (innerIndex % 2 === 0) {",
                    "        if (innerToken !== \"\") {",
                    "          appendNode({",
                    "            type: \"word\",",
                    "            value: innerToken,",
                    "            kind: KIND_NON_CJK,",
                    "            hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),",
                    "            hasTrailingPunctuation: punctuationRegex.test(innerToken.at(-1)),",
                    "          });",
                    "        }",
                    "        continue;",
                    "      }",
                    "",
                    "      // CJK character",
                    "      appendNode(",
                    "        punctuationRegex.test(innerToken)",
                    "          ? {",
                    "              type: \"word\",",
                    "              value: innerToken,",
                    "              kind: KIND_CJK_PUNCTUATION,",
                    "              hasLeadingPunctuation: true,",
                    "              hasTrailingPunctuation: true,",
                    "            }",
                    "          : {",
                    "              type: \"word\",",
                    "              value: innerToken,",
                    "              // Korean uses space to divide words, but Chinese & Japanese do not",
                    "              kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,",
                    "              hasLeadingPunctuation: false,",
                    "              hasTrailingPunctuation: false,",
                    "            }",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  // Check for `canBeConvertedToSpace` in ./print-whitespace.js etc.",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    for (let i = 1; i < nodes.length; i++) {",
                    "      assert(",
                    "        !(nodes[i - 1].type === \"whitespace\" && nodes[i].type === \"whitespace\"),",
                    "        \"splitText should not create consecutive whitespace nodes\"",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return nodes;",
                    "",
                    "  function appendNode(node) {",
                    "    const lastNode = nodes.at(-1);",
                    "    if (",
                    "      lastNode?.type === \"word\" &&",
                    "      !isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) &&",
                    "      // disallow leading/trailing full-width whitespace",
                    "      ![lastNode.value, node.value].some((value) => /\\u3000/.test(value))",
                    "    ) {",
                    "      nodes.push({ type: \"whitespace\", value: \"\" });",
                    "    }",
                    "    nodes.push(node);",
                    "",
                    "    function isBetween(kind1, kind2) {",
                    "      return (",
                    "        (lastNode.kind === kind1 && node.kind === kind2) ||",
                    "        (lastNode.kind === kind2 && node.kind === kind1)",
                    "      );",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getOrderedListItemInfo(orderListItem, originalText) {",
                    "  const [, numberText, marker, leadingSpaces] = originalText",
                    "    .slice(",
                    "      orderListItem.position.start.offset,",
                    "      orderListItem.position.end.offset",
                    "    )",
                    "    .match(/^\\s*(\\d+)(\\.|\\))(\\s*)/);",
                    "",
                    "  return { numberText, marker, leadingSpaces };",
                    "}",
                    "",
                    "function hasGitDiffFriendlyOrderedList(node, options) {",
                    "  if (!node.ordered) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (node.children.length < 2) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const firstNumber = Number(",
                    "    getOrderedListItemInfo(node.children[0], options.originalText).numberText",
                    "  );",
                    "",
                    "  const secondNumber = Number(",
                    "    getOrderedListItemInfo(node.children[1], options.originalText).numberText",
                    "  );",
                    "",
                    "  if (firstNumber === 0 && node.children.length > 2) {",
                    "    const thirdNumber = Number(",
                    "      getOrderedListItemInfo(node.children[2], options.originalText).numberText",
                    "    );",
                    "",
                    "    return secondNumber === 1 && thirdNumber === 1;",
                    "  }",
                    "",
                    "  return secondNumber === 1;",
                    "}",
                    "",
                    "// The final new line should not include in value",
                    "// https://github.com/remarkjs/remark/issues/512",
                    "function getFencedCodeBlockValue(node, originalText) {",
                    "  const { value } = node;",
                    "  if (",
                    "    node.position.end.offset === originalText.length &&",
                    "    value.endsWith(\"\\n\") &&",
                    "    // Code block has no end mark",
                    "    originalText.endsWith(\"\\n\")",
                    "  ) {",
                    "    return value.slice(0, -1);",
                    "  }",
                    "  return value;",
                    "}",
                    "",
                    "function mapAst(ast, handler) {",
                    "  return (function preorder(node, index, parentStack) {",
                    "    const newNode = { ...handler(node, index, parentStack) };",
                    "    if (newNode.children) {",
                    "      newNode.children = newNode.children.map((child, index) =>",
                    "        preorder(child, index, [newNode, ...parentStack])",
                    "      );",
                    "    }",
                    "",
                    "    return newNode;",
                    "  })(ast, null, []);",
                    "}",
                    "",
                    "function isAutolink(node) {",
                    "  if (node?.type !== \"link\" || node.children.length !== 1) {",
                    "    return false;",
                    "  }",
                    "  const [child] = node.children;",
                    "  return locStart(node) === locStart(child) && locEnd(node) === locEnd(child);",
                    "}",
                    "",
                    "export {",
                    "  mapAst,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  getFencedCodeBlockValue,",
                    "  getOrderedListItemInfo,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "  isAutolink,",
                    "  KIND_NON_CJK,",
                    "  KIND_CJ_LETTER,",
                    "  KIND_K_LETTER,",
                    "  KIND_CJK_PUNCTUATION,",
                    "};"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = {",
                    "  \"front-matter\": [],",
                    "  root: [\"children\"],",
                    "  paragraph: [\"children\"],",
                    "  sentence: [\"children\"],",
                    "  word: [],",
                    "  whitespace: [],",
                    "  emphasis: [\"children\"],",
                    "  strong: [\"children\"],",
                    "  delete: [\"children\"],",
                    "  inlineCode: [],",
                    "  wikiLink: [],",
                    "  link: [\"children\"],",
                    "  image: [],",
                    "  blockquote: [\"children\"],",
                    "  heading: [\"children\"],",
                    "  code: [],",
                    "  html: [],",
                    "  list: [\"children\"],",
                    "  thematicBreak: [],",
                    "  linkReference: [\"children\"],",
                    "  imageReference: [],",
                    "  definition: [],",
                    "  footnote: [\"children\"],",
                    "  footnoteReference: [],",
                    "  footnoteDefinition: [\"children\"],",
                    "  table: [\"children\"],",
                    "  tableCell: [\"children\"],",
                    "  break: [],",
                    "  liquidNode: [],",
                    "  import: [],",
                    "  export: [],",
                    "  esComment: [],",
                    "  jsx: [],",
                    "  math: [],",
                    "  inlineMath: [],",
                    "  tableRow: [\"children\"],",
                    "  listItem: [\"children\"],",
                    "  text: [],",
                    "};",
                    "",
                    "export default visitorKeys;"
                ]
            },
            "unified-plugins": {
                "front-matter.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import parseFrontMatter from \"../../utils/front-matter/parse.js\";",
                        "",
                        "function frontMatter() {",
                        "  const proto = this.Parser.prototype;",
                        "  proto.blockMethods = [\"frontMatter\", ...proto.blockMethods];",
                        "  proto.blockTokenizers.frontMatter = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const parsed = parseFrontMatter(value);",
                        "",
                        "    if (parsed.frontMatter) {",
                        "      return eat(parsed.frontMatter.raw)(parsed.frontMatter);",
                        "    }",
                        "  }",
                        "  tokenizer.onlyAtStart = true;",
                        "}",
                        "",
                        "export default frontMatter;"
                    ]
                },
                "html-to-jsx.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { COMMENT_REGEX } from \"../mdx.js\";",
                        "import { mapAst, INLINE_NODE_WRAPPER_TYPES } from \"../utils.js\";",
                        "",
                        "function htmlToJsx() {",
                        "  return (ast) =>",
                        "    mapAst(ast, (node, _index, [parent]) => {",
                        "      if (",
                        "        node.type !== \"html\" ||",
                        "        // Keep HTML-style comments (legacy MDX)",
                        "        COMMENT_REGEX.test(node.value) ||",
                        "        INLINE_NODE_WRAPPER_TYPES.has(parent.type)",
                        "      ) {",
                        "        return node;",
                        "      }",
                        "      return { ...node, type: \"jsx\" };",
                        "    });",
                        "}",
                        "",
                        "export default htmlToJsx;"
                    ]
                },
                "liquid.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function liquid() {",
                        "  const proto = this.Parser.prototype;",
                        "  const methods = proto.inlineMethods;",
                        "  methods.splice(methods.indexOf(\"text\"), 0, \"liquid\");",
                        "  proto.inlineTokenizers.liquid = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const match = value.match(/^({%.*?%}|{{.*?}})/s);",
                        "",
                        "    if (match) {",
                        "      return eat(match[0])({",
                        "        type: \"liquidNode\",",
                        "        value: match[0],",
                        "      });",
                        "    }",
                        "  }",
                        "  tokenizer.locator = function (value, fromIndex) {",
                        "    return value.indexOf(\"{\", fromIndex);",
                        "  };",
                        "}",
                        "",
                        "export default liquid;"
                    ]
                },
                "wiki-link.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function wikiLink() {",
                        "  const entityType = \"wikiLink\";",
                        "  const wikiLinkRegex = /^\\[\\[(?<linkContents>.+?)]]/s;",
                        "  const proto = this.Parser.prototype;",
                        "  const methods = proto.inlineMethods;",
                        "  methods.splice(methods.indexOf(\"link\"), 0, entityType);",
                        "  proto.inlineTokenizers.wikiLink = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const match = wikiLinkRegex.exec(value);",
                        "",
                        "    if (match) {",
                        "      const linkContents = match.groups.linkContents.trim();",
                        "",
                        "      return eat(match[0])({",
                        "        type: entityType,",
                        "        value: linkContents,",
                        "      });",
                        "    }",
                        "  }",
                        "",
                        "  tokenizer.locator = function (value, fromIndex) {",
                        "    return value.indexOf(\"[\", fromIndex);",
                        "  };",
                        "}",
                        "",
                        "export default wikiLink;"
                    ]
                }
            }
        },
        "language-yaml": {
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { hardline } from \"../document/builders.js\";",
                    "",
                    "function embed(path, options) {",
                    "  const { node } = path;",
                    "",
                    "  // Try to format `.prettierrc`, `.stylelintrc`, and `.lintstagedrc` as `json` first",
                    "  if (",
                    "    node.type === \"root\" &&",
                    "    options.filepath &&",
                    "    /(?:[/\\\\]|^)\\.(?:prettier|stylelint|lintstaged)rc$/.test(options.filepath)",
                    "  ) {",
                    "    return async (textToDoc) => {",
                    "      const doc = await textToDoc(options.originalText, { parser: \"json\" });",
                    "      return doc ? [doc, hardline] : undefined;",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "// Only \"root\" allow print as JSON",
                    "// Use `[]` to prevent `printEmbeddedLanguages` traverse deep",
                    "embed.getVisitorKeys = () => [];",
                    "",
                    "export default embed;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-yaml.js\";",
                    "",
                    "export const printers = {",
                    "  yaml: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-yaml.js\"),",
                    "    parserNames: [\"yaml\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.YAML, (data) => ({",
                    "    parsers: [\"yaml\"],",
                    "    vscodeLanguageIds: [\"yaml\", \"ansible\", \"home-assistant\"],",
                    "    // yarn.lock is not YAML: https://github.com/yarnpkg/yarn/issues/5629",
                    "    filenames: [",
                    "      ...data.filenames.filter((filename) => filename !== \"yarn.lock\"),",
                    "      \".prettierrc\",",
                    "      \".stylelintrc\",",
                    "      \".lintstagedrc\",",
                    "    ],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(node) {",
                    "  return node.position.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.position.end.offset;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  proseWrap: commonOptions.proseWrap,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { parse as parseYaml } from \"yaml-unist-parser/lib/parse.js\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "",
                    "function parse(text) {",
                    "  try {",
                    "    const root = parseYaml(text);",
                    "",
                    "    /**",
                    "     * suppress `comment not printed` error",
                    "     *",
                    "     * comments are handled in printer-yaml.js without using `printComment`",
                    "     * so that it'll always throw errors even if we printed it correctly",
                    "     */",
                    "    delete root.comments;",
                    "",
                    "    return root;",
                    "  } catch (error) {",
                    "    if (error?.position) {",
                    "      throw createError(error.message, {",
                    "        loc: error.position,",
                    "        cause: error,",
                    "      });",
                    "    }",
                    "",
                    "    /* c8 ignore next */",
                    "    throw error;",
                    "  }",
                    "}",
                    "",
                    "export const yaml = {",
                    "  astFormat: \"yaml\",",
                    "  parse,",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function isPragma(text) {",
                    "  return /^\\s*@(?:prettier|format)\\s*$/.test(text);",
                    "}",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(?:prettier|format)\\s*?(?:\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return `# @format\\n\\n${text}`;",
                    "}",
                    "",
                    "export { isPragma, hasPragma, insertPragma };"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { defineShortcut, mapNode } from \"./utils.js\";",
                    "",
                    "function preprocess(ast) {",
                    "  return mapNode(ast, defineShortcuts);",
                    "}",
                    "",
                    "function defineShortcuts(node) {",
                    "  switch (node.type) {",
                    "    case \"document\":",
                    "      defineShortcut(node, \"head\", () => node.children[0]);",
                    "      defineShortcut(node, \"body\", () => node.children[1]);",
                    "      break;",
                    "    case \"documentBody\":",
                    "    case \"sequenceItem\":",
                    "    case \"flowSequenceItem\":",
                    "    case \"mappingKey\":",
                    "    case \"mappingValue\":",
                    "      defineShortcut(node, \"content\", () => node.children[0]);",
                    "      break;",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\":",
                    "      defineShortcut(node, \"key\", () => node.children[0]);",
                    "      defineShortcut(node, \"value\", () => node.children[1]);",
                    "      break;",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "export default preprocess;"
                ]
            },
            "printer-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/** @typedef {import(\"../document/builders.js\").Doc} Doc */",
                    "",
                    "import {",
                    "  breakParent,",
                    "  fill,",
                    "  group,",
                    "  hardline,",
                    "  join,",
                    "  line,",
                    "  lineSuffix,",
                    "} from \"../document/builders.js\";",
                    "import { replaceEndOfLine } from \"../document/utils.js\";",
                    "import isPreviousLineEmpty from \"../utils/is-previous-line-empty.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import { insertPragma, isPragma } from \"./pragma.js\";",
                    "import { locStart } from \"./loc.js\";",
                    "import embed from \"./embed.js\";",
                    "import {",
                    "  getFlowScalarLineContents,",
                    "  getLastDescendantNode,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "  hasPrettierIgnore,",
                    "  isLastDescendantNode,",
                    "  isNode,",
                    "  isInlineNode,",
                    "} from \"./utils.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "import preprocess from \"./print-preprocess.js\";",
                    "import {",
                    "  alignWithSpaces,",
                    "  printNextEmptyLine,",
                    "  shouldPrintEndComments,",
                    "} from \"./print/misc.js\";",
                    "import {",
                    "  printFlowMapping,",
                    "  printFlowSequence,",
                    "} from \"./print/flow-mapping-sequence.js\";",
                    "import printMappingItem from \"./print/mapping-item.js\";",
                    "import printBlock from \"./print/block.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  /** @type {Doc[]} */",
                    "  const parts = [];",
                    "",
                    "  if (node.type !== \"mappingValue\" && hasLeadingComments(node)) {",
                    "    parts.push([join(hardline, path.map(print, \"leadingComments\")), hardline]);",
                    "  }",
                    "",
                    "  const { tag, anchor } = node;",
                    "  if (tag) {",
                    "    parts.push(print(\"tag\"));",
                    "  }",
                    "  if (tag && anchor) {",
                    "    parts.push(\" \");",
                    "  }",
                    "  if (anchor) {",
                    "    parts.push(print(\"anchor\"));",
                    "  }",
                    "",
                    "  /** @type {Doc} */",
                    "  let nextEmptyLine = \"\";",
                    "",
                    "  if (",
                    "    isNode(node, [",
                    "      \"mapping\",",
                    "      \"sequence\",",
                    "      \"comment\",",
                    "      \"directive\",",
                    "      \"mappingItem\",",
                    "      \"sequenceItem\",",
                    "    ]) &&",
                    "    !isLastDescendantNode(path)",
                    "  ) {",
                    "    nextEmptyLine = printNextEmptyLine(path, options.originalText);",
                    "  }",
                    "",
                    "  if (tag || anchor) {",
                    "    if (isNode(node, [\"sequence\", \"mapping\"]) && !hasMiddleComments(node)) {",
                    "      parts.push(hardline);",
                    "    } else {",
                    "      parts.push(\" \");",
                    "    }",
                    "  }",
                    "",
                    "  if (hasMiddleComments(node)) {",
                    "    parts.push([",
                    "      node.middleComments.length === 1 ? \"\" : hardline,",
                    "      join(hardline, path.map(print, \"middleComments\")),",
                    "      hardline,",
                    "    ]);",
                    "  }",
                    "",
                    "  if (hasPrettierIgnore(path)) {",
                    "    parts.push(",
                    "      replaceEndOfLine(",
                    "        options.originalText",
                    "          .slice(node.position.start.offset, node.position.end.offset)",
                    "          .trimEnd()",
                    "      )",
                    "    );",
                    "  } else {",
                    "    parts.push(group(printNode(path, options, print)));",
                    "  }",
                    "",
                    "  if (hasTrailingComment(node) && !isNode(node, [\"document\", \"documentHead\"])) {",
                    "    parts.push(",
                    "      lineSuffix([",
                    "        node.type === \"mappingValue\" && !node.content ? \"\" : \" \",",
                    "        path.parent.type === \"mappingKey\" &&",
                    "        path.getParentNode(2).type === \"mapping\" &&",
                    "        isInlineNode(node)",
                    "          ? \"\"",
                    "          : breakParent,",
                    "        print(\"trailingComment\"),",
                    "      ])",
                    "    );",
                    "  }",
                    "",
                    "  if (shouldPrintEndComments(node)) {",
                    "    parts.push(",
                    "      alignWithSpaces(node.type === \"sequenceItem\" ? 2 : 0, [",
                    "        hardline,",
                    "        join(",
                    "          hardline,",
                    "          path.map(",
                    "            ({ node }) => [",
                    "              isPreviousLineEmpty(options.originalText, locStart(node))",
                    "                ? hardline",
                    "                : \"\",",
                    "              print(),",
                    "            ],",
                    "            \"endComments\"",
                    "          )",
                    "        ),",
                    "      ])",
                    "    );",
                    "  }",
                    "  parts.push(nextEmptyLine);",
                    "  return parts;",
                    "}",
                    "",
                    "function printNode(path, options, print) {",
                    "  const { node } = path;",
                    "  switch (node.type) {",
                    "    case \"root\": {",
                    "      const parts = [];",
                    "      path.each(({ node: document, next: nextDocument, isFirst }) => {",
                    "        if (!isFirst) {",
                    "          parts.push(hardline);",
                    "        }",
                    "        parts.push(print());",
                    "        if (shouldPrintDocumentEndMarker(document, nextDocument)) {",
                    "          parts.push(hardline, \"...\");",
                    "          if (hasTrailingComment(document)) {",
                    "            parts.push(\" \", print(\"trailingComment\"));",
                    "          }",
                    "        } else if (nextDocument && !hasTrailingComment(nextDocument.head)) {",
                    "          parts.push(hardline, \"---\");",
                    "        }",
                    "      }, \"children\");",
                    "",
                    "      const lastDescendantNode = getLastDescendantNode(node);",
                    "      if (",
                    "        !isNode(lastDescendantNode, [\"blockLiteral\", \"blockFolded\"]) ||",
                    "        lastDescendantNode.chomping !== \"keep\"",
                    "      ) {",
                    "        parts.push(hardline);",
                    "      }",
                    "      return parts;",
                    "    }",
                    "    case \"document\": {",
                    "      const parts = [];",
                    "      if (shouldPrintDocumentHeadEndMarker(path, options) === \"head\") {",
                    "        if (node.head.children.length > 0 || node.head.endComments.length > 0) {",
                    "          parts.push(print(\"head\"));",
                    "        }",
                    "",
                    "        if (hasTrailingComment(node.head)) {",
                    "          parts.push([\"---\", \" \", print([\"head\", \"trailingComment\"])]);",
                    "        } else {",
                    "          parts.push(\"---\");",
                    "        }",
                    "      }",
                    "",
                    "      if (shouldPrintDocumentBody(node)) {",
                    "        parts.push(print(\"body\"));",
                    "      }",
                    "",
                    "      return join(hardline, parts);",
                    "    }",
                    "    case \"documentHead\":",
                    "      return join(hardline, [",
                    "        ...path.map(print, \"children\"),",
                    "        ...path.map(print, \"endComments\"),",
                    "      ]);",
                    "    case \"documentBody\": {",
                    "      const { children, endComments } = node;",
                    "      /** @type {Doc} */",
                    "      let separator = \"\";",
                    "      if (children.length > 0 && endComments.length > 0) {",
                    "        const lastDescendantNode = getLastDescendantNode(node);",
                    "        // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)",
                    "        if (isNode(lastDescendantNode, [\"blockFolded\", \"blockLiteral\"])) {",
                    "          // an extra newline for better readability",
                    "          if (lastDescendantNode.chomping !== \"keep\") {",
                    "            separator = [hardline, hardline];",
                    "          }",
                    "        } else {",
                    "          separator = hardline;",
                    "        }",
                    "      }",
                    "",
                    "      return [",
                    "        join(hardline, path.map(print, \"children\")),",
                    "        separator,",
                    "        join(hardline, path.map(print, \"endComments\")),",
                    "      ];",
                    "    }",
                    "    case \"directive\":",
                    "      return [\"%\", join(\" \", [node.name, ...node.parameters])];",
                    "    case \"comment\":",
                    "      return [\"#\", node.value];",
                    "    case \"alias\":",
                    "      return [\"*\", node.value];",
                    "    case \"tag\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"anchor\":",
                    "      return [\"&\", node.value];",
                    "    case \"plain\":",
                    "      return printFlowScalarContent(",
                    "        node.type,",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        ),",
                    "        options",
                    "      );",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\": {",
                    "      const singleQuote = \"'\";",
                    "      const doubleQuote = '\"';",
                    "",
                    "      const raw = options.originalText.slice(",
                    "        node.position.start.offset + 1,",
                    "        node.position.end.offset - 1",
                    "      );",
                    "",
                    "      if (",
                    "        (node.type === \"quoteSingle\" && raw.includes(\"\\\\\")) ||",
                    "        (node.type === \"quoteDouble\" && /\\\\[^\"]/.test(raw))",
                    "      ) {",
                    "        // only quoteDouble can use escape chars",
                    "        // and quoteSingle do not need to escape backslashes",
                    "        const originalQuote =",
                    "          node.type === \"quoteDouble\" ? doubleQuote : singleQuote;",
                    "        return [",
                    "          originalQuote,",
                    "          printFlowScalarContent(node.type, raw, options),",
                    "          originalQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      if (raw.includes(doubleQuote)) {",
                    "        return [",
                    "          singleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteDouble\"",
                    "              ? raw",
                    "                  // double quote needs to be escaped by backslash in quoteDouble",
                    "                  .replaceAll('\\\\\"', doubleQuote)",
                    "                  .replaceAll(\"'\", singleQuote.repeat(2))",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          singleQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      if (raw.includes(singleQuote)) {",
                    "        return [",
                    "          doubleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteSingle\"",
                    "              ? // single quote needs to be escaped by 2 single quotes in quoteSingle",
                    "                raw.replaceAll(\"''\", singleQuote)",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          doubleQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      const quote = options.singleQuote ? singleQuote : doubleQuote;",
                    "      return [quote, printFlowScalarContent(node.type, raw, options), quote];",
                    "    }",
                    "    case \"blockFolded\":",
                    "    case \"blockLiteral\":",
                    "      return printBlock(path, print, options);",
                    "",
                    "    case \"mapping\":",
                    "    case \"sequence\":",
                    "      return join(hardline, path.map(print, \"children\"));",
                    "    case \"sequenceItem\":",
                    "      return [\"- \", alignWithSpaces(2, node.content ? print(\"content\") : \"\")];",
                    "    case \"mappingKey\":",
                    "    case \"mappingValue\":",
                    "      return !node.content ? \"\" : print(\"content\");",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\":",
                    "      return printMappingItem(path, print, options);",
                    "",
                    "    case \"flowMapping\":",
                    "      return printFlowMapping(path, print, options);",
                    "    case \"flowSequence\":",
                    "      return printFlowSequence(path, print, options);",
                    "    case \"flowSequenceItem\":",
                    "      return print(\"content\");",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"YAML\");",
                    "  }",
                    "}",
                    "",
                    "function shouldPrintDocumentBody(document) {",
                    "  return document.body.children.length > 0 || hasEndComments(document.body);",
                    "}",
                    "",
                    "function shouldPrintDocumentEndMarker(document, nextDocument) {",
                    "  return (",
                    "    /**",
                    "     *... # trailingComment",
                    "     */",
                    "    hasTrailingComment(document) ||",
                    "    (nextDocument &&",
                    "      /**",
                    "       * ...",
                    "       * %DIRECTIVE",
                    "       * ---",
                    "       */",
                    "      (nextDocument.head.children.length > 0 ||",
                    "        /**",
                    "         * ...",
                    "         * # endComment",
                    "         * ---",
                    "         */",
                    "        hasEndComments(nextDocument.head)))",
                    "  );",
                    "}",
                    "",
                    "function shouldPrintDocumentHeadEndMarker(path, options) {",
                    "  const document = path.node;",
                    "  if (",
                    "    /**",
                    "     * ---",
                    "     * preserve the first document head end marker",
                    "     */",
                    "    (path.isFirst &&",
                    "      /---(?:\\s|$)/.test(",
                    "        options.originalText.slice(locStart(document), locStart(document) + 4)",
                    "      )) ||",
                    "    /**",
                    "     * %DIRECTIVE",
                    "     * ---",
                    "     */",
                    "    document.head.children.length > 0 ||",
                    "    /**",
                    "     * # end comment",
                    "     * ---",
                    "     */",
                    "    hasEndComments(document.head) ||",
                    "    /**",
                    "     * --- # trailing comment",
                    "     */",
                    "    hasTrailingComment(document.head)",
                    "  ) {",
                    "    return \"head\";",
                    "  }",
                    "",
                    "  const nextDocument = path.next;",
                    "  if (shouldPrintDocumentEndMarker(document, nextDocument)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return nextDocument ? \"root\" : false;",
                    "}",
                    "",
                    "function printFlowScalarContent(nodeType, content, options) {",
                    "  const lineContents = getFlowScalarLineContents(nodeType, content, options);",
                    "  return join(",
                    "    hardline,",
                    "    lineContents.map((lineContentWords) => fill(join(line, lineContentWords)))",
                    "  );",
                    "}",
                    "",
                    "function clean(node, newNode /*, parent */) {",
                    "  if (isNode(newNode)) {",
                    "    delete newNode.position;",
                    "    switch (newNode.type) {",
                    "      case \"comment\":",
                    "        // insert pragma",
                    "        if (isPragma(newNode.value)) {",
                    "          return null;",
                    "        }",
                    "        break;",
                    "      case \"quoteDouble\":",
                    "      case \"quoteSingle\":",
                    "        newNode.type = \"quote\";",
                    "        break;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "const printer = {",
                    "  preprocess,",
                    "  embed,",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  insertPragma,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "",
                    "/**",
                    " * @param {any} value",
                    " * @param {string[]=} types",
                    " */",
                    "function isNode(value, types) {",
                    "  return (",
                    "    typeof value?.type === \"string\" && (!types || types.includes(value.type))",
                    "  );",
                    "}",
                    "",
                    "function mapNode(node, callback, parent) {",
                    "  return callback(",
                    "    \"children\" in node",
                    "      ? {",
                    "          ...node,",
                    "          children: node.children.map((childNode) =>",
                    "            mapNode(childNode, callback, node)",
                    "          ),",
                    "        }",
                    "      : node,",
                    "    parent",
                    "  );",
                    "}",
                    "",
                    "function defineShortcut(x, key, getter) {",
                    "  Object.defineProperty(x, key, {",
                    "    get: getter,",
                    "    enumerable: false,",
                    "  });",
                    "}",
                    "",
                    "function isNextLineEmpty(node, text) {",
                    "  let newlineCount = 0;",
                    "  const textLength = text.length;",
                    "  for (let i = node.position.end.offset - 1; i < textLength; i++) {",
                    "    const char = text[i];",
                    "",
                    "    if (char === \"\\n\") {",
                    "      newlineCount++;",
                    "    }",
                    "",
                    "    if (newlineCount === 1 && /\\S/.test(char)) {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (newlineCount === 2) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isLastDescendantNode(path) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"tag\":",
                    "    case \"anchor\":",
                    "    case \"comment\":",
                    "      return false;",
                    "  }",
                    "",
                    "  const pathStackLength = path.stack.length;",
                    "",
                    "  for (let i = 1; i < pathStackLength; i++) {",
                    "    const item = path.stack[i];",
                    "    const parentItem = path.stack[i - 1];",
                    "",
                    "    if (",
                    "      Array.isArray(parentItem) &&",
                    "      typeof item === \"number\" &&",
                    "      item !== parentItem.length - 1",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function getLastDescendantNode(node) {",
                    "  return isNonEmptyArray(node.children)",
                    "    ? getLastDescendantNode(node.children.at(-1))",
                    "    : node;",
                    "}",
                    "",
                    "function isPrettierIgnore(comment) {",
                    "  return comment.value.trim() === \"prettier-ignore\";",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const { node } = path;",
                    "",
                    "  if (node.type === \"documentBody\") {",
                    "    const documentHead = path.parent.head;",
                    "    return (",
                    "      hasEndComments(documentHead) &&",
                    "      isPrettierIgnore(documentHead.endComments.at(-1))",
                    "    );",
                    "  }",
                    "",
                    "  return (",
                    "    hasLeadingComments(node) && isPrettierIgnore(node.leadingComments.at(-1))",
                    "  );",
                    "}",
                    "",
                    "function isEmptyNode(node) {",
                    "  return !isNonEmptyArray(node.children) && !hasComments(node);",
                    "}",
                    "",
                    "function hasComments(node) {",
                    "  return (",
                    "    hasLeadingComments(node) ||",
                    "    hasMiddleComments(node) ||",
                    "    hasIndicatorComment(node) ||",
                    "    hasTrailingComment(node) ||",
                    "    hasEndComments(node)",
                    "  );",
                    "}",
                    "",
                    "function hasLeadingComments(node) {",
                    "  return isNonEmptyArray(node?.leadingComments);",
                    "}",
                    "",
                    "function hasMiddleComments(node) {",
                    "  return isNonEmptyArray(node?.middleComments);",
                    "}",
                    "",
                    "function hasIndicatorComment(node) {",
                    "  return node?.indicatorComment;",
                    "}",
                    "",
                    "function hasTrailingComment(node) {",
                    "  return node?.trailingComment;",
                    "}",
                    "",
                    "function hasEndComments(node) {",
                    "  return isNonEmptyArray(node?.endComments);",
                    "}",
                    "",
                    "/**",
                    " * \" a   b c   d e   f \" -> [\" a   b\", \"c   d\", \"e   f \"]",
                    " */",
                    "function splitWithSingleSpace(text) {",
                    "  const parts = [];",
                    "",
                    "  let lastPart;",
                    "  for (const part of text.split(/( +)/)) {",
                    "    if (part !== \" \") {",
                    "      if (lastPart === \" \") {",
                    "        parts.push(part);",
                    "      } else {",
                    "        parts.push((parts.pop() || \"\") + part);",
                    "      }",
                    "    } else if (lastPart === undefined) {",
                    "      parts.unshift(\"\");",
                    "    }",
                    "",
                    "    lastPart = part;",
                    "  }",
                    "",
                    "  /* c8 ignore next 3 */",
                    "  if (lastPart === \" \") {",
                    "    parts.push((parts.pop() || \"\") + \" \");",
                    "  }",
                    "",
                    "  if (parts[0] === \"\") {",
                    "    parts.shift();",
                    "    parts.unshift(\" \" + (parts.shift() || \"\"));",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function getFlowScalarLineContents(nodeType, content, options) {",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent, index, lineContents) =>",
                    "      index === 0 && index === lineContents.length - 1",
                    "        ? lineContent",
                    "        : index !== 0 && index !== lineContents.length - 1",
                    "        ? lineContent.trim()",
                    "        : index === 0",
                    "        ? lineContent.trimEnd()",
                    "        : lineContent.trimStart()",
                    "    );",
                    "",
                    "  if (options.proseWrap === \"preserve\") {",
                    "    return rawLineContents.map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : [lineContent]",
                    "    );",
                    "  }",
                    "",
                    "  return rawLineContents",
                    "    .map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "    )",
                    "    .reduce(",
                    "      (reduced, lineContentWords, index) =>",
                    "        index !== 0 &&",
                    "        rawLineContents[index - 1].length > 0 &&",
                    "        lineContentWords.length > 0 &&",
                    "        !(",
                    "          // trailing backslash in quoteDouble should be preserved",
                    "          (nodeType === \"quoteDouble\" && reduced.at(-1).at(-1).endsWith(\"\\\\\"))",
                    "        )",
                    "          ? [...reduced.slice(0, -1), [...reduced.at(-1), ...lineContentWords]]",
                    "          : [...reduced, lineContentWords],",
                    "      []",
                    "    )",
                    "    .map((lineContentWords) =>",
                    "      options.proseWrap === \"never\"",
                    "        ? [lineContentWords.join(\" \")]",
                    "        : lineContentWords",
                    "    );",
                    "}",
                    "",
                    "function getBlockValueLineContents(",
                    "  node,",
                    "  { parentIndent, isLastDescendant, options }",
                    ") {",
                    "  const content =",
                    "    node.position.start.line === node.position.end.line",
                    "      ? \"\"",
                    "      : options.originalText",
                    "          .slice(node.position.start.offset, node.position.end.offset)",
                    "          // exclude open line `>` or `|`",
                    "          .match(/^[^\\n]*\\n(.*)$/s)[1];",
                    "",
                    "  let leadingSpaceCount;",
                    "  if (node.indent === null) {",
                    "    const matches = content.match(/^(?<leadingSpace> *)[^\\n\\r ]/m);",
                    "    leadingSpaceCount = matches",
                    "      ? matches.groups.leadingSpace.length",
                    "      : Number.POSITIVE_INFINITY;",
                    "  } else {",
                    "    leadingSpaceCount = node.indent - 1 + parentIndent;",
                    "  }",
                    "",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent) => lineContent.slice(leadingSpaceCount));",
                    "",
                    "  if (options.proseWrap === \"preserve\" || node.type === \"blockLiteral\") {",
                    "    return removeUnnecessaryTrailingNewlines(",
                    "      rawLineContents.map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : [lineContent]",
                    "      )",
                    "    );",
                    "  }",
                    "",
                    "  return removeUnnecessaryTrailingNewlines(",
                    "    rawLineContents",
                    "      .map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "      )",
                    "      .reduce(",
                    "        (reduced, lineContentWords, index) =>",
                    "          index !== 0 &&",
                    "          rawLineContents[index - 1].length > 0 &&",
                    "          lineContentWords.length > 0 &&",
                    "          !/^\\s/.test(lineContentWords[0]) &&",
                    "          !/^\\s|\\s$/.test(reduced.at(-1))",
                    "            ? [",
                    "                ...reduced.slice(0, -1),",
                    "                [...reduced.at(-1), ...lineContentWords],",
                    "              ]",
                    "            : [...reduced, lineContentWords],",
                    "        []",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        lineContentWords.reduce(",
                    "          (reduced, word) =>",
                    "            // disallow trailing spaces",
                    "            reduced.length > 0 && /\\s$/.test(reduced.at(-1))",
                    "              ? [...reduced.slice(0, -1), reduced.at(-1) + \" \" + word]",
                    "              : [...reduced, word],",
                    "          []",
                    "        )",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        options.proseWrap === \"never\"",
                    "          ? [lineContentWords.join(\" \")]",
                    "          : lineContentWords",
                    "      )",
                    "  );",
                    "",
                    "  function removeUnnecessaryTrailingNewlines(lineContents) {",
                    "    if (node.chomping === \"keep\") {",
                    "      return lineContents.at(-1).length === 0",
                    "        ? lineContents.slice(0, -1)",
                    "        : lineContents;",
                    "    }",
                    "",
                    "    let trailingNewlineCount = 0;",
                    "    for (let i = lineContents.length - 1; i >= 0; i--) {",
                    "      if (lineContents[i].length === 0) {",
                    "        trailingNewlineCount++;",
                    "      } else {",
                    "        break;",
                    "      }",
                    "    }",
                    "",
                    "    return trailingNewlineCount === 0",
                    "      ? lineContents",
                    "      : trailingNewlineCount >= 2 && !isLastDescendant",
                    "      ? // next empty line",
                    "        lineContents.slice(0, -(trailingNewlineCount - 1))",
                    "      : lineContents.slice(0, -trailingNewlineCount);",
                    "  }",
                    "}",
                    "",
                    "function isInlineNode(node) {",
                    "  /* c8 ignore next 3 */",
                    "  if (!node) {",
                    "    return true;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"plain\":",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\":",
                    "    case \"alias\":",
                    "    case \"flowMapping\":",
                    "    case \"flowSequence\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "export {",
                    "  isNode,",
                    "  isEmptyNode,",
                    "  isInlineNode,",
                    "  mapNode,",
                    "  defineShortcut,",
                    "  isNextLineEmpty,",
                    "  isLastDescendantNode,",
                    "  getBlockValueLineContents,",
                    "  getFlowScalarLineContents,",
                    "  getLastDescendantNode,",
                    "  hasPrettierIgnore,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasIndicatorComment,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "};"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = Object.fromEntries(",
                    "  Object.entries({",
                    "    root: [\"children\"],",
                    "    document: [\"head\", \"body\", \"children\"],",
                    "    documentHead: [\"children\"],",
                    "    documentBody: [\"children\"],",
                    "    directive: [],",
                    "    alias: [],",
                    "    blockLiteral: [],",
                    "    blockFolded: [\"children\"],",
                    "    plain: [\"children\"],",
                    "    quoteSingle: [],",
                    "    quoteDouble: [],",
                    "    mapping: [\"children\"],",
                    "    mappingItem: [\"key\", \"value\", \"children\"],",
                    "    mappingKey: [\"content\", \"children\"],",
                    "    mappingValue: [\"content\", \"children\"],",
                    "    sequence: [\"children\"],",
                    "    sequenceItem: [\"content\", \"children\"],",
                    "    flowMapping: [\"children\"],",
                    "    flowMappingItem: [\"key\", \"value\", \"children\"],",
                    "    flowSequence: [\"children\"],",
                    "    flowSequenceItem: [\"content\", \"children\"],",
                    "    comment: [],",
                    "    tag: [],",
                    "    anchor: [],",
                    "  }).map(([type, keys]) => [",
                    "    type,",
                    "    [",
                    "      ...keys,",
                    "      \"anchor\",",
                    "      \"tag\",",
                    "      \"indicatorComment\",",
                    "      \"leadingComments\",",
                    "      \"middleComments\",",
                    "      \"trailingComment\",",
                    "      \"endComments\",",
                    "    ],",
                    "  ])",
                    ");",
                    "",
                    "export default visitorKeys;"
                ]
            },
            "print": {
                "block.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "import {",
                        "  dedent,",
                        "  dedentToRoot,",
                        "  fill,",
                        "  hardline,",
                        "  join,",
                        "  line,",
                        "  literalline,",
                        "  markAsRoot,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  getBlockValueLineContents,",
                        "  hasIndicatorComment,",
                        "  isLastDescendantNode,",
                        "} from \"../utils.js\";",
                        "import { alignWithSpaces } from \"./misc.js\";",
                        "",
                        "function printBlock(path, print, options) {",
                        "  const { node } = path;",
                        "  const parentIndent = path.ancestors.filter(",
                        "    (node) => node.type === \"sequence\" || node.type === \"mapping\"",
                        "  ).length;",
                        "  const isLastDescendant = isLastDescendantNode(path);",
                        "  /** @type {Doc[]} */",
                        "  const parts = [node.type === \"blockFolded\" ? \">\" : \"|\"];",
                        "  if (node.indent !== null) {",
                        "    parts.push(node.indent.toString());",
                        "  }",
                        "",
                        "  if (node.chomping !== \"clip\") {",
                        "    parts.push(node.chomping === \"keep\" ? \"+\" : \"-\");",
                        "  }",
                        "",
                        "  if (hasIndicatorComment(node)) {",
                        "    parts.push(\" \", print(\"indicatorComment\"));",
                        "  }",
                        "",
                        "  const lineContents = getBlockValueLineContents(node, {",
                        "    parentIndent,",
                        "    isLastDescendant,",
                        "    options,",
                        "  });",
                        "  /** @type {Doc[]} */",
                        "  const contentsParts = [];",
                        "  for (const [index, lineWords] of lineContents.entries()) {",
                        "    if (index === 0) {",
                        "      contentsParts.push(hardline);",
                        "    }",
                        "    contentsParts.push(fill(join(line, lineWords)));",
                        "    if (index !== lineContents.length - 1) {",
                        "      contentsParts.push(",
                        "        lineWords.length === 0 ? hardline : markAsRoot(literalline)",
                        "      );",
                        "    } else if (node.chomping === \"keep\" && isLastDescendant) {",
                        "      contentsParts.push(",
                        "        dedentToRoot(lineWords.length === 0 ? hardline : literalline)",
                        "      );",
                        "    }",
                        "  }",
                        "  if (node.indent === null) {",
                        "    parts.push(dedent(alignWithSpaces(options.tabWidth, contentsParts)));",
                        "  } else {",
                        "    parts.push(",
                        "      dedentToRoot(",
                        "        alignWithSpaces(node.indent - 1 + parentIndent, contentsParts)",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export default printBlock;"
                    ]
                },
                "flow-mapping-sequence.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  ifBreak,",
                        "  line,",
                        "  softline,",
                        "  hardline,",
                        "  join,",
                        "} from \"../../document/builders.js\";",
                        "import { isEmptyNode, hasEndComments } from \"../utils.js\";",
                        "import { printNextEmptyLine, alignWithSpaces } from \"./misc.js\";",
                        "",
                        "function printFlowMapping(path, print, options) {",
                        "  const { node } = path;",
                        "  const isMapping = node.type === \"flowMapping\";",
                        "  const openMarker = isMapping ? \"{\" : \"[\";",
                        "  const closeMarker = isMapping ? \"}\" : \"]\";",
                        "",
                        "  /** @type {softline | line} */",
                        "  let bracketSpacing = softline;",
                        "  if (isMapping && node.children.length > 0 && options.bracketSpacing) {",
                        "    bracketSpacing = line;",
                        "  }",
                        "  const lastItem = node.children.at(-1);",
                        "  const isLastItemEmptyMappingItem =",
                        "    lastItem?.type === \"flowMappingItem\" &&",
                        "    isEmptyNode(lastItem.key) &&",
                        "    isEmptyNode(lastItem.value);",
                        "",
                        "  return [",
                        "    openMarker,",
                        "    alignWithSpaces(options.tabWidth, [",
                        "      bracketSpacing,",
                        "      printChildren(path, print, options),",
                        "      options.trailingComma === \"none\" ? \"\" : ifBreak(\",\"),",
                        "      hasEndComments(node)",
                        "        ? [hardline, join(hardline, path.map(print, \"endComments\"))]",
                        "        : \"\",",
                        "    ]),",
                        "    isLastItemEmptyMappingItem ? \"\" : bracketSpacing,",
                        "    closeMarker,",
                        "  ];",
                        "}",
                        "",
                        "function printChildren(path, print, options) {",
                        "  return path.map(",
                        "    ({ isLast, node, next }) => [",
                        "      print(),",
                        "      isLast",
                        "        ? \"\"",
                        "        : [",
                        "            \",\",",
                        "            line,",
                        "            node.position.start.line !== next.position.start.line",
                        "              ? printNextEmptyLine(path, options.originalText)",
                        "              : \"\",",
                        "          ],",
                        "    ],",
                        "    \"children\"",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  printFlowMapping,",
                        "  // Alias",
                        "  printFlowMapping as printFlowSequence,",
                        "};"
                    ]
                },
                "mapping-item.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "import {",
                        "  conditionalGroup,",
                        "  group,",
                        "  hardline,",
                        "  ifBreak,",
                        "  line,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  hasLeadingComments,",
                        "  hasMiddleComments,",
                        "  hasTrailingComment,",
                        "  hasEndComments,",
                        "  isNode,",
                        "  isEmptyNode,",
                        "  isInlineNode,",
                        "} from \"../utils.js\";",
                        "import { alignWithSpaces } from \"./misc.js\";",
                        "",
                        "function printMappingItem(path, print, options) {",
                        "  const { node, parent } = path;",
                        "  const { key, value } = node;",
                        "",
                        "  const isEmptyMappingKey = isEmptyNode(key);",
                        "  const isEmptyMappingValue = isEmptyNode(value);",
                        "",
                        "  if (isEmptyMappingKey && isEmptyMappingValue) {",
                        "    return \": \";",
                        "  }",
                        "",
                        "  const printedKey = print(\"key\");",
                        "  const spaceBeforeColon = needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\";",
                        "",
                        "  if (isEmptyMappingValue) {",
                        "    if (node.type === \"flowMappingItem\" && parent.type === \"flowMapping\") {",
                        "      return printedKey;",
                        "    }",
                        "",
                        "    if (",
                        "      node.type === \"mappingItem\" &&",
                        "      isAbsolutelyPrintedAsSingleLineNode(key.content, options) &&",
                        "      !hasTrailingComment(key.content) &&",
                        "      parent.tag?.value !== \"tag:yaml.org,2002:set\"",
                        "    ) {",
                        "      return [printedKey, spaceBeforeColon, \":\"];",
                        "    }",
                        "",
                        "    return [\"? \", alignWithSpaces(2, printedKey)];",
                        "  }",
                        "",
                        "  const printedValue = print(\"value\");",
                        "  if (isEmptyMappingKey) {",
                        "    return [\": \", alignWithSpaces(2, printedValue)];",
                        "  }",
                        "",
                        "  // force explicit Key",
                        "  if (hasLeadingComments(value) || !isInlineNode(key.content)) {",
                        "    return [",
                        "      \"? \",",
                        "      alignWithSpaces(2, printedKey),",
                        "      hardline,",
                        "      ...path.map(() => [print(), hardline], \"value\", \"leadingComments\"),",
                        "      \": \",",
                        "      alignWithSpaces(2, printedValue),",
                        "    ];",
                        "  }",
                        "",
                        "  // force singleline",
                        "  if (",
                        "    isSingleLineNode(key.content) &&",
                        "    !hasLeadingComments(key.content) &&",
                        "    !hasMiddleComments(key.content) &&",
                        "    !hasTrailingComment(key.content) &&",
                        "    !hasEndComments(key) &&",
                        "    !hasLeadingComments(value.content) &&",
                        "    !hasMiddleComments(value.content) &&",
                        "    !hasEndComments(value) &&",
                        "    isAbsolutelyPrintedAsSingleLineNode(value.content, options)",
                        "  ) {",
                        "    return [printedKey, spaceBeforeColon, \": \", printedValue];",
                        "  }",
                        "",
                        "  const groupId = Symbol(\"mappingKey\");",
                        "  const groupedKey = group([",
                        "    ifBreak(\"? \"),",
                        "    group(alignWithSpaces(2, printedKey), { id: groupId }),",
                        "  ]);",
                        "",
                        "  // Construct both explicit and implicit mapping values.",
                        "  const explicitMappingValue = [",
                        "    hardline,",
                        "    \": \",",
                        "    alignWithSpaces(2, printedValue),",
                        "  ];",
                        "  /** @type {Doc[]} */",
                        "  // In the implicit case, it's convenient to treat everything from the key's colon",
                        "  // as part of the mapping value",
                        "  const implicitMappingValueParts = [spaceBeforeColon, \":\"];",
                        "  if (",
                        "    hasLeadingComments(value.content) ||",
                        "    (hasEndComments(value) &&",
                        "      value.content &&",
                        "      !isNode(value.content, [\"mapping\", \"sequence\"])) ||",
                        "    (parent.type === \"mapping\" &&",
                        "      hasTrailingComment(key.content) &&",
                        "      isInlineNode(value.content)) ||",
                        "    (isNode(value.content, [\"mapping\", \"sequence\"]) &&",
                        "      value.content.tag === null &&",
                        "      value.content.anchor === null)",
                        "  ) {",
                        "    implicitMappingValueParts.push(hardline);",
                        "  } else if (value.content) {",
                        "    implicitMappingValueParts.push(line);",
                        "  }",
                        "  implicitMappingValueParts.push(printedValue);",
                        "  const implicitMappingValue = alignWithSpaces(",
                        "    options.tabWidth,",
                        "    implicitMappingValueParts",
                        "  );",
                        "",
                        "  // If a key is definitely single-line, forcibly use implicit style to avoid edge cases (very long",
                        "  // keys) that would otherwise trigger explicit style as if it was multiline.",
                        "  // In those cases, explicit style makes the line even longer and causes confusion.",
                        "  if (",
                        "    isAbsolutelyPrintedAsSingleLineNode(key.content, options) &&",
                        "    !hasLeadingComments(key.content) &&",
                        "    !hasMiddleComments(key.content) &&",
                        "    !hasEndComments(key)",
                        "  ) {",
                        "    return conditionalGroup([[printedKey, implicitMappingValue]]);",
                        "  }",
                        "",
                        "  // Use explicit mapping syntax if the key breaks, implicit otherwise",
                        "  return conditionalGroup([",
                        "    [",
                        "      groupedKey,",
                        "      ifBreak(explicitMappingValue, implicitMappingValue, { groupId }),",
                        "    ],",
                        "  ]);",
                        "}",
                        "",
                        "function isAbsolutelyPrintedAsSingleLineNode(node, options) {",
                        "  if (!node) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"plain\":",
                        "    case \"quoteSingle\":",
                        "    case \"quoteDouble\":",
                        "      break;",
                        "    case \"alias\":",
                        "      return true;",
                        "",
                        "    default:",
                        "      return false;",
                        "  }",
                        "",
                        "  if (options.proseWrap === \"preserve\") {",
                        "    return node.position.start.line === node.position.end.line;",
                        "  }",
                        "",
                        "  if (",
                        "    // backslash-newline",
                        "    /\\\\$/m.test(",
                        "      options.originalText.slice(",
                        "        node.position.start.offset,",
                        "        node.position.end.offset",
                        "      )",
                        "    )",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  switch (options.proseWrap) {",
                        "    case \"never\":",
                        "      return !node.value.includes(\"\\n\");",
                        "    case \"always\":",
                        "      return !/[\\n ]/.test(node.value);",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "function needsSpaceInFrontOfMappingValue(node) {",
                        "  return node.key.content?.type === \"alias\";",
                        "}",
                        "",
                        "function isSingleLineNode(node) {",
                        "  /* c8 ignore next 3 */",
                        "  if (!node) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"plain\":",
                        "    case \"quoteDouble\":",
                        "    case \"quoteSingle\":",
                        "      return node.position.start.line === node.position.end.line;",
                        "    case \"alias\":",
                        "      return true;",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "export default printMappingItem;"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { softline, align } from \"../../document/builders.js\";",
                        "import { hasEndComments, isNextLineEmpty, isNode } from \"../utils.js\";",
                        "",
                        "const printedEmptyLineCache = new WeakMap();",
                        "function printNextEmptyLine(path, originalText) {",
                        "  const { node, root } = path;",
                        "",
                        "  let isNextEmptyLinePrintedSet;",
                        "  if (printedEmptyLineCache.has(root)) {",
                        "    isNextEmptyLinePrintedSet = printedEmptyLineCache.get(root);",
                        "  } else {",
                        "    isNextEmptyLinePrintedSet = new Set();",
                        "    printedEmptyLineCache.set(root, isNextEmptyLinePrintedSet);",
                        "  }",
                        "",
                        "  if (!isNextEmptyLinePrintedSet.has(node.position.end.line)) {",
                        "    isNextEmptyLinePrintedSet.add(node.position.end.line);",
                        "    if (",
                        "      isNextLineEmpty(node, originalText) &&",
                        "      !shouldPrintEndComments(path.parent)",
                        "    ) {",
                        "      return softline;",
                        "    }",
                        "  }",
                        "",
                        "  return \"\";",
                        "}",
                        "",
                        "function shouldPrintEndComments(node) {",
                        "  return (",
                        "    hasEndComments(node) &&",
                        "    !isNode(node, [",
                        "      \"documentHead\",",
                        "      \"documentBody\",",
                        "      \"flowMapping\",",
                        "      \"flowSequence\",",
                        "    ])",
                        "  );",
                        "}",
                        "",
                        "function alignWithSpaces(width, doc) {",
                        "  return align(\" \".repeat(width), doc);",
                        "}",
                        "",
                        "export { alignWithSpaces, shouldPrintEndComments, printNextEmptyLine };"
                    ]
                }
            }
        },
        "main": {
            "ast-to-doc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import AstPath from \"../common/ast-path.js\";",
                    "import { cursor } from \"../document/builders.js\";",
                    "import { inheritLabel } from \"../document/utils.js\";",
                    "import { attachComments } from \"./comments/attach.js\";",
                    "import { printComments, ensureAllCommentsPrinted } from \"./comments/print.js\";",
                    "import { printEmbeddedLanguages } from \"./multiparser.js\";",
                    "import createPrintPreCheckFunction from \"./create-print-pre-check-function.js\";",
                    "import printIgnored from \"./print-ignored.js\";",
                    "",
                    "/**",
                    " * Takes an abstract syntax tree (AST) and recursively converts it to a",
                    " * document (series of printing primitives).",
                    " *",
                    " * This is done by descending down the AST recursively. The recursion",
                    " * involves two functions that call each other:",
                    " *",
                    " * 1. mainPrint(), which is defined as an inner function here.",
                    " *    It basically takes care of node caching.",
                    " * 2. callPluginPrintFunction(), which checks for some options, and",
                    " *    ultimately calls the print() function provided by the plugin.",
                    " *",
                    " * The plugin function will call mainPrint() again for child nodes",
                    " * of the current node. mainPrint() will do its housekeeping, then call",
                    " * the plugin function again, and so on.",
                    " *",
                    " * All the while, these functions pass a \"path\" variable around, which",
                    " * is a stack-like data structure (AstPath) that maintains the current",
                    " * state of the recursion. It is called \"path\", because it represents",
                    " * the path to the current node through the Abstract Syntax Tree.",
                    " */",
                    "async function printAstToDoc(ast, options) {",
                    "  ({ ast } = await prepareToPrint(ast, options));",
                    "",
                    "  const cache = new Map();",
                    "  const path = new AstPath(ast);",
                    "",
                    "  const ensurePrintingNode = createPrintPreCheckFunction(options);",
                    "  const embeds = new Map();",
                    "",
                    "  await printEmbeddedLanguages(path, mainPrint, options, printAstToDoc, embeds);",
                    "",
                    "  // Only the root call of the print method is awaited.",
                    "  // This is done to make things simpler for plugins that don't use recursive printing.",
                    "  const doc = await callPluginPrintFunction(",
                    "    path,",
                    "    options,",
                    "    mainPrint,",
                    "    undefined,",
                    "    embeds",
                    "  );",
                    "",
                    "  ensureAllCommentsPrinted(options);",
                    "",
                    "  return doc;",
                    "",
                    "  function mainPrint(selector, args) {",
                    "    if (selector === undefined || selector === path) {",
                    "      return mainPrintInternal(args);",
                    "    }",
                    "",
                    "    if (Array.isArray(selector)) {",
                    "      return path.call(() => mainPrintInternal(args), ...selector);",
                    "    }",
                    "",
                    "    return path.call(() => mainPrintInternal(args), selector);",
                    "  }",
                    "",
                    "  function mainPrintInternal(args) {",
                    "    ensurePrintingNode(path);",
                    "",
                    "    const value = path.node;",
                    "",
                    "    if (value === undefined || value === null) {",
                    "      return \"\";",
                    "    }",
                    "",
                    "    const shouldCache =",
                    "      value && typeof value === \"object\" && args === undefined;",
                    "",
                    "    if (shouldCache && cache.has(value)) {",
                    "      return cache.get(value);",
                    "    }",
                    "",
                    "    const doc = callPluginPrintFunction(path, options, mainPrint, args, embeds);",
                    "",
                    "    if (shouldCache) {",
                    "      cache.set(value, doc);",
                    "    }",
                    "",
                    "    return doc;",
                    "  }",
                    "}",
                    "",
                    "function callPluginPrintFunction(path, options, printPath, args, embeds) {",
                    "  const { node } = path;",
                    "  const { printer } = options;",
                    "",
                    "  let doc;",
                    "",
                    "  // Escape hatch",
                    "  if (printer.hasPrettierIgnore?.(path)) {",
                    "    doc = printIgnored(path, options);",
                    "  } else if (embeds.has(node)) {",
                    "    doc = embeds.get(node);",
                    "  } else {",
                    "    doc = printer.print(path, options, printPath, args);",
                    "  }",
                    "",
                    "  // We let JSXElement print its comments itself because it adds () around",
                    "  // UnionTypeAnnotation has to align the child without the comments",
                    "  if (",
                    "    printer.printComment &&",
                    "    (!printer.willPrintOwnComments ||",
                    "      !printer.willPrintOwnComments(path, options))",
                    "  ) {",
                    "    // printComments will call the plugin print function and check for",
                    "    // comments to print",
                    "    doc = printComments(path, doc, options);",
                    "  }",
                    "",
                    "  if (node === options.cursorNode) {",
                    "    doc = inheritLabel(doc, (doc) => [cursor, doc, cursor]);",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "async function prepareToPrint(ast, options) {",
                    "  const comments = ast.comments ?? [];",
                    "  options[Symbol.for(\"comments\")] = comments;",
                    "  options[Symbol.for(\"tokens\")] = ast.tokens ?? [];",
                    "  // For JS printer to ignore attached comments",
                    "  options[Symbol.for(\"printedComments\")] = new Set();",
                    "",
                    "  attachComments(ast, options);",
                    "",
                    "  const {",
                    "    printer: { preprocess },",
                    "  } = options;",
                    "",
                    "  ast = preprocess ? await preprocess(ast, options) : ast;",
                    "",
                    "  return { ast, comments };",
                    "}",
                    "",
                    "export { printAstToDoc, prepareToPrint };"
                ]
            },
            "core-options.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { outdent } from \"outdent\";",
                    "import {",
                    "  CATEGORY_CONFIG,",
                    "  CATEGORY_EDITOR,",
                    "  CATEGORY_OTHER,",
                    "  CATEGORY_GLOBAL,",
                    "  CATEGORY_SPECIAL,",
                    "} from \"./option-categories.js\";",
                    "",
                    "/**",
                    " * @typedef {Object} OptionInfo",
                    " * @property {string} category",
                    " * @property {'int' | 'boolean' | 'choice' | 'path' | 'string' | 'flag'} type",
                    " * @property {boolean} [array] - indicate it's an array of the specified type",
                    " * @property {OptionValueInfo} [default]",
                    " * @property {OptionRangeInfo} [range] - for type int",
                    " * @property {string} description",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionRedirectInfo} [redirect] - redirect deprecated option",
                    " * @property {(value: any) => boolean} [exception]",
                    " * @property {OptionChoiceInfo[]} [choices] - for type choice",
                    " * @property {string} [cliName]",
                    " * @property {string} [cliCategory]",
                    " * @property {string} [cliDescription]",
                    " *",
                    " * @typedef {number | boolean | string | []} OptionValue",
                    " * @typedef {OptionValue | [{ value: OptionValue }]} OptionValueInfo",
                    " *",
                    " * @typedef {Object} OptionRedirectInfo",
                    " * @property {string} option",
                    " * @property {OptionValue} value",
                    " *",
                    " * @typedef {Object} OptionRangeInfo",
                    " * @property {number} start - recommended range start",
                    " * @property {number} end - recommended range end",
                    " * @property {number} step - recommended range step",
                    " *",
                    " * @typedef {Object} OptionChoiceInfo",
                    " * @property {boolean | string} value - boolean for the option that is originally boolean type",
                    " * @property {string} description",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionValueInfo} [redirect] - redirect deprecated value",
                    " */",
                    "",
                    "/** @type {{ [name: string]: OptionInfo }} */",
                    "const options = {",
                    "  cursorOffset: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: -1,",
                    "    range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Print (to stderr) where a cursor at the given position would move to after formatting.",
                    "      This option cannot be used with --range-start and --range-end.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  endOfLine: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: \"lf\",",
                    "    description: \"Which end of line characters to apply.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"lf\",",
                    "        description:",
                    "          \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\",",
                    "      },",
                    "      {",
                    "        value: \"crlf\",",
                    "        description:",
                    "          \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\",",
                    "      },",
                    "      {",
                    "        value: \"cr\",",
                    "        description: \"Carriage Return character only (\\\\r), used very rarely\",",
                    "      },",
                    "      {",
                    "        value: \"auto\",",
                    "        description: outdent`",
                    "          Maintain existing",
                    "          (mixed values within one file are normalised by looking at what's used after the first line)",
                    "        `,",
                    "      },",
                    "    ],",
                    "  },",
                    "  filepath: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"path\",",
                    "    description:",
                    "      \"Specify the input filepath. This will be used to do parser inference.\",",
                    "    cliName: \"stdin-filepath\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "    cliDescription: \"Path to the file to pretend that stdin comes from.\",",
                    "  },",
                    "  insertPragma: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Insert @format pragma into file's first docblock comment.\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  parser: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: undefined,",
                    "    description: \"Which parser to use.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"function\",",
                    "    choices: [",
                    "      { value: \"flow\", description: \"Flow\" },",
                    "      { value: \"babel\", description: \"JavaScript\" },",
                    "      { value: \"babel-flow\", description: \"Flow\" },",
                    "      { value: \"babel-ts\", description: \"TypeScript\" },",
                    "      { value: \"typescript\", description: \"TypeScript\" },",
                    "      { value: \"acorn\", description: \"JavaScript\" },",
                    "      { value: \"espree\", description: \"JavaScript\" },",
                    "      { value: \"meriyah\", description: \"JavaScript\" },",
                    "      { value: \"css\", description: \"CSS\" },",
                    "      { value: \"less\", description: \"Less\" },",
                    "      { value: \"scss\", description: \"SCSS\" },",
                    "      { value: \"json\", description: \"JSON\" },",
                    "      { value: \"json5\", description: \"JSON5\" },",
                    "      { value: \"json-stringify\", description: \"JSON.stringify\" },",
                    "      { value: \"graphql\", description: \"GraphQL\" },",
                    "      { value: \"markdown\", description: \"Markdown\" },",
                    "      { value: \"mdx\", description: \"MDX\" },",
                    "      { value: \"vue\", description: \"Vue\" },",
                    "      { value: \"yaml\", description: \"YAML\" },",
                    "      { value: \"glimmer\", description: \"Ember / Handlebars\" },",
                    "      { value: \"html\", description: \"HTML\" },",
                    "      { value: \"angular\", description: \"Angular\" },",
                    "      { value: \"lwc\", description: \"Lightning Web Components\" },",
                    "    ],",
                    "  },",
                    "  plugins: {",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description:",
                    "      \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  pluginSearchDirs: {",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description: outdent`",
                    "      Custom directory that contains prettier plugins in node_modules subdirectory.",
                    "      Overrides default behavior when plugins are searched relatively to the location of Prettier.",
                    "      Multiple values are accepted.",
                    "    `,",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin-search-dir\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  printWidth: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"int\",",
                    "    default: 80,",
                    "    description: \"The line length where Prettier will try wrap.\",",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "  },",
                    "  rangeEnd: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: Number.POSITIVE_INFINITY,",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Format code ending at a given character offset (exclusive).",
                    "      The range will extend forwards to the end of the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  rangeStart: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: 0,",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Format code starting at a given character offset.",
                    "      The range will extend backwards to the start of the first line containing the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  requirePragma: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: outdent`",
                    "      Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                    "      in order for it to be formatted.",
                    "    `,",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  tabWidth: {",
                    "    type: \"int\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    default: 2,",
                    "    description: \"Number of spaces per indentation level.\",",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "  },",
                    "  useTabs: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent with tabs instead of spaces.\",",
                    "  },",
                    "  embeddedLanguageFormatting: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: \"auto\",",
                    "    description:",
                    "      \"Control how Prettier formats quoted code embedded in the file.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"auto\",",
                    "        description:",
                    "          \"Format embedded code if Prettier can automatically identify it.\",",
                    "      },",
                    "      {",
                    "        value: \"off\",",
                    "        description: \"Never automatically format embedded code.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "core.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { diffArrays } from \"diff\";",
                    "",
                    "import { hardline, addAlignmentToDoc } from \"../document/builders.js\";",
                    "import { printDocToString as printDocToStringWithoutNormalizeOptions } from \"../document/printer.js\";",
                    "import { printDocToDebug } from \"../document/debug.js\";",
                    "import getAlignmentSize from \"../utils/get-alignment-size.js\";",
                    "import {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "  countEndOfLineChars,",
                    "  normalizeEndOfLine,",
                    "} from \"../common/end-of-line.js\";",
                    "import normalizeFormatOptions from \"./normalize-format-options.js\";",
                    "import massageAst from \"./massage-ast.js\";",
                    "import { resolveParser } from \"./parser-and-printer.js\";",
                    "import parseText from \"./parse.js\";",
                    "import { printAstToDoc, prepareToPrint } from \"./ast-to-doc.js\";",
                    "import { calculateRange } from \"./range-util.js\";",
                    "import getCursorNode from \"./get-cursor-node.js\";",
                    "",
                    "const BOM = \"\\uFEFF\";",
                    "",
                    "const CURSOR = Symbol(\"cursor\");",
                    "",
                    "async function coreFormat(originalText, opts, addAlignmentSize = 0) {",
                    "  if (!originalText || originalText.trim().length === 0) {",
                    "    return { formatted: \"\", cursorOffset: -1, comments: [] };",
                    "  }",
                    "",
                    "  const { ast, text } = await parseText(originalText, opts);",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    opts.cursorNode = getCursorNode(ast, opts);",
                    "  }",
                    "",
                    "  let doc = await printAstToDoc(ast, opts, addAlignmentSize);",
                    "",
                    "  if (addAlignmentSize > 0) {",
                    "    // Add a hardline to make the indents take effect, it will be removed later",
                    "    doc = addAlignmentToDoc([hardline, doc], addAlignmentSize, opts.tabWidth);",
                    "  }",
                    "",
                    "  const result = printDocToStringWithoutNormalizeOptions(doc, opts);",
                    "",
                    "  // Remove extra leading indentation as well as the added indentation after last newline",
                    "  if (addAlignmentSize > 0) {",
                    "    const trimmed = result.formatted.trim();",
                    "",
                    "    if (result.cursorNodeStart !== undefined) {",
                    "      result.cursorNodeStart -= result.formatted.indexOf(trimmed);",
                    "    }",
                    "",
                    "    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);",
                    "  }",
                    "",
                    "  const comments = opts[Symbol.for(\"comments\")];",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    let oldCursorNodeStart;",
                    "    let oldCursorNodeText;",
                    "",
                    "    let cursorOffsetRelativeToOldCursorNode;",
                    "",
                    "    let newCursorNodeStart;",
                    "    let newCursorNodeText;",
                    "",
                    "    if (opts.cursorNode && result.cursorNodeText) {",
                    "      oldCursorNodeStart = opts.locStart(opts.cursorNode);",
                    "      oldCursorNodeText = text.slice(",
                    "        oldCursorNodeStart,",
                    "        opts.locEnd(opts.cursorNode)",
                    "      );",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode =",
                    "        opts.cursorOffset - oldCursorNodeStart;",
                    "",
                    "      newCursorNodeStart = result.cursorNodeStart;",
                    "      newCursorNodeText = result.cursorNodeText;",
                    "    } else {",
                    "      oldCursorNodeStart = 0;",
                    "      oldCursorNodeText = text;",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;",
                    "",
                    "      newCursorNodeStart = 0;",
                    "      newCursorNodeText = result.formatted;",
                    "    }",
                    "",
                    "    if (oldCursorNodeText === newCursorNodeText) {",
                    "      return {",
                    "        formatted: result.formatted,",
                    "        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,",
                    "        comments,",
                    "      };",
                    "    }",
                    "",
                    "    // diff old and new cursor node texts, with a special cursor",
                    "    // symbol inserted to find out where it moves to",
                    "",
                    "    // eslint-disable-next-line unicorn/prefer-spread",
                    "    const oldCursorNodeCharArray = oldCursorNodeText.split(\"\");",
                    "    oldCursorNodeCharArray.splice(",
                    "      cursorOffsetRelativeToOldCursorNode,",
                    "      0,",
                    "      CURSOR",
                    "    );",
                    "",
                    "    // eslint-disable-next-line unicorn/prefer-spread",
                    "    const newCursorNodeCharArray = newCursorNodeText.split(\"\");",
                    "",
                    "    const cursorNodeDiff = diffArrays(",
                    "      oldCursorNodeCharArray,",
                    "      newCursorNodeCharArray",
                    "    );",
                    "",
                    "    let cursorOffset = newCursorNodeStart;",
                    "    for (const entry of cursorNodeDiff) {",
                    "      if (entry.removed) {",
                    "        if (entry.value.includes(CURSOR)) {",
                    "          break;",
                    "        }",
                    "      } else {",
                    "        cursorOffset += entry.count;",
                    "      }",
                    "    }",
                    "",
                    "    return { formatted: result.formatted, cursorOffset, comments };",
                    "  }",
                    "",
                    "  return { formatted: result.formatted, cursorOffset: -1, comments };",
                    "}",
                    "",
                    "async function formatRange(originalText, opts) {",
                    "  const { ast, text } = await parseText(originalText, opts);",
                    "  const { rangeStart, rangeEnd } = calculateRange(text, opts, ast);",
                    "  const rangeString = text.slice(rangeStart, rangeEnd);",
                    "",
                    "  // Try to extend the range backwards to the beginning of the line.",
                    "  // This is so we can detect indentation correctly and restore it.",
                    "  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0",
                    "  const rangeStart2 = Math.min(",
                    "    rangeStart,",
                    "    text.lastIndexOf(\"\\n\", rangeStart) + 1",
                    "  );",
                    "  const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];",
                    "",
                    "  const alignmentSize = getAlignmentSize(indentString, opts.tabWidth);",
                    "",
                    "  const rangeResult = await coreFormat(",
                    "    rangeString,",
                    "    {",
                    "      ...opts,",
                    "      rangeStart: 0,",
                    "      rangeEnd: Number.POSITIVE_INFINITY,",
                    "      // Track the cursor offset only if it's within our range",
                    "      cursorOffset:",
                    "        opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd",
                    "          ? opts.cursorOffset - rangeStart",
                    "          : -1,",
                    "      // Always use `lf` to format, we'll replace it later",
                    "      endOfLine: \"lf\",",
                    "    },",
                    "    alignmentSize",
                    "  );",
                    "",
                    "  // Since the range contracts to avoid trailing whitespace,",
                    "  // we need to remove the newline that was inserted by the `format` call.",
                    "  const rangeTrimmed = rangeResult.formatted.trimEnd();",
                    "",
                    "  let { cursorOffset } = opts;",
                    "  if (cursorOffset > rangeEnd) {",
                    "    // handle the case where the cursor was past the end of the range",
                    "    cursorOffset += rangeTrimmed.length - rangeString.length;",
                    "  } else if (rangeResult.cursorOffset >= 0) {",
                    "    // handle the case where the cursor was in the range",
                    "    cursorOffset = rangeResult.cursorOffset + rangeStart;",
                    "  }",
                    "  // keep the cursor as it was if it was before the start of the range",
                    "",
                    "  let formatted =",
                    "    text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);",
                    "  if (opts.endOfLine !== \"lf\") {",
                    "    const eol = convertEndOfLineToChars(opts.endOfLine);",
                    "    if (cursorOffset >= 0 && eol === \"\\r\\n\") {",
                    "      cursorOffset += countEndOfLineChars(",
                    "        formatted.slice(0, cursorOffset),",
                    "        \"\\n\"",
                    "      );",
                    "    }",
                    "",
                    "    formatted = formatted.replaceAll(\"\\n\", eol);",
                    "  }",
                    "",
                    "  return { formatted, cursorOffset, comments: rangeResult.comments };",
                    "}",
                    "",
                    "function ensureIndexInText(text, index, defaultValue) {",
                    "  if (",
                    "    typeof index !== \"number\" ||",
                    "    Number.isNaN(index) ||",
                    "    index < 0 ||",
                    "    index > text.length",
                    "  ) {",
                    "    return defaultValue;",
                    "  }",
                    "",
                    "  return index;",
                    "}",
                    "",
                    "function normalizeIndexes(text, options) {",
                    "  let { cursorOffset, rangeStart, rangeEnd } = options;",
                    "  cursorOffset = ensureIndexInText(text, cursorOffset, -1);",
                    "  rangeStart = ensureIndexInText(text, rangeStart, 0);",
                    "  rangeEnd = ensureIndexInText(text, rangeEnd, text.length);",
                    "",
                    "  return { ...options, cursorOffset, rangeStart, rangeEnd };",
                    "}",
                    "",
                    "function normalizeInputAndOptions(text, options) {",
                    "  let { cursorOffset, rangeStart, rangeEnd, endOfLine } = normalizeIndexes(",
                    "    text,",
                    "    options",
                    "  );",
                    "",
                    "  const hasBOM = text.charAt(0) === BOM;",
                    "",
                    "  if (hasBOM) {",
                    "    text = text.slice(1);",
                    "    cursorOffset--;",
                    "    rangeStart--;",
                    "    rangeEnd--;",
                    "  }",
                    "",
                    "  if (endOfLine === \"auto\") {",
                    "    endOfLine = guessEndOfLine(text);",
                    "  }",
                    "",
                    "  // get rid of CR/CRLF parsing",
                    "  if (text.includes(\"\\r\")) {",
                    "    const countCrlfBefore = (index) =>",
                    "      countEndOfLineChars(text.slice(0, Math.max(index, 0)), \"\\r\\n\");",
                    "",
                    "    cursorOffset -= countCrlfBefore(cursorOffset);",
                    "    rangeStart -= countCrlfBefore(rangeStart);",
                    "    rangeEnd -= countCrlfBefore(rangeEnd);",
                    "",
                    "    text = normalizeEndOfLine(text);",
                    "  }",
                    "",
                    "  return {",
                    "    hasBOM,",
                    "    text,",
                    "    options: normalizeIndexes(text, {",
                    "      ...options,",
                    "      cursorOffset,",
                    "      rangeStart,",
                    "      rangeEnd,",
                    "      endOfLine,",
                    "    }),",
                    "  };",
                    "}",
                    "",
                    "async function hasPragma(text, options) {",
                    "  const selectedParser = await resolveParser(options);",
                    "  return !selectedParser.hasPragma || selectedParser.hasPragma(text);",
                    "}",
                    "",
                    "async function formatWithCursor(originalText, originalOptions) {",
                    "  let { hasBOM, text, options } = normalizeInputAndOptions(",
                    "    originalText,",
                    "    await normalizeFormatOptions(originalOptions)",
                    "  );",
                    "",
                    "  if (",
                    "    (options.rangeStart >= options.rangeEnd && text !== \"\") ||",
                    "    (options.requirePragma && !(await hasPragma(text, options)))",
                    "  ) {",
                    "    return {",
                    "      formatted: originalText,",
                    "      cursorOffset: originalOptions.cursorOffset,",
                    "      comments: [],",
                    "    };",
                    "  }",
                    "",
                    "  let result;",
                    "",
                    "  if (options.rangeStart > 0 || options.rangeEnd < text.length) {",
                    "    result = await formatRange(text, options);",
                    "  } else {",
                    "    if (",
                    "      !options.requirePragma &&",
                    "      options.insertPragma &&",
                    "      options.printer.insertPragma &&",
                    "      !(await hasPragma(text, options))",
                    "    ) {",
                    "      text = options.printer.insertPragma(text);",
                    "    }",
                    "    result = await coreFormat(text, options);",
                    "  }",
                    "",
                    "  if (hasBOM) {",
                    "    result.formatted = BOM + result.formatted;",
                    "",
                    "    if (result.cursorOffset >= 0) {",
                    "      result.cursorOffset++;",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "async function parse(originalText, originalOptions, devOptions) {",
                    "  const { text, options } = normalizeInputAndOptions(",
                    "    originalText,",
                    "    await normalizeFormatOptions(originalOptions)",
                    "  );",
                    "  const parsed = await parseText(text, options);",
                    "  if (devOptions) {",
                    "    if (devOptions.preprocessForPrint) {",
                    "      parsed.ast = await prepareToPrint(parsed.ast, options);",
                    "    }",
                    "    if (devOptions.massage) {",
                    "      parsed.ast = massageAst(parsed.ast, options);",
                    "    }",
                    "  }",
                    "  return parsed;",
                    "}",
                    "",
                    "async function formatAst(ast, options) {",
                    "  options = await normalizeFormatOptions(options);",
                    "  const doc = await printAstToDoc(ast, options);",
                    "  return printDocToStringWithoutNormalizeOptions(doc, options);",
                    "}",
                    "",
                    "// Doesn't handle shebang for now",
                    "async function formatDoc(doc, options) {",
                    "  const text = printDocToDebug(doc);",
                    "  const { formatted } = await formatWithCursor(text, {",
                    "    ...options,",
                    "    parser: \"__js_expression\",",
                    "  });",
                    "",
                    "  return formatted;",
                    "}",
                    "",
                    "async function printToDoc(originalText, options) {",
                    "  options = await normalizeFormatOptions(options);",
                    "  const { ast } = await parseText(originalText, options);",
                    "  return printAstToDoc(ast, options);",
                    "}",
                    "",
                    "async function printDocToString(doc, options) {",
                    "  return printDocToStringWithoutNormalizeOptions(",
                    "    doc,",
                    "    await normalizeFormatOptions(options)",
                    "  );",
                    "}",
                    "",
                    "export {",
                    "  formatWithCursor,",
                    "  parse,",
                    "  formatAst,",
                    "  formatDoc,",
                    "  printToDoc,",
                    "  printDocToString,",
                    "};"
                ]
            },
            "create-get-visitor-keys-function.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const nonTraversableKeys = new Set([",
                    "  \"tokens\",",
                    "  \"comments\",",
                    "  \"parent\",",
                    "  \"enclosingNode\",",
                    "  \"precedingNode\",",
                    "  \"followingNode\",",
                    "]);",
                    "",
                    "const defaultGetVisitorKeys = (node) =>",
                    "  Object.keys(node).filter((key) => !nonTraversableKeys.has(key));",
                    "",
                    "function createGetVisitorKeysFunction(printerGetVisitorKeys) {",
                    "  return printerGetVisitorKeys",
                    "    ? (node) => printerGetVisitorKeys(node, nonTraversableKeys)",
                    "    : defaultGetVisitorKeys;",
                    "}",
                    "",
                    "export default createGetVisitorKeysFunction;"
                ]
            },
            "create-print-pre-check-function.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeysFunction from \"./create-get-visitor-keys-function.js\";",
                    "",
                    "function createPrintPreCheckFunction(options) {",
                    "  if (process.env.NODE_ENV === \"production\") {",
                    "    return () => {};",
                    "  }",
                    "",
                    "  // All core plugins have full list of keys for possible child nodes",
                    "  // Ensure we only pass node to `print`",
                    "  const getVisitorKeys = createGetVisitorKeysFunction(",
                    "    options.printer.getVisitorKeys",
                    "  );",
                    "",
                    "  return function (path) {",
                    "    if (path.isRoot) {",
                    "      return;",
                    "    }",
                    "",
                    "    const { key, parent } = path;",
                    "",
                    "    const visitorKeys = getVisitorKeys(parent);",
                    "    if (visitorKeys.includes(key)) {",
                    "      return;",
                    "    }",
                    "",
                    "    /* c8 ignore start */",
                    "    throw Object.assign(new Error(\"Calling `print()` on non-node object.\"), {",
                    "      parentNode: parent,",
                    "      allowedProperties: visitorKeys,",
                    "      printingProperty: key,",
                    "      printingValue: path.node,",
                    "      pathStack:",
                    "        path.stack.length > 5",
                    "          ? [\"...\", ...path.stack.slice(-5)]",
                    "          : [...path.stack],",
                    "    });",
                    "    /* c8 ignore stop */",
                    "  };",
                    "}",
                    "",
                    "export default createPrintPreCheckFunction;"
                ]
            },
            "get-cursor-node.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { getDescendants } from \"../utils/ast-utils.js\";",
                    "import createGetVisitorKeysFunction from \"./create-get-visitor-keys-function.js\";",
                    "",
                    "function getCursorNode(ast, options) {",
                    "  const { cursorOffset, locStart, locEnd } = options;",
                    "  const getVisitorKeys = createGetVisitorKeysFunction(",
                    "    options.printer.getVisitorKeys",
                    "  );",
                    "  const nodeContainsCursor = (node) =>",
                    "    locStart(node) <= cursorOffset && locEnd(node) >= cursorOffset;",
                    "",
                    "  let cursorNode = ast;",
                    "  for (const node of getDescendants(ast, {",
                    "    getVisitorKeys,",
                    "    filter: nodeContainsCursor,",
                    "  })) {",
                    "    cursorNode = node;",
                    "  }",
                    "",
                    "  return cursorNode;",
                    "}",
                    "",
                    "export default getCursorNode;"
                ]
            },
            "massage-ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeysFunction from \"./create-get-visitor-keys-function.js\";",
                    "",
                    "function massageAst(ast, options) {",
                    "  const {",
                    "    printer: {",
                    "      massageAstNode: cleanFunction,",
                    "      getVisitorKeys: printerGetVisitorKeys,",
                    "    },",
                    "  } = options;",
                    "",
                    "  if (!cleanFunction) {",
                    "    return ast;",
                    "  }",
                    "",
                    "  const getVisitorKeys = createGetVisitorKeysFunction(printerGetVisitorKeys);",
                    "  const ignoredProperties = cleanFunction.ignoredProperties ?? new Set();",
                    "",
                    "  return recurse(ast);",
                    "",
                    "  function recurse(node, parent) {",
                    "    if (!(node !== null && typeof node === \"object\")) {",
                    "      return node;",
                    "    }",
                    "",
                    "    if (Array.isArray(node)) {",
                    "      return node.map((child) => recurse(child, parent)).filter(Boolean);",
                    "    }",
                    "",
                    "    const newObj = {};",
                    "    const childrenKeys = new Set(getVisitorKeys(node));",
                    "    for (const key in node) {",
                    "      if (!Object.hasOwn(node, key) || ignoredProperties.has(key)) {",
                    "        continue;",
                    "      }",
                    "",
                    "      if (childrenKeys.has(key)) {",
                    "        newObj[key] = recurse(node[key], node);",
                    "      } else {",
                    "        newObj[key] = node[key];",
                    "      }",
                    "    }",
                    "",
                    "    const result = cleanFunction(node, newObj, parent);",
                    "    if (result === null) {",
                    "      return;",
                    "    }",
                    "",
                    "    return result ?? newObj;",
                    "  }",
                    "}",
                    "",
                    "export default massageAst;"
                ]
            },
            "multiparser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { stripTrailingHardline } from \"../document/utils.js\";",
                    "import normalizeFormatOptions from \"./normalize-format-options.js\";",
                    "import parse from \"./parse.js\";",
                    "import createGetVisitorKeysFunction from \"./create-get-visitor-keys-function.js\";",
                    "",
                    "async function printEmbeddedLanguages(",
                    "  /** @type {import(\"../common/ast-path.js\").default} */ path,",
                    "  genericPrint,",
                    "  options,",
                    "  printAstToDoc,",
                    "  embeds",
                    ") {",
                    "  const {",
                    "    embeddedLanguageFormatting,",
                    "    printer: {",
                    "      embed,",
                    "      hasPrettierIgnore = () => false,",
                    "      getVisitorKeys: printerGetVisitorKeys,",
                    "    },",
                    "  } = options;",
                    "",
                    "  if (!embed || embeddedLanguageFormatting !== \"auto\") {",
                    "    return;",
                    "  }",
                    "",
                    "  if (embed.length > 2) {",
                    "    throw new Error(",
                    "      \"printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed\"",
                    "    );",
                    "  }",
                    "",
                    "  const getVisitorKeys = createGetVisitorKeysFunction(",
                    "    embed.getVisitorKeys ?? printerGetVisitorKeys",
                    "  );",
                    "  const embedCallResults = [];",
                    "",
                    "  recurse();",
                    "",
                    "  const originalPathStack = path.stack;",
                    "",
                    "  for (const { print, node, pathStack } of embedCallResults) {",
                    "    try {",
                    "      path.stack = pathStack;",
                    "      const doc = await print(textToDocForEmbed, genericPrint, path, options);",
                    "",
                    "      if (doc) {",
                    "        embeds.set(node, doc);",
                    "      }",
                    "    } catch (error) {",
                    "      /* c8 ignore next 3 */",
                    "      if (process.env.PRETTIER_DEBUG) {",
                    "        throw error;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  path.stack = originalPathStack;",
                    "",
                    "  function textToDocForEmbed(text, partialNextOptions) {",
                    "    return textToDoc(text, partialNextOptions, options, printAstToDoc);",
                    "  }",
                    "",
                    "  function recurse() {",
                    "    const { node } = path;",
                    "    if (node === null || typeof node !== \"object\" || hasPrettierIgnore(path)) {",
                    "      return;",
                    "    }",
                    "",
                    "    for (const key of getVisitorKeys(node)) {",
                    "      if (Array.isArray(node[key])) {",
                    "        path.each(recurse, key);",
                    "      } else {",
                    "        path.call(recurse, key);",
                    "      }",
                    "    }",
                    "",
                    "    const result = embed(path, options);",
                    "",
                    "    if (!result) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (typeof result === \"function\") {",
                    "      embedCallResults.push({",
                    "        print: result,",
                    "        node,",
                    "        pathStack: [...path.stack],",
                    "      });",
                    "      return;",
                    "    }",
                    "",
                    "    if (",
                    "      process.env.NODE_ENV !== \"production\" &&",
                    "      typeof result.then === \"function\"",
                    "    ) {",
                    "      throw new Error(",
                    "        \"`embed` should return an async function instead of Promise.\"",
                    "      );",
                    "    }",
                    "",
                    "    embeds.set(node, result);",
                    "  }",
                    "}",
                    "",
                    "async function textToDoc(",
                    "  text,",
                    "  partialNextOptions,",
                    "  parentOptions,",
                    "  printAstToDoc",
                    ") {",
                    "  const options = await normalizeFormatOptions(",
                    "    {",
                    "      ...parentOptions,",
                    "      ...partialNextOptions,",
                    "      parentParser: parentOptions.parser,",
                    "      originalText: text,",
                    "    },",
                    "    { passThrough: true }",
                    "  );",
                    "",
                    "  const { ast } = await parse(text, options);",
                    "  const doc = await printAstToDoc(ast, options);",
                    "",
                    "  return stripTrailingHardline(doc);",
                    "}",
                    "",
                    "export { printEmbeddedLanguages };"
                ]
            },
            "normalize-format-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { UndefinedParserError } from \"../common/errors.js\";",
                    "import { getSupportInfo } from \"../main/support.js\";",
                    "import inferParser from \"../utils/infer-parser.js\";",
                    "import normalizeOptions from \"./normalize-options.js\";",
                    "import {",
                    "  getParserPluginByParserName,",
                    "  getPrinterPluginByAstFormat,",
                    "  initParser,",
                    "} from \"./parser-and-printer.js\";",
                    "",
                    "const formatOptionsHiddenDefaults = {",
                    "  astFormat: \"estree\",",
                    "  printer: {},",
                    "  originalText: undefined,",
                    "  locStart: null,",
                    "  locEnd: null,",
                    "};",
                    "",
                    "// Copy options and fill in default values.",
                    "async function normalizeFormatOptions(options, opts = {}) {",
                    "  const rawOptions = { ...options };",
                    "",
                    "  const supportOptions = getSupportInfo({",
                    "    plugins: options.plugins,",
                    "    showDeprecated: true,",
                    "  }).options;",
                    "",
                    "  const defaults = {",
                    "    ...formatOptionsHiddenDefaults,",
                    "    ...Object.fromEntries(",
                    "      supportOptions",
                    "        .filter((optionInfo) => optionInfo.default !== undefined)",
                    "        .map((option) => [option.name, option.default])",
                    "    ),",
                    "  };",
                    "  if (!rawOptions.parser) {",
                    "    if (!rawOptions.filepath) {",
                    "      const logger = opts.logger || console;",
                    "      logger.warn(",
                    "        \"No parser and no filepath given, using 'babel' the parser now \" +",
                    "          \"but this will throw an error in the future. \" +",
                    "          \"Please specify a parser or a filepath so one can be inferred.\"",
                    "      );",
                    "      rawOptions.parser = \"babel\";",
                    "    } else {",
                    "      rawOptions.parser = inferParser(rawOptions, {",
                    "        physicalFile: rawOptions.filepath,",
                    "      });",
                    "      if (!rawOptions.parser) {",
                    "        throw new UndefinedParserError(",
                    "          `No parser could be inferred for file \"${rawOptions.filepath}\".`",
                    "        );",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const parserPlugin = getParserPluginByParserName(",
                    "    rawOptions.plugins,",
                    "    rawOptions.parser",
                    "  );",
                    "",
                    "  const parser = await initParser(parserPlugin, rawOptions.parser);",
                    "  rawOptions.astFormat = parser.astFormat;",
                    "  rawOptions.locEnd = parser.locEnd;",
                    "  rawOptions.locStart = parser.locStart;",
                    "",
                    "  const printerPlugin = parserPlugin.printers?.[parser.astFormat]",
                    "    ? parserPlugin",
                    "    : getPrinterPluginByAstFormat(rawOptions.plugins, parser.astFormat);",
                    "  const printer = printerPlugin.printers[parser.astFormat];",
                    "",
                    "  rawOptions.printer = printer;",
                    "",
                    "  const pluginDefaults = printerPlugin.defaultOptions",
                    "    ? Object.fromEntries(",
                    "        Object.entries(printerPlugin.defaultOptions).filter(",
                    "          ([, value]) => value !== undefined",
                    "        )",
                    "      )",
                    "    : {};",
                    "",
                    "  const mixedDefaults = { ...defaults, ...pluginDefaults };",
                    "",
                    "  for (const [k, value] of Object.entries(mixedDefaults)) {",
                    "    if (rawOptions[k] === null || rawOptions[k] === undefined) {",
                    "      rawOptions[k] = value;",
                    "    }",
                    "  }",
                    "",
                    "  if (rawOptions.parser === \"json\") {",
                    "    rawOptions.trailingComma = \"none\";",
                    "  }",
                    "",
                    "  return normalizeOptions(rawOptions, supportOptions, {",
                    "    passThrough: Object.keys(formatOptionsHiddenDefaults),",
                    "    ...opts,",
                    "  });",
                    "}",
                    "",
                    "export default normalizeFormatOptions;",
                    "export { formatOptionsHiddenDefaults };"
                ]
            },
            "normalize-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import vnopts from \"vnopts\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./support.js\").NamedOptionInfo} NamedOptionInfo",
                    " */",
                    "",
                    "let hasDeprecationWarned;",
                    "",
                    "/**",
                    " * @param {*} options",
                    " * @param {*} optionInfos",
                    " * @param {{ logger?: false; isCLI?: boolean; passThrough?: string[] | boolean; FlagSchema?: any; descriptor?: any }} param2",
                    " */",
                    "function normalizeOptions(",
                    "  options,",
                    "  optionInfos,",
                    "  {",
                    "    logger = false,",
                    "    isCLI = false,",
                    "    passThrough = false,",
                    "    FlagSchema,",
                    "    descriptor,",
                    "  } = {}",
                    ") {",
                    "  // TODO: Move CLI related part into `/src/cli`",
                    "  if (isCLI) {",
                    "    /* c8 ignore start */",
                    "    if (!FlagSchema) {",
                    "      throw new Error(\"'FlagSchema' option is required.\");",
                    "    }",
                    "",
                    "    if (!descriptor) {",
                    "      throw new Error(\"'descriptor' option is required.\");",
                    "    }",
                    "    /* c8 ignore stop */",
                    "  } else {",
                    "    descriptor = vnopts.apiDescriptor;",
                    "  }",
                    "",
                    "  const unknown = !passThrough",
                    "    ? (key, value, options) => {",
                    "        // Don't suggest `_` for unknown flags",
                    "        const { _, ...schemas } = options.schemas;",
                    "        return vnopts.levenUnknownHandler(key, value, {",
                    "          ...options,",
                    "          schemas,",
                    "        });",
                    "      }",
                    "    : Array.isArray(passThrough)",
                    "    ? (key, value) =>",
                    "        !passThrough.includes(key) ? undefined : { [key]: value }",
                    "    : (key, value) => ({ [key]: value });",
                    "",
                    "  const schemas = optionInfosToSchemas(optionInfos, { isCLI, FlagSchema });",
                    "  const normalizer = new vnopts.Normalizer(schemas, {",
                    "    logger,",
                    "    unknown,",
                    "    descriptor,",
                    "  });",
                    "",
                    "  const shouldSuppressDuplicateDeprecationWarnings = logger !== false;",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {",
                    "    // @ts-expect-error",
                    "    normalizer._hasDeprecationWarned = hasDeprecationWarned;",
                    "  }",
                    "",
                    "  const normalized = normalizer.normalize(options);",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings) {",
                    "    // @ts-expect-error",
                    "    hasDeprecationWarned = normalizer._hasDeprecationWarned;",
                    "  }",
                    "",
                    "  if (isCLI && normalized[\"plugin-search\"] === false) {",
                    "    normalized[\"plugin-search-dir\"] = false;",
                    "  }",
                    "",
                    "  return normalized;",
                    "}",
                    "",
                    "function optionInfosToSchemas(optionInfos, { isCLI, FlagSchema }) {",
                    "  const schemas = [];",
                    "",
                    "  if (isCLI) {",
                    "    schemas.push(vnopts.AnySchema.create({ name: \"_\" }));",
                    "  }",
                    "",
                    "  for (const optionInfo of optionInfos) {",
                    "    schemas.push(",
                    "      optionInfoToSchema(optionInfo, {",
                    "        isCLI,",
                    "        optionInfos,",
                    "        FlagSchema,",
                    "      })",
                    "    );",
                    "",
                    "    if (optionInfo.alias && isCLI) {",
                    "      schemas.push(",
                    "        vnopts.AliasSchema.create({",
                    "          // @ts-expect-error",
                    "          name: optionInfo.alias,",
                    "          sourceName: optionInfo.name,",
                    "        })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return schemas;",
                    "}",
                    "",
                    "/**",
                    " * @param {NamedOptionInfo} optionInfo",
                    " * @param {any} param1",
                    " * @returns",
                    " */",
                    "function optionInfoToSchema(optionInfo, { isCLI, optionInfos, FlagSchema }) {",
                    "  const { name } = optionInfo;",
                    "",
                    "  if (name === \"plugin-search-dir\" || name === \"pluginSearchDirs\") {",
                    "    return vnopts.AnySchema.create({",
                    "      // @ts-expect-error",
                    "      name,",
                    "      preprocess(value) {",
                    "        if (value === false) {",
                    "          return value;",
                    "        }",
                    "        value = Array.isArray(value) ? value : [value];",
                    "        return value;",
                    "      },",
                    "      /**",
                    "       * @param {Array<unknown> | false} value",
                    "       */",
                    "      validate(value) {",
                    "        if (value === false) {",
                    "          return true;",
                    "        }",
                    "        return value.every((dir) => typeof dir === \"string\");",
                    "      },",
                    "      expected() {",
                    "        return \"false or paths to plugin search dir\";",
                    "      },",
                    "    });",
                    "  }",
                    "",
                    "  const parameters = { name };",
                    "  let SchemaConstructor;",
                    "  const handlers = {};",
                    "",
                    "  switch (optionInfo.type) {",
                    "    case \"int\":",
                    "      SchemaConstructor = vnopts.IntegerSchema;",
                    "      if (isCLI) {",
                    "        parameters.preprocess = Number;",
                    "      }",
                    "      break;",
                    "    case \"string\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    case \"choice\":",
                    "      SchemaConstructor = vnopts.ChoiceSchema;",
                    "      parameters.choices = optionInfo.choices.map((choiceInfo) =>",
                    "        choiceInfo?.redirect",
                    "          ? {",
                    "              ...choiceInfo,",
                    "              redirect: {",
                    "                to: { key: optionInfo.name, value: choiceInfo.redirect },",
                    "              },",
                    "            }",
                    "          : choiceInfo",
                    "      );",
                    "      break;",
                    "    case \"boolean\":",
                    "      SchemaConstructor = vnopts.BooleanSchema;",
                    "      break;",
                    "    case \"flag\":",
                    "      // Only available when normalizing CLI options",
                    "      SchemaConstructor = FlagSchema;",
                    "      parameters.flags = optionInfos.flatMap((optionInfo) =>",
                    "        [",
                    "          optionInfo.alias,",
                    "          optionInfo.description && optionInfo.name,",
                    "          optionInfo.oppositeDescription && `no-${optionInfo.name}`,",
                    "        ].filter(Boolean)",
                    "      );",
                    "      break;",
                    "    case \"path\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new Error(`Unexpected type ${optionInfo.type}`);",
                    "  }",
                    "",
                    "  if (optionInfo.exception) {",
                    "    parameters.validate = (value, schema, utils) =>",
                    "      optionInfo.exception(value) || schema.validate(value, utils);",
                    "  } else {",
                    "    parameters.validate = (value, schema, utils) =>",
                    "      value === undefined || schema.validate(value, utils);",
                    "  }",
                    "",
                    "  /* c8 ignore start */",
                    "  if (optionInfo.redirect) {",
                    "    handlers.redirect = (value) =>",
                    "      !value",
                    "        ? undefined",
                    "        : {",
                    "            to: {",
                    "              key: optionInfo.redirect.option,",
                    "              value: optionInfo.redirect.value,",
                    "            },",
                    "          };",
                    "  }",
                    "  /* c8 ignore stop */",
                    "",
                    "  /* c8 ignore next 3 */",
                    "  if (optionInfo.deprecated) {",
                    "    handlers.deprecated = true;",
                    "  }",
                    "",
                    "  // allow CLI overriding, e.g., prettier package.json --tab-width 1 --tab-width 2",
                    "  if (isCLI && !optionInfo.array) {",
                    "    const originalPreprocess = parameters.preprocess || ((x) => x);",
                    "    parameters.preprocess = (value, schema, utils) =>",
                    "      schema.preprocess(",
                    "        originalPreprocess(Array.isArray(value) ? value.at(-1) : value),",
                    "        utils",
                    "      );",
                    "  }",
                    "",
                    "  return optionInfo.array",
                    "    ? vnopts.ArraySchema.create({",
                    "        ...(isCLI ? { preprocess: (v) => (Array.isArray(v) ? v : [v]) } : {}),",
                    "        ...handlers,",
                    "        // @ts-expect-error",
                    "        valueSchema: SchemaConstructor.create(parameters),",
                    "      })",
                    "    : SchemaConstructor.create({ ...parameters, ...handlers });",
                    "}",
                    "",
                    "export default normalizeOptions;"
                ]
            },
            "option-categories.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export const CATEGORY_CONFIG = \"Config\";",
                    "export const CATEGORY_EDITOR = \"Editor\";",
                    "export const CATEGORY_FORMAT = \"Format\";",
                    "export const CATEGORY_OTHER = \"Other\";",
                    "export const CATEGORY_OUTPUT = \"Output\";",
                    "export const CATEGORY_GLOBAL = \"Global\";",
                    "export const CATEGORY_SPECIAL = \"Special\";"
                ]
            },
            "parse.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { codeFrameColumns } from \"@babel/code-frame\";",
                    "import { resolveParser } from \"./parser-and-printer.js\";",
                    "",
                    "async function parse(originalText, options) {",
                    "  const parser = await resolveParser(options);",
                    "  const text = parser.preprocess",
                    "    ? parser.preprocess(originalText, options)",
                    "    : originalText;",
                    "  options.originalText = text;",
                    "",
                    "  let ast;",
                    "  try {",
                    "    ast = await parser.parse(",
                    "      text,",
                    "      options,",
                    "      // TODO: remove the third argument in v4",
                    "      // The duplicated argument is passed as intended, see #10156",
                    "      options",
                    "    );",
                    "  } catch (error) {",
                    "    handleParseError(error, originalText);",
                    "  }",
                    "",
                    "  return { text, ast };",
                    "}",
                    "",
                    "function handleParseError(error, text) {",
                    "  const { loc } = error;",
                    "",
                    "  if (loc) {",
                    "    const codeFrame = codeFrameColumns(text, loc, { highlightCode: true });",
                    "    error.message += \"\\n\" + codeFrame;",
                    "    error.codeFrame = codeFrame;",
                    "    throw error;",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  throw error;",
                    "}",
                    "",
                    "export default parse;"
                ]
            },
            "parser-and-printer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { ConfigError } from \"../common/errors.js\";",
                    "",
                    "// TODO: Improve coverage",
                    "",
                    "function getParserPluginByParserName(plugins, parserName) {",
                    "  /* c8 ignore start */",
                    "  if (!parserName) {",
                    "    throw new Error(\"parserName is required.\");",
                    "  }",
                    "  /* c8 ignore stop */",
                    "",
                    "  /*",
                    "  Loop from end to allow plugins override builtin plugins,",
                    "  this is how `resolveParser` works in v2.",
                    "  This is a temporarily solution, see #13729",
                    "  */",
                    "  for (let index = plugins.length - 1; index >= 0; index--) {",
                    "    const plugin = plugins[index];",
                    "    if (plugin.parsers && Object.hasOwn(plugin.parsers, parserName)) {",
                    "      return plugin;",
                    "    }",
                    "  }",
                    "",
                    "  /* c8 ignore start */",
                    "  let message = `Couldn't resolve parser \"${parserName}\".`;",
                    "  if (process.env.PRETTIER_TARGET === \"universal\") {",
                    "    message += \" Plugins must be explicitly added to the standalone bundle.\";",
                    "  }",
                    "",
                    "  throw new ConfigError(message);",
                    "  /* c8 ignore stop */",
                    "}",
                    "",
                    "function getPrinterPluginByAstFormat(plugins, astFormat) {",
                    "  /* c8 ignore start */",
                    "  if (!astFormat) {",
                    "    throw new Error(\"astFormat is required.\");",
                    "  }",
                    "  /* c8 ignore stop */",
                    "",
                    "  // Loop from end to consistent with parser resolve logic",
                    "  for (let index = plugins.length - 1; index >= 0; index--) {",
                    "    const plugin = plugins[index];",
                    "    if (plugin.printers && Object.hasOwn(plugin.printers, astFormat)) {",
                    "      return plugin;",
                    "    }",
                    "  }",
                    "",
                    "  /* c8 ignore start */",
                    "  let message = `Couldn't find plugin for AST format \"${astFormat}\".`;",
                    "  if (process.env.PRETTIER_TARGET === \"universal\") {",
                    "    message += \" Plugins must be explicitly added to the standalone bundle.\";",
                    "  }",
                    "",
                    "  throw new ConfigError(message);",
                    "  /* c8 ignore stop */",
                    "}",
                    "",
                    "function resolveParser({ plugins, parser }) {",
                    "  const plugin = getParserPluginByParserName(plugins, parser);",
                    "  return initParser(plugin, parser);",
                    "}",
                    "",
                    "function initParser(plugin, parserName) {",
                    "  const parserOrParserInitFunction = plugin.parsers[parserName];",
                    "  return typeof parserOrParserInitFunction === \"function\"",
                    "    ? parserOrParserInitFunction()",
                    "    : parserOrParserInitFunction;",
                    "}",
                    "",
                    "export {",
                    "  getParserPluginByParserName,",
                    "  getPrinterPluginByAstFormat,",
                    "  initParser,",
                    "  resolveParser,",
                    "};"
                ]
            },
            "print-ignored.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function printIgnored(path, options) {",
                    "  const {",
                    "    originalText,",
                    "    [Symbol.for(\"comments\")]: comments,",
                    "    locStart,",
                    "    locEnd,",
                    "    [Symbol.for(\"printedComments\")]: printedComments,",
                    "  } = options;",
                    "",
                    "  const { node } = path;",
                    "  const start = locStart(node);",
                    "  const end = locEnd(node);",
                    "",
                    "  for (const comment of comments) {",
                    "    if (locStart(comment) >= start && locEnd(comment) <= end) {",
                    "      printedComments.add(comment);",
                    "    }",
                    "  }",
                    "",
                    "  return originalText.slice(start, end);",
                    "}",
                    "",
                    "export default printIgnored;"
                ]
            },
            "range-util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import assert from \"node:assert\";",
                    "import { getSortedChildNodes } from \"./comments/attach.js\";",
                    "",
                    "const isJsonParser = ({ parser }) =>",
                    "  parser === \"json\" || parser === \"json5\" || parser === \"json-stringify\";",
                    "",
                    "function findCommonAncestor(startNodeAndParents, endNodeAndParents) {",
                    "  const startNodeAndAncestors = [",
                    "    startNodeAndParents.node,",
                    "    ...startNodeAndParents.parentNodes,",
                    "  ];",
                    "  const endNodeAndAncestors = new Set([",
                    "    endNodeAndParents.node,",
                    "    ...endNodeAndParents.parentNodes,",
                    "  ]);",
                    "  return startNodeAndAncestors.find(",
                    "    (node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node)",
                    "  );",
                    "}",
                    "",
                    "function dropRootParents(parents) {",
                    "  let lastParentIndex = parents.length - 1;",
                    "  for (;;) {",
                    "    const parent = parents[lastParentIndex];",
                    "    if (parent?.type === \"Program\" || parent?.type === \"File\") {",
                    "      lastParentIndex--;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "  return parents.slice(0, lastParentIndex + 1);",
                    "}",
                    "",
                    "function findSiblingAncestors(",
                    "  startNodeAndParents,",
                    "  endNodeAndParents,",
                    "  { locStart, locEnd }",
                    ") {",
                    "  let resultStartNode = startNodeAndParents.node;",
                    "  let resultEndNode = endNodeAndParents.node;",
                    "",
                    "  if (resultStartNode === resultEndNode) {",
                    "    return {",
                    "      startNode: resultStartNode,",
                    "      endNode: resultEndNode,",
                    "    };",
                    "  }",
                    "",
                    "  const startNodeStart = locStart(startNodeAndParents.node);",
                    "  for (const endParent of dropRootParents(endNodeAndParents.parentNodes)) {",
                    "    if (locStart(endParent) >= startNodeStart) {",
                    "      resultEndNode = endParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  const endNodeEnd = locEnd(endNodeAndParents.node);",
                    "  for (const startParent of dropRootParents(startNodeAndParents.parentNodes)) {",
                    "    if (locEnd(startParent) <= endNodeEnd) {",
                    "      resultStartNode = startParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "    if (resultStartNode === resultEndNode) {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  return {",
                    "    startNode: resultStartNode,",
                    "    endNode: resultEndNode,",
                    "  };",
                    "}",
                    "",
                    "function findNodeAtOffset(",
                    "  node,",
                    "  offset,",
                    "  options,",
                    "  predicate,",
                    "  parentNodes = [],",
                    "  type",
                    ") {",
                    "  const { locStart, locEnd } = options;",
                    "  const start = locStart(node);",
                    "  const end = locEnd(node);",
                    "",
                    "  if (",
                    "    offset > end ||",
                    "    offset < start ||",
                    "    (type === \"rangeEnd\" && offset === start) ||",
                    "    (type === \"rangeStart\" && offset === end)",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  for (const childNode of getSortedChildNodes(node, options)) {",
                    "    const childResult = findNodeAtOffset(",
                    "      childNode,",
                    "      offset,",
                    "      options,",
                    "      predicate,",
                    "      [node, ...parentNodes],",
                    "      type",
                    "    );",
                    "    if (childResult) {",
                    "      return childResult;",
                    "    }",
                    "  }",
                    "",
                    "  if (!predicate || predicate(node, parentNodes[0])) {",
                    "    return {",
                    "      node,",
                    "      parentNodes,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "// See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5",
                    "function isJsSourceElement(type, parentType) {",
                    "  return (",
                    "    parentType !== \"DeclareExportDeclaration\" &&",
                    "    type !== \"TypeParameterDeclaration\" &&",
                    "    (type === \"Directive\" ||",
                    "      type === \"TypeAlias\" ||",
                    "      type === \"TSExportAssignment\" ||",
                    "      type.startsWith(\"Declare\") ||",
                    "      type.startsWith(\"TSDeclare\") ||",
                    "      type.endsWith(\"Statement\") ||",
                    "      type.endsWith(\"Declaration\"))",
                    "  );",
                    "}",
                    "",
                    "const jsonSourceElements = new Set([",
                    "  \"JsonRoot\",",
                    "  \"ObjectExpression\",",
                    "  \"ArrayExpression\",",
                    "  \"StringLiteral\",",
                    "  \"NumericLiteral\",",
                    "  \"BooleanLiteral\",",
                    "  \"NullLiteral\",",
                    "  \"UnaryExpression\",",
                    "  \"TemplateLiteral\",",
                    "]);",
                    "const graphqlSourceElements = new Set([",
                    "  \"OperationDefinition\",",
                    "  \"FragmentDefinition\",",
                    "  \"VariableDefinition\",",
                    "  \"TypeExtensionDefinition\",",
                    "  \"ObjectTypeDefinition\",",
                    "  \"FieldDefinition\",",
                    "  \"DirectiveDefinition\",",
                    "  \"EnumTypeDefinition\",",
                    "  \"EnumValueDefinition\",",
                    "  \"InputValueDefinition\",",
                    "  \"InputObjectTypeDefinition\",",
                    "  \"SchemaDefinition\",",
                    "  \"OperationTypeDefinition\",",
                    "  \"InterfaceTypeDefinition\",",
                    "  \"UnionTypeDefinition\",",
                    "  \"ScalarTypeDefinition\",",
                    "]);",
                    "function isSourceElement(opts, node, parentNode) {",
                    "  /* c8 ignore next 3 */",
                    "  if (!node) {",
                    "    return false;",
                    "  }",
                    "  switch (opts.parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"__babel_estree\":",
                    "      return isJsSourceElement(node.type, parentNode?.type);",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      return jsonSourceElements.has(node.type);",
                    "    case \"graphql\":",
                    "      return graphqlSourceElements.has(node.kind);",
                    "    case \"vue\":",
                    "      return node.tag !== \"root\";",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function calculateRange(text, opts, ast) {",
                    "  let { rangeStart: start, rangeEnd: end, locStart, locEnd } = opts;",
                    "  assert.ok(end > start);",
                    "  // Contract the range so that it has non-whitespace characters at its endpoints.",
                    "  // This ensures we can format a range that doesn't end on a node.",
                    "  const firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\\S/);",
                    "  const isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;",
                    "  if (!isAllWhitespace) {",
                    "    start += firstNonWhitespaceCharacterIndex;",
                    "    for (; end > start; --end) {",
                    "      if (/\\S/.test(text[end - 1])) {",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const startNodeAndParents = findNodeAtOffset(",
                    "    ast,",
                    "    start,",
                    "    opts,",
                    "    (node, parentNode) => isSourceElement(opts, node, parentNode),",
                    "    [],",
                    "    \"rangeStart\"",
                    "  );",
                    "  const endNodeAndParents =",
                    "    // No need find Node at `end`, it will be the same as `startNodeAndParents`",
                    "    isAllWhitespace",
                    "      ? startNodeAndParents",
                    "      : findNodeAtOffset(",
                    "          ast,",
                    "          end,",
                    "          opts,",
                    "          (node) => isSourceElement(opts, node),",
                    "          [],",
                    "          \"rangeEnd\"",
                    "        );",
                    "  if (!startNodeAndParents || !endNodeAndParents) {",
                    "    return {",
                    "      rangeStart: 0,",
                    "      rangeEnd: 0,",
                    "    };",
                    "  }",
                    "",
                    "  let startNode;",
                    "  let endNode;",
                    "  if (isJsonParser(opts)) {",
                    "    const commonAncestor = findCommonAncestor(",
                    "      startNodeAndParents,",
                    "      endNodeAndParents",
                    "    );",
                    "    startNode = commonAncestor;",
                    "    endNode = commonAncestor;",
                    "  } else {",
                    "    ({ startNode, endNode } = findSiblingAncestors(",
                    "      startNodeAndParents,",
                    "      endNodeAndParents,",
                    "      opts",
                    "    ));",
                    "  }",
                    "",
                    "  return {",
                    "    rangeStart: Math.min(locStart(startNode), locStart(endNode)),",
                    "    rangeEnd: Math.max(locEnd(startNode), locEnd(endNode)),",
                    "  };",
                    "}",
                    "",
                    "export { calculateRange, findNodeAtOffset };"
                ]
            },
            "support.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import coreOptions from \"./core-options.evaluate.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./core-options.evaluate.js\").OptionInfo} OptionInfo",
                    " * @typedef {{ name: string; pluginDefaults: Array<any> } & OptionInfo} NamedOptionInfo",
                    " */",
                    "",
                    "/**",
                    " * Strings in `plugins` and `pluginSearchDirs` are handled by a wrapped version",
                    " * of this function created by `withPlugins`. Don't pass them here directly.",
                    " * @param {object} param0",
                    " * @param {(string | object)[]=} param0.plugins Strings are resolved by `withPlugins`.",
                    " * @param {string[]=} param0.pluginSearchDirs Added by `withPlugins`.",
                    " * @param {boolean=} param0.showDeprecated",
                    " * @return {{ languages: Array<any>, options: Array<NamedOptionInfo> }}",
                    " */",
                    "function getSupportInfo({ plugins = [], showDeprecated = false } = {}) {",
                    "  const languages = plugins.flatMap((plugin) => plugin.languages ?? []);",
                    "",
                    "  const options = [];",
                    "  for (const option of normalizeOptionSettings(",
                    "    Object.assign({}, ...plugins.map(({ options }) => options), coreOptions)",
                    "  )) {",
                    "    if (!showDeprecated && option.deprecated) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (Array.isArray(option.choices)) {",
                    "      if (!showDeprecated) {",
                    "        option.choices = option.choices.filter((choice) => !choice.deprecated);",
                    "      }",
                    "",
                    "      if (option.name === \"parser\") {",
                    "        option.choices = [",
                    "          ...option.choices,",
                    "          ...collectParsersFromLanguages(option.choices, languages, plugins),",
                    "        ];",
                    "      }",
                    "    }",
                    "",
                    "    option.pluginDefaults = Object.fromEntries(",
                    "      plugins",
                    "        .filter((plugin) => plugin.defaultOptions?.[option.name] !== undefined)",
                    "        .map((plugin) => [plugin.name, plugin.defaultOptions[option.name]])",
                    "    );",
                    "",
                    "    options.push(option);",
                    "  }",
                    "",
                    "  return { languages, options };",
                    "}",
                    "",
                    "function* collectParsersFromLanguages(parserChoices, languages, plugins) {",
                    "  const existingParsers = new Set(parserChoices.map((choice) => choice.value));",
                    "",
                    "  for (const language of languages) {",
                    "    if (language.parsers) {",
                    "      for (const parserName of language.parsers) {",
                    "        if (!existingParsers.has(parserName)) {",
                    "          existingParsers.add(parserName);",
                    "          const plugin = plugins.find(",
                    "            (plugin) =>",
                    "              plugin.parsers && Object.hasOwn(plugin.parsers, parserName)",
                    "          );",
                    "",
                    "          let description = language.name;",
                    "          if (plugin?.name) {",
                    "            description += ` (plugin: ${plugin.name})`;",
                    "          }",
                    "          yield { value: parserName, description };",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function normalizeOptionSettings(settings) {",
                    "  const options = [];",
                    "  for (const [name, originalOption] of Object.entries(settings)) {",
                    "    const option = { name, ...originalOption };",
                    "",
                    "    // This work this way because we used support `[{value: [], since: '0.0.0'}]`",
                    "    if (Array.isArray(option.default)) {",
                    "      option.default = option.default.at(-1).value;",
                    "    }",
                    "",
                    "    options.push(option);",
                    "  }",
                    "",
                    "  return options;",
                    "}",
                    "",
                    "export { getSupportInfo, normalizeOptionSettings };"
                ]
            },
            "version.evaluate.cjs": {},
            "comments": {
                "attach.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import assert from \"node:assert\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import { getChildren } from \"../../utils/ast-utils.js\";",
                        "import createGetVisitorKeysFunction from \"../create-get-visitor-keys-function.js\";",
                        "import {",
                        "  addLeadingComment,",
                        "  addDanglingComment,",
                        "  addTrailingComment,",
                        "} from \"./utils.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " */",
                        "",
                        "const childNodesCache = new WeakMap();",
                        "function getSortedChildNodes(node, options) {",
                        "  if (childNodesCache.has(node)) {",
                        "    return childNodesCache.get(node);",
                        "  }",
                        "",
                        "  const {",
                        "    printer: {",
                        "      getCommentChildNodes,",
                        "      canAttachComment,",
                        "      getVisitorKeys: printerGetVisitorKeys,",
                        "    },",
                        "    locStart,",
                        "    locEnd,",
                        "  } = options;",
                        "",
                        "  if (!canAttachComment) {",
                        "    return [];",
                        "  }",
                        "",
                        "  const childNodes = (",
                        "    getCommentChildNodes?.(node, options) ?? [",
                        "      ...getChildren(node, {",
                        "        getVisitorKeys: createGetVisitorKeysFunction(printerGetVisitorKeys),",
                        "      }),",
                        "    ]",
                        "  ).flatMap((node) =>",
                        "    canAttachComment(node) ? [node] : getSortedChildNodes(node, options)",
                        "  );",
                        "  // Sort by `start` location first, then `end` location",
                        "  childNodes.sort(",
                        "    (nodeA, nodeB) =>",
                        "      locStart(nodeA) - locStart(nodeB) || locEnd(nodeA) - locEnd(nodeB)",
                        "  );",
                        "",
                        "  childNodesCache.set(node, childNodes);",
                        "  return childNodes;",
                        "}",
                        "",
                        "// As efficiently as possible, decorate the comment object with",
                        "// .precedingNode, .enclosingNode, and/or .followingNode properties, at",
                        "// least one of which is guaranteed to be defined.",
                        "function decorateComment(node, comment, options, enclosingNode) {",
                        "  const { locStart, locEnd } = options;",
                        "  const commentStart = locStart(comment);",
                        "  const commentEnd = locEnd(comment);",
                        "",
                        "  const childNodes = getSortedChildNodes(node, options);",
                        "  let precedingNode;",
                        "  let followingNode;",
                        "  // Time to dust off the old binary search robes and wizard hat.",
                        "  let left = 0;",
                        "  let right = childNodes.length;",
                        "  while (left < right) {",
                        "    const middle = (left + right) >> 1;",
                        "    const child = childNodes[middle];",
                        "    const start = locStart(child);",
                        "    const end = locEnd(child);",
                        "",
                        "    // The comment is completely contained by this child node.",
                        "    if (start <= commentStart && commentEnd <= end) {",
                        "      // Abandon the binary search at this level.",
                        "      return decorateComment(child, comment, options, child);",
                        "    }",
                        "",
                        "    if (end <= commentStart) {",
                        "      // This child node falls completely before the comment.",
                        "      // Because we will never consider this node or any nodes",
                        "      // before it again, this node must be the closest preceding",
                        "      // node we have encountered so far.",
                        "      precedingNode = child;",
                        "      left = middle + 1;",
                        "      continue;",
                        "    }",
                        "",
                        "    if (commentEnd <= start) {",
                        "      // This child node falls completely after the comment.",
                        "      // Because we will never consider this node or any nodes after",
                        "      // it again, this node must be the closest following node we",
                        "      // have encountered so far.",
                        "      followingNode = child;",
                        "      right = middle;",
                        "      continue;",
                        "    }",
                        "",
                        "    /* c8 ignore next */",
                        "    throw new Error(\"Comment location overlaps with node location\");",
                        "  }",
                        "",
                        "  // We don't want comments inside of different expressions inside of the same",
                        "  // template literal to move to another expression.",
                        "  if (enclosingNode?.type === \"TemplateLiteral\") {",
                        "    const { quasis } = enclosingNode;",
                        "    const commentIndex = findExpressionIndexForComment(",
                        "      quasis,",
                        "      comment,",
                        "      options",
                        "    );",
                        "",
                        "    if (",
                        "      precedingNode &&",
                        "      findExpressionIndexForComment(quasis, precedingNode, options) !==",
                        "        commentIndex",
                        "    ) {",
                        "      precedingNode = null;",
                        "    }",
                        "    if (",
                        "      followingNode &&",
                        "      findExpressionIndexForComment(quasis, followingNode, options) !==",
                        "        commentIndex",
                        "    ) {",
                        "      followingNode = null;",
                        "    }",
                        "  }",
                        "",
                        "  return { enclosingNode, precedingNode, followingNode };",
                        "}",
                        "",
                        "const returnFalse = () => false;",
                        "function attachComments(ast, options) {",
                        "  const { comments } = ast;",
                        "  delete ast.comments;",
                        "",
                        "  if (!isNonEmptyArray(comments) || !options.printer.canAttachComment) {",
                        "    return;",
                        "  }",
                        "",
                        "  const tiesToBreak = [];",
                        "  const {",
                        "    locStart,",
                        "    locEnd,",
                        "    printer: {",
                        "      experimentalFeatures: {",
                        "        // TODO: Make this as default behavior",
                        "        avoidAstMutation = false,",
                        "      } = {},",
                        "      handleComments = {},",
                        "    },",
                        "    originalText: text,",
                        "  } = options;",
                        "  const {",
                        "    ownLine: handleOwnLineComment = returnFalse,",
                        "    endOfLine: handleEndOfLineComment = returnFalse,",
                        "    remaining: handleRemainingComment = returnFalse,",
                        "  } = handleComments;",
                        "",
                        "  const decoratedComments = comments.map((comment, index) => ({",
                        "    ...decorateComment(ast, comment, options),",
                        "    comment,",
                        "    text,",
                        "    options,",
                        "    ast,",
                        "    isLastComment: comments.length - 1 === index,",
                        "  }));",
                        "",
                        "  for (const [index, context] of decoratedComments.entries()) {",
                        "    const {",
                        "      comment,",
                        "      precedingNode,",
                        "      enclosingNode,",
                        "      followingNode,",
                        "      text,",
                        "      options,",
                        "      ast,",
                        "      isLastComment,",
                        "    } = context;",
                        "",
                        "    if (",
                        "      options.parser === \"json\" ||",
                        "      options.parser === \"json5\" ||",
                        "      options.parser === \"__js_expression\" ||",
                        "      options.parser === \"__ts_expression\" ||",
                        "      options.parser === \"__vue_expression\" ||",
                        "      options.parser === \"__vue_ts_expression\"",
                        "    ) {",
                        "      if (locStart(comment) - locStart(ast) <= 0) {",
                        "        addLeadingComment(ast, comment);",
                        "        continue;",
                        "      }",
                        "      if (locEnd(comment) - locEnd(ast) >= 0) {",
                        "        addTrailingComment(ast, comment);",
                        "        continue;",
                        "      }",
                        "    }",
                        "",
                        "    let args;",
                        "    if (avoidAstMutation) {",
                        "      args = [context];",
                        "    } else {",
                        "      comment.enclosingNode = enclosingNode;",
                        "      comment.precedingNode = precedingNode;",
                        "      comment.followingNode = followingNode;",
                        "      args = [comment, text, options, ast, isLastComment];",
                        "    }",
                        "",
                        "    if (isOwnLineComment(text, options, decoratedComments, index)) {",
                        "      comment.placement = \"ownLine\";",
                        "      // If a comment exists on its own line, prefer a leading comment.",
                        "      // We also need to check if it's the first line of the file.",
                        "      if (handleOwnLineComment(...args)) {",
                        "        // We're good",
                        "      } else if (followingNode) {",
                        "        // Always a leading comment.",
                        "        addLeadingComment(followingNode, comment);",
                        "      } else if (precedingNode) {",
                        "        addTrailingComment(precedingNode, comment);",
                        "      } else if (enclosingNode) {",
                        "        addDanglingComment(enclosingNode, comment);",
                        "      } else {",
                        "        // There are no nodes, let's attach it to the root of the ast",
                        "        /* c8 ignore next */",
                        "        addDanglingComment(ast, comment);",
                        "      }",
                        "    } else if (isEndOfLineComment(text, options, decoratedComments, index)) {",
                        "      comment.placement = \"endOfLine\";",
                        "      if (handleEndOfLineComment(...args)) {",
                        "        // We're good",
                        "      } else if (precedingNode) {",
                        "        // There is content before this comment on the same line, but",
                        "        // none after it, so prefer a trailing comment of the previous node.",
                        "        addTrailingComment(precedingNode, comment);",
                        "      } else if (followingNode) {",
                        "        addLeadingComment(followingNode, comment);",
                        "      } else if (enclosingNode) {",
                        "        addDanglingComment(enclosingNode, comment);",
                        "      } else {",
                        "        // There are no nodes, let's attach it to the root of the ast",
                        "        /* c8 ignore next */",
                        "        addDanglingComment(ast, comment);",
                        "      }",
                        "    } else {",
                        "      comment.placement = \"remaining\";",
                        "      if (handleRemainingComment(...args)) {",
                        "        // We're good",
                        "      } else if (precedingNode && followingNode) {",
                        "        // Otherwise, text exists both before and after the comment on",
                        "        // the same line. If there is both a preceding and following",
                        "        // node, use a tie-breaking algorithm to determine if it should",
                        "        // be attached to the next or previous node. In the last case,",
                        "        // simply attach the right node;",
                        "        const tieCount = tiesToBreak.length;",
                        "        if (tieCount > 0) {",
                        "          const lastTie = tiesToBreak[tieCount - 1];",
                        "          if (lastTie.followingNode !== followingNode) {",
                        "            breakTies(tiesToBreak, options);",
                        "          }",
                        "        }",
                        "        tiesToBreak.push(context);",
                        "      } else if (precedingNode) {",
                        "        addTrailingComment(precedingNode, comment);",
                        "      } else if (followingNode) {",
                        "        addLeadingComment(followingNode, comment);",
                        "      } else if (enclosingNode) {",
                        "        addDanglingComment(enclosingNode, comment);",
                        "      } else {",
                        "        // There are no nodes, let's attach it to the root of the ast",
                        "        /* c8 ignore next */",
                        "        addDanglingComment(ast, comment);",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  breakTies(tiesToBreak, options);",
                        "",
                        "  if (!avoidAstMutation) {",
                        "    for (const comment of comments) {",
                        "      // These node references were useful for breaking ties, but we",
                        "      // don't need them anymore, and they create cycles in the AST that",
                        "      // may lead to infinite recursion if we don't delete them here.",
                        "      delete comment.precedingNode;",
                        "      delete comment.enclosingNode;",
                        "      delete comment.followingNode;",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "const isAllEmptyAndNoLineBreak = (text) => !/[\\S\\n\\u2028\\u2029]/.test(text);",
                        "function isOwnLineComment(text, options, decoratedComments, commentIndex) {",
                        "  const { comment, precedingNode } = decoratedComments[commentIndex];",
                        "  const { locStart, locEnd } = options;",
                        "  let start = locStart(comment);",
                        "",
                        "  if (precedingNode) {",
                        "    // Find first comment on the same line",
                        "    for (let index = commentIndex - 1; index >= 0; index--) {",
                        "      const { comment, precedingNode: currentCommentPrecedingNode } =",
                        "        decoratedComments[index];",
                        "      if (",
                        "        currentCommentPrecedingNode !== precedingNode ||",
                        "        !isAllEmptyAndNoLineBreak(text.slice(locEnd(comment), start))",
                        "      ) {",
                        "        break;",
                        "      }",
                        "      start = locStart(comment);",
                        "    }",
                        "  }",
                        "",
                        "  return hasNewline(text, start, { backwards: true });",
                        "}",
                        "",
                        "function isEndOfLineComment(text, options, decoratedComments, commentIndex) {",
                        "  const { comment, followingNode } = decoratedComments[commentIndex];",
                        "  const { locStart, locEnd } = options;",
                        "  let end = locEnd(comment);",
                        "",
                        "  if (followingNode) {",
                        "    // Find last comment on the same line",
                        "    for (",
                        "      let index = commentIndex + 1;",
                        "      index < decoratedComments.length;",
                        "      index++",
                        "    ) {",
                        "      const { comment, followingNode: currentCommentFollowingNode } =",
                        "        decoratedComments[index];",
                        "      if (",
                        "        currentCommentFollowingNode !== followingNode ||",
                        "        !isAllEmptyAndNoLineBreak(text.slice(end, locStart(comment)))",
                        "      ) {",
                        "        break;",
                        "      }",
                        "      end = locEnd(comment);",
                        "    }",
                        "  }",
                        "",
                        "  return hasNewline(text, end);",
                        "}",
                        "",
                        "function breakTies(tiesToBreak, options) {",
                        "  const tieCount = tiesToBreak.length;",
                        "  if (tieCount === 0) {",
                        "    return;",
                        "  }",
                        "  const { precedingNode, followingNode } = tiesToBreak[0];",
                        "",
                        "  let gapEndPos = options.locStart(followingNode);",
                        "",
                        "  // Iterate backwards through tiesToBreak, examining the gaps between the tied",
                        "  // comments. In order to qualify as leading, a comment must be separated from",
                        "  // followingNode by an unbroken series of gaps (or other comments). By",
                        "  // default, gaps should only contain whitespace or open parentheses.",
                        "  // printer.isGap can be used to define custom logic for checking gaps.",
                        "  let indexOfFirstLeadingComment;",
                        "  for (",
                        "    indexOfFirstLeadingComment = tieCount;",
                        "    indexOfFirstLeadingComment > 0;",
                        "    --indexOfFirstLeadingComment",
                        "  ) {",
                        "    const {",
                        "      comment,",
                        "      precedingNode: currentCommentPrecedingNode,",
                        "      followingNode: currentCommentFollowingNode,",
                        "    } = tiesToBreak[indexOfFirstLeadingComment - 1];",
                        "    assert.strictEqual(currentCommentPrecedingNode, precedingNode);",
                        "    assert.strictEqual(currentCommentFollowingNode, followingNode);",
                        "",
                        "    const gap = options.originalText.slice(options.locEnd(comment), gapEndPos);",
                        "",
                        "    if (options.printer.isGap?.(gap, options) ?? /^[\\s(]*$/.test(gap)) {",
                        "      gapEndPos = options.locStart(comment);",
                        "    } else {",
                        "      // The gap string contained something other than whitespace or open",
                        "      // parentheses.",
                        "      break;",
                        "    }",
                        "  }",
                        "",
                        "  for (const [i, { comment }] of tiesToBreak.entries()) {",
                        "    if (i < indexOfFirstLeadingComment) {",
                        "      addTrailingComment(precedingNode, comment);",
                        "    } else {",
                        "      addLeadingComment(followingNode, comment);",
                        "    }",
                        "  }",
                        "",
                        "  for (const node of [precedingNode, followingNode]) {",
                        "    if (node.comments && node.comments.length > 1) {",
                        "      node.comments.sort((a, b) => options.locStart(a) - options.locStart(b));",
                        "    }",
                        "  }",
                        "",
                        "  tiesToBreak.length = 0;",
                        "}",
                        "",
                        "function findExpressionIndexForComment(quasis, comment, options) {",
                        "  const startPos = options.locStart(comment) - 1;",
                        "",
                        "  for (let i = 1; i < quasis.length; ++i) {",
                        "    if (startPos < options.locStart(quasis[i])) {",
                        "      return i - 1;",
                        "    }",
                        "  }",
                        "",
                        "  // We haven't found it, it probably means that some of the locations are off.",
                        "  // Let's just return the first one.",
                        "  /* c8 ignore next */",
                        "  return 0;",
                        "}",
                        "",
                        "export { attachComments, getSortedChildNodes };"
                    ]
                },
                "print.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  breakParent,",
                        "  indent,",
                        "  lineSuffix,",
                        "  join,",
                        "} from \"../../document/builders.js\";",
                        "import { inheritLabel } from \"../../document/utils.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import skipNewline from \"../../utils/skip-newline.js\";",
                        "import { skipSpaces } from \"../../utils/skip.js\";",
                        "import isPreviousLineEmpty from \"../../utils/is-previous-line-empty.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "const returnTrue = () => true;",
                        "",
                        "function printComment(path, options) {",
                        "  const comment = path.node;",
                        "  comment.printed = true;",
                        "  return options.printer.printComment(path, options);",
                        "}",
                        "",
                        "function printLeadingComment(path, options) {",
                        "  const comment = path.node;",
                        "  const parts = [printComment(path, options)];",
                        "",
                        "  const { printer, originalText, locStart, locEnd } = options;",
                        "  const isBlock = printer.isBlockComment?.(comment);",
                        "",
                        "  // Leading block comments should see if they need to stay on the",
                        "  // same line or not.",
                        "  if (isBlock) {",
                        "    const lineBreak = hasNewline(originalText, locEnd(comment))",
                        "      ? hasNewline(originalText, locStart(comment), {",
                        "          backwards: true,",
                        "        })",
                        "        ? hardline",
                        "        : line",
                        "      : \" \";",
                        "",
                        "    parts.push(lineBreak);",
                        "  } else {",
                        "    parts.push(hardline);",
                        "  }",
                        "",
                        "  const index = skipNewline(",
                        "    originalText,",
                        "    skipSpaces(originalText, locEnd(comment))",
                        "  );",
                        "",
                        "  if (index !== false && hasNewline(originalText, index)) {",
                        "    parts.push(hardline);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printTrailingComment(path, options, previousComment) {",
                        "  const comment = path.node;",
                        "  const printed = printComment(path, options);",
                        "",
                        "  const { printer, originalText, locStart } = options;",
                        "  const isBlock = printer.isBlockComment?.(comment);",
                        "",
                        "  if (",
                        "    (previousComment?.hasLineSuffix && !previousComment?.isBlock) ||",
                        "    hasNewline(originalText, locStart(comment), { backwards: true })",
                        "  ) {",
                        "    // This allows comments at the end of nested structures:",
                        "    // {",
                        "    //   x: 1,",
                        "    //   y: 2",
                        "    //   // A comment",
                        "    // }",
                        "    // Those kinds of comments are almost always leading comments, but",
                        "    // here it doesn't go \"outside\" the block and turns it into a",
                        "    // trailing comment for `2`. We can simulate the above by checking",
                        "    // if this a comment on its own line; normal trailing comments are",
                        "    // always at the end of another expression.",
                        "",
                        "    const isLineBeforeEmpty = isPreviousLineEmpty(",
                        "      originalText,",
                        "      locStart(comment)",
                        "    );",
                        "",
                        "    return {",
                        "      doc: lineSuffix([hardline, isLineBeforeEmpty ? hardline : \"\", printed]),",
                        "      isBlock,",
                        "      hasLineSuffix: true,",
                        "    };",
                        "  }",
                        "",
                        "  if (!isBlock || previousComment?.hasLineSuffix) {",
                        "    return {",
                        "      doc: [lineSuffix([\" \", printed]), breakParent],",
                        "      isBlock,",
                        "      hasLineSuffix: true,",
                        "    };",
                        "  }",
                        "",
                        "  return { doc: [\" \", printed], isBlock, hasLineSuffix: false };",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @param {{",
                        " *  indent?: boolean,",
                        " *  marker?: symbol,",
                        " *  filter?: (comment) => boolean,",
                        " * }} [danglingCommentsPrintOptions]",
                        " * @returns {Doc}",
                        " */",
                        "function printDanglingComments(",
                        "  path,",
                        "  options,",
                        "  danglingCommentsPrintOptions = {}",
                        ") {",
                        "  const { node } = path;",
                        "",
                        "  if (!isNonEmptyArray(node?.comments)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const {",
                        "    indent: shouldIndent = false,",
                        "    marker,",
                        "    filter = returnTrue,",
                        "  } = danglingCommentsPrintOptions;",
                        "",
                        "  const parts = [];",
                        "  path.each(({ node: comment }) => {",
                        "    if (",
                        "      comment.leading ||",
                        "      comment.trailing ||",
                        "      comment.marker !== marker ||",
                        "      !filter(comment)",
                        "    ) {",
                        "      return;",
                        "    }",
                        "",
                        "    parts.push(printComment(path, options));",
                        "  }, \"comments\");",
                        "",
                        "  if (parts.length === 0) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const doc = join(hardline, parts);",
                        "  return shouldIndent ? indent([hardline, doc]) : doc;",
                        "}",
                        "",
                        "function printCommentsSeparately(path, options) {",
                        "  const value = path.node;",
                        "  if (!value) {",
                        "    return {};",
                        "  }",
                        "",
                        "  const ignored = options[Symbol.for(\"printedComments\")];",
                        "  const comments = (value.comments || []).filter(",
                        "    (comment) => !ignored.has(comment)",
                        "  );",
                        "",
                        "  if (comments.length === 0) {",
                        "    return { leading: \"\", trailing: \"\" };",
                        "  }",
                        "",
                        "  const leadingParts = [];",
                        "  const trailingParts = [];",
                        "  let printedTrailingComment;",
                        "  path.each(() => {",
                        "    const comment = path.node;",
                        "    if (ignored?.has(comment)) {",
                        "      return;",
                        "    }",
                        "",
                        "    const { leading, trailing } = comment;",
                        "    if (leading) {",
                        "      leadingParts.push(printLeadingComment(path, options));",
                        "    } else if (trailing) {",
                        "      printedTrailingComment = printTrailingComment(",
                        "        path,",
                        "        options,",
                        "        printedTrailingComment",
                        "      );",
                        "      trailingParts.push(printedTrailingComment.doc);",
                        "    }",
                        "  }, \"comments\");",
                        "",
                        "  return { leading: leadingParts, trailing: trailingParts };",
                        "}",
                        "",
                        "function printComments(path, doc, options) {",
                        "  const { leading, trailing } = printCommentsSeparately(path, options);",
                        "  if (!leading && !trailing) {",
                        "    return doc;",
                        "  }",
                        "  return inheritLabel(doc, (doc) => [leading, doc, trailing]);",
                        "}",
                        "",
                        "function ensureAllCommentsPrinted(options) {",
                        "  const {",
                        "    [Symbol.for(\"comments\")]: comments,",
                        "    [Symbol.for(\"printedComments\")]: printedComments,",
                        "  } = options;",
                        "",
                        "  for (const comment of comments) {",
                        "    if (!comment.printed && !printedComments.has(comment)) {",
                        "      throw new Error(",
                        "        'Comment \"' +",
                        "          comment.value.trim() +",
                        "          '\" was not printed. Please report this error!'",
                        "      );",
                        "    }",
                        "    delete comment.printed;",
                        "  }",
                        "}",
                        "",
                        "export {",
                        "  printComments,",
                        "  printCommentsSeparately,",
                        "  printDanglingComments,",
                        "  ensureAllCommentsPrinted,",
                        "};"
                    ]
                },
                "utils.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function describeNodeForDebugging(node) {",
                        "  const nodeType = node.type || node.kind || \"(unknown type)\";",
                        "  let nodeName = String(",
                        "    node.name ||",
                        "      (node.id && (typeof node.id === \"object\" ? node.id.name : node.id)) ||",
                        "      (node.key && (typeof node.key === \"object\" ? node.key.name : node.key)) ||",
                        "      (node.value &&",
                        "        (typeof node.value === \"object\" ? \"\" : String(node.value))) ||",
                        "      node.operator ||",
                        "      \"\"",
                        "  );",
                        "  if (nodeName.length > 20) {",
                        "    nodeName = nodeName.slice(0, 19) + \"…\";",
                        "  }",
                        "  return nodeType + (nodeName ? \" \" + nodeName : \"\");",
                        "}",
                        "",
                        "function addCommentHelper(node, comment) {",
                        "  const comments = (node.comments ??= []);",
                        "  comments.push(comment);",
                        "  comment.printed = false;",
                        "  comment.nodeDescription = describeNodeForDebugging(node);",
                        "}",
                        "",
                        "function addLeadingComment(node, comment) {",
                        "  comment.leading = true;",
                        "  comment.trailing = false;",
                        "  addCommentHelper(node, comment);",
                        "}",
                        "",
                        "function addDanglingComment(node, comment, marker) {",
                        "  comment.leading = false;",
                        "  comment.trailing = false;",
                        "  if (marker) {",
                        "    comment.marker = marker;",
                        "  }",
                        "  addCommentHelper(node, comment);",
                        "}",
                        "",
                        "function addTrailingComment(node, comment) {",
                        "  comment.leading = false;",
                        "  comment.trailing = true;",
                        "  addCommentHelper(node, comment);",
                        "}",
                        "",
                        "export { addLeadingComment, addDanglingComment, addTrailingComment };"
                    ]
                }
            },
            "plugins": {
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { clearCache as clearPluginLoadCache } from \"./load-plugin.js\";",
                        "import { clearCache as clearPluginSearchCache } from \"./search-plugins.js\";",
                        "",
                        "export function clearCache() {",
                        "  clearPluginLoadCache();",
                        "  clearPluginSearchCache();",
                        "}",
                        "export { default as loadBuiltinPlugins } from \"./load-builtin-plugins.js\";",
                        "export { default as loadPlugins } from \"./load-plugins.js\";",
                        "export { searchPlugins } from \"./search-plugins.js\";"
                    ]
                },
                "load-builtin-plugins.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "let builtinPlugins;",
                        "",
                        "async function loadBuiltinPlugins() {",
                        "  builtinPlugins ??= await Promise.all([",
                        "    import(\"../../plugins/estree.js\"),",
                        "    import(\"../../plugins/babel.js\"),",
                        "    import(\"../../plugins/flow.js\"),",
                        "    import(\"../../plugins/typescript.js\"),",
                        "    import(\"../../plugins/acorn.js\"),",
                        "    import(\"../../plugins/meriyah.js\"),",
                        "    import(\"../../plugins/angular.js\"),",
                        "    import(\"../../plugins/postcss.js\"),",
                        "    import(\"../../plugins/graphql.js\"),",
                        "    import(\"../../plugins/markdown.js\"),",
                        "    import(\"../../plugins/glimmer.js\"),",
                        "    import(\"../../plugins/html.js\"),",
                        "    import(\"../../plugins/yaml.js\"),",
                        "  ]);",
                        "",
                        "  return builtinPlugins;",
                        "}",
                        "",
                        "export default loadBuiltinPlugins;"
                    ]
                },
                "load-plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { pathToFileURL } from \"node:url\";",
                        "import path from \"node:path\";",
                        "import mem, { memClear } from \"mem\";",
                        "import importFromDirectory from \"../../utils/import-from-directory.js\";",
                        "",
                        "function normalizePlugin(pluginInstanceOfPluginModule, name) {",
                        "  const plugin =",
                        "    pluginInstanceOfPluginModule.default ?? pluginInstanceOfPluginModule;",
                        "  return { name, ...plugin };",
                        "}",
                        "",
                        "const loadPluginFromDirectory = mem(",
                        "  async (name, directory) =>",
                        "    normalizePlugin(await importFromDirectory(name, directory), name),",
                        "  { cacheKey: JSON.stringify }",
                        ");",
                        "",
                        "const importPlugin = mem(async (name) => {",
                        "  try {",
                        "    // try local files",
                        "    return await import(pathToFileURL(path.resolve(name)).href);",
                        "  } catch {",
                        "    // try node modules",
                        "    return importFromDirectory(name, process.cwd());",
                        "  }",
                        "});",
                        "",
                        "async function loadPlugin(plugin) {",
                        "  if (typeof plugin === \"string\") {",
                        "    return normalizePlugin(await importPlugin(plugin), plugin);",
                        "  }",
                        "",
                        "  return plugin;",
                        "}",
                        "",
                        "function clearCache() {",
                        "  memClear(loadPluginFromDirectory);",
                        "  memClear(importPlugin);",
                        "}",
                        "",
                        "export { loadPlugin, loadPluginFromDirectory, clearCache };"
                    ]
                },
                "load-plugins.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { loadPlugin } from \"./load-plugin.js\";",
                        "",
                        "function loadPlugins(plugins = []) {",
                        "  return Promise.all(plugins.map((plugin) => loadPlugin(plugin)));",
                        "}",
                        "",
                        "export default loadPlugins;"
                    ]
                },
                "search-plugins.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import path from \"node:path\";",
                        "import { fileURLToPath } from \"node:url\";",
                        "import mem, { memClear } from \"mem\";",
                        "import fastGlob from \"fast-glob\";",
                        "import isDirectory from \"../../utils/is-directory.js\";",
                        "import mockable from \"../../common/mockable.js\";",
                        "import { loadPluginFromDirectory } from \"./load-plugin.js\";",
                        "",
                        "const __dirname = path.dirname(fileURLToPath(import.meta.url));",
                        "",
                        "const findNodeModules = mem((directory) =>",
                        "  mockable.findParentDir(directory, \"node_modules\")",
                        ");",
                        "",
                        "const findPluginsInNodeModules = mem(async (nodeModulesDir) => {",
                        "  const pluginPackageJsonPaths = await fastGlob(",
                        "    [",
                        "      \"prettier-plugin-*/package.json\",",
                        "      \"@*/prettier-plugin-*/package.json\",",
                        "      \"@prettier/plugin-*/package.json\",",
                        "    ],",
                        "    {",
                        "      cwd: nodeModulesDir,",
                        "    }",
                        "  );",
                        "  return pluginPackageJsonPaths.map(path.dirname);",
                        "});",
                        "",
                        "const searchPluginsInDirectory = mem(async (directory) => {",
                        "  const absolutePath = path.resolve(process.cwd(), directory);",
                        "  const nodeModulesDir = path.join(absolutePath, \"node_modules\");",
                        "",
                        "  // In some fringe cases (ex: files \"mounted\" as virtual directories), the",
                        "  // isDirectory(absolutePath) check might be false even though",
                        "  // the node_modules actually exists.",
                        "  if (",
                        "    !(await isDirectory(nodeModulesDir)) &&",
                        "    !(await isDirectory(absolutePath))",
                        "  ) {",
                        "    throw new Error(`${directory} does not exist or is not a directory`);",
                        "  }",
                        "",
                        "  const pluginNames = await findPluginsInNodeModules(nodeModulesDir);",
                        "",
                        "  return Promise.all(",
                        "    pluginNames.map((name) => loadPluginFromDirectory(name, nodeModulesDir))",
                        "  );",
                        "});",
                        "",
                        "const searchPlugins = mem(",
                        "  async (directories = []) => {",
                        "    // unless pluginSearchDirs are provided, auto-load plugins from node_modules that are parent to Prettier",
                        "    if (directories.length === 0) {",
                        "      const nodeModulesDirectory = findNodeModules(__dirname);",
                        "      if (nodeModulesDirectory) {",
                        "        directories = [nodeModulesDirectory];",
                        "      }",
                        "    }",
                        "",
                        "    return (",
                        "      await Promise.all(",
                        "        directories.map((directory) => searchPluginsInDirectory(directory))",
                        "      )",
                        "    ).flat();",
                        "  },",
                        "  { cacheKey: JSON.stringify }",
                        ");",
                        "",
                        "function clearCache() {",
                        "  memClear(searchPlugins);",
                        "  memClear(searchPluginsInDirectory);",
                        "  memClear(findPluginsInNodeModules);",
                        "  memClear(findNodeModules);",
                        "}",
                        "",
                        "export { searchPlugins, clearCache };"
                    ]
                }
            }
        },
        "plugins": {
            "acorn.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/acorn.js\"),",
                    "    parserNames: [\"acorn\"],",
                    "  },",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/espree.js\"),",
                    "    parserNames: [\"espree\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "angular.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/angular.js\"),",
                    "    parserNames: [",
                    "      \"__ng_action\",",
                    "      \"__ng_binding\",",
                    "      \"__ng_interpolation\",",
                    "      \"__ng_directive\",",
                    "    ],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "babel.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: async () =>",
                    "      (await import(\"../language-js/parse/babel.js\")).default,",
                    "    parserNames: [",
                    "      \"babel\",",
                    "      \"babel-flow\",",
                    "      \"babel-ts\",",
                    "      \"__js_expression\",",
                    "      \"__ts_expression\",",
                    "      \"__vue_expression\",",
                    "      \"__vue_ts_expression\",",
                    "      \"__vue_event_binding\",",
                    "      \"__vue_ts_event_binding\",",
                    "      \"__babel_estree\",",
                    "    ],",
                    "  },",
                    "  // JSON parsers are based on babel, bundle together to reduce package size",
                    "  {",
                    "    importParsers: async () =>",
                    "      (await import(\"../language-json/parser-json.js\")).default,",
                    "    parserNames: [\"json\", \"json5\", \"json-stringify\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "estree.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as estreePrinter from \"../language-js/printer-estree.js\";",
                    "import jsLanguages from \"../language-js/languages.evaluate.js\";",
                    "import * as estreeJsonPrinter from \"../language-json/printer-estree-json.js\";",
                    "import jsonLanguages from \"../language-json/languages.evaluate.js\";",
                    "import options from \"../language-js/options.js\";",
                    "",
                    "export const printers = {",
                    "  estree: estreePrinter,",
                    "  \"estree-json\": estreeJsonPrinter,",
                    "};",
                    "export const languages = [...jsLanguages, ...jsonLanguages];",
                    "export { options };",
                    "export default { printers, languages, options };"
                ]
            },
            "flow.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/flow.js\"),",
                    "    parserNames: [\"flow\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-handlebars/index.js\";",
                    "export * as default from \"../language-handlebars/index.js\";"
                ]
            },
            "graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-graphql/index.js\";",
                    "export * as default from \"../language-graphql/index.js\";"
                ]
            },
            "html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-html/index.js\";",
                    "export * as default from \"../language-html/index.js\";"
                ]
            },
            "markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-markdown/index.js\";",
                    "export * as default from \"../language-markdown/index.js\";"
                ]
            },
            "meriyah.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/meriyah.js\"),",
                    "    parserNames: [\"meriyah\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-css/index.js\";",
                    "export * as default from \"../language-css/index.js\";"
                ]
            },
            "typescript.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/typescript.js\"),",
                    "    parserNames: [\"typescript\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-yaml/index.js\";",
                    "export * as default from \"../language-yaml/index.js\";"
                ]
            }
        },
        "utils": {
            "ast-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isObject from \"./is-object.js\";",
                    "",
                    "/**",
                    " * @typedef {NonNullable<object>} Node",
                    " * @typedef {(unknown) => string[]} GetVisitorKeys",
                    " * @typedef {(unknown) => boolean} Predicate",
                    " */",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @param {{getVisitorKeys: GetVisitorKeys, filter?: Predicate}} options",
                    " */",
                    "function* getChildren(node, options) {",
                    "  const { getVisitorKeys, filter = () => true } = options;",
                    "  const isMatchedNode = (node) => isObject(node) && filter(node);",
                    "",
                    "  for (const key of getVisitorKeys(node)) {",
                    "    const value = node[key];",
                    "",
                    "    if (Array.isArray(value)) {",
                    "      for (const child of value) {",
                    "        if (isMatchedNode(child)) {",
                    "          yield child;",
                    "        }",
                    "      }",
                    "    } else if (isMatchedNode(value)) {",
                    "      yield value;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @param {{getVisitorKeys: GetVisitorKeys, filter?: Predicate}} options",
                    " */",
                    "function* getDescendants(node, options) {",
                    "  const queue = [node];",
                    "  for (let index = 0; index < queue.length; index++) {",
                    "    const node = queue[index];",
                    "",
                    "    for (const child of getChildren(node, options)) {",
                    "      yield child;",
                    "      queue.push(child);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @param {{getVisitorKeys: GetVisitorKeys, predicate: Predicate}} options",
                    " */",
                    "function hasDescendant(node, { getVisitorKeys, predicate }) {",
                    "  for (const descendant of getDescendants(node, { getVisitorKeys })) {",
                    "    if (predicate(descendant)) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "export { hasDescendant, getDescendants, getChildren };"
                ]
            },
            "create-get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import toFastProperties from \"to-fast-properties\";",
                    "",
                    "function createGetVisitorKeys(visitorKeys, typeProperty = \"type\") {",
                    "  toFastProperties(visitorKeys);",
                    "",
                    "  function getVisitorKeys(node) {",
                    "    const type = node[typeProperty];",
                    "",
                    "    /* c8 ignore next 5 */",
                    "    if (process.env.NODE_ENV !== \"production\" && type === undefined) {",
                    "      throw new Error(",
                    "        `Can't get node type, you must pass the wrong typeProperty '${typeProperty}'`",
                    "      );",
                    "    }",
                    "",
                    "    const keys = visitorKeys[type];",
                    "    /* c8 ignore next 5 */",
                    "    if (!Array.isArray(keys)) {",
                    "      throw Object.assign(new Error(`Missing visitor keys for '${type}'.`), {",
                    "        node,",
                    "      });",
                    "    }",
                    "",
                    "    return keys;",
                    "  }",
                    "",
                    "  return getVisitorKeys;",
                    "}",
                    "",
                    "export default createGetVisitorKeys;"
                ]
            },
            "create-group-id-mapper.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {string} description",
                    " * @returns {(node: any) => symbol}",
                    " */",
                    "function createGroupIdMapper(description) {",
                    "  const groupIds = new WeakMap();",
                    "  return function (node) {",
                    "    if (!groupIds.has(node)) {",
                    "      groupIds.set(node, Symbol(description));",
                    "    }",
                    "    return groupIds.get(node);",
                    "  };",
                    "}",
                    "",
                    "export default createGroupIdMapper;"
                ]
            },
            "create-language.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function createLanguage(linguistData, override) {",
                    "  const { languageId, ...rest } = linguistData;",
                    "  return {",
                    "    linguistLanguageId: languageId,",
                    "    ...rest,",
                    "    ...override(linguistData),",
                    "  };",
                    "}",
                    "",
                    "export default createLanguage;"
                ]
            },
            "create-parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function createParsers(modules) {",
                    "  const parsers = Object.create(null);",
                    "",
                    "  for (const { importParsers, parserNames } of modules) {",
                    "    for (const parserName of parserNames) {",
                    "      parsers[parserName] = async () =>",
                    "        Object.assign(parsers, await importParsers())[parserName];",
                    "    }",
                    "  }",
                    "",
                    "  return parsers;",
                    "}",
                    "",
                    "export default createParsers;"
                ]
            },
            "get-alignment-size.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {string} text",
                    " * @param {number} tabWidth",
                    " * @param {number=} startIndex",
                    " * @returns {number}",
                    " */",
                    "function getAlignmentSize(text, tabWidth, startIndex = 0) {",
                    "  let size = 0;",
                    "  for (let i = startIndex; i < text.length; ++i) {",
                    "    if (text[i] === \"\\t\") {",
                    "      // Tabs behave in a way that they are aligned to the nearest",
                    "      // multiple of tabWidth:",
                    "      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4",
                    "      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...",
                    "      size = size + tabWidth - (size % tabWidth);",
                    "    } else {",
                    "      size++;",
                    "    }",
                    "  }",
                    "",
                    "  return size;",
                    "}",
                    "",
                    "export default getAlignmentSize;"
                ]
            },
            "get-indent-size.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getAlignmentSize from \"./get-alignment-size.js\";",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @param {number} tabWidth",
                    " * @returns {number}",
                    " */",
                    "function getIndentSize(value, tabWidth) {",
                    "  const lastNewlineIndex = value.lastIndexOf(\"\\n\");",
                    "  /* c8 ignore next 3 */",
                    "  if (lastNewlineIndex === -1) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return getAlignmentSize(",
                    "    // All the leading whitespaces",
                    "    value.slice(lastNewlineIndex + 1).match(/^[\\t ]*/)[0],",
                    "    tabWidth",
                    "  );",
                    "}",
                    "",
                    "export default getIndentSize;"
                ]
            },
            "get-interpreter.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs\";",
                    "import readlines from \"n-readlines\";",
                    "",
                    "function getInterpreter(filepath) {",
                    "  /* c8 ignore next 3 */",
                    "  if (typeof filepath !== \"string\") {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  let fd;",
                    "  try {",
                    "    fd = fs.openSync(filepath, \"r\");",
                    "  } catch {",
                    "    /* c8 ignore next */",
                    "    return \"\";",
                    "  }",
                    "",
                    "  try {",
                    "    const liner = new readlines(fd);",
                    "    const firstLine = liner.next().toString(\"utf8\");",
                    "",
                    "    // #!/bin/env node, #!/usr/bin/env node",
                    "    const m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);",
                    "    if (m1) {",
                    "      return m1[1];",
                    "    }",
                    "",
                    "    // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node",
                    "    const m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);",
                    "    if (m2) {",
                    "      return m2[1];",
                    "    }",
                    "    return \"\";",
                    "  } catch {",
                    "    // There are some weird cases where paths are missing, causing Jest",
                    "    // failures. It's unclear what these correspond to in the real world.",
                    "    /* c8 ignore next */",
                    "    return \"\";",
                    "  } finally {",
                    "    try {",
                    "      // There are some weird cases where paths are missing, causing Jest",
                    "      // failures. It's unclear what these correspond to in the real world.",
                    "      fs.closeSync(fd);",
                    "    } catch {",
                    "      // nop",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "export default getInterpreter;"
                ]
            },
            "get-max-continuous-count.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import escapeStringRegexp from \"escape-string-regexp\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {string} searchString",
                    " * @returns {number}",
                    " */",
                    "function getMaxContinuousCount(text, searchString) {",
                    "  const results = text.match(",
                    "    new RegExp(`(${escapeStringRegexp(searchString)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (results === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return results.reduce(",
                    "    (maxCount, result) =>",
                    "      Math.max(maxCount, result.length / searchString.length),",
                    "    0",
                    "  );",
                    "}",
                    "",
                    "export default getMaxContinuousCount;"
                ]
            },
            "get-min-not-present-continuous-count.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import escapeStringRegexp from \"escape-string-regexp\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {string} searchString",
                    " * @returns {number}",
                    " */",
                    "function getMinNotPresentContinuousCount(text, searchString) {",
                    "  const matches = text.match(",
                    "    new RegExp(`(${escapeStringRegexp(searchString)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (matches === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  const countPresent = new Map();",
                    "  let max = 0;",
                    "",
                    "  for (const match of matches) {",
                    "    const count = match.length / searchString.length;",
                    "    countPresent.set(count, true);",
                    "    if (count > max) {",
                    "      max = count;",
                    "    }",
                    "  }",
                    "",
                    "  for (let i = 1; i < max; i++) {",
                    "    if (!countPresent.get(i)) {",
                    "      return i;",
                    "    }",
                    "  }",
                    "",
                    "  return max + 1;",
                    "}",
                    "",
                    "export default getMinNotPresentContinuousCount;"
                ]
            },
            "get-next-non-space-non-comment-character-index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import skipInlineComment from \"./skip-inline-comment.js\";",
                    "import skipNewline from \"./skip-newline.js\";",
                    "import skipTrailingComment from \"./skip-trailing-comment.js\";",
                    "import { skipSpaces } from \"./skip.js\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {number | false}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacterIndex(text, startIndex) {",
                    "  /** @type {number | false} */",
                    "  let oldIdx = null;",
                    "  /** @type {number | false} */",
                    "  let nextIdx = startIndex;",
                    "  while (nextIdx !== oldIdx) {",
                    "    oldIdx = nextIdx;",
                    "    nextIdx = skipSpaces(text, nextIdx);",
                    "    nextIdx = skipInlineComment(text, nextIdx);",
                    "    nextIdx = skipTrailingComment(text, nextIdx);",
                    "    nextIdx = skipNewline(text, nextIdx);",
                    "  }",
                    "  return nextIdx;",
                    "}",
                    "",
                    "export default getNextNonSpaceNonCommentCharacterIndex;"
                ]
            },
            "get-next-non-space-non-comment-character.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getNextNonSpaceNonCommentCharacterIndex from \"./get-next-non-space-non-comment-character-index.js\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {string}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacter(text, startIndex) {",
                    "  const index = getNextNonSpaceNonCommentCharacterIndex(text, startIndex);",
                    "  return index === false ? \"\" : text.charAt(index);",
                    "}",
                    "",
                    "export default getNextNonSpaceNonCommentCharacter;"
                ]
            },
            "get-preferred-quote.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @typedef {SINGLE_QUOTE | DOUBLE_QUOTE} Quote",
                    " */",
                    "",
                    "const SINGLE_QUOTE = \"'\";",
                    "const DOUBLE_QUOTE = '\"';",
                    "",
                    "/**",
                    " *",
                    " * @param {string} rawContent",
                    " * @param {Quote | boolean} preferredQuoteOrPreferSingleQuote",
                    " * @returns {Quote}",
                    " */",
                    "function getPreferredQuote(rawContent, preferredQuoteOrPreferSingleQuote) {",
                    "  const preferred =",
                    "    preferredQuoteOrPreferSingleQuote === true ||",
                    "    preferredQuoteOrPreferSingleQuote === SINGLE_QUOTE",
                    "      ? SINGLE_QUOTE",
                    "      : DOUBLE_QUOTE;",
                    "  const alternate = preferred === SINGLE_QUOTE ? DOUBLE_QUOTE : SINGLE_QUOTE;",
                    "",
                    "  let preferredQuoteCount = 0;",
                    "  let alternateQuoteCount = 0;",
                    "  for (const character of rawContent) {",
                    "    if (character === preferred) {",
                    "      preferredQuoteCount++;",
                    "    } else if (character === alternate) {",
                    "      alternateQuoteCount++;",
                    "    }",
                    "  }",
                    "",
                    "  return preferredQuoteCount > alternateQuoteCount ? alternate : preferred;",
                    "}",
                    "",
                    "export default getPreferredQuote;"
                ]
            },
            "get-string-width.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import stringWidth from \"string-width\";",
                    "",
                    "const notAsciiRegex = /[^\\x20-\\x7F]/;",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @returns {number}",
                    " */",
                    "function getStringWidth(text) {",
                    "  if (!text) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`",
                    "  if (!notAsciiRegex.test(text)) {",
                    "    return text.length;",
                    "  }",
                    "",
                    "  return stringWidth(text);",
                    "}",
                    "",
                    "export default getStringWidth;"
                ]
            },
            "has-newline-in-range.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @param {number} endIndex",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewlineInRange(text, startIndex, endIndex) {",
                    "  for (let i = startIndex; i < endIndex; ++i) {",
                    "    if (text.charAt(i) === \"\\n\") {",
                    "      return true;",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "export default hasNewlineInRange;"
                ]
            },
            "has-newline.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { skipSpaces } from \"./skip.js\";",
                    "import skipNewline from \"./skip-newline.js\";",
                    "",
                    "/** @typedef {import(\"./skip.js\").SkipOptions} SkipOptions */",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @param {SkipOptions=} options",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewline(text, startIndex, options = {}) {",
                    "  const idx = skipSpaces(",
                    "    text,",
                    "    options.backwards ? startIndex - 1 : startIndex,",
                    "    options",
                    "  );",
                    "  const idx2 = skipNewline(text, idx, options);",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "export default hasNewline;"
                ]
            },
            "has-spaces.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { skipSpaces } from \"./skip.js\";",
                    "",
                    "/** @typedef {import(\"./skip.js\").SkipOptions} SkipOptions */",
                    "",
                    "// Not using, but it's public utils",
                    "/* c8 ignore start */",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @param {SkipOptions=} options",
                    " * @returns {boolean}",
                    " */",
                    "function hasSpaces(text, startIndex, options = {}) {",
                    "  const idx = skipSpaces(",
                    "    text,",
                    "    options.backwards ? startIndex - 1 : startIndex,",
                    "    options",
                    "  );",
                    "  return idx !== startIndex;",
                    "}",
                    "/* c8 ignore stop */",
                    "",
                    "export default hasSpaces;"
                ]
            },
            "html-whitespace-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import WhitespaceUtils from \"./whitespace-utils.js\";",
                    "",
                    "// https://infra.spec.whatwg.org/#ascii-whitespace",
                    "const HTML_WHITESPACE_CHARACTERS = [\"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"];",
                    "const htmlWhitespaceUtils = new WhitespaceUtils(HTML_WHITESPACE_CHARACTERS);",
                    "",
                    "export default htmlWhitespaceUtils;"
                ]
            },
            "ignore.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import ignoreModule from \"ignore\";",
                    "import readFile from \"../utils/read-file.js\";",
                    "",
                    "const createIgnore = ignoreModule.default;",
                    "const slash =",
                    "  path.sep === \"\\\\\"",
                    "    ? (filepath) => filepath.replaceAll(\"\\\\\", \"/\")",
                    "    : (filepath) => filepath;",
                    "",
                    "/**",
                    " * @param {string?} ignoreFilePath",
                    " * @param {boolean?} withNodeModules",
                    " * @returns {Promise<(string) => boolean>}",
                    " */",
                    "async function createSingleIsIgnoredFunction(ignoreFilePath, withNodeModules) {",
                    "  let content = \"\";",
                    "",
                    "  if (ignoreFilePath) {",
                    "    content += (await readFile(ignoreFilePath)) ?? \"\";",
                    "  }",
                    "",
                    "  if (!withNodeModules) {",
                    "    content += \"\\n\" + \"node_modules\";",
                    "  }",
                    "",
                    "  if (!content) {",
                    "    return;",
                    "  }",
                    "",
                    "  const ignore = createIgnore({ allowRelativePaths: true }).add(content);",
                    "",
                    "  return (filepath) => {",
                    "    filepath = path.resolve(filepath);",
                    "",
                    "    // If there's an ignore-path set, the filename must be relative to the",
                    "    // ignore path, not the current working directory.",
                    "    const relativePath = ignoreFilePath",
                    "      ? path.relative(path.dirname(ignoreFilePath), filepath)",
                    "      : path.relative(process.cwd(), filepath);",
                    "",
                    "    return ignore.ignores(slash(relativePath));",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {string[]} ignoreFilePaths",
                    " * @param {boolean?} withNodeModules",
                    " * @returns {Promise<(string) => boolean>}",
                    " */",
                    "async function createIsIgnoredFunction(ignoreFilePaths, withNodeModules) {",
                    "  // If `ignoreFilePaths` is empty, we still want `withNodeModules` to work",
                    "  if (ignoreFilePaths.length === 0 && !withNodeModules) {",
                    "    ignoreFilePaths = [undefined];",
                    "  }",
                    "",
                    "  const isIgnoredFunctions = (",
                    "    await Promise.all(",
                    "      ignoreFilePaths.map((ignoreFilePath) =>",
                    "        createSingleIsIgnoredFunction(ignoreFilePath, withNodeModules)",
                    "      )",
                    "    )",
                    "  ).filter(Boolean);",
                    "",
                    "  return (filepath) =>",
                    "    isIgnoredFunctions.some((isIgnored) => isIgnored(filepath));",
                    "}",
                    "",
                    "/**",
                    " * @param {string[]} filepath",
                    " * @param {{ignorePath: string[], withNodeModules?: boolean}} options",
                    " * @returns {Promise<boolean>}",
                    " */",
                    "async function isIgnored(filepath, options) {",
                    "  const { ignorePath, withNodeModules } = options;",
                    "  const isIgnored = await createIsIgnoredFunction(ignorePath, withNodeModules);",
                    "  return isIgnored(filepath);",
                    "}",
                    "",
                    "export { createIsIgnoredFunction, isIgnored };"
                ]
            },
            "import-from-directory.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import importFromFile from \"./import-from-file.js\";",
                    "",
                    "function importFromDirectory(specifier, directory) {",
                    "  return importFromFile(specifier, path.join(directory, \"noop.js\"));",
                    "}",
                    "",
                    "export default importFromDirectory;"
                ]
            },
            "import-from-file.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { pathToFileURL } from \"node:url\";",
                    "// TODO: Use `import.meta.resolve` when it's available",
                    "import { resolve } from \"import-meta-resolve\";",
                    "",
                    "async function importFromFile(specifier, parent) {",
                    "  const url = await resolve(specifier, pathToFileURL(parent).href);",
                    "  return import(url);",
                    "}",
                    "",
                    "export default importFromFile;"
                ]
            },
            "infer-parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getInterpreter from \"./get-interpreter.js\";",
                    "",
                    "// Didn't use `path.basename` since this module need work in browsers too",
                    "const getFileBasename = (file) => file.split(/[/\\\\]/).pop();",
                    "",
                    "function getLanguageByFilename(languages, filename) {",
                    "  if (!filename) {",
                    "    return;",
                    "  }",
                    "",
                    "  const basename = getFileBasename(filename).toLowerCase();",
                    "",
                    "  return languages.find(",
                    "    (language) =>",
                    "      language.extensions?.some((extension) => basename.endsWith(extension)) ||",
                    "      language.filenames?.some((name) => name.toLowerCase() === basename)",
                    "  );",
                    "}",
                    "",
                    "function getLanguageByName(languages, languageName) {",
                    "  if (!languageName) {",
                    "    return;",
                    "  }",
                    "",
                    "  return (",
                    "    languages.find(({ name }) => name.toLowerCase() === languageName) ??",
                    "    languages.find(({ aliases }) => aliases?.includes(languageName)) ??",
                    "    languages.find(({ extensions }) => extensions?.includes(`.${languageName}`))",
                    "  );",
                    "}",
                    "",
                    "function getLanguageByInterpreter(languages, file) {",
                    "  if (",
                    "    process.env.PRETTIER_TARGET === \"universal\" ||",
                    "    !file ||",
                    "    getFileBasename(file).includes(\".\")",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  const interpreter = getInterpreter(file);",
                    "",
                    "  if (!interpreter) {",
                    "    return;",
                    "  }",
                    "",
                    "  return languages.find((language) =>",
                    "    language.interpreters?.includes(interpreter)",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {import(\"../index.js\").Options} options",
                    " * @param {{physicalFile?: string, file?: string, language?: string}} fileInfo",
                    " * @returns {string | void} matched parser name if found",
                    " */",
                    "function inferParser(options, fileInfo) {",
                    "  const languages = options.plugins.flatMap(",
                    "    (plugin) =>",
                    "      // @ts-expect-error -- Safe",
                    "      plugin.languages ?? []",
                    "  );",
                    "",
                    "  // If the file has no extension, we can try to infer the language from the",
                    "  // interpreter in the shebang line, if any; but since this requires FS access,",
                    "  // do it last.",
                    "  const language =",
                    "    getLanguageByName(languages, fileInfo.language) ??",
                    "    getLanguageByFilename(languages, fileInfo.physicalFile) ??",
                    "    getLanguageByFilename(languages, fileInfo.file) ??",
                    "    getLanguageByInterpreter(languages, fileInfo.physicalFile);",
                    "",
                    "  return language?.parsers[0];",
                    "}",
                    "",
                    "export default inferParser;"
                ]
            },
            "is-directory.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "",
                    "async function isDirectory(directory) {",
                    "  let stat;",
                    "",
                    "  try {",
                    "    stat = await fs.stat(directory);",
                    "  } catch {",
                    "    return false;",
                    "  }",
                    "",
                    "  return stat.isDirectory();",
                    "}",
                    "",
                    "export default isDirectory;"
                ]
            },
            "is-next-line-empty.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import skipNewline from \"./skip-newline.js\";",
                    "import { skipSpaces, skipToLineEnd } from \"./skip.js\";",
                    "import skipInlineComment from \"./skip-inline-comment.js\";",
                    "import skipTrailingComment from \"./skip-trailing-comment.js\";",
                    "import hasNewline from \"./has-newline.js\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {boolean}",
                    " */",
                    "function isNextLineEmpty(text, startIndex) {",
                    "  /** @type {number | false} */",
                    "  let oldIdx = null;",
                    "  /** @type {number | false} */",
                    "  let idx = startIndex;",
                    "  while (idx !== oldIdx) {",
                    "    // We need to skip all the potential trailing inline comments",
                    "    oldIdx = idx;",
                    "    idx = skipToLineEnd(text, idx);",
                    "    idx = skipInlineComment(text, idx);",
                    "    idx = skipSpaces(text, idx);",
                    "  }",
                    "  idx = skipTrailingComment(text, idx);",
                    "  idx = skipNewline(text, idx);",
                    "  return idx !== false && hasNewline(text, idx);",
                    "}",
                    "",
                    "export default isNextLineEmpty;"
                ]
            },
            "is-non-empty-array.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {unknown} object",
                    " * @returns {object is Array<any>}",
                    " */",
                    "function isNonEmptyArray(object) {",
                    "  return Array.isArray(object) && object.length > 0;",
                    "}",
                    "",
                    "export default isNonEmptyArray;"
                ]
            },
            "is-object.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {unknown} object",
                    " * @returns {object is NonNullable<object>}",
                    " */",
                    "function isObject(object) {",
                    "  return object !== null && typeof object === \"object\";",
                    "}",
                    "",
                    "export default isObject;"
                ]
            },
            "is-previous-line-empty.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import skipNewline from \"./skip-newline.js\";",
                    "import { skipSpaces } from \"./skip.js\";",
                    "",
                    "// Note: this function doesn't ignore leading comments unlike isNextLineEmpty",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {boolean}",
                    " */",
                    "function isPreviousLineEmpty(text, startIndex) {",
                    "  /** @type {number | false} */",
                    "  let idx = startIndex - 1;",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  idx = skipNewline(text, idx, { backwards: true });",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  const idx2 = skipNewline(text, idx, { backwards: true });",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "export default isPreviousLineEmpty;"
                ]
            },
            "line-column-to-index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// Super inefficient, needs to be cached.",
                    "function lineColumnToIndex(lineColumn, text) {",
                    "  let index = 0;",
                    "  for (let i = 0; i < lineColumn.line - 1; ++i) {",
                    "    index = text.indexOf(\"\\n\", index) + 1;",
                    "  }",
                    "  return index + lineColumn.column;",
                    "}",
                    "",
                    "export default lineColumnToIndex;"
                ]
            },
            "make-string.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/** @typedef {import(\"./get-preferred-quote.js\").Quote} Quote */",
                    "",
                    "/**",
                    " * @param {string} rawText",
                    " * @param {Quote} enclosingQuote",
                    " * @param {boolean=} unescapeUnnecessaryEscapes",
                    " * @returns {string}",
                    " */",
                    "function makeString(rawText, enclosingQuote, unescapeUnnecessaryEscapes) {",
                    "  const otherQuote = enclosingQuote === '\"' ? \"'\" : '\"';",
                    "",
                    "  // Matches _any_ escape and unescaped quotes (both single and double).",
                    "  const regex = /\\\\(.)|([\"'])/gs;",
                    "",
                    "  // Escape and unescape single and double quotes as needed to be able to",
                    "  // enclose `rawText` with `enclosingQuote`.",
                    "  const raw = rawText.replaceAll(regex, (match, escaped, quote) => {",
                    "    // If we matched an escape, and the escaped character is a quote of the",
                    "    // other type than we intend to enclose the string with, there's no need for",
                    "    // it to be escaped, so return it _without_ the backslash.",
                    "    if (escaped === otherQuote) {",
                    "      return escaped;",
                    "    }",
                    "",
                    "    // If we matched an unescaped quote and it is of the _same_ type as we",
                    "    // intend to enclose the string with, it must be escaped, so return it with",
                    "    // a backslash.",
                    "    if (quote === enclosingQuote) {",
                    "      return \"\\\\\" + quote;",
                    "    }",
                    "",
                    "    if (quote) {",
                    "      return quote;",
                    "    }",
                    "",
                    "    // Unescape any unnecessarily escaped character.",
                    "    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27",
                    "    return unescapeUnnecessaryEscapes &&",
                    "      /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(escaped)",
                    "      ? escaped",
                    "      : \"\\\\\" + escaped;",
                    "  });",
                    "",
                    "  return enclosingQuote + raw + enclosingQuote;",
                    "}",
                    "",
                    "export default makeString;"
                ]
            },
            "object-omit.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function omit(object, keys) {",
                    "  keys = new Set(keys);",
                    "  return Object.fromEntries(",
                    "    Object.entries(object).filter(([key]) => !keys.has(key))",
                    "  );",
                    "}",
                    "",
                    "export default omit;"
                ]
            },
            "partition.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @template Element",
                    " * @param {Array<Element>} array",
                    " * @param {(value: Element) => boolean} predicate",
                    " * @returns {[Array<Element>, Array<Element>]}",
                    " */",
                    "function partition(array, predicate) {",
                    "  /** @type {[Array<Element>, Array<Element>]} */",
                    "  const result = [[], []];",
                    "",
                    "  for (const value of array) {",
                    "    result[predicate(value) ? 0 : 1].push(value);",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "export default partition;"
                ]
            },
            "print-number.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function printNumber(rawNumber) {",
                    "  return (",
                    "    rawNumber",
                    "      .toLowerCase()",
                    "      // Remove unnecessary plus and zeroes from scientific notation.",
                    "      .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(?=\\d)/, \"$1$2\")",
                    "      // Remove unnecessary scientific notation (1e0).",
                    "      .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\")",
                    "      // Make sure numbers always start with a digit.",
                    "      .replace(/^([+-])?\\./, \"$10.\")",
                    "      // Remove extraneous trailing decimal zeroes.",
                    "      .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\")",
                    "      // Remove trailing dot.",
                    "      .replace(/\\.(?=e|$)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "export default printNumber;"
                ]
            },
            "print-string.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getPreferredQuote from \"./get-preferred-quote.js\";",
                    "import makeString from \"./make-string.js\";",
                    "",
                    "/** @typedef {import(\"./get-preferred-quote.js\").Quote} Quote */",
                    "",
                    "function printString(raw, options) {",
                    "  // `rawContent` is the string exactly like it appeared in the input source",
                    "  // code, without its enclosing quotes.",
                    "  const rawContent = raw.slice(1, -1);",
                    "",
                    "  /** @type {Quote} */",
                    "  const enclosingQuote =",
                    "    options.parser === \"json\" ||",
                    "    (options.parser === \"json5\" &&",
                    "      options.quoteProps === \"preserve\" &&",
                    "      !options.singleQuote)",
                    "      ? '\"'",
                    "      : options.__isInHtmlAttribute",
                    "      ? \"'\"",
                    "      : getPreferredQuote(rawContent, options.singleQuote);",
                    "",
                    "  // It might sound unnecessary to use `makeString` even if the string already",
                    "  // is enclosed with `enclosingQuote`, but it isn't. The string could contain",
                    "  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes",
                    "  // sure that we consistently output the minimum amount of escaped quotes.",
                    "  return makeString(",
                    "    rawContent,",
                    "    enclosingQuote,",
                    "    !(",
                    "      options.parser === \"css\" ||",
                    "      options.parser === \"less\" ||",
                    "      options.parser === \"scss\" ||",
                    "      options.__embeddedInHtml",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "export default printString;"
                ]
            },
            "public.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getNextNonSpaceNonCommentCharacterIndexWithStartIndex from \"./get-next-non-space-non-comment-character-index.js\";",
                    "import isPreviousLineEmptyWithStartIndex from \"./is-previous-line-empty.js\";",
                    "import isNextLineEmptyAfterIndex from \"./is-next-line-empty.js\";",
                    "",
                    "// Legacy version of `getNextNonSpaceNonCommentCharacterIndex`",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {number | false}",
                    " */",
                    "function legacyGetNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {",
                    "  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "    text,",
                    "    locEnd(node)",
                    "  );",
                    "}",
                    "",
                    "// TODO: export `getNextNonSpaceNonCommentCharacterIndex` directly in v4",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {number | false}",
                    " */",
                    "export function getNextNonSpaceNonCommentCharacterIndex(text, startIndex) {",
                    "  return arguments.length === 2 || typeof startIndex === \"number\"",
                    "    ? getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, startIndex)",
                    "    : // @ts-expect-error -- expected",
                    "      // eslint-disable-next-line prefer-rest-params",
                    "      legacyGetNextNonSpaceNonCommentCharacterIndex(...arguments);",
                    "}",
                    "",
                    "// Legacy version of `isPreviousLineEmpty`",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locStart",
                    " */",
                    "function legacyIsPreviousLineEmpty(text, node, locStart) {",
                    "  return isPreviousLineEmptyWithStartIndex(text, locStart(node));",
                    "}",
                    "",
                    "// TODO: export `isPreviousLineEmpty` directly in v4",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {boolean}",
                    " */",
                    "export function isPreviousLineEmpty(text, startIndex) {",
                    "  return arguments.length === 2 || typeof startIndex === \"number\"",
                    "    ? isPreviousLineEmptyWithStartIndex(text, startIndex)",
                    "    : // @ts-expect-error -- expected",
                    "      // eslint-disable-next-line prefer-rest-params",
                    "      legacyIsPreviousLineEmpty(...arguments);",
                    "}",
                    "",
                    "// Legacy version of `isNextLineEmpty`",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {boolean}",
                    " */",
                    "function legacyIsNextLineEmpty(text, node, locEnd) {",
                    "  return isNextLineEmptyAfterIndex(text, locEnd(node));",
                    "}",
                    "",
                    "// TODO: export `isNextLineEmpty` directly in v4",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {boolean}",
                    " */",
                    "export function isNextLineEmpty(text, startIndex) {",
                    "  return arguments.length === 2 || typeof startIndex === \"number\"",
                    "    ? isNextLineEmptyAfterIndex(text, startIndex)",
                    "    : // @ts-expect-error -- expected",
                    "      // eslint-disable-next-line prefer-rest-params",
                    "      legacyIsNextLineEmpty(...arguments);",
                    "}",
                    "",
                    "export { default as getMaxContinuousCount } from \"./get-max-continuous-count.js\";",
                    "export { default as getStringWidth } from \"./get-string-width.js\";",
                    "export { default as getAlignmentSize } from \"./get-alignment-size.js\";",
                    "export { default as getIndentSize } from \"./get-indent-size.js\";",
                    "export { default as skipNewline } from \"./skip-newline.js\";",
                    "export { default as skipInlineComment } from \"./skip-inline-comment.js\";",
                    "export { default as skipTrailingComment } from \"./skip-trailing-comment.js\";",
                    "export { default as hasNewline } from \"./has-newline.js\";",
                    "export { default as hasNewlineInRange } from \"./has-newline-in-range.js\";",
                    "export { default as hasSpaces } from \"./has-spaces.js\";",
                    "export { default as getNextNonSpaceNonCommentCharacter } from \"./get-next-non-space-non-comment-character.js\";",
                    "export { default as makeString } from \"./make-string.js\";",
                    "export {",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "} from \"./skip.js\";",
                    "export {",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "} from \"../main/comments/utils.js\";",
                    "",
                    "// TODO: Remove this in v4",
                    "export { isNextLineEmptyAfterIndex };"
                ]
            },
            "read-file.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "",
                    "/**",
                    " * @param {string} filename",
                    " * @returns {Promise<undefined | string>}",
                    " */",
                    "async function readFile(filename) {",
                    "  try {",
                    "    return await fs.readFile(filename, \"utf8\");",
                    "  } catch (error) {",
                    "    if (error.code === \"ENOENT\") {",
                    "      return;",
                    "    }",
                    "",
                    "    throw new Error(`Unable to read '${filename}': ${error.message}`);",
                    "  }",
                    "}",
                    "",
                    "export default readFile;"
                ]
            },
            "require-from-file.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { createRequire } from \"node:module\";",
                    "",
                    "function requireFromFile(id, parent) {",
                    "  const require = createRequire(parent);",
                    "  return require(id);",
                    "}",
                    "",
                    "export default requireFromFile;"
                ]
            },
            "skip-inline-comment.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} startIndex",
                    " * @returns {number | false}",
                    " */",
                    "function skipInlineComment(text, startIndex) {",
                    "  /* c8 ignore next 3 */",
                    "  if (startIndex === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(startIndex) === \"/\" && text.charAt(startIndex + 1) === \"*\") {",
                    "    for (let i = startIndex + 2; i < text.length; ++i) {",
                    "      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {",
                    "        return i + 2;",
                    "      }",
                    "    }",
                    "  }",
                    "  return startIndex;",
                    "}",
                    "",
                    "export default skipInlineComment;"
                ]
            },
            "skip-newline.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/** @typedef {import(\"./skip.js\").SkipOptions} SkipOptions */",
                    "",
                    "// This one doesn't use the above helper function because it wants to",
                    "// test \\r\\n in order and `skip` doesn't support ordering and we only",
                    "// want to skip one newline. It's simple to implement.",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} startIndex",
                    " * @param {SkipOptions=} options",
                    " * @returns {number | false}",
                    " */",
                    "function skipNewline(text, startIndex, options) {",
                    "  const backwards = Boolean(options?.backwards);",
                    "  if (startIndex === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const character = text.charAt(startIndex);",
                    "  if (backwards) {",
                    "    // We already replace `\\r\\n` with `\\n` before parsing",
                    "    /* c8 ignore next 3 */",
                    "    if (text.charAt(startIndex - 1) === \"\\r\" && character === \"\\n\") {",
                    "      return startIndex - 2;",
                    "    }",
                    "    if (",
                    "      character === \"\\n\" ||",
                    "      character === \"\\r\" ||",
                    "      character === \"\\u2028\" ||",
                    "      character === \"\\u2029\"",
                    "    ) {",
                    "      return startIndex - 1;",
                    "    }",
                    "  } else {",
                    "    // We already replace `\\r\\n` with `\\n` before parsing",
                    "    /* c8 ignore next 3 */",
                    "    if (character === \"\\r\" && text.charAt(startIndex + 1) === \"\\n\") {",
                    "      return startIndex + 2;",
                    "    }",
                    "    if (",
                    "      character === \"\\n\" ||",
                    "      character === \"\\r\" ||",
                    "      character === \"\\u2028\" ||",
                    "      character === \"\\u2029\"",
                    "    ) {",
                    "      return startIndex + 1;",
                    "    }",
                    "  }",
                    "",
                    "  return startIndex;",
                    "}",
                    "",
                    "export default skipNewline;"
                ]
            },
            "skip-trailing-comment.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { skipEverythingButNewLine } from \"./skip.js\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} startIndex",
                    " * @returns {number | false}",
                    " */",
                    "function skipTrailingComment(text, startIndex) {",
                    "  /* c8 ignore next 3 */",
                    "  if (startIndex === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(startIndex) === \"/\" && text.charAt(startIndex + 1) === \"/\") {",
                    "    return skipEverythingButNewLine(text, startIndex);",
                    "  }",
                    "  return startIndex;",
                    "}",
                    "",
                    "export default skipTrailingComment;"
                ]
            },
            "skip.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @typedef {{backwards?: boolean}} SkipOptions",
                    " */",
                    "",
                    "/**",
                    " * @param {string | RegExp} characters",
                    " * @returns {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "function skip(characters) {",
                    "  return (text, startIndex, options) => {",
                    "    const backwards = Boolean(options?.backwards);",
                    "",
                    "    // Allow `skip` functions to be threaded together without having",
                    "    // to check for failures (did someone say monads?).",
                    "    /* c8 ignore next 3 */",
                    "    if (startIndex === false) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const { length } = text;",
                    "    let cursor = startIndex;",
                    "    while (cursor >= 0 && cursor < length) {",
                    "      const character = text.charAt(cursor);",
                    "      if (characters instanceof RegExp) {",
                    "        if (!characters.test(character)) {",
                    "          return cursor;",
                    "        }",
                    "      } else if (!characters.includes(character)) {",
                    "        return cursor;",
                    "      }",
                    "",
                    "      backwards ? cursor-- : cursor++;",
                    "    }",
                    "",
                    "    if (cursor === -1 || cursor === length) {",
                    "      // If we reached the beginning or end of the file, return the",
                    "      // out-of-bounds cursor. It's up to the caller to handle this",
                    "      // correctly. We don't want to indicate `false` though if it",
                    "      // actually skipped valid characters.",
                    "      return cursor;",
                    "    }",
                    "    return false;",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @type {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "const skipWhitespace = skip(/\\s/);",
                    "/**",
                    " * @type {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "const skipSpaces = skip(\" \\t\");",
                    "/**",
                    " * @type {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "const skipToLineEnd = skip(\",; \\t\");",
                    "/**",
                    " * @type {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "const skipEverythingButNewLine = skip(/[^\\n\\r]/);",
                    "",
                    "export {",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "};"
                ]
            },
            "try-combinations.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function tryCombinations(combinations) {",
                    "  const errors = [];",
                    "  for (const fn of combinations) {",
                    "    try {",
                    "      return fn();",
                    "    } catch (error) {",
                    "      errors.push(error);",
                    "    }",
                    "  }",
                    "",
                    "  // TODO: Use `AggregateError` when we drop Node.js v14",
                    "  // throw new AggregateError(errors, \"All combinations failed\");",
                    "  throw Object.assign(new Error(\"All combinations failed\"), { errors });",
                    "}",
                    "",
                    "export default tryCombinations;"
                ]
            },
            "unexpected-node-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "class UnexpectedNodeError extends Error {",
                    "  name = \"UnexpectedNodeError\";",
                    "",
                    "  constructor(node, language, typeProperty = \"type\") {",
                    "    super(",
                    "      `Unexpected ${language} node ${typeProperty}: ${JSON.stringify(",
                    "        node[typeProperty]",
                    "      )}.`",
                    "    );",
                    "    this.node = node;",
                    "  }",
                    "}",
                    "",
                    "export default UnexpectedNodeError;"
                ]
            },
            "whitespace-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import escapeStringRegexp from \"escape-string-regexp\";",
                    "",
                    "class WhitespaceUtils {",
                    "  #whitespaceCharacters;",
                    "",
                    "  constructor(whitespaceCharacters) {",
                    "    this.#whitespaceCharacters = new Set(whitespaceCharacters);",
                    "",
                    "    if (",
                    "      process.env.NODE_ENV !== \"production\" &&",
                    "      (this.#whitespaceCharacters.size === 0 ||",
                    "        Array.prototype.some.call(",
                    "          whitespaceCharacters,",
                    "          (character) => !/^\\s$/.test(character)",
                    "        ))",
                    "    ) {",
                    "      throw new TypeError(",
                    "        `Invalid characters: ${JSON.stringify(whitespaceCharacters)}`",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  getLeadingWhitespaceCount(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    let count = 0;",
                    "",
                    "    for (",
                    "      let index = 0;",
                    "      index < text.length && whitespaceCharacters.has(text.charAt(index));",
                    "      index++",
                    "    ) {",
                    "      count++;",
                    "    }",
                    "",
                    "    return count;",
                    "  }",
                    "",
                    "  getTrailingWhitespaceCount(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    let count = 0;",
                    "",
                    "    for (",
                    "      let index = text.length - 1;",
                    "      index >= 0 && whitespaceCharacters.has(text.charAt(index));",
                    "      index--",
                    "    ) {",
                    "      count++;",
                    "    }",
                    "",
                    "    return count;",
                    "  }",
                    "",
                    "  getLeadingWhitespace(text) {",
                    "    const count = this.getLeadingWhitespaceCount(text);",
                    "    return text.slice(0, count);",
                    "  }",
                    "",
                    "  getTrailingWhitespace(text) {",
                    "    const count = this.getTrailingWhitespaceCount(text);",
                    "    return text.slice(text.length - count);",
                    "  }",
                    "",
                    "  hasLeadingWhitespace(text) {",
                    "    return this.#whitespaceCharacters.has(text.charAt(0));",
                    "  }",
                    "",
                    "  hasTrailingWhitespace(text) {",
                    "    return this.#whitespaceCharacters.has(text.at(-1));",
                    "  }",
                    "",
                    "  trimStart(text) {",
                    "    const count = this.getLeadingWhitespaceCount(text);",
                    "    return text.slice(count);",
                    "  }",
                    "",
                    "  trimEnd(text) {",
                    "    const count = this.getTrailingWhitespaceCount(text);",
                    "    return text.slice(0, text.length - count);",
                    "  }",
                    "",
                    "  trim(text) {",
                    "    return this.trimEnd(this.trimStart(text));",
                    "  }",
                    "",
                    "  split(text, captureWhitespace = false) {",
                    "    const pattern = `[${escapeStringRegexp(",
                    "      [...this.#whitespaceCharacters].join(\"\")",
                    "    )}]+`;",
                    "    const regexp = new RegExp(captureWhitespace ? `(${pattern})` : pattern);",
                    "    return text.split(regexp);",
                    "  }",
                    "",
                    "  hasWhitespaceCharacter(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    return Array.prototype.some.call(text, (character) =>",
                    "      whitespaceCharacters.has(character)",
                    "    );",
                    "  }",
                    "",
                    "  hasNonWhitespaceCharacter(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    return Array.prototype.some.call(",
                    "      text,",
                    "      (character) => !whitespaceCharacters.has(character)",
                    "    );",
                    "  }",
                    "",
                    "  isWhitespaceOnly(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    return Array.prototype.every.call(text, (character) =>",
                    "      whitespaceCharacters.has(character)",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "export default WhitespaceUtils;"
                ]
            },
            "front-matter": {
                "is-front-matter.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isFrontMatter(node) {",
                        "  return node?.type === \"front-matter\";",
                        "}",
                        "",
                        "export default isFrontMatter;"
                    ]
                },
                "parse.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const frontMatterRegex = new RegExp(",
                        "  \"^(?<startDelimiter>-{3}|\\\\+{3})\" +",
                        "    // trailing spaces after delimiters are allowed",
                        "    \"(?<language>[^\\\\n]*)\" +",
                        "    \"\\\\n(?:|(?<value>.*?)\\\\n)\" +",
                        "    // In some markdown processors such as pandoc,",
                        "    // \"...\" can be used as the end delimiter for YAML front-matter.",
                        "    // Adding `\\.{3}` make the regex matches `+++\\n...`, but we'll exclude it later",
                        "    \"(?<endDelimiter>\\\\k<startDelimiter>|\\\\.{3})\" +",
                        "    \"[^\\\\S\\\\n]*(?:\\\\n|$)\",",
                        "  \"s\"",
                        ");",
                        "",
                        "function parse(text) {",
                        "  const match = text.match(frontMatterRegex);",
                        "  if (!match) {",
                        "    return { content: text };",
                        "  }",
                        "",
                        "  const { startDelimiter, language, value = \"\", endDelimiter } = match.groups;",
                        "",
                        "  let lang = language.trim() || \"yaml\";",
                        "  if (startDelimiter === \"+++\") {",
                        "    lang = \"toml\";",
                        "  }",
                        "",
                        "  // Only allow yaml to parse with a different end delimiter",
                        "  if (lang !== \"yaml\" && startDelimiter !== endDelimiter) {",
                        "    return { content: text };",
                        "  }",
                        "",
                        "  const [raw] = match;",
                        "  const frontMatter = {",
                        "    type: \"front-matter\",",
                        "    lang,",
                        "    value,",
                        "    startDelimiter,",
                        "    endDelimiter,",
                        "    raw: raw.replace(/\\n$/, \"\"),",
                        "  };",
                        "",
                        "  return {",
                        "    frontMatter,",
                        "    content: raw.replaceAll(/[^\\n]/g, \" \") + text.slice(raw.length),",
                        "  };",
                        "}",
                        "",
                        "export default parse;"
                    ]
                },
                "print.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { hardline, markAsRoot } from \"../../document/builders.js\";",
                        "",
                        "async function print(node, textToDoc) {",
                        "  if (node.lang === \"yaml\") {",
                        "    const value = node.value.trim();",
                        "    const doc = value ? await textToDoc(value, { parser: \"yaml\" }) : \"\";",
                        "    return markAsRoot([",
                        "      node.startDelimiter,",
                        "      hardline,",
                        "      doc,",
                        "      doc ? hardline : \"\",",
                        "      node.endDelimiter,",
                        "    ]);",
                        "  }",
                        "}",
                        "",
                        "export default print;"
                    ]
                }
            }
        }
    },
    "types": {
        "angular-html-parser": {
            "index.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "import \"angular-html-parser/lib/compiler/src/ml_parser/ast\";",
                    "import { HtmlTagDefinition } from \"angular-html-parser/lib/compiler/src/ml_parser/html_tags.js\";",
                    "",
                    "declare module \"angular-html-parser/lib/compiler/src/ml_parser/ast.js\" {",
                    "  interface Attribute {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "    // see restoreName in parser-html.js",
                    "    namespace?: string | null;",
                    "    hasExplicitNamespace?: boolean;",
                    "  }",
                    "",
                    "  interface CDATA {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface Comment {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface DocType {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface Element {",
                    "    tagDefinition: HtmlTagDefinition;",
                    "    // see restoreName in parser-html.js",
                    "    namespace?: string | null;",
                    "    hasExplicitNamespace?: boolean;",
                    "  }",
                    "",
                    "  interface Text {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "}"
                ]
            }
        },
        "espree": {
            "index.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "declare module \"espree\" {",
                    "  // https://github.com/eslint/espree#options",
                    "  export interface Options {",
                    "    range?: boolean;",
                    "    loc?: boolean;",
                    "    comment?: boolean;",
                    "    tokens?: boolean;",
                    "    ecmaVersion?: \"latest\";",
                    "    sourceType?: \"script\" | \"module\";",
                    "    ecmaFeatures?: {",
                    "      jsx?: boolean;",
                    "      globalReturn?: boolean;",
                    "      impliedStrict?: boolean;",
                    "    };",
                    "  }",
                    "  // https://github.com/eslint/espree#parse",
                    "  export function parse(code: string, options?: Options): any;",
                    "  // https://github.com/eslint/espree#tokenize",
                    "  export function tokenize(code: string, options?: Options): any;",
                    "}"
                ]
            }
        }
    },
    "website": {
        "README.md": {},
        "package.json": {},
        "sidebars.json": {},
        "siteConfig.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "// Docs: https://docusaurus.io/docs/en/site-config.html",
                "",
                "const path = require(\"path\");",
                "const fs = require(\"fs\");",
                "const { load: parseYaml } = require(\"js-yaml\");",
                "",
                "const PACKAGE = require(\"../package.json\");",
                "const GITHUB_URL = `https://github.com/${PACKAGE.repository}`;",
                "",
                "function loadYaml(fsPath) {",
                "  return parseYaml(fs.readFileSync(path.join(__dirname, fsPath), \"utf8\"));",
                "}",
                "",
                "const users = loadYaml(\"./data/users.yml\");",
                "const editors = loadYaml(\"./data/editors.yml\");",
                "const supportedLanguages = loadYaml(\"./data/languages.yml\");",
                "",
                "const siteConfig = {",
                "  title: \"Prettier\",",
                "  tagline: \"Opinionated Code Formatter\",",
                "  githubUrl: GITHUB_URL,",
                "  url: PACKAGE.homepage,",
                "  baseUrl: \"/\",",
                "  projectName: PACKAGE.name,",
                "  repo: PACKAGE.repository,",
                "  cname: \"prettier.io\",",
                "  users,",
                "  editors,",
                "  supportedLanguages,",
                "  tideliftUrl:",
                "    \"https://tidelift.com/subscription/pkg/npm-prettier?utm_source=npm-prettier&utm_medium=referral&utm_campaign=website\",",
                "  /* base url for editing docs, usage example: editUrl + 'en/doc1.md' */",
                "  editUrl: `${GITHUB_URL}/edit/main/docs/`,",
                "  headerLinks: [",
                "    { href: \"/playground/\", label: \"Playground\" },",
                "    { doc: \"index\", label: \"Docs\" },",
                "    { blog: true, label: \"Blog\" },",
                "    { search: true },",
                "    { href: \"https://opencollective.com/prettier\", label: \"Donate\" },",
                "    { href: GITHUB_URL, label: \"GitHub\" },",
                "  ],",
                "  /* path to images for header/footer */",
                "  headerIcon: \"icon.png\",",
                "  footerIcon: \"icon.png\",",
                "  favicon: \"icon.png\",",
                "  /* colors for website */",
                "  colors: {",
                "    primaryColor: \"#1A2B34\",",
                "    secondaryColor: \"#808080\",",
                "  },",
                "  highlight: {",
                "    theme: \"default\",",
                "    // eslint-disable-next-line import/no-extraneous-dependencies -- This is a docusaurus dependency",
                "    version: require(\"highlight.js/package.json\").version,",
                "  },",
                "  usePrism: [\"javascript\", \"jsx\", \"typescript\", \"ts\", \"js\", \"html\", \"css\"],",
                "  useEnglishUrl: true,",
                "  scripts: [",
                "    \"https://buttons.github.io/buttons.js\",",
                "    \"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js\",",
                "    \"/js/code-block-buttons.js\",",
                "  ],",
                "  stylesheets: [",
                "    \"//unpkg.com/@sandhose/prettier-animated-logo@1.0.3/dist/wide.css\",",
                "  ],",
                "  algolia: {",
                "    apiKey: process.env.ALGOLIA_PRETTIER_API_KEY,",
                "    indexName: \"prettier\",",
                "  },",
                "  markdownPlugins: [",
                "    // ignore `<!-- prettier-ignore -->` before passing into Docusaurus to avoid mis-parsing (#3322)",
                "    (md) => {",
                "      md.block.ruler.before(",
                "        \"htmlblock\",",
                "        \"prettierignore\",",
                "        (state, startLine) => {",
                "          const pos = state.bMarks[startLine];",
                "          const max = state.eMarks[startLine];",
                "          if (/<!-- prettier-ignore -->/.test(state.src.slice(pos, max))) {",
                "            state.line += 1;",
                "            return true;",
                "          }",
                "          return false;",
                "        }",
                "      );",
                "    },",
                "  ],",
                "  separateCss: [\"static/separate-css\"],",
                "  gaTrackingId: \"UA-111350464-1\",",
                "  twitter: true,",
                "  twitterUsername: \"PrettierCode\",",
                "  twitterImage: \"icon.png\",",
                "  ogImage: \"icon.png\",",
                "  onPageNav: \"separate\",",
                "};",
                "",
                "module.exports = siteConfig;"
            ]
        },
        "versions.json": {},
        "webpack.config.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "const path = require(\"node:path\");",
                "",
                "module.exports = {",
                "  entry: {",
                "    playground: \"./playground/index.js\",",
                "  },",
                "  output: {",
                "    filename: \"[name].js\",",
                "    path: path.join(__dirname, \"static\"),",
                "  },",
                "  module: {",
                "    rules: [",
                "      {",
                "        test: /\\.js$/,",
                "        exclude: /node_modules/,",
                "        loader: \"babel-loader\",",
                "        options: {",
                "          presets: [\"@babel/env\", \"@babel/react\"],",
                "        },",
                "      },",
                "    ],",
                "  },",
                "  externals: {",
                "    clipboard: \"ClipboardJS\",",
                "    codemirror: \"CodeMirror\",",
                "    react: \"React\",",
                "    \"react-dom\": \"ReactDOM\",",
                "  },",
                "};"
            ]
        },
        "yarn.lock": {},
        "blog": {
            "2017-04-13-1.0.0.md": {},
            "2017-04-20-1.2.0.md": {},
            "2017-05-03-1.3.0.md": {},
            "2017-06-03-1.4.0.md": {},
            "2017-06-28-1.5.0.md": {},
            "2017-08-29-1.6.0.md": {},
            "2017-09-15-1.7.0.md": {},
            "2017-11-07-1.8.0.md": {},
            "2017-12-05-1.9.0.md": {},
            "2018-01-10-1.10.0.md": {},
            "2018-02-26-1.11.0.md": {},
            "2018-04-09-plugin-php-0.1.md": {},
            "2018-04-11-1.12.0.md": {},
            "2018-05-27-1.13.0.md": {},
            "2018-07-29-1.14.0.md": {},
            "2018-11-07-1.15.0.md": {},
            "2019-01-20-1.16.0.md": {},
            "2019-04-12-1.17.0.md": {},
            "2019-06-06-1.18.0.md": {},
            "2019-11-09-1.19.0.md": {},
            "2020-03-21-2.0.0.md": {},
            "2020-08-24-2.1.0.md": {},
            "2020-11-20-2.2.0.md": {},
            "2020-12-11-plugin-ruby-1.0.md": {},
            "2021-05-09-2.3.0.md": {},
            "2021-09-09-2.4.0.md": {},
            "2021-11-25-2.5.0.md": {},
            "2022-01-06-prettier-begins-paying-maintainers.md": {},
            "2022-03-16-2.6.0.md": {},
            "2022-06-14-2.7.0.md": {},
            "2022-11-23-2.8.0.md": {}
        },
        "core": {
            "Footer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const React = require(\"react\");",
                    "const PropTypes = require(\"prop-types\");",
                    "",
                    "const GithubButton = (props) => (",
                    "  <a",
                    "    className=\"github-button\"",
                    "    href={props.config.githubUrl}",
                    "    data-icon=\"octicon-star\"",
                    "    data-show-count=\"true\"",
                    "    aria-label=\"Star this project on GitHub\"",
                    "  >",
                    "    Star",
                    "  </a>",
                    ");",
                    "",
                    "GithubButton.propTypes = {",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "class Footer extends React.Component {",
                    "  url(path) {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}docs/${language}${path}`;",
                    "  }",
                    "",
                    "  usersUrl() {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}${language}/users`;",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <footer className=\"footerSection nav-footer\" id=\"footer\">",
                    "        <section className=\"sitemap\">",
                    "          <a href={this.props.config.baseUrl} className=\"nav-home\">",
                    "            <img",
                    "              src={this.props.config.baseUrl + this.props.config.footerIcon}",
                    "              alt={this.props.config.title}",
                    "            />",
                    "          </a>",
                    "          <div>",
                    "            <h5>Docs</h5>",
                    "            <a href={this.url(\"/index.html\")}>About</a>",
                    "            <a href={this.url(\"/install.html\")}>Usage</a>",
                    "            <br />",
                    "            <a href=\"https://www.netlify.com\">",
                    "              <img src=\"https://www.netlify.com/img/global/badges/netlify-color-accent.svg\" />",
                    "            </a>",
                    "          </div>",
                    "          <div>",
                    "            <h5>Community</h5>",
                    "            <a href={this.usersUrl()}>User Showcase</a>",
                    "            <a",
                    "              href=\"http://stackoverflow.com/questions/tagged/prettier\"",
                    "              target=\"_blank\"",
                    "              rel=\"noopener noreferrer\"",
                    "            >",
                    "              Stack Overflow",
                    "            </a>",
                    "            <a href=\"https://twitter.com/PrettierCode\">",
                    "              @PrettierCode on Twitter",
                    "            </a>",
                    "            <object",
                    "              type=\"image/svg+xml\"",
                    "              data=\"https://img.shields.io/twitter/follow/prettiercode.svg?label=Follow+Prettier&style=social\"",
                    "            >",
                    "              <a href=\"https://twitter.com/intent/follow?screen_name=prettiercode\">",
                    "                <img",
                    "                  alt=\"Follow Prettier on Twitter\"",
                    "                  src=\"https://img.shields.io/twitter/follow/prettiercode.png?label=Follow+Prettier&style=social\"",
                    "                />",
                    "              </a>",
                    "            </object>",
                    "          </div>",
                    "          <div>",
                    "            <h5>More</h5>",
                    "            <a href={this.props.config.baseUrl + \"blog\"}>Blog</a>",
                    "            <a href={this.props.config.githubUrl}>GitHub</a>",
                    "            <a href={this.props.config.githubUrl + \"/issues\"}>Issues</a>",
                    "            <GithubButton config={this.props.config} />",
                    "          </div>",
                    "        </section>",
                    "      </footer>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "Footer.propTypes = {",
                    "  language: PropTypes.string,",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "module.exports = Footer;"
                ]
            }
        },
        "data": {
            "editors.yml": {},
            "languages.yml": {},
            "users.yml": {}
        },
        "pages": {
            "googlefe164a33bda4034b.html": {},
            "playground-redirect.html": {},
            "en": {
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const React = require(\"react\");",
                        "const PropTypes = require(\"prop-types\");",
                        "const AnimatedLogo = require(\"@sandhose/prettier-animated-logo\");",
                        "const { MarkdownBlock, Container } = require(\"../../core/CompLibrary.js\");",
                        "",
                        "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                        "",
                        "const ButtonGroup = (props) => (",
                        "  <div className=\"buttonGroup buttonWrapper\">{props.children}</div>",
                        ");",
                        "",
                        "ButtonGroup.propTypes = {",
                        "  children: PropTypes.node,",
                        "};",
                        "",
                        "class Button extends React.Component {",
                        "  render() {",
                        "    return (",
                        "      <div className=\"pluginWrapper buttonWrapper\">",
                        "        <a className=\"button\" href={this.props.href} target={this.props.target}>",
                        "          {this.props.children}",
                        "        </a>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Button.defaultProps = {",
                        "  target: \"_self\",",
                        "};",
                        "",
                        "Button.propTypes = {",
                        "  href: PropTypes.string,",
                        "  target: PropTypes.string,",
                        "  children: PropTypes.any,",
                        "};",
                        "",
                        "function Tidelift() {",
                        "  return (",
                        "    <a className=\"tidelift\" href={siteConfig.tideliftUrl}>",
                        "      PRETTIER FOR ENTERPRISE",
                        "    </a>",
                        "  );",
                        "}",
                        "",
                        "const HomeSplash = (props) => (",
                        "  <div className=\"homeContainer\">",
                        "    <Tidelift />",
                        "    <div className=\"homeSplashFade\">",
                        "      <div className=\"wrapper homeWrapper\">",
                        "        <div className=\"animatedLogoWrapper\">",
                        "          <AnimatedLogo version=\"wide\" />",
                        "        </div>",
                        "        <div className=\"inner\">",
                        "          <div className=\"section promoSection\">",
                        "            <div className=\"promoRow\">",
                        "              <div className=\"pluginRowBlock\">",
                        "                <Button href=\"/playground/\">Try It Online</Button>&nbsp;",
                        "                <Button href={\"/docs/\" + props.language + \"/install.html\"}>",
                        "                  Install Prettier",
                        "                </Button>",
                        "              </div>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </div>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "HomeSplash.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const TldrSection = ({ language }) => (",
                        "  <div className=\"tldrSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-evenly\",",
                        "        }}",
                        "      >",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>What is Prettier?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>An opinionated code formatter</li>",
                        "            <li>Supports many languages</li>",
                        "            <li>Integrates with most editors</li>",
                        "            <li>",
                        "              <a href={\"/docs/\" + language + \"/option-philosophy.html\"}>",
                        "                Has few options &raquo;",
                        "              </a>",
                        "            </li>",
                        "          </ul>",
                        "        </div>",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>Why?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>Your code is formatted on save</li>",
                        "            <li>No need to discuss style in code review</li>",
                        "            <li>Saves you time and energy</li>",
                        "            <li>",
                        "              <a href={\"/docs/\" + language + \"/why-prettier.html\"}>",
                        "                And more &raquo;",
                        "              </a>",
                        "            </li>",
                        "          </ul>",
                        "        </div>",
                        "      </div>",
                        "    </Container>",
                        "  </div>",
                        ");",
                        "",
                        "TldrSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const Language = ({ name, nameLink, showName, image, variants }) => (",
                        "  <div",
                        "    className=\"languageCategory\"",
                        "    style={{",
                        "      display: \"flex\",",
                        "      alignItems: \"flex-start\",",
                        "      paddingBottom: \"1em\",",
                        "    }}",
                        "  >",
                        "    <img src={image} style={{ width: \"50px\", padding: \"0 20px\" }} />",
                        "    <ul>",
                        "      {showName && (",
                        "        <li className=\"accented\">",
                        "          {nameLink ? <a href={nameLink}>{name}</a> : name}",
                        "        </li>",
                        "      )}",
                        "      {variants.map((variant) => (",
                        "        <li key={variant}>",
                        "          <MarkdownBlock>{variant}</MarkdownBlock>",
                        "        </li>",
                        "      ))}",
                        "    </ul>",
                        "  </div>",
                        ");",
                        "",
                        "Language.propTypes = {",
                        "  name: PropTypes.string,",
                        "  nameLink: PropTypes.string,",
                        "  showName: PropTypes.bool,",
                        "  image: PropTypes.string,",
                        "  variants: PropTypes.array,",
                        "};",
                        "",
                        "const LanguagesSection = () => {",
                        "  const languageChunks = siteConfig.supportedLanguages.reduce(",
                        "    (acc, language) => {",
                        "      const last = acc.at(-1);",
                        "      if (",
                        "        last &&",
                        "        last.length < 2 &&",
                        "        last.reduce((sum, lang) => sum + lang.variants.length, 0) +",
                        "          language.variants.length <",
                        "          9",
                        "      ) {",
                        "        last.push(language);",
                        "      } else {",
                        "        acc.push([language]);",
                        "      }",
                        "      return acc;",
                        "    },",
                        "    []",
                        "  );",
                        "",
                        "  return (",
                        "    <div",
                        "      className=\"languagesSection productShowcaseSection\"",
                        "      style={{ textAlign: \"center\" }}",
                        "    >",
                        "      <Container>",
                        "        <h2>Works with the Tools You Use</h2>",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {languageChunks.map((languageChunk, index) => (",
                        "            <div key={index} style={{ flex: \"1 1 auto\" }}>",
                        "              {languageChunk.map((language) => (",
                        "                <Language key={language.name} {...language} />",
                        "              ))}",
                        "            </div>",
                        "          ))}",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "const Editor = ({ content = \"\", image, name }) => (",
                        "  <div className=\"editor\">",
                        "    <img className=\"editorImage\" src={image} />",
                        "    <div className=\"editorInfo\">",
                        "      <h3 className=\"editorName\">{name}</h3>",
                        "      <MarkdownBlock>{content.replaceAll(\"\\n\", \"  \\n\")}</MarkdownBlock>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "Editor.propTypes = {",
                        "  content: PropTypes.string,",
                        "  image: PropTypes.string.isRequired,",
                        "  name: PropTypes.string.isRequired,",
                        "};",
                        "",
                        "const EditorSupportSection = () => (",
                        "  <div className=\"editorSupportSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <h2>Editor Support</h2>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-around\",",
                        "        }}",
                        "      >",
                        "        {siteConfig.editors.map((editor) => (",
                        "          <Editor key={editor.name} {...editor} />",
                        "        ))}",
                        "      </div>",
                        "    </Container>",
                        "",
                        "    <div style={{ float: \"right\" }}>",
                        "      <span>Got more? </span>",
                        "      <a",
                        "        href={`${siteConfig.githubUrl}/edit/main/website/data/editors.yml`}",
                        "        className=\"button\"",
                        "      >",
                        "        Send a PR",
                        "      </a>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "const UsersSection = ({ language }) => {",
                        "  const showcase = siteConfig.users",
                        "    .filter((user) => user.pinned)",
                        "    .map((user, i) => (",
                        "      <a key={i} className=\"growOnHover alignCenter\" href={user.infoLink}>",
                        "        <img className=\"user\" src={user.greyImage} title={user.caption} />",
                        "      </a>",
                        "    ));",
                        "",
                        "  return (",
                        "    <div className=\"usersSection productShowcaseSection\">",
                        "      <Container>",
                        "        <h2>Used By People You Rely On</h2>",
                        "        <div style={{ textAlign: \"right\" }} />",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {showcase}",
                        "        </div>",
                        "        <div className=\"more-users\">",
                        "          <a",
                        "            className=\"button\"",
                        "            href={siteConfig.baseUrl + language + \"/users/\"}",
                        "            target=\"_self\"",
                        "            style={{ marginRight: \"10px\" }}",
                        "          >",
                        "            See Others",
                        "          </a>",
                        "        </div>",
                        "",
                        "        <h2 className=\"ecosystemSubHeader\">Established in the Ecosystem</h2>",
                        "        <div",
                        "          className=\"ecosystemSubSection\"",
                        "          style={{",
                        "            display: \"flex\",",
                        "            justifyContent: \"space-around\",",
                        "            flexFlow: \"row wrap\",",
                        "          }}",
                        "        >",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://2021.stateofjs.com/en-US/other-tools/utilities\"",
                        "              style={{ marginTop: \"15px\" }}",
                        "            >",
                        "              <img",
                        "                src=\"/images/state_of_js_grey.svg\"",
                        "                style={{ width: \"80px\" }}",
                        "              />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>Regularly used by:</p>",
                        "              <ul style={{ marginBottom: \"0\" }}>",
                        "                <li>",
                        "                  <a href=\"https://2021.stateofjs.com/en-US/other-tools/#utilities\">",
                        "                    More than 83% of respondents to State of JS 2021.",
                        "                  </a>",
                        "                </li>",
                        "                <li>",
                        "                  <a href=\"https://2020.stateofjs.com/en-US/other-tools/#utilities\">",
                        "                    More than 70% of respondents to State of JS 2020.",
                        "                  </a>",
                        "                </li>",
                        "              </ul>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a href=\"https://github.com/prettier/prettier\">",
                        "              <img src=\"/images/github_grey.svg\" style={{ width: \"80px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than{\" \"}",
                        "                <strong data-placeholder=\"dependent-github\">5.2 million</strong>{\" \"}",
                        "                dependent repositories on GitHub",
                        "              </p>",
                        "              <Button href=\"https://github.com/prettier/prettier/network/dependents\">",
                        "                Check Them Out",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a href=\"https://npmjs.com/package/prettier\">",
                        "              <img src=\"/images/npm_grey.svg\" style={{ width: \"80px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than <strong data-placeholder=\"dependent-npm\">13k</strong>{\" \"}",
                        "                dependent packages on npm",
                        "              </p>",
                        "              <Button href=\"https://www.npmjs.com/browse/depended/prettier\">",
                        "                See them all",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "UsersSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "class Index extends React.Component {",
                        "  render() {",
                        "    const language = this.props.language || \"en\";",
                        "",
                        "    return (",
                        "      <div>",
                        "        <script src=\"landing.js\" />",
                        "        <HomeSplash language={language} />",
                        "        <div className=\"mainContainer landingContainer\">",
                        "          <TldrSection language={language} />",
                        "          <LanguagesSection />",
                        "          <EditorSupportSection />",
                        "          <UsersSection language={language} />",
                        "        </div>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Index.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "module.exports = Index;"
                    ]
                },
                "versions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * Copyright (c) 2017-present, Facebook, Inc.",
                        " *",
                        " * This source code is licensed under the MIT license found in the",
                        " * LICENSE file in the root directory of this source tree.",
                        " */",
                        "",
                        "const React = require(\"react\");",
                        "const { Container } = require(\"../../core/CompLibrary.js\");",
                        "",
                        "const CWD = process.cwd();",
                        "",
                        "const versions = require(`${CWD}/versions.json`);",
                        "",
                        "const rootPackageJson = require(`${CWD}/../package.json`);",
                        "const defaultBranchVersion = rootPackageJson.version;",
                        "const isDefaultBranchDevVersion = defaultBranchVersion.endsWith(\"-dev\");",
                        "const devVersion = isDefaultBranchDevVersion ? defaultBranchVersion : null;",
                        "const latestVersion = isDefaultBranchDevVersion",
                        "  ? rootPackageJson.devDependencies.prettier",
                        "  : defaultBranchVersion;",
                        "const [latestDocsVersion, ...pastDocsVersions] = versions;",
                        "",
                        "function Versions(props) {",
                        "  const { config: siteConfig } = props;",
                        "  return (",
                        "    <div className=\"docMainWrapper wrapper\">",
                        "      <Container className=\"mainContainer versionsContainer\">",
                        "        <div className=\"post\">",
                        "          <header className=\"postHeader\">",
                        "            <h1>{siteConfig.title} Versions</h1>",
                        "          </header>",
                        "          <table className=\"versions\">",
                        "            <tbody>",
                        "              <tr>",
                        "                <th>Version</th>",
                        "                <th>Install with</th>",
                        "                <th>Documentation</th>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{latestVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/index.html`}>",
                        "                    {latestDocsVersion}",
                        "                  </a>{\" \"}",
                        "                  (latest)",
                        "                </td>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{devVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier/prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/next/index.html`}>",
                        "                    next",
                        "                  </a>{\" \"}",
                        "                  (main)",
                        "                </td>",
                        "              </tr>",
                        "              {pastDocsVersions.length > 0 &&",
                        "                pastDocsVersions.map((pastDocsVersion, index) => {",
                        "                  const pastMajorVersion = pastDocsVersion.replace(/^v/, \"\");",
                        "                  return (",
                        "                    <tr key={index}>",
                        "                      <td>{pastMajorVersion}.x</td>",
                        "                      <td>",
                        "                        <code>",
                        "                          npm install prettier@",
                        "                          {pastMajorVersion}",
                        "                        </code>",
                        "                      </td>",
                        "                      <td>",
                        "                        <a",
                        "                          href={`${siteConfig.baseUrl}docs/en/${pastDocsVersion}/index.html`}",
                        "                        >",
                        "                          {pastDocsVersion}",
                        "                        </a>",
                        "                      </td>",
                        "                    </tr>",
                        "                  );",
                        "                })}",
                        "            </tbody>",
                        "          </table>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "module.exports = Versions;"
                    ]
                },
                "help": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container, GridBlock } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "class Help extends React.Component {",
                            "  render() {",
                            "    const supportLinks = [",
                            "      {",
                            "        content:",
                            "          \"Learn more using the [documentation on this site.](/docs/en/why-prettier.html)\\n\",",
                            "        title: \"Browse Docs\",",
                            "      },",
                            "      {",
                            "        content: \"Ask questions about the documentation and project\\n\",",
                            "        title: \"Join the community\",",
                            "      },",
                            "      {",
                            "        content: \"Find out what's new with this project\\n\",",
                            "        title: \"Stay up to date\",",
                            "      },",
                            "    ];",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"docMainWrapper wrapper\">",
                            "          <Container className=\"mainContainer documentContainer postContainer\">",
                            "            <div className=\"post\">",
                            "              <header className=\"postHeader\">",
                            "                <h2>Need help?</h2>",
                            "              </header>",
                            "              <p>This project is maintained by a dedicated group of people;</p>",
                            "              <GridBlock contents={supportLinks} layout=\"threeColumn\" />",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Help.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "module.exports = Help;"
                        ]
                    }
                },
                "users": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                            "",
                            "class Users extends React.Component {",
                            "  render() {",
                            "    const showcase = siteConfig.users.map((user, i) => (",
                            "      <a key={i} href={user.infoLink}>",
                            "        <img src={user.image} title={user.caption} />",
                            "      </a>",
                            "    ));",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"mainContainer\">",
                            "          <Container padding={[\"bottom\", \"top\"]}>",
                            "            <div className=\"showcaseSection\">",
                            "              <div className=\"prose\">",
                            "                <h1>Who’s Using This?</h1>",
                            "              </div>",
                            "              <blockquote",
                            "                style={{",
                            "                  fontSize: \"125%\",",
                            "                  textAlign: \"left\",",
                            "                }}",
                            "              >",
                            "                <p>Prettier is regularly used by:</p>",
                            "                <ul>",
                            "                  <li>",
                            "                    <a href=\"https://2021.stateofjs.com/en-US/other-tools/#utilities\">",
                            "                      More than <strong>83%</strong> of respondents to State of",
                            "                      JS 2021 (10282 developers out of 12360).",
                            "                    </a>",
                            "                  </li>",
                            "                  <li>",
                            "                    <a href=\"https://2020.stateofjs.com/en-US/other-tools/#utilities\">",
                            "                      More than <strong>70%</strong> of respondents to State of",
                            "                      JS 2020 (14880 developers out of 20974).",
                            "                    </a>",
                            "                  </li>",
                            "                </ul>",
                            "              </blockquote>",
                            "              <div className=\"logos\">{showcase}</div>",
                            "              <div className=\"prose\">",
                            "                ...and{\" \"}",
                            "                <a href=\"https://www.npmjs.com/browse/depended/prettier\">",
                            "                  many more projects",
                            "                </a>",
                            "              </div>",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Users.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "Users.title = \"Who's using Prettier?\";",
                            "",
                            "module.exports = Users;"
                        ]
                    }
                }
            },
            "playground": {
                "index.html": {}
            }
        },
        "playground": {
            "BottomBar.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"bottom-bar\");",
                    "",
                    "export default function BottomBar({ left, right }) {",
                    "  return ReactDOM.createPortal(",
                    "    <React.Fragment>",
                    "      <div className=\"bottom-bar-buttons\">{left}</div>",
                    "      <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">{right}</div>",
                    "    </React.Fragment>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "EditorState.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { stateToggler, shallowEqual } from \"./helpers.js\";",
                    "import * as storage from \"./storage.js\";",
                    "",
                    "export default class EditorState extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = {",
                    "      showSidebar: window.innerWidth > window.innerHeight,",
                    "      showAst: false,",
                    "      showPreprocessedAst: false,",
                    "      showDoc: false,",
                    "      showComments: false,",
                    "      showSecondFormat: false,",
                    "      showInput: true,",
                    "      showOutput: true,",
                    "      rethrowEmbedErrors: false,",
                    "      toggleSidebar: () => this.setState(stateToggler(\"showSidebar\")),",
                    "      toggleAst: () => this.setState(stateToggler(\"showAst\")),",
                    "      togglePreprocessedAst: () =>",
                    "        this.setState(stateToggler(\"showPreprocessedAst\")),",
                    "      toggleDoc: () => this.setState(stateToggler(\"showDoc\")),",
                    "      toggleComments: () => this.setState(stateToggler(\"showComments\")),",
                    "      toggleSecondFormat: () => this.setState(stateToggler(\"showSecondFormat\")),",
                    "      toggleInput: () => this.setState(stateToggler(\"showInput\")),",
                    "      toggleOutput: () => this.setState(stateToggler(\"showOutput\")),",
                    "      toggleEmbedErrors: () =>",
                    "        this.setState(stateToggler(\"rethrowEmbedErrors\")),",
                    "      ...storage.get(\"editor_state\"),",
                    "    };",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    if (!shallowEqual(this.state, prevState)) {",
                    "      storage.set(\"editor_state\", this.state);",
                    "    }",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "Playground.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { Button, ClipboardButton } from \"./buttons.js\";",
                    "import EditorState from \"./EditorState.js\";",
                    "import { DebugPanel, InputPanel, OutputPanel } from \"./panels.js\";",
                    "import PrettierFormat from \"./PrettierFormat.js\";",
                    "import { shallowEqual } from \"./helpers.js\";",
                    "import * as urlHash from \"./urlHash.js\";",
                    "import formatMarkdown from \"./markdown.js\";",
                    "import * as util from \"./util.js\";",
                    "import generateDummyId from \"./dummyId.js\";",
                    "import getCodeSample from \"./codeSamples.mjs\";",
                    "",
                    "import { Sidebar, SidebarCategory } from \"./sidebar/components.js\";",
                    "import SidebarOptions from \"./sidebar/SidebarOptions.js\";",
                    "import Option from \"./sidebar/options.js\";",
                    "import { Checkbox } from \"./sidebar/inputs.js\";",
                    "",
                    "const CATEGORIES_ORDER = [",
                    "  \"Global\",",
                    "  \"Common\",",
                    "  \"JavaScript\",",
                    "  \"Markdown\",",
                    "  \"HTML\",",
                    "  \"Special\",",
                    "];",
                    "const ISSUES_URL = \"https://github.com/prettier/prettier/issues/new?body=\";",
                    "const MAX_LENGTH = 8000 - ISSUES_URL.length; // it seems that GitHub limit is 8195",
                    "const COPY_MESSAGE =",
                    "  \"<!-- The issue body has been saved to the clipboard. Please paste it after this line! 👇 -->\\n\";",
                    "",
                    "const ENABLED_OPTIONS = [",
                    "  \"parser\",",
                    "  \"printWidth\",",
                    "  \"tabWidth\",",
                    "  \"useTabs\",",
                    "  \"semi\",",
                    "  \"singleQuote\",",
                    "  \"bracketSpacing\",",
                    "  \"jsxSingleQuote\",",
                    "  \"quoteProps\",",
                    "  \"arrowParens\",",
                    "  \"trailingComma\",",
                    "  \"proseWrap\",",
                    "  \"htmlWhitespaceSensitivity\",",
                    "  \"insertPragma\",",
                    "  \"requirePragma\",",
                    "  \"vueIndentScriptAndStyle\",",
                    "  \"embeddedLanguageFormatting\",",
                    "  \"bracketSameLine\",",
                    "  \"singleAttributePerLine\",",
                    "];",
                    "",
                    "class Playground extends React.Component {",
                    "  constructor(props) {",
                    "    super();",
                    "",
                    "    const original = urlHash.read();",
                    "",
                    "    const defaultOptions = util.getDefaults(",
                    "      props.availableOptions,",
                    "      ENABLED_OPTIONS",
                    "    );",
                    "",
                    "    const options = Object.assign(defaultOptions, original.options);",
                    "",
                    "    // 0.0.0 ~ 0.0.10",
                    "    if (options.parser === \"babylon\") {",
                    "      options.parser = \"babel\";",
                    "    }",
                    "",
                    "    // 0.0.0 ~ 0.0.10",
                    "    if (options.useFlowParser) {",
                    "      options.parser ??= \"flow\";",
                    "    }",
                    "",
                    "    // 1.8.2 ~ 1.9.0",
                    "    if (typeof options.proseWrap === \"boolean\") {",
                    "      options.proseWrap = options.proseWrap ? \"always\" : \"never\";",
                    "    }",
                    "",
                    "    // 0.0.0 ~ 1.9.0",
                    "    if (typeof options.trailingComma === \"boolean\") {",
                    "      options.trailingComma = options.trailingComma ? \"es5\" : \"none\";",
                    "    }",
                    "",
                    "    // 0.17.0 ~ 2.4.0",
                    "    if (options.jsxBracketSameLine) {",
                    "      delete options.jsxBracketSameLine;",
                    "      options.bracketSameLine ??= options.jsxBracketSameLine;",
                    "    }",
                    "",
                    "    const codeSample = getCodeSample(options.parser);",
                    "    const content = original.content || codeSample;",
                    "    const needsClickForFirstRun =",
                    "      options.parser === \"doc-explorer\" && content !== codeSample;",
                    "    const selection = {};",
                    "",
                    "    this.state = { content, options, selection, needsClickForFirstRun };",
                    "",
                    "    this.handleOptionValueChange = this.handleOptionValueChange.bind(this);",
                    "",
                    "    this.setContent = (content) => this.setState({ content });",
                    "    this.clearContent = this.setContent.bind(this, \"\");",
                    "    this.resetOptions = () => this.setState({ options: defaultOptions });",
                    "    this.setSelection = (selection) => this.setState({ selection });",
                    "    this.setSelectionAsRange = () => {",
                    "      const { selection, content, options } = this.state;",
                    "      const [rangeStart, rangeEnd] = util.convertSelectionToRange(",
                    "        selection,",
                    "        content",
                    "      );",
                    "      const updatedOptions = { ...options, rangeStart, rangeEnd };",
                    "      if (rangeStart === rangeEnd) {",
                    "        delete updatedOptions.rangeStart;",
                    "        delete updatedOptions.rangeEnd;",
                    "      }",
                    "      this.setState({ options: updatedOptions });",
                    "    };",
                    "",
                    "    this.enabledOptions = orderOptions(props.availableOptions, ENABLED_OPTIONS);",
                    "    this.rangeStartOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeStart\"",
                    "    );",
                    "    this.rangeEndOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeEnd\"",
                    "    );",
                    "",
                    "    this.formatInput = this.formatInput.bind(this);",
                    "    this.insertDummyId = this.insertDummyId.bind(this);",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    const { content, options } = this.state;",
                    "    if (",
                    "      !shallowEqual(prevState.options, this.state.options) ||",
                    "      prevState.content !== content",
                    "    ) {",
                    "      urlHash.replace({ content, options });",
                    "    }",
                    "  }",
                    "",
                    "  handleOptionValueChange(option, value) {",
                    "    this.setState((state) => {",
                    "      const options = { ...state.options };",
                    "",
                    "      if (option.type === \"int\" && Number.isNaN(value)) {",
                    "        delete options[option.name];",
                    "      } else {",
                    "        options[option.name] = value;",
                    "      }",
                    "",
                    "      const content =",
                    "        state.content === \"\" ||",
                    "        state.content === getCodeSample(state.options.parser)",
                    "          ? getCodeSample(options.parser)",
                    "          : state.content;",
                    "",
                    "      if (option.name === \"parser\") {",
                    "        state.needsClickForFirstRun = false;",
                    "      }",
                    "",
                    "      return { options, content };",
                    "    });",
                    "  }",
                    "",
                    "  getMarkdown({ formatted, reformatted, full, doc }) {",
                    "    const { content, options } = this.state;",
                    "    const { availableOptions, version } = this.props;",
                    "    const orderedOptions = orderOptions(availableOptions, [",
                    "      ...ENABLED_OPTIONS,",
                    "      \"rangeStart\",",
                    "      \"rangeEnd\",",
                    "    ]);",
                    "    const cliOptions = util.buildCliArgs(orderedOptions, options);",
                    "",
                    "    return formatMarkdown({",
                    "      input: content,",
                    "      output: formatted,",
                    "      output2: reformatted,",
                    "      doc,",
                    "      version,",
                    "      url: window.location.href,",
                    "      options,",
                    "      cliOptions,",
                    "      full,",
                    "    });",
                    "  }",
                    "",
                    "  formatInput() {",
                    "    if (this.state.options.parser !== \"doc-explorer\") {",
                    "      return;",
                    "    }",
                    "",
                    "    const { content, selection } = this.state;",
                    "",
                    "    return this.props.worker",
                    "      .format(content, {",
                    "        parser: \"__js_expression\",",
                    "        cursorOffset: util.convertSelectionToRange(selection, content)[0],",
                    "      })",
                    "      .then(({ error, formatted, cursorOffset }) => {",
                    "        if (error) {",
                    "          return;",
                    "        }",
                    "",
                    "        this.setState({",
                    "          content: formatted,",
                    "          selection: util.convertOffsetToSelection(cursorOffset, formatted),",
                    "        });",
                    "      });",
                    "  }",
                    "",
                    "  insertDummyId() {",
                    "    const { content, selection } = this.state;",
                    "    const dummyId = generateDummyId();",
                    "    const range = util.convertSelectionToRange(selection, content);",
                    "    const modifiedContent =",
                    "      content.slice(0, range[0]) + dummyId + content.slice(range[1]);",
                    "",
                    "    this.setState({",
                    "      content: modifiedContent,",
                    "      selection: util.convertOffsetToSelection(",
                    "        range[0] + dummyId.length,",
                    "        modifiedContent",
                    "      ),",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { worker } = this.props;",
                    "    const { content, options } = this.state;",
                    "",
                    "    return (",
                    "      <EditorState>",
                    "        {(editorState) => (",
                    "          <PrettierFormat",
                    "            enabled={!this.state.needsClickForFirstRun}",
                    "            worker={worker}",
                    "            code={content}",
                    "            options={options}",
                    "            debugAst={editorState.showAst}",
                    "            debugPreprocessedAst={editorState.showPreprocessedAst}",
                    "            debugDoc={editorState.showDoc}",
                    "            debugComments={editorState.showComments}",
                    "            reformat={editorState.showSecondFormat}",
                    "            rethrowEmbedErrors={editorState.rethrowEmbedErrors}",
                    "          >",
                    "            {({ formatted, debug }) => {",
                    "              const fullReport = this.getMarkdown({",
                    "                formatted,",
                    "                reformatted: debug.reformatted,",
                    "                full: true,",
                    "              });",
                    "              const showFullReport =",
                    "                encodeURIComponent(fullReport).length < MAX_LENGTH;",
                    "              return (",
                    "                <React.Fragment>",
                    "                  <div className=\"editors-container\">",
                    "                    <Sidebar visible={editorState.showSidebar}>",
                    "                      <SidebarOptions",
                    "                        categories={CATEGORIES_ORDER}",
                    "                        availableOptions={this.enabledOptions}",
                    "                        optionValues={options}",
                    "                        onOptionValueChange={this.handleOptionValueChange}",
                    "                      />",
                    "                      <SidebarCategory title=\"Range\">",
                    "                        <label>",
                    "                          The selected range will be highlighted in yellow in",
                    "                          the input editor",
                    "                        </label>",
                    "                        <Option",
                    "                          option={this.rangeStartOption}",
                    "                          value={",
                    "                            typeof options.rangeStart === \"number\"",
                    "                              ? options.rangeStart",
                    "                              : \"\"",
                    "                          }",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "                        <Option",
                    "                          option={this.rangeEndOption}",
                    "                          value={",
                    "                            typeof options.rangeEnd === \"number\"",
                    "                              ? options.rangeEnd",
                    "                              : \"\"",
                    "                          }",
                    "                          overrideMax={content.length}",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "",
                    "                        <Button onClick={this.setSelectionAsRange}>",
                    "                          Set selected text as range",
                    "                        </Button>",
                    "                      </SidebarCategory>",
                    "                      <SidebarCategory title=\"Debug\">",
                    "                        <Checkbox",
                    "                          label=\"show input\"",
                    "                          checked={editorState.showInput}",
                    "                          onChange={editorState.toggleInput}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show AST\"",
                    "                          checked={editorState.showAst}",
                    "                          onChange={editorState.toggleAst}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show preprocessed AST\"",
                    "                          checked={editorState.showPreprocessedAst}",
                    "                          onChange={editorState.togglePreprocessedAst}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show doc\"",
                    "                          checked={editorState.showDoc}",
                    "                          onChange={editorState.toggleDoc}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show comments\"",
                    "                          checked={editorState.showComments}",
                    "                          onChange={editorState.toggleComments}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show output\"",
                    "                          checked={editorState.showOutput}",
                    "                          onChange={editorState.toggleOutput}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show second format\"",
                    "                          checked={editorState.showSecondFormat}",
                    "                          onChange={editorState.toggleSecondFormat}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"rethrow embed errors\"",
                    "                          checked={editorState.rethrowEmbedErrors}",
                    "                          onChange={editorState.toggleEmbedErrors}",
                    "                        />",
                    "                        {editorState.showDoc && (",
                    "                          <ClipboardButton",
                    "                            copy={() => this.getMarkdown({ doc: debug.doc })}",
                    "                            disabled={!debug.doc}",
                    "                          >",
                    "                            Copy doc",
                    "                          </ClipboardButton>",
                    "                        )}",
                    "                      </SidebarCategory>",
                    "                      <div className=\"sub-options\">",
                    "                        <Button onClick={this.resetOptions}>",
                    "                          Reset to defaults",
                    "                        </Button>",
                    "                      </div>",
                    "                    </Sidebar>",
                    "                    <div className=\"editors\">",
                    "                      {editorState.showInput ? (",
                    "                        <InputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          ruler={options.printWidth}",
                    "                          value={content}",
                    "                          selection={this.state.selection}",
                    "                          codeSample={getCodeSample(options.parser)}",
                    "                          overlayStart={options.rangeStart}",
                    "                          overlayEnd={options.rangeEnd}",
                    "                          onChange={this.setContent}",
                    "                          onSelectionChange={this.setSelection}",
                    "                          extraKeys={{",
                    "                            \"Shift-Alt-F\": this.formatInput,",
                    "                            \"Ctrl-Q\": this.insertDummyId,",
                    "                          }}",
                    "                          foldGutter={options.parser === \"doc-explorer\"}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showAst ? (",
                    "                        <DebugPanel",
                    "                          value={debug.ast || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showPreprocessedAst ? (",
                    "                        <DebugPanel",
                    "                          value={debug.preprocessedAst || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showDoc ? (",
                    "                        <DebugPanel value={debug.doc || \"\"} />",
                    "                      ) : null}",
                    "                      {editorState.showComments ? (",
                    "                        <DebugPanel",
                    "                          value={debug.comments || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showOutput ? (",
                    "                        this.state.needsClickForFirstRun ? (",
                    "                          <div className=\"editor disabled-output-panel\">",
                    "                            <div className=\"explanation\">",
                    "                              <code>doc-explorer</code> involves running code",
                    "                              provided by users.",
                    "                            </div>",
                    "                            <div className=\"explanation\">",
                    "                              To stay on the safe side and prevent abuse, an",
                    "                              explicit user action is required when a direct",
                    "                              link to a <code>doc-explorer</code> playground is",
                    "                              opened.",
                    "                            </div>",
                    "                            <div className=\"explanation\">",
                    "                              Click the button below to start the playground.",
                    "                            </div>",
                    "                            <Button",
                    "                              onClick={() =>",
                    "                                this.setState({ needsClickForFirstRun: false })",
                    "                              }",
                    "                            >",
                    "                              Start",
                    "                            </Button>",
                    "                          </div>",
                    "                        ) : (",
                    "                          <OutputPanel",
                    "                            mode={util.getCodemirrorMode(options.parser)}",
                    "                            value={formatted}",
                    "                            ruler={options.printWidth}",
                    "                          />",
                    "                        )",
                    "                      ) : null}",
                    "                      {editorState.showSecondFormat ? (",
                    "                        <OutputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          value={getSecondFormat(formatted, debug.reformatted)}",
                    "                          ruler={options.printWidth}",
                    "                        />",
                    "                      ) : null}",
                    "                    </div>",
                    "                  </div>",
                    "                  <div className=\"bottom-bar\">",
                    "                    <div className=\"bottom-bar-buttons\">",
                    "                      <Button onClick={editorState.toggleSidebar}>",
                    "                        {editorState.showSidebar ? \"Hide\" : \"Show\"} options",
                    "                      </Button>",
                    "                      <Button onClick={this.clearContent}>Clear</Button>",
                    "                      <ClipboardButton",
                    "                        copy={JSON.stringify(",
                    "                          // Remove `parser` since people usually paste this",
                    "                          // into their .prettierrc and specifying a top-level",
                    "                          // parser there is an anti-pattern. Note:",
                    "                          // `JSON.stringify` omits keys whose values are",
                    "                          // `undefined`.",
                    "                          { ...options, parser: undefined },",
                    "                          null,",
                    "                          2",
                    "                        )}",
                    "                      >",
                    "                        Copy config JSON",
                    "                      </ClipboardButton>",
                    "                      <Button",
                    "                        onClick={this.insertDummyId}",
                    "                        onMouseDown={(event) => event.preventDefault()} // prevent button from focusing",
                    "                        title=\"Generate a nonsense variable name (Ctrl-Q)\"",
                    "                      >",
                    "                        Insert dummy id",
                    "                      </Button>",
                    "                    </div>",
                    "                    <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">",
                    "                      <ClipboardButton copy={window.location.href}>",
                    "                        Copy link",
                    "                      </ClipboardButton>",
                    "                      <ClipboardButton",
                    "                        copy={() =>",
                    "                          this.getMarkdown({",
                    "                            formatted,",
                    "                            reformatted: debug.reformatted,",
                    "                          })",
                    "                        }",
                    "                      >",
                    "                        Copy markdown",
                    "                      </ClipboardButton>",
                    "                      <a",
                    "                        href={getReportLink(",
                    "                          showFullReport ? fullReport : COPY_MESSAGE",
                    "                        )}",
                    "                        target=\"_blank\"",
                    "                        rel=\"noopener noreferrer\"",
                    "                      >",
                    "                        <ClipboardButton",
                    "                          copy={() => (showFullReport ? \"\" : fullReport)}",
                    "                        >",
                    "                          Report issue",
                    "                        </ClipboardButton>",
                    "                      </a>",
                    "                    </div>",
                    "                  </div>",
                    "                </React.Fragment>",
                    "              );",
                    "            }}",
                    "          </PrettierFormat>",
                    "        )}",
                    "      </EditorState>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function orderOptions(availableOptions, order) {",
                    "  const optionsByName = {};",
                    "  for (const option of availableOptions) {",
                    "    optionsByName[option.name] = option;",
                    "  }",
                    "",
                    "  return order.map((name) => optionsByName[name]);",
                    "}",
                    "",
                    "function getReportLink(reportBody) {",
                    "  return `${ISSUES_URL}${encodeURIComponent(reportBody)}`;",
                    "}",
                    "",
                    "function getSecondFormat(formatted, reformatted) {",
                    "  return formatted === \"\"",
                    "    ? \"\"",
                    "    : formatted === reformatted",
                    "    ? \"✓ Second format is unchanged.\"",
                    "    : reformatted;",
                    "}",
                    "",
                    "export default Playground;"
                ]
            },
            "PrettierFormat.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "export default class PrettierFormat extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { formatted: \"\", debug: {} };",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.format();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    for (const key of [",
                    "      \"enabled\",",
                    "      \"code\",",
                    "      \"options\",",
                    "      \"debugAst\",",
                    "      \"debugPreprocessedAst\",",
                    "      \"debugDoc\",",
                    "      \"debugComments\",",
                    "      \"reformat\",",
                    "      \"rethrowEmbedErrors\",",
                    "    ]) {",
                    "      if (prevProps[key] !== this.props[key]) {",
                    "        this.format();",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  async format() {",
                    "    const {",
                    "      enabled,",
                    "      worker,",
                    "      code,",
                    "      options,",
                    "      debugAst: ast,",
                    "      debugPreprocessedAst: preprocessedAst,",
                    "      debugDoc: doc,",
                    "      debugComments: comments,",
                    "      reformat,",
                    "      rethrowEmbedErrors,",
                    "    } = this.props;",
                    "",
                    "    if (!enabled) {",
                    "      return;",
                    "    }",
                    "",
                    "    const result = await worker.format(code, options, {",
                    "      ast,",
                    "      preprocessedAst,",
                    "      doc,",
                    "      comments,",
                    "      reformat,",
                    "      rethrowEmbedErrors,",
                    "    });",
                    "",
                    "    this.setState(result);",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "VersionLink.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"version\");",
                    "",
                    "export default function VersionLink({ version }) {",
                    "  const match = version.match(/^pr-(\\d+)$/);",
                    "  let href;",
                    "  if (match) {",
                    "    href = `pull/${match[1]}`;",
                    "  } else if (/\\.0$/.test(version)) {",
                    "    href = `releases/tag/${version}`;",
                    "  } else {",
                    "    href = `blob/main/CHANGELOG.md#${version.replaceAll(\".\", \"\")}`;",
                    "  }",
                    "",
                    "  const formattedVersion = match ? `PR #${match[1]}` : `v${version}`;",
                    "",
                    "  React.useEffect(() => {",
                    "    document.title = `Prettier ${formattedVersion}`;",
                    "  }, [formattedVersion]);",
                    "",
                    "  return ReactDOM.createPortal(",
                    "    <a",
                    "      href={`https://github.com/prettier/prettier/${href}`}",
                    "      target=\"_blank\"",
                    "      rel=\"noreferrer noopener\"",
                    "    >",
                    "      {formattedVersion}",
                    "    </a>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "WorkerApi.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export default function WorkerApi(source) {",
                    "  const worker = new Worker(source);",
                    "  let counter = 0;",
                    "  const handlers = {};",
                    "",
                    "  worker.addEventListener(\"message\", (event) => {",
                    "    const { uid, message, error } = event.data;",
                    "",
                    "    if (!handlers[uid]) {",
                    "      return;",
                    "    }",
                    "",
                    "    const [resolve, reject] = handlers[uid];",
                    "    delete handlers[uid];",
                    "",
                    "    if (error) {",
                    "      reject(error);",
                    "    } else {",
                    "      resolve(message);",
                    "    }",
                    "  });",
                    "",
                    "  function postMessage(message) {",
                    "    const uid = ++counter;",
                    "    return new Promise((resolve, reject) => {",
                    "      handlers[uid] = [resolve, reject];",
                    "      worker.postMessage({ uid, message });",
                    "    });",
                    "  }",
                    "",
                    "  return {",
                    "    getMetadata() {",
                    "      return postMessage({ type: \"meta\" });",
                    "    },",
                    "    format(code, options, debug = {}) {",
                    "      return postMessage({ type: \"format\", code, options, debug });",
                    "    },",
                    "    postMessage,",
                    "  };",
                    "}"
                ]
            },
            "buttons.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import ClipboardJS from \"clipboard\";",
                    "",
                    "export const Button = React.forwardRef((props, ref) => (",
                    "  <button type=\"button\" className=\"btn\" ref={ref} {...props} />",
                    "));",
                    "",
                    "export class ClipboardButton extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { showTooltip: false, tooltipText: \"\" };",
                    "    this.timer = null;",
                    "    this.ref = React.createRef();",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.clipboard = new ClipboardJS(this.ref.current, {",
                    "      text: () => {",
                    "        const { copy } = this.props;",
                    "        return typeof copy === \"function\" ? copy() : copy;",
                    "      },",
                    "    });",
                    "    this.clipboard.on(\"success\", () => this.showTooltip(\"Copied!\"));",
                    "    this.clipboard.on(\"error\", () => this.showTooltip(\"Press ctrl+c to copy\"));",
                    "  }",
                    "",
                    "  showTooltip(text) {",
                    "    this.setState({ showTooltip: true, tooltipText: text }, () => {",
                    "      if (this.timer) {",
                    "        clearTimeout(this.timer);",
                    "      }",
                    "      this.timer = setTimeout(() => {",
                    "        this.timer = null;",
                    "        this.setState({ showTooltip: false });",
                    "      }, 2000);",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { children, copy, ...rest } = this.props;",
                    "    const { showTooltip, tooltipText } = this.state;",
                    "",
                    "    return (",
                    "      <Button ref={this.ref} {...rest}>",
                    "        {showTooltip ? <span className=\"tooltip\">{tooltipText}</span> : null}",
                    "        {children}",
                    "      </Button>",
                    "    );",
                    "  }",
                    "}"
                ]
            },
            "codeSamples.mjs": {},
            "dummyId.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* cSpell:disable */",
                    "const dummyAdjectives = [",
                    "  \"annular\",",
                    "  \"abugidic\",",
                    "  \"cantilevered\",",
                    "  \"equidistant\",",
                    "  \"hippopotamic\",",
                    "  \"octahedral\",",
                    "  \"particolored\",",
                    "  \"quadrupedal\",",
                    "  \"stellated\",",
                    "  \"transdecimal\",",
                    "];",
                    "",
                    "const dummyNouns = [",
                    "  \"anteater\",",
                    "  \"dingbat\",",
                    "  \"dinosaur\",",
                    "  \"fossil\",",
                    "  \"kangaroo\",",
                    "  \"palimpsest\",",
                    "  \"platypus\",",
                    "  \"rhinoceros\",",
                    "  \"rhubarb\",",
                    "  \"romanocastor\",",
                    "  \"smorgasbord\",",
                    "  \"thingamabob\",",
                    "  \"weevil\",",
                    "  \"zamazingo\",",
                    "];",
                    "",
                    "const dummyFinalNouns = [",
                    "  \"factory\",",
                    "  \"generator\",",
                    "  \"mutator\",",
                    "  \"processor\",",
                    "  \"provider\",",
                    "  \"replacer\",",
                    "  \"resolver\",",
                    "  \"service\",",
                    "  \"transformer\",",
                    "  \"wrapper\",",
                    "];",
                    "// cSpell:enable",
                    "",
                    "function getRandomElement(array) {",
                    "  return array[Math.floor(Math.random() * array.length)];",
                    "}",
                    "",
                    "function camelCase(string) {",
                    "  return string.replaceAll(/_(\\w)/g, (_, c) => c.toUpperCase());",
                    "}",
                    "",
                    "export default function generateDummyId() {",
                    "  return camelCase(",
                    "    [dummyAdjectives, dummyNouns, dummyFinalNouns]",
                    "      .map(getRandomElement)",
                    "      .join(\"_\")",
                    "  );",
                    "}"
                ]
            },
            "helpers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function stateToggler(key) {",
                    "  return (state) => ({ [key]: !state[key] });",
                    "}",
                    "",
                    "const { hasOwnProperty } = Object.prototype;",
                    "",
                    "function is(x, y) {",
                    "  // SameValue algorithm",
                    "  if (x === y) {",
                    "    // Steps 1-5, 7-10",
                    "    // Steps 6.b-6.e: +0 != -0",
                    "    return x !== 0 || 1 / x === 1 / y;",
                    "  }",
                    "  // Step 6.a: NaN == NaN",
                    "  return x !== x && y !== y;",
                    "}",
                    "",
                    "export function shallowEqual(objA, objB) {",
                    "  if (is(objA, objB)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    typeof objA !== \"object\" ||",
                    "    objA === null ||",
                    "    typeof objB !== \"object\" ||",
                    "    objB === null",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const keysA = Object.keys(objA);",
                    "  const keysB = Object.keys(objB);",
                    "",
                    "  if (keysA.length !== keysB.length) {",
                    "    return false;",
                    "  }",
                    "",
                    "  for (let i = 0; i < keysA.length; i++) {",
                    "    if (",
                    "      !hasOwnProperty.call(objB, keysA[i]) ||",
                    "      !is(objA[keysA[i]], objB[keysA[i]])",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import \"codemirror-graphql/mode\";",
                    "",
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "import Playground from \"./Playground.js\";",
                    "import VersionLink from \"./VersionLink.js\";",
                    "import WorkerApi from \"./WorkerApi.js\";",
                    "import { fixPrettierVersion } from \"./util.js\";",
                    "",
                    "class App extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { loaded: false };",
                    "    this.worker = new WorkerApi(\"/worker.js\");",
                    "  }",
                    "",
                    "  async componentDidMount() {",
                    "    const { supportInfo, version } = await this.worker.getMetadata();",
                    "",
                    "    this.setState({",
                    "      loaded: true,",
                    "      availableOptions: supportInfo.options.map(augmentOption),",
                    "      version: fixPrettierVersion(version),",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { loaded, availableOptions, version } = this.state;",
                    "",
                    "    if (!loaded) {",
                    "      return \"Loading...\";",
                    "    }",
                    "",
                    "    return (",
                    "      <React.Fragment>",
                    "        <VersionLink version={version} />",
                    "        <Playground",
                    "          worker={this.worker}",
                    "          availableOptions={availableOptions}",
                    "          version={version}",
                    "        />",
                    "      </React.Fragment>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function augmentOption(option) {",
                    "  if (option.type === \"boolean\" && option.default === true) {",
                    "    option.inverted = true;",
                    "  }",
                    "",
                    "  option.cliName =",
                    "    \"--\" +",
                    "    (option.inverted ? \"no-\" : \"\") +",
                    "    option.name.replaceAll(/(?<=[a-z])(?=[A-Z])/g, \"-\").toLowerCase();",
                    "",
                    "  return option;",
                    "}",
                    "",
                    "ReactDOM.render(<App />, document.getElementById(\"root\"));"
                ]
            },
            "markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function formatMarkdown({",
                    "  input,",
                    "  output,",
                    "  output2,",
                    "  doc,",
                    "  version,",
                    "  url,",
                    "  options,",
                    "  cliOptions,",
                    "  full,",
                    "}) {",
                    "  const syntax = getMarkdownSyntax(options);",
                    "  const optionsString = formatCLIOptions(cliOptions);",
                    "  const isIdempotent = !output2 || output === output2;",
                    "",
                    "  return [",
                    "    `**Prettier ${version}**`,",
                    "    `[Playground link](${url})`,",
                    "    optionsString === \"\" ? null : codeBlock(optionsString, \"sh\"),",
                    "    \"\",",
                    "    \"**Input:**\",",
                    "    codeBlock(input, syntax),",
                    "    ...(doc ? [\"\", \"**Doc:**\", codeBlock(doc, \"js\")] : []),",
                    "    ...(output === undefined",
                    "      ? []",
                    "      : [\"\", \"**Output:**\", codeBlock(output, syntax)]),",
                    "    ...(isIdempotent",
                    "      ? []",
                    "      : [\"\", \"**Second Output:**\", codeBlock(output2, syntax)]),",
                    "    ...(full ? [\"\", \"**Expected behavior:**\", \"\"] : []),",
                    "  ]",
                    "    .filter((part) => part !== null)",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function getMarkdownSyntax(options) {",
                    "  switch (options.parser) {",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"flow\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"doc-explorer\":",
                    "      return \"jsx\";",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "      return \"tsx\";",
                    "    case \"json\":",
                    "    case \"json-stringify\":",
                    "      return \"jsonc\";",
                    "    case \"glimmer\":",
                    "      return \"hbs\";",
                    "    case \"angular\":",
                    "    case \"lwc\":",
                    "      return \"html\";",
                    "    default:",
                    "      return options.parser;",
                    "  }",
                    "}",
                    "",
                    "function formatCLIOptions(cliOptions) {",
                    "  return cliOptions",
                    "    .map(([name, value]) => (value === true ? name : `${name} ${value}`))",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function codeBlock(content, syntax) {",
                    "  const backtickSequences = content.match(/`+/g) || [];",
                    "  const longestBacktickSequenceLength = Math.max(",
                    "    ...backtickSequences.map(({ length }) => length)",
                    "  );",
                    "  const prettierIgnoreComment = \"<!-- prettier-ignore -->\";",
                    "  const fenceLength = Math.max(3, longestBacktickSequenceLength + 1);",
                    "  const fence = \"`\".repeat(fenceLength);",
                    "  return [prettierIgnoreComment, fence + (syntax || \"\"), content, fence].join(",
                    "    \"\\n\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = formatMarkdown;"
                ]
            },
            "panels.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import CodeMirror from \"codemirror\";",
                    "import * as React from \"react\";",
                    "",
                    "class CodeMirrorPanel extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this._textareaRef = React.createRef();",
                    "    this._codeMirror = null;",
                    "    this._cached = \"\";",
                    "    this._overlay = null;",
                    "    this.handleChange = this.handleChange.bind(this);",
                    "    this.handleFocus = this.handleFocus.bind(this);",
                    "    this.handleSelectionChange = this.handleSelectionChange.bind(this);",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    const options = { ...this.props };",
                    "    delete options.ruler;",
                    "    delete options.rulerColor;",
                    "    delete options.value;",
                    "    delete options.selection;",
                    "    delete options.onChange;",
                    "",
                    "    options.rulers = [makeRuler(this.props)];",
                    "    options.gutters = makeGutters(this.props);",
                    "",
                    "    this._codeMirror = CodeMirror.fromTextArea(",
                    "      this._textareaRef.current,",
                    "      options",
                    "    );",
                    "    this._codeMirror.on(\"change\", this.handleChange);",
                    "    this._codeMirror.on(\"focus\", this.handleFocus);",
                    "    this._codeMirror.on(\"beforeSelectionChange\", this.handleSelectionChange);",
                    "",
                    "    window.CodeMirror.keyMap.pcSublime[\"Ctrl-L\"] = false;",
                    "    window.CodeMirror.keyMap.sublime[\"Ctrl-L\"] = false;",
                    "",
                    "    this.updateValue(this.props.value || \"\");",
                    "    this.updateSelection();",
                    "    this.updateOverlay();",
                    "  }",
                    "",
                    "  componentWillUnmount() {",
                    "    this._codeMirror && this._codeMirror.toTextArea();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    if (this.props.value !== this._cached) {",
                    "      this.updateValue(this.props.value);",
                    "    }",
                    "    if (",
                    "      !isEqualSelection(this.props.selection, prevProps.selection) &&",
                    "      !isEqualSelection(",
                    "        this.props.selection,",
                    "        this._codeMirror.listSelections()[0]",
                    "      )",
                    "    ) {",
                    "      this.updateSelection();",
                    "    }",
                    "    if (",
                    "      this.props.overlayStart !== prevProps.overlayStart ||",
                    "      this.props.overlayEnd !== prevProps.overlayEnd",
                    "    ) {",
                    "      this.updateOverlay();",
                    "    }",
                    "    if (this.props.mode !== prevProps.mode) {",
                    "      this._codeMirror.setOption(\"mode\", this.props.mode);",
                    "    }",
                    "    if (this.props.ruler !== prevProps.ruler) {",
                    "      this._codeMirror.setOption(\"rulers\", [makeRuler(this.props)]);",
                    "    }",
                    "    if (this.props.foldGutter !== prevProps.foldGutter) {",
                    "      this._codeMirror.setOption(\"gutters\", makeGutters(this.props));",
                    "    }",
                    "  }",
                    "",
                    "  updateValue(value) {",
                    "    this._cached = value;",
                    "    this._codeMirror.setValue(value);",
                    "",
                    "    if (this.props.autoFold instanceof RegExp) {",
                    "      const lines = value.split(\"\\n\");",
                    "      // going backwards to prevent unfolding folds created earlier",
                    "      for (let i = lines.length - 1; i >= 0; i--) {",
                    "        if (this.props.autoFold.test(lines[i])) {",
                    "          this._codeMirror.foldCode(i);",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  updateSelection() {",
                    "    this._codeMirror.setSelection(",
                    "      this.props.selection?.anchor ?? { line: 0, ch: 0 },",
                    "      this.props.selection?.head",
                    "    );",
                    "  }",
                    "",
                    "  updateOverlay() {",
                    "    if (!this.props.readOnly) {",
                    "      if (this._overlay) {",
                    "        this._codeMirror.removeOverlay(this._overlay);",
                    "      }",
                    "      const [start, end] = getIndexPosition(this.props.value, [",
                    "        this.props.overlayStart,",
                    "        this.props.overlayEnd,",
                    "      ]);",
                    "      this._overlay = createOverlay(start, end);",
                    "      this._codeMirror.addOverlay(this._overlay);",
                    "    }",
                    "  }",
                    "",
                    "  handleFocus(/* codeMirror, event */) {",
                    "    if (this._codeMirror.getValue() === this.props.codeSample) {",
                    "      this._codeMirror.execCommand(\"selectAll\");",
                    "    }",
                    "  }",
                    "",
                    "  handleChange(doc, change) {",
                    "    if (change.origin !== \"setValue\") {",
                    "      this._cached = doc.getValue();",
                    "      this.props.onChange(this._cached);",
                    "      this.updateOverlay();",
                    "    }",
                    "  }",
                    "",
                    "  handleSelectionChange(doc, change) {",
                    "    this.props.onSelectionChange?.(change.ranges[0]);",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <div className=\"editor input\">",
                    "        <textarea ref={this._textareaRef} />",
                    "      </div>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function getIndexPosition(text, indexes) {",
                    "  indexes = [...indexes];",
                    "  let line = 0;",
                    "  let count = 0;",
                    "  let lineStart = 0;",
                    "  const result = [];",
                    "",
                    "  while (indexes.length > 0) {",
                    "    const index = indexes.shift();",
                    "",
                    "    while (count < index && count < text.length) {",
                    "      if (text[count] === \"\\n\") {",
                    "        line++;",
                    "        lineStart = count + 1;",
                    "      }",
                    "      count++;",
                    "    }",
                    "",
                    "    result.push({ line, pos: count - lineStart });",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function createOverlay(start, end) {",
                    "  return {",
                    "    token(stream) {",
                    "      const { line } = stream.lineOracle;",
                    "",
                    "      if (line < start.line || line > end.line) {",
                    "        stream.skipToEnd();",
                    "      } else if (line === start.line && stream.pos < start.pos) {",
                    "        stream.pos = start.pos;",
                    "      } else if (line === end.line) {",
                    "        if (stream.pos < end.pos) {",
                    "          stream.pos = end.pos;",
                    "          return \"searching\";",
                    "        }",
                    "        stream.skipToEnd();",
                    "      } else {",
                    "        stream.skipToEnd();",
                    "        return \"searching\";",
                    "      }",
                    "    },",
                    "  };",
                    "}",
                    "",
                    "function makeRuler(props) {",
                    "  return { column: props.ruler, color: props.rulerColor };",
                    "}",
                    "",
                    "function makeGutters(props) {",
                    "  return props.foldGutter",
                    "    ? [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"]",
                    "    : [];",
                    "}",
                    "",
                    "function isEqualSelection(selection1, selection2) {",
                    "  const anchor1 = selection1?.anchor ?? { line: 0, ch: 0 };",
                    "  const head1 = selection1?.head ?? anchor1;",
                    "  const anchor2 = selection2?.anchor ?? { line: 0, ch: 0 };",
                    "  const head2 = selection2?.head ?? anchor2;",
                    "  return (",
                    "    head1.line === head2.line &&",
                    "    head1.ch === head2.ch &&",
                    "    anchor1.line === anchor2.line &&",
                    "    anchor1.ch === anchor2.ch",
                    "  );",
                    "}",
                    "",
                    "export function InputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      lineNumbers={true}",
                    "      keyMap=\"sublime\"",
                    "      autoCloseBrackets={true}",
                    "      matchBrackets={true}",
                    "      showCursorWhenSelecting={true}",
                    "      tabSize={4}",
                    "      rulerColor=\"#eeeeee\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function OutputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={true}",
                    "      rulerColor=\"#444444\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function DebugPanel({ value, autoFold }) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={false}",
                    "      foldGutter={true}",
                    "      autoFold={autoFold}",
                    "      mode=\"jsx\"",
                    "      value={value}",
                    "    />",
                    "  );",
                    "}"
                ]
            },
            "storage.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function get(key) {",
                    "  try {",
                    "    return JSON.parse(window.localStorage.getItem(key));",
                    "  } catch {",
                    "    // noop",
                    "  }",
                    "}",
                    "",
                    "export function set(key, value) {",
                    "  try {",
                    "    window.localStorage.setItem(key, JSON.stringify(value));",
                    "  } catch {",
                    "    // noop",
                    "  }",
                    "}"
                ]
            },
            "urlHash.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import LZString from \"lz-string\";",
                    "",
                    "export function read() {",
                    "  const hash = document.location.hash.slice(1);",
                    "  if (!hash) {",
                    "    return {};",
                    "  }",
                    "",
                    "  // backwards support for old json encoded URIComponent",
                    "  const decode = hash.includes(\"%7B%22\")",
                    "    ? decodeURIComponent",
                    "    : LZString.decompressFromEncodedURIComponent;",
                    "",
                    "  try {",
                    "    return JSON.parse(decode(hash));",
                    "  } catch {",
                    "    return {};",
                    "  }",
                    "}",
                    "",
                    "export function replace(state) {",
                    "  const hash = LZString.compressToEncodedURIComponent(JSON.stringify(state));",
                    "  if (",
                    "    typeof URL === \"function\" &&",
                    "    typeof history === \"object\" &&",
                    "    typeof history.replaceState === \"function\"",
                    "  ) {",
                    "    const url = new URL(location);",
                    "    url.hash = hash;",
                    "    history.replaceState(null, null, url);",
                    "  } else {",
                    "    location.hash = hash;",
                    "  }",
                    "}"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function fixPrettierVersion(version) {",
                    "  const match = version.match(/^\\d+\\.\\d+\\.\\d+-pr.(\\d+)$/);",
                    "  if (match) {",
                    "    return `pr-${match[1]}`;",
                    "  }",
                    "  return version;",
                    "}",
                    "",
                    "export function getDefaults(availableOptions, optionNames) {",
                    "  const defaults = {};",
                    "  for (const option of availableOptions) {",
                    "    if (optionNames.includes(option.name)) {",
                    "      defaults[option.name] =",
                    "        option.name === \"parser\" ? \"babel\" : option.default;",
                    "    }",
                    "  }",
                    "  return defaults;",
                    "}",
                    "",
                    "export function buildCliArgs(availableOptions, options) {",
                    "  const args = [];",
                    "  for (const option of availableOptions) {",
                    "    const value = options[option.name];",
                    "",
                    "    if (value === undefined) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (option.type === \"boolean\") {",
                    "      if ((value && !option.inverted) || (!value && option.inverted)) {",
                    "        args.push([option.cliName, true]);",
                    "      }",
                    "    } else if (value !== option.default || option.name === \"rangeStart\") {",
                    "      args.push([option.cliName, value]);",
                    "    }",
                    "  }",
                    "  return args;",
                    "}",
                    "",
                    "export function getCodemirrorMode(parser) {",
                    "  switch (parser) {",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return \"css\";",
                    "    case \"graphql\":",
                    "      return \"graphql\";",
                    "    case \"markdown\":",
                    "      return \"markdown\";",
                    "    default:",
                    "      return \"jsx\";",
                    "  }",
                    "}",
                    "",
                    "const astAutoFold = {",
                    "  estree: /^\\s*\"(loc|start|end|tokens|\\w+Comments|comments)\":/,",
                    "  postcss: /^\\s*\"(source|input|raws|file)\":/,",
                    "  html: /^\\s*\"(\\w+Span|valueTokens|tokens|file|tagDefinition)\":/,",
                    "  mdast: /^\\s*\"position\":/,",
                    "  yaml: /^\\s*\"position\":/,",
                    "  glimmer: /^\\s*\"loc\":/,",
                    "  graphql: /^\\s*\"loc\":/,",
                    "};",
                    "",
                    "export function getAstAutoFold(parser) {",
                    "  switch (parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      return astAutoFold.estree;",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return astAutoFold.postcss;",
                    "    case \"html\":",
                    "    case \"angular\":",
                    "    case \"vue\":",
                    "    case \"lwc\":",
                    "      return astAutoFold.html;",
                    "    case \"markdown\":",
                    "    case \"mdx\":",
                    "      return astAutoFold.mdast;",
                    "    case \"yaml\":",
                    "      return astAutoFold.yaml;",
                    "    default:",
                    "      return astAutoFold[parser];",
                    "  }",
                    "}",
                    "",
                    "export function convertSelectionToRange({ head, anchor }, content) {",
                    "  const lines = content.split(\"\\n\");",
                    "  return [head, anchor]",
                    "    .map(",
                    "      ({ ch, line }) =>",
                    "        lines.slice(0, line).join(\"\\n\").length + ch + (line ? 1 : 0)",
                    "    )",
                    "    .sort((a, b) => a - b);",
                    "}",
                    "",
                    "export function convertOffsetToSelection(offset, content) {",
                    "  let line = 0;",
                    "  let ch = 0;",
                    "  for (let i = 0; i < offset && i <= content.length; i++) {",
                    "    if (content[i] === \"\\n\") {",
                    "      line++;",
                    "      ch = 0;",
                    "    } else {",
                    "      ch++;",
                    "    }",
                    "  }",
                    "  return { anchor: { line, ch } };",
                    "}",
                    "",
                    "/**",
                    " * Copied from https://github.com/prettier/prettier/blob/6fe21780115cf5f74f83876d64b03a727fbab220/src/cli/utils.js#L6-L27",
                    " * @template Obj",
                    " * @template Key",
                    " * @param {Array<Obj>} array",
                    " * @param {(value: Obj) => Key} iteratee",
                    " * @returns {{[p in Key]: T}}",
                    " */",
                    "export function groupBy(array, iteratee) {",
                    "  const result = Object.create(null);",
                    "",
                    "  for (const value of array) {",
                    "    const key = iteratee(value);",
                    "",
                    "    if (Array.isArray(result[key])) {",
                    "      result[key].push(value);",
                    "    } else {",
                    "      result[key] = [value];",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}"
                ]
            },
            "sidebar": {
                "SidebarOptions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "import { SidebarCategory } from \"./components.js\";",
                        "import Option from \"./options.js\";",
                        "",
                        "// Copied from `/src/cli/utils.js`",
                        "function groupBy(array, iteratee) {",
                        "  const result = Object.create(null);",
                        "",
                        "  for (const value of array) {",
                        "    const key = iteratee(value);",
                        "",
                        "    if (Array.isArray(result[key])) {",
                        "      result[key].push(value);",
                        "    } else {",
                        "      result[key] = [value];",
                        "    }",
                        "  }",
                        "",
                        "  return result;",
                        "}",
                        "",
                        "export default function SidebarOptions({",
                        "  categories,",
                        "  availableOptions,",
                        "  optionValues,",
                        "  onOptionValueChange,",
                        "}) {",
                        "  const options = groupBy(availableOptions, (option) => option.category);",
                        "  return categories.map((category) =>",
                        "    options[category] ? (",
                        "      <SidebarCategory key={category} title={category}>",
                        "        {options[category].map((option) => (",
                        "          <Option",
                        "            key={option.name}",
                        "            option={option}",
                        "            value={optionValues[option.name]}",
                        "            onChange={onOptionValueChange}",
                        "          />",
                        "        ))}",
                        "      </SidebarCategory>",
                        "    ) : null",
                        "  );",
                        "}"
                    ]
                },
                "components.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Sidebar({ visible, children }) {",
                        "  return (",
                        "    <div className={`options-container ${visible ? \"open\" : \"\"}`}>",
                        "      <div className=\"options\">{children}</div>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "export function SidebarCategory({ title, children }) {",
                        "  return (",
                        "    <details className=\"sub-options\" open=\"true\">",
                        "      <summary>{title}</summary>",
                        "      {children}",
                        "    </details>",
                        "  );",
                        "}"
                    ]
                },
                "inputs.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Checkbox({ label: _label, title, checked, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      <input",
                        "        type=\"checkbox\"",
                        "        checked={checked}",
                        "        onChange={(ev) => onChange(ev.target.checked)}",
                        "      />{\" \"}",
                        "      {_label}",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function Select({ label: _label, title, values, selected, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <select value={selected} onChange={(ev) => onChange(ev.target.value)}>",
                        "        {values.map((val) => (",
                        "          <option key={val} value={val}>",
                        "            {val}",
                        "          </option>",
                        "        ))}",
                        "      </select>",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function NumberInput({",
                        "  label: _label,",
                        "  title,",
                        "  value,",
                        "  min,",
                        "  max,",
                        "  step,",
                        "  onChange,",
                        "}) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <input",
                        "        type=\"number\"",
                        "        min={min}",
                        "        max={max}",
                        "        step={step}",
                        "        value={value}",
                        "        onChange={(ev) => onChange(Number.parseInt(ev.target.value, 10))}",
                        "      />",
                        "    </label>",
                        "  );",
                        "}"
                    ]
                },
                "options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "import { Checkbox, Select, NumberInput } from \"./inputs.js\";",
                        "",
                        "export function BooleanOption({ option, value, onChange }) {",
                        "  function maybeInvert(value) {",
                        "    return option.inverted ? !value : value;",
                        "  }",
                        "  return (",
                        "    <Checkbox",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      checked={maybeInvert(value)}",
                        "      onChange={(checked) => onChange(option, maybeInvert(checked))}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function ChoiceOption({ option, value, onChange }) {",
                        "  return (",
                        "    <Select",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      values={option.choices.map((choice) => choice.value)}",
                        "      selected={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function NumberOption({ option, value, onChange }) {",
                        "  return (",
                        "    <NumberInput",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      min={option.range.start}",
                        "      max={option.range.end}",
                        "      step={option.range.step}",
                        "      value={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export default function Option(props) {",
                        "  switch (props.option.type) {",
                        "    case \"boolean\":",
                        "      return <BooleanOption {...props} />;",
                        "    case \"int\":",
                        "      return <NumberOption {...props} />;",
                        "    case \"choice\":",
                        "      return <ChoiceOption {...props} />;",
                        "    default:",
                        "      throw new Error(\"unsupported type\");",
                        "  }",
                        "}",
                        "",
                        "function getDescription(option) {",
                        "  const description = option.inverted",
                        "    ? option.oppositeDescription",
                        "    : option.description;",
                        "  return description && description.replaceAll(\"\\n\", \" \");",
                        "}"
                    ]
                }
            }
        },
        "static": {
            "_redirects": {},
            "icon.png": {},
            "install-service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "if (\"serviceWorker\" in navigator) {",
                    "  navigator.serviceWorker.register(\"/service-worker.js\", {",
                    "    scope: \"/playground/\",",
                    "  });",
                    "}"
                ]
            },
            "landing.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "if (location.hash.slice(1).startsWith(encodeURIComponent(\"{\"))) {",
                    "  location.pathname = \"/playground/\";",
                    "}",
                    "",
                    "window.addEventListener(\"load\", () => {",
                    "  // We don't have access to a unique body css attribute for just the homepage",
                    "  // so instead it is set on load. It's only really visible on a vertical overscroll",
                    "  document.body.style.backgroundColor = \"rgb(24, 32, 37)\";",
                    "",
                    "  const logoWrapper = document.querySelector(\".animatedLogoWrapper\");",
                    "  const logo = document.querySelector(\".prettier-logo-wide\");",
                    "  const lastDash = logo.querySelector(\"g:last-of-type path:last-of-type\");",
                    "",
                    "  function handleLogoDrag(event) {",
                    "    logo.classList.add(\"rolling\");",
                    "    event.preventDefault();",
                    "  }",
                    "",
                    "  logoWrapper.setAttribute(\"draggable\", \"true\");",
                    "  logoWrapper.addEventListener(\"touchstart\", handleLogoDrag);",
                    "  logoWrapper.addEventListener(\"dragstart\", handleLogoDrag);",
                    "",
                    "  lastDash.addEventListener(\"animationend\", (event) => {",
                    "    if (/roll/.test(event.animationName)) {",
                    "      logo.classList.remove(\"rolling\");",
                    "    }",
                    "  });",
                    "});"
                ]
            },
            "manifest.json": {},
            "overrides.css": {},
            "prettier-centered-logo-static.svg": {},
            "prettier.png": {},
            "service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* global toolbox prettierPackageManifest */",
                    "",
                    "\"use strict\";",
                    "",
                    "importScripts(\"lib/package-manifest.js\");",
                    "importScripts(",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/sw-toolbox/3.6.0/sw-toolbox.js\"",
                    ");",
                    "",
                    "const plugins = prettierPackageManifest.builtinPlugins.map(",
                    "  ({ file }) => `lib/${file}`",
                    ");",
                    "",
                    "toolbox.precache([",
                    "  // Scripts",
                    "  \"lib/standalone.js\",",
                    "  ...plugins,",
                    "  \"playground.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/sw-toolbox/3.6.0/sw-toolbox.js\",",
                    "",
                    "  // CodeMirror; keep this in sync with website/pages/playground/index.html",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/codemirror.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/fold/foldgutter.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/codemirror.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/javascript/javascript.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/xml/xml.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/jsx/jsx.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/css/css.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/markdown/markdown.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/display/placeholder.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/display/rulers.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/search/searchcursor.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/edit/matchbrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/edit/closebrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/comment/comment.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/wrap/hardwrap.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/fold/foldcode.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/fold/foldgutter.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/fold/brace-fold.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/keymap/sublime.min.js\",",
                    "",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js\",",
                    "",
                    "  // Images",
                    "  \"/prettier.png\",",
                    "]);",
                    "",
                    "// Default to hit the cache only if there's a network error",
                    "toolbox.router.default = toolbox.networkFirst;",
                    "",
                    "// For scripts, stylesheets and images, we can use the \"fastest\" strategy",
                    "// This means you need to reload twice to get new changes",
                    "toolbox.router.get(/\\.(js|css|png|svg)$/, toolbox.fastest);"
                ]
            },
            "worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* globals prettier prettierPlugins prettierPackageManifest */",
                    "",
                    "\"use strict\";",
                    "",
                    "importScripts(\"lib/package-manifest.js\");",
                    "importScripts(\"lib/standalone.js\");",
                    "",
                    "// TODO[@fisker]: Lazy load plugins",
                    "for (const { file } of prettierPackageManifest.builtinPlugins) {",
                    "  importScripts(`lib/${file}`);",
                    "}",
                    "",
                    "const docExplorerPlugin = {",
                    "  parsers: {",
                    "    \"doc-explorer\": {",
                    "      parse: (text) =>",
                    "        new Function(",
                    "          `{ ${Object.keys(prettier.doc.builders)} }`,",
                    "          `const result = (${text || \"''\"}\\n); return result;`",
                    "        )(prettier.doc.builders),",
                    "      astFormat: \"doc-explorer\",",
                    "    },",
                    "  },",
                    "  printers: {",
                    "    \"doc-explorer\": {",
                    "      print: (path) => path.getValue(),",
                    "    },",
                    "  },",
                    "  languages: [{ name: \"doc-explorer\", parsers: [\"doc-explorer\"] }],",
                    "};",
                    "",
                    "const plugins = [...Object.values(prettierPlugins), docExplorerPlugin];",
                    "",
                    "self.onmessage = async function (event) {",
                    "  self.postMessage({",
                    "    uid: event.data.uid,",
                    "    message: await handleMessage(event.data.message),",
                    "  });",
                    "};",
                    "",
                    "function serializeAst(ast) {",
                    "  return JSON.stringify(",
                    "    ast,",
                    "    (_, value) =>",
                    "      value instanceof Error",
                    "        ? { name: value.name, message: value.message, ...value }",
                    "        : typeof value === \"bigint\"",
                    "        ? `BigInt('${String(value)}')`",
                    "        : typeof value === \"symbol\"",
                    "        ? String(value)",
                    "        : value,",
                    "    2",
                    "  );",
                    "}",
                    "",
                    "function handleMessage(message) {",
                    "  switch (message.type) {",
                    "    case \"meta\":",
                    "      return handleMetaMessage();",
                    "    case \"format\":",
                    "      return handleFormatMessage(message);",
                    "  }",
                    "}",
                    "",
                    "async function handleMetaMessage() {",
                    "  const supportInfo = await prettier.getSupportInfo({ plugins });",
                    "",
                    "  return {",
                    "    type: \"meta\",",
                    "    supportInfo: JSON.parse(JSON.stringify(supportInfo)),",
                    "    version: prettier.version,",
                    "  };",
                    "}",
                    "",
                    "async function handleFormatMessage(message) {",
                    "  const options = { ...message.options, plugins };",
                    "",
                    "  delete options.ast;",
                    "  delete options.doc;",
                    "  delete options.output2;",
                    "",
                    "  const formatResult = await formatCode(",
                    "    message.code,",
                    "    options,",
                    "    message.debug.rethrowEmbedErrors",
                    "  );",
                    "",
                    "  const response = {",
                    "    formatted: formatResult.formatted,",
                    "    cursorOffset: formatResult.cursorOffset,",
                    "    error: formatResult.error,",
                    "    debug: {",
                    "      ast: null,",
                    "      doc: null,",
                    "      comments: null,",
                    "      reformatted: null,",
                    "    },",
                    "  };",
                    "",
                    "  for (const key of [\"ast\", \"preprocessedAst\"]) {",
                    "    if (!message.debug[key]) {",
                    "      continue;",
                    "    }",
                    "    let ast;",
                    "    let errored = false;",
                    "    try {",
                    "      const parsed = await prettier.__debug.parse(message.code, options, {",
                    "        preprocessForPrint: key === \"preprocessedAst\",",
                    "      });",
                    "      ast = serializeAst(parsed.ast);",
                    "    } catch (e) {",
                    "      errored = true;",
                    "      ast = String(e);",
                    "    }",
                    "",
                    "    if (!errored) {",
                    "      try {",
                    "        ast = (await formatCode(ast, { parser: \"json\", plugins })).formatted;",
                    "      } catch {",
                    "        ast = serializeAst(ast);",
                    "      }",
                    "    }",
                    "    response.debug[key] = ast;",
                    "  }",
                    "",
                    "  if (message.debug.doc) {",
                    "    try {",
                    "      response.debug.doc = await prettier.__debug.formatDoc(",
                    "        await prettier.__debug.printToDoc(message.code, options),",
                    "        { plugins }",
                    "      );",
                    "    } catch {",
                    "      response.debug.doc = \"\";",
                    "    }",
                    "  }",
                    "",
                    "  if (message.debug.comments) {",
                    "    response.debug.comments = (",
                    "      await formatCode(JSON.stringify(formatResult.comments || []), {",
                    "        parser: \"json\",",
                    "        plugins,",
                    "      })",
                    "    ).formatted;",
                    "  }",
                    "",
                    "  if (message.debug.reformat) {",
                    "    response.debug.reformatted = (",
                    "      await formatCode(response.formatted, options)",
                    "    ).formatted;",
                    "  }",
                    "",
                    "  return response;",
                    "}",
                    "",
                    "async function formatCode(text, options, rethrowEmbedErrors) {",
                    "  try {",
                    "    self.PRETTIER_DEBUG = rethrowEmbedErrors;",
                    "    return await prettier.formatWithCursor(text, options);",
                    "  } catch (e) {",
                    "    if (e.constructor && e.constructor.name === \"SyntaxError\") {",
                    "      // Likely something wrong with the user's code",
                    "      return { formatted: String(e), error: true };",
                    "    }",
                    "    // Likely a bug in Prettier",
                    "    // Provide the whole stack for debugging",
                    "    return { formatted: stringifyError(e), error: true };",
                    "  } finally {",
                    "    self.PRETTIER_DEBUG = undefined;",
                    "  }",
                    "}",
                    "",
                    "function stringifyError(e) {",
                    "  const stringified = String(e);",
                    "  if (typeof e.stack !== \"string\") {",
                    "    return stringified;",
                    "  }",
                    "  if (e.stack.includes(stringified)) {",
                    "    // Chrome",
                    "    return e.stack;",
                    "  }",
                    "  // Firefox",
                    "  return stringified + \"\\n\" + e.stack;",
                    "}"
                ]
            },
            "css": {
                "code-block-buttons.css": {}
            },
            "images": {
                "get_started_rects.svg": {},
                "github.svg": {},
                "github_grey.svg": {},
                "npm.svg": {},
                "npm_grey.svg": {},
                "state_of_js_grey.svg": {},
                "tidelift-small.png": {},
                "editors": {
                    "atom-128px.png": {},
                    "editor_atom.svg": {},
                    "editor_emacs.svg": {},
                    "editor_espresso.svg": {},
                    "editor_nova.svg": {},
                    "editor_sublime.svg": {},
                    "editor_vim.svg": {},
                    "editor_vs.svg": {},
                    "editor_vscode.svg": {},
                    "editor_webstorm.svg": {},
                    "emacs-128px.png": {},
                    "espresso-128px.png": {},
                    "sublimetext-128px.png": {},
                    "vim-128px.png": {},
                    "visualstudio-128px.png": {},
                    "vscode-128px.png": {},
                    "webstorm-128px.png": {}
                },
                "languages": {
                    "css-128px.png": {},
                    "css_small_grey.svg": {},
                    "graphql-128px.png": {},
                    "graphql_small_grey.svg": {},
                    "js-128px.png": {},
                    "js_small_grey.svg": {},
                    "markdown-128px.png": {},
                    "markdown_small_grey.svg": {},
                    "python_small_grey.svg": {},
                    "swift_small_grey.svg": {},
                    "tools_css.svg": {},
                    "tools_gql.svg": {},
                    "tools_html.svg": {},
                    "tools_js.svg": {},
                    "tools_md.svg": {},
                    "tools_wip.svg": {},
                    "tools_yaml.svg": {}
                },
                "users": {
                    "3yourmind.svg": {},
                    "aircall.svg": {},
                    "algolia-200x100.png": {},
                    "assertible-200x100.png": {},
                    "babel-200x100.png": {},
                    "brigad-200x100.png": {},
                    "buildcom.svg": {},
                    "campusjaeger.svg": {},
                    "charlietango-200x100.png": {},
                    "chillicream.svg": {},
                    "codecarrot.svg": {},
                    "codemix-200x100.png": {},
                    "computerbase.svg": {},
                    "contiamo-200x100.png": {},
                    "danger-200x100.png": {},
                    "dev-it-jobs-200-100.jpg": {},
                    "discord-200x100.png": {},
                    "drizly-200x100.png": {},
                    "dropbox.svg": {},
                    "dropbox_grey.svg": {},
                    "escrow-200x100.png": {},
                    "estalee.svg": {},
                    "eventstag-200x100.png": {},
                    "exponea.svg": {},
                    "eyesquare-200x100.png": {},
                    "facebook-200x100.png": {},
                    "freelancer-200x100.png": {},
                    "getonboard-200x100.png": {},
                    "gumgum-200x100.png": {},
                    "hackclub-200x100.png": {},
                    "hasura-200x100.png": {},
                    "hearthsim-200x100.png": {},
                    "heroku.svg": {},
                    "holidaycheck-200x100.png": {},
                    "housinganywhere.svg": {},
                    "hudl-200x100.png": {},
                    "icons8.svg": {},
                    "ideati-200x100.png": {},
                    "iress-200x100.png": {},
                    "jane-200x100.png": {},
                    "jest-200x100.png": {},
                    "leesa.svg": {},
                    "lifesum-200x100.png": {},
                    "loyaltylion-200x100.png": {},
                    "m6web-200x100.png": {},
                    "materialui-200x100.png": {},
                    "mathrioshka-200x100.png": {},
                    "metric-ai-white.svg": {},
                    "monei-200x100.png": {},
                    "mongodb-200x100.png": {},
                    "moonmail-200x100.png": {},
                    "n26-200x100.png": {},
                    "nhl-200x100.png": {},
                    "nrwl-200x100.png": {},
                    "openbravo-200x100.png": {},
                    "outreach-200x100.png": {},
                    "paypal-200x100.png": {},
                    "quip.svg": {},
                    "react-200x100.png": {},
                    "researchanddesign.svg": {},
                    "rnfirebase-200x100.png": {},
                    "salesforce.svg": {},
                    "sevenspan-200x100.png": {},
                    "shelf-200x100.png": {},
                    "smooth-code-200x100.png": {},
                    "storybook-200x100.png": {},
                    "swissdev-devops-jobs-200-100.png": {},
                    "talkable-200x100.png": {},
                    "toptal.png": {},
                    "tradeshift-200x100.png": {},
                    "tradie-training.png": {},
                    "transloadit-200x100.png": {},
                    "troops-200x100.png": {},
                    "used_by_babel.svg": {},
                    "used_by_danger.svg": {},
                    "used_by_facebook.svg": {},
                    "used_by_jest.svg": {},
                    "used_by_react.svg": {},
                    "used_by_spotify.svg": {},
                    "used_by_storybook.svg": {},
                    "used_by_webpack.svg": {},
                    "used_by_yarn.svg": {},
                    "used_by_zeit.svg": {},
                    "vercel-logotype-dark.svg": {},
                    "webflow-200x100.png": {},
                    "webpack-200x100.png": {},
                    "wingify-200x100.png": {},
                    "wire-200x100.png": {},
                    "yarn-200x100.png": {},
                    "yelp-200x100.png": {},
                    "zipch-200x100.png": {}
                }
            },
            "js": {
                "code-block-buttons.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/* global ClipboardJS */",
                        "",
                        "\"use strict\";",
                        "",
                        "(function () {",
                        "  const CONTAINER_CLASS_NAME = \"code-block-with-actions\";",
                        "  const ACTIONS_CONTAINER_CLASS_NAME = \"code-block-actions\";",
                        "  const COPY_BUTTON_CLASS_NAME = \"code-block-copy-button\";",
                        "  const COPY_BUTTON_COPIED_CLASS_NAME = `${COPY_BUTTON_CLASS_NAME}--copied`;",
                        "  const COPY_BUTTON_ICON_CLASS_NAME = `${COPY_BUTTON_CLASS_NAME}__icon`;",
                        "  const COPY_BUTTON_COPY_ICON_CLASS_NAME = `${COPY_BUTTON_ICON_CLASS_NAME}--copy`;",
                        "  const COPY_BUTTON_COPIED_ICON_CLASS_NAME = `${COPY_BUTTON_ICON_CLASS_NAME}--copied`;",
                        "  const ARIA_LABEL = \"Copy code to clipboard\";",
                        "  const ARIA_LABEL_COPIED = \"Copied\";",
                        "",
                        "  function init(codeBlock) {",
                        "    const container = codeBlock.parentNode;",
                        "    container.classList.add(CONTAINER_CLASS_NAME);",
                        "",
                        "    const actionsContainer = Object.assign(document.createElement(\"div\"), {",
                        "      className: ACTIONS_CONTAINER_CLASS_NAME,",
                        "    });",
                        "    const copyButton = Object.assign(document.createElement(\"button\"), {",
                        "      className: COPY_BUTTON_CLASS_NAME,",
                        "      type: \"button\",",
                        "      innerHTML:",
                        "        `<svg class=\"${COPY_BUTTON_ICON_CLASS_NAME} ${COPY_BUTTON_COPY_ICON_CLASS_NAME}\" viewBox=\"0 0 24 24\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg>` +",
                        "        `<svg class=\"${COPY_BUTTON_ICON_CLASS_NAME} ${COPY_BUTTON_COPIED_ICON_CLASS_NAME}\" viewBox=\"0 0 24 24\"><path d=\"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z\"></path></svg>`,",
                        "    });",
                        "    copyButton.setAttribute(\"aria-label\", ARIA_LABEL);",
                        "",
                        "    new ClipboardJS(copyButton, { target: () => codeBlock }).on(",
                        "      \"success\",",
                        "      (event) => {",
                        "        event.clearSelection();",
                        "        copyButton.classList.add(COPY_BUTTON_COPIED_CLASS_NAME);",
                        "        copyButton.setAttribute(\"aria-label\", ARIA_LABEL_COPIED);",
                        "        copyButton.disabled = true;",
                        "",
                        "        setTimeout(() => {",
                        "          copyButton.classList.remove(COPY_BUTTON_COPIED_CLASS_NAME);",
                        "          copyButton.setAttribute(\"aria-label\", ARIA_LABEL);",
                        "          copyButton.disabled = false;",
                        "        }, 2000);",
                        "      }",
                        "    );",
                        "",
                        "    actionsContainer.appendChild(copyButton);",
                        "    container.appendChild(actionsContainer);",
                        "  }",
                        "",
                        "  window.addEventListener(\"load\", () => {",
                        "    for (const codeBlock of document.querySelectorAll(\"pre > code.hljs\")) {",
                        "      init(codeBlock);",
                        "    }",
                        "  });",
                        "})();"
                    ]
                }
            },
            "separate-css": {
                "playground.css": {}
            }
        },
        "versioned_docs": {
            "version-stable": {
                "api.md": {},
                "browser.md": {},
                "cli.md": {},
                "comparison.md": {},
                "configuration.md": {},
                "editors.md": {},
                "for-enterprise.md": {},
                "ignore.md": {},
                "index.md": {},
                "install.md": {},
                "integrating-with-linters.md": {},
                "option-philosophy.md": {},
                "options.md": {},
                "plugins.md": {},
                "precommit.md": {},
                "rationale.md": {},
                "related-projects.md": {},
                "technical-details.md": {},
                "vim.md": {},
                "watching-files.md": {},
                "webstorm.md": {},
                "why-prettier.md": {}
            }
        },
        "versioned_sidebars": {
            "version-stable-sidebars.json": {}
        }
    }
}