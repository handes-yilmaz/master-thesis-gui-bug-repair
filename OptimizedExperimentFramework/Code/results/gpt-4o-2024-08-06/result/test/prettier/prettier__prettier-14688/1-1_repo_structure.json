{
    ".codecov.yml": {},
    ".editorconfig": {},
    ".eslintignore": {},
    ".eslintrc.cjs": {},
    ".git-blame-ignore-revs": {},
    ".gitattributes": {},
    ".gitignore": {},
    ".gitpod.yml": {},
    ".ignore": {},
    ".prettierignore": {},
    ".prettierrc": {},
    ".yarnrc.yml": {},
    "CHANGELOG.md": {},
    "CODE_OF_CONDUCT.md": {},
    "CONTRIBUTING.md": {},
    "LICENSE": {},
    "README.md": {},
    "commands.md": {},
    "cspell.json": {},
    "index.js": {
        "classes": [],
        "functions": [],
        "text": [
            "export * from \"./src/index.js\";"
        ]
    },
    "jest.config.js": {
        "classes": [],
        "functions": [],
        "text": [
            "import path from \"node:path\";",
            "import createEsmUtils from \"esm-utils\";",
            "import installPrettier from \"./tests/config/install-prettier.js\";",
            "",
            "const { dirname: PROJECT_ROOT } = createEsmUtils(import.meta);",
            "const isProduction = process.env.NODE_ENV === \"production\";",
            "// Disabled https://github.com/nicolo-ribaudo/jest-light-runner/pull/13",
            "// const ENABLE_CODE_COVERAGE = Boolean(process.env.ENABLE_CODE_COVERAGE);",
            "const TEST_STANDALONE = Boolean(process.env.TEST_STANDALONE);",
            "const INSTALL_PACKAGE = Boolean(process.env.INSTALL_PACKAGE);",
            "// When debugging production test, this flag can skip installing package",
            "const SKIP_PRODUCTION_INSTALL = Boolean(process.env.SKIP_PRODUCTION_INSTALL);",
            "const SKIP_TESTS_WITH_NEW_SYNTAX = process.versions.node.startsWith(\"14.\");",
            "",
            "let PRETTIER_DIR = isProduction",
            "  ? path.join(PROJECT_ROOT, \"dist\")",
            "  : PROJECT_ROOT;",
            "let PRETTIER_INSTALLED_DIR = \"\";",
            "if (",
            "  INSTALL_PACKAGE ||",
            "  (isProduction && !TEST_STANDALONE && !SKIP_PRODUCTION_INSTALL)",
            ") {",
            "  PRETTIER_INSTALLED_DIR = installPrettier(PRETTIER_DIR);",
            "  PRETTIER_DIR = path.join(PRETTIER_INSTALLED_DIR, \"node_modules/prettier\");",
            "}",
            "process.env.PRETTIER_INSTALLED_DIR = PRETTIER_INSTALLED_DIR;",
            "process.env.PRETTIER_DIR = PRETTIER_DIR;",
            "",
            "const testPathIgnorePatterns = [];",
            "if (TEST_STANDALONE) {",
            "  testPathIgnorePatterns.push(\"<rootDir>/tests/integration/\");",
            "}",
            "if (isProduction) {",
            "  // Only run unit test for development",
            "  testPathIgnorePatterns.push(\"<rootDir>/tests/unit/\");",
            "} else {",
            "  // Only test bundles for production",
            "  testPathIgnorePatterns.push(",
            "    \"<rootDir>/tests/integration/__tests__/bundle.js\"",
            "  );",
            "}",
            "",
            "if (SKIP_TESTS_WITH_NEW_SYNTAX) {",
            "  testPathIgnorePatterns.push(",
            "    \"<rootDir>/tests/integration/__tests__/help-options.js\",",
            "    \"<rootDir>/tests/integration/__tests__/plugin-parsers.js\",",
            "    \"<rootDir>/tests/integration/__tests__/normalize-doc.js\",",
            "    \"<rootDir>/tests/integration/__tests__/doc-utils-clean-doc.js\"",
            "  );",
            "}",
            "",
            "const config = {",
            "  setupFiles: [",
            "    \"<rootDir>/tests/config/format-test-setup.js\",",
            "    \"<rootDir>/tests/integration/integration-test-setup.js\",",
            "  ],",
            "  runner: \"jest-light-runner\",",
            "  snapshotSerializers: [",
            "    \"jest-snapshot-serializer-raw\",",
            "    \"jest-snapshot-serializer-ansi\",",
            "  ],",
            "  testMatch: [",
            "    \"<rootDir>/tests/format/**/jsfmt.spec.js\",",
            "    \"<rootDir>/tests/integration/__tests__/**/*.js\",",
            "    \"<rootDir>/tests/unit/**/*.js\",",
            "    \"<rootDir>/tests/dts/unit/**/*.js\",",
            "  ],",
            "  testPathIgnorePatterns,",
            "  // collectCoverage: ENABLE_CODE_COVERAGE,",
            "  collectCoverageFrom: [\"<rootDir>/src/**/*.js\", \"<rootDir>/bin/**/*.js\"],",
            "  coveragePathIgnorePatterns: [",
            "    \"<rootDir>/src/standalone.js\",",
            "    \"<rootDir>/src/document/debug.js\",",
            "  ],",
            "  coverageReporters: [\"text\", \"lcov\"],",
            "  moduleNameMapper: {",
            "    \"prettier-local\": \"<rootDir>/tests/config/prettier-entry.js\",",
            "    \"prettier-standalone\": \"<rootDir>/tests/config/require-standalone.cjs\",",
            "  },",
            "  modulePathIgnorePatterns: [",
            "    \"<rootDir>/dist\",",
            "    \"<rootDir>/website\",",
            "    \"<rootDir>/scripts/release\",",
            "  ],",
            "  transform: {},",
            "  watchPlugins: [",
            "    \"jest-watch-typeahead/filename\",",
            "    \"jest-watch-typeahead/testname\",",
            "  ],",
            "};",
            "",
            "export default config;"
        ]
    },
    "netlify.toml": {},
    "package.json": {},
    "standalone.js": {
        "classes": [],
        "functions": [],
        "text": [
            "export * from \"./src/standalone.js\";"
        ]
    },
    "tsconfig.json": {},
    "yarn.lock": {},
    "bin": {
        "prettier.cjs": {},
        "prettier.js": {
            "classes": [],
            "functions": [],
            "text": [
                "#!/usr/bin/env node",
                "",
                "// Add this file so we can use `node bin/prettier` or `node bin/prettier.js`",
                "// instead of `node bin/prettier.cjs`.",
                "",
                "import \"./prettier.cjs\";"
            ]
        }
    },
    "changelog_unreleased": {
        "BLOG_POST_INTRO_TEMPLATE.md": {},
        "TEMPLATE.md": {},
        "angular": {
            ".gitkeep": {},
            "13609.md": {},
            "14216.md": {},
            "14658.md": {}
        },
        "api": {
            ".gitkeep": {},
            "11830.md": {},
            "12574.md": {},
            "12740.md": {},
            "12748.md": {},
            "13130.md": {},
            "13201.md": {},
            "13203.md": {},
            "13220.md": {},
            "13250.md": {},
            "13268.md": {},
            "13397.md": {},
            "13532-2.md": {},
            "14108.md": {},
            "14212.md": {},
            "14317.md": {},
            "14576.md": {}
        },
        "cli": {
            ".gitkeep": {},
            "11369.md": {},
            "13204.md": {},
            "14332.md": {},
            "14333.md": {}
        },
        "css": {
            ".gitkeep": {},
            "13402.md": {},
            "14208.md": {},
            "14476.md": {},
            "7933.md": {},
            "9209.md": {}
        },
        "flow": {
            ".gitkeep": {},
            "13396.md": {},
            "13687.md": {},
            "14085.md": {},
            "14573.md": {},
            "14619.md": {}
        },
        "graphql": {
            ".gitkeep": {},
            "12835.md": {}
        },
        "handlebars": {
            ".gitkeep": {}
        },
        "html": {
            ".gitkeep": {},
            "13578.md": {},
            "14400.md": {},
            "14615.md": {},
            "7391.md": {}
        },
        "javascript": {
            ".gitkeep": {},
            "10714.md": {},
            "13143.md": {},
            "13340.md": {},
            "13341.md": {},
            "13391.md": {},
            "13410.md": {},
            "13438.md": {},
            "13445.md": {},
            "13532.md": {},
            "13621.md": {},
            "13752.md": {},
            "13771.md": {},
            "14065.md": {},
            "14163.md": {},
            "14192.md": {},
            "14314.md": {},
            "14391.md": {},
            "14406.md": {},
            "14409.md": {},
            "14599.md": {}
        },
        "json": {
            ".gitkeep": {}
        },
        "less": {
            ".gitkeep": {},
            "11343.md": {},
            "14109.md": {}
        },
        "lwc": {
            ".gitkeep": {}
        },
        "markdown": {
            ".gitkeep": {},
            "11597.md": {},
            "13590.md": {}
        },
        "mdx": {
            ".gitkeep": {}
        },
        "misc": {
            ".gitkeep": {}
        },
        "scss": {
            ".gitkeep": {},
            "13487.md": {}
        },
        "typescript": {
            ".gitkeep": {},
            "13427.md": {},
            "13608.md": {},
            "13860.md": {},
            "14171.md": {},
            "14402.md": {},
            "14654.md": {},
            "14659.md": {},
            "14672.md": {}
        },
        "vue": {
            ".gitkeep": {},
            "14401.md": {},
            "14506.md": {},
            "14542.md": {},
            "14557.md": {},
            "14587.md": {}
        },
        "yaml": {
            ".gitkeep": {}
        }
    },
    "src": {
        "index.cjs": {},
        "index.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "// Copied from `@types/prettier`",
                "// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/5bb07fc4b087cb7ee91084afa6fe750551a7bbb1/types/prettier/index.d.ts",
                "",
                "// Minimum TypeScript Version: 4.2",
                "",
                "// Add `export {}` here to shut off automatic exporting from index.d.ts. There",
                "// are quite a few utility types here that don't need to be shipped with the",
                "// exported module.",
                "export {};",
                "",
                "import { builders, printer, utils } from \"./document/public.js\";",
                "",
                "export namespace doc {",
                "  export { builders, printer, utils };",
                "}",
                "",
                "// This utility is here to handle the case where you have an explicit union",
                "// between string literals and the generic string type. It would normally",
                "// resolve out to just the string type, but this generic LiteralUnion maintains",
                "// the intellisense of the original union.",
                "//",
                "// It comes from this issue: microsoft/TypeScript#29729:",
                "//   https://github.com/microsoft/TypeScript/issues/29729#issuecomment-700527227",
                "export type LiteralUnion<T extends U, U = string> =",
                "  | T",
                "  | (Pick<U, never> & { _?: never | undefined });",
                "",
                "export type AST = any;",
                "export type Doc = doc.builders.Doc;",
                "",
                "// The type of elements that make up the given array T.",
                "type ArrayElement<T> = T extends Array<infer E> ? E : never;",
                "",
                "// A union of the properties of the given object that are arrays.",
                "type ArrayProperties<T> = {",
                "  [K in keyof T]: NonNullable<T[K]> extends any[] ? K : never;",
                "}[keyof T];",
                "",
                "// A union of the properties of the given array T that can be used to index it.",
                "// If the array is a tuple, then that's going to be the explicit indices of the",
                "// array, otherwise it's going to just be number.",
                "type IndexProperties<T extends { length: number }> = IsTuple<T> extends true",
                "  ? Exclude<Partial<T>[\"length\"], T[\"length\"]>",
                "  : number;",
                "",
                "// Effectively performing T[P], except that it's telling TypeScript that it's",
                "// safe to do this for tuples, arrays, or objects.",
                "type IndexValue<T, P> = T extends any[]",
                "  ? P extends number",
                "    ? T[P]",
                "    : never",
                "  : P extends keyof T",
                "  ? T[P]",
                "  : never;",
                "",
                "// Determines if an object T is an array like string[] (in which case this",
                "// evaluates to false) or a tuple like [string] (in which case this evaluates to",
                "// true).",
                "// eslint-disable-next-line @typescript-eslint/no-unused-vars",
                "type IsTuple<T> = T extends []",
                "  ? true",
                "  : T extends [infer First, ...infer Remain]",
                "  ? IsTuple<Remain>",
                "  : false;",
                "",
                "type CallProperties<T> = T extends any[] ? IndexProperties<T> : keyof T;",
                "type IterProperties<T> = T extends any[]",
                "  ? IndexProperties<T>",
                "  : ArrayProperties<T>;",
                "",
                "type CallCallback<T, U> = (path: AstPath<T>, index: number, value: any) => U;",
                "type EachCallback<T> = (",
                "  path: AstPath<ArrayElement<T>>,",
                "  index: number,",
                "  value: any",
                ") => void;",
                "type MapCallback<T, U> = (",
                "  path: AstPath<ArrayElement<T>>,",
                "  index: number,",
                "  value: any",
                ") => U;",
                "",
                "// https://github.com/prettier/prettier/blob/next/src/common/ast-path.js",
                "export class AstPath<T = any> {",
                "  constructor(value: T);",
                "",
                "  get key(): string | null;",
                "  get index(): number | null;",
                "  get node(): T;",
                "  get parent(): T | null;",
                "  get grandparent(): T | null;",
                "  get isInArray(): boolean;",
                "  get siblings(): T[] | null;",
                "  get next(): T | null;",
                "  get previous(): T | null;",
                "  get isFirst(): boolean;",
                "  get isLast(): boolean;",
                "  get isRoot(): boolean;",
                "  get root(): T;",
                "  get ancestors(): T[];",
                "",
                "  stack: T[];",
                "",
                "  callParent<U>(callback: (path: this) => U, count?: number): U;",
                "",
                "  /**",
                "   * @deprecated Please use `AstPath#key` or `AstPath#index`",
                "   */",
                "  getName(): PropertyKey | null;",
                "",
                "  /**",
                "   * @deprecated Please use `AstPath#node` or  `AstPath#siblings`",
                "   */",
                "  getValue(): T;",
                "",
                "  getNode(count?: number): T | null;",
                "",
                "  getParentNode(count?: number): T | null;",
                "",
                "  match(",
                "    ...predicates: Array<",
                "      (node: any, name: string | null, number: number | null) => boolean",
                "    >",
                "  ): boolean;",
                "",
                "  // For each of the tree walk functions (call, each, and map) this provides 5",
                "  // strict type signatures, along with a fallback at the end if you end up",
                "  // calling more than 5 properties deep. This helps a lot with typing because",
                "  // for the majority of cases you're calling fewer than 5 properties, so the",
                "  // tree walk functions have a clearer understanding of what you're doing.",
                "  //",
                "  // Note that resolving these types is somewhat complicated, and it wasn't",
                "  // even supported until TypeScript 4.2 (before it would just say that the",
                "  // type instantiation was excessively deep and possibly infinite).",
                "",
                "  call<U>(callback: CallCallback<T, U>): U;",
                "  call<U, P1 extends CallProperties<T>>(",
                "    callback: CallCallback<IndexValue<T, P1>, U>,",
                "    prop1: P1",
                "  ): U;",
                "  call<U, P1 extends keyof T, P2 extends CallProperties<T[P1]>>(",
                "    callback: CallCallback<IndexValue<IndexValue<T, P1>, P2>, U>,",
                "    prop1: P1,",
                "    prop2: P2",
                "  ): U;",
                "  call<",
                "    U,",
                "    P1 extends keyof T,",
                "    P2 extends CallProperties<T[P1]>,",
                "    P3 extends CallProperties<IndexValue<T[P1], P2>>",
                "  >(",
                "    callback: CallCallback<",
                "      IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>,",
                "      U",
                "    >,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3",
                "  ): U;",
                "  call<",
                "    U,",
                "    P1 extends keyof T,",
                "    P2 extends CallProperties<T[P1]>,",
                "    P3 extends CallProperties<IndexValue<T[P1], P2>>,",
                "    P4 extends CallProperties<IndexValue<IndexValue<T[P1], P2>, P3>>",
                "  >(",
                "    callback: CallCallback<",
                "      IndexValue<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>, P4>,",
                "      U",
                "    >,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3,",
                "    prop4: P4",
                "  ): U;",
                "  call<U, P extends PropertyKey>(",
                "    callback: CallCallback<any, U>,",
                "    prop1: P,",
                "    prop2: P,",
                "    prop3: P,",
                "    prop4: P,",
                "    ...props: P[]",
                "  ): U;",
                "",
                "  each(callback: EachCallback<T>): void;",
                "  each<P1 extends IterProperties<T>>(",
                "    callback: EachCallback<IndexValue<T, P1>>,",
                "    prop1: P1",
                "  ): void;",
                "  each<P1 extends keyof T, P2 extends IterProperties<T[P1]>>(",
                "    callback: EachCallback<IndexValue<IndexValue<T, P1>, P2>>,",
                "    prop1: P1,",
                "    prop2: P2",
                "  ): void;",
                "  each<",
                "    P1 extends keyof T,",
                "    P2 extends IterProperties<T[P1]>,",
                "    P3 extends IterProperties<IndexValue<T[P1], P2>>",
                "  >(",
                "    callback: EachCallback<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>>,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3",
                "  ): void;",
                "  each<",
                "    P1 extends keyof T,",
                "    P2 extends IterProperties<T[P1]>,",
                "    P3 extends IterProperties<IndexValue<T[P1], P2>>,",
                "    P4 extends IterProperties<IndexValue<IndexValue<T[P1], P2>, P3>>",
                "  >(",
                "    callback: EachCallback<",
                "      IndexValue<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>, P4>",
                "    >,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3,",
                "    prop4: P4",
                "  ): void;",
                "  each(",
                "    callback: EachCallback<any[]>,",
                "    prop1: PropertyKey,",
                "    prop2: PropertyKey,",
                "    prop3: PropertyKey,",
                "    prop4: PropertyKey,",
                "    ...props: PropertyKey[]",
                "  ): void;",
                "",
                "  map<U>(callback: MapCallback<T, U>): U[];",
                "  map<U, P1 extends IterProperties<T>>(",
                "    callback: MapCallback<IndexValue<T, P1>, U>,",
                "    prop1: P1",
                "  ): U[];",
                "  map<U, P1 extends keyof T, P2 extends IterProperties<T[P1]>>(",
                "    callback: MapCallback<IndexValue<IndexValue<T, P1>, P2>, U>,",
                "    prop1: P1,",
                "    prop2: P2",
                "  ): U[];",
                "  map<",
                "    U,",
                "    P1 extends keyof T,",
                "    P2 extends IterProperties<T[P1]>,",
                "    P3 extends IterProperties<IndexValue<T[P1], P2>>",
                "  >(",
                "    callback: MapCallback<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>, U>,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3",
                "  ): U[];",
                "  map<",
                "    U,",
                "    P1 extends keyof T,",
                "    P2 extends IterProperties<T[P1]>,",
                "    P3 extends IterProperties<IndexValue<T[P1], P2>>,",
                "    P4 extends IterProperties<IndexValue<IndexValue<T[P1], P2>, P3>>",
                "  >(",
                "    callback: MapCallback<",
                "      IndexValue<IndexValue<IndexValue<IndexValue<T, P1>, P2>, P3>, P4>,",
                "      U",
                "    >,",
                "    prop1: P1,",
                "    prop2: P2,",
                "    prop3: P3,",
                "    prop4: P4",
                "  ): U[];",
                "  map<U>(",
                "    callback: MapCallback<any[], U>,",
                "    prop1: PropertyKey,",
                "    prop2: PropertyKey,",
                "    prop3: PropertyKey,",
                "    prop4: PropertyKey,",
                "    ...props: PropertyKey[]",
                "  ): U[];",
                "}",
                "",
                "/** @deprecated `FastPath` was renamed to `AstPath` */",
                "export type FastPath<T = any> = AstPath<T>;",
                "",
                "export type BuiltInParser = (text: string, options?: any) => AST;",
                "export type BuiltInParserName =",
                "  | \"acorn\"",
                "  | \"angular\"",
                "  | \"babel-flow\"",
                "  | \"babel-ts\"",
                "  | \"babel\"",
                "  | \"css\"",
                "  | \"espree\"",
                "  | \"flow\"",
                "  | \"glimmer\"",
                "  | \"graphql\"",
                "  | \"html\"",
                "  | \"json-stringify\"",
                "  | \"json\"",
                "  | \"json5\"",
                "  | \"less\"",
                "  | \"lwc\"",
                "  | \"markdown\"",
                "  | \"mdx\"",
                "  | \"meriyah\"",
                "  | \"scss\"",
                "  | \"typescript\"",
                "  | \"vue\"",
                "  | \"yaml\";",
                "export type BuiltInParsers = Record<BuiltInParserName, BuiltInParser>;",
                "",
                "export type CustomParser = (",
                "  text: string,",
                "  options: Options",
                ") => AST | Promise<AST>;",
                "",
                "/**",
                " * For use in `.prettierrc.js`, `.prettierrc.cjs`, `prettierrc.mjs`, `prettier.config.js`, `prettier.config.cjs`, `prettier.config.mjs`",
                " */",
                "export interface Config extends Options {",
                "  overrides?: Array<{",
                "    files: string | string[];",
                "    excludeFiles?: string | string[];",
                "    options?: Options;",
                "  }>;",
                "}",
                "",
                "export interface Options extends Partial<RequiredOptions> {}",
                "",
                "export interface RequiredOptions extends doc.printer.Options {",
                "  /**",
                "   * Print semicolons at the ends of statements.",
                "   * @default true",
                "   */",
                "  semi: boolean;",
                "  /**",
                "   * Use single quotes instead of double quotes.",
                "   * @default false",
                "   */",
                "  singleQuote: boolean;",
                "  /**",
                "   * Use single quotes in JSX.",
                "   * @default false",
                "   */",
                "  jsxSingleQuote: boolean;",
                "  /**",
                "   * Print trailing commas wherever possible.",
                "   * @default \"all\"",
                "   */",
                "  trailingComma: \"none\" | \"es5\" | \"all\";",
                "  /**",
                "   * Print spaces between brackets in object literals.",
                "   * @default true",
                "   */",
                "  bracketSpacing: boolean;",
                "  /**",
                "   * Put the `>` of a multi-line HTML (HTML, JSX, Vue, Angular) element at the end of the last line instead of being",
                "   * alone on the next line (does not apply to self closing elements).",
                "   * @default false",
                "   */",
                "  bracketSameLine: boolean;",
                "  /**",
                "   * Put the `>` of a multi-line JSX element at the end of the last line instead of being alone on the next line.",
                "   * @default false",
                "   * @deprecated use bracketSameLine instead",
                "   */",
                "  jsxBracketSameLine: boolean;",
                "  /**",
                "   * Format only a segment of a file.",
                "   * @default 0",
                "   */",
                "  rangeStart: number;",
                "  /**",
                "   * Format only a segment of a file.",
                "   * @default Number.POSITIVE_INFINITY",
                "   */",
                "  rangeEnd: number;",
                "  /**",
                "   * Specify which parser to use.",
                "   */",
                "  parser: LiteralUnion<BuiltInParserName> | CustomParser;",
                "  /**",
                "   * Specify the input filepath. This will be used to do parser inference.",
                "   */",
                "  filepath: string;",
                "  /**",
                "   * Prettier can restrict itself to only format files that contain a special comment, called a pragma, at the top of the file.",
                "   * This is very useful when gradually transitioning large, unformatted codebases to prettier.",
                "   * @default false",
                "   */",
                "  requirePragma: boolean;",
                "  /**",
                "   * Prettier can insert a special @format marker at the top of files specifying that",
                "   * the file has been formatted with prettier. This works well when used in tandem with",
                "   * the --require-pragma option. If there is already a docblock at the top of",
                "   * the file then this option will add a newline to it with the @format marker.",
                "   * @default false",
                "   */",
                "  insertPragma: boolean;",
                "  /**",
                "   * By default, Prettier will wrap markdown text as-is since some services use a linebreak-sensitive renderer.",
                "   * In some cases you may want to rely on editor/viewer soft wrapping instead, so this option allows you to opt out.",
                "   * @default \"preserve\"",
                "   */",
                "  proseWrap: \"always\" | \"never\" | \"preserve\";",
                "  /**",
                "   * Include parentheses around a sole arrow function parameter.",
                "   * @default \"always\"",
                "   */",
                "  arrowParens: \"avoid\" | \"always\";",
                "  /**",
                "   * Provide ability to support new languages to prettier.",
                "   */",
                "  plugins: Array<string | Plugin>;",
                "  /**",
                "   * Specify plugin directory paths to search for plugins if not installed in the same `node_modules` where prettier is located.",
                "   */",
                "  pluginSearchDirs: string[] | false;",
                "  /**",
                "   * How to handle whitespaces in HTML.",
                "   * @default \"css\"",
                "   */",
                "  htmlWhitespaceSensitivity: \"css\" | \"strict\" | \"ignore\";",
                "  /**",
                "   * Which end of line characters to apply.",
                "   * @default \"lf\"",
                "   */",
                "  endOfLine: \"auto\" | \"lf\" | \"crlf\" | \"cr\";",
                "  /**",
                "   * Change when properties in objects are quoted.",
                "   * @default \"as-needed\"",
                "   */",
                "  quoteProps: \"as-needed\" | \"consistent\" | \"preserve\";",
                "  /**",
                "   * Whether or not to indent the code inside <script> and <style> tags in Vue files.",
                "   * @default false",
                "   */",
                "  vueIndentScriptAndStyle: boolean;",
                "  /**",
                "   * Control whether Prettier formats quoted code embedded in the file.",
                "   * @default \"auto\"",
                "   */",
                "  embeddedLanguageFormatting: \"auto\" | \"off\";",
                "  /**",
                "   * Enforce single attribute per line in HTML, Vue and JSX.",
                "   * @default false",
                "   */",
                "  singleAttributePerLine: boolean;",
                "}",
                "",
                "export interface ParserOptions<T = any> extends RequiredOptions {",
                "  locStart: (node: T) => number;",
                "  locEnd: (node: T) => number;",
                "  originalText: string;",
                "}",
                "",
                "export interface Plugin<T = any> {",
                "  languages?: SupportLanguage[] | undefined;",
                "  parsers?:",
                "    | { [parserName: string]: Parser<T> | (() => Promise<Parser<T>>) }",
                "    | undefined;",
                "  printers?: { [astFormat: string]: Printer<T> } | undefined;",
                "  options?: SupportOptions | undefined;",
                "  defaultOptions?: Partial<RequiredOptions> | undefined;",
                "}",
                "",
                "export interface Parser<T = any> {",
                "  parse: (text: string, options: ParserOptions<T>) => T | Promise<T>;",
                "  astFormat: string;",
                "  hasPragma?: ((text: string) => boolean) | undefined;",
                "  locStart: (node: T) => number;",
                "  locEnd: (node: T) => number;",
                "  preprocess?:",
                "    | ((text: string, options: ParserOptions<T>) => string)",
                "    | undefined;",
                "}",
                "",
                "export interface Printer<T = any> {",
                "  print(",
                "    path: AstPath<T>,",
                "    options: ParserOptions<T>,",
                "    print: (path: AstPath<T>) => Doc,",
                "    args?: unknown",
                "  ): Doc;",
                "  embed?:",
                "    | ((",
                "        path: AstPath,",
                "        options: Options",
                "      ) =>",
                "        | ((",
                "            textToDoc: (text: string, options: Options) => Promise<Doc>,",
                "            print: (",
                "              selector?: string | number | Array<string | number> | AstPath",
                "            ) => Doc,",
                "            path: AstPath,",
                "            options: Options",
                "          ) => Promise<Doc | undefined> | Doc | undefined)",
                "        | Doc",
                "        | null)",
                "    | undefined;",
                "  insertPragma?: (text: string) => string;",
                "  /**",
                "   * @returns `null` if you want to remove this node",
                "   * @returns `void` if you want to use modified newNode",
                "   * @returns anything if you want to replace the node with it",
                "   */",
                "  massageAstNode?: ((node: any, newNode: any, parent: any) => any) | undefined;",
                "  hasPrettierIgnore?: ((path: AstPath<T>) => boolean) | undefined;",
                "  canAttachComment?: ((node: T) => boolean) | undefined;",
                "  isBlockComment?: ((node: T) => boolean) | undefined;",
                "  willPrintOwnComments?: ((path: AstPath<T>) => boolean) | undefined;",
                "  printComment?:",
                "    | ((commentPath: AstPath<T>, options: ParserOptions<T>) => Doc)",
                "    | undefined;",
                "  /**",
                "   * By default, Prettier searches all object properties (except for a few predefined ones) of each node recursively.",
                "   * This function can be provided to override that behavior.",
                "   * @param node The node whose children should be returned.",
                "   * @param options Current options.",
                "   * @returns `[]` if the node has no children or `undefined` to fall back on the default behavior.",
                "   */",
                "  getCommentChildNodes?:",
                "    | ((node: T, options: ParserOptions<T>) => T[] | undefined)",
                "    | undefined;",
                "  handleComments?:",
                "    | {",
                "        ownLine?:",
                "          | ((",
                "              commentNode: any,",
                "              text: string,",
                "              options: ParserOptions<T>,",
                "              ast: T,",
                "              isLastComment: boolean",
                "            ) => boolean)",
                "          | undefined;",
                "        endOfLine?:",
                "          | ((",
                "              commentNode: any,",
                "              text: string,",
                "              options: ParserOptions<T>,",
                "              ast: T,",
                "              isLastComment: boolean",
                "            ) => boolean)",
                "          | undefined;",
                "        remaining?:",
                "          | ((",
                "              commentNode: any,",
                "              text: string,",
                "              options: ParserOptions<T>,",
                "              ast: T,",
                "              isLastComment: boolean",
                "            ) => boolean)",
                "          | undefined;",
                "      }",
                "    | undefined;",
                "}",
                "",
                "export interface CursorOptions extends Options {",
                "  /**",
                "   * Specify where the cursor is.",
                "   */",
                "  cursorOffset: number;",
                "  rangeStart?: never;",
                "  rangeEnd?: never;",
                "}",
                "",
                "export interface CursorResult {",
                "  formatted: string;",
                "  cursorOffset: number;",
                "}",
                "",
                "/**",
                " * `format` is used to format text using Prettier. [Options](https://prettier.io/docs/en/options.html) may be provided to override the defaults.",
                " */",
                "export function format(source: string, options?: Options): Promise<string>;",
                "",
                "/**",
                " * `check` checks to see if the file has been formatted with Prettier given those options and returns a `Boolean`.",
                " * This is similar to the `--list-different` parameter in the CLI and is useful for running Prettier in CI scenarios.",
                " */",
                "export function check(source: string, options?: Options): Promise<boolean>;",
                "",
                "/**",
                " * `formatWithCursor` both formats the code, and translates a cursor position from unformatted code to formatted code.",
                " * This is useful for editor integrations, to prevent the cursor from moving when code is formatted.",
                " *",
                " * The `cursorOffset` option should be provided, to specify where the cursor is. This option cannot be used with `rangeStart` and `rangeEnd`.",
                " */",
                "export function formatWithCursor(",
                "  source: string,",
                "  options: CursorOptions",
                "): Promise<CursorResult>;",
                "",
                "export function formatAST(ast: any, options?: Options): Promise<string>;",
                "",
                "export interface ResolveConfigOptions {",
                "  /**",
                "   * If set to `false`, all caching will be bypassed.",
                "   */",
                "  useCache?: boolean | undefined;",
                "  /**",
                "   * Pass directly the path of the config file if you don't wish to search for it.",
                "   */",
                "  config?: string | undefined;",
                "  /**",
                "   * If set to `true` and an `.editorconfig` file is in your project,",
                "   * Prettier will parse it and convert its properties to the corresponding prettier configuration.",
                "   * This configuration will be overridden by `.prettierrc`, etc. Currently,",
                "   * the following EditorConfig properties are supported:",
                "   * - indent_style",
                "   * - indent_size/tab_width",
                "   * - max_line_length",
                "   */",
                "  editorconfig?: boolean | undefined;",
                "}",
                "",
                "/**",
                " * `resolveConfig` can be used to resolve configuration for a given source file,",
                " * passing its path as the first argument. The config search will start at the",
                " * file path and continue to search up the directory.",
                " * (You can use `process.cwd()` to start searching from the current directory).",
                " *",
                " * A promise is returned which will resolve to:",
                " *",
                " *  - An options object, providing a [config file](https://prettier.io/docs/en/configuration.html) was found.",
                " *  - `null`, if no file was found.",
                " *",
                " * The promise will be rejected if there was an error parsing the configuration file.",
                " */",
                "export function resolveConfig(",
                "  filePath: string,",
                "  options?: ResolveConfigOptions",
                "): Promise<Options | null>;",
                "",
                "/**",
                " * `resolveConfigFile` can be used to find the path of the Prettier configuration file,",
                " * that will be used when resolving the config (i.e. when calling `resolveConfig`).",
                " *",
                " * A promise is returned which will resolve to:",
                " *",
                " * - The path of the configuration file.",
                " * - `null`, if no file was found.",
                " *",
                " * The promise will be rejected if there was an error parsing the configuration file.",
                " */",
                "export function resolveConfigFile(filePath?: string): Promise<string | null>;",
                "",
                "/**",
                " * As you repeatedly call `resolveConfig`, the file system structure will be cached for performance. This function will clear the cache.",
                " * Generally this is only needed for editor integrations that know that the file system has changed since the last format took place.",
                " */",
                "export function clearConfigCache(): Promise<void>;",
                "",
                "export interface SupportLanguage {",
                "  name: string;",
                "  since?: string | undefined;",
                "  parsers: BuiltInParserName[] | string[];",
                "  group?: string | undefined;",
                "  tmScope?: string | undefined;",
                "  aceMode?: string | undefined;",
                "  codemirrorMode?: string | undefined;",
                "  codemirrorMimeType?: string | undefined;",
                "  aliases?: string[] | undefined;",
                "  extensions?: string[] | undefined;",
                "  filenames?: string[] | undefined;",
                "  linguistLanguageId?: number | undefined;",
                "  vscodeLanguageIds?: string[] | undefined;",
                "  interpreters?: string[] | undefined;",
                "}",
                "",
                "export interface SupportOptionRange {",
                "  start: number;",
                "  end: number;",
                "  step: number;",
                "}",
                "",
                "export type SupportOptionType =",
                "  | \"int\"",
                "  | \"string\"",
                "  | \"boolean\"",
                "  | \"choice\"",
                "  | \"path\";",
                "",
                "export type CoreCategoryType =",
                "  | \"Config\"",
                "  | \"Editor\"",
                "  | \"Format\"",
                "  | \"Other\"",
                "  | \"Output\"",
                "  | \"Global\"",
                "  | \"Special\";",
                "",
                "export interface BaseSupportOption<Type extends SupportOptionType> {",
                "  readonly name?: string | undefined;",
                "  /**",
                "   * Usually you can use {@link CoreCategoryType}",
                "   */",
                "  category: string;",
                "  /**",
                "   * The type of the option.",
                "   *",
                "   * When passing a type other than the ones listed below, the option is",
                "   * treated as taking any string as argument, and `--option <${type}>` will",
                "   * be displayed in --help.",
                "   */",
                "  type: Type;",
                "  /**",
                "   * Indicate that the option is deprecated.",
                "   *",
                "   * Use a string to add an extra message to --help for the option,",
                "   * for example to suggest a replacement option.",
                "   */",
                "  deprecated?: true | string | undefined;",
                "  /**",
                "   * Description to be displayed in --help. If omitted, the option won't be",
                "   * shown at all in --help.",
                "   */",
                "  description?: string | undefined;",
                "}",
                "",
                "export interface IntSupportOption extends BaseSupportOption<\"int\"> {",
                "  default?: number | undefined;",
                "  array?: false | undefined;",
                "  range?: SupportOptionRange | undefined;",
                "}",
                "",
                "export interface IntArraySupportOption extends BaseSupportOption<\"int\"> {",
                "  default?: Array<{ value: number[] }> | undefined;",
                "  array: true;",
                "}",
                "",
                "export interface StringSupportOption extends BaseSupportOption<\"string\"> {",
                "  default?: string | undefined;",
                "  array?: false | undefined;",
                "}",
                "",
                "export interface StringArraySupportOption extends BaseSupportOption<\"string\"> {",
                "  default?: Array<{ value: string[] }> | undefined;",
                "  array: true;",
                "}",
                "",
                "export interface BooleanSupportOption extends BaseSupportOption<\"boolean\"> {",
                "  default?: boolean | undefined;",
                "  array?: false | undefined;",
                "  description: string;",
                "  oppositeDescription?: string | undefined;",
                "}",
                "",
                "export interface BooleanArraySupportOption",
                "  extends BaseSupportOption<\"boolean\"> {",
                "  default?: Array<{ value: boolean[] }> | undefined;",
                "  array: true;",
                "}",
                "",
                "export interface ChoiceSupportOption<Value = any>",
                "  extends BaseSupportOption<\"choice\"> {",
                "  default?: Value | Array<{ value: Value }> | undefined;",
                "  description: string;",
                "  choices: Array<{",
                "    since?: string | undefined;",
                "    value: Value;",
                "    description: string;",
                "  }>;",
                "}",
                "",
                "export interface PathSupportOption extends BaseSupportOption<\"path\"> {",
                "  default?: string | undefined;",
                "  array?: false | undefined;",
                "}",
                "",
                "export interface PathArraySupportOption extends BaseSupportOption<\"path\"> {",
                "  default?: Array<{ value: string[] }> | undefined;",
                "  array: true;",
                "}",
                "",
                "export type SupportOption =",
                "  | IntSupportOption",
                "  | IntArraySupportOption",
                "  | StringSupportOption",
                "  | StringArraySupportOption",
                "  | BooleanSupportOption",
                "  | BooleanArraySupportOption",
                "  | ChoiceSupportOption",
                "  | PathSupportOption",
                "  | PathArraySupportOption;",
                "",
                "export interface SupportOptions extends Record<string, SupportOption> {}",
                "",
                "export interface SupportInfo {",
                "  languages: SupportLanguage[];",
                "  options: SupportOption[];",
                "}",
                "",
                "export interface FileInfoOptions {",
                "  ignorePath?: string | string[] | undefined;",
                "  withNodeModules?: boolean | undefined;",
                "  plugins?: string[] | undefined;",
                "  resolveConfig?: boolean | undefined;",
                "}",
                "",
                "export interface FileInfoResult {",
                "  ignored: boolean;",
                "  inferredParser: string | null;",
                "}",
                "",
                "export function getFileInfo(",
                "  filePath: string,",
                "  options?: FileInfoOptions",
                "): Promise<FileInfoResult>;",
                "",
                "/**",
                " * Returns an object representing the parsers, languages and file types Prettier supports for the current version.",
                " */",
                "export function getSupportInfo(): Promise<SupportInfo>;",
                "",
                "/**",
                " * `version` field in `package.json`",
                " */",
                "export const version: string;",
                "",
                "// https://github.com/prettier/prettier/blob/next/src/utils/public.js",
                "export namespace util {",
                "  interface SkipOptions {",
                "    backwards?: boolean | undefined;",
                "  }",
                "",
                "  type Quote = \"'\" | '\"';",
                "",
                "  function getMaxContinuousCount(text: string, searchString: string): number;",
                "",
                "  function getStringWidth(text: string): number;",
                "",
                "  function getAlignmentSize(",
                "    text: string,",
                "    tabWidth: number,",
                "    startIndex?: number | undefined",
                "  ): number;",
                "",
                "  function getIndentSize(value: string, tabWidth: number): number;",
                "",
                "  function skipNewline(",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions | undefined",
                "  ): number | false;",
                "",
                "  function skipInlineComment(",
                "    text: string,",
                "    startIndex: number | false",
                "  ): number | false;",
                "",
                "  function skipTrailingComment(",
                "    text: string,",
                "    startIndex: number | false",
                "  ): number | false;",
                "",
                "  function skipTrailingComment(",
                "    text: string,",
                "    startIndex: number | false",
                "  ): number | false;",
                "",
                "  function hasNewline(",
                "    text: string,",
                "    startIndex: number,",
                "    options?: SkipOptions | undefined",
                "  ): boolean;",
                "",
                "  function hasNewlineInRange(",
                "    text: string,",
                "    startIndex: number,",
                "    endIndex: number",
                "  ): boolean;",
                "",
                "  function hasSpaces(",
                "    text: string,",
                "    startIndex: number,",
                "    options?: SkipOptions | undefined",
                "  ): boolean;",
                "",
                "  function getNextNonSpaceNonCommentCharacter(",
                "    text: string,",
                "    startIndex: number",
                "  ): string;",
                "",
                "  function makeString(",
                "    rawText: string,",
                "    enclosingQuote: Quote,",
                "    unescapeUnnecessaryEscapes?: boolean | undefined",
                "  ): string;",
                "",
                "  function skip(",
                "    characters: string | RegExp",
                "  ): (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  const skipWhitespace: (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  const skipSpaces: (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  const skipToLineEnd: (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  const skipEverythingButNewLine: (",
                "    text: string,",
                "    startIndex: number | false,",
                "    options?: SkipOptions",
                "  ) => number | false;",
                "",
                "  function addLeadingComment(node: any, comment: any): void;",
                "",
                "  function addDanglingComment(node: any, comment: any, marker: any): void;",
                "",
                "  function addTrailingComment(node: any, comment: any): void;",
                "}"
            ]
        },
        "index.js": {
            "classes": [],
            "functions": [],
            "text": [
                "import vnopts from \"vnopts\";",
                "import fastGlob from \"fast-glob\";",
                "import * as core from \"./main/core.js\";",
                "import {",
                "  getSupportInfo as getSupportInfoWithoutPlugins,",
                "  normalizeOptionSettings,",
                "} from \"./main/support.js\";",
                "import getFileInfoWithoutPlugins from \"./common/get-file-info.js\";",
                "import {",
                "  loadBuiltinPlugins,",
                "  loadPlugins,",
                "  searchPlugins,",
                "  clearCache as clearPluginCache,",
                "} from \"./main/plugins/index.js\";",
                "import {",
                "  resolveConfig,",
                "  resolveConfigFile,",
                "  clearCache as clearConfigCache,",
                "} from \"./config/resolve-config.js\";",
                "import * as errors from \"./common/errors.js\";",
                "import * as optionCategories from \"./main/option-categories.js\";",
                "import { createIsIgnoredFunction } from \"./utils/ignore.js\";",
                "import { formatOptionsHiddenDefaults } from \"./main/normalize-format-options.js\";",
                "import normalizeOptions from \"./main/normalize-options.js\";",
                "import partition from \"./utils/partition.js\";",
                "import isNonEmptyArray from \"./utils/is-non-empty-array.js\";",
                "import omit from \"./utils/object-omit.js\";",
                "",
                "/**",
                " * @param {*} fn",
                " * @param {number} [optionsArgumentIndex]",
                " * @returns {*}",
                " */",
                "function withPlugins(",
                "  fn,",
                "  optionsArgumentIndex = 1 // Usually `options` is the 2nd argument",
                ") {",
                "  return async (...args) => {",
                "    const options = args[optionsArgumentIndex] ?? {};",
                "    const { plugins = [], pluginSearchDirs } = options;",
                "",
                "    args[optionsArgumentIndex] = {",
                "      ...options,",
                "      plugins: (",
                "        await Promise.all([",
                "          loadBuiltinPlugins(),",
                "          // TODO: standalone version allow `plugins` to be `prettierPlugins` which is an object, should allow that too",
                "          loadPlugins(plugins),",
                "          options.pluginSearchDirs === false",
                "            ? []",
                "            : searchPlugins(pluginSearchDirs),",
                "        ])",
                "      ).flat(),",
                "    };",
                "",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "async function format(text, options) {",
                "  const { formatted } = await formatWithCursor(text, {",
                "    ...options,",
                "    cursorOffset: -1,",
                "  });",
                "  return formatted;",
                "}",
                "",
                "async function check(text, options) {",
                "  return (await format(text, options)) === text;",
                "}",
                "",
                "// eslint-disable-next-line require-await",
                "async function clearCache() {",
                "  clearConfigCache();",
                "  clearPluginCache();",
                "}",
                "",
                "/** @type {typeof getFileInfoWithoutPlugins} */",
                "const getFileInfo = withPlugins(getFileInfoWithoutPlugins);",
                "",
                "/** @type {typeof getSupportInfoWithoutPlugins} */",
                "const getSupportInfo = withPlugins(getSupportInfoWithoutPlugins, 0);",
                "",
                "// Internal shared with cli",
                "const sharedWithCli = {",
                "  errors,",
                "  optionCategories,",
                "  createIsIgnoredFunction,",
                "  formatOptionsHiddenDefaults,",
                "  normalizeOptions,",
                "  getSupportInfoWithoutPlugins,",
                "  normalizeOptionSettings,",
                "  vnopts,",
                "  fastGlob,",
                "  utils: {",
                "    isNonEmptyArray,",
                "    partition,",
                "    omit,",
                "  },",
                "};",
                "",
                "const debugApis = {",
                "  parse: withPlugins(core.parse),",
                "  formatAST: withPlugins(core.formatAst),",
                "  formatDoc: withPlugins(core.formatDoc),",
                "  printToDoc: withPlugins(core.printToDoc),",
                "  printDocToString: withPlugins(core.printDocToString),",
                "};",
                "",
                "export {",
                "  formatWithCursor,",
                "  format,",
                "  check,",
                "  resolveConfig,",
                "  resolveConfigFile,",
                "  clearCache as clearConfigCache,",
                "  getFileInfo,",
                "  getSupportInfo,",
                "  sharedWithCli as __internal,",
                "  debugApis as __debug,",
                "};",
                "export * as util from \"./utils/public.js\";",
                "export * as doc from \"./document/public.js\";",
                "export { default as version } from \"./main/version.evaluate.cjs\";"
            ]
        },
        "standalone.d.ts": {
            "classes": [],
            "functions": [],
            "text": [
                "import { CursorOptions, CursorResult, Options, SupportInfo } from \"./index.js\";",
                "",
                "/**",
                " * formatWithCursor both formats the code, and translates a cursor position from unformatted code to formatted code.",
                " * This is useful for editor integrations, to prevent the cursor from moving when code is formatted",
                " *",
                " * The cursorOffset option should be provided, to specify where the cursor is. This option cannot be used with rangeStart and rangeEnd.",
                " *",
                " * ```js",
                " * await prettier.formatWithCursor(\" 1\", { cursorOffset: 2, parser: \"babel\" });",
                " * ```",
                " * `-> { formatted: \"1;\\n\", cursorOffset: 1 }`",
                " */",
                "export function formatWithCursor(",
                "  source: string,",
                "  options: CursorOptions",
                "): Promise<CursorResult>;",
                "",
                "/**",
                " * `format` is used to format text using Prettier. [Options](https://prettier.io/docs/en/options.html) may be provided to override the defaults.",
                " */",
                "export function format(source: string, options?: Options): Promise<string>;",
                "",
                "/**",
                " * `check` checks to see if the file has been formatted with Prettier given those options and returns a `Boolean`.",
                " * This is similar to the `--list-different` parameter in the CLI and is useful for running Prettier in CI scenarios.",
                " */",
                "export function check(source: string, options?: Options): Promise<boolean>;",
                "",
                "/**",
                " * Returns an object representing the parsers, languages and file types Prettier supports for the current version.",
                " */",
                "export function getSupportInfo(): Promise<SupportInfo>;"
            ]
        },
        "standalone.js": {
            "classes": [],
            "functions": [],
            "text": [
                "import * as core from \"./main/core.js\";",
                "import { getSupportInfo as getSupportInfoWithoutPlugins } from \"./main/support.js\";",
                "",
                "function withPlugins(",
                "  fn,",
                "  optionsArgumentIndex = 1 // Usually `options` is the 2nd argument",
                ") {",
                "  // Returns Promises to consistent with functions in `index.js`",
                "  // eslint-disable-next-line require-await",
                "  return async (...args) => {",
                "    const options = args[optionsArgumentIndex] ?? {};",
                "    const plugins = options.plugins ?? [];",
                "",
                "    args[optionsArgumentIndex] = {",
                "      ...options,",
                "      plugins: Array.isArray(plugins) ? plugins : Object.values(plugins),",
                "    };",
                "",
                "    return fn(...args);",
                "  };",
                "}",
                "",
                "const formatWithCursor = withPlugins(core.formatWithCursor);",
                "",
                "async function format(text, options) {",
                "  const { formatted } = await formatWithCursor(text, {",
                "    ...options,",
                "    cursorOffset: -1,",
                "  });",
                "  return formatted;",
                "}",
                "",
                "async function check(text, options) {",
                "  return (await format(text, options)) === text;",
                "}",
                "",
                "const getSupportInfo = withPlugins(getSupportInfoWithoutPlugins, 0);",
                "",
                "const debugApis = {",
                "  parse: withPlugins(core.parse),",
                "  formatAST: withPlugins(core.formatAst),",
                "  formatDoc: withPlugins(core.formatDoc),",
                "  printToDoc: withPlugins(core.printToDoc),",
                "  printDocToString: withPlugins(core.printDocToString),",
                "};",
                "",
                "export {",
                "  formatWithCursor,",
                "  format,",
                "  check,",
                "  getSupportInfo,",
                "  debugApis as __debug,",
                "};",
                "export * as util from \"./utils/public.js\";",
                "export * as doc from \"./document/public.js\";",
                "export { default as version } from \"./main/version.evaluate.cjs\";"
            ]
        },
        "cli": {
            "cli-options.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { outdent } from \"outdent\";",
                    "import { optionCategories } from \"./prettier-internal.js\";",
                    "",
                    "/**",
                    " * {",
                    " *   [optionName]: {",
                    " *     // The type of the option. For 'choice', see also `choices` below.",
                    " *     // When passing a type other than the ones listed below, the option is",
                    " *     // treated as taking any string as argument, and `--option <${type}>` will",
                    " *     // be displayed in --help.",
                    " *     type: \"boolean\" | \"choice\" | \"int\" | string;",
                    " *",
                    " *     // Default value to be passed to the minimist option `default`.",
                    " *     default?: any;",
                    " *",
                    " *     // Alias name to be passed to the minimist option `alias`.",
                    " *     alias?: string;",
                    " *",
                    " *     // For grouping options by category in --help.",
                    " *     category?: string;",
                    " *",
                    " *     // Description to be displayed in --help. If omitted, the option won't be",
                    " *     // shown at all in --help (but see also `oppositeDescription` below).",
                    " *     description?: string;",
                    " *",
                    " *     // Description for `--no-${name}` to be displayed in --help. If omitted,",
                    " *     // `--no-${name}` won't be shown.",
                    " *     oppositeDescription?: string;",
                    " *",
                    " *     // Indicate if this option is simply passed to the API.",
                    " *     // true: use camelified name as the API option name.",
                    " *     // string: use this value as the API option name.",
                    " *     forwardToApi?: boolean | string;",
                    " *",
                    " *     // Indicate that a CLI flag should be an array when forwarded to the API.",
                    " *     array?: boolean;",
                    " *",
                    " *     // Specify available choices for validation. They will also be displayed",
                    " *     // in --help as <a|b|c>.",
                    " *     // Use an object instead of a string if a choice is deprecated and should",
                    " *     // be treated as `redirect` instead, or if you'd like to add description for",
                    " *     // the choice.",
                    " *     choices?: Array<",
                    " *       | string",
                    " *       | { value: string, description?: string, deprecated?: boolean, redirect?: string }",
                    " *     >;",
                    " *",
                    " *     // If the option has a value that is an exception to the regular value",
                    " *     // constraints, indicate that value here (or use a function for more",
                    " *     // flexibility).",
                    " *     exception?: ((value: any) => boolean);",
                    " *",
                    " *     // Indicate that the option is deprecated. Use a string to add an extra",
                    " *     // message to --help for the option, for example to suggest a replacement",
                    " *     // option.",
                    " *     deprecated?: true | string;",
                    " *   }",
                    " * }",
                    " *",
                    " * Note: The options below are sorted alphabetically.",
                    " */",
                    "/* eslint sort-keys: \"error\" */",
                    "const options = {",
                    "  cache: {",
                    "    default: false,",
                    "    description: \"Only format changed files. Cannot use with --stdin-filepath.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  cacheLocation: {",
                    "    description: \"Path to the cache file.\",",
                    "    type: \"path\",",
                    "  },",
                    "  cacheStrategy: {",
                    "    choices: [",
                    "      {",
                    "        description: \"Use the file metadata such as timestamps as cache keys\",",
                    "        value: \"metadata\",",
                    "      },",
                    "      {",
                    "        description: \"Use the file content as cache keys\",",
                    "        value: \"content\",",
                    "      },",
                    "    ],",
                    "    description: \"Strategy for the cache to use for detecting changed files.\",",
                    "    type: \"choice\",",
                    "  },",
                    "  check: {",
                    "    alias: \"c\",",
                    "    category: optionCategories.CATEGORY_OUTPUT,",
                    "    description: outdent`",
                    "      Check if the given files are formatted, print a human-friendly summary",
                    "      message and paths to unformatted files (see also --list-different).",
                    "    `,",
                    "    type: \"boolean\",",
                    "  },",
                    "  color: {",
                    "    // The supports-color package (a sub sub dependency) looks directly at",
                    "    // `process.argv` for `--no-color` and such-like options. The reason it is",
                    "    // listed here is to avoid \"Ignored unknown option: --no-color\" warnings.",
                    "    // See https://github.com/chalk/supports-color/#info for more information.",
                    "    default: true,",
                    "    description: \"Colorize error messages.\",",
                    "    oppositeDescription: \"Do not colorize error messages.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  config: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Path to a Prettier configuration file (.prettierrc, package.json, prettier.config.js).\",",
                    "    exception: (value) => value === false,",
                    "    oppositeDescription: \"Do not look for a configuration file.\",",
                    "    type: \"path\",",
                    "  },",
                    "  configPrecedence: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    choices: [",
                    "      {",
                    "        description: \"CLI options take precedence over config file\",",
                    "        value: \"cli-override\",",
                    "      },",
                    "      {",
                    "        description: \"Config file take precedence over CLI options\",",
                    "        value: \"file-override\",",
                    "      },",
                    "      {",
                    "        description: outdent`",
                    "          If a config file is found will evaluate it and ignore other CLI options.",
                    "          If no config file is found CLI options will evaluate as normal.",
                    "        `,",
                    "        value: \"prefer-file\",",
                    "      },",
                    "    ],",
                    "    default: \"cli-override\",",
                    "    description:",
                    "      \"Define in which order config files and CLI options should be evaluated.\",",
                    "    type: \"choice\",",
                    "  },",
                    "  debugBenchmark: {",
                    "    // Run the formatting benchmarks. Requires 'benchmark' module to be installed.",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugCheck: {",
                    "    // Run the formatting once again on the formatted output, throw if different.",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugPrintAst: {",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugPrintComments: {",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugPrintDoc: {",
                    "    type: \"boolean\",",
                    "  },",
                    "  debugRepeat: {",
                    "    // Repeat the formatting a few times and measure the average duration.",
                    "    default: 0,",
                    "    type: \"int\",",
                    "  },",
                    "  editorconfig: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    default: true,",
                    "    description: \"Take .editorconfig into account when parsing configuration.\",",
                    "    oppositeDescription:",
                    "      \"Don't take .editorconfig into account when parsing configuration.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  errorOnUnmatchedPattern: {",
                    "    oppositeDescription: \"Prevent errors when pattern is unmatched.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  fileInfo: {",
                    "    description: outdent`",
                    "      Extract the following info (as JSON) for a given file path. Reported fields:",
                    "      * ignored (boolean) - true if file path is filtered by --ignore-path",
                    "      * inferredParser (string | null) - name of parser inferred from file path",
                    "    `,",
                    "    type: \"path\",",
                    "  },",
                    "  findConfigPath: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    description:",
                    "      \"Find and print the path to a configuration file for the given input file.\",",
                    "    type: \"path\",",
                    "  },",
                    "  help: {",
                    "    alias: \"h\",",
                    "    description: outdent`",
                    "      Show CLI usage, or details about the given flag.",
                    "      Example: --help write",
                    "    `,",
                    "    exception: (value) => value === \"\",",
                    "    type: \"flag\",",
                    "  },",
                    "  ignorePath: {",
                    "    array: true,",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    default: [{ value: [\".prettierignore\"] }],",
                    "    description: outdent`",
                    "      Path to a file with patterns describing files to ignore.",
                    "      Multiple values are accepted.",
                    "    `,",
                    "    type: \"path\",",
                    "  },",
                    "  ignoreUnknown: {",
                    "    alias: \"u\",",
                    "    description: \"Ignore unknown files.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  listDifferent: {",
                    "    alias: \"l\",",
                    "    category: optionCategories.CATEGORY_OUTPUT,",
                    "    description:",
                    "      \"Print the names of files that are different from Prettier's formatting (see also --check).\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  logLevel: {",
                    "    choices: [\"silent\", \"error\", \"warn\", \"log\", \"debug\"],",
                    "    default: \"log\",",
                    "    description: \"What level of logs to report.\",",
                    "    type: \"choice\",",
                    "  },",
                    "  pluginSearch: {",
                    "    oppositeDescription: \"Disable plugin autoloading.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  supportInfo: {",
                    "    description: \"Print support information as JSON.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  version: {",
                    "    alias: \"v\",",
                    "    description: \"Print Prettier version.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  withNodeModules: {",
                    "    category: optionCategories.CATEGORY_CONFIG,",
                    "    description: \"Process files inside 'node_modules' directory.\",",
                    "    type: \"boolean\",",
                    "  },",
                    "  write: {",
                    "    alias: \"w\",",
                    "    category: optionCategories.CATEGORY_OUTPUT,",
                    "    description: \"Edit files in-place. (Beware!)\",",
                    "    type: \"boolean\",",
                    "  },",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { outdent } from \"outdent\";",
                    "import { optionCategories } from \"./prettier-internal.js\";",
                    "",
                    "const categoryOrder = [",
                    "  optionCategories.CATEGORY_OUTPUT,",
                    "  optionCategories.CATEGORY_FORMAT,",
                    "  optionCategories.CATEGORY_CONFIG,",
                    "  optionCategories.CATEGORY_EDITOR,",
                    "  optionCategories.CATEGORY_OTHER,",
                    "];",
                    "",
                    "const usageSummary = outdent`",
                    "  Usage: prettier [options] [file/dir/glob ...]",
                    "",
                    "  By default, output is written to stdout.",
                    "  Stdin is read if it is piped to Prettier and no files are given.",
                    "`;",
                    "",
                    "export { categoryOrder, usageSummary };"
                ]
            },
            "context.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { getContextOptions } from \"./options/get-context-options.js\";",
                    "import {",
                    "  parseArgv,",
                    "  parseArgvWithoutPlugins,",
                    "} from \"./options/parse-cli-arguments.js\";",
                    "",
                    "/**",
                    " * @typedef {Object} Context",
                    " * @property logger",
                    " * @property {string[]} rawArguments",
                    " * @property argv",
                    " * @property {string[]} filePatterns",
                    " * @property {any[]} supportOptions",
                    " * @property detailedOptions",
                    " * @property languages",
                    " * @property {Partial<Context>[]} stack",
                    " * @property pushContextPlugins",
                    " * @property popContextPlugins",
                    " */",
                    "",
                    "class Context {",
                    "  #stack = [];",
                    "",
                    "  constructor({ rawArguments, logger }) {",
                    "    this.rawArguments = rawArguments;",
                    "    this.logger = logger;",
                    "  }",
                    "",
                    "  async init() {",
                    "    const { rawArguments, logger } = this;",
                    "",
                    "    const { plugins, pluginSearchDirs } = parseArgvWithoutPlugins(",
                    "      rawArguments,",
                    "      logger,",
                    "      [\"plugin\", \"plugin-search-dir\"]",
                    "    );",
                    "",
                    "    await this.pushContextPlugins(plugins, pluginSearchDirs);",
                    "",
                    "    const argv = parseArgv(rawArguments, this.detailedOptions, logger);",
                    "    this.argv = argv;",
                    "    this.filePatterns = argv._;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string[]} plugins",
                    "   * @param {string[]=} pluginSearchDirs",
                    "   */",
                    "  async pushContextPlugins(plugins, pluginSearchDirs) {",
                    "    const options = await getContextOptions(plugins, pluginSearchDirs);",
                    "    this.#stack.push(options);",
                    "    Object.assign(this, options);",
                    "  }",
                    "",
                    "  popContextPlugins() {",
                    "    this.#stack.pop();",
                    "    Object.assign(this, this.#stack.at(-1));",
                    "  }",
                    "",
                    "  // eslint-disable-next-line getter-return",
                    "  get performanceTestFlag() {",
                    "    const { debugBenchmark, debugRepeat } = this.argv;",
                    "    /* c8 ignore start */",
                    "    if (debugBenchmark) {",
                    "      return {",
                    "        name: \"--debug-benchmark\",",
                    "        debugBenchmark: true,",
                    "      };",
                    "    }",
                    "    /* c8 ignore stop */",
                    "",
                    "    if (debugRepeat > 0) {",
                    "      return {",
                    "        name: \"--debug-repeat\",",
                    "        debugRepeat,",
                    "      };",
                    "    }",
                    "",
                    "    /* c8 ignore start */",
                    "    const { PRETTIER_PERF_REPEAT } = process.env;",
                    "    if (PRETTIER_PERF_REPEAT && /^\\d+$/.test(PRETTIER_PERF_REPEAT)) {",
                    "      return {",
                    "        name: \"PRETTIER_PERF_REPEAT (environment variable)\",",
                    "        debugRepeat: Number(PRETTIER_PERF_REPEAT),",
                    "      };",
                    "    }",
                    "    /* c8 ignore stop */",
                    "  }",
                    "}",
                    "",
                    "export default Context;"
                ]
            },
            "expand-patterns.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import { statSafe, normalizeToPosix } from \"./utils.js\";",
                    "import { fastGlob } from \"./prettier-internal.js\";",
                    "",
                    "/** @typedef {import('./context').Context} Context */",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "async function* expandPatterns(context) {",
                    "  const seen = new Set();",
                    "  let noResults = true;",
                    "",
                    "  for await (const pathOrError of expandPatternsInternal(context)) {",
                    "    noResults = false;",
                    "    if (typeof pathOrError !== \"string\") {",
                    "      yield pathOrError;",
                    "      continue;",
                    "    }",
                    "",
                    "    const fileName = path.resolve(pathOrError);",
                    "",
                    "    // filter out duplicates",
                    "    if (seen.has(fileName)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    seen.add(fileName);",
                    "    yield fileName;",
                    "  }",
                    "",
                    "  if (noResults && context.argv.errorOnUnmatchedPattern !== false) {",
                    "    // If there was no files and no other errors, let's yield a general error.",
                    "    yield {",
                    "      error: `No matching files. Patterns: ${context.filePatterns.join(\" \")}`,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Context} context",
                    " */",
                    "async function* expandPatternsInternal(context) {",
                    "  // Ignores files in version control systems directories and `node_modules`",
                    "  const silentlyIgnoredDirs = [\".git\", \".sl\", \".svn\", \".hg\"];",
                    "  if (context.argv.withNodeModules !== true) {",
                    "    silentlyIgnoredDirs.push(\"node_modules\");",
                    "  }",
                    "  const globOptions = {",
                    "    dot: true,",
                    "    ignore: silentlyIgnoredDirs.map((dir) => \"**/\" + dir),",
                    "  };",
                    "",
                    "  let supportedFilesGlob;",
                    "  const cwd = process.cwd();",
                    "",
                    "  /** @type {Array<{ type: 'file' | 'dir' | 'glob'; glob: string; input: string; }>} */",
                    "  const entries = [];",
                    "",
                    "  for (const pattern of context.filePatterns) {",
                    "    const absolutePath = path.resolve(cwd, pattern);",
                    "",
                    "    if (containsIgnoredPathSegment(absolutePath, cwd, silentlyIgnoredDirs)) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const stat = await statSafe(absolutePath);",
                    "    if (stat) {",
                    "      if (stat.isFile()) {",
                    "        entries.push({",
                    "          type: \"file\",",
                    "          glob: escapePathForGlob(fixWindowsSlashes(pattern)),",
                    "          input: pattern,",
                    "        });",
                    "      } else if (stat.isDirectory()) {",
                    "        /*",
                    "        1. Remove trailing `/`, `fast-glob` can't find files for `src//*.js` pattern",
                    "        2. Cleanup dirname, when glob `src/../*.js` pattern with `fast-glob`,",
                    "          it returns files like 'src/../index.js'",
                    "        */",
                    "        const relativePath = path.relative(cwd, absolutePath) || \".\";",
                    "        entries.push({",
                    "          type: \"dir\",",
                    "          glob:",
                    "            escapePathForGlob(fixWindowsSlashes(relativePath)) +",
                    "            \"/\" +",
                    "            getSupportedFilesGlob(),",
                    "          input: pattern,",
                    "        });",
                    "      }",
                    "    } else if (pattern[0] === \"!\") {",
                    "      // convert negative patterns to `ignore` entries",
                    "      globOptions.ignore.push(fixWindowsSlashes(pattern.slice(1)));",
                    "    } else {",
                    "      entries.push({",
                    "        type: \"glob\",",
                    "        glob: fixWindowsSlashes(pattern),",
                    "        input: pattern,",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  for (const { type, glob, input } of entries) {",
                    "    let result;",
                    "",
                    "    try {",
                    "      result = await fastGlob(glob, globOptions);",
                    "    } catch ({ message }) {",
                    "      /* c8 ignore next 4 */",
                    "      yield {",
                    "        error: `${errorMessages.globError[type]}: \"${input}\".\\n${message}`,",
                    "      };",
                    "      continue;",
                    "    }",
                    "",
                    "    if (result.length === 0) {",
                    "      if (context.argv.errorOnUnmatchedPattern !== false) {",
                    "        yield { error: `${errorMessages.emptyResults[type]}: \"${input}\".` };",
                    "      }",
                    "    } else {",
                    "      yield* sortPaths(result);",
                    "    }",
                    "  }",
                    "",
                    "  function getSupportedFilesGlob() {",
                    "    if (!supportedFilesGlob) {",
                    "      const extensions = context.languages.flatMap(",
                    "        (lang) => lang.extensions || []",
                    "      );",
                    "      const filenames = context.languages.flatMap(",
                    "        (lang) => lang.filenames || []",
                    "      );",
                    "      supportedFilesGlob = `**/{${[",
                    "        ...extensions.map((ext) => \"*\" + (ext[0] === \".\" ? ext : \".\" + ext)),",
                    "        ...filenames,",
                    "      ]}}`;",
                    "    }",
                    "    return supportedFilesGlob;",
                    "  }",
                    "}",
                    "",
                    "const errorMessages = {",
                    "  globError: {",
                    "    file: \"Unable to resolve file\",",
                    "    dir: \"Unable to expand directory\",",
                    "    glob: \"Unable to expand glob pattern\",",
                    "  },",
                    "  emptyResults: {",
                    "    file: \"Explicitly specified file was ignored due to negative glob patterns\",",
                    "    dir: \"No supported files were found in the directory\",",
                    "    glob: \"No files matching the pattern were found\",",
                    "  },",
                    "};",
                    "",
                    "/**",
                    " * @param {string} absolutePath",
                    " * @param {string} cwd",
                    " * @param {string[]} ignoredDirectories",
                    " */",
                    "function containsIgnoredPathSegment(absolutePath, cwd, ignoredDirectories) {",
                    "  return path",
                    "    .relative(cwd, absolutePath)",
                    "    .split(path.sep)",
                    "    .some((dir) => ignoredDirectories.includes(dir));",
                    "}",
                    "",
                    "/**",
                    " * @param {string[]} paths",
                    " */",
                    "function sortPaths(paths) {",
                    "  return paths.sort((a, b) => a.localeCompare(b));",
                    "}",
                    "",
                    "/**",
                    " * This function should be replaced with `fastGlob.escapePath` when these issues are fixed:",
                    " * - https://github.com/mrmlnc/fast-glob/issues/261",
                    " * - https://github.com/mrmlnc/fast-glob/issues/262",
                    " * @param {string} path",
                    " */",
                    "function escapePathForGlob(path) {",
                    "  return fastGlob",
                    "    .escapePath(",
                    "      path.replaceAll(\"\\\\\", \"\\0\") // Workaround for fast-glob#262 (part 1)",
                    "    )",
                    "    .replaceAll(\"\\\\!\", \"@(!)\") // Workaround for fast-glob#261",
                    "    .replaceAll(\"\\0\", \"@(\\\\\\\\)\"); // Workaround for fast-glob#262 (part 2)",
                    "}",
                    "",
                    "/**",
                    " * Using backslashes in globs is probably not okay, but not accepting",
                    " * backslashes as path separators on Windows is even more not okay.",
                    " * https://github.com/prettier/prettier/pull/6776#discussion_r380723717",
                    " * https://github.com/mrmlnc/fast-glob#how-to-write-patterns-on-windows",
                    " */",
                    "const fixWindowsSlashes = normalizeToPosix;",
                    "",
                    "export { expandPatterns };"
                ]
            },
            "file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import stringify from \"fast-json-stable-stringify\";",
                    "import { format, getFileInfo } from \"../index.js\";",
                    "import { printToScreen } from \"./utils.js\";",
                    "",
                    "async function logFileInfoOrDie(context) {",
                    "  const {",
                    "    fileInfo: file,",
                    "    ignorePath,",
                    "    withNodeModules,",
                    "    plugins,",
                    "    pluginSearchDirs,",
                    "    config,",
                    "  } = context.argv;",
                    "",
                    "  const fileInfo = await getFileInfo(file, {",
                    "    ignorePath,",
                    "    withNodeModules,",
                    "    plugins,",
                    "    pluginSearchDirs,",
                    "    resolveConfig: config !== false,",
                    "  });",
                    "",
                    "  printToScreen(await format(stringify(fileInfo), { parser: \"json\" }));",
                    "}",
                    "",
                    "export default logFileInfoOrDie;"
                ]
            },
            "find-cache-file.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "import os from \"node:os\";",
                    "import path from \"node:path\";",
                    "import findCacheDir from \"find-cache-dir\";",
                    "import { statSafe, isJson } from \"./utils.js\";",
                    "",
                    "/**",
                    " * Find default cache file (`./node_modules/.cache/prettier/.prettier-cache`) using https://github.com/avajs/find-cache-dir",
                    " */",
                    "function findDefaultCacheFile() {",
                    "  const cacheDir =",
                    "    findCacheDir({ name: \"prettier\", create: true }) || os.tmpdir();",
                    "  const cacheFilePath = path.join(cacheDir, \".prettier-cache\");",
                    "  return cacheFilePath;",
                    "}",
                    "",
                    "async function findCacheFileFromOption(cacheLocation) {",
                    "  const cacheFile = path.resolve(cacheLocation);",
                    "",
                    "  const stat = await statSafe(cacheFile);",
                    "  if (stat) {",
                    "    if (stat.isDirectory()) {",
                    "      throw new Error(",
                    "        `Resolved --cache-location '${cacheFile}' is a directory`",
                    "      );",
                    "    }",
                    "",
                    "    const data = await fs.readFile(cacheFile, \"utf8\");",
                    "    if (!isJson(data)) {",
                    "      throw new Error(`'${cacheFile}' isn't a valid JSON file`);",
                    "    }",
                    "  }",
                    "",
                    "  return cacheFile;",
                    "}",
                    "",
                    "/**",
                    " * @param {string | undefined} cacheLocation",
                    " * @returns {Promise<string>}",
                    " */",
                    "async function findCacheFile(cacheLocation) {",
                    "  if (!cacheLocation) {",
                    "    return findDefaultCacheFile();",
                    "  }",
                    "  const cacheFile = await findCacheFileFromOption(cacheLocation);",
                    "  return cacheFile;",
                    "}",
                    "",
                    "export default findCacheFile;"
                ]
            },
            "find-config-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import { resolveConfigFile } from \"../index.js\";",
                    "import { printToScreen, normalizeToPosix } from \"./utils.js\";",
                    "",
                    "async function logResolvedConfigPathOrDie(context) {",
                    "  const file = context.argv.findConfigPath;",
                    "  const configFile = await resolveConfigFile(file);",
                    "  if (configFile) {",
                    "    printToScreen(normalizeToPosix(path.relative(process.cwd(), configFile)));",
                    "  } else {",
                    "    throw new Error(`Can not find configure file for \"${file}\".`);",
                    "  }",
                    "}",
                    "",
                    "export default logResolvedConfigPathOrDie;"
                ]
            },
            "format-results-cache.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// Inspired by LintResultsCache from ESLint",
                    "// https://github.com/eslint/eslint/blob/c2d0a830754b6099a3325e6d3348c3ba983a677a/lib/cli-engine/lint-result-cache.js",
                    "",
                    "import fileEntryCache from \"file-entry-cache\";",
                    "import stringify from \"fast-json-stable-stringify\";",
                    "import { version as prettierVersion } from \"../index.js\";",
                    "import { createHash } from \"./utils.js\";",
                    "",
                    "const optionsHashCache = new WeakMap();",
                    "const nodeVersion = process.version;",
                    "",
                    "/**",
                    " * @param {*} options",
                    " * @returns {string}",
                    " */",
                    "function getHashOfOptions(options) {",
                    "  if (optionsHashCache.has(options)) {",
                    "    return optionsHashCache.get(options);",
                    "  }",
                    "  const hash = createHash(",
                    "    `${prettierVersion}_${nodeVersion}_${stringify(options)}`",
                    "  );",
                    "  optionsHashCache.set(options, hash);",
                    "  return hash;",
                    "}",
                    "",
                    "/**",
                    " * @typedef {{ hashOfOptions?: string }} OurMeta",
                    " * @typedef {import(\"file-entry-cache\").FileDescriptor} FileDescriptor",
                    " *",
                    " * @param {import(\"file-entry-cache\").FileDescriptor} fileDescriptor",
                    " * @returns {FileDescriptor[\"meta\"] & OurMeta}",
                    " */",
                    "function getMetadataFromFileDescriptor(fileDescriptor) {",
                    "  return fileDescriptor.meta;",
                    "}",
                    "",
                    "class FormatResultsCache {",
                    "  #fileEntryCache;",
                    "",
                    "  /**",
                    "   * @param {string} cacheFileLocation The path of cache file location. (default: `node_modules/.cache/prettier/.prettier-cache`)",
                    "   * @param {string} cacheStrategy",
                    "   */",
                    "  constructor(cacheFileLocation, cacheStrategy) {",
                    "    const useChecksum = cacheStrategy === \"content\";",
                    "",
                    "    this.#fileEntryCache = fileEntryCache.create(",
                    "      /* cacheId */ cacheFileLocation,",
                    "      /* directory */ undefined,",
                    "      useChecksum",
                    "    );",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string} filePath",
                    "   * @param {any} options",
                    "   */",
                    "  existsAvailableFormatResultsCache(filePath, options) {",
                    "    const fileDescriptor = this.#fileEntryCache.getFileDescriptor(filePath);",
                    "",
                    "    /* c8 ignore next 3 */",
                    "    if (fileDescriptor.notFound) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const hashOfOptions = getHashOfOptions(options);",
                    "    const meta = getMetadataFromFileDescriptor(fileDescriptor);",
                    "    const changed =",
                    "      fileDescriptor.changed || meta.hashOfOptions !== hashOfOptions;",
                    "",
                    "    return !changed;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string} filePath",
                    "   * @param {any} options",
                    "   */",
                    "  setFormatResultsCache(filePath, options) {",
                    "    const fileDescriptor = this.#fileEntryCache.getFileDescriptor(filePath);",
                    "    const meta = getMetadataFromFileDescriptor(fileDescriptor);",
                    "    if (fileDescriptor && !fileDescriptor.notFound) {",
                    "      meta.hashOfOptions = getHashOfOptions(options);",
                    "    }",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {string} filePath",
                    "   */",
                    "  removeFormatResultsCache(filePath) {",
                    "    this.#fileEntryCache.removeEntry(filePath);",
                    "  }",
                    "",
                    "  reconcile() {",
                    "    this.#fileEntryCache.reconcile();",
                    "  }",
                    "}",
                    "",
                    "export default FormatResultsCache;"
                ]
            },
            "format.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "import path from \"node:path\";",
                    "import chalk from \"chalk\";",
                    "import { createTwoFilesPatch } from \"diff\";",
                    "import * as prettier from \"../index.js\";",
                    "import mockable from \"../common/mockable.js\";",
                    "import { createIsIgnoredFunction, errors } from \"./prettier-internal.js\";",
                    "import { expandPatterns } from \"./expand-patterns.js\";",
                    "import getOptionsForFile from \"./options/get-options-for-file.js\";",
                    "import isTTY from \"./is-tty.js\";",
                    "import findCacheFile from \"./find-cache-file.js\";",
                    "import FormatResultsCache from \"./format-results-cache.js\";",
                    "import { statSafe, normalizeToPosix } from \"./utils.js\";",
                    "",
                    "const { getStdin, writeFormattedFile } = mockable;",
                    "",
                    "function diff(a, b) {",
                    "  return createTwoFilesPatch(\"\", \"\", a, b, \"\", \"\", { context: 2 });",
                    "}",
                    "",
                    "class DebugError extends Error {}",
                    "",
                    "function handleError(context, filename, error, printedFilename) {",
                    "  if (error instanceof errors.UndefinedParserError) {",
                    "    // Can't test on CI, `isTTY()` is always false, see ./is-tty.js",
                    "    /* c8 ignore next 3 */",
                    "    if ((context.argv.write || context.argv.ignoreUnknown) && printedFilename) {",
                    "      printedFilename.clear();",
                    "    }",
                    "",
                    "    if (context.argv.ignoreUnknown) {",
                    "      return;",
                    "    }",
                    "    if (!context.argv.check && !context.argv.listDifferent) {",
                    "      process.exitCode = 2;",
                    "    }",
                    "    context.logger.error(error.message);",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.write) {",
                    "    // Add newline to split errors from filename line.",
                    "    process.stdout.write(\"\\n\");",
                    "  }",
                    "",
                    "  const isParseError = Boolean(error?.loc);",
                    "  const isValidationError = /^Invalid \\S+ value\\./.test(error?.message);",
                    "",
                    "  if (isParseError) {",
                    "    // `invalid.js: SyntaxError: Unexpected token (1:1)`.",
                    "    context.logger.error(`${filename}: ${String(error)}`);",
                    "  } else if (isValidationError || error instanceof errors.ConfigError) {",
                    "    // `Invalid printWidth value. Expected an integer, but received 0.5.`",
                    "    context.logger.error(error.message);",
                    "    // If validation fails for one file, it will fail for all of them.",
                    "    process.exit(1);",
                    "  } else if (error instanceof DebugError) {",
                    "    // `invalid.js: Some debug error message`",
                    "    context.logger.error(`${filename}: ${error.message}`);",
                    "  } else {",
                    "    // `invalid.js: Error: Some unexpected error\\n[stack trace]`",
                    "    /* c8 ignore next */",
                    "    context.logger.error(filename + \": \" + (error.stack || error));",
                    "  }",
                    "",
                    "  // Don't exit the process if one file failed",
                    "  process.exitCode = 2;",
                    "}",
                    "",
                    "function writeOutput(context, result, options) {",
                    "  // Don't use `console.log` here since it adds an extra newline at the end.",
                    "  process.stdout.write(",
                    "    context.argv.debugCheck ? result.filepath : result.formatted",
                    "  );",
                    "",
                    "  if (options && options.cursorOffset >= 0) {",
                    "    process.stderr.write(result.cursorOffset + \"\\n\");",
                    "  }",
                    "}",
                    "",
                    "async function listDifferent(context, input, options, filename) {",
                    "  if (!context.argv.check && !context.argv.listDifferent) {",
                    "    return;",
                    "  }",
                    "",
                    "  try {",
                    "    if (!options.filepath && !options.parser) {",
                    "      throw new errors.UndefinedParserError(",
                    "        \"No parser and no file path given, couldn't infer a parser.\"",
                    "      );",
                    "    }",
                    "    if (!(await prettier.check(input, options)) && !context.argv.write) {",
                    "      context.logger.log(filename);",
                    "      process.exitCode = 1;",
                    "    }",
                    "  } catch (error) {",
                    "    context.logger.error(error.message);",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "async function format(context, input, opt) {",
                    "  if (!opt.parser && !opt.filepath) {",
                    "    throw new errors.UndefinedParserError(",
                    "      \"No parser and no file path given, couldn't infer a parser.\"",
                    "    );",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintDoc) {",
                    "    const doc = await prettier.__debug.printToDoc(input, opt);",
                    "    return { formatted: (await prettier.__debug.formatDoc(doc)) + \"\\n\" };",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintComments) {",
                    "    return {",
                    "      formatted: await prettier.format(",
                    "        JSON.stringify(",
                    "          (await prettier.formatWithCursor(input, opt)).comments || []",
                    "        ),",
                    "        { parser: \"json\" }",
                    "      ),",
                    "    };",
                    "  }",
                    "",
                    "  if (context.argv.debugPrintAst) {",
                    "    const { ast } = await prettier.__debug.parse(input, opt);",
                    "    return {",
                    "      formatted: JSON.stringify(ast),",
                    "    };",
                    "  }",
                    "",
                    "  if (context.argv.debugCheck) {",
                    "    const pp = await prettier.format(input, opt);",
                    "    const pppp = await prettier.format(pp, opt);",
                    "    if (pp !== pppp) {",
                    "      throw new DebugError(",
                    "        \"prettier(input) !== prettier(prettier(input))\\n\" + diff(pp, pppp)",
                    "      );",
                    "    } else {",
                    "      const stringify = (obj) => JSON.stringify(obj, null, 2);",
                    "      const ast = stringify(",
                    "        (await prettier.__debug.parse(input, opt, { massage: true })).ast",
                    "      );",
                    "      const past = stringify(",
                    "        (await prettier.__debug.parse(pp, opt, { massage: true })).ast",
                    "      );",
                    "",
                    "      /* c8 ignore start */",
                    "      if (ast !== past) {",
                    "        const MAX_AST_SIZE = 2097152; // 2MB",
                    "        const astDiff =",
                    "          ast.length > MAX_AST_SIZE || past.length > MAX_AST_SIZE",
                    "            ? \"AST diff too large to render\"",
                    "            : diff(ast, past);",
                    "        throw new DebugError(",
                    "          \"ast(input) !== ast(prettier(input))\\n\" +",
                    "            astDiff +",
                    "            \"\\n\" +",
                    "            diff(input, pp)",
                    "        );",
                    "      }",
                    "      /* c8 ignore end */",
                    "    }",
                    "    return { formatted: pp, filepath: opt.filepath || \"(stdin)\\n\" };",
                    "  }",
                    "",
                    "  const { performanceTestFlag } = context;",
                    "  if (performanceTestFlag?.debugBenchmark) {",
                    "    let benchmark;",
                    "    try {",
                    "      // eslint-disable-next-line import/no-extraneous-dependencies",
                    "      ({ default: benchmark } = await import(\"benchmark\"));",
                    "    } catch {",
                    "      context.logger.debug(",
                    "        \"'--debug-benchmark' requires the 'benchmark' package to be installed.\"",
                    "      );",
                    "      process.exit(2);",
                    "    }",
                    "    context.logger.debug(",
                    "      \"'--debug-benchmark' option found, measuring formatWithCursor with 'benchmark' module.\"",
                    "    );",
                    "    const suite = new benchmark.Suite();",
                    "    suite.add(\"format\", {",
                    "      defer: true,",
                    "      async fn(deferred) {",
                    "        await prettier.formatWithCursor(input, opt);",
                    "        deferred.resolve();",
                    "      },",
                    "    });",
                    "    const result = await new Promise((resolve) => {",
                    "      suite",
                    "        .on(\"complete\", (event) => {",
                    "          resolve({",
                    "            benchmark: String(event.target),",
                    "            hz: event.target.hz,",
                    "            ms: event.target.times.cycle * 1000,",
                    "          });",
                    "        })",
                    "        .run({ async: false });",
                    "    });",
                    "    context.logger.debug(",
                    "      \"'--debug-benchmark' measurements for formatWithCursor: \" +",
                    "        JSON.stringify(result, null, 2)",
                    "    );",
                    "  } else if (performanceTestFlag?.debugRepeat) {",
                    "    const repeat = performanceTestFlag.debugRepeat;",
                    "    context.logger.debug(",
                    "      `'${performanceTestFlag.name}' found, running formatWithCursor ${repeat} times.`",
                    "    );",
                    "    let totalMs = 0;",
                    "    for (let i = 0; i < repeat; ++i) {",
                    "      // should be using `performance.now()`, but only `Date` is cross-platform enough",
                    "      const startMs = Date.now();",
                    "      await prettier.formatWithCursor(input, opt);",
                    "      totalMs += Date.now() - startMs;",
                    "    }",
                    "    const averageMs = totalMs / repeat;",
                    "    const results = {",
                    "      repeat,",
                    "      hz: 1000 / averageMs,",
                    "      ms: averageMs,",
                    "    };",
                    "    context.logger.debug(",
                    "      `'${",
                    "        performanceTestFlag.name",
                    "      }' measurements for formatWithCursor: ${JSON.stringify(results, null, 2)}`",
                    "    );",
                    "  }",
                    "",
                    "  return prettier.formatWithCursor(input, opt);",
                    "}",
                    "",
                    "async function createIsIgnoredFromContextOrDie(context) {",
                    "  try {",
                    "    return await createIsIgnoredFunction(",
                    "      context.argv.ignorePath,",
                    "      context.argv.withNodeModules",
                    "    );",
                    "  } catch (e) {",
                    "    context.logger.error(e.message);",
                    "    process.exit(2);",
                    "  }",
                    "}",
                    "",
                    "async function formatStdin(context) {",
                    "  const { filepath } = context.argv;",
                    "",
                    "  try {",
                    "    const input = await getStdin();",
                    "",
                    "    let isFileIgnored = false;",
                    "    if (filepath) {",
                    "      const isIgnored = await createIsIgnoredFromContextOrDie(context);",
                    "      isFileIgnored = isIgnored(filepath);",
                    "    }",
                    "",
                    "    if (isFileIgnored) {",
                    "      writeOutput(context, { formatted: input });",
                    "      return;",
                    "    }",
                    "",
                    "    const options = await getOptionsForFile(",
                    "      context,",
                    "      filepath ? path.resolve(process.cwd(), filepath) : process.cwd()",
                    "    );",
                    "",
                    "    if (await listDifferent(context, input, options, \"(stdin)\")) {",
                    "      return;",
                    "    }",
                    "",
                    "    const formatted = await format(context, input, options);",
                    "",
                    "    const { performanceTestFlag } = context;",
                    "    if (performanceTestFlag) {",
                    "      context.logger.log(",
                    "        `'${performanceTestFlag.name}' option found, skipped print code to screen.`",
                    "      );",
                    "      return;",
                    "    }",
                    "",
                    "    writeOutput(context, formatted, options);",
                    "  } catch (error) {",
                    "    handleError(context, filepath || \"stdin\", error);",
                    "  }",
                    "}",
                    "",
                    "async function formatFiles(context) {",
                    "  // This will be used to filter file paths after the glob is checked,",
                    "  // before any files are actually written",
                    "  const isIgnored = await createIsIgnoredFromContextOrDie(context);",
                    "  const cwd = process.cwd();",
                    "",
                    "  let numberOfUnformattedFilesFound = 0;",
                    "  const { performanceTestFlag } = context;",
                    "",
                    "  if (context.argv.check && !performanceTestFlag) {",
                    "    context.logger.log(\"Checking formatting...\");",
                    "  }",
                    "",
                    "  let formatResultsCache;",
                    "  const cacheFilePath = await findCacheFile(context.argv.cacheLocation);",
                    "  if (context.argv.cache) {",
                    "    formatResultsCache = new FormatResultsCache(",
                    "      cacheFilePath,",
                    "      context.argv.cacheStrategy || \"content\"",
                    "    );",
                    "  } else {",
                    "    if (context.argv.cacheStrategy) {",
                    "      context.logger.error(",
                    "        \"`--cache-strategy` cannot be used without `--cache`.\"",
                    "      );",
                    "      process.exit(2);",
                    "    }",
                    "    if (!context.argv.cacheLocation) {",
                    "      const stat = await statSafe(cacheFilePath);",
                    "      if (stat) {",
                    "        await fs.unlink(cacheFilePath);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  for await (const pathOrError of expandPatterns(context)) {",
                    "    if (typeof pathOrError === \"object\") {",
                    "      context.logger.error(pathOrError.error);",
                    "      // Don't exit, but set the exit code to 2",
                    "      process.exitCode = 2;",
                    "      continue;",
                    "    }",
                    "",
                    "    const filename = pathOrError;",
                    "",
                    "    const isFileIgnored = isIgnored(filename);",
                    "    if (",
                    "      isFileIgnored &&",
                    "      (context.argv.debugCheck ||",
                    "        context.argv.write ||",
                    "        context.argv.check ||",
                    "        context.argv.listDifferent)",
                    "    ) {",
                    "      continue;",
                    "    }",
                    "",
                    "    const options = {",
                    "      ...(await getOptionsForFile(context, filename)),",
                    "      filepath: filename,",
                    "    };",
                    "",
                    "    const fileNameToDisplay = normalizeToPosix(path.relative(cwd, filename));",
                    "    let printedFilename;",
                    "    if (isTTY()) {",
                    "      printedFilename = context.logger.log(fileNameToDisplay, {",
                    "        newline: false,",
                    "        clearable: true,",
                    "      });",
                    "    }",
                    "",
                    "    let input;",
                    "    try {",
                    "      input = await fs.readFile(filename, \"utf8\");",
                    "    } catch (error) {",
                    "      // Add newline to split errors from filename line.",
                    "      /* c8 ignore start */",
                    "      context.logger.log(\"\");",
                    "",
                    "      context.logger.error(",
                    "        `Unable to read file \"${fileNameToDisplay}\":\\n${error.message}`",
                    "      );",
                    "",
                    "      // Don't exit the process if one file failed",
                    "      process.exitCode = 2;",
                    "",
                    "      continue;",
                    "      /* c8 ignore stop */",
                    "    }",
                    "",
                    "    if (isFileIgnored) {",
                    "      writeOutput(context, { formatted: input }, options);",
                    "      continue;",
                    "    }",
                    "",
                    "    const start = Date.now();",
                    "",
                    "    const isCacheExists = formatResultsCache?.existsAvailableFormatResultsCache(",
                    "      filename,",
                    "      options",
                    "    );",
                    "",
                    "    let result;",
                    "    let output;",
                    "",
                    "    try {",
                    "      if (isCacheExists) {",
                    "        result = { formatted: input };",
                    "      } else {",
                    "        result = await format(context, input, options);",
                    "      }",
                    "      output = result.formatted;",
                    "    } catch (error) {",
                    "      handleError(context, fileNameToDisplay, error, printedFilename);",
                    "      continue;",
                    "    }",
                    "",
                    "    const isDifferent = output !== input;",
                    "    let shouldSetCache = !isDifferent;",
                    "",
                    "    if (printedFilename) {",
                    "      // Remove previously printed filename to log it with duration.",
                    "      printedFilename.clear();",
                    "    }",
                    "",
                    "    if (performanceTestFlag) {",
                    "      context.logger.log(",
                    "        `'${performanceTestFlag.name}' option found, skipped print code or write files.`",
                    "      );",
                    "      return;",
                    "    }",
                    "",
                    "    if (context.argv.write) {",
                    "      // Don't write the file if it won't change in order not to invalidate",
                    "      // mtime based caches.",
                    "      if (isDifferent) {",
                    "        if (!context.argv.check && !context.argv.listDifferent) {",
                    "          context.logger.log(`${fileNameToDisplay} ${Date.now() - start}ms`);",
                    "        }",
                    "",
                    "        try {",
                    "          await writeFormattedFile(filename, output);",
                    "",
                    "          // Set cache if format succeeds",
                    "          shouldSetCache = true;",
                    "        } catch (error) {",
                    "          context.logger.error(",
                    "            `Unable to write file \"${fileNameToDisplay}\":\\n${error.message}`",
                    "          );",
                    "",
                    "          // Don't exit the process if one file failed",
                    "          process.exitCode = 2;",
                    "        }",
                    "      } else if (!context.argv.check && !context.argv.listDifferent) {",
                    "        const message = `${chalk.grey(fileNameToDisplay)} ${",
                    "          Date.now() - start",
                    "        }ms`;",
                    "        if (isCacheExists) {",
                    "          context.logger.log(`${message} (cached)`);",
                    "        } else {",
                    "          context.logger.log(message);",
                    "        }",
                    "      }",
                    "    } else if (context.argv.debugCheck) {",
                    "      if (result.filepath) {",
                    "        context.logger.log(fileNameToDisplay);",
                    "      } else {",
                    "        /* c8 ignore next */",
                    "        process.exitCode = 2;",
                    "      }",
                    "    } else if (!context.argv.check && !context.argv.listDifferent) {",
                    "      writeOutput(context, result, options);",
                    "    }",
                    "",
                    "    if (shouldSetCache) {",
                    "      formatResultsCache?.setFormatResultsCache(filename, options);",
                    "    } else {",
                    "      formatResultsCache?.removeFormatResultsCache(filename);",
                    "    }",
                    "",
                    "    if (isDifferent) {",
                    "      if (context.argv.check) {",
                    "        context.logger.warn(fileNameToDisplay);",
                    "      } else if (context.argv.listDifferent) {",
                    "        context.logger.log(fileNameToDisplay);",
                    "      }",
                    "      numberOfUnformattedFilesFound += 1;",
                    "    }",
                    "  }",
                    "",
                    "  formatResultsCache?.reconcile();",
                    "",
                    "  // Print check summary based on expected exit code",
                    "  if (context.argv.check) {",
                    "    if (numberOfUnformattedFilesFound === 0) {",
                    "      context.logger.log(\"All matched files use Prettier code style!\");",
                    "    } else {",
                    "      const files =",
                    "        numberOfUnformattedFilesFound === 1",
                    "          ? \"the above file\"",
                    "          : `${numberOfUnformattedFilesFound} files`;",
                    "      context.logger.warn(",
                    "        context.argv.write",
                    "          ? `Code style issues fixed in ${files}.`",
                    "          : `Code style issues found in ${files}. Run Prettier to fix.`",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  // Ensure non-zero exitCode when using --check/list-different is not combined with --write",
                    "  if (",
                    "    (context.argv.check || context.argv.listDifferent) &&",
                    "    numberOfUnformattedFilesFound > 0 &&",
                    "    !process.exitCode &&",
                    "    !context.argv.write",
                    "  ) {",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "export { formatStdin, formatFiles };"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as prettier from \"../index.js\";",
                    "import createLogger from \"./logger.js\";",
                    "import Context from \"./context.js\";",
                    "import { parseArgvWithoutPlugins } from \"./options/parse-cli-arguments.js\";",
                    "import { createDetailedUsage, createUsage } from \"./usage.js\";",
                    "import { formatStdin, formatFiles } from \"./format.js\";",
                    "import logFileInfoOrDie from \"./file-info.js\";",
                    "import logResolvedConfigPathOrDie from \"./find-config-path.js\";",
                    "import { printToScreen, isNonEmptyArray } from \"./utils.js\";",
                    "import printSupportInfo from \"./print-support-info.js\";",
                    "",
                    "async function run(rawArguments) {",
                    "  // Create a default level logger, so we can log errors during `logLevel` parsing",
                    "  let logger = createLogger();",
                    "",
                    "  try {",
                    "    const { logLevel } = parseArgvWithoutPlugins(",
                    "      rawArguments,",
                    "      logger,",
                    "      \"log-level\"",
                    "    );",
                    "    if (logLevel !== logger.logLevel) {",
                    "      logger = createLogger(logLevel);",
                    "    }",
                    "    const context = new Context({ rawArguments, logger });",
                    "    await context.init();",
                    "    if (logger.logLevel !== \"debug\" && context.performanceTestFlag) {",
                    "      context.logger = createLogger(\"debug\");",
                    "    }",
                    "",
                    "    await main(context);",
                    "  } catch (error) {",
                    "    logger.error(error.message);",
                    "    process.exitCode = 1;",
                    "  }",
                    "}",
                    "",
                    "async function main(context) {",
                    "  context.logger.debug(`normalized argv: ${JSON.stringify(context.argv)}`);",
                    "",
                    "  if (context.argv.pluginSearch === false) {",
                    "    const rawPluginSearchDirs = context.argv.__raw[\"plugin-search-dir\"];",
                    "    if (",
                    "      typeof rawPluginSearchDirs === \"string\" ||",
                    "      isNonEmptyArray(rawPluginSearchDirs)",
                    "    ) {",
                    "      throw new Error(",
                    "        \"Cannot use --no-plugin-search and --plugin-search-dir together.\"",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  if (context.argv.check && context.argv.listDifferent) {",
                    "    throw new Error(\"Cannot use --check and --list-different together.\");",
                    "  }",
                    "",
                    "  if (context.argv.write && context.argv.debugCheck) {",
                    "    throw new Error(\"Cannot use --write and --debug-check together.\");",
                    "  }",
                    "",
                    "  if (context.argv.findConfigPath && context.filePatterns.length > 0) {",
                    "    throw new Error(\"Cannot use --find-config-path with multiple files\");",
                    "  }",
                    "",
                    "  if (context.argv.fileInfo && context.filePatterns.length > 0) {",
                    "    throw new Error(\"Cannot use --file-info with multiple files\");",
                    "  }",
                    "",
                    "  if (context.argv.version) {",
                    "    printToScreen(prettier.version);",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.help !== undefined) {",
                    "    printToScreen(",
                    "      typeof context.argv.help === \"string\" && context.argv.help !== \"\"",
                    "        ? createDetailedUsage(context, context.argv.help)",
                    "        : createUsage(context)",
                    "    );",
                    "    return;",
                    "  }",
                    "",
                    "  if (context.argv.supportInfo) {",
                    "    return printSupportInfo();",
                    "  }",
                    "",
                    "  const hasFilePatterns = context.filePatterns.length > 0;",
                    "  const useStdin =",
                    "    !hasFilePatterns && (!process.stdin.isTTY || context.argv.filePath);",
                    "",
                    "  if (context.argv.findConfigPath) {",
                    "    await logResolvedConfigPathOrDie(context);",
                    "  } else if (context.argv.fileInfo) {",
                    "    await logFileInfoOrDie(context);",
                    "  } else if (useStdin) {",
                    "    if (context.argv.cache) {",
                    "      context.logger.error(\"`--cache` cannot be used with stdin.\");",
                    "      process.exit(2);",
                    "    }",
                    "    await formatStdin(context);",
                    "  } else if (hasFilePatterns) {",
                    "    await formatFiles(context);",
                    "  } else {",
                    "    process.exitCode = 1;",
                    "    printToScreen(createUsage(context));",
                    "  }",
                    "}",
                    "",
                    "export { run };"
                ]
            },
            "is-tty.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import mockable from \"../common/mockable.js\";",
                    "",
                    "// Some CI pipelines incorrectly report process.stdout.isTTY status,",
                    "// which causes unwanted lines in the output. An additional check for isCI() helps.",
                    "// See https://github.com/prettier/prettier/issues/5801",
                    "export default function isTTY() {",
                    "  return process.stdout.isTTY && !mockable.isCI();",
                    "}"
                ]
            },
            "logger.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import readline from \"node:readline\";",
                    "import chalk, { chalkStderr } from \"chalk\";",
                    "import stripAnsi from \"strip-ansi\";",
                    "import wcwidth from \"wcwidth\";",
                    "",
                    "const countLines = (stream, text) => {",
                    "  const columns = stream.columns || 80;",
                    "  let lineCount = 0;",
                    "  for (const line of stripAnsi(text).split(\"\\n\")) {",
                    "    lineCount += Math.max(1, Math.ceil(wcwidth(line) / columns));",
                    "  }",
                    "  return lineCount;",
                    "};",
                    "",
                    "const clear = (stream, text) => () => {",
                    "  const lineCount = countLines(stream, text);",
                    "",
                    "  for (let line = 0; line < lineCount; line++) {",
                    "    /* c8 ignore next 3 */",
                    "    if (line > 0) {",
                    "      readline.moveCursor(stream, 0, -1);",
                    "    }",
                    "",
                    "    readline.clearLine(stream, 0);",
                    "    readline.cursorTo(stream, 0);",
                    "  }",
                    "};",
                    "",
                    "const emptyLogResult = { clear() {} };",
                    "function createLogger(logLevel = \"log\") {",
                    "  return {",
                    "    logLevel,",
                    "    warn: createLogFunc(\"warn\", \"yellow\"),",
                    "    error: createLogFunc(\"error\", \"red\"),",
                    "    debug: createLogFunc(\"debug\", \"blue\"),",
                    "    log: createLogFunc(\"log\"),",
                    "  };",
                    "",
                    "  function createLogFunc(loggerName, color) {",
                    "    if (!shouldLog(loggerName)) {",
                    "      return () => emptyLogResult;",
                    "    }",
                    "",
                    "    const stream = process[loggerName === \"log\" ? \"stdout\" : \"stderr\"];",
                    "    const chalkInstance = loggerName === \"log\" ? chalk : chalkStderr;",
                    "    const prefix = color ? `[${chalkInstance[color](loggerName)}] ` : \"\";",
                    "",
                    "    return (message, options) => {",
                    "      options = {",
                    "        newline: true,",
                    "        clearable: false,",
                    "        ...options,",
                    "      };",
                    "      message =",
                    "        message.replaceAll(/^/gm, prefix) + (options.newline ? \"\\n\" : \"\");",
                    "      stream.write(message);",
                    "",
                    "      if (options.clearable) {",
                    "        return {",
                    "          clear: clear(stream, message),",
                    "        };",
                    "      }",
                    "    };",
                    "  }",
                    "",
                    "  function shouldLog(loggerName) {",
                    "    switch (logLevel) {",
                    "      case \"silent\":",
                    "        return false;",
                    "      case \"debug\":",
                    "        if (loggerName === \"debug\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"log\":",
                    "        if (loggerName === \"log\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"warn\":",
                    "        if (loggerName === \"warn\") {",
                    "          return true;",
                    "        }",
                    "      // fall through",
                    "      case \"error\":",
                    "        return loggerName === \"error\";",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "export default createLogger;"
                ]
            },
            "prettier-internal.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// @ts-expect-error",
                    "import { __internal as sharedWithCli } from \"../index.js\";",
                    "",
                    "export const {",
                    "  errors,",
                    "  optionCategories,",
                    "  createIsIgnoredFunction,",
                    "  formatOptionsHiddenDefaults,",
                    "  normalizeOptions,",
                    "  getSupportInfoWithoutPlugins,",
                    "  normalizeOptionSettings,",
                    "  vnopts,",
                    "  fastGlob,",
                    "} = sharedWithCli;"
                ]
            },
            "print-support-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import stringify from \"fast-json-stable-stringify\";",
                    "import { getSupportInfo, format } from \"../index.js\";",
                    "import { printToScreen, omit } from \"./utils.js\";",
                    "",
                    "const sortByName = (array) =>",
                    "  array.sort((a, b) => a.name.localeCompare(b.name));",
                    "",
                    "async function printSupportInfo() {",
                    "  const { languages, options } = await getSupportInfo();",
                    "  const supportInfo = {",
                    "    languages: sortByName(languages),",
                    "    options: sortByName(options).map((option) =>",
                    "      omit(option, [\"cliName\", \"cliCategory\", \"cliDescription\"])",
                    "    ),",
                    "  };",
                    "",
                    "  printToScreen(await format(stringify(supportInfo), { parser: \"json\" }));",
                    "}",
                    "",
                    "export default printSupportInfo;"
                ]
            },
            "usage.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import camelCase from \"camelcase\";",
                    "import { categoryOrder, usageSummary } from \"./constants.evaluate.js\";",
                    "import { groupBy } from \"./utils.js\";",
                    "import { formatOptionsHiddenDefaults } from \"./prettier-internal.js\";",
                    "",
                    "const OPTION_USAGE_THRESHOLD = 25;",
                    "const CHOICE_USAGE_MARGIN = 3;",
                    "const CHOICE_USAGE_INDENTATION = 2;",
                    "",
                    "function indent(str, spaces) {",
                    "  return str.replaceAll(/^/gm, \" \".repeat(spaces));",
                    "}",
                    "",
                    "function createDefaultValueDisplay(value) {",
                    "  return Array.isArray(value)",
                    "    ? `[${value.map(createDefaultValueDisplay).join(\", \")}]`",
                    "    : value;",
                    "}",
                    "",
                    "function getOptionDefaultValue(context, optionName) {",
                    "  // --no-option",
                    "  const option = context.detailedOptions.find(",
                    "    ({ name }) => name === optionName",
                    "  );",
                    "",
                    "  if (option?.default !== undefined) {",
                    "    return option.default;",
                    "  }",
                    "",
                    "  const optionCamelName = camelCase(optionName);",
                    "  return (",
                    "    formatOptionsHiddenDefaults[optionCamelName] ??",
                    "    context.supportOptions.find(",
                    "      (option) => !option.deprecated && option.name === optionCamelName",
                    "    )?.default",
                    "  );",
                    "}",
                    "",
                    "function createOptionUsageHeader(option) {",
                    "  const name = `--${option.name}`;",
                    "  const alias = option.alias ? `-${option.alias},` : null;",
                    "  const type = createOptionUsageType(option);",
                    "  return [alias, name, type].filter(Boolean).join(\" \");",
                    "}",
                    "",
                    "function createOptionUsageRow(header, content, threshold) {",
                    "  const separator =",
                    "    header.length >= threshold",
                    "      ? `\\n${\" \".repeat(threshold)}`",
                    "      : \" \".repeat(threshold - header.length);",
                    "",
                    "  const description = content.replaceAll(\"\\n\", `\\n${\" \".repeat(threshold)}`);",
                    "",
                    "  return `${header}${separator}${description}`;",
                    "}",
                    "",
                    "function createOptionUsageType(option) {",
                    "  switch (option.type) {",
                    "    case \"boolean\":",
                    "      return null;",
                    "    case \"choice\":",
                    "      return `<${option.choices",
                    "        .filter((choice) => !choice.deprecated)",
                    "        .map((choice) => choice.value)",
                    "        .join(\"|\")}>`;",
                    "    default:",
                    "      return `<${option.type}>`;",
                    "  }",
                    "}",
                    "",
                    "function createChoiceUsages(choices, margin, indentation) {",
                    "  const activeChoices = choices.filter((choice) => !choice.deprecated);",
                    "  const threshold =",
                    "    Math.max(0, ...activeChoices.map((choice) => choice.value.length)) + margin;",
                    "  return activeChoices.map((choice) =>",
                    "    indent(",
                    "      createOptionUsageRow(choice.value, choice.description, threshold),",
                    "      indentation",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "function createOptionUsage(context, option, threshold) {",
                    "  const header = createOptionUsageHeader(option);",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  return createOptionUsageRow(",
                    "    header,",
                    "    `${option.description}${",
                    "      optionDefaultValue === undefined",
                    "        ? \"\"",
                    "        : `\\nDefaults to ${createDefaultValueDisplay(optionDefaultValue)}.`",
                    "    }`,",
                    "    threshold",
                    "  );",
                    "}",
                    "",
                    "function getOptionsWithOpposites(options) {",
                    "  // Add --no-foo after --foo.",
                    "  const optionsWithOpposites = options.map((option) => [",
                    "    option.description ? option : null,",
                    "    option.oppositeDescription",
                    "      ? {",
                    "          ...option,",
                    "          name: `no-${option.name}`,",
                    "          type: \"boolean\",",
                    "          description: option.oppositeDescription,",
                    "        }",
                    "      : null,",
                    "  ]);",
                    "  return optionsWithOpposites.flat().filter(Boolean);",
                    "}",
                    "",
                    "function createUsage(context) {",
                    "  const sortedOptions = context.detailedOptions.sort((optionA, optionB) =>",
                    "    optionA.name.localeCompare(optionB.name)",
                    "  );",
                    "",
                    "  const options = getOptionsWithOpposites(sortedOptions).filter(",
                    "    // remove unnecessary option (e.g. `semi`, `color`, etc.), which is only used for --help <flag>",
                    "    (option) =>",
                    "      !(",
                    "        option.type === \"boolean\" &&",
                    "        option.oppositeDescription &&",
                    "        !option.name.startsWith(\"no-\")",
                    "      )",
                    "  );",
                    "  const groupedOptions = groupBy(options, (option) => option.category);",
                    "",
                    "  const firstCategories = categoryOrder.slice(0, -1);",
                    "  const lastCategories = categoryOrder.slice(-1);",
                    "  const restCategories = Object.keys(groupedOptions).filter(",
                    "    (category) => !categoryOrder.includes(category)",
                    "  );",
                    "  const allCategories = [",
                    "    ...firstCategories,",
                    "    ...restCategories,",
                    "    ...lastCategories,",
                    "  ];",
                    "",
                    "  const optionsUsage = allCategories.map((category) => {",
                    "    const categoryOptions = groupedOptions[category]",
                    "      .map((option) =>",
                    "        createOptionUsage(context, option, OPTION_USAGE_THRESHOLD)",
                    "      )",
                    "      .join(\"\\n\");",
                    "    return `${category} options:\\n\\n${indent(categoryOptions, 2)}`;",
                    "  });",
                    "",
                    "  return [usageSummary, ...optionsUsage, \"\"].join(\"\\n\\n\");",
                    "}",
                    "",
                    "function createPluginDefaults(pluginDefaults) {",
                    "  if (!pluginDefaults || Object.keys(pluginDefaults).length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const defaults = Object.entries(pluginDefaults)",
                    "    .sort(([pluginNameA], [pluginNameB]) =>",
                    "      pluginNameA.localeCompare(pluginNameB)",
                    "    )",
                    "    .map(",
                    "      ([plugin, value]) => `* ${plugin}: ${createDefaultValueDisplay(value)}`",
                    "    )",
                    "    .join(\"\\n\");",
                    "",
                    "  return `\\nPlugin defaults:\\n${defaults}`;",
                    "}",
                    "",
                    "function createDetailedUsage(context, flag) {",
                    "  const option = getOptionsWithOpposites(context.detailedOptions).find(",
                    "    (option) => option.name === flag || option.alias === flag",
                    "  );",
                    "",
                    "  const header = createOptionUsageHeader(option);",
                    "  const description = `\\n\\n${indent(option.description, 2)}`;",
                    "",
                    "  const choices =",
                    "    option.type !== \"choice\"",
                    "      ? \"\"",
                    "      : `\\n\\nValid options:\\n\\n${createChoiceUsages(",
                    "          option.choices,",
                    "          CHOICE_USAGE_MARGIN,",
                    "          CHOICE_USAGE_INDENTATION",
                    "        ).join(\"\\n\")}`;",
                    "",
                    "  const optionDefaultValue = getOptionDefaultValue(context, option.name);",
                    "  const defaults =",
                    "    optionDefaultValue !== undefined",
                    "      ? `\\n\\nDefault: ${createDefaultValueDisplay(optionDefaultValue)}`",
                    "      : \"\";",
                    "",
                    "  const pluginDefaults = createPluginDefaults(option.pluginDefaults);",
                    "  return `${header}${description}${choices}${defaults}${pluginDefaults}`;",
                    "}",
                    "",
                    "export { createUsage, createDetailedUsage };"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "import path from \"node:path\";",
                    "import sdbm from \"sdbm\";",
                    "// @ts-expect-error",
                    "import { __internal as sharedWithCli } from \"../index.js\";",
                    "",
                    "// eslint-disable-next-line no-console",
                    "const printToScreen = console.log.bind(console);",
                    "",
                    "/**",
                    " * @template Obj",
                    " * @template Key",
                    " * @param {Array<Obj>} array",
                    " * @param {(value: Obj) => Key} iteratee",
                    " * @returns {{[p in Key]: T}}",
                    " */",
                    "function groupBy(array, iteratee) {",
                    "  const result = Object.create(null);",
                    "",
                    "  for (const value of array) {",
                    "    const key = iteratee(value);",
                    "",
                    "    if (Array.isArray(result[key])) {",
                    "      result[key].push(value);",
                    "    } else {",
                    "      result[key] = [value];",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "/**",
                    " * @template Obj",
                    " * @template {keyof Obj} Keys",
                    " * @param {Obj} object",
                    " * @param {Array<Keys>} keys",
                    " * @returns {{[key in Keys]: Obj[key]}}",
                    " */",
                    "function pick(object, keys) {",
                    "  const entries = keys.map((key) => [key, object[key]]);",
                    "  return Object.fromEntries(entries);",
                    "}",
                    "",
                    "/**",
                    " * @param {string} source",
                    " * @returns {string}",
                    " */",
                    "function createHash(source) {",
                    "  return String(sdbm(source));",
                    "}",
                    "",
                    "/**",
                    " * Get stats of a given path.",
                    " * @param {string} filePath The path to target file.",
                    " * @returns {Promise<import('fs').Stats | undefined>} The stats.",
                    " */",
                    "async function statSafe(filePath) {",
                    "  try {",
                    "    return await fs.stat(filePath);",
                    "  } catch (error) {",
                    "    /* c8 ignore next 3 */",
                    "    if (error.code !== \"ENOENT\") {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @returns {boolean}",
                    " */",
                    "function isJson(value) {",
                    "  try {",
                    "    JSON.parse(value);",
                    "    return true;",
                    "  } catch {",
                    "    return false;",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * Replace `\\` with `/` on Windows",
                    " * @param {string} filepath",
                    " * @returns {string}",
                    " */",
                    "const normalizeToPosix =",
                    "  path.sep === \"\\\\\"",
                    "    ? (filepath) => filepath.replaceAll(\"\\\\\", \"/\")",
                    "    : (filepath) => filepath;",
                    "",
                    "export const { isNonEmptyArray, partition, omit } = sharedWithCli.utils;",
                    "export {",
                    "  printToScreen,",
                    "  groupBy,",
                    "  pick,",
                    "  createHash,",
                    "  statSafe,",
                    "  isJson,",
                    "  normalizeToPosix,",
                    "};"
                ]
            },
            "options": {
                "create-minimist-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "export default function createMinimistOptions(detailedOptions) {",
                        "  const booleanNames = [];",
                        "  const stringNames = [];",
                        "  const defaultValues = {};",
                        "",
                        "  for (const option of detailedOptions) {",
                        "    const { name, alias, type } = option;",
                        "    const names = type === \"boolean\" ? booleanNames : stringNames;",
                        "    names.push(name);",
                        "    if (alias) {",
                        "      names.push(alias);",
                        "    }",
                        "",
                        "    if (",
                        "      !option.deprecated &&",
                        "      (!option.forwardToApi ||",
                        "        name === \"plugin\" ||",
                        "        name === \"plugin-search-dir\") &&",
                        "      option.default !== undefined",
                        "    ) {",
                        "      defaultValues[option.name] = option.default;",
                        "    }",
                        "  }",
                        "",
                        "  return {",
                        "    // we use vnopts' AliasSchema to handle aliases for better error messages",
                        "    alias: {},",
                        "    boolean: booleanNames,",
                        "    string: stringNames,",
                        "    default: defaultValues,",
                        "  };",
                        "}"
                    ]
                },
                "get-context-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import dashify from \"dashify\";",
                        "import { getSupportInfo } from \"../../index.js\";",
                        "import {",
                        "  optionCategories,",
                        "  getSupportInfoWithoutPlugins,",
                        "  normalizeOptionSettings,",
                        "} from \"../prettier-internal.js\";",
                        "import cliOptions from \"../cli-options.evaluate.js\";",
                        "",
                        "const detailedCliOptions = normalizeOptionSettings(cliOptions).map((option) =>",
                        "  normalizeDetailedOption(option)",
                        ");",
                        "",
                        "function apiOptionToCliOption(apiOption) {",
                        "  const cliOption = {",
                        "    ...apiOption,",
                        "    description: apiOption.cliDescription ?? apiOption.description,",
                        "    category: apiOption.cliCategory ?? optionCategories.CATEGORY_FORMAT,",
                        "    forwardToApi: apiOption.name,",
                        "  };",
                        "",
                        "  /* c8 ignore start */",
                        "  if (apiOption.deprecated) {",
                        "    delete cliOption.forwardToApi;",
                        "    delete cliOption.description;",
                        "    delete cliOption.oppositeDescription;",
                        "    cliOption.deprecated = true;",
                        "  }",
                        "  /* c8 ignore stop */",
                        "",
                        "  return normalizeDetailedOption(cliOption);",
                        "}",
                        "",
                        "function normalizeDetailedOption(option) {",
                        "  return {",
                        "    category: optionCategories.CATEGORY_OTHER,",
                        "    ...option,",
                        "    name: option.cliName ?? dashify(option.name),",
                        "    choices: option.choices?.map((choice) => {",
                        "      const newChoice = {",
                        "        description: \"\",",
                        "        deprecated: false,",
                        "        ...(typeof choice === \"object\" ? choice : { value: choice }),",
                        "      };",
                        "      /* c8 ignore next 3 */",
                        "      if (newChoice.value === true) {",
                        "        newChoice.value = \"\"; // backward compatibility for original boolean option",
                        "      }",
                        "      return newChoice;",
                        "    }),",
                        "  };",
                        "}",
                        "",
                        "function supportInfoToContextOptions({ options: supportOptions, languages }) {",
                        "  const detailedOptions = [",
                        "    ...detailedCliOptions,",
                        "    ...supportOptions.map((apiOption) => apiOptionToCliOption(apiOption)),",
                        "  ];",
                        "",
                        "  return {",
                        "    supportOptions,",
                        "    languages,",
                        "    detailedOptions,",
                        "  };",
                        "}",
                        "",
                        "async function getContextOptions(plugins, pluginSearchDirs) {",
                        "  const supportInfo = await getSupportInfo({",
                        "    showDeprecated: true,",
                        "    plugins,",
                        "    pluginSearchDirs,",
                        "  });",
                        "",
                        "  return supportInfoToContextOptions(supportInfo);",
                        "}",
                        "",
                        "function getContextOptionsWithoutPlugins() {",
                        "  const supportInfo = getSupportInfoWithoutPlugins();",
                        "  return supportInfoToContextOptions(supportInfo);",
                        "}",
                        "",
                        "export { getContextOptions, getContextOptionsWithoutPlugins };"
                    ]
                },
                "get-options-for-file.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import dashify from \"dashify\";",
                        "import { resolveConfig } from \"../../index.js\";",
                        "import { normalizeOptions as normalizeApiOptions } from \"../prettier-internal.js\";",
                        "import minimist from \"./minimist.js\";",
                        "import createMinimistOptions from \"./create-minimist-options.js\";",
                        "import normalizeCliOptions from \"./normalize-cli-options.js\";",
                        "",
                        "function getOptions(argv, detailedOptions) {",
                        "  return Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(({ forwardToApi }) => forwardToApi)",
                        "      .map(({ forwardToApi, name }) => [forwardToApi, argv[name]])",
                        "  );",
                        "}",
                        "",
                        "function cliifyOptions(object, apiDetailedOptionMap) {",
                        "  return Object.fromEntries(",
                        "    Object.entries(object || {}).map(([key, value]) => {",
                        "      const apiOption = apiDetailedOptionMap[key];",
                        "      const cliKey = apiOption ? apiOption.name : key;",
                        "",
                        "      return [dashify(cliKey), value];",
                        "    })",
                        "  );",
                        "}",
                        "",
                        "function createApiDetailedOptionMap(detailedOptions) {",
                        "  return Object.fromEntries(",
                        "    detailedOptions",
                        "      .filter(",
                        "        (option) => option.forwardToApi && option.forwardToApi !== option.name",
                        "      )",
                        "      .map((option) => [option.forwardToApi, option])",
                        "  );",
                        "}",
                        "",
                        "function parseArgsToOptions(context, overrideDefaults) {",
                        "  const minimistOptions = createMinimistOptions(context.detailedOptions);",
                        "  const apiDetailedOptionMap = createApiDetailedOptionMap(",
                        "    context.detailedOptions",
                        "  );",
                        "  return getOptions(",
                        "    normalizeCliOptions(",
                        "      minimist(context.rawArguments, {",
                        "        string: minimistOptions.string,",
                        "        boolean: minimistOptions.boolean,",
                        "        default: cliifyOptions(overrideDefaults, apiDetailedOptionMap),",
                        "      }),",
                        "      context.detailedOptions,",
                        "      { logger: false }",
                        "    ),",
                        "    context.detailedOptions",
                        "  );",
                        "}",
                        "",
                        "async function getOptionsOrDie(context, filePath) {",
                        "  try {",
                        "    if (context.argv.config === false) {",
                        "      context.logger.debug(",
                        "        \"'--no-config' option found, skip loading config file.\"",
                        "      );",
                        "      return null;",
                        "    }",
                        "",
                        "    context.logger.debug(",
                        "      context.argv.config",
                        "        ? `load config file from '${context.argv.config}'`",
                        "        : `resolve config from '${filePath}'`",
                        "    );",
                        "",
                        "    const options = await resolveConfig(filePath, {",
                        "      editorconfig: context.argv.editorconfig,",
                        "      config: context.argv.config,",
                        "    });",
                        "",
                        "    context.logger.debug(\"loaded options `\" + JSON.stringify(options) + \"`\");",
                        "    return options;",
                        "  } catch (error) {",
                        "    context.logger.error(",
                        "      `Invalid configuration for file \"${filePath}\":\\n` + error.message",
                        "    );",
                        "    process.exit(2);",
                        "  }",
                        "}",
                        "",
                        "function applyConfigPrecedence(context, options) {",
                        "  try {",
                        "    switch (context.argv.configPrecedence) {",
                        "      case \"cli-override\":",
                        "        return parseArgsToOptions(context, options);",
                        "      case \"file-override\":",
                        "        return { ...parseArgsToOptions(context), ...options };",
                        "      case \"prefer-file\":",
                        "        return options || parseArgsToOptions(context);",
                        "    }",
                        "  } catch (error) {",
                        "    /* c8 ignore start */",
                        "    context.logger.error(error.toString());",
                        "    process.exit(2);",
                        "    /* c8 ignore stop */",
                        "  }",
                        "}",
                        "",
                        "async function getOptionsForFile(context, filepath) {",
                        "  const options = await getOptionsOrDie(context, filepath);",
                        "",
                        "  const hasPlugins = options?.plugins;",
                        "  if (hasPlugins) {",
                        "    await context.pushContextPlugins(options.plugins);",
                        "  }",
                        "",
                        "  const appliedOptions = {",
                        "    filepath,",
                        "    ...applyConfigPrecedence(",
                        "      context,",
                        "      options &&",
                        "        normalizeApiOptions(options, context.supportOptions, {",
                        "          logger: context.logger,",
                        "        })",
                        "    ),",
                        "  };",
                        "",
                        "  context.logger.debug(",
                        "    `applied config-precedence (${context.argv.configPrecedence}): ` +",
                        "      `${JSON.stringify(appliedOptions)}`",
                        "  );",
                        "",
                        "  if (hasPlugins) {",
                        "    context.popContextPlugins();",
                        "  }",
                        "",
                        "  return appliedOptions;",
                        "}",
                        "",
                        "export default getOptionsForFile;"
                    ]
                },
                "minimist.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import minimist from \"minimist\";",
                        "",
                        "const PLACEHOLDER = null;",
                        "",
                        "/**",
                        " * unspecified boolean flag without default value is parsed as `undefined` instead of `false`",
                        " */",
                        "export default function minimistParse(args, options) {",
                        "  /* c8 ignore next */",
                        "  const boolean = options.boolean ?? [];",
                        "  /* c8 ignore next */",
                        "  const defaults = options.default ?? {};",
                        "",
                        "  const booleanWithoutDefault = boolean.filter((key) => !(key in defaults));",
                        "  const newDefaults = {",
                        "    ...defaults,",
                        "    ...Object.fromEntries(",
                        "      booleanWithoutDefault.map((key) => [key, PLACEHOLDER])",
                        "    ),",
                        "  };",
                        "",
                        "  const parsed = minimist(args, { ...options, default: newDefaults });",
                        "",
                        "  return Object.fromEntries(",
                        "    Object.entries(parsed).filter(([, value]) => value !== PLACEHOLDER)",
                        "  );",
                        "}"
                    ]
                },
                "normalize-cli-options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import chalk from \"chalk\";",
                        "import leven from \"leven\";",
                        "import { normalizeOptions, vnopts } from \"../prettier-internal.js\";",
                        "",
                        "const descriptor = {",
                        "  key: (key) => (key.length === 1 ? `-${key}` : `--${key}`),",
                        "  value: (value) => vnopts.apiDescriptor.value(value),",
                        "  pair: ({ key, value }) =>",
                        "    value === false",
                        "      ? `--no-${key}`",
                        "      : value === true",
                        "      ? descriptor.key(key)",
                        "      : value === \"\"",
                        "      ? `${descriptor.key(key)} without an argument`",
                        "      : `${descriptor.key(key)}=${value}`,",
                        "};",
                        "",
                        "class FlagSchema extends vnopts.ChoiceSchema {",
                        "  #flags = [];",
                        "",
                        "  constructor({ name, flags }) {",
                        "    super({ name, choices: flags });",
                        "    this.#flags = [...flags].sort();",
                        "  }",
                        "  preprocess(value, utils) {",
                        "    if (",
                        "      typeof value === \"string\" &&",
                        "      value.length > 0 &&",
                        "      !this.#flags.includes(value)",
                        "    ) {",
                        "      const suggestion = this.#flags.find((flag) => leven(flag, value) < 3);",
                        "      if (suggestion) {",
                        "        utils.logger.warn(",
                        "          [",
                        "            `Unknown flag ${chalk.yellow(utils.descriptor.value(value))},`,",
                        "            `did you mean ${chalk.blue(utils.descriptor.value(suggestion))}?`,",
                        "          ].join(\" \")",
                        "        );",
                        "        return suggestion;",
                        "      }",
                        "    }",
                        "    return value;",
                        "  }",
                        "  expected() {",
                        "    return \"a flag\";",
                        "  }",
                        "}",
                        "",
                        "function normalizeCliOptions(options, optionInfos, opts) {",
                        "  return normalizeOptions(options, optionInfos, {",
                        "    ...opts,",
                        "    isCLI: true,",
                        "    FlagSchema,",
                        "    descriptor,",
                        "  });",
                        "}",
                        "",
                        "export default normalizeCliOptions;"
                    ]
                },
                "parse-cli-arguments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import camelCase from \"camelcase\";",
                        "import { pick } from \"../utils.js\";",
                        "import { getContextOptionsWithoutPlugins } from \"./get-context-options.js\";",
                        "import minimist from \"./minimist.js\";",
                        "import createMinimistOptions from \"./create-minimist-options.js\";",
                        "import normalizeCliOptions from \"./normalize-cli-options.js\";",
                        "",
                        "function parseArgv(rawArguments, detailedOptions, logger, keys) {",
                        "  const minimistOptions = createMinimistOptions(detailedOptions);",
                        "  let argv = minimist(rawArguments, minimistOptions);",
                        "",
                        "  if (keys) {",
                        "    if (keys.includes(\"plugin-search-dir\") && !keys.includes(\"plugin-search\")) {",
                        "      keys.push(\"plugin-search\");",
                        "    }",
                        "",
                        "    detailedOptions = detailedOptions.filter((option) =>",
                        "      keys.includes(option.name)",
                        "    );",
                        "    argv = pick(argv, keys);",
                        "  }",
                        "",
                        "  const normalized = normalizeCliOptions(argv, detailedOptions, { logger });",
                        "",
                        "  return {",
                        "    ...Object.fromEntries(",
                        "      Object.entries(normalized).map(([key, value]) => {",
                        "        const option = detailedOptions.find(({ name }) => name === key) || {};",
                        "        // If the flag is a prettier option, use the option name",
                        "        // `--plugin-search-dir` -> `pluginSearchDirs`",
                        "        // Otherwise use camel case for readability",
                        "        // `--ignore-unknown` -> `ignoreUnknown`",
                        "        return [option.forwardToApi || camelCase(key), value];",
                        "      })",
                        "    ),",
                        "    _: normalized._?.map(String),",
                        "    get __raw() {",
                        "      return argv;",
                        "    },",
                        "  };",
                        "}",
                        "",
                        "const { detailedOptions: detailedOptionsWithoutPlugins } =",
                        "  getContextOptionsWithoutPlugins();",
                        "function parseArgvWithoutPlugins(rawArguments, logger, keys) {",
                        "  return parseArgv(",
                        "    rawArguments,",
                        "    detailedOptionsWithoutPlugins,",
                        "    logger,",
                        "    typeof keys === \"string\" ? [keys] : keys",
                        "  );",
                        "}",
                        "",
                        "export { parseArgv, parseArgvWithoutPlugins };"
                    ]
                }
            }
        },
        "common": {
            "ast-path.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "class AstPath {",
                    "  constructor(value) {",
                    "    this.stack = [value];",
                    "  }",
                    "",
                    "  /** @type {string | null} */",
                    "  get key() {",
                    "    const { stack, siblings } = this;",
                    "    return stack.at(siblings === null ? -2 : -4) ?? null;",
                    "  }",
                    "",
                    "  /** @type {number | null} */",
                    "  get index() {",
                    "    return this.siblings === null ? null : this.stack.at(-2);",
                    "  }",
                    "",
                    "  /** @type {object} */",
                    "  get node() {",
                    "    return this.stack.at(-1);",
                    "  }",
                    "",
                    "  /** @type {object | null} */",
                    "  get parent() {",
                    "    return this.getNode(1);",
                    "  }",
                    "",
                    "  /** @type {object | null} */",
                    "  get grandparent() {",
                    "    return this.getNode(2);",
                    "  }",
                    "",
                    "  /** @type {boolean} */",
                    "  get isInArray() {",
                    "    return this.siblings !== null;",
                    "  }",
                    "",
                    "  /** @type {object[] | null} */",
                    "  get siblings() {",
                    "    const { stack } = this;",
                    "    const maybeArray = stack.at(-3);",
                    "    return Array.isArray(maybeArray) ? maybeArray : null;",
                    "  }",
                    "",
                    "  /** @type {object | null} */",
                    "  get next() {",
                    "    const { siblings } = this;",
                    "    return siblings === null ? null : siblings[this.index + 1];",
                    "  }",
                    "",
                    "  /** @type {object | null} */",
                    "  get previous() {",
                    "    const { siblings } = this;",
                    "    return siblings === null ? null : siblings[this.index - 1];",
                    "  }",
                    "",
                    "  /** @type {boolean} */",
                    "  get isFirst() {",
                    "    return this.index === 0;",
                    "  }",
                    "",
                    "  /** @type {boolean} */",
                    "  get isLast() {",
                    "    const { siblings, index } = this;",
                    "    return siblings !== null && index === siblings.length - 1;",
                    "  }",
                    "",
                    "  /** @type {boolean} */",
                    "  get isRoot() {",
                    "    return this.stack.length === 1;",
                    "  }",
                    "",
                    "  /** @type {object} */",
                    "  get root() {",
                    "    return this.stack[0];",
                    "  }",
                    "",
                    "  /** @type {object[]} */",
                    "  get ancestors() {",
                    "    return [...this.#getAncestors()];",
                    "  }",
                    "",
                    "  // The name of the current property is always the penultimate element of",
                    "  // this.stack, and always a string/number/symbol.",
                    "  getName() {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    if (length > 1) {",
                    "      return stack.at(-2);",
                    "    }",
                    "    // Since the name is a string/number/symbol, null is a safe sentinel value",
                    "    // to return if we do not know the name of the (root) value.",
                    "    /* c8 ignore next */",
                    "    return null;",
                    "  }",
                    "",
                    "  // The value of the current property is always the final element of",
                    "  // this.stack.",
                    "  getValue() {",
                    "    return this.stack.at(-1);",
                    "  }",
                    "",
                    "  getNode(count = 0) {",
                    "    const stackIndex = this.#getNodeStackIndex(count);",
                    "    return stackIndex === -1 ? null : this.stack[stackIndex];",
                    "  }",
                    "",
                    "  getParentNode(count = 0) {",
                    "    return this.getNode(count + 1);",
                    "  }",
                    "",
                    "  #getNodeStackIndex(count) {",
                    "    const { stack } = this;",
                    "    for (let i = stack.length - 1; i >= 0; i -= 2) {",
                    "      if (!Array.isArray(stack[i]) && --count < 0) {",
                    "        return i;",
                    "      }",
                    "    }",
                    "    return -1;",
                    "  }",
                    "",
                    "  // Temporarily push properties named by string arguments given after the",
                    "  // callback function onto this.stack, then call the callback with a",
                    "  // reference to this (modified) AstPath object. Note that the stack will",
                    "  // be restored to its original state after the callback is finished, so it",
                    "  // is probably a mistake to retain a reference to the path.",
                    "  call(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = stack.at(-1);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "    try {",
                    "      return callback(this);",
                    "    } finally {",
                    "      stack.length = length;",
                    "    }",
                    "  }",
                    "",
                    "  callParent(callback, count = 0) {",
                    "    const stackIndex = this.#getNodeStackIndex(count + 1);",
                    "    const parentValues = this.stack.splice(stackIndex + 1);",
                    "    try {",
                    "      return callback(this);",
                    "    } finally {",
                    "      this.stack.push(...parentValues);",
                    "    }",
                    "  }",
                    "",
                    "  // Similar to AstPath.prototype.call, except that the value obtained by",
                    "  // accessing this.getValue()[name1][name2]... should be array. The",
                    "  // callback will be called with a reference to this path object for each",
                    "  // element of the array.",
                    "  each(callback, ...names) {",
                    "    const { stack } = this;",
                    "    const { length } = stack;",
                    "    let value = stack.at(-1);",
                    "",
                    "    for (const name of names) {",
                    "      value = value[name];",
                    "      stack.push(name, value);",
                    "    }",
                    "",
                    "    try {",
                    "      for (let i = 0; i < value.length; ++i) {",
                    "        stack.push(i, value[i]);",
                    "        callback(this, i, value);",
                    "        stack.length -= 2;",
                    "      }",
                    "    } finally {",
                    "      stack.length = length;",
                    "    }",
                    "  }",
                    "",
                    "  // Similar to AstPath.prototype.each, except that the results of the",
                    "  // callback function invocations are stored in an array and returned at",
                    "  // the end of the iteration.",
                    "  map(callback, ...names) {",
                    "    const result = [];",
                    "    this.each((path, index, value) => {",
                    "      result[index] = callback(path, index, value);",
                    "    }, ...names);",
                    "    return result;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {...(",
                    "   *   | ((node: any, name: string | null, number: number | null) => boolean)",
                    "   *   | undefined",
                    "   * )} predicates",
                    "   */",
                    "  match(...predicates) {",
                    "    let stackPointer = this.stack.length - 1;",
                    "",
                    "    let name = null;",
                    "    let node = this.stack[stackPointer--];",
                    "",
                    "    for (const predicate of predicates) {",
                    "      /* c8 ignore next 3 */",
                    "      if (node === undefined) {",
                    "        return false;",
                    "      }",
                    "",
                    "      // skip index/array",
                    "      let number = null;",
                    "      if (typeof name === \"number\") {",
                    "        number = name;",
                    "        name = this.stack[stackPointer--];",
                    "        node = this.stack[stackPointer--];",
                    "      }",
                    "",
                    "      if (predicate && !predicate(node, name, number)) {",
                    "        return false;",
                    "      }",
                    "",
                    "      name = this.stack[stackPointer--];",
                    "      node = this.stack[stackPointer--];",
                    "    }",
                    "",
                    "    return true;",
                    "  }",
                    "",
                    "  /**",
                    "   * Traverses the ancestors of the current node heading toward the tree root",
                    "   * until it finds a node that matches the provided predicate function. Will",
                    "   * return the first matching ancestor. If no such node exists, returns undefined.",
                    "   * @param {(node: any) => boolean} predicate",
                    "   * @internal Unstable API. Don't use in plugins for now.",
                    "   */",
                    "  findAncestor(predicate) {",
                    "    for (const node of this.#getAncestors()) {",
                    "      if (predicate(node)) {",
                    "        return node;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  /**",
                    "   * Traverses the ancestors of the current node heading toward the tree root",
                    "   * until it finds a node that matches the provided predicate function.",
                    "   * returns true if matched node found.",
                    "   * @param {(node: any) => boolean} predicate",
                    "   * @returns {boolean}",
                    "   * @internal Unstable API. Don't use in plugins for now.",
                    "   */",
                    "  hasAncestor(predicate) {",
                    "    for (const node of this.#getAncestors()) {",
                    "      if (predicate(node)) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "",
                    "    return false;",
                    "  }",
                    "",
                    "  *#getAncestors() {",
                    "    const { stack } = this;",
                    "",
                    "    for (let index = stack.length - 3; index >= 0; index -= 2) {",
                    "      const value = stack[index];",
                    "      if (!Array.isArray(value)) {",
                    "        yield value;",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "export default AstPath;"
                ]
            },
            "common-options.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const CATEGORY_COMMON = \"Common\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  bracketSpacing: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print spaces between brackets.\",",
                    "    oppositeDescription: \"Do not print spaces between brackets.\",",
                    "  },",
                    "  singleQuote: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes instead of double quotes.\",",
                    "  },",
                    "  proseWrap: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"choice\",",
                    "    default: \"preserve\",",
                    "    description: \"How to wrap prose.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"always\",",
                    "        description: \"Wrap prose if it exceeds the print width.\",",
                    "      },",
                    "      {",
                    "        value: \"never\",",
                    "        description: \"Do not wrap prose.\",",
                    "      },",
                    "      {",
                    "        value: \"preserve\",",
                    "        description: \"Wrap prose as-is.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  bracketSameLine: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description:",
                    "      \"Put > of opening tags on the last line instead of on a new line.\",",
                    "  },",
                    "  singleAttributePerLine: {",
                    "    category: CATEGORY_COMMON,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Enforce single attribute per line in HTML, Vue and JSX.\",",
                    "  },",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "end-of-line.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function guessEndOfLine(text) {",
                    "  const index = text.indexOf(\"\\r\");",
                    "  if (index >= 0) {",
                    "    return text.charAt(index + 1) === \"\\n\" ? \"crlf\" : \"cr\";",
                    "  }",
                    "  return \"lf\";",
                    "}",
                    "",
                    "function convertEndOfLineToChars(value) {",
                    "  switch (value) {",
                    "    case \"cr\":",
                    "      return \"\\r\";",
                    "    case \"crlf\":",
                    "      return \"\\r\\n\";",
                    "    default:",
                    "      return \"\\n\";",
                    "  }",
                    "}",
                    "",
                    "function countEndOfLineChars(text, eol) {",
                    "  let regex;",
                    "",
                    "  switch (eol) {",
                    "    case \"\\n\":",
                    "      regex = /\\n/g;",
                    "      break;",
                    "    case \"\\r\":",
                    "      regex = /\\r/g;",
                    "      break;",
                    "    case \"\\r\\n\":",
                    "      regex = /\\r\\n/g;",
                    "      break;",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new Error(`Unexpected \"eol\" ${JSON.stringify(eol)}.`);",
                    "  }",
                    "",
                    "  const endOfLines = text.match(regex);",
                    "  return endOfLines ? endOfLines.length : 0;",
                    "}",
                    "",
                    "function normalizeEndOfLine(text) {",
                    "  return text.replaceAll(/\\r\\n?/g, \"\\n\");",
                    "}",
                    "",
                    "export {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "  countEndOfLineChars,",
                    "  normalizeEndOfLine,",
                    "};"
                ]
            },
            "errors.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "class ConfigError extends Error {}",
                    "class UndefinedParserError extends Error {}",
                    "class ArgExpansionBailout extends Error {}",
                    "",
                    "export { ConfigError, UndefinedParserError, ArgExpansionBailout };"
                ]
            },
            "get-file-info.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import inferParser from \"../utils/infer-parser.js\";",
                    "import { resolveConfig } from \"../config/resolve-config.js\";",
                    "import { isIgnored } from \"../utils/ignore.js\";",
                    "",
                    "/**",
                    " * @typedef {{ ignorePath?: string, withNodeModules?: boolean, plugins: object, resolveConfig?: boolean }} FileInfoOptions",
                    " * @typedef {{ ignored: boolean, inferredParser: string | null }} FileInfoResult",
                    " */",
                    "",
                    "/**",
                    " * @param {string} filePath",
                    " * @param {FileInfoOptions} options",
                    " * @returns {Promise<FileInfoResult>}",
                    " *",
                    " * Please note that prettier.getFileInfo() expects options.plugins to be an array of paths,",
                    " * not an object. A transformation from this array to an object is automatically done",
                    " * internally by the method wrapper. See withPlugins() in index.js.",
                    " */",
                    "async function getFileInfo(filePath, options) {",
                    "  if (typeof filePath !== \"string\") {",
                    "    throw new TypeError(",
                    "      `expect \\`filePath\\` to be a string, got \\`${typeof filePath}\\``",
                    "    );",
                    "  }",
                    "",
                    "  let { ignorePath, withNodeModules } = options;",
                    "  // In API we allow single `ignorePath`",
                    "  if (!Array.isArray(ignorePath)) {",
                    "    ignorePath = [ignorePath];",
                    "  }",
                    "",
                    "  const ignored = await isIgnored(filePath, { ignorePath, withNodeModules });",
                    "",
                    "  let inferredParser;",
                    "  if (!ignored) {",
                    "    inferredParser = await getParser(filePath, options);",
                    "  }",
                    "",
                    "  return {",
                    "    ignored,",
                    "    inferredParser: inferredParser ?? null,",
                    "  };",
                    "}",
                    "",
                    "async function getParser(filePath, options) {",
                    "  let config;",
                    "  if (options.resolveConfig !== false) {",
                    "    config = await resolveConfig(filePath);",
                    "  }",
                    "",
                    "  return config?.parser ?? inferParser(options, { physicalFile: filePath });",
                    "}",
                    "",
                    "export default getFileInfo;"
                ]
            },
            "mockable.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "import { cosmiconfig } from \"cosmiconfig\";",
                    "import { sync as findParentDir } from \"find-parent-dir\";",
                    "import getStdin from \"get-stdin\";",
                    "import { isCI } from \"ci-info\";",
                    "",
                    "function writeFormattedFile(file, data) {",
                    "  return fs.writeFile(file, data);",
                    "}",
                    "",
                    "const mockable = {",
                    "  cosmiconfig,",
                    "  findParentDir,",
                    "  getStdin,",
                    "  isCI: () => isCI,",
                    "  writeFormattedFile,",
                    "};",
                    "",
                    "export default mockable;"
                ]
            },
            "parser-create-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function createError(message, options) {",
                    "  // TODO: Use `Error.prototype.cause` when we drop support for Node.js<18.7.0",
                    "",
                    "  // Construct an error similar to the ones thrown by Babel.",
                    "  const error = new SyntaxError(",
                    "    message +",
                    "      \" (\" +",
                    "      options.loc.start.line +",
                    "      \":\" +",
                    "      options.loc.start.column +",
                    "      \")\"",
                    "  );",
                    "",
                    "  return Object.assign(error, options);",
                    "}",
                    "",
                    "export default createError;"
                ]
            }
        },
        "config": {
            "find-project-root.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// Simple version of `find-project-root`",
                    "// https://github.com/kirstein/find-project-root/blob/master/index.js",
                    "",
                    "import fs from \"node:fs\";",
                    "import path from \"node:path\";",
                    "",
                    "const MARKERS = [\".git\", \".hg\"];",
                    "",
                    "const markerExists = (directory) =>",
                    "  MARKERS.some((mark) => fs.existsSync(path.join(directory, mark)));",
                    "",
                    "function findProjectRoot(directory) {",
                    "  while (!markerExists(directory)) {",
                    "    const parentDirectory = path.resolve(directory, \"..\");",
                    "    if (parentDirectory === directory) {",
                    "      break;",
                    "    }",
                    "    directory = parentDirectory;",
                    "  }",
                    "",
                    "  return directory;",
                    "}",
                    "",
                    "export default findProjectRoot;"
                ]
            },
            "get-prettier-config-explorer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { pathToFileURL } from \"node:url\";",
                    "import parseToml from \"@iarna/toml/parse-async.js\";",
                    "import parseJson5 from \"json5/lib/parse.js\";",
                    "import mockable from \"../common/mockable.js\";",
                    "import loadExternalConfig from \"./load-external-config.js\";",
                    "",
                    "const { cosmiconfig } = mockable;",
                    "",
                    "const searchPlaces = [",
                    "  \"package.json\",",
                    "  \".prettierrc\",",
                    "  \".prettierrc.json\",",
                    "  \".prettierrc.yaml\",",
                    "  \".prettierrc.yml\",",
                    "  \".prettierrc.json5\",",
                    "  \".prettierrc.js\",",
                    "  \".prettierrc.mjs\",",
                    "  \".prettierrc.cjs\",",
                    "  \"prettier.config.js\",",
                    "  \"prettier.config.mjs\",",
                    "  \"prettier.config.cjs\",",
                    "  \".prettierrc.toml\",",
                    "];",
                    "",
                    "async function loadJs(filepath /*, content*/) {",
                    "  const module = await import(pathToFileURL(filepath).href);",
                    "  return module.default;",
                    "}",
                    "",
                    "const loaders = {",
                    "  async \".toml\"(filePath, content) {",
                    "    try {",
                    "      return await parseToml(content);",
                    "    } catch (error) {",
                    "      error.message = `TOML Error in ${filePath}:\\n${error.message}`;",
                    "      throw error;",
                    "    }",
                    "  },",
                    "  \".json5\"(filePath, content) {",
                    "    try {",
                    "      return parseJson5(content);",
                    "    } catch (error) {",
                    "      error.message = `JSON5 Error in ${filePath}:\\n${error.message}`;",
                    "      throw error;",
                    "    }",
                    "  },",
                    "  \".js\": loadJs,",
                    "  \".mjs\": loadJs,",
                    "  \".cjs\": loadJs,",
                    "};",
                    "",
                    "async function transform(result) {",
                    "  if (!result?.config) {",
                    "    return result;",
                    "  }",
                    "",
                    "  let { config, filepath } = result;",
                    "",
                    "  /*",
                    "  We support external config",
                    "",
                    "  ```json",
                    "  {",
                    "    \"prettier\": \"my-prettier-config-package-or-file\"",
                    "  }",
                    "  ```",
                    "  */",
                    "  if (typeof config === \"string\") {",
                    "    config = await loadExternalConfig(config, filepath);",
                    "    result.config = config;",
                    "  }",
                    "",
                    "  if (typeof config !== \"object\") {",
                    "    throw new TypeError(",
                    "      \"Config is only allowed to be an object, \" +",
                    "        `but received ${typeof config} in \"${filepath}\"`",
                    "    );",
                    "  }",
                    "",
                    "  delete config.$schema;",
                    "  return result;",
                    "}",
                    "",
                    "/**",
                    " * @param {{cache: boolean }} options",
                    " * @return {ReturnType<import(\"cosmiconfig\").cosmiconfig>}",
                    " */",
                    "function getExplorer(options) {",
                    "  return cosmiconfig(\"prettier\", {",
                    "    cache: options.cache,",
                    "    transform,",
                    "    searchPlaces,",
                    "    loaders,",
                    "  });",
                    "}",
                    "",
                    "export default getExplorer;"
                ]
            },
            "load-external-config.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import requireFromFile from \"../utils/require-from-file.js\";",
                    "import importFromFile from \"../utils/import-from-file.js\";",
                    "",
                    "async function loadExternalConfig(config, filepath) {",
                    "  /*",
                    "  Try `require()` first, this is how it works in Prettier v2.",
                    "  Kept this because the external config path or package may can't load with `import()`:",
                    "  1. is JSON file or package",
                    "  2. is CommonJS file without extension",
                    "  3. is a dirname with index.js inside",
                    "  */",
                    "  try {",
                    "    return requireFromFile(config, filepath);",
                    "  } catch (error) {",
                    "    if (",
                    "      error?.code !== \"MODULE_NOT_FOUND\" &&",
                    "      error?.code !== \"ERR_REQUIRE_ESM\"",
                    "    ) {",
                    "      throw error;",
                    "    }",
                    "  }",
                    "",
                    "  const module = await importFromFile(config, filepath);",
                    "  return module.default;",
                    "}",
                    "",
                    "export default loadExternalConfig;"
                ]
            },
            "resolve-config.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import micromatch from \"micromatch\";",
                    "import mem, { memClear } from \"mem\";",
                    "import partition from \"../utils/partition.js\";",
                    "import loadEditorConfigWithoutCache from \"./resolve-editorconfig.js\";",
                    "import getPrettierConfigExplorerWithoutCache from \"./get-prettier-config-explorer.js\";",
                    "",
                    "const getPrettierConfigExplorer = mem(getPrettierConfigExplorerWithoutCache, {",
                    "  cacheKey: ([options]) => options.cache,",
                    "});",
                    "const memoizedLoadEditorConfig = mem(loadEditorConfigWithoutCache);",
                    "function clearCache() {",
                    "  memClear(getPrettierConfigExplorer);",
                    "  memClear(memoizedLoadEditorConfig);",
                    "}",
                    "",
                    "function loadEditorConfig(filePath, options) {",
                    "  if (!filePath || !options.editorconfig) {",
                    "    return;",
                    "  }",
                    "",
                    "  return (",
                    "    options.useCache ? memoizedLoadEditorConfig : loadEditorConfigWithoutCache",
                    "  )(filePath);",
                    "}",
                    "",
                    "function loadPrettierConfig(filePath, options) {",
                    "  const { useCache, config: configPath } = options;",
                    "  const { load, search } = getPrettierConfigExplorer({",
                    "    cache: Boolean(useCache),",
                    "  });",
                    "  return configPath ? load(configPath) : search(filePath);",
                    "}",
                    "",
                    "async function resolveConfig(filePath, options) {",
                    "  options = { useCache: true, ...options };",
                    "",
                    "  const [result, editorConfigured] = await Promise.all([",
                    "    loadPrettierConfig(filePath, options),",
                    "    loadEditorConfig(filePath, options),",
                    "  ]);",
                    "",
                    "  if (!result && !editorConfigured) {",
                    "    return null;",
                    "  }",
                    "",
                    "  const merged = {",
                    "    ...editorConfigured,",
                    "    ...mergeOverrides(result, filePath),",
                    "  };",
                    "",
                    "  for (const optionName of [\"plugins\", \"pluginSearchDirs\"]) {",
                    "    if (Array.isArray(merged[optionName])) {",
                    "      merged[optionName] = merged[optionName].map((value) =>",
                    "        typeof value === \"string\" && value.startsWith(\".\") // relative path",
                    "          ? path.resolve(path.dirname(result.filepath), value)",
                    "          : value",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return merged;",
                    "}",
                    "",
                    "async function resolveConfigFile(filePath) {",
                    "  const { search } = getPrettierConfigExplorer({ cache: false });",
                    "  const result = await search(filePath);",
                    "  return result ? result.filepath : null;",
                    "}",
                    "",
                    "function mergeOverrides(configResult, filePath) {",
                    "  const { config, filepath: configPath } = configResult || {};",
                    "  const { overrides, ...options } = config || {};",
                    "  if (filePath && overrides) {",
                    "    const relativeFilePath = path.relative(path.dirname(configPath), filePath);",
                    "    for (const override of overrides) {",
                    "      if (",
                    "        pathMatchesGlobs(",
                    "          relativeFilePath,",
                    "          override.files,",
                    "          override.excludeFiles",
                    "        )",
                    "      ) {",
                    "        Object.assign(options, override.options);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  return options;",
                    "}",
                    "",
                    "// Based on eslint: https://github.com/eslint/eslint/blob/master/lib/config/config-ops.js",
                    "function pathMatchesGlobs(filePath, patterns, excludedPatterns) {",
                    "  const patternList = Array.isArray(patterns) ? patterns : [patterns];",
                    "  // micromatch always matches against basename when the option is enabled",
                    "  // use only patterns without slashes with it to match minimatch behavior",
                    "  const [withSlashes, withoutSlashes] = partition(patternList, (pattern) =>",
                    "    pattern.includes(\"/\")",
                    "  );",
                    "",
                    "  return (",
                    "    micromatch.isMatch(filePath, withoutSlashes, {",
                    "      ignore: excludedPatterns,",
                    "      basename: true,",
                    "      dot: true,",
                    "    }) ||",
                    "    micromatch.isMatch(filePath, withSlashes, {",
                    "      ignore: excludedPatterns,",
                    "      basename: false,",
                    "      dot: true,",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "export { resolveConfig, resolveConfigFile, clearCache };"
                ]
            },
            "resolve-editorconfig.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import editorconfig from \"editorconfig\";",
                    "import editorConfigToPrettier from \"editorconfig-to-prettier\";",
                    "import findProjectRoot from \"./find-project-root.js\";",
                    "",
                    "async function loadEditorConfig(filePath) {",
                    "  const editorConfig = await editorconfig.parse(filePath, {",
                    "    root: findProjectRoot(path.dirname(path.resolve(filePath))),",
                    "  });",
                    "",
                    "  const config = editorConfigToPrettier(editorConfig);",
                    "",
                    "  if (config) {",
                    "    // We are not using this option",
                    "    delete config.insertFinalNewline;",
                    "  }",
                    "",
                    "  return config;",
                    "}",
                    "",
                    "export default loadEditorConfig;"
                ]
            }
        },
        "document": {
            "builders.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  DOC_TYPE_CURSOR,",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "} from \"./constants.js\";",
                    "import { assertDoc, assertDocArray } from \"./utils/assert-doc.js\";",
                    "",
                    "/**",
                    " * TBD properly tagged union for Doc object type is needed here.",
                    " *",
                    " * @typedef {object} DocObject",
                    " * @property {string} type",
                    " * @property {boolean} [hard]",
                    " * @property {boolean} [literal]",
                    " *",
                    " * @typedef {Doc[]} DocArray",
                    " *",
                    " * @typedef {string | DocObject | DocArray} Doc",
                    " */",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function indent(contents) {",
                    "  assertDoc(contents);",
                    "",
                    "  return { type: DOC_TYPE_INDENT, contents };",
                    "}",
                    "",
                    "/**",
                    " * @param {number | string} widthOrString",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function align(widthOrString, contents) {",
                    "  assertDoc(contents);",
                    "",
                    "  return { type: DOC_TYPE_ALIGN, contents, n: widthOrString };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function group(contents, opts = {}) {",
                    "  assertDoc(contents);",
                    "  assertDocArray(opts.expandedStates, /* optional */ true);",
                    "",
                    "  return {",
                    "    type: DOC_TYPE_GROUP,",
                    "    id: opts.id,",
                    "    contents,",
                    "    break: Boolean(opts.shouldBreak),",
                    "    expandedStates: opts.expandedStates,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedentToRoot(contents) {",
                    "  return align(Number.NEGATIVE_INFINITY, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function markAsRoot(contents) {",
                    "  // @ts-expect-error - TBD ???:",
                    "  return align({ type: \"root\" }, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function dedent(contents) {",
                    "  return align(-1, contents);",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} states",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function conditionalGroup(states, opts) {",
                    "  return group(states[0], { ...opts, expandedStates: states });",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc[]} parts",
                    " * @returns Doc",
                    " */",
                    "function fill(parts) {",
                    "  assertDocArray(parts);",
                    "",
                    "  return { type: DOC_TYPE_FILL, parts };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} breakContents",
                    " * @param {Doc} [flatContents]",
                    " * @param {object} [opts] - TBD ???",
                    " * @returns Doc",
                    " */",
                    "function ifBreak(breakContents, flatContents = \"\", opts = {}) {",
                    "  assertDoc(breakContents);",
                    "  if (flatContents !== \"\") {",
                    "    assertDoc(flatContents);",
                    "  }",
                    "",
                    "  return {",
                    "    type: DOC_TYPE_IF_BREAK,",
                    "    breakContents,",
                    "    flatContents,",
                    "    groupId: opts.groupId,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * Optimized version of `ifBreak(indent(doc), doc, { groupId: ... })`",
                    " * @param {Doc} contents",
                    " * @param {{ groupId: symbol, negate?: boolean }} opts",
                    " * @returns Doc",
                    " */",
                    "function indentIfBreak(contents, opts) {",
                    "  assertDoc(contents);",
                    "",
                    "  return {",
                    "    type: DOC_TYPE_INDENT_IF_BREAK,",
                    "    contents,",
                    "    groupId: opts.groupId,",
                    "    negate: opts.negate,",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} contents",
                    " * @returns Doc",
                    " */",
                    "function lineSuffix(contents) {",
                    "  assertDoc(contents);",
                    "",
                    "  return { type: DOC_TYPE_LINE_SUFFIX, contents };",
                    "}",
                    "",
                    "const lineSuffixBoundary = { type: DOC_TYPE_LINE_SUFFIX_BOUNDARY };",
                    "const breakParent = { type: DOC_TYPE_BREAK_PARENT };",
                    "const trim = { type: DOC_TYPE_TRIM };",
                    "",
                    "const hardlineWithoutBreakParent = { type: DOC_TYPE_LINE, hard: true };",
                    "const literallineWithoutBreakParent = {",
                    "  type: DOC_TYPE_LINE,",
                    "  hard: true,",
                    "  literal: true,",
                    "};",
                    "",
                    "const line = { type: DOC_TYPE_LINE };",
                    "const softline = { type: DOC_TYPE_LINE, soft: true };",
                    "const hardline = [hardlineWithoutBreakParent, breakParent];",
                    "const literalline = [literallineWithoutBreakParent, breakParent];",
                    "",
                    "const cursor = { type: DOC_TYPE_CURSOR };",
                    "",
                    "/**",
                    " * @param {Doc} separator",
                    " * @param {Doc[]} docs",
                    " * @returns Doc",
                    " */",
                    "function join(separator, docs) {",
                    "  assertDoc(separator);",
                    "  assertDocArray(docs);",
                    "",
                    "  const parts = [];",
                    "",
                    "  for (let i = 0; i < docs.length; i++) {",
                    "    if (i !== 0) {",
                    "      parts.push(separator);",
                    "    }",
                    "",
                    "    parts.push(docs[i]);",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "/**",
                    " * @param {Doc} doc",
                    " * @param {number} size",
                    " * @param {number} tabWidth",
                    " */",
                    "function addAlignmentToDoc(doc, size, tabWidth) {",
                    "  assertDoc(doc);",
                    "",
                    "  let aligned = doc;",
                    "  if (size > 0) {",
                    "    // Use indent to add tabs for all the levels of tabs we need",
                    "    for (let i = 0; i < Math.floor(size / tabWidth); ++i) {",
                    "      aligned = indent(aligned);",
                    "    }",
                    "    // Use align for all the spaces that are needed",
                    "    aligned = align(size % tabWidth, aligned);",
                    "    // size is absolute from 0 and not relative to the current",
                    "    // indentation, so we use -Infinity to reset the indentation to 0",
                    "    aligned = align(Number.NEGATIVE_INFINITY, aligned);",
                    "  }",
                    "  return aligned;",
                    "}",
                    "",
                    "/**",
                    " * Mark a doc with an arbitrary truthy value. This doesn't affect how the doc is printed, but can be useful for heuristics based on doc introspection.",
                    " * @param {any} label If falsy, the `contents` doc is returned as is.",
                    " * @param {Doc} contents",
                    " */",
                    "function label(label, contents) {",
                    "  assertDoc(contents);",
                    "",
                    "  return label ? { type: DOC_TYPE_LABEL, label, contents } : contents;",
                    "}",
                    "",
                    "export {",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  trim,",
                    "  indent,",
                    "  indentIfBreak,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent,",
                    "  hardlineWithoutBreakParent,",
                    "  literallineWithoutBreakParent,",
                    "  label,",
                    "};"
                ]
            },
            "constants.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export const DOC_TYPE_STRING = \"string\";",
                    "export const DOC_TYPE_ARRAY = \"array\";",
                    "export const DOC_TYPE_CURSOR = \"cursor\";",
                    "export const DOC_TYPE_INDENT = \"indent\";",
                    "export const DOC_TYPE_ALIGN = \"align\";",
                    "export const DOC_TYPE_TRIM = \"trim\";",
                    "export const DOC_TYPE_GROUP = \"group\";",
                    "export const DOC_TYPE_FILL = \"fill\";",
                    "export const DOC_TYPE_IF_BREAK = \"if-break\";",
                    "export const DOC_TYPE_INDENT_IF_BREAK = \"indent-if-break\";",
                    "export const DOC_TYPE_LINE_SUFFIX = \"line-suffix\";",
                    "export const DOC_TYPE_LINE_SUFFIX_BOUNDARY = \"line-suffix-boundary\";",
                    "export const DOC_TYPE_LINE = \"line\";",
                    "export const DOC_TYPE_LABEL = \"label\";",
                    "export const DOC_TYPE_BREAK_PARENT = \"break-parent\";",
                    "",
                    "export const VALID_OBJECT_DOC_TYPES = new Set([",
                    "  DOC_TYPE_CURSOR,",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "]);"
                ]
            },
            "debug.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "} from \"./constants.js\";",
                    "",
                    "function flattenDoc(doc) {",
                    "  if (!doc) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  if (Array.isArray(doc)) {",
                    "    const res = [];",
                    "    for (const part of doc) {",
                    "      if (Array.isArray(part)) {",
                    "        res.push(...flattenDoc(part));",
                    "      } else {",
                    "        const flattened = flattenDoc(part);",
                    "        if (flattened !== \"\") {",
                    "          res.push(flattened);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return res;",
                    "  }",
                    "",
                    "  if (doc.type === DOC_TYPE_IF_BREAK) {",
                    "    return {",
                    "      ...doc,",
                    "      breakContents: flattenDoc(doc.breakContents),",
                    "      flatContents: flattenDoc(doc.flatContents),",
                    "    };",
                    "  }",
                    "",
                    "  if (doc.type === DOC_TYPE_GROUP) {",
                    "    return {",
                    "      ...doc,",
                    "      contents: flattenDoc(doc.contents),",
                    "      expandedStates: doc.expandedStates?.map(flattenDoc),",
                    "    };",
                    "  }",
                    "",
                    "  if (doc.type === DOC_TYPE_FILL) {",
                    "    return { type: \"fill\", parts: doc.parts.map(flattenDoc) };",
                    "  }",
                    "",
                    "  if (doc.contents) {",
                    "    return { ...doc, contents: flattenDoc(doc.contents) };",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function printDocToDebug(doc) {",
                    "  /** @type Record<symbol, string> */",
                    "  const printedSymbols = Object.create(null);",
                    "  /** @type Set<string> */",
                    "  const usedKeysForSymbols = new Set();",
                    "  return printDoc(flattenDoc(doc));",
                    "",
                    "  function printDoc(doc, index, parentParts) {",
                    "    if (typeof doc === \"string\") {",
                    "      return JSON.stringify(doc);",
                    "    }",
                    "",
                    "    if (Array.isArray(doc)) {",
                    "      const printed = doc.map(printDoc).filter(Boolean);",
                    "      return printed.length === 1 ? printed[0] : `[${printed.join(\", \")}]`;",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_LINE) {",
                    "      const withBreakParent =",
                    "        parentParts?.[index + 1]?.type === DOC_TYPE_BREAK_PARENT;",
                    "      if (doc.literal) {",
                    "        return withBreakParent",
                    "          ? \"literalline\"",
                    "          : \"literallineWithoutBreakParent\";",
                    "      }",
                    "      if (doc.hard) {",
                    "        return withBreakParent ? \"hardline\" : \"hardlineWithoutBreakParent\";",
                    "      }",
                    "      if (doc.soft) {",
                    "        return \"softline\";",
                    "      }",
                    "      return \"line\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_BREAK_PARENT) {",
                    "      const afterHardline =",
                    "        parentParts?.[index - 1]?.type === DOC_TYPE_LINE &&",
                    "        parentParts[index - 1].hard;",
                    "      return afterHardline ? undefined : \"breakParent\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_TRIM) {",
                    "      return \"trim\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_INDENT) {",
                    "      return \"indent(\" + printDoc(doc.contents) + \")\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_ALIGN) {",
                    "      return doc.n === Number.NEGATIVE_INFINITY",
                    "        ? \"dedentToRoot(\" + printDoc(doc.contents) + \")\"",
                    "        : doc.n < 0",
                    "        ? \"dedent(\" + printDoc(doc.contents) + \")\"",
                    "        : doc.n.type === \"root\"",
                    "        ? \"markAsRoot(\" + printDoc(doc.contents) + \")\"",
                    "        : \"align(\" +",
                    "          JSON.stringify(doc.n) +",
                    "          \", \" +",
                    "          printDoc(doc.contents) +",
                    "          \")\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_IF_BREAK) {",
                    "      return (",
                    "        \"ifBreak(\" +",
                    "        printDoc(doc.breakContents) +",
                    "        (doc.flatContents ? \", \" + printDoc(doc.flatContents) : \"\") +",
                    "        (doc.groupId",
                    "          ? (!doc.flatContents ? ', \"\"' : \"\") +",
                    "            `, { groupId: ${printGroupId(doc.groupId)} }`",
                    "          : \"\") +",
                    "        \")\"",
                    "      );",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_INDENT_IF_BREAK) {",
                    "      const optionsParts = [];",
                    "",
                    "      if (doc.negate) {",
                    "        optionsParts.push(\"negate: true\");",
                    "      }",
                    "",
                    "      if (doc.groupId) {",
                    "        optionsParts.push(`groupId: ${printGroupId(doc.groupId)}`);",
                    "      }",
                    "",
                    "      const options =",
                    "        optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";",
                    "",
                    "      return `indentIfBreak(${printDoc(doc.contents)}${options})`;",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_GROUP) {",
                    "      const optionsParts = [];",
                    "",
                    "      if (doc.break && doc.break !== \"propagated\") {",
                    "        optionsParts.push(\"shouldBreak: true\");",
                    "      }",
                    "",
                    "      if (doc.id) {",
                    "        optionsParts.push(`id: ${printGroupId(doc.id)}`);",
                    "      }",
                    "",
                    "      const options =",
                    "        optionsParts.length > 0 ? `, { ${optionsParts.join(\", \")} }` : \"\";",
                    "",
                    "      if (doc.expandedStates) {",
                    "        return `conditionalGroup([${doc.expandedStates",
                    "          .map((part) => printDoc(part))",
                    "          .join(\",\")}]${options})`;",
                    "      }",
                    "",
                    "      return `group(${printDoc(doc.contents)}${options})`;",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_FILL) {",
                    "      return `fill([${doc.parts.map((part) => printDoc(part)).join(\", \")}])`;",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_LINE_SUFFIX) {",
                    "      return \"lineSuffix(\" + printDoc(doc.contents) + \")\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_LINE_SUFFIX_BOUNDARY) {",
                    "      return \"lineSuffixBoundary\";",
                    "    }",
                    "",
                    "    if (doc.type === DOC_TYPE_LABEL) {",
                    "      return `label(${JSON.stringify(doc.label)}, ${printDoc(doc.contents)})`;",
                    "    }",
                    "",
                    "    throw new Error(\"Unknown doc type \" + doc.type);",
                    "  }",
                    "",
                    "  function printGroupId(id) {",
                    "    if (typeof id !== \"symbol\") {",
                    "      return JSON.stringify(String(id));",
                    "    }",
                    "",
                    "    if (id in printedSymbols) {",
                    "      return printedSymbols[id];",
                    "    }",
                    "",
                    "    const prefix = id.description || \"symbol\";",
                    "    for (let counter = 0; ; counter++) {",
                    "      const key = prefix + (counter > 0 ? ` #${counter}` : \"\");",
                    "      if (!usedKeysForSymbols.has(key)) {",
                    "        usedKeysForSymbols.add(key);",
                    "        return (printedSymbols[id] = `Symbol.for(${JSON.stringify(key)})`);",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "export { printDocToDebug };"
                ]
            },
            "invalid-doc-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { VALID_OBJECT_DOC_TYPES } from \"./constants.js\";",
                    "import getDocType from \"./utils/get-doc-type.js\";",
                    "",
                    "const disjunctionListFormat = (list) =>",
                    "  new Intl.ListFormat(\"en-US\", { type: \"disjunction\" }).format(list);",
                    "",
                    "function getDocErrorMessage(doc) {",
                    "  const type = doc === null ? \"null\" : typeof doc;",
                    "  if (type !== \"string\" && type !== \"object\") {",
                    "    return `Unexpected doc '${type}', \\nExpected it to be 'string' or 'object'.`;",
                    "  }",
                    "",
                    "  /* c8 ignore next 3 */",
                    "  if (getDocType(doc)) {",
                    "    throw new Error(\"doc is valid.\");",
                    "  }",
                    "",
                    "  // eslint-disable-next-line prettier-internal-rules/no-unnecessary-ast-path-call",
                    "  const objectType = Object.prototype.toString.call(doc);",
                    "  if (objectType !== \"[object Object]\") {",
                    "    return `Unexpected doc '${objectType}'.`;",
                    "  }",
                    "",
                    "  const EXPECTED_TYPE_VALUES = disjunctionListFormat(",
                    "    [...VALID_OBJECT_DOC_TYPES].map((type) => `'${type}'`)",
                    "  );",
                    "",
                    "  return `Unexpected doc.type '${doc.type}'.\\nExpected it to be ${EXPECTED_TYPE_VALUES}.`;",
                    "}",
                    "",
                    "class InvalidDocError extends Error {",
                    "  name = \"InvalidDocError\";",
                    "",
                    "  constructor(doc) {",
                    "    super(getDocErrorMessage(doc));",
                    "    this.doc = doc;",
                    "  }",
                    "}",
                    "",
                    "export default InvalidDocError;"
                ]
            },
            "printer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { convertEndOfLineToChars } from \"../common/end-of-line.js\";",
                    "import getStringWidth from \"../utils/get-string-width.js\";",
                    "import {",
                    "  DOC_TYPE_STRING,",
                    "  DOC_TYPE_ARRAY,",
                    "  DOC_TYPE_CURSOR,",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "} from \"./constants.js\";",
                    "import { fill, indent, hardlineWithoutBreakParent } from \"./builders.js\";",
                    "import { getDocParts, getDocType, propagateBreaks } from \"./utils.js\";",
                    "import InvalidDocError from \"./invalid-doc-error.js\";",
                    "",
                    "/** @typedef {typeof MODE_BREAK | typeof MODE_FLAT} Mode */",
                    "/** @typedef {{ ind: any, doc: any, mode: Mode }} Command */",
                    "/** @typedef {Record<symbol, Mode>} GroupModeMap */",
                    "",
                    "/** @type {unique symbol} */",
                    "const MODE_BREAK = Symbol(\"MODE_BREAK\");",
                    "/** @type {unique symbol} */",
                    "const MODE_FLAT = Symbol(\"MODE_FLAT\");",
                    "",
                    "const CURSOR_PLACEHOLDER = Symbol(\"cursor\");",
                    "",
                    "function rootIndent() {",
                    "  return { value: \"\", length: 0, queue: [] };",
                    "}",
                    "",
                    "function makeIndent(ind, options) {",
                    "  return generateInd(ind, { type: \"indent\" }, options);",
                    "}",
                    "",
                    "function makeAlign(indent, widthOrDoc, options) {",
                    "  if (widthOrDoc === Number.NEGATIVE_INFINITY) {",
                    "    return indent.root || rootIndent();",
                    "  }",
                    "",
                    "  if (widthOrDoc < 0) {",
                    "    return generateInd(indent, { type: \"dedent\" }, options);",
                    "  }",
                    "",
                    "  if (!widthOrDoc) {",
                    "    return indent;",
                    "  }",
                    "",
                    "  if (widthOrDoc.type === \"root\") {",
                    "    return { ...indent, root: indent };",
                    "  }",
                    "",
                    "  const alignType =",
                    "    typeof widthOrDoc === \"string\" ? \"stringAlign\" : \"numberAlign\";",
                    "",
                    "  return generateInd(indent, { type: alignType, n: widthOrDoc }, options);",
                    "}",
                    "",
                    "function generateInd(ind, newPart, options) {",
                    "  const queue =",
                    "    newPart.type === \"dedent\"",
                    "      ? ind.queue.slice(0, -1)",
                    "      : [...ind.queue, newPart];",
                    "",
                    "  let value = \"\";",
                    "  let length = 0;",
                    "  let lastTabs = 0;",
                    "  let lastSpaces = 0;",
                    "",
                    "  for (const part of queue) {",
                    "    switch (part.type) {",
                    "      case \"indent\":",
                    "        flush();",
                    "        if (options.useTabs) {",
                    "          addTabs(1);",
                    "        } else {",
                    "          addSpaces(options.tabWidth);",
                    "        }",
                    "        break;",
                    "      case \"stringAlign\":",
                    "        flush();",
                    "        value += part.n;",
                    "        length += part.n.length;",
                    "        break;",
                    "      case \"numberAlign\":",
                    "        lastTabs += 1;",
                    "        lastSpaces += part.n;",
                    "        break;",
                    "      default:",
                    "        /* c8 ignore next */",
                    "        throw new Error(`Unexpected type '${part.type}'`);",
                    "    }",
                    "  }",
                    "",
                    "  flushSpaces();",
                    "",
                    "  return { ...ind, value, length, queue };",
                    "",
                    "  function addTabs(count) {",
                    "    value += \"\\t\".repeat(count);",
                    "    length += options.tabWidth * count;",
                    "  }",
                    "",
                    "  function addSpaces(count) {",
                    "    value += \" \".repeat(count);",
                    "    length += count;",
                    "  }",
                    "",
                    "  function flush() {",
                    "    if (options.useTabs) {",
                    "      flushTabs();",
                    "    } else {",
                    "      flushSpaces();",
                    "    }",
                    "  }",
                    "",
                    "  function flushTabs() {",
                    "    if (lastTabs > 0) {",
                    "      addTabs(lastTabs);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function flushSpaces() {",
                    "    if (lastSpaces > 0) {",
                    "      addSpaces(lastSpaces);",
                    "    }",
                    "    resetLast();",
                    "  }",
                    "",
                    "  function resetLast() {",
                    "    lastTabs = 0;",
                    "    lastSpaces = 0;",
                    "  }",
                    "}",
                    "",
                    "// Trim `Tab(U+0009)` and `Space(U+0020)` at the end of line",
                    "function trim(out) {",
                    "  let trimCount = 0;",
                    "  let cursorCount = 0;",
                    "  let outIndex = out.length;",
                    "",
                    "  outer: while (outIndex--) {",
                    "    const last = out[outIndex];",
                    "",
                    "    if (last === CURSOR_PLACEHOLDER) {",
                    "      cursorCount++;",
                    "      continue;",
                    "    }",
                    "",
                    "    /* c8 ignore next 3 */",
                    "    if (process.env.NODE_ENV !== \"production\" && typeof last !== \"string\") {",
                    "      throw new Error(`Unexpected value in trim: '${typeof last}'`);",
                    "    }",
                    "",
                    "    // Not using a regexp here because regexps for trimming off trailing",
                    "    // characters are known to have performance issues.",
                    "    for (let charIndex = last.length - 1; charIndex >= 0; charIndex--) {",
                    "      const char = last[charIndex];",
                    "      if (char === \" \" || char === \"\\t\") {",
                    "        trimCount++;",
                    "      } else {",
                    "        out[outIndex] = last.slice(0, charIndex + 1);",
                    "        break outer;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  if (trimCount > 0 || cursorCount > 0) {",
                    "    out.length = outIndex + 1;",
                    "",
                    "    while (cursorCount-- > 0) {",
                    "      out.push(CURSOR_PLACEHOLDER);",
                    "    }",
                    "  }",
                    "",
                    "  return trimCount;",
                    "}",
                    "",
                    "/**",
                    " * @param {Command} next",
                    " * @param {Command[]} restCommands",
                    " * @param {number} width",
                    " * @param {boolean} hasLineSuffix",
                    " * @param {GroupModeMap} groupModeMap",
                    " * @param {boolean} [mustBeFlat]",
                    " * @returns {boolean}",
                    " */",
                    "function fits(",
                    "  next,",
                    "  restCommands,",
                    "  width,",
                    "  hasLineSuffix,",
                    "  groupModeMap,",
                    "  mustBeFlat",
                    ") {",
                    "  if (width === Number.POSITIVE_INFINITY) {",
                    "    return true;",
                    "  }",
                    "",
                    "  let restIdx = restCommands.length;",
                    "  /** @type {Array<Omit<Command, 'ind'>>} */",
                    "  const cmds = [next];",
                    "  // `out` is only used for width counting because `trim` requires to look",
                    "  // backwards for space characters.",
                    "  const out = [];",
                    "  while (width >= 0) {",
                    "    if (cmds.length === 0) {",
                    "      if (restIdx === 0) {",
                    "        return true;",
                    "      }",
                    "      cmds.push(restCommands[--restIdx]);",
                    "",
                    "      continue;",
                    "    }",
                    "",
                    "    const { mode, doc } = cmds.pop();",
                    "",
                    "    switch (getDocType(doc)) {",
                    "      case DOC_TYPE_STRING:",
                    "        out.push(doc);",
                    "        width -= getStringWidth(doc);",
                    "        break;",
                    "",
                    "      case DOC_TYPE_ARRAY:",
                    "      case DOC_TYPE_FILL: {",
                    "        const parts = getDocParts(doc);",
                    "        for (let i = parts.length - 1; i >= 0; i--) {",
                    "          cmds.push({ mode, doc: parts[i] });",
                    "        }",
                    "        break;",
                    "      }",
                    "",
                    "      case DOC_TYPE_INDENT:",
                    "      case DOC_TYPE_ALIGN:",
                    "      case DOC_TYPE_INDENT_IF_BREAK:",
                    "      case DOC_TYPE_LABEL:",
                    "        cmds.push({ mode, doc: doc.contents });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_TRIM:",
                    "        width += trim(out);",
                    "        break;",
                    "",
                    "      case DOC_TYPE_GROUP: {",
                    "        if (mustBeFlat && doc.break) {",
                    "          return false;",
                    "        }",
                    "        const groupMode = doc.break ? MODE_BREAK : mode;",
                    "        // The most expanded state takes up the least space on the current line.",
                    "        const contents =",
                    "          doc.expandedStates && groupMode === MODE_BREAK",
                    "            ? doc.expandedStates.at(-1)",
                    "            : doc.contents;",
                    "        cmds.push({ mode: groupMode, doc: contents });",
                    "        break;",
                    "      }",
                    "",
                    "      case DOC_TYPE_IF_BREAK: {",
                    "        const groupMode = doc.groupId",
                    "          ? groupModeMap[doc.groupId] || MODE_FLAT",
                    "          : mode;",
                    "        const contents =",
                    "          groupMode === MODE_BREAK ? doc.breakContents : doc.flatContents;",
                    "        if (contents) {",
                    "          cmds.push({ mode, doc: contents });",
                    "        }",
                    "        break;",
                    "      }",
                    "",
                    "      case DOC_TYPE_LINE:",
                    "        if (mode === MODE_BREAK || doc.hard) {",
                    "          return true;",
                    "        }",
                    "        if (!doc.soft) {",
                    "          out.push(\" \");",
                    "          width--;",
                    "        }",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LINE_SUFFIX:",
                    "        hasLineSuffix = true;",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "        if (hasLineSuffix) {",
                    "          return false;",
                    "        }",
                    "        break;",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function printDocToString(doc, options) {",
                    "  /** @type GroupModeMap */",
                    "  const groupModeMap = {};",
                    "",
                    "  const width = options.printWidth;",
                    "  const newLine = convertEndOfLineToChars(options.endOfLine);",
                    "  let pos = 0;",
                    "  // cmds is basically a stack. We've turned a recursive call into a",
                    "  // while loop which is much faster. The while loop below adds new",
                    "  // cmds to the array instead of recursively calling `print`.",
                    "  /** @type Command[] */",
                    "  const cmds = [{ ind: rootIndent(), mode: MODE_BREAK, doc }];",
                    "  const out = [];",
                    "  let shouldRemeasure = false;",
                    "  /** @type Command[] */",
                    "  const lineSuffix = [];",
                    "  let printedCursorCount = 0;",
                    "",
                    "  propagateBreaks(doc);",
                    "",
                    "  while (cmds.length > 0) {",
                    "    const { ind, mode, doc } = cmds.pop();",
                    "    switch (getDocType(doc)) {",
                    "      case DOC_TYPE_STRING: {",
                    "        const formatted =",
                    "          newLine !== \"\\n\" ? doc.replaceAll(\"\\n\", newLine) : doc;",
                    "        out.push(formatted);",
                    "        // Plugins may print single string, should skip measure the width",
                    "        if (cmds.length > 0) {",
                    "          pos += getStringWidth(formatted);",
                    "        }",
                    "        break;",
                    "      }",
                    "",
                    "      case DOC_TYPE_ARRAY:",
                    "        for (let i = doc.length - 1; i >= 0; i--) {",
                    "          cmds.push({ ind, mode, doc: doc[i] });",
                    "        }",
                    "        break;",
                    "",
                    "      case DOC_TYPE_CURSOR:",
                    "        if (printedCursorCount >= 2) {",
                    "          throw new Error(\"There are too many 'cursor' in doc.\");",
                    "        }",
                    "        out.push(CURSOR_PLACEHOLDER);",
                    "        printedCursorCount++;",
                    "        break;",
                    "",
                    "      case DOC_TYPE_INDENT:",
                    "        cmds.push({ ind: makeIndent(ind, options), mode, doc: doc.contents });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_ALIGN:",
                    "        cmds.push({",
                    "          ind: makeAlign(ind, doc.n, options),",
                    "          mode,",
                    "          doc: doc.contents,",
                    "        });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_TRIM:",
                    "        pos -= trim(out);",
                    "        break;",
                    "",
                    "      case DOC_TYPE_GROUP:",
                    "        switch (mode) {",
                    "          case MODE_FLAT:",
                    "            if (!shouldRemeasure) {",
                    "              cmds.push({",
                    "                ind,",
                    "                mode: doc.break ? MODE_BREAK : MODE_FLAT,",
                    "                doc: doc.contents,",
                    "              });",
                    "",
                    "              break;",
                    "            }",
                    "          // fallthrough",
                    "",
                    "          case MODE_BREAK: {",
                    "            shouldRemeasure = false;",
                    "",
                    "            const next = { ind, mode: MODE_FLAT, doc: doc.contents };",
                    "            const rem = width - pos;",
                    "            const hasLineSuffix = lineSuffix.length > 0;",
                    "",
                    "            if (",
                    "              !doc.break &&",
                    "              fits(next, cmds, rem, hasLineSuffix, groupModeMap)",
                    "            ) {",
                    "              cmds.push(next);",
                    "            } else {",
                    "              // Expanded states are a rare case where a document",
                    "              // can manually provide multiple representations of",
                    "              // itself. It provides an array of documents",
                    "              // going from the least expanded (most flattened)",
                    "              // representation first to the most expanded. If a",
                    "              // group has these, we need to manually go through",
                    "              // these states and find the first one that fits.",
                    "              // eslint-disable-next-line no-lonely-if",
                    "              if (doc.expandedStates) {",
                    "                const mostExpanded = doc.expandedStates.at(-1);",
                    "",
                    "                if (doc.break) {",
                    "                  cmds.push({ ind, mode: MODE_BREAK, doc: mostExpanded });",
                    "",
                    "                  break;",
                    "                } else {",
                    "                  for (let i = 1; i < doc.expandedStates.length + 1; i++) {",
                    "                    if (i >= doc.expandedStates.length) {",
                    "                      cmds.push({ ind, mode: MODE_BREAK, doc: mostExpanded });",
                    "",
                    "                      break;",
                    "                    } else {",
                    "                      const state = doc.expandedStates[i];",
                    "                      const cmd = { ind, mode: MODE_FLAT, doc: state };",
                    "",
                    "                      if (fits(cmd, cmds, rem, hasLineSuffix, groupModeMap)) {",
                    "                        cmds.push(cmd);",
                    "",
                    "                        break;",
                    "                      }",
                    "                    }",
                    "                  }",
                    "                }",
                    "              } else {",
                    "                cmds.push({ ind, mode: MODE_BREAK, doc: doc.contents });",
                    "              }",
                    "            }",
                    "",
                    "            break;",
                    "          }",
                    "        }",
                    "",
                    "        if (doc.id) {",
                    "          groupModeMap[doc.id] = cmds.at(-1).mode;",
                    "        }",
                    "        break;",
                    "      // Fills each line with as much code as possible before moving to a new",
                    "      // line with the same indentation.",
                    "      //",
                    "      // Expects doc.parts to be an array of alternating content and",
                    "      // whitespace. The whitespace contains the linebreaks.",
                    "      //",
                    "      // For example:",
                    "      //   [\"I\", line, \"love\", line, \"monkeys\"]",
                    "      // or",
                    "      //   [{ type: group, ... }, softline, { type: group, ... }]",
                    "      //",
                    "      // It uses this parts structure to handle three main layout cases:",
                    "      // * The first two content items fit on the same line without",
                    "      //   breaking",
                    "      //   -> output the first content item and the whitespace \"flat\".",
                    "      // * Only the first content item fits on the line without breaking",
                    "      //   -> output the first content item \"flat\" and the whitespace with",
                    "      //   \"break\".",
                    "      // * Neither content item fits on the line without breaking",
                    "      //   -> output the first content item and the whitespace with \"break\".",
                    "      case DOC_TYPE_FILL: {",
                    "        const rem = width - pos;",
                    "",
                    "        const { parts } = doc;",
                    "        if (parts.length === 0) {",
                    "          break;",
                    "        }",
                    "",
                    "        const [content, whitespace] = parts;",
                    "        const contentFlatCmd = { ind, mode: MODE_FLAT, doc: content };",
                    "        const contentBreakCmd = { ind, mode: MODE_BREAK, doc: content };",
                    "        const contentFits = fits(",
                    "          contentFlatCmd,",
                    "          [],",
                    "          rem,",
                    "          lineSuffix.length > 0,",
                    "          groupModeMap,",
                    "          true",
                    "        );",
                    "",
                    "        if (parts.length === 1) {",
                    "          if (contentFits) {",
                    "            cmds.push(contentFlatCmd);",
                    "          } else {",
                    "            cmds.push(contentBreakCmd);",
                    "          }",
                    "          break;",
                    "        }",
                    "",
                    "        const whitespaceFlatCmd = { ind, mode: MODE_FLAT, doc: whitespace };",
                    "        const whitespaceBreakCmd = { ind, mode: MODE_BREAK, doc: whitespace };",
                    "",
                    "        if (parts.length === 2) {",
                    "          if (contentFits) {",
                    "            cmds.push(whitespaceFlatCmd, contentFlatCmd);",
                    "          } else {",
                    "            cmds.push(whitespaceBreakCmd, contentBreakCmd);",
                    "          }",
                    "          break;",
                    "        }",
                    "",
                    "        // At this point we've handled the first pair (context, separator)",
                    "        // and will create a new fill doc for the rest of the content.",
                    "        // Ideally we wouldn't mutate the array here but copying all the",
                    "        // elements to a new array would make this algorithm quadratic,",
                    "        // which is unusable for large arrays (e.g. large texts in JSX).",
                    "        parts.splice(0, 2);",
                    "        const remainingCmd = { ind, mode, doc: fill(parts) };",
                    "",
                    "        const secondContent = parts[0];",
                    "",
                    "        const firstAndSecondContentFlatCmd = {",
                    "          ind,",
                    "          mode: MODE_FLAT,",
                    "          doc: [content, whitespace, secondContent],",
                    "        };",
                    "        const firstAndSecondContentFits = fits(",
                    "          firstAndSecondContentFlatCmd,",
                    "          [],",
                    "          rem,",
                    "          lineSuffix.length > 0,",
                    "          groupModeMap,",
                    "          true",
                    "        );",
                    "",
                    "        if (firstAndSecondContentFits) {",
                    "          cmds.push(remainingCmd, whitespaceFlatCmd, contentFlatCmd);",
                    "        } else if (contentFits) {",
                    "          cmds.push(remainingCmd, whitespaceBreakCmd, contentFlatCmd);",
                    "        } else {",
                    "          cmds.push(remainingCmd, whitespaceBreakCmd, contentBreakCmd);",
                    "        }",
                    "        break;",
                    "      }",
                    "      case DOC_TYPE_IF_BREAK:",
                    "      case DOC_TYPE_INDENT_IF_BREAK: {",
                    "        const groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;",
                    "        if (groupMode === MODE_BREAK) {",
                    "          const breakContents =",
                    "            doc.type === DOC_TYPE_IF_BREAK",
                    "              ? doc.breakContents",
                    "              : doc.negate",
                    "              ? doc.contents",
                    "              : indent(doc.contents);",
                    "          if (breakContents) {",
                    "            cmds.push({ ind, mode, doc: breakContents });",
                    "          }",
                    "        }",
                    "        if (groupMode === MODE_FLAT) {",
                    "          const flatContents =",
                    "            doc.type === DOC_TYPE_IF_BREAK",
                    "              ? doc.flatContents",
                    "              : doc.negate",
                    "              ? indent(doc.contents)",
                    "              : doc.contents;",
                    "          if (flatContents) {",
                    "            cmds.push({ ind, mode, doc: flatContents });",
                    "          }",
                    "        }",
                    "",
                    "        break;",
                    "      }",
                    "      case DOC_TYPE_LINE_SUFFIX:",
                    "        lineSuffix.push({ ind, mode, doc: doc.contents });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "        if (lineSuffix.length > 0) {",
                    "          cmds.push({ ind, mode, doc: hardlineWithoutBreakParent });",
                    "        }",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LINE:",
                    "        switch (mode) {",
                    "          case MODE_FLAT:",
                    "            if (!doc.hard) {",
                    "              if (!doc.soft) {",
                    "                out.push(\" \");",
                    "",
                    "                pos += 1;",
                    "              }",
                    "",
                    "              break;",
                    "            } else {",
                    "              // This line was forced into the output even if we",
                    "              // were in flattened mode, so we need to tell the next",
                    "              // group that no matter what, it needs to remeasure",
                    "              // because the previous measurement didn't accurately",
                    "              // capture the entire expression (this is necessary",
                    "              // for nested groups)",
                    "              shouldRemeasure = true;",
                    "            }",
                    "          // fallthrough",
                    "",
                    "          case MODE_BREAK:",
                    "            if (lineSuffix.length > 0) {",
                    "              cmds.push({ ind, mode, doc }, ...lineSuffix.reverse());",
                    "              lineSuffix.length = 0;",
                    "              break;",
                    "            }",
                    "",
                    "            if (doc.literal) {",
                    "              if (ind.root) {",
                    "                out.push(newLine, ind.root.value);",
                    "                pos = ind.root.length;",
                    "              } else {",
                    "                out.push(newLine);",
                    "                pos = 0;",
                    "              }",
                    "            } else {",
                    "              pos -= trim(out);",
                    "              out.push(newLine + ind.value);",
                    "              pos = ind.length;",
                    "            }",
                    "            break;",
                    "        }",
                    "        break;",
                    "",
                    "      case DOC_TYPE_LABEL:",
                    "        cmds.push({ ind, mode, doc: doc.contents });",
                    "        break;",
                    "",
                    "      case DOC_TYPE_BREAK_PARENT:",
                    "        // No op",
                    "        break;",
                    "",
                    "      default:",
                    "        throw new InvalidDocError(doc);",
                    "    }",
                    "",
                    "    // Flush remaining line-suffix contents at the end of the document, in case",
                    "    // there is no new line after the line-suffix.",
                    "    if (cmds.length === 0 && lineSuffix.length > 0) {",
                    "      cmds.push(...lineSuffix.reverse());",
                    "      lineSuffix.length = 0;",
                    "    }",
                    "  }",
                    "",
                    "  const cursorPlaceholderIndex = out.indexOf(CURSOR_PLACEHOLDER);",
                    "  if (cursorPlaceholderIndex !== -1) {",
                    "    const otherCursorPlaceholderIndex = out.indexOf(",
                    "      CURSOR_PLACEHOLDER,",
                    "      cursorPlaceholderIndex + 1",
                    "    );",
                    "    const beforeCursor = out.slice(0, cursorPlaceholderIndex).join(\"\");",
                    "    const aroundCursor = out",
                    "      .slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex)",
                    "      .join(\"\");",
                    "    const afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join(\"\");",
                    "",
                    "    return {",
                    "      formatted: beforeCursor + aroundCursor + afterCursor,",
                    "      cursorNodeStart: beforeCursor.length,",
                    "      cursorNodeText: aroundCursor,",
                    "    };",
                    "  }",
                    "",
                    "  return { formatted: out.join(\"\") };",
                    "}",
                    "",
                    "export { printDocToString };"
                ]
            },
            "public.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "// https://github.com/prettier/prettier/blob/next/src/document/public.js",
                    "export namespace builders {",
                    "  type DocCommand =",
                    "    | Align",
                    "    | BreakParent",
                    "    | Cursor",
                    "    | Fill",
                    "    | Group",
                    "    | IfBreak",
                    "    | Indent",
                    "    | IndentIfBreak",
                    "    | Label",
                    "    | Line",
                    "    | LineSuffix",
                    "    | LineSuffixBoundary",
                    "    | Trim;",
                    "  type Doc = string | Doc[] | DocCommand;",
                    "",
                    "  interface Align {",
                    "    type: \"align\";",
                    "    contents: Doc;",
                    "    n: number | string | { type: \"root\" };",
                    "  }",
                    "",
                    "  interface BreakParent {",
                    "    type: \"break-parent\";",
                    "  }",
                    "",
                    "  interface Cursor {",
                    "    type: \"cursor\";",
                    "    placeholder: symbol;",
                    "  }",
                    "",
                    "  interface Fill {",
                    "    type: \"fill\";",
                    "    parts: Doc[];",
                    "  }",
                    "",
                    "  interface Group {",
                    "    type: \"group\";",
                    "    contents: Doc;",
                    "    break: boolean;",
                    "    expandedStates: Doc[];",
                    "  }",
                    "",
                    "  interface HardlineWithoutBreakParent extends Line {",
                    "    hard: true;",
                    "  }",
                    "",
                    "  interface IfBreak {",
                    "    type: \"if-break\";",
                    "    breakContents: Doc;",
                    "    flatContents: Doc;",
                    "  }",
                    "",
                    "  interface Indent {",
                    "    type: \"indent\";",
                    "    contents: Doc;",
                    "  }",
                    "",
                    "  interface IndentIfBreak {",
                    "    type: \"indent-if-break\";",
                    "  }",
                    "",
                    "  interface Label {",
                    "    type: \"label\";",
                    "  }",
                    "",
                    "  interface Line {",
                    "    type: \"line\";",
                    "    soft?: boolean | undefined;",
                    "    hard?: boolean | undefined;",
                    "    literal?: boolean | undefined;",
                    "  }",
                    "",
                    "  interface LineSuffix {",
                    "    type: \"line-suffix\";",
                    "    contents: Doc;",
                    "  }",
                    "",
                    "  interface LineSuffixBoundary {",
                    "    type: \"line-suffix-boundary\";",
                    "  }",
                    "",
                    "  interface LiterallineWithoutBreakParent extends Line {",
                    "    hard: true;",
                    "    literal: true;",
                    "  }",
                    "",
                    "  type LiteralLine = [LiterallineWithoutBreakParent, BreakParent];",
                    "",
                    "  interface Softline extends Line {",
                    "    soft: true;",
                    "  }",
                    "",
                    "  type Hardline = [HardlineWithoutBreakParent, BreakParent];",
                    "",
                    "  interface Trim {",
                    "    type: \"trim\";",
                    "  }",
                    "",
                    "  interface GroupOptions {",
                    "    shouldBreak?: boolean | undefined;",
                    "    id?: symbol | undefined;",
                    "  }",
                    "",
                    "  function addAlignmentToDoc(doc: Doc, size: number, tabWidth: number): Doc;",
                    "",
                    "  /** @see [align](https://github.com/prettier/prettier/blob/main/commands.md#align) */",
                    "  function align(widthOrString: Align[\"n\"], doc: Doc): Align;",
                    "",
                    "  /** @see [breakParent](https://github.com/prettier/prettier/blob/main/commands.md#breakparent) */",
                    "  const breakParent: BreakParent;",
                    "",
                    "  /** @see [conditionalGroup](https://github.com/prettier/prettier/blob/main/commands.md#conditionalgroup) */",
                    "  function conditionalGroup(alternatives: Doc[], options?: GroupOptions): Group;",
                    "",
                    "  /** @see [dedent](https://github.com/prettier/prettier/blob/main/commands.md#dedent) */",
                    "  function dedent(doc: Doc): Align;",
                    "",
                    "  /** @see [dedentToRoot](https://github.com/prettier/prettier/blob/main/commands.md#dedenttoroot) */",
                    "  function dedentToRoot(doc: Doc): Align;",
                    "",
                    "  /** @see [fill](https://github.com/prettier/prettier/blob/main/commands.md#fill) */",
                    "  function fill(docs: Doc[]): Fill;",
                    "",
                    "  /** @see [group](https://github.com/prettier/prettier/blob/main/commands.md#group) */",
                    "  function group(doc: Doc, opts?: GroupOptions): Group;",
                    "",
                    "  /** @see [hardline](https://github.com/prettier/prettier/blob/main/commands.md#hardline) */",
                    "  const hardline: Hardline;",
                    "",
                    "  /** @see [hardlineWithoutBreakParent](https://github.com/prettier/prettier/blob/main/commands.md#hardlinewithoutbreakparent-and-literallinewithoutbreakparent) */",
                    "  const hardlineWithoutBreakParent: HardlineWithoutBreakParent;",
                    "",
                    "  /** @see [ifBreak](https://github.com/prettier/prettier/blob/main/commands.md#ifbreak) */",
                    "  function ifBreak(",
                    "    ifBreak: Doc,",
                    "    noBreak?: Doc,",
                    "    options?: { groupId?: symbol | undefined }",
                    "  ): IfBreak;",
                    "",
                    "  /** @see [indent](https://github.com/prettier/prettier/blob/main/commands.md#indent) */",
                    "  function indent(doc: Doc): Indent;",
                    "",
                    "  /** @see [indentIfBreak](https://github.com/prettier/prettier/blob/main/commands.md#indentifbreak) */",
                    "  function indentIfBreak(",
                    "    doc: Doc,",
                    "    opts: { groupId: symbol; negate?: boolean | undefined }",
                    "  ): IndentIfBreak;",
                    "",
                    "  /** @see [join](https://github.com/prettier/prettier/blob/main/commands.md#join) */",
                    "  function join(sep: Doc, docs: Doc[]): Doc[];",
                    "",
                    "  /** @see [label](https://github.com/prettier/prettier/blob/main/commands.md#label) */",
                    "  function label(label: any | undefined, contents: Doc): Doc;",
                    "",
                    "  /** @see [line](https://github.com/prettier/prettier/blob/main/commands.md#line) */",
                    "  const line: Line;",
                    "",
                    "  /** @see [lineSuffix](https://github.com/prettier/prettier/blob/main/commands.md#linesuffix) */",
                    "  function lineSuffix(suffix: Doc): LineSuffix;",
                    "",
                    "  /** @see [lineSuffixBoundary](https://github.com/prettier/prettier/blob/main/commands.md#linesuffixboundary) */",
                    "  const lineSuffixBoundary: LineSuffixBoundary;",
                    "",
                    "  /** @see [literalline](https://github.com/prettier/prettier/blob/main/commands.md#literalline) */",
                    "  const literalline: LiteralLine;",
                    "",
                    "  /** @see [literallineWithoutBreakParent](https://github.com/prettier/prettier/blob/main/commands.md#hardlinewithoutbreakparent-and-literallinewithoutbreakparent) */",
                    "  const literallineWithoutBreakParent: LiterallineWithoutBreakParent;",
                    "",
                    "  /** @see [markAsRoot](https://github.com/prettier/prettier/blob/main/commands.md#markasroot) */",
                    "  function markAsRoot(doc: Doc): Align;",
                    "",
                    "  /** @see [softline](https://github.com/prettier/prettier/blob/main/commands.md#softline) */",
                    "  const softline: Softline;",
                    "",
                    "  /** @see [trim](https://github.com/prettier/prettier/blob/main/commands.md#trim) */",
                    "  const trim: Trim;",
                    "",
                    "  /** @see [cursor](https://github.com/prettier/prettier/blob/main/commands.md#cursor) */",
                    "  const cursor: Cursor;",
                    "}",
                    "",
                    "export namespace printer {",
                    "  function printDocToString(",
                    "    doc: builders.Doc,",
                    "    options: Options",
                    "  ): {",
                    "    formatted: string;",
                    "    cursorNodeStart?: number | undefined;",
                    "    cursorNodeText?: string | undefined;",
                    "  };",
                    "  interface Options {",
                    "    /**",
                    "     * Specify the line length that the printer will wrap on.",
                    "     * @default 80",
                    "     */",
                    "    printWidth: number;",
                    "    /**",
                    "     * Specify the number of spaces per indentation-level.",
                    "     * @default 2",
                    "     */",
                    "    tabWidth: number;",
                    "    /**",
                    "     * Indent lines with tabs instead of spaces",
                    "     * @default false",
                    "     */",
                    "    useTabs?: boolean;",
                    "    parentParser?: string | undefined;",
                    "    __embeddedInHtml?: boolean | undefined;",
                    "  }",
                    "}",
                    "",
                    "export namespace utils {",
                    "  function willBreak(doc: builders.Doc): boolean;",
                    "  function traverseDoc(",
                    "    doc: builders.Doc,",
                    "    onEnter?: (doc: builders.Doc) => void | boolean,",
                    "    onExit?: (doc: builders.Doc) => void,",
                    "    shouldTraverseConditionalGroups?: boolean",
                    "  ): void;",
                    "  function findInDoc<T = builders.Doc>(",
                    "    doc: builders.Doc,",
                    "    callback: (doc: builders.Doc) => T,",
                    "    defaultValue: T",
                    "  ): T;",
                    "  function mapDoc<T = builders.Doc>(",
                    "    doc: builders.Doc,",
                    "    callback: (doc: builders.Doc) => T",
                    "  ): T;",
                    "  function removeLines(doc: builders.Doc): builders.Doc;",
                    "  function stripTrailingHardline(doc: builders.Doc): builders.Doc;",
                    "  function replaceEndOfLine(",
                    "    doc: builders.Doc,",
                    "    replacement?: builders.Doc",
                    "  ): builders.Doc;",
                    "  function canBreak(doc: builders.Doc): boolean;",
                    "}"
                ]
            },
            "public.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  trim,",
                    "  indent,",
                    "  indentIfBreak,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent,",
                    "  hardlineWithoutBreakParent,",
                    "  literallineWithoutBreakParent,",
                    "  label,",
                    "} from \"./builders.js\";",
                    "import { printDocToString } from \"./printer.js\";",
                    "import {",
                    "  willBreak,",
                    "  traverseDoc,",
                    "  findInDoc,",
                    "  mapDoc,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  replaceEndOfLine,",
                    "  canBreak,",
                    "} from \"./utils.js\";",
                    "",
                    "export const builders = {",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "  hardline,",
                    "  literalline,",
                    "  group,",
                    "  conditionalGroup,",
                    "  fill,",
                    "  lineSuffix,",
                    "  lineSuffixBoundary,",
                    "  cursor,",
                    "  breakParent,",
                    "  ifBreak,",
                    "  trim,",
                    "  indent,",
                    "  indentIfBreak,",
                    "  align,",
                    "  addAlignmentToDoc,",
                    "  markAsRoot,",
                    "  dedentToRoot,",
                    "  dedent,",
                    "  hardlineWithoutBreakParent,",
                    "  literallineWithoutBreakParent,",
                    "  label,",
                    "  // TODO: Remove this in v4",
                    "  concat: (parts) => parts,",
                    "};",
                    "export const printer = { printDocToString };",
                    "export const utils = {",
                    "  willBreak,",
                    "  traverseDoc,",
                    "  findInDoc,",
                    "  mapDoc,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  replaceEndOfLine,",
                    "  canBreak,",
                    "};"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  DOC_TYPE_STRING,",
                    "  DOC_TYPE_ARRAY,",
                    "  DOC_TYPE_CURSOR,",
                    "  DOC_TYPE_INDENT,",
                    "  DOC_TYPE_ALIGN,",
                    "  DOC_TYPE_TRIM,",
                    "  DOC_TYPE_GROUP,",
                    "  DOC_TYPE_FILL,",
                    "  DOC_TYPE_IF_BREAK,",
                    "  DOC_TYPE_INDENT_IF_BREAK,",
                    "  DOC_TYPE_LINE_SUFFIX,",
                    "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                    "  DOC_TYPE_LINE,",
                    "  DOC_TYPE_LABEL,",
                    "  DOC_TYPE_BREAK_PARENT,",
                    "} from \"./constants.js\";",
                    "import { literalline, join } from \"./builders.js\";",
                    "import getDocType from \"./utils/get-doc-type.js\";",
                    "import traverseDoc from \"./utils/traverse-doc.js\";",
                    "import InvalidDocError from \"./invalid-doc-error.js\";",
                    "",
                    "const getDocParts = (doc) => {",
                    "  if (Array.isArray(doc)) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  /* c8 ignore next 3 */",
                    "  if (doc.type !== DOC_TYPE_FILL) {",
                    "    throw new Error(`Expect doc to be 'array' or '${DOC_TYPE_FILL}'.`);",
                    "  }",
                    "",
                    "  return doc.parts;",
                    "};",
                    "",
                    "function mapDoc(doc, cb) {",
                    "  // Avoid creating `Map`",
                    "  if (typeof doc === \"string\") {",
                    "    return cb(doc);",
                    "  }",
                    "",
                    "  // Within a doc tree, the same subtrees can be found multiple times.",
                    "  // E.g., often this happens in conditional groups.",
                    "  // As an optimization (those subtrees can be huge) and to maintain the",
                    "  // reference structure of the tree, the mapping results are cached in",
                    "  // a map and reused.",
                    "  const mapped = new Map();",
                    "",
                    "  return rec(doc);",
                    "",
                    "  function rec(doc) {",
                    "    if (mapped.has(doc)) {",
                    "      return mapped.get(doc);",
                    "    }",
                    "    const result = process(doc);",
                    "    mapped.set(doc, result);",
                    "    return result;",
                    "  }",
                    "",
                    "  function process(doc) {",
                    "    switch (getDocType(doc)) {",
                    "      case DOC_TYPE_ARRAY:",
                    "        return cb(doc.map(rec));",
                    "",
                    "      case DOC_TYPE_FILL:",
                    "        return cb({ ...doc, parts: doc.parts.map(rec) });",
                    "",
                    "      case DOC_TYPE_IF_BREAK:",
                    "        return cb({",
                    "          ...doc,",
                    "          breakContents: rec(doc.breakContents),",
                    "          flatContents: rec(doc.flatContents),",
                    "        });",
                    "",
                    "      case DOC_TYPE_GROUP: {",
                    "        let { expandedStates, contents } = doc;",
                    "        if (expandedStates) {",
                    "          expandedStates = expandedStates.map(rec);",
                    "          contents = expandedStates[0];",
                    "        } else {",
                    "          contents = rec(contents);",
                    "        }",
                    "        return cb({ ...doc, contents, expandedStates });",
                    "      }",
                    "",
                    "      case DOC_TYPE_ALIGN:",
                    "      case DOC_TYPE_INDENT:",
                    "      case DOC_TYPE_INDENT_IF_BREAK:",
                    "      case DOC_TYPE_LABEL:",
                    "      case DOC_TYPE_LINE_SUFFIX:",
                    "        return cb({ ...doc, contents: rec(doc.contents) });",
                    "",
                    "      case DOC_TYPE_STRING:",
                    "      case DOC_TYPE_CURSOR:",
                    "      case DOC_TYPE_TRIM:",
                    "      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "      case DOC_TYPE_LINE:",
                    "      case DOC_TYPE_BREAK_PARENT:",
                    "        return cb(doc);",
                    "",
                    "      default:",
                    "        /* c8 ignore next 3 */",
                    "        throw new InvalidDocError(doc);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function findInDoc(doc, fn, defaultValue) {",
                    "  let result = defaultValue;",
                    "  let shouldSkipFurtherProcessing = false;",
                    "  function findInDocOnEnterFn(doc) {",
                    "    if (shouldSkipFurtherProcessing) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const maybeResult = fn(doc);",
                    "    if (maybeResult !== undefined) {",
                    "      shouldSkipFurtherProcessing = true;",
                    "      result = maybeResult;",
                    "    }",
                    "  }",
                    "  traverseDoc(doc, findInDocOnEnterFn);",
                    "  return result;",
                    "}",
                    "",
                    "function willBreakFn(doc) {",
                    "  if (doc.type === DOC_TYPE_GROUP && doc.break) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === DOC_TYPE_LINE && doc.hard) {",
                    "    return true;",
                    "  }",
                    "  if (doc.type === DOC_TYPE_BREAK_PARENT) {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function willBreak(doc) {",
                    "  return findInDoc(doc, willBreakFn, false);",
                    "}",
                    "",
                    "function breakParentGroup(groupStack) {",
                    "  if (groupStack.length > 0) {",
                    "    const parentGroup = groupStack.at(-1);",
                    "    // Breaks are not propagated through conditional groups because",
                    "    // the user is expected to manually handle what breaks.",
                    "    if (!parentGroup.expandedStates && !parentGroup.break) {",
                    "      // An alternative truthy value allows to distinguish propagated group breaks",
                    "      // and not to print them as `group(..., { break: true })` in `--debug-print-doc`.",
                    "      parentGroup.break = \"propagated\";",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function propagateBreaks(doc) {",
                    "  const alreadyVisitedSet = new Set();",
                    "  const groupStack = [];",
                    "  function propagateBreaksOnEnterFn(doc) {",
                    "    if (doc.type === DOC_TYPE_BREAK_PARENT) {",
                    "      breakParentGroup(groupStack);",
                    "    }",
                    "    if (doc.type === DOC_TYPE_GROUP) {",
                    "      groupStack.push(doc);",
                    "      if (alreadyVisitedSet.has(doc)) {",
                    "        return false;",
                    "      }",
                    "      alreadyVisitedSet.add(doc);",
                    "    }",
                    "  }",
                    "  function propagateBreaksOnExitFn(doc) {",
                    "    if (doc.type === DOC_TYPE_GROUP) {",
                    "      const group = groupStack.pop();",
                    "      if (group.break) {",
                    "        breakParentGroup(groupStack);",
                    "      }",
                    "    }",
                    "  }",
                    "  traverseDoc(",
                    "    doc,",
                    "    propagateBreaksOnEnterFn,",
                    "    propagateBreaksOnExitFn,",
                    "    /* shouldTraverseConditionalGroups */ true",
                    "  );",
                    "}",
                    "",
                    "function removeLinesFn(doc) {",
                    "  // Force this doc into flat mode by statically converting all",
                    "  // lines into spaces (or soft lines into nothing). Hard lines",
                    "  // should still output because there's too great of a chance",
                    "  // of breaking existing assumptions otherwise.",
                    "  if (doc.type === DOC_TYPE_LINE && !doc.hard) {",
                    "    return doc.soft ? \"\" : \" \";",
                    "  }",
                    "",
                    "  if (doc.type === DOC_TYPE_IF_BREAK) {",
                    "    return doc.flatContents;",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function removeLines(doc) {",
                    "  return mapDoc(doc, removeLinesFn);",
                    "}",
                    "",
                    "function stripTrailingHardlineFromParts(parts) {",
                    "  parts = [...parts];",
                    "",
                    "  while (",
                    "    parts.length >= 2 &&",
                    "    parts.at(-2).type === DOC_TYPE_LINE &&",
                    "    parts.at(-1).type === DOC_TYPE_BREAK_PARENT",
                    "  ) {",
                    "    parts.length -= 2;",
                    "  }",
                    "",
                    "  if (parts.length > 0) {",
                    "    const lastPart = stripTrailingHardlineFromDoc(parts.at(-1));",
                    "    parts[parts.length - 1] = lastPart;",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function stripTrailingHardlineFromDoc(doc) {",
                    "  switch (getDocType(doc)) {",
                    "    case DOC_TYPE_ALIGN:",
                    "    case DOC_TYPE_INDENT:",
                    "    case DOC_TYPE_INDENT_IF_BREAK:",
                    "    case DOC_TYPE_GROUP:",
                    "    case DOC_TYPE_LINE_SUFFIX:",
                    "    case DOC_TYPE_LABEL: {",
                    "      const contents = stripTrailingHardlineFromDoc(doc.contents);",
                    "      return { ...doc, contents };",
                    "    }",
                    "",
                    "    case DOC_TYPE_IF_BREAK:",
                    "      return {",
                    "        ...doc,",
                    "        breakContents: stripTrailingHardlineFromDoc(doc.breakContents),",
                    "        flatContents: stripTrailingHardlineFromDoc(doc.flatContents),",
                    "      };",
                    "",
                    "    case DOC_TYPE_FILL:",
                    "      return { ...doc, parts: stripTrailingHardlineFromParts(doc.parts) };",
                    "",
                    "    case DOC_TYPE_ARRAY:",
                    "      return stripTrailingHardlineFromParts(doc);",
                    "",
                    "    case DOC_TYPE_STRING:",
                    "      return doc.replace(/[\\n\\r]*$/, \"\");",
                    "",
                    "    case DOC_TYPE_CURSOR:",
                    "    case DOC_TYPE_TRIM:",
                    "    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "    case DOC_TYPE_LINE:",
                    "    case DOC_TYPE_BREAK_PARENT:",
                    "      // No op",
                    "      break;",
                    "",
                    "    default:",
                    "      throw new InvalidDocError(doc);",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "function stripTrailingHardline(doc) {",
                    "  // HACK remove ending hardline, original PR: #1984",
                    "  return stripTrailingHardlineFromDoc(cleanDoc(doc));",
                    "}",
                    "",
                    "function cleanDocFn(doc) {",
                    "  switch (getDocType(doc)) {",
                    "    case DOC_TYPE_FILL:",
                    "      if (doc.parts.every((part) => part === \"\")) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case DOC_TYPE_GROUP:",
                    "      if (!doc.contents && !doc.id && !doc.break && !doc.expandedStates) {",
                    "        return \"\";",
                    "      }",
                    "      // Remove nested only group",
                    "      if (",
                    "        doc.contents.type === DOC_TYPE_GROUP &&",
                    "        doc.contents.id === doc.id &&",
                    "        doc.contents.break === doc.break &&",
                    "        doc.contents.expandedStates === doc.expandedStates",
                    "      ) {",
                    "        return doc.contents;",
                    "      }",
                    "      break;",
                    "    case DOC_TYPE_ALIGN:",
                    "    case DOC_TYPE_INDENT:",
                    "    case DOC_TYPE_INDENT_IF_BREAK:",
                    "    case DOC_TYPE_LINE_SUFFIX:",
                    "      if (!doc.contents) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case DOC_TYPE_IF_BREAK:",
                    "      if (!doc.flatContents && !doc.breakContents) {",
                    "        return \"\";",
                    "      }",
                    "      break;",
                    "    case DOC_TYPE_ARRAY: {",
                    "      // Flat array, concat strings",
                    "      const parts = [];",
                    "      for (const part of doc) {",
                    "        if (!part) {",
                    "          continue;",
                    "        }",
                    "        const [currentPart, ...restParts] = Array.isArray(part) ? part : [part];",
                    "        if (",
                    "          typeof currentPart === \"string\" &&",
                    "          typeof parts.at(-1) === \"string\"",
                    "        ) {",
                    "          parts[parts.length - 1] += currentPart;",
                    "        } else {",
                    "          parts.push(currentPart);",
                    "        }",
                    "        parts.push(...restParts);",
                    "      }",
                    "",
                    "      if (parts.length === 0) {",
                    "        return \"\";",
                    "      }",
                    "",
                    "      if (parts.length === 1) {",
                    "        return parts[0];",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    case DOC_TYPE_STRING:",
                    "    case DOC_TYPE_CURSOR:",
                    "    case DOC_TYPE_TRIM:",
                    "    case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                    "    case DOC_TYPE_LINE:",
                    "    case DOC_TYPE_LABEL:",
                    "    case DOC_TYPE_BREAK_PARENT:",
                    "      // No op",
                    "      break;",
                    "    default:",
                    "      /* c8 ignore next 3 */",
                    "      throw new InvalidDocError(doc);",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "// A safer version of `normalizeDoc`",
                    "// - `normalizeDoc` concat strings and flat array in `fill`, while `cleanDoc` don't",
                    "// - On array, `normalizeDoc` always return object with `parts`, `cleanDoc` may return strings",
                    "// - `cleanDoc` also remove nested `group`s and empty `fill`/`align`/`indent`/`line-suffix`/`if-break` if possible",
                    "function cleanDoc(doc) {",
                    "  return mapDoc(doc, (currentDoc) => cleanDocFn(currentDoc));",
                    "}",
                    "",
                    "function normalizeParts(parts) {",
                    "  const newParts = [];",
                    "",
                    "  const restParts = parts.filter(Boolean);",
                    "  while (restParts.length > 0) {",
                    "    const part = restParts.shift();",
                    "",
                    "    if (!part) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (Array.isArray(part)) {",
                    "      restParts.unshift(...part);",
                    "      continue;",
                    "    }",
                    "",
                    "    if (",
                    "      newParts.length > 0 &&",
                    "      typeof newParts.at(-1) === \"string\" &&",
                    "      typeof part === \"string\"",
                    "    ) {",
                    "      newParts[newParts.length - 1] += part;",
                    "      continue;",
                    "    }",
                    "",
                    "    newParts.push(part);",
                    "  }",
                    "",
                    "  return newParts;",
                    "}",
                    "",
                    "function normalizeDoc(doc) {",
                    "  return mapDoc(doc, (currentDoc) => {",
                    "    if (Array.isArray(currentDoc)) {",
                    "      return normalizeParts(currentDoc);",
                    "    }",
                    "    if (!currentDoc.parts) {",
                    "      return currentDoc;",
                    "    }",
                    "    return {",
                    "      ...currentDoc,",
                    "      parts: normalizeParts(currentDoc.parts),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "function replaceEndOfLine(doc, replacement = literalline) {",
                    "  return mapDoc(doc, (currentDoc) =>",
                    "    typeof currentDoc === \"string\"",
                    "      ? join(replacement, currentDoc.split(\"\\n\"))",
                    "      : currentDoc",
                    "  );",
                    "}",
                    "",
                    "function canBreakFn(doc) {",
                    "  if (doc.type === DOC_TYPE_LINE) {",
                    "    return true;",
                    "  }",
                    "}",
                    "",
                    "function canBreak(doc) {",
                    "  return findInDoc(doc, canBreakFn, false);",
                    "}",
                    "",
                    "function inheritLabel(doc, fn) {",
                    "  return doc.type === DOC_TYPE_LABEL",
                    "    ? { ...doc, contents: fn(doc.contents) }",
                    "    : fn(doc);",
                    "}",
                    "",
                    "export {",
                    "  getDocParts,",
                    "  willBreak,",
                    "  traverseDoc,",
                    "  findInDoc,",
                    "  mapDoc,",
                    "  propagateBreaks,",
                    "  removeLines,",
                    "  stripTrailingHardline,",
                    "  normalizeParts,",
                    "  normalizeDoc,",
                    "  cleanDoc,",
                    "  replaceEndOfLine,",
                    "  canBreak,",
                    "  getDocType,",
                    "  inheritLabel,",
                    "};"
                ]
            },
            "utils": {
                "assert-doc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import traverseDoc from \"./traverse-doc.js\";",
                        "",
                        "const checked = process.env.NODE_ENV !== \"production\" && new WeakSet();",
                        "const noop = () => {};",
                        "const assertDoc =",
                        "  process.env.NODE_ENV === \"production\"",
                        "    ? noop",
                        "    : function (doc) {",
                        "        traverseDoc(doc, (doc) => {",
                        "          if (checked.has(doc)) {",
                        "            return false;",
                        "          }",
                        "",
                        "          if (typeof doc !== \"string\") {",
                        "            checked.add(doc);",
                        "          }",
                        "        });",
                        "      };",
                        "",
                        "const assertDocArray =",
                        "  process.env.NODE_ENV === \"production\"",
                        "    ? noop",
                        "    : function (docs, optional = false) {",
                        "        if (optional && !docs) {",
                        "          return;",
                        "        }",
                        "",
                        "        if (!Array.isArray(docs)) {",
                        "          throw new TypeError(\"Unexpected doc array.\");",
                        "        }",
                        "",
                        "        for (const doc of docs) {",
                        "          assertDoc(doc);",
                        "        }",
                        "      };",
                        "",
                        "export { assertDoc, assertDocArray };"
                    ]
                },
                "get-doc-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  DOC_TYPE_STRING,",
                        "  DOC_TYPE_ARRAY,",
                        "  VALID_OBJECT_DOC_TYPES,",
                        "} from \"../constants.js\";",
                        "",
                        "function getDocType(doc) {",
                        "  if (typeof doc === \"string\") {",
                        "    return DOC_TYPE_STRING;",
                        "  }",
                        "",
                        "  if (Array.isArray(doc)) {",
                        "    return DOC_TYPE_ARRAY;",
                        "  }",
                        "",
                        "  if (!doc) {",
                        "    return;",
                        "  }",
                        "",
                        "  const { type } = doc;",
                        "",
                        "  if (VALID_OBJECT_DOC_TYPES.has(type)) {",
                        "    return type;",
                        "  }",
                        "}",
                        "",
                        "export default getDocType;"
                    ]
                },
                "traverse-doc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  DOC_TYPE_STRING,",
                        "  DOC_TYPE_ARRAY,",
                        "  DOC_TYPE_CURSOR,",
                        "  DOC_TYPE_INDENT,",
                        "  DOC_TYPE_ALIGN,",
                        "  DOC_TYPE_TRIM,",
                        "  DOC_TYPE_GROUP,",
                        "  DOC_TYPE_FILL,",
                        "  DOC_TYPE_IF_BREAK,",
                        "  DOC_TYPE_INDENT_IF_BREAK,",
                        "  DOC_TYPE_LINE_SUFFIX,",
                        "  DOC_TYPE_LINE_SUFFIX_BOUNDARY,",
                        "  DOC_TYPE_LINE,",
                        "  DOC_TYPE_LABEL,",
                        "  DOC_TYPE_BREAK_PARENT,",
                        "} from \"../constants.js\";",
                        "import InvalidDocError from \"../invalid-doc-error.js\";",
                        "import getDocType from \"./get-doc-type.js\";",
                        "",
                        "// Using a unique object to compare by reference.",
                        "const traverseDocOnExitStackMarker = {};",
                        "",
                        "function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {",
                        "  const docsStack = [doc];",
                        "",
                        "  while (docsStack.length > 0) {",
                        "    const doc = docsStack.pop();",
                        "",
                        "    if (doc === traverseDocOnExitStackMarker) {",
                        "      onExit(docsStack.pop());",
                        "      continue;",
                        "    }",
                        "",
                        "    if (onExit) {",
                        "      docsStack.push(doc, traverseDocOnExitStackMarker);",
                        "    }",
                        "",
                        "    const docType = getDocType(doc);",
                        "    if (!docType) {",
                        "      throw new InvalidDocError(doc);",
                        "    }",
                        "",
                        "    // Should Recurse",
                        "    if (onEnter?.(doc) === false) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // When there are multiple parts to process,",
                        "    // the parts need to be pushed onto the stack in reverse order,",
                        "    // so that they are processed in the original order",
                        "    // when the stack is popped.",
                        "",
                        "    switch (docType) {",
                        "      case DOC_TYPE_ARRAY:",
                        "      case DOC_TYPE_FILL: {",
                        "        const parts = docType === DOC_TYPE_ARRAY ? doc : doc.parts;",
                        "        for (let ic = parts.length, i = ic - 1; i >= 0; --i) {",
                        "          docsStack.push(parts[i]);",
                        "        }",
                        "        break;",
                        "      }",
                        "",
                        "      case DOC_TYPE_IF_BREAK:",
                        "        docsStack.push(doc.flatContents, doc.breakContents);",
                        "        break;",
                        "",
                        "      case DOC_TYPE_GROUP:",
                        "        if (shouldTraverseConditionalGroups && doc.expandedStates) {",
                        "          for (let ic = doc.expandedStates.length, i = ic - 1; i >= 0; --i) {",
                        "            docsStack.push(doc.expandedStates[i]);",
                        "          }",
                        "        } else {",
                        "          docsStack.push(doc.contents);",
                        "        }",
                        "        break;",
                        "",
                        "      case DOC_TYPE_ALIGN:",
                        "      case DOC_TYPE_INDENT:",
                        "      case DOC_TYPE_INDENT_IF_BREAK:",
                        "      case DOC_TYPE_LABEL:",
                        "      case DOC_TYPE_LINE_SUFFIX:",
                        "        docsStack.push(doc.contents);",
                        "        break;",
                        "",
                        "      case DOC_TYPE_STRING:",
                        "      case DOC_TYPE_CURSOR:",
                        "      case DOC_TYPE_TRIM:",
                        "      case DOC_TYPE_LINE_SUFFIX_BOUNDARY:",
                        "      case DOC_TYPE_LINE:",
                        "      case DOC_TYPE_BREAK_PARENT:",
                        "        // No children",
                        "        break;",
                        "",
                        "      default:",
                        "        throw new InvalidDocError(doc);",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "export default traverseDoc;"
                    ]
                }
            }
        },
        "language-css": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isFrontMatter from \"../utils/front-matter/is-front-matter.js\";",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"raw\", // front-matter",
                    "  \"raws\",",
                    "  \"sourceIndex\",",
                    "  \"source\",",
                    "  \"before\",",
                    "  \"after\",",
                    "  \"trailingComma\",",
                    "  \"spaces\",",
                    "]);",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  if (isFrontMatter(ast) && ast.lang === \"yaml\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"css-comment\" &&",
                    "    parent.type === \"css-root\" &&",
                    "    parent.nodes.length > 0",
                    "  ) {",
                    "    // --insert-pragma",
                    "    // first non-front-matter comment",
                    "    if (",
                    "      parent.nodes[0] === ast ||",
                    "      (isFrontMatter(parent.nodes[0]) && parent.nodes[1] === ast)",
                    "    ) {",
                    "      /**",
                    "       * something",
                    "       *",
                    "       * @format",
                    "       */",
                    "      delete newObj.text;",
                    "",
                    "      // standalone pragma",
                    "      if (/^\\*\\s*@(?:format|prettier)\\s*$/.test(ast.text)) {",
                    "        return null;",
                    "      }",
                    "    }",
                    "",
                    "    // Last comment is not parsed, when omitting semicolon, #8675",
                    "    if (parent.type === \"css-root\" && parent.nodes.at(-1) === ast) {",
                    "      return null;",
                    "    }",
                    "  }",
                    "",
                    "  if (ast.type === \"value-root\") {",
                    "    delete newObj.text;",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"media-query\" ||",
                    "    ast.type === \"media-query-list\" ||",
                    "    ast.type === \"media-feature-expression\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"css-rule\") {",
                    "    delete newObj.params;",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-combinator\") {",
                    "    newObj.value = newObj.value.replaceAll(/\\s+/g, \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"media-feature\") {",
                    "    newObj.value = newObj.value.replaceAll(\" \", \"\");",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"value-word\" &&",
                    "      ((ast.isColor && ast.isHex) ||",
                    "        [\"initial\", \"inherit\", \"unset\", \"revert\"].includes(",
                    "          newObj.value.toLowerCase()",
                    "        ))) ||",
                    "    ast.type === \"media-feature\" ||",
                    "    ast.type === \"selector-root-invalid\" ||",
                    "    ast.type === \"selector-pseudo\"",
                    "  ) {",
                    "    newObj.value = newObj.value.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-decl\") {",
                    "    newObj.prop = newObj.prop.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"css-atrule\" || ast.type === \"css-import\") {",
                    "    newObj.name = newObj.name.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"value-number\") {",
                    "    newObj.unit = newObj.unit.toLowerCase();",
                    "  }",
                    "  if (ast.type === \"value-unknown\") {",
                    "    newObj.value = newObj.value.replaceAll(/;$/g, \"\");",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-feature\" ||",
                    "      ast.type === \"media-keyword\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"media-unknown\" ||",
                    "      ast.type === \"media-url\" ||",
                    "      ast.type === \"media-value\" ||",
                    "      ast.type === \"selector-attribute\" ||",
                    "      ast.type === \"selector-string\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"value-string\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = cleanCSSStrings(newObj.value);",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-attribute\") {",
                    "    newObj.attribute = newObj.attribute.trim();",
                    "",
                    "    if (newObj.namespace && typeof newObj.namespace === \"string\") {",
                    "      newObj.namespace = newObj.namespace.trim();",
                    "",
                    "      if (newObj.namespace.length === 0) {",
                    "        newObj.namespace = true;",
                    "      }",
                    "    }",
                    "",
                    "    if (newObj.value) {",
                    "      newObj.value = newObj.value.trim().replaceAll(/^[\"']|[\"']$/g, \"\");",
                    "      delete newObj.quoted;",
                    "    }",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"media-value\" ||",
                    "      ast.type === \"media-type\" ||",
                    "      ast.type === \"value-number\" ||",
                    "      ast.type === \"selector-root-invalid\" ||",
                    "      ast.type === \"selector-class\" ||",
                    "      ast.type === \"selector-combinator\" ||",
                    "      ast.type === \"selector-tag\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = newObj.value.replaceAll(",
                    "      /([\\d+.Ee-]+)([A-Za-z]*)/g,",
                    "      (match, numStr, unit) => {",
                    "        const num = Number(numStr);",
                    "        return Number.isNaN(num) ? match : num + unit.toLowerCase();",
                    "      }",
                    "    );",
                    "  }",
                    "",
                    "  if (ast.type === \"selector-tag\") {",
                    "    const lowercasedValue = ast.value.toLowerCase();",
                    "",
                    "    if ([\"from\", \"to\"].includes(lowercasedValue)) {",
                    "      newObj.value = lowercasedValue;",
                    "    }",
                    "  }",
                    "",
                    "  // Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`",
                    "  if (ast.type === \"css-atrule\" && ast.name.toLowerCase() === \"supports\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // Workaround for SCSS nested properties",
                    "  if (ast.type === \"selector-unknown\") {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  // Workaround for SCSS arbitrary arguments",
                    "  if (ast.type === \"value-comma_group\") {",
                    "    const index = ast.groups.findIndex(",
                    "      (node) => node.type === \"value-number\" && node.unit === \"...\"",
                    "    );",
                    "",
                    "    if (index !== -1) {",
                    "      newObj.groups[index].unit = \"\";",
                    "      newObj.groups.splice(index + 1, 0, {",
                    "        type: \"value-word\",",
                    "        value: \"...\",",
                    "        isColor: false,",
                    "        isHex: false,",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  // We parse `@var[ foo ]` and `@var[foo]` differently",
                    "  if (",
                    "    ast.type === \"value-comma_group\" &&",
                    "    ast.groups.some(",
                    "      (node) =>",
                    "        (node.type === \"value-atword\" && node.value.endsWith(\"[\")) ||",
                    "        (node.type === \"value-word\" && node.value.startsWith(\"]\"))",
                    "    )",
                    "  ) {",
                    "    return {",
                    "      type: \"value-atword\",",
                    "      value: ast.groups.map((node) => node.value).join(\"\"),",
                    "      group: {",
                    "        open: null,",
                    "        close: null,",
                    "        groups: [],",
                    "        type: \"value-paren_group\",",
                    "      },",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "function cleanCSSStrings(value) {",
                    "  return value.replaceAll(\"'\", '\"').replaceAll(/\\\\([^\\dA-Fa-f])/g, \"$1\");",
                    "}",
                    "",
                    "export default clean;"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { hardline } from \"../document/builders.js\";",
                    "import printFrontMatter from \"../utils/front-matter/print.js\";",
                    "",
                    "function embed(path) {",
                    "  const { node } = path;",
                    "",
                    "  if (node.type === \"front-matter\") {",
                    "    return async (textToDoc) => {",
                    "      const doc = await printFrontMatter(node, textToDoc);",
                    "      return doc ? [doc, hardline] : undefined;",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "// `front-matter` only available on `css-root`",
                    "embed.getVisitorKeys = (node) =>",
                    "  node.type === \"css-root\" ? [\"frontMatter\"] : [];",
                    "",
                    "export default embed;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-postcss.js\";",
                    "",
                    "export const printers = {",
                    "  postcss: printer,",
                    "};",
                    "export const parsers = createParsers(",
                    "  // TODO: switch these to just `postcss` and use `language` instead.",
                    "  [",
                    "    {",
                    "      importParsers: () => import(\"./parser-postcss.js\"),",
                    "      parserNames: [\"css\", \"less\", \"scss\"],",
                    "    },",
                    "  ]",
                    ");",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.CSS, (data) => ({",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"css\"],",
                    "    extensions: [",
                    "      ...data.extensions,",
                    "      // `WeiXin Style Sheets`(Weixin Mini Programs)",
                    "      // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                    "      \".wxss\",",
                    "    ],",
                    "  })),",
                    "  createLanguage(linguistLanguages.PostCSS, () => ({",
                    "    parsers: [\"css\"],",
                    "    vscodeLanguageIds: [\"postcss\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.Less, () => ({",
                    "    parsers: [\"less\"],",
                    "    vscodeLanguageIds: [\"less\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.SCSS, () => ({",
                    "    parsers: [\"scss\"],",
                    "    vscodeLanguageIds: [\"scss\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { skipEverythingButNewLine } from \"../utils/skip.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import lineColumnToIndex from \"../utils/line-column-to-index.js\";",
                    "",
                    "function calculateLocStart(node, text) {",
                    "  // `postcss>=8`",
                    "  if (typeof node.source?.start?.offset === \"number\") {",
                    "    return node.source.start.offset;",
                    "  }",
                    "",
                    "  // value-* nodes have this",
                    "  if (typeof node.sourceIndex === \"number\") {",
                    "    return node.sourceIndex;",
                    "  }",
                    "",
                    "  if (node.source?.start) {",
                    "    return lineColumnToIndex(node.source.start, text);",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  throw Object.assign(new Error(\"Can not locate node.\"), { node });",
                    "}",
                    "",
                    "function calculateLocEnd(node, text) {",
                    "  if (node.type === \"css-comment\" && node.inline) {",
                    "    return skipEverythingButNewLine(text, node.source.startOffset);",
                    "  }",
                    "",
                    "  // `postcss>=8`",
                    "  if (typeof node.source?.end?.offset === \"number\") {",
                    "    // https://github.com/postcss/postcss/issues/1450",
                    "    return node.source.end.offset + 1;",
                    "  }",
                    "",
                    "  if (node.source) {",
                    "    if (node.source.end) {",
                    "      return lineColumnToIndex(node.source.end, text);",
                    "    }",
                    "",
                    "    if (isNonEmptyArray(node.nodes)) {",
                    "      return calculateLocEnd(node.nodes.at(-1), text);",
                    "    }",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "function calculateLoc(node, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text);",
                    "    node.source.endOffset = calculateLocEnd(node, text);",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (child.type === \"value-root\" || child.type === \"value-unknown\") {",
                    "      calculateValueNodeLoc(",
                    "        child,",
                    "        getValueRootOffset(node),",
                    "        child.text || child.value",
                    "      );",
                    "    } else {",
                    "      calculateLoc(child, text);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function calculateValueNodeLoc(node, rootOffset, text) {",
                    "  if (node.source) {",
                    "    node.source.startOffset = calculateLocStart(node, text) + rootOffset;",
                    "    node.source.endOffset = calculateLocEnd(node, text) + rootOffset;",
                    "  }",
                    "",
                    "  for (const key in node) {",
                    "    const child = node[key];",
                    "",
                    "    if (key === \"source\" || !child || typeof child !== \"object\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    calculateValueNodeLoc(child, rootOffset, text);",
                    "  }",
                    "}",
                    "",
                    "function getValueRootOffset(node) {",
                    "  let result = node.source.startOffset;",
                    "  if (typeof node.prop === \"string\") {",
                    "    result += node.prop.length;",
                    "  }",
                    "",
                    "  if (node.type === \"css-atrule\" && typeof node.name === \"string\") {",
                    "    result +=",
                    "      1 + node.name.length + node.raws.afterName.match(/^\\s*:?\\s*/)[0].length;",
                    "  }",
                    "",
                    "  if (node.type !== \"css-atrule\" && typeof node.raws?.between === \"string\") {",
                    "    result += node.raws.between.length;",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "/**",
                    " * Workaround for a bug: quotes and asterisks in inline comments corrupt loc data of subsequent nodes.",
                    " * This function replaces the quotes and asterisks with spaces. Later, when the comments are printed,",
                    " * their content is extracted from the original text.",
                    " * - https://github.com/prettier/prettier/issues/7780",
                    " * - https://github.com/shellscape/postcss-less/issues/145",
                    " * - https://github.com/prettier/prettier/issues/8130",
                    " * @param text {string}",
                    " */",
                    "function replaceQuotesInInlineComments(text) {",
                    "  /** @typedef { 'initial' | 'single-quotes' | 'double-quotes' | 'url' | 'comment-block' | 'comment-inline' } State */",
                    "  /** @type {State} */",
                    "  let state = \"initial\";",
                    "  /** @type {State} */",
                    "  let stateToReturnFromQuotes = \"initial\";",
                    "  let inlineCommentStartIndex;",
                    "  let inlineCommentContainsQuotes = false;",
                    "  const inlineCommentsToReplace = [];",
                    "",
                    "  for (let i = 0; i < text.length; i++) {",
                    "    const c = text[i];",
                    "",
                    "    switch (state) {",
                    "      case \"initial\":",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (",
                    "          (c === \"u\" || c === \"U\") &&",
                    "          text.slice(i, i + 4).toLowerCase() === \"url(\"",
                    "        ) {",
                    "          state = \"url\";",
                    "          i += 3;",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"*\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-block\";",
                    "          continue;",
                    "        }",
                    "",
                    "        if (c === \"/\" && text[i - 1] === \"/\") {",
                    "          state = \"comment-inline\";",
                    "          inlineCommentStartIndex = i - 1;",
                    "          continue;",
                    "        }",
                    "",
                    "        continue;",
                    "",
                    "      case \"single-quotes\":",
                    "        if (c === \"'\" && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"double-quotes\":",
                    "        if (c === '\"' && text[i - 1] !== \"\\\\\") {",
                    "          state = stateToReturnFromQuotes;",
                    "          stateToReturnFromQuotes = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"url\":",
                    "        if (c === \")\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          return text; // invalid input",
                    "        }",
                    "        if (c === \"'\") {",
                    "          state = \"single-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        if (c === '\"') {",
                    "          state = \"double-quotes\";",
                    "          stateToReturnFromQuotes = \"url\";",
                    "          continue;",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-block\":",
                    "        if (c === \"/\" && text[i - 1] === \"*\") {",
                    "          state = \"initial\";",
                    "        }",
                    "        continue;",
                    "",
                    "      case \"comment-inline\":",
                    "        if (c === '\"' || c === \"'\" || c === \"*\") {",
                    "          inlineCommentContainsQuotes = true;",
                    "        }",
                    "        if (c === \"\\n\" || c === \"\\r\") {",
                    "          if (inlineCommentContainsQuotes) {",
                    "            inlineCommentsToReplace.push([inlineCommentStartIndex, i]);",
                    "          }",
                    "          state = \"initial\";",
                    "          inlineCommentContainsQuotes = false;",
                    "        }",
                    "        continue;",
                    "    }",
                    "  }",
                    "",
                    "  for (const [start, end] of inlineCommentsToReplace) {",
                    "    text =",
                    "      text.slice(0, start) +",
                    "      text.slice(start, end).replaceAll(/[\"'*]/g, \" \") +",
                    "      text.slice(end);",
                    "  }",
                    "",
                    "  return text;",
                    "}",
                    "",
                    "function locStart(node) {",
                    "  return node.source?.startOffset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.source?.endOffset;",
                    "}",
                    "",
                    "export { locStart, locEnd, calculateLoc, replaceQuotesInInlineComments };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import postcssParse from \"postcss/lib/parse\";",
                    "import postcssLess from \"postcss-less\";",
                    "import postcssScssParse from \"postcss-scss/lib/scss-parse\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import parseFrontMatter from \"../utils/front-matter/parse.js\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import {",
                    "  locStart,",
                    "  locEnd,",
                    "  calculateLoc,",
                    "  replaceQuotesInInlineComments,",
                    "} from \"./loc.js\";",
                    "import isSCSSNestedPropertyNode from \"./utils/is-scss-nested-property-node.js\";",
                    "import isModuleRuleName from \"./utils/is-module-rule-name.js\";",
                    "import parseValue from \"./parse/parse-value.js\";",
                    "import parseSelector from \"./parse/parse-selector.js\";",
                    "import parseMediaQuery from \"./parse/parse-media-query.js\";",
                    "import { addTypePrefix } from \"./parse/utils.js\";",
                    "",
                    "const DEFAULT_SCSS_DIRECTIVE = /(\\s*)(!default).*$/;",
                    "const GLOBAL_SCSS_DIRECTIVE = /(\\s*)(!global).*$/;",
                    "",
                    "function parseNestedCSS(node, options) {",
                    "  if (node && typeof node === \"object\") {",
                    "    delete node.parent;",
                    "",
                    "    for (const key in node) {",
                    "      parseNestedCSS(node[key], options);",
                    "    }",
                    "",
                    "    if (!node.type) {",
                    "      return node;",
                    "    }",
                    "",
                    "    /* c8 ignore next */",
                    "    node.raws ??= {};",
                    "",
                    "    // Custom properties looks like declarations",
                    "    if (",
                    "      node.type === \"css-decl\" &&",
                    "      typeof node.prop === \"string\" &&",
                    "      node.prop.startsWith(\"--\") &&",
                    "      typeof node.value === \"string\" &&",
                    "      node.value.startsWith(\"{\")",
                    "    ) {",
                    "      let rules;",
                    "      if (node.value.trimEnd().endsWith(\"}\")) {",
                    "        const textBefore = options.originalText.slice(",
                    "          0,",
                    "          node.source.start.offset",
                    "        );",
                    "        const nodeText =",
                    "          \"a\".repeat(node.prop.length) +",
                    "          options.originalText.slice(",
                    "            node.source.start.offset + node.prop.length,",
                    "            node.source.end.offset + 1",
                    "          );",
                    "        const fakeContent = textBefore.replaceAll(/[^\\n]/g, \" \") + nodeText;",
                    "        let parse;",
                    "        if (options.parser === \"scss\") {",
                    "          parse = parseScss;",
                    "        } else if (options.parser === \"less\") {",
                    "          parse = parseLess;",
                    "        } else {",
                    "          parse = parseCss;",
                    "        }",
                    "        let ast;",
                    "        try {",
                    "          ast = parse(fakeContent, { ...options });",
                    "        } catch {",
                    "          // noop",
                    "        }",
                    "        if (ast?.nodes?.length === 1 && ast.nodes[0].type === \"css-rule\") {",
                    "          rules = ast.nodes[0].nodes;",
                    "        }",
                    "      }",
                    "      if (rules) {",
                    "        node.value = {",
                    "          type: \"css-rule\",",
                    "          nodes: rules,",
                    "        };",
                    "      } else {",
                    "        node.value = {",
                    "          type: \"value-unknown\",",
                    "          value: node.raws.value.raw,",
                    "        };",
                    "      }",
                    "      return node;",
                    "    }",
                    "",
                    "    let selector = \"\";",
                    "",
                    "    if (typeof node.selector === \"string\") {",
                    "      selector = node.raws.selector",
                    "        ? node.raws.selector.scss ?? node.raws.selector.raw",
                    "        : node.selector;",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        selector += node.raws.between;",
                    "      }",
                    "",
                    "      node.raws.selector = selector;",
                    "    }",
                    "",
                    "    let value = \"\";",
                    "",
                    "    if (typeof node.value === \"string\") {",
                    "      value = node.raws.value",
                    "        ? node.raws.value.scss ?? node.raws.value.raw",
                    "        : node.value;",
                    "",
                    "      value = value.trim();",
                    "",
                    "      node.raws.value = value;",
                    "    }",
                    "",
                    "    let params = \"\";",
                    "",
                    "    if (typeof node.params === \"string\") {",
                    "      params = node.raws.params",
                    "        ? node.raws.params.scss ?? node.raws.params.raw",
                    "        : node.params;",
                    "",
                    "      if (node.raws.afterName && node.raws.afterName.trim().length > 0) {",
                    "        params = node.raws.afterName + params;",
                    "      }",
                    "",
                    "      if (node.raws.between && node.raws.between.trim().length > 0) {",
                    "        params = params + node.raws.between;",
                    "      }",
                    "",
                    "      params = params.trim();",
                    "",
                    "      node.raws.params = params;",
                    "    }",
                    "",
                    "    // Ignore LESS mixin declaration",
                    "    if (selector.trim().length > 0) {",
                    "      // TODO: confirm this code is dead",
                    "      /* c8 ignore next 3 */",
                    "      if (selector.startsWith(\"@\") && selector.endsWith(\":\")) {",
                    "        return node;",
                    "      }",
                    "",
                    "      // TODO: confirm this code is dead",
                    "      /* c8 ignore next 6 */",
                    "      // Ignore LESS mixins",
                    "      if (node.mixin) {",
                    "        node.selector = parseValue(selector, options);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      // Check on SCSS nested property",
                    "      if (isSCSSNestedPropertyNode(node, options)) {",
                    "        node.isSCSSNesterProperty = true;",
                    "      }",
                    "",
                    "      node.selector = parseSelector(selector);",
                    "",
                    "      return node;",
                    "    }",
                    "",
                    "    if (value.length > 0) {",
                    "      const defaultSCSSDirectiveIndex = value.match(DEFAULT_SCSS_DIRECTIVE);",
                    "",
                    "      if (defaultSCSSDirectiveIndex) {",
                    "        value = value.slice(0, defaultSCSSDirectiveIndex.index);",
                    "        node.scssDefault = true;",
                    "",
                    "        if (defaultSCSSDirectiveIndex[0].trim() !== \"!default\") {",
                    "          node.raws.scssDefault = defaultSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      const globalSCSSDirectiveIndex = value.match(GLOBAL_SCSS_DIRECTIVE);",
                    "",
                    "      if (globalSCSSDirectiveIndex) {",
                    "        value = value.slice(0, globalSCSSDirectiveIndex.index);",
                    "        node.scssGlobal = true;",
                    "",
                    "        if (globalSCSSDirectiveIndex[0].trim() !== \"!global\") {",
                    "          node.raws.scssGlobal = globalSCSSDirectiveIndex[0];",
                    "        }",
                    "      }",
                    "",
                    "      if (value.startsWith(\"progid:\")) {",
                    "        return {",
                    "          type: \"value-unknown\",",
                    "          value,",
                    "        };",
                    "      }",
                    "",
                    "      node.value = parseValue(value, options);",
                    "    }",
                    "",
                    "    if (",
                    "      options.parser === \"less\" &&",
                    "      node.type === \"css-decl\" &&",
                    "      value.startsWith(\"extend(\")",
                    "    ) {",
                    "      // extend is missing",
                    "      node.extend ||= node.raws.between === \":\";",
                    "",
                    "      // `:extend()` is parsed as value",
                    "      if (node.extend && !node.selector) {",
                    "        delete node.value;",
                    "        node.selector = parseSelector(value.slice(\"extend(\".length, -1));",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\") {",
                    "      if (options.parser === \"less\") {",
                    "        // mixin",
                    "        if (node.mixin) {",
                    "          const source =",
                    "            node.raws.identifier +",
                    "            node.name +",
                    "            node.raws.afterName +",
                    "            node.raws.params;",
                    "          node.selector = parseSelector(source);",
                    "          delete node.params;",
                    "          return node;",
                    "        }",
                    "",
                    "        // function",
                    "        if (node.function) {",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      // only css support custom-selector",
                    "      if (options.parser === \"css\" && node.name === \"custom-selector\") {",
                    "        const customSelector = node.params.match(/:--\\S+\\s+/)[0].trim();",
                    "        node.customSelector = customSelector;",
                    "        node.selector = parseSelector(",
                    "          node.params.slice(customSelector.length).trim()",
                    "        );",
                    "        delete node.params;",
                    "        return node;",
                    "      }",
                    "",
                    "      if (options.parser === \"less\") {",
                    "        // postcss-less doesn't recognize variables in some cases.",
                    "        // `@color: blue;` is recognized fine, but the cases below aren't:",
                    "",
                    "        // `@color:blue;`",
                    "        if (node.name.includes(\":\") && !node.params) {",
                    "          node.variable = true;",
                    "          const parts = node.name.split(\":\");",
                    "          node.name = parts[0];",
                    "          node.value = parseValue(parts.slice(1).join(\":\"), options);",
                    "        }",
                    "",
                    "        // `@color :blue;`",
                    "        if (",
                    "          ![\"page\", \"nest\", \"keyframes\"].includes(node.name) &&",
                    "          node.params?.[0] === \":\"",
                    "        ) {",
                    "          node.variable = true;",
                    "          const text = node.params.slice(1);",
                    "          if (text) {",
                    "            node.value = parseValue(text, options);",
                    "          }",
                    "          node.raws.afterName += \":\";",
                    "        }",
                    "",
                    "        // Less variable",
                    "        if (node.variable) {",
                    "          delete node.params;",
                    "",
                    "          if (!node.value) {",
                    "            delete node.value;",
                    "          }",
                    "",
                    "          return node;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (node.type === \"css-atrule\" && params.length > 0) {",
                    "      const { name } = node;",
                    "      const lowercasedName = node.name.toLowerCase();",
                    "",
                    "      if (name === \"warn\" || name === \"error\") {",
                    "        node.params = {",
                    "          type: \"media-unknown\",",
                    "          value: params,",
                    "        };",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"extend\" || name === \"nest\") {",
                    "        node.selector = parseSelector(params);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (name === \"at-root\") {",
                    "        if (/^\\(\\s*(?:without|with)\\s*:.+\\)$/s.test(params)) {",
                    "          node.params = parseValue(params, options);",
                    "        } else {",
                    "          node.selector = parseSelector(params);",
                    "          delete node.params;",
                    "        }",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if (isModuleRuleName(lowercasedName)) {",
                    "        node.import = true;",
                    "        delete node.filename;",
                    "        node.params = parseValue(params, options);",
                    "        return node;",
                    "      }",
                    "",
                    "      if (",
                    "        [",
                    "          \"namespace\",",
                    "          \"supports\",",
                    "          \"if\",",
                    "          \"else\",",
                    "          \"for\",",
                    "          \"each\",",
                    "          \"while\",",
                    "          \"debug\",",
                    "          \"mixin\",",
                    "          \"include\",",
                    "          \"function\",",
                    "          \"return\",",
                    "          \"define-mixin\",",
                    "          \"add-mixin\",",
                    "        ].includes(name)",
                    "      ) {",
                    "        // Remove unnecessary spaces in SCSS variable arguments",
                    "        // Move spaces after the `...`, so we can keep the range correct",
                    "        params = params.replace(/(\\$\\S+?)(\\s+)?\\.{3}/, \"$1...$2\");",
                    "        // Remove unnecessary spaces before SCSS control, mixin and function directives",
                    "        // Move spaces after the `(`, so we can keep the range correct",
                    "        params = params.replace(/^(?!if)(\\S+)(\\s+)\\(/, \"$1($2\");",
                    "",
                    "        node.value = parseValue(params, options);",
                    "        delete node.params;",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      if ([\"media\", \"custom-media\"].includes(lowercasedName)) {",
                    "        if (params.includes(\"#{\")) {",
                    "          // Workaround for media at rule with scss interpolation",
                    "          return {",
                    "            type: \"media-unknown\",",
                    "            value: params,",
                    "          };",
                    "        }",
                    "",
                    "        node.params = parseMediaQuery(params);",
                    "",
                    "        return node;",
                    "      }",
                    "",
                    "      node.params = params;",
                    "",
                    "      return node;",
                    "    }",
                    "  }",
                    "",
                    "  return node;",
                    "}",
                    "",
                    "function parseWithParser(parse, text, options) {",
                    "  const parsed = parseFrontMatter(text);",
                    "  const { frontMatter } = parsed;",
                    "  text = parsed.content;",
                    "",
                    "  let result;",
                    "",
                    "  try {",
                    "    result = parse(text, {",
                    "      // Prevent file access https://github.com/postcss/postcss/blob/4f4e2932fc97e2c117e1a4b15f0272ed551ed59d/lib/previous-map.js#L18",
                    "      map: false,",
                    "    });",
                    "  } catch (error) {",
                    "    const { name, reason, line, column } = error;",
                    "    /* c8 ignore 3 */",
                    "    if (typeof line !== \"number\") {",
                    "      throw error;",
                    "    }",
                    "",
                    "    throw createError(`${name}: ${reason}`, {",
                    "      loc: { start: { line, column } },",
                    "      cause: error,",
                    "    });",
                    "  }",
                    "",
                    "  options.originalText = text;",
                    "  result = parseNestedCSS(addTypePrefix(result, \"css-\"), options);",
                    "",
                    "  calculateLoc(result, text);",
                    "",
                    "  if (frontMatter) {",
                    "    frontMatter.source = {",
                    "      startOffset: 0,",
                    "      endOffset: frontMatter.raw.length,",
                    "    };",
                    "    result.frontMatter = frontMatter;",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function parseCss(text, options = {}) {",
                    "  return parseWithParser(postcssParse.default, text, options);",
                    "}",
                    "",
                    "function parseLess(text, options = {}) {",
                    "  return parseWithParser(",
                    "    // Workaround for https://github.com/shellscape/postcss-less/issues/145",
                    "    // See comments for `replaceQuotesInInlineComments` in `loc.js`.",
                    "    (text) => postcssLess.parse(replaceQuotesInInlineComments(text)),",
                    "    text,",
                    "    options",
                    "  );",
                    "}",
                    "",
                    "function parseScss(text, options = {}) {",
                    "  return parseWithParser(postcssScssParse, text, options);",
                    "}",
                    "",
                    "const postCssParser = {",
                    "  astFormat: \"postcss\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "export const css = { ...postCssParser, parse: parseCss };",
                    "export const less = { ...postCssParser, parse: parseLess };",
                    "export const scss = { ...postCssParser, parse: parseScss };"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  hasPragma as jsHasPragma,",
                    "  insertPragma as jsInsertPragma,",
                    "} from \"../language-js/pragma.js\";",
                    "import parseFrontMatter from \"../utils/front-matter/parse.js\";",
                    "",
                    "function hasPragma(text) {",
                    "  return jsHasPragma(parseFrontMatter(text).content);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  const { frontMatter, content } = parseFrontMatter(text);",
                    "  return (",
                    "    (frontMatter ? frontMatter.raw + \"\\n\\n\" : \"\") + jsInsertPragma(content)",
                    "  );",
                    "}",
                    "",
                    "export { hasPragma, insertPragma };"
                ]
            },
            "printer-postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import printString from \"../utils/print-string.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import {",
                    "  join,",
                    "  line,",
                    "  hardline,",
                    "  softline,",
                    "  group,",
                    "  indent,",
                    "  dedent,",
                    "  ifBreak,",
                    "  breakParent,",
                    "} from \"../document/builders.js\";",
                    "import { removeLines } from \"../document/utils.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import clean from \"./clean.js\";",
                    "import embed from \"./embed.js\";",
                    "import { insertPragma } from \"./pragma.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "import {",
                    "  maybeToLowerCase,",
                    "  insideValueFunctionNode,",
                    "  insideICSSRuleNode,",
                    "  insideAtRuleNode,",
                    "  isKeyframeAtRuleKeywords,",
                    "  isWideKeywords,",
                    "  isLastNode,",
                    "  isSCSSControlDirectiveNode,",
                    "  isDetachedRulesetDeclarationNode,",
                    "  hasComposesNode,",
                    "  hasParensAroundNode,",
                    "  isDetachedRulesetCallNode,",
                    "  isTemplatePlaceholderNode,",
                    "  isTemplatePropNode,",
                    "  isMediaAndSupportsKeywords,",
                    "  lastLineHasInlineComment,",
                    "} from \"./utils/index.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import {",
                    "  adjustStrings,",
                    "  adjustNumbers,",
                    "  quoteAttributeValue,",
                    "  printUnit,",
                    "  printCssNumber,",
                    "} from \"./print/misc.js\";",
                    "import printCommaSeparatedValueGroup from \"./print/comma-separated-value-group.js\";",
                    "import {",
                    "  printParenthesizedValueGroup,",
                    "  shouldBreakList,",
                    "} from \"./print/parenthesized-value-group.js\";",
                    "import printSequence from \"./print/sequence.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return [node.raw, hardline];",
                    "    case \"css-root\": {",
                    "      const nodes = printSequence(path, options, print);",
                    "      let after = node.raws.after.trim();",
                    "      if (after.startsWith(\";\")) {",
                    "        after = after.slice(1).trim();",
                    "      }",
                    "",
                    "      return [",
                    "        node.frontMatter ? [print(\"frontMatter\"), hardline] : \"\",",
                    "        nodes,",
                    "        after ? ` ${after}` : \"\",",
                    "        node.nodes.length > 0 ? hardline : \"\",",
                    "      ];",
                    "    }",
                    "    case \"css-comment\": {",
                    "      const isInlineComment = node.inline || node.raws.inline;",
                    "",
                    "      const text = options.originalText.slice(locStart(node), locEnd(node));",
                    "",
                    "      return isInlineComment ? text.trimEnd() : text;",
                    "    }",
                    "    case \"css-rule\":",
                    "      return [",
                    "        print(\"selector\"),",
                    "        node.important ? \" !important\" : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              node.selector?.type === \"selector-unknown\" &&",
                    "              lastLineHasInlineComment(node.selector.value)",
                    "                ? line",
                    "                : node.selector",
                    "                ? \" \"",
                    "                : \"\",",
                    "              \"{\",",
                    "              node.nodes.length > 0",
                    "                ? indent([hardline, printSequence(path, options, print)])",
                    "                : \"\",",
                    "              hardline,",
                    "              \"}\",",
                    "              isDetachedRulesetDeclarationNode(node) ? \";\" : \"\",",
                    "            ]",
                    "          : \";\",",
                    "      ];",
                    "",
                    "    case \"css-decl\": {",
                    "      const parentNode = path.parent;",
                    "",
                    "      const { between: rawBetween } = node.raws;",
                    "      const trimmedBetween = rawBetween.trim();",
                    "      const isColon = trimmedBetween === \":\";",
                    "      const isValueAllSpace =",
                    "        typeof node.value === \"string\" && /^ *$/.test(node.value);",
                    "      let value = typeof node.value === \"string\" ? node.value : print(\"value\");",
                    "",
                    "      value = hasComposesNode(node) ? removeLines(value) : value;",
                    "",
                    "      if (",
                    "        !isColon &&",
                    "        lastLineHasInlineComment(trimmedBetween) &&",
                    "        !(",
                    "          node.value?.group?.group &&",
                    "          path.call(() => shouldBreakList(path), \"value\", \"group\", \"group\")",
                    "        )",
                    "      ) {",
                    "        value = indent([hardline, dedent(value)]);",
                    "      }",
                    "",
                    "      return [",
                    "        node.raws.before.replaceAll(/[\\s;]/g, \"\"),",
                    "        // Less variable",
                    "        (parentNode.type === \"css-atrule\" && parentNode.variable) ||",
                    "        insideICSSRuleNode(path)",
                    "          ? node.prop",
                    "          : maybeToLowerCase(node.prop),",
                    "        trimmedBetween.startsWith(\"//\") ? \" \" : \"\",",
                    "        trimmedBetween,",
                    "        node.extend || isValueAllSpace ? \"\" : \" \",",
                    "        options.parser === \"less\" && node.extend && node.selector",
                    "          ? [\"extend(\", print(\"selector\"), \")\"]",
                    "          : \"\",",
                    "        value,",
                    "        node.raws.important",
                    "          ? node.raws.important.replace(/\\s*!\\s*important/i, \" !important\")",
                    "          : node.important",
                    "          ? \" !important\"",
                    "          : \"\",",
                    "        node.raws.scssDefault",
                    "          ? node.raws.scssDefault.replace(/\\s*!default/i, \" !default\")",
                    "          : node.scssDefault",
                    "          ? \" !default\"",
                    "          : \"\",",
                    "        node.raws.scssGlobal",
                    "          ? node.raws.scssGlobal.replace(/\\s*!global/i, \" !global\")",
                    "          : node.scssGlobal",
                    "          ? \" !global\"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              \" {\",",
                    "              indent([softline, printSequence(path, options, print)]),",
                    "              softline,",
                    "              \"}\",",
                    "            ]",
                    "          : isTemplatePropNode(node) &&",
                    "            !parentNode.raws.semicolon &&",
                    "            options.originalText[locEnd(node) - 1] !== \";\"",
                    "          ? \"\"",
                    "          : options.__isHTMLStyleAttribute && isLastNode(path, node)",
                    "          ? ifBreak(\";\")",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    case \"css-atrule\": {",
                    "      const parentNode = path.parent;",
                    "      const isTemplatePlaceholderNodeWithoutSemiColon =",
                    "        isTemplatePlaceholderNode(node) &&",
                    "        !parentNode.raws.semicolon &&",
                    "        options.originalText[locEnd(node) - 1] !== \";\";",
                    "",
                    "      if (options.parser === \"less\") {",
                    "        if (node.mixin) {",
                    "          return [",
                    "            print(\"selector\"),",
                    "            node.important ? \" !important\" : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "",
                    "        if (node.function) {",
                    "          return [",
                    "            node.name,",
                    "            typeof node.params === \"string\" ? node.params : print(\"params\"),",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "",
                    "        if (node.variable) {",
                    "          return [",
                    "            \"@\",",
                    "            node.name,",
                    "            \": \",",
                    "            node.value ? print(\"value\") : \"\",",
                    "            node.raws.between.trim() ? node.raws.between.trim() + \" \" : \"\",",
                    "            node.nodes",
                    "              ? [",
                    "                  \"{\",",
                    "                  indent([",
                    "                    node.nodes.length > 0 ? softline : \"\",",
                    "                    printSequence(path, options, print),",
                    "                  ]),",
                    "                  softline,",
                    "                  \"}\",",
                    "                ]",
                    "              : \"\",",
                    "            isTemplatePlaceholderNodeWithoutSemiColon ? \"\" : \";\",",
                    "          ];",
                    "        }",
                    "      }",
                    "      const isImportUnknownValueEndsWithSemiColon =",
                    "        node.name === \"import\" &&",
                    "        node.params?.type === \"value-unknown\" &&",
                    "        node.params.value.endsWith(\";\");",
                    "",
                    "      return [",
                    "        \"@\",",
                    "        // If a Less file ends up being parsed with the SCSS parser, Less",
                    "        // variable declarations will be parsed as at-rules with names ending",
                    "        // with a colon, so keep the original case then.",
                    "        isDetachedRulesetCallNode(node) || node.name.endsWith(\":\")",
                    "          ? node.name",
                    "          : maybeToLowerCase(node.name),",
                    "        node.params",
                    "          ? [",
                    "              isDetachedRulesetCallNode(node)",
                    "                ? \"\"",
                    "                : isTemplatePlaceholderNode(node)",
                    "                ? node.raws.afterName === \"\"",
                    "                  ? \"\"",
                    "                  : node.name.endsWith(\":\")",
                    "                  ? \" \"",
                    "                  : /^\\s*\\n\\s*\\n/.test(node.raws.afterName)",
                    "                  ? [hardline, hardline]",
                    "                  : /^\\s*\\n/.test(node.raws.afterName)",
                    "                  ? hardline",
                    "                  : \" \"",
                    "                : \" \",",
                    "              typeof node.params === \"string\" ? node.params : print(\"params\"),",
                    "            ]",
                    "          : \"\",",
                    "        node.selector ? indent([\" \", print(\"selector\")]) : \"\",",
                    "        node.value",
                    "          ? group([",
                    "              \" \",",
                    "              print(\"value\"),",
                    "              isSCSSControlDirectiveNode(node, options)",
                    "                ? hasParensAroundNode(node)",
                    "                  ? \" \"",
                    "                  : line",
                    "                : \"\",",
                    "            ])",
                    "          : node.name === \"else\"",
                    "          ? \" \"",
                    "          : \"\",",
                    "        node.nodes",
                    "          ? [",
                    "              isSCSSControlDirectiveNode(node, options)",
                    "                ? \"\"",
                    "                : (node.selector &&",
                    "                    !node.selector.nodes &&",
                    "                    typeof node.selector.value === \"string\" &&",
                    "                    lastLineHasInlineComment(node.selector.value)) ||",
                    "                  (!node.selector &&",
                    "                    typeof node.params === \"string\" &&",
                    "                    lastLineHasInlineComment(node.params))",
                    "                ? line",
                    "                : \" \",",
                    "              \"{\",",
                    "              indent([",
                    "                node.nodes.length > 0 ? softline : \"\",",
                    "                printSequence(path, options, print),",
                    "              ]),",
                    "              softline,",
                    "              \"}\",",
                    "            ]",
                    "          : isTemplatePlaceholderNodeWithoutSemiColon ||",
                    "            isImportUnknownValueEndsWithSemiColon",
                    "          ? \"\"",
                    "          : \";\",",
                    "      ];",
                    "    }",
                    "    // postcss-media-query-parser",
                    "    case \"media-query-list\": {",
                    "      const parts = [];",
                    "      path.each(({ node }) => {",
                    "        if (node.type === \"media-query\" && node.value === \"\") {",
                    "          return;",
                    "        }",
                    "        parts.push(print());",
                    "      }, \"nodes\");",
                    "",
                    "      return group(indent(join(line, parts)));",
                    "    }",
                    "    case \"media-query\":",
                    "      return [",
                    "        join(\" \", path.map(print, \"nodes\")),",
                    "        isLastNode(path, node) ? \"\" : \",\",",
                    "      ];",
                    "",
                    "    case \"media-type\":",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "",
                    "    case \"media-feature-expression\":",
                    "      if (!node.nodes) {",
                    "        return node.value;",
                    "      }",
                    "      return [\"(\", ...path.map(print, \"nodes\"), \")\"];",
                    "",
                    "    case \"media-feature\":",
                    "      return maybeToLowerCase(",
                    "        adjustStrings(node.value.replaceAll(/ +/g, \" \"), options)",
                    "      );",
                    "",
                    "    case \"media-colon\":",
                    "      return [node.value, \" \"];",
                    "",
                    "    case \"media-value\":",
                    "      return adjustNumbers(adjustStrings(node.value, options));",
                    "",
                    "    case \"media-keyword\":",
                    "      return adjustStrings(node.value, options);",
                    "",
                    "    case \"media-url\":",
                    "      return adjustStrings(",
                    "        node.value.replaceAll(/^url\\(\\s+/gi, \"url(\").replaceAll(/\\s+\\)$/g, \")\"),",
                    "        options",
                    "      );",
                    "",
                    "    case \"media-unknown\":",
                    "      return node.value;",
                    "",
                    "    // postcss-selector-parser",
                    "    case \"selector-root\":",
                    "      return group([",
                    "        insideAtRuleNode(path, \"custom-selector\")",
                    "          ? [",
                    "              path.findAncestor((node) => node.type === \"css-atrule\")",
                    "                .customSelector,",
                    "              line,",
                    "            ]",
                    "          : \"\",",
                    "        join(",
                    "          [",
                    "            \",\",",
                    "            insideAtRuleNode(path, [\"extend\", \"custom-selector\", \"nest\"])",
                    "              ? line",
                    "              : hardline,",
                    "          ],",
                    "          path.map(print, \"nodes\")",
                    "        ),",
                    "      ]);",
                    "",
                    "    case \"selector-selector\":",
                    "      return group(indent(path.map(print, \"nodes\")));",
                    "",
                    "    case \"selector-comment\":",
                    "      return node.value;",
                    "",
                    "    case \"selector-string\":",
                    "      return adjustStrings(node.value, options);",
                    "",
                    "    case \"selector-tag\":",
                    "      return [",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        path.previous?.type === \"selector-nesting\"",
                    "          ? node.value",
                    "          : adjustNumbers(",
                    "              isKeyframeAtRuleKeywords(path, node.value)",
                    "                ? node.value.toLowerCase()",
                    "                : node.value",
                    "            ),",
                    "      ];",
                    "",
                    "    case \"selector-id\":",
                    "      return [\"#\", node.value];",
                    "",
                    "    case \"selector-class\":",
                    "      return [\".\", adjustNumbers(adjustStrings(node.value, options))];",
                    "",
                    "    case \"selector-attribute\":",
                    "      return [",
                    "        \"[\",",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        node.attribute.trim(),",
                    "        node.operator ?? \"\",",
                    "        node.value",
                    "          ? quoteAttributeValue(",
                    "              adjustStrings(node.value.trim(), options),",
                    "              options",
                    "            )",
                    "          : \"\",",
                    "        node.insensitive ? \" i\" : \"\",",
                    "        \"]\",",
                    "      ];",
                    "",
                    "    case \"selector-combinator\": {",
                    "      if (",
                    "        node.value === \"+\" ||",
                    "        node.value === \">\" ||",
                    "        node.value === \"~\" ||",
                    "        node.value === \">>>\"",
                    "      ) {",
                    "        const parentNode = path.parent;",
                    "        const leading =",
                    "          parentNode.type === \"selector-selector\" &&",
                    "          parentNode.nodes[0] === node",
                    "            ? \"\"",
                    "            : line;",
                    "",
                    "        return [leading, node.value, isLastNode(path, node) ? \"\" : \" \"];",
                    "      }",
                    "",
                    "      const leading = node.value.trim().startsWith(\"(\") ? line : \"\";",
                    "      const value =",
                    "        adjustNumbers(adjustStrings(node.value.trim(), options)) || line;",
                    "",
                    "      return [leading, value];",
                    "    }",
                    "    case \"selector-universal\":",
                    "      return [",
                    "        node.namespace",
                    "          ? [node.namespace === true ? \"\" : node.namespace.trim(), \"|\"]",
                    "          : \"\",",
                    "        node.value,",
                    "      ];",
                    "",
                    "    case \"selector-pseudo\":",
                    "      return [",
                    "        maybeToLowerCase(node.value),",
                    "        isNonEmptyArray(node.nodes)",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([softline, join([\",\", line], path.map(print, \"nodes\"))]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "      ];",
                    "",
                    "    case \"selector-nesting\":",
                    "      return node.value;",
                    "",
                    "    case \"selector-unknown\": {",
                    "      const ruleAncestorNode = path.findAncestor(",
                    "        (node) => node.type === \"css-rule\"",
                    "      );",
                    "",
                    "      // Nested SCSS property",
                    "      if (ruleAncestorNode?.isSCSSNesterProperty) {",
                    "        return adjustNumbers(",
                    "          adjustStrings(maybeToLowerCase(node.value), options)",
                    "        );",
                    "      }",
                    "",
                    "      // originalText has to be used for Less, see replaceQuotesInInlineComments in loc.js",
                    "      const parentNode = path.parent;",
                    "      if (parentNode.raws?.selector) {",
                    "        const start = locStart(parentNode);",
                    "        const end = start + parentNode.raws.selector.length;",
                    "        return options.originalText.slice(start, end).trim();",
                    "      }",
                    "",
                    "      // Same reason above",
                    "      const grandParent = path.grandparent;",
                    "      if (",
                    "        parentNode.type === \"value-paren_group\" &&",
                    "        grandParent?.type === \"value-func\" &&",
                    "        grandParent.value === \"selector\"",
                    "      ) {",
                    "        const start = locEnd(parentNode.open) + 1;",
                    "        const end = locStart(parentNode.close);",
                    "        const selector = options.originalText.slice(start, end).trim();",
                    "",
                    "        return lastLineHasInlineComment(selector)",
                    "          ? [breakParent, selector]",
                    "          : selector;",
                    "      }",
                    "",
                    "      return node.value;",
                    "    }",
                    "    // postcss-values-parser",
                    "    case \"value-value\":",
                    "    case \"value-root\":",
                    "      return print(\"group\");",
                    "",
                    "    case \"value-comment\":",
                    "      return options.originalText.slice(locStart(node), locEnd(node));",
                    "",
                    "    case \"value-comma_group\":",
                    "      return printCommaSeparatedValueGroup(path, options, print);",
                    "",
                    "    case \"value-paren_group\":",
                    "      return printParenthesizedValueGroup(path, options, print);",
                    "",
                    "    case \"value-func\":",
                    "      return [",
                    "        node.value,",
                    "        insideAtRuleNode(path, \"supports\") && isMediaAndSupportsKeywords(node)",
                    "          ? \" \"",
                    "          : \"\",",
                    "        print(\"group\"),",
                    "      ];",
                    "",
                    "    case \"value-paren\":",
                    "      return node.value;",
                    "",
                    "    case \"value-number\":",
                    "      return [printCssNumber(node.value), printUnit(node.unit)];",
                    "",
                    "    case \"value-operator\":",
                    "      return node.value;",
                    "",
                    "    case \"value-word\":",
                    "      if ((node.isColor && node.isHex) || isWideKeywords(node.value)) {",
                    "        return node.value.toLowerCase();",
                    "      }",
                    "",
                    "      return node.value;",
                    "",
                    "    case \"value-colon\": {",
                    "      const { previous } = path;",
                    "      return [",
                    "        node.value,",
                    "        // Don't add spaces on escaped colon `:`, e.g: grid-template-rows: [row-1-00\\:00] auto;",
                    "        (typeof previous?.value === \"string\" &&",
                    "          previous.value.endsWith(\"\\\\\")) ||",
                    "        // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)",
                    "        insideValueFunctionNode(path, \"url\")",
                    "          ? \"\"",
                    "          : line,",
                    "      ];",
                    "    }",
                    "    case \"value-string\":",
                    "      return printString(",
                    "        node.raws.quote + node.value + node.raws.quote,",
                    "        options",
                    "      );",
                    "",
                    "    case \"value-atword\":",
                    "      return [\"@\", node.value];",
                    "",
                    "    case \"value-unicode-range\":",
                    "      return node.value;",
                    "",
                    "    case \"value-unknown\":",
                    "      return node.value;",
                    "",
                    "    case \"value-comma\": // Handled in `value-comma_group`",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"PostCSS\");",
                    "  }",
                    "}",
                    "",
                    "const printer = {",
                    "  print: genericPrint,",
                    "  embed,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = {",
                    "  \"front-matter\": [],",
                    "  \"css-root\": [\"frontMatter\", \"nodes\"],",
                    "  \"css-comment\": [],",
                    "  \"css-rule\": [\"selector\", \"nodes\"],",
                    "  \"css-decl\": [\"value\", \"selector\", \"nodes\"],",
                    "  \"css-atrule\": [\"selector\", \"params\", \"value\", \"nodes\"],",
                    "  \"media-query-list\": [\"nodes\"],",
                    "  \"media-query\": [\"nodes\"],",
                    "  \"media-type\": [],",
                    "  \"media-feature-expression\": [\"nodes\"],",
                    "  \"media-feature\": [],",
                    "  \"media-colon\": [],",
                    "  \"media-value\": [],",
                    "  \"media-keyword\": [],",
                    "  \"media-url\": [],",
                    "  \"media-unknown\": [],",
                    "  \"selector-root\": [\"nodes\"],",
                    "  \"selector-selector\": [\"nodes\"],",
                    "  \"selector-comment\": [],",
                    "  \"selector-string\": [],",
                    "  \"selector-tag\": [],",
                    "  \"selector-id\": [],",
                    "  \"selector-class\": [],",
                    "  \"selector-attribute\": [],",
                    "  \"selector-combinator\": [\"nodes\"],",
                    "  \"selector-universal\": [],",
                    "  \"selector-pseudo\": [\"nodes\"],",
                    "  \"selector-nesting\": [],",
                    "  \"selector-unknown\": [],",
                    "  \"value-value\": [\"group\"],",
                    "  \"value-root\": [\"group\"],",
                    "  \"value-comment\": [],",
                    "  \"value-comma_group\": [\"groups\"],",
                    "  \"value-paren_group\": [\"open\", \"groups\", \"close\"],",
                    "  \"value-func\": [\"group\"],",
                    "  \"value-paren\": [],",
                    "  \"value-number\": [],",
                    "  \"value-operator\": [],",
                    "  \"value-word\": [],",
                    "  \"value-colon\": [],",
                    "  \"value-comma\": [],",
                    "  \"value-string\": [],",
                    "  \"value-atword\": [],",
                    "  \"value-unicode-range\": [],",
                    "  \"value-unknown\": [],",
                    "};",
                    "",
                    "export default visitorKeys;"
                ]
            },
            "parse": {
                "parse-media-query.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import postcssMediaQueryParser from \"postcss-media-query-parser\";",
                        "import { addTypePrefix, addMissingType } from \"./utils.js\";",
                        "",
                        "const parse = postcssMediaQueryParser.default;",
                        "",
                        "function parseMediaQuery(params) {",
                        "  let result;",
                        "",
                        "  try {",
                        "    result = parse(params);",
                        "  } catch {",
                        "    // Ignore bad media queries",
                        "    /* c8 ignore next 4 */",
                        "    return {",
                        "      type: \"selector-unknown\",",
                        "      value: params,",
                        "    };",
                        "  }",
                        "",
                        "  return addTypePrefix(addMissingType(result), \"media-\");",
                        "}",
                        "",
                        "export default parseMediaQuery;"
                    ]
                },
                "parse-selector.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import PostcssSelectorParser from \"postcss-selector-parser/dist/processor.js\";",
                        "import { addTypePrefix } from \"./utils.js\";",
                        "",
                        "function parseSelector(selector) {",
                        "  // If there's a comment inside of a selector, the parser tries to parse",
                        "  // the content of the comment as selectors which turns it into complete",
                        "  // garbage. Better to print the whole selector as-is and not try to parse",
                        "  // and reformat it.",
                        "  if (/\\/\\/|\\/\\*/.test(selector)) {",
                        "    return {",
                        "      type: \"selector-unknown\",",
                        "      value: selector.trim(),",
                        "    };",
                        "  }",
                        "",
                        "  let result;",
                        "",
                        "  try {",
                        "    new PostcssSelectorParser((selectors) => {",
                        "      result = selectors;",
                        "    }).process(selector);",
                        "  } catch {",
                        "    // Fail silently. It's better to print it as is than to try and parse it",
                        "    // Note: A common failure is for SCSS nested properties. `background:",
                        "    // none { color: red; }` is parsed as a NestedDeclaration by",
                        "    // postcss-scss, while `background: { color: red; }` is parsed as a Rule",
                        "    // with a selector ending with a colon. See:",
                        "    // https://github.com/postcss/postcss-scss/issues/39",
                        "    return {",
                        "      type: \"selector-unknown\",",
                        "      value: selector,",
                        "    };",
                        "  }",
                        "",
                        "  return addTypePrefix(result, \"selector-\");",
                        "}",
                        "",
                        "export default parseSelector;"
                    ]
                },
                "parse-value.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import PostcssValuesParser from \"postcss-values-parser/lib/parser.js\";",
                        "import getFunctionArgumentsText from \"../utils/get-function-arguments-text.js\";",
                        "import getValueRoot from \"../utils/get-value-root.js\";",
                        "import hasSCSSInterpolation from \"../utils/has-scss-interpolation.js\";",
                        "import hasStringOrFunction from \"../utils/has-string-or-function.js\";",
                        "import isSCSSVariable from \"../utils/is-scss-variable.js\";",
                        "import parseSelector from \"./parse-selector.js\";",
                        "import { addTypePrefix } from \"./utils.js\";",
                        "",
                        "function parseValueNode(valueNode, options) {",
                        "  const { nodes } = valueNode;",
                        "  let parenGroup = {",
                        "    open: null,",
                        "    close: null,",
                        "    groups: [],",
                        "    type: \"paren_group\",",
                        "  };",
                        "  const parenGroupStack = [parenGroup];",
                        "  const rootParenGroup = parenGroup;",
                        "  let commaGroup = {",
                        "    groups: [],",
                        "    type: \"comma_group\",",
                        "  };",
                        "  const commaGroupStack = [commaGroup];",
                        "",
                        "  for (let i = 0; i < nodes.length; ++i) {",
                        "    const node = nodes[i];",
                        "",
                        "    if (",
                        "      options.parser === \"scss\" &&",
                        "      node.type === \"number\" &&",
                        "      node.unit === \"..\" &&",
                        "      node.value.endsWith(\".\")",
                        "    ) {",
                        "      // Work around postcss bug parsing `50...` as `50.` with unit `..`",
                        "      // Set the unit to `...` to \"accidentally\" have arbitrary arguments work in the same way that cases where the node already had a unit work.",
                        "      // For example, 50px... is parsed as `50` with unit `px...` already by postcss-values-parser.",
                        "      node.value = node.value.slice(0, -1);",
                        "      node.unit = \"...\";",
                        "    }",
                        "",
                        "    if (node.type === \"func\" && node.value === \"selector\") {",
                        "      node.group.groups = [",
                        "        parseSelector(",
                        "          getValueRoot(valueNode).text.slice(",
                        "            node.group.open.sourceIndex + 1,",
                        "            node.group.close.sourceIndex",
                        "          )",
                        "        ),",
                        "      ];",
                        "    }",
                        "",
                        "    if (node.type === \"func\" && node.value === \"url\") {",
                        "      const groups = node.group?.groups ?? [];",
                        "",
                        "      // Create a view with any top-level comma groups flattened.",
                        "      let groupList = [];",
                        "      for (let i = 0; i < groups.length; i++) {",
                        "        const group = groups[i];",
                        "        if (group.type === \"comma_group\") {",
                        "          groupList = [...groupList, ...group.groups];",
                        "        } else {",
                        "          groupList.push(group);",
                        "        }",
                        "      }",
                        "",
                        "      // Stringify if the value parser can't handle the content.",
                        "      if (",
                        "        hasSCSSInterpolation(groupList) ||",
                        "        (!hasStringOrFunction(groupList) &&",
                        "          !isSCSSVariable(groupList[0], options))",
                        "      ) {",
                        "        node.group.groups = [getFunctionArgumentsText(node)];",
                        "      }",
                        "    }",
                        "    if (node.type === \"paren\" && node.value === \"(\") {",
                        "      parenGroup = {",
                        "        open: node,",
                        "        close: null,",
                        "        groups: [],",
                        "        type: \"paren_group\",",
                        "      };",
                        "      parenGroupStack.push(parenGroup);",
                        "",
                        "      commaGroup = {",
                        "        groups: [],",
                        "        type: \"comma_group\",",
                        "      };",
                        "      commaGroupStack.push(commaGroup);",
                        "    } else if (node.type === \"paren\" && node.value === \")\") {",
                        "      if (commaGroup.groups.length > 0) {",
                        "        parenGroup.groups.push(commaGroup);",
                        "      }",
                        "      parenGroup.close = node;",
                        "",
                        "      /* c8 ignore next 3 */",
                        "      if (commaGroupStack.length === 1) {",
                        "        throw new Error(\"Unbalanced parenthesis\");",
                        "      }",
                        "",
                        "      commaGroupStack.pop();",
                        "      commaGroup = commaGroupStack.at(-1);",
                        "      commaGroup.groups.push(parenGroup);",
                        "",
                        "      parenGroupStack.pop();",
                        "      parenGroup = parenGroupStack.at(-1);",
                        "    } else if (node.type === \"comma\") {",
                        "      parenGroup.groups.push(commaGroup);",
                        "      commaGroup = {",
                        "        groups: [],",
                        "        type: \"comma_group\",",
                        "      };",
                        "      commaGroupStack[commaGroupStack.length - 1] = commaGroup;",
                        "    } else {",
                        "      commaGroup.groups.push(node);",
                        "    }",
                        "  }",
                        "  if (commaGroup.groups.length > 0) {",
                        "    parenGroup.groups.push(commaGroup);",
                        "  }",
                        "  return rootParenGroup;",
                        "}",
                        "",
                        "function flattenGroups(node) {",
                        "  if (",
                        "    node.type === \"paren_group\" &&",
                        "    !node.open &&",
                        "    !node.close &&",
                        "    node.groups.length === 1",
                        "  ) {",
                        "    return flattenGroups(node.groups[0]);",
                        "  }",
                        "",
                        "  if (node.type === \"comma_group\" && node.groups.length === 1) {",
                        "    return flattenGroups(node.groups[0]);",
                        "  }",
                        "",
                        "  if (node.type === \"paren_group\" || node.type === \"comma_group\") {",
                        "    return { ...node, groups: node.groups.map(flattenGroups) };",
                        "  }",
                        "",
                        "  return node;",
                        "}",
                        "",
                        "function parseNestedValue(node, options) {",
                        "  if (node && typeof node === \"object\") {",
                        "    for (const key in node) {",
                        "      if (key !== \"parent\") {",
                        "        parseNestedValue(node[key], options);",
                        "        if (key === \"nodes\") {",
                        "          node.group = flattenGroups(parseValueNode(node, options));",
                        "          delete node[key];",
                        "        }",
                        "      }",
                        "    }",
                        "  }",
                        "  return node;",
                        "}",
                        "",
                        "function parseValue(value, options) {",
                        "  // Inline javascript in Less",
                        "  if (options.parser === \"less\" && value.startsWith(\"~`\")) {",
                        "    return { type: \"value-unknown\", value };",
                        "  }",
                        "",
                        "  let result = null;",
                        "",
                        "  try {",
                        "    result = new PostcssValuesParser(value, { loose: true }).parse();",
                        "  } catch {",
                        "    return {",
                        "      type: \"value-unknown\",",
                        "      value,",
                        "    };",
                        "  }",
                        "",
                        "  result.text = value;",
                        "",
                        "  const parsedResult = parseNestedValue(result, options);",
                        "",
                        "  return addTypePrefix(parsedResult, \"value-\", /^selector-/);",
                        "}",
                        "",
                        "export default parseValue;"
                    ]
                },
                "utils.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function addTypePrefix(node, prefix, skipPrefix) {",
                        "  if (node && typeof node === \"object\") {",
                        "    delete node.parent;",
                        "    for (const key in node) {",
                        "      addTypePrefix(node[key], prefix, skipPrefix);",
                        "      if (",
                        "        key === \"type\" &&",
                        "        typeof node[key] === \"string\" &&",
                        "        !node[key].startsWith(prefix) &&",
                        "        (!skipPrefix || !skipPrefix.test(node[key]))",
                        "      ) {",
                        "        node[key] = prefix + node[key];",
                        "      }",
                        "    }",
                        "  }",
                        "  return node;",
                        "}",
                        "",
                        "function addMissingType(node) {",
                        "  if (node && typeof node === \"object\") {",
                        "    delete node.parent;",
                        "    for (const key in node) {",
                        "      addMissingType(node[key]);",
                        "    }",
                        "    if (!Array.isArray(node) && node.value && !node.type) {",
                        "      node.type = \"unknown\";",
                        "    }",
                        "  }",
                        "  return node;",
                        "}",
                        "",
                        "export { addTypePrefix, addMissingType };"
                    ]
                }
            },
            "print": {
                "comma-separated-value-group.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  fill,",
                        "  indent,",
                        "  dedent,",
                        "  breakParent,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  getPropOfDeclNode,",
                        "  insideValueFunctionNode,",
                        "  insideAtRuleNode,",
                        "  insideURLFunctionInImportAtRuleNode,",
                        "  isSCSSControlDirectiveNode,",
                        "  isRelationalOperatorNode,",
                        "  isEqualityOperatorNode,",
                        "  isMultiplicationNode,",
                        "  isDivisionNode,",
                        "  isAdditionNode,",
                        "  isSubtractionNode,",
                        "  isMathOperatorNode,",
                        "  isEachKeywordNode,",
                        "  isForKeywordNode,",
                        "  isIfElseKeywordNode,",
                        "  hasEmptyRawBefore,",
                        "  isPostcssSimpleVarNode,",
                        "  isInlineValueCommentNode,",
                        "  isHashNode,",
                        "  isLeftCurlyBraceNode,",
                        "  isRightCurlyBraceNode,",
                        "  isWordNode,",
                        "  isColonNode,",
                        "  isColorAdjusterFuncNode,",
                        "  isAtWordPlaceholderNode,",
                        "  isParenGroupNode,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "",
                        "function printCommaSeparatedValueGroup(path, options, print) {",
                        "  const { node } = path;",
                        "  const parentNode = path.parent;",
                        "  const parentParentNode = path.grandparent;",
                        "  const declAncestorProp = getPropOfDeclNode(path);",
                        "  const isGridValue =",
                        "    declAncestorProp &&",
                        "    parentNode.type === \"value-value\" &&",
                        "    (declAncestorProp === \"grid\" ||",
                        "      declAncestorProp.startsWith(\"grid-template\"));",
                        "  const atRuleAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"css-atrule\"",
                        "  );",
                        "  const isControlDirective =",
                        "    atRuleAncestorNode &&",
                        "    isSCSSControlDirectiveNode(atRuleAncestorNode, options);",
                        "  const hasInlineComment = node.groups.some((node) =>",
                        "    isInlineValueCommentNode(node)",
                        "  );",
                        "",
                        "  const printed = path.map(print, \"groups\");",
                        "  const parts = [];",
                        "  const insideURLFunction = insideValueFunctionNode(path, \"url\");",
                        "",
                        "  let insideSCSSInterpolationInString = false;",
                        "  let didBreak = false;",
                        "",
                        "  for (let i = 0; i < node.groups.length; ++i) {",
                        "    parts.push(printed[i]);",
                        "",
                        "    const iPrevNode = node.groups[i - 1];",
                        "    const iNode = node.groups[i];",
                        "    const iNextNode = node.groups[i + 1];",
                        "    const iNextNextNode = node.groups[i + 2];",
                        "",
                        "    if (insideURLFunction) {",
                        "      if ((iNextNode && isAdditionNode(iNextNode)) || isAdditionNode(iNode)) {",
                        "        parts.push(\" \");",
                        "      }",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore SCSS @forward wildcard suffix",
                        "    if (",
                        "      insideAtRuleNode(path, \"forward\") &&",
                        "      iNode.type === \"value-word\" &&",
                        "      iNode.value &&",
                        "      iPrevNode !== undefined &&",
                        "      iPrevNode.type === \"value-word\" &&",
                        "      iPrevNode.value === \"as\" &&",
                        "      iNextNode.type === \"value-operator\" &&",
                        "      iNextNode.value === \"*\"",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore after latest node (i.e. before semicolon)",
                        "    if (!iNextNode) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // styled.div` background: var(--${one}); `",
                        "    if (",
                        "      iNode.type === \"value-word\" &&",
                        "      iNode.value.endsWith(\"-\") &&",
                        "      isAtWordPlaceholderNode(iNextNode)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore spaces before/after string interpolation (i.e. `\"#{my-fn(\"_\")}\"`)",
                        "    if (iNode.type === \"value-string\" && iNode.quoted) {",
                        "      const positionOfOpeningInterpolation = iNode.value.lastIndexOf(\"#{\");",
                        "      const positionOfClosingInterpolation = iNode.value.lastIndexOf(\"}\");",
                        "      if (",
                        "        positionOfOpeningInterpolation !== -1 &&",
                        "        positionOfClosingInterpolation !== -1",
                        "      ) {",
                        "        insideSCSSInterpolationInString =",
                        "          positionOfOpeningInterpolation > positionOfClosingInterpolation;",
                        "      } else if (positionOfOpeningInterpolation !== -1) {",
                        "        insideSCSSInterpolationInString = true;",
                        "      } else if (positionOfClosingInterpolation !== -1) {",
                        "        insideSCSSInterpolationInString = false;",
                        "      }",
                        "    }",
                        "",
                        "    if (insideSCSSInterpolationInString) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore colon (i.e. `:`)",
                        "    if (isColonNode(iNode) || isColonNode(iNextNode)) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore `@` in Less (i.e. `@@var;`)",
                        "    if (",
                        "      iNode.type === \"value-atword\" &&",
                        "      (iNode.value === \"\" ||",
                        "        /*",
                        "            @var[ @notVarNested ][notVar]",
                        "            ^^^^^",
                        "            */",
                        "        iNode.value.endsWith(\"[\"))",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    /*",
                        "    @var[ @notVarNested ][notVar]",
                        "                        ^^^^^^^^^",
                        "    */",
                        "    if (iNextNode.type === \"value-word\" && iNextNode.value.startsWith(\"]\")) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore `~` in Less (i.e. `content: ~\"^//* some horrible but needed css hack\";`)",
                        "    if (iNode.value === \"~\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore escape `\\`",
                        "    if (",
                        "      iNode.type !== \"value-string\" &&",
                        "      iNode.value &&",
                        "      iNode.value.includes(\"\\\\\") &&",
                        "      iNextNode &&",
                        "      iNextNode.type !== \"value-comment\"",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore escaped `/`",
                        "    if (",
                        "      iPrevNode?.value &&",
                        "      iPrevNode.value.indexOf(\"\\\\\") === iPrevNode.value.length - 1 &&",
                        "      iNode.type === \"value-operator\" &&",
                        "      iNode.value === \"/\"",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore `\\` (i.e. `$variable: \\@small;`)",
                        "    if (iNode.value === \"\\\\\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore `$$` (i.e. `background-color: $$(style)Color;`)",
                        "    if (isPostcssSimpleVarNode(iNode, iNextNode)) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)",
                        "    if (",
                        "      isHashNode(iNode) ||",
                        "      isLeftCurlyBraceNode(iNode) ||",
                        "      isRightCurlyBraceNode(iNextNode) ||",
                        "      (isLeftCurlyBraceNode(iNextNode) && hasEmptyRawBefore(iNextNode)) ||",
                        "      (isRightCurlyBraceNode(iNode) && hasEmptyRawBefore(iNextNode))",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)",
                        "    if (iNode.value === \"--\" && isHashNode(iNextNode)) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Formatting math operations",
                        "    const isMathOperator = isMathOperatorNode(iNode);",
                        "    const isNextMathOperator = isMathOperatorNode(iNextNode);",
                        "",
                        "    // Print spaces before and after math operators beside SCSS interpolation as is",
                        "    // (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)",
                        "    // (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)",
                        "    if (",
                        "      ((isMathOperator && isHashNode(iNextNode)) ||",
                        "        (isNextMathOperator && isRightCurlyBraceNode(iNode))) &&",
                        "      hasEmptyRawBefore(iNextNode)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // absolute paths are only parsed as one token if they are part of url(/abs/path) call",
                        "    // but if you have custom -fb-url(/abs/path/) then it is parsed as \"division /\" and rest",
                        "    // of the path. We don't want to put a space after that first division in this case.",
                        "    if (!iPrevNode && isDivisionNode(iNode)) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Print spaces before and after addition and subtraction math operators as is in `calc` function",
                        "    // due to the fact that it is not valid syntax",
                        "    // (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)",
                        "    if (",
                        "      insideValueFunctionNode(path, \"calc\") &&",
                        "      (isAdditionNode(iNode) ||",
                        "        isAdditionNode(iNextNode) ||",
                        "        isSubtractionNode(iNode) ||",
                        "        isSubtractionNode(iNextNode)) &&",
                        "      hasEmptyRawBefore(iNextNode)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)",
                        "    // Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.",
                        "    const isColorAdjusterNode =",
                        "      (isAdditionNode(iNode) || isSubtractionNode(iNode)) &&",
                        "      i === 0 &&",
                        "      (iNextNode.type === \"value-number\" || iNextNode.isHex) &&",
                        "      parentParentNode &&",
                        "      isColorAdjusterFuncNode(parentParentNode) &&",
                        "      !hasEmptyRawBefore(iNextNode);",
                        "",
                        "    const requireSpaceBeforeOperator =",
                        "      iNextNextNode?.type === \"value-func\" ||",
                        "      (iNextNextNode && isWordNode(iNextNextNode)) ||",
                        "      iNode.type === \"value-func\" ||",
                        "      isWordNode(iNode);",
                        "    const requireSpaceAfterOperator =",
                        "      iNextNode.type === \"value-func\" ||",
                        "      isWordNode(iNextNode) ||",
                        "      iPrevNode?.type === \"value-func\" ||",
                        "      (iPrevNode && isWordNode(iPrevNode));",
                        "",
                        "    // Formatting `/`, `+`, `-` sign",
                        "    if (",
                        "      !(isMultiplicationNode(iNextNode) || isMultiplicationNode(iNode)) &&",
                        "      !insideValueFunctionNode(path, \"calc\") &&",
                        "      !isColorAdjusterNode &&",
                        "      ((isDivisionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                        "        (isDivisionNode(iNode) && !requireSpaceAfterOperator) ||",
                        "        (isAdditionNode(iNextNode) && !requireSpaceBeforeOperator) ||",
                        "        (isAdditionNode(iNode) && !requireSpaceAfterOperator) ||",
                        "        isSubtractionNode(iNextNode) ||",
                        "        isSubtractionNode(iNode)) &&",
                        "      (hasEmptyRawBefore(iNextNode) ||",
                        "        (isMathOperator &&",
                        "          (!iPrevNode || (iPrevNode && isMathOperatorNode(iPrevNode)))))",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // No space before unary minus followed by an opening parenthesis `-(`",
                        "    if (",
                        "      (options.parser === \"scss\" || options.parser === \"less\") &&",
                        "      isMathOperator &&",
                        "      iNode.value === \"-\" &&",
                        "      isParenGroupNode(iNextNode) &&",
                        "      locEnd(iNode) === locStart(iNextNode.open) &&",
                        "      iNextNode.open.value === \"(\"",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Add `hardline` after inline comment (i.e. `// comment\\n foo: bar;`)",
                        "    if (isInlineValueCommentNode(iNode)) {",
                        "      if (parentNode.type === \"value-paren_group\") {",
                        "        parts.push(dedent(hardline));",
                        "        continue;",
                        "      }",
                        "      parts.push(hardline);",
                        "      continue;",
                        "    }",
                        "",
                        "    // Handle keywords in SCSS control directive",
                        "    if (",
                        "      isControlDirective &&",
                        "      (isEqualityOperatorNode(iNextNode) ||",
                        "        isRelationalOperatorNode(iNextNode) ||",
                        "        isIfElseKeywordNode(iNextNode) ||",
                        "        isEachKeywordNode(iNode) ||",
                        "        isForKeywordNode(iNode))",
                        "    ) {",
                        "      parts.push(\" \");",
                        "",
                        "      continue;",
                        "    }",
                        "",
                        "    // At-rule `namespace` should be in one line",
                        "    if (",
                        "      atRuleAncestorNode &&",
                        "      atRuleAncestorNode.name.toLowerCase() === \"namespace\"",
                        "    ) {",
                        "      parts.push(\" \");",
                        "",
                        "      continue;",
                        "    }",
                        "",
                        "    // Formatting `grid` property",
                        "    if (isGridValue) {",
                        "      if (",
                        "        iNode.source &&",
                        "        iNextNode.source &&",
                        "        iNode.source.start.line !== iNextNode.source.start.line",
                        "      ) {",
                        "        parts.push(hardline);",
                        "",
                        "        didBreak = true;",
                        "      } else {",
                        "        parts.push(\" \");",
                        "      }",
                        "",
                        "      continue;",
                        "    }",
                        "",
                        "    // Add `space` before next math operation",
                        "    // Note: `grip` property have `/` delimiter and it is not math operation, so",
                        "    // `grid` property handles above",
                        "    if (isNextMathOperator) {",
                        "      parts.push(\" \");",
                        "",
                        "      continue;",
                        "    }",
                        "    // allow function(returns-list($list)...)",
                        "    if (iNextNode?.value === \"...\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (",
                        "      isAtWordPlaceholderNode(iNode) &&",
                        "      isAtWordPlaceholderNode(iNextNode) &&",
                        "      locEnd(iNode) === locStart(iNextNode)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (",
                        "      isAtWordPlaceholderNode(iNode) &&",
                        "      isParenGroupNode(iNextNode) &&",
                        "      locEnd(iNode) === locStart(iNextNode.open)",
                        "    ) {",
                        "      parts.push(softline);",
                        "      continue;",
                        "    }",
                        "",
                        "    if (iNode.value === \"with\" && isParenGroupNode(iNextNode)) {",
                        "      parts.push(\" \");",
                        "      continue;",
                        "    }",
                        "",
                        "    if (",
                        "      iNode.value?.endsWith(\"#\") &&",
                        "      iNextNode.value === \"{\" &&",
                        "      isParenGroupNode(iNextNode.group)",
                        "    ) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Be default all values go through `line`",
                        "    parts.push(line);",
                        "  }",
                        "",
                        "  if (hasInlineComment) {",
                        "    parts.push(breakParent);",
                        "  }",
                        "",
                        "  if (didBreak) {",
                        "    parts.unshift(hardline);",
                        "  }",
                        "",
                        "  if (isControlDirective) {",
                        "    return group(indent(parts));",
                        "  }",
                        "",
                        "  // Indent is not needed for import url when url is very long",
                        "  // and node has two groups",
                        "  // when type is value-comma_group",
                        "  // example @import url(\"verylongurl\") projection,tv",
                        "  if (insideURLFunctionInImportAtRuleNode(path)) {",
                        "    return group(fill(parts));",
                        "  }",
                        "",
                        "  return group(indent(fill(parts)));",
                        "}",
                        "",
                        "export default printCommaSeparatedValueGroup;"
                    ]
                },
                "css-units.evaluate.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import cssUnits from \"css-units-list\";",
                        "",
                        "const CSS_UNITS = new Map(cssUnits.map((unit) => [unit.toLowerCase(), unit]));",
                        "",
                        "export default CSS_UNITS;"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import printNumber from \"../../utils/print-number.js\";",
                        "import printString from \"../../utils/print-string.js\";",
                        "import { maybeToLowerCase } from \"../utils/index.js\";",
                        "import CSS_UNITS from \"./css-units.evaluate.js\";",
                        "",
                        "function printUnit(unit) {",
                        "  const lowercased = unit.toLowerCase();",
                        "  return CSS_UNITS.has(lowercased) ? CSS_UNITS.get(lowercased) : unit;",
                        "}",
                        "",
                        "const STRING_REGEX = /([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*\\1/gs;",
                        "const NUMBER_REGEX = /(?:\\d*\\.\\d+|\\d+\\.?)(?:[Ee][+-]?\\d+)?/g;",
                        "const STANDARD_UNIT_REGEX = /[A-Za-z]+/g;",
                        "const WORD_PART_REGEX = /[$@]?[A-Z_a-z\\u0080-\\uFFFF][\\w\\u0080-\\uFFFF-]*/g;",
                        "const ADJUST_NUMBERS_REGEX = new RegExp(",
                        "  STRING_REGEX.source +",
                        "    \"|\" +",
                        "    `(${WORD_PART_REGEX.source})?` +",
                        "    `(${NUMBER_REGEX.source})` +",
                        "    `(${STANDARD_UNIT_REGEX.source})?`,",
                        "  \"g\"",
                        ");",
                        "",
                        "function adjustStrings(value, options) {",
                        "  return value.replaceAll(STRING_REGEX, (match) => printString(match, options));",
                        "}",
                        "",
                        "function quoteAttributeValue(value, options) {",
                        "  const quote = options.singleQuote ? \"'\" : '\"';",
                        "  return value.includes('\"') || value.includes(\"'\")",
                        "    ? value",
                        "    : quote + value + quote;",
                        "}",
                        "",
                        "function adjustNumbers(value) {",
                        "  return value.replace(",
                        "    ADJUST_NUMBERS_REGEX,",
                        "    (match, quote, wordPart, number, unit) =>",
                        "      !wordPart && number",
                        "        ? printCssNumber(number) + maybeToLowerCase(unit || \"\")",
                        "        : match",
                        "  );",
                        "}",
                        "",
                        "function printCssNumber(rawNumber) {",
                        "  return (",
                        "    printNumber(rawNumber)",
                        "      // Remove trailing `.0`.",
                        "      .replace(/\\.0(?=$|e)/, \"\")",
                        "  );",
                        "}",
                        "",
                        "function shouldPrintTrailingComma(options) {",
                        "  return options.trailingComma === \"es5\" || options.trailingComma === \"all\";",
                        "}",
                        "",
                        "export {",
                        "  adjustStrings,",
                        "  adjustNumbers,",
                        "  quoteAttributeValue,",
                        "  shouldPrintTrailingComma,",
                        "  printUnit,",
                        "  printCssNumber,",
                        "};"
                    ]
                },
                "parenthesized-value-group.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNextLineEmpty from \"../../utils/is-next-line-empty.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  join,",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  fill,",
                        "  indent,",
                        "  dedent,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import { getDocParts } from \"../../document/utils.js\";",
                        "import {",
                        "  isURLFunctionNode,",
                        "  isKeyValuePairNode,",
                        "  isKeyInValuePairNode,",
                        "  isSCSSMapItemNode,",
                        "  isConfigurationNode,",
                        "  isVarFunctionNode,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import { shouldPrintTrailingComma } from \"./misc.js\";",
                        "",
                        "function hasComma({ node, parent }, options) {",
                        "  return Boolean(",
                        "    node.source &&",
                        "      options.originalText",
                        "        .slice(locStart(node), locStart(parent.close))",
                        "        .trimEnd()",
                        "        .endsWith(\",\")",
                        "  );",
                        "}",
                        "",
                        "function printTrailingComma(path, options) {",
                        "  if (isVarFunctionNode(path.grandparent) && hasComma(path, options)) {",
                        "    return \",\";",
                        "  }",
                        "",
                        "  if (",
                        "    path.node.type !== \"value-comment\" &&",
                        "    shouldPrintTrailingComma(options) &&",
                        "    path.callParent(() => isSCSSMapItemNode(path, options))",
                        "  ) {",
                        "    return ifBreak(\",\");",
                        "  }",
                        "",
                        "  return \"\";",
                        "}",
                        "",
                        "function printParenthesizedValueGroup(path, options, print) {",
                        "  const { node, parent } = path;",
                        "  const groupDocs = path.map(",
                        "    ({ node }) => (typeof node === \"string\" ? node : print()),",
                        "    \"groups\"",
                        "  );",
                        "",
                        "  if (",
                        "    parent &&",
                        "    isURLFunctionNode(parent) &&",
                        "    (node.groups.length === 1 ||",
                        "      (node.groups.length > 0 &&",
                        "        node.groups[0].type === \"value-comma_group\" &&",
                        "        node.groups[0].groups.length > 0 &&",
                        "        node.groups[0].groups[0].type === \"value-word\" &&",
                        "        node.groups[0].groups[0].value.startsWith(\"data:\")))",
                        "  ) {",
                        "    return [",
                        "      node.open ? print(\"open\") : \"\",",
                        "      join(\",\", groupDocs),",
                        "      node.close ? print(\"close\") : \"\",",
                        "    ];",
                        "  }",
                        "",
                        "  if (!node.open) {",
                        "    const forceHardLine = shouldBreakList(path);",
                        "    const parts = join([\",\", forceHardLine ? hardline : line], groupDocs);",
                        "    return indent(forceHardLine ? [hardline, parts] : group(fill(parts)));",
                        "  }",
                        "",
                        "  const parts = path.map(({ node: child, isLast, index }) => {",
                        "    let doc = groupDocs[index];",
                        "",
                        "    // Key/Value pair in open paren already indented",
                        "    if (",
                        "      isKeyValuePairNode(child) &&",
                        "      child.type === \"value-comma_group\" &&",
                        "      child.groups &&",
                        "      child.groups[0].type !== \"value-paren_group\" &&",
                        "      child.groups[2]?.type === \"value-paren_group\"",
                        "    ) {",
                        "      const parts = getDocParts(doc.contents.contents);",
                        "      parts[1] = group(parts[1]);",
                        "      doc = group(dedent(doc));",
                        "    }",
                        "",
                        "    const parts = [doc, isLast ? printTrailingComma(path, options) : \",\"];",
                        "",
                        "    if (",
                        "      !isLast &&",
                        "      child.type === \"value-comma_group\" &&",
                        "      isNonEmptyArray(child.groups)",
                        "    ) {",
                        "      let last = child.groups.at(-1);",
                        "",
                        "      // `value-paren_group` does not have location info, but its closing parenthesis does.",
                        "      if (!last.source && last.close) {",
                        "        last = last.close;",
                        "      }",
                        "",
                        "      if (last.source && isNextLineEmpty(options.originalText, locEnd(last))) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "",
                        "    return parts;",
                        "  }, \"groups\");",
                        "  const isKey = isKeyInValuePairNode(node, parent);",
                        "  const isConfiguration = isConfigurationNode(node, parent);",
                        "  const isSCSSMapItem = isSCSSMapItemNode(path, options);",
                        "  const shouldBreak = isConfiguration || (isSCSSMapItem && !isKey);",
                        "  const shouldDedent = isConfiguration || isKey;",
                        "",
                        "  const doc = group(",
                        "    [",
                        "      node.open ? print(\"open\") : \"\",",
                        "      indent([softline, join(line, parts)]),",
                        "      softline,",
                        "      node.close ? print(\"close\") : \"\",",
                        "    ],",
                        "    {",
                        "      shouldBreak,",
                        "    }",
                        "  );",
                        "",
                        "  return shouldDedent ? dedent(doc) : doc;",
                        "}",
                        "",
                        "function shouldBreakList(path) {",
                        "  return path.match(",
                        "    (node) =>",
                        "      node.type === \"value-paren_group\" &&",
                        "      !node.open &&",
                        "      node.groups.some((node) => node.type === \"value-comma_group\"),",
                        "    (node, key) => key === \"group\" && node.type === \"value-value\",",
                        "    (node, key) => key === \"group\" && node.type === \"value-root\",",
                        "    (node, key) =>",
                        "      key === \"value\" &&",
                        "      ((node.type === \"css-decl\" && !node.prop.startsWith(\"--\")) ||",
                        "        (node.type === \"css-atrule\" && node.variable))",
                        "  );",
                        "}",
                        "",
                        "export { printParenthesizedValueGroup, shouldBreakList };"
                    ]
                },
                "sequence.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isNextLineEmpty from \"../../utils/is-next-line-empty.js\";",
                        "import isFrontMatter from \"../../utils/front-matter/is-front-matter.js\";",
                        "import { line, hardline } from \"../../document/builders.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "",
                        "function printSequence(path, options, print) {",
                        "  const parts = [];",
                        "  path.each(() => {",
                        "    const { node, previous } = path;",
                        "    if (",
                        "      previous?.type === \"css-comment\" &&",
                        "      previous.text.trim() === \"prettier-ignore\"",
                        "    ) {",
                        "      parts.push(options.originalText.slice(locStart(node), locEnd(node)));",
                        "    } else {",
                        "      parts.push(print());",
                        "    }",
                        "",
                        "    if (path.isLast) {",
                        "      return;",
                        "    }",
                        "",
                        "    const { next } = path;",
                        "    if (",
                        "      (next.type === \"css-comment\" &&",
                        "        !hasNewline(options.originalText, locStart(next), {",
                        "          backwards: true,",
                        "        }) &&",
                        "        !isFrontMatter(node)) ||",
                        "      (next.type === \"css-atrule\" &&",
                        "        next.name === \"else\" &&",
                        "        node.type !== \"css-comment\")",
                        "    ) {",
                        "      parts.push(\" \");",
                        "    } else {",
                        "      parts.push(options.__isHTMLStyleAttribute ? line : hardline);",
                        "      if (",
                        "        isNextLineEmpty(options.originalText, locEnd(node)) &&",
                        "        !isFrontMatter(node)",
                        "      ) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, \"nodes\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export default printSequence;"
                    ]
                }
            },
            "utils": {
                "get-function-arguments-text.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import getValueRoot from \"./get-value-root.js\";",
                        "",
                        "/**",
                        " * @param {*} node",
                        " * @returns {string}",
                        " */",
                        "function getFunctionArgumentsText(node) {",
                        "  return getValueRoot(node)",
                        "    .text.slice(node.group.open.sourceIndex + 1, node.group.close.sourceIndex)",
                        "    .trim();",
                        "}",
                        "",
                        "export default getFunctionArgumentsText;"
                    ]
                },
                "get-value-root.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const getValueRoot = (node) => {",
                        "  while (node.parent) {",
                        "    node = node.parent;",
                        "  }",
                        "",
                        "  return node;",
                        "};",
                        "",
                        "export default getValueRoot;"
                    ]
                },
                "has-scss-interpolation.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "",
                        "function hasSCSSInterpolation(groupList) {",
                        "  if (isNonEmptyArray(groupList)) {",
                        "    for (let i = groupList.length - 1; i > 0; i--) {",
                        "      // If we find `#{`, return true.",
                        "      if (",
                        "        groupList[i].type === \"word\" &&",
                        "        groupList[i].value === \"{\" &&",
                        "        groupList[i - 1].type === \"word\" &&",
                        "        groupList[i - 1].value.endsWith(\"#\")",
                        "      ) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "export default hasSCSSInterpolation;"
                    ]
                },
                "has-string-or-function.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function hasStringOrFunction(groupList) {",
                        "  return groupList.some(",
                        "    (group) =>",
                        "      group.type === \"string\" ||",
                        "      (group.type === \"func\" &&",
                        "        // workaround false-positive func",
                        "        !group.value.endsWith(\"\\\\\"))",
                        "  );",
                        "}",
                        "",
                        "export default hasStringOrFunction;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const colorAdjusterFunctions = new Set([",
                        "  \"red\",",
                        "  \"green\",",
                        "  \"blue\",",
                        "  \"alpha\",",
                        "  \"a\",",
                        "  \"rgb\",",
                        "  \"hue\",",
                        "  \"h\",",
                        "  \"saturation\",",
                        "  \"s\",",
                        "  \"lightness\",",
                        "  \"l\",",
                        "  \"whiteness\",",
                        "  \"w\",",
                        "  \"blackness\",",
                        "  \"b\",",
                        "  \"tint\",",
                        "  \"shade\",",
                        "  \"blend\",",
                        "  \"blenda\",",
                        "  \"contrast\",",
                        "  \"hsl\",",
                        "  \"hsla\",",
                        "  \"hwb\",",
                        "  \"hwba\",",
                        "]);",
                        "",
                        "function getPropOfDeclNode(path) {",
                        "  return path",
                        "    .findAncestor((node) => node.type === \"css-decl\")",
                        "    ?.prop?.toLowerCase();",
                        "}",
                        "",
                        "const wideKeywords = new Set([\"initial\", \"inherit\", \"unset\", \"revert\"]);",
                        "function isWideKeywords(value) {",
                        "  return wideKeywords.has(value.toLowerCase());",
                        "}",
                        "",
                        "function isKeyframeAtRuleKeywords(path, value) {",
                        "  const atRuleAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"css-atrule\"",
                        "  );",
                        "  return (",
                        "    atRuleAncestorNode?.name?.toLowerCase().endsWith(\"keyframes\") &&",
                        "    [\"from\", \"to\"].includes(value.toLowerCase())",
                        "  );",
                        "}",
                        "",
                        "function maybeToLowerCase(value) {",
                        "  return value.includes(\"$\") ||",
                        "    value.includes(\"@\") ||",
                        "    value.includes(\"#\") ||",
                        "    value.startsWith(\"%\") ||",
                        "    value.startsWith(\"--\") ||",
                        "    value.startsWith(\":--\") ||",
                        "    (value.includes(\"(\") && value.includes(\")\"))",
                        "    ? value",
                        "    : value.toLowerCase();",
                        "}",
                        "",
                        "function insideValueFunctionNode(path, functionName) {",
                        "  const funcAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"value-func\"",
                        "  );",
                        "  return funcAncestorNode?.value?.toLowerCase() === functionName;",
                        "}",
                        "",
                        "function insideICSSRuleNode(path) {",
                        "  const ruleAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"css-rule\"",
                        "  );",
                        "  const selector = ruleAncestorNode?.raws?.selector;",
                        "",
                        "  return (",
                        "    selector &&",
                        "    (selector.startsWith(\":import\") || selector.startsWith(\":export\"))",
                        "  );",
                        "}",
                        "",
                        "function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {",
                        "  const atRuleNames = Array.isArray(atRuleNameOrAtRuleNames)",
                        "    ? atRuleNameOrAtRuleNames",
                        "    : [atRuleNameOrAtRuleNames];",
                        "  const atRuleAncestorNode = path.findAncestor(",
                        "    (node) => node.type === \"css-atrule\"",
                        "  );",
                        "",
                        "  return (",
                        "    atRuleAncestorNode &&",
                        "    atRuleNames.includes(atRuleAncestorNode.name.toLowerCase())",
                        "  );",
                        "}",
                        "",
                        "function insideURLFunctionInImportAtRuleNode(path) {",
                        "  const { node } = path;",
                        "  return (",
                        "    node.groups[0].value === \"url\" &&",
                        "    node.groups.length === 2 &&",
                        "    path.findAncestor((node) => node.type === \"css-atrule\")?.name === \"import\"",
                        "  );",
                        "}",
                        "",
                        "function isURLFunctionNode(node) {",
                        "  return node.type === \"value-func\" && node.value.toLowerCase() === \"url\";",
                        "}",
                        "",
                        "function isVarFunctionNode(node) {",
                        "  return node.type === \"value-func\" && node.value.toLowerCase() === \"var\";",
                        "}",
                        "",
                        "function isLastNode(path, node) {",
                        "  const nodes = path.parent?.nodes;",
                        "  return nodes && nodes.indexOf(node) === nodes.length - 1;",
                        "}",
                        "",
                        "function isDetachedRulesetDeclarationNode(node) {",
                        "  const { selector } = node;",
                        "  // If a Less file ends up being parsed with the SCSS parser, Less",
                        "  // variable declarations will be parsed as atrules with names ending",
                        "  // with a colon, so keep the original case then.",
                        "  /* c8 ignore next 3 */",
                        "  if (!selector) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return (",
                        "    (typeof selector === \"string\" && /^@.+:.*$/.test(selector)) ||",
                        "    (selector.value && /^@.+:.*$/.test(selector.value))",
                        "  );",
                        "}",
                        "",
                        "function isForKeywordNode(node) {",
                        "  return (",
                        "    node.type === \"value-word\" &&",
                        "    [\"from\", \"through\", \"end\"].includes(node.value)",
                        "  );",
                        "}",
                        "",
                        "function isIfElseKeywordNode(node) {",
                        "  return (",
                        "    node.type === \"value-word\" && [\"and\", \"or\", \"not\"].includes(node.value)",
                        "  );",
                        "}",
                        "",
                        "function isEachKeywordNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"in\";",
                        "}",
                        "",
                        "function isMultiplicationNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"*\";",
                        "}",
                        "",
                        "function isDivisionNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"/\";",
                        "}",
                        "",
                        "function isAdditionNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"+\";",
                        "}",
                        "",
                        "function isSubtractionNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"-\";",
                        "}",
                        "",
                        "function isModuloNode(node) {",
                        "  return node.type === \"value-operator\" && node.value === \"%\";",
                        "}",
                        "",
                        "function isMathOperatorNode(node) {",
                        "  return (",
                        "    isMultiplicationNode(node) ||",
                        "    isDivisionNode(node) ||",
                        "    isAdditionNode(node) ||",
                        "    isSubtractionNode(node) ||",
                        "    isModuloNode(node)",
                        "  );",
                        "}",
                        "",
                        "function isEqualityOperatorNode(node) {",
                        "  return node.type === \"value-word\" && [\"==\", \"!=\"].includes(node.value);",
                        "}",
                        "",
                        "function isRelationalOperatorNode(node) {",
                        "  return (",
                        "    node.type === \"value-word\" && [\"<\", \">\", \"<=\", \">=\"].includes(node.value)",
                        "  );",
                        "}",
                        "",
                        "function isSCSSControlDirectiveNode(node, options) {",
                        "  return (",
                        "    options.parser === \"scss\" &&",
                        "    node.type === \"css-atrule\" &&",
                        "    [\"if\", \"else\", \"for\", \"each\", \"while\"].includes(node.name)",
                        "  );",
                        "}",
                        "",
                        "function isDetachedRulesetCallNode(node) {",
                        "  return node.raws?.params && /^\\(\\s*\\)$/.test(node.raws.params);",
                        "}",
                        "",
                        "function isTemplatePlaceholderNode(node) {",
                        "  return node.name.startsWith(\"prettier-placeholder\");",
                        "}",
                        "",
                        "function isTemplatePropNode(node) {",
                        "  return node.prop.startsWith(\"@prettier-placeholder\");",
                        "}",
                        "",
                        "function isPostcssSimpleVarNode(currentNode, nextNode) {",
                        "  return (",
                        "    currentNode.value === \"$$\" &&",
                        "    currentNode.type === \"value-func\" &&",
                        "    nextNode?.type === \"value-word\" &&",
                        "    !nextNode.raws.before",
                        "  );",
                        "}",
                        "",
                        "function hasComposesNode(node) {",
                        "  return (",
                        "    node.value?.type === \"value-root\" &&",
                        "    node.value.group?.type === \"value-value\" &&",
                        "    node.prop.toLowerCase() === \"composes\"",
                        "  );",
                        "}",
                        "",
                        "function hasParensAroundNode(node) {",
                        "  return (",
                        "    node.value?.group?.group?.type === \"value-paren_group\" &&",
                        "    node.value.group.group.open !== null &&",
                        "    node.value.group.group.close !== null",
                        "  );",
                        "}",
                        "",
                        "function hasEmptyRawBefore(node) {",
                        "  return node.raws?.before === \"\";",
                        "}",
                        "",
                        "function isKeyValuePairNode(node) {",
                        "  return (",
                        "    node.type === \"value-comma_group\" &&",
                        "    node.groups?.[1]?.type === \"value-colon\"",
                        "  );",
                        "}",
                        "",
                        "function isKeyValuePairInParenGroupNode(node) {",
                        "  return (",
                        "    node.type === \"value-paren_group\" &&",
                        "    node.groups?.[0] &&",
                        "    isKeyValuePairNode(node.groups[0])",
                        "  );",
                        "}",
                        "",
                        "function isSCSSMapItemNode(path, options) {",
                        "  if (options.parser !== \"scss\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  const { node } = path;",
                        "",
                        "  // Ignore empty item (i.e. `$key: ()`)",
                        "  if (node.groups.length === 0) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const parentParentNode = path.grandparent;",
                        "",
                        "  // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)",
                        "  if (",
                        "    !isKeyValuePairInParenGroupNode(node) &&",
                        "    !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const declNode = path.findAncestor((node) => node.type === \"css-decl\");",
                        "",
                        "  // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)",
                        "  if (declNode?.prop?.startsWith(\"$\")) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)",
                        "  if (isKeyValuePairInParenGroupNode(parentParentNode)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)",
                        "  if (parentParentNode.type === \"value-func\") {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function isInlineValueCommentNode(node) {",
                        "  return node.type === \"value-comment\" && node.inline;",
                        "}",
                        "",
                        "function isHashNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"#\";",
                        "}",
                        "",
                        "function isLeftCurlyBraceNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"{\";",
                        "}",
                        "",
                        "function isRightCurlyBraceNode(node) {",
                        "  return node.type === \"value-word\" && node.value === \"}\";",
                        "}",
                        "",
                        "function isWordNode(node) {",
                        "  return [\"value-word\", \"value-atword\"].includes(node.type);",
                        "}",
                        "",
                        "function isColonNode(node) {",
                        "  return node?.type === \"value-colon\";",
                        "}",
                        "",
                        "function isKeyInValuePairNode(node, parentNode) {",
                        "  if (!isKeyValuePairNode(parentNode)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const { groups } = parentNode;",
                        "  const index = groups.indexOf(node);",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (index === -1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return isColonNode(groups[index + 1]);",
                        "}",
                        "",
                        "function isMediaAndSupportsKeywords(node) {",
                        "  return node.value && [\"not\", \"and\", \"or\"].includes(node.value.toLowerCase());",
                        "}",
                        "",
                        "function isColorAdjusterFuncNode(node) {",
                        "  if (node.type !== \"value-func\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  return colorAdjusterFunctions.has(node.value.toLowerCase());",
                        "}",
                        "",
                        "function lastLineHasInlineComment(text) {",
                        "  return /\\/\\//.test(text.split(/[\\n\\r]/).pop());",
                        "}",
                        "",
                        "function isAtWordPlaceholderNode(node) {",
                        "  return (",
                        "    node?.type === \"value-atword\" &&",
                        "    node.value.startsWith(\"prettier-placeholder-\")",
                        "  );",
                        "}",
                        "",
                        "function isConfigurationNode(node, parentNode) {",
                        "  if (",
                        "    node.open?.value !== \"(\" ||",
                        "    node.close?.value !== \")\" ||",
                        "    node.groups.some((group) => group.type !== \"value-comma_group\")",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "  if (parentNode.type === \"value-comma_group\") {",
                        "    const prevIdx = parentNode.groups.indexOf(node) - 1;",
                        "    const maybeWithNode = parentNode.groups[prevIdx];",
                        "    if (",
                        "      maybeWithNode?.type === \"value-word\" &&",
                        "      maybeWithNode.value === \"with\"",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function isParenGroupNode(node) {",
                        "  return (",
                        "    node.type === \"value-paren_group\" &&",
                        "    node.open?.value === \"(\" &&",
                        "    node.close?.value === \")\"",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  getPropOfDeclNode,",
                        "  maybeToLowerCase,",
                        "  insideValueFunctionNode,",
                        "  insideICSSRuleNode,",
                        "  insideAtRuleNode,",
                        "  insideURLFunctionInImportAtRuleNode,",
                        "  isKeyframeAtRuleKeywords,",
                        "  isWideKeywords,",
                        "  isLastNode,",
                        "  isSCSSControlDirectiveNode,",
                        "  isDetachedRulesetDeclarationNode,",
                        "  isRelationalOperatorNode,",
                        "  isEqualityOperatorNode,",
                        "  isMultiplicationNode,",
                        "  isDivisionNode,",
                        "  isAdditionNode,",
                        "  isSubtractionNode,",
                        "  isModuloNode,",
                        "  isMathOperatorNode,",
                        "  isEachKeywordNode,",
                        "  isForKeywordNode,",
                        "  isURLFunctionNode,",
                        "  isIfElseKeywordNode,",
                        "  hasComposesNode,",
                        "  hasParensAroundNode,",
                        "  hasEmptyRawBefore,",
                        "  isDetachedRulesetCallNode,",
                        "  isTemplatePlaceholderNode,",
                        "  isTemplatePropNode,",
                        "  isPostcssSimpleVarNode,",
                        "  isKeyValuePairNode,",
                        "  isKeyValuePairInParenGroupNode,",
                        "  isKeyInValuePairNode,",
                        "  isSCSSMapItemNode,",
                        "  isInlineValueCommentNode,",
                        "  isHashNode,",
                        "  isLeftCurlyBraceNode,",
                        "  isRightCurlyBraceNode,",
                        "  isWordNode,",
                        "  isColonNode,",
                        "  isMediaAndSupportsKeywords,",
                        "  isColorAdjusterFuncNode,",
                        "  lastLineHasInlineComment,",
                        "  isAtWordPlaceholderNode,",
                        "  isConfigurationNode,",
                        "  isParenGroupNode,",
                        "  isVarFunctionNode,",
                        "};"
                    ]
                },
                "is-module-rule-name.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const moduleRuleNames = new Set([\"import\", \"use\", \"forward\"]);",
                        "",
                        "function isModuleRuleName(name) {",
                        "  return moduleRuleNames.has(name);",
                        "}",
                        "",
                        "export default isModuleRuleName;"
                    ]
                },
                "is-scss-nested-property-node.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isSCSSNestedPropertyNode(node, options) {",
                        "  if (options.parser !== \"scss\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (!node.selector) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return node.selector",
                        "    .replace(/\\/\\*.*?\\*\\//, \"\")",
                        "    .replace(/\\/\\/.*\\n/, \"\")",
                        "    .trim()",
                        "    .endsWith(\":\");",
                        "}",
                        "",
                        "export default isSCSSNestedPropertyNode;"
                    ]
                },
                "is-scss-variable.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isSCSSVariable(node, options) {",
                        "  return Boolean(",
                        "    options.parser === \"scss\" &&",
                        "      node?.type === \"word\" &&",
                        "      node.value.startsWith(\"$\")",
                        "  );",
                        "}",
                        "",
                        "export default isSCSSVariable;"
                    ]
                },
                "stringify-node.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function stringifyNode(node) {",
                        "  if (node.groups) {",
                        "    const open = node.open?.value || \"\";",
                        "    const groups = node.groups",
                        "      .map((currentValue) => stringifyNode(currentValue))",
                        "      .join(node.groups[0]?.type === \"comma_group\" ? \",\" : \"\");",
                        "    const close = node.close?.value || \"\";",
                        "",
                        "    return open + groups + close;",
                        "  }",
                        "",
                        "  const before = node.raws?.before || \"\";",
                        "  const quote = node.raws?.quote || \"\";",
                        "  const atword = node.type === \"atword\" ? \"@\" : \"\";",
                        "  const value = node.value || \"\";",
                        "  const unit = node.unit || \"\";",
                        "  const group = node.group ? stringifyNode(node.group) : \"\";",
                        "  const after = node.raws?.after || \"\";",
                        "",
                        "  return before + quote + atword + value + quote + unit + group + after;",
                        "}",
                        "",
                        "export default stringifyNode;"
                    ]
                }
            }
        },
        "language-graphql": {
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys, \"kind\");",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-graphql.js\";",
                    "",
                    "export const printers = {",
                    "  graphql: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-graphql.js\"),",
                    "    parserNames: [\"graphql\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.GraphQL, () => ({",
                    "    parsers: [\"graphql\"],",
                    "    vscodeLanguageIds: [\"graphql\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(nodeOrToken) {",
                    "  return nodeOrToken.kind === \"Comment\"",
                    "    ? nodeOrToken.start",
                    "    : nodeOrToken.loc.start;",
                    "}",
                    "",
                    "function locEnd(nodeOrToken) {",
                    "  return nodeOrToken.kind === \"Comment\" ? nodeOrToken.end : nodeOrToken.loc.end;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { parse as parseGraphql } from \"graphql/language/parser.mjs\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "",
                    "function parseComments(ast) {",
                    "  const comments = [];",
                    "  const { startToken, endToken } = ast.loc;",
                    "  for (let token = startToken; token !== endToken; token = token.next) {",
                    "    if (token.kind === \"Comment\") {",
                    "      comments.push(token);",
                    "    }",
                    "  }",
                    "",
                    "  return comments;",
                    "}",
                    "",
                    "const parseOptions = {",
                    "  allowLegacyFragmentVariables: true,",
                    "};",
                    "",
                    "function createParseError(error) {",
                    "  if (error?.name === \"GraphQLError\") {",
                    "    const {",
                    "      message,",
                    "      locations: [start],",
                    "    } = error;",
                    "    return createError(message, { loc: { start }, cause: error });",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  return error;",
                    "}",
                    "",
                    "function parse(text /*, options */) {",
                    "  /** @type {any} */",
                    "  let ast;",
                    "  try {",
                    "    ast = parseGraphql(text, parseOptions);",
                    "  } catch (error) {",
                    "    throw createParseError(error);",
                    "  }",
                    "",
                    "  ast.comments = parseComments(ast);",
                    "  return ast;",
                    "}",
                    "",
                    "export const graphql = {",
                    "  parse,",
                    "  astFormat: \"graphql\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(?:format|prettier)\\s*(?:\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"# @format\\n\\n\" + text;",
                    "}",
                    "",
                    "export { hasPragma, insertPragma };"
                ]
            },
            "printer-graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  join,",
                    "  hardline,",
                    "  line,",
                    "  softline,",
                    "  group,",
                    "  indent,",
                    "  ifBreak,",
                    "} from \"../document/builders.js\";",
                    "import isNextLineEmpty from \"../utils/is-next-line-empty.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import { insertPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "import printDescription from \"./print/description.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.kind) {",
                    "    case \"Document\":",
                    "      return [",
                    "        ...join(hardline, printSequence(path, options, print, \"definitions\")),",
                    "        hardline,",
                    "      ];",
                    "",
                    "    case \"OperationDefinition\": {",
                    "      const hasOperation = options.originalText[locStart(node)] !== \"{\";",
                    "      const hasName = Boolean(node.name);",
                    "      return [",
                    "        hasOperation ? node.operation : \"\",",
                    "        hasOperation && hasName ? [\" \", print(\"name\")] : \"\",",
                    "        hasOperation && !hasName && isNonEmptyArray(node.variableDefinitions)",
                    "          ? \" \"",
                    "          : \"\",",
                    "        printVariableDefinitions(path, print),",
                    "        printDirectives(path, print, node),",
                    "        !hasOperation && !hasName ? \"\" : \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "    }",
                    "    case \"FragmentDefinition\":",
                    "      return [",
                    "        \"fragment \",",
                    "        print(\"name\"),",
                    "        printVariableDefinitions(path, print),",
                    "        \" on \",",
                    "        print(\"typeCondition\"),",
                    "        printDirectives(path, print, node),",
                    "        \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "",
                    "    case \"SelectionSet\":",
                    "      return [",
                    "        \"{\",",
                    "        indent([",
                    "          hardline,",
                    "          join(hardline, printSequence(path, options, print, \"selections\")),",
                    "        ]),",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "",
                    "    case \"Field\":",
                    "      return group([",
                    "        node.alias ? [print(\"alias\"), \": \"] : \"\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        printDirectives(path, print, node),",
                    "        node.selectionSet ? \" \" : \"\",",
                    "        print(\"selectionSet\"),",
                    "      ]);",
                    "",
                    "    case \"Name\":",
                    "      return node.value;",
                    "",
                    "    case \"StringValue\":",
                    "      if (node.block) {",
                    "        const lines = node.value.replaceAll('\"\"\"', '\\\\\"\"\"').split(\"\\n\");",
                    "        if (lines.length === 1) {",
                    "          lines[0] = lines[0].trim();",
                    "        }",
                    "",
                    "        if (lines.every((line) => line === \"\")) {",
                    "          lines.length = 0;",
                    "        }",
                    "",
                    "        return join(hardline, ['\"\"\"', ...lines, '\"\"\"']);",
                    "      }",
                    "      return [",
                    "        '\"',",
                    "        node.value.replaceAll(/[\"\\\\]/g, \"\\\\$&\").replaceAll(\"\\n\", \"\\\\n\"),",
                    "        '\"',",
                    "      ];",
                    "",
                    "    case \"IntValue\":",
                    "    case \"FloatValue\":",
                    "    case \"EnumValue\":",
                    "      return node.value;",
                    "",
                    "    case \"BooleanValue\":",
                    "      return node.value ? \"true\" : \"false\";",
                    "",
                    "    case \"NullValue\":",
                    "      return \"null\";",
                    "",
                    "    case \"Variable\":",
                    "      return [\"$\", print(\"name\")];",
                    "",
                    "    case \"ListValue\":",
                    "      return group([",
                    "        \"[\",",
                    "        indent([",
                    "          softline,",
                    "          join([ifBreak(\"\", \", \"), softline], path.map(print, \"values\")),",
                    "        ]),",
                    "        softline,",
                    "        \"]\",",
                    "      ]);",
                    "",
                    "    case \"ObjectValue\": {",
                    "      const bracketSpace =",
                    "        options.bracketSpacing && node.fields.length > 0 ? \" \" : \"\";",
                    "      return group([",
                    "        \"{\",",
                    "        bracketSpace,",
                    "        indent([",
                    "          softline,",
                    "          join([ifBreak(\"\", \", \"), softline], path.map(print, \"fields\")),",
                    "        ]),",
                    "        softline,",
                    "        ifBreak(\"\", bracketSpace),",
                    "        \"}\",",
                    "      ]);",
                    "    }",
                    "",
                    "    case \"ObjectField\":",
                    "    case \"Argument\":",
                    "      return [print(\"name\"), \": \", print(\"value\")];",
                    "",
                    "    case \"Directive\":",
                    "      return [",
                    "        \"@\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "      ];",
                    "",
                    "    case \"NamedType\":",
                    "      return print(\"name\");",
                    "",
                    "    case \"VariableDefinition\":",
                    "      return [",
                    "        print(\"variable\"),",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        node.defaultValue ? [\" = \", print(\"defaultValue\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"ObjectTypeExtension\":",
                    "    case \"ObjectTypeDefinition\":",
                    "    case \"InputObjectTypeExtension\":",
                    "    case \"InputObjectTypeDefinition\":",
                    "    case \"InterfaceTypeExtension\":",
                    "    case \"InterfaceTypeDefinition\": {",
                    "      const { kind } = node;",
                    "      const parts = [];",
                    "",
                    "      if (kind.endsWith(\"TypeDefinition\")) {",
                    "        parts.push(printDescription(path, options, print));",
                    "      } else {",
                    "        parts.push(\"extend \");",
                    "      }",
                    "",
                    "      if (kind.startsWith(\"ObjectType\")) {",
                    "        parts.push(\"type\");",
                    "      } else if (kind.startsWith(\"InputObjectType\")) {",
                    "        parts.push(\"input\");",
                    "      } else {",
                    "        parts.push(\"interface\");",
                    "      }",
                    "      parts.push(\" \", print(\"name\"));",
                    "",
                    "      if (!kind.startsWith(\"InputObjectType\") && node.interfaces.length > 0) {",
                    "        parts.push(\" implements \", ...printInterfaces(path, options, print));",
                    "      }",
                    "",
                    "      parts.push(printDirectives(path, print, node));",
                    "",
                    "      if (node.fields.length > 0) {",
                    "        parts.push([",
                    "          \" {\",",
                    "          indent([",
                    "            hardline,",
                    "            join(hardline, printSequence(path, options, print, \"fields\")),",
                    "          ]),",
                    "          hardline,",
                    "          \"}\",",
                    "        ]);",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "",
                    "    case \"FieldDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"DirectiveDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        \"directive \",",
                    "        \"@\",",
                    "        print(\"name\"),",
                    "        node.arguments.length > 0",
                    "          ? group([",
                    "              \"(\",",
                    "              indent([",
                    "                softline,",
                    "                join(",
                    "                  [ifBreak(\"\", \", \"), softline],",
                    "                  printSequence(path, options, print, \"arguments\")",
                    "                ),",
                    "              ]),",
                    "              softline,",
                    "              \")\",",
                    "            ])",
                    "          : \"\",",
                    "        node.repeatable ? \" repeatable\" : \"\",",
                    "        \" on \",",
                    "        ...join(\" | \", path.map(print, \"locations\")),",
                    "      ];",
                    "",
                    "    case \"EnumTypeExtension\":",
                    "    case \"EnumTypeDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        node.kind === \"EnumTypeExtension\" ? \"extend \" : \"\",",
                    "        \"enum \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "        node.values.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(hardline, printSequence(path, options, print, \"values\")),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : \"\",",
                    "      ];",
                    "",
                    "    case \"EnumValueDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"InputValueDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        print(\"name\"),",
                    "        \": \",",
                    "        print(\"type\"),",
                    "        node.defaultValue ? [\" = \", print(\"defaultValue\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"SchemaExtension\":",
                    "      return [",
                    "        \"extend schema\",",
                    "        printDirectives(path, print, node),",
                    "        ...(node.operationTypes.length > 0",
                    "          ? [",
                    "              \" {\",",
                    "              indent([",
                    "                hardline,",
                    "                join(",
                    "                  hardline,",
                    "                  printSequence(path, options, print, \"operationTypes\")",
                    "                ),",
                    "              ]),",
                    "              hardline,",
                    "              \"}\",",
                    "            ]",
                    "          : []),",
                    "      ];",
                    "",
                    "    case \"SchemaDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        \"schema\",",
                    "        printDirectives(path, print, node),",
                    "        \" {\",",
                    "        node.operationTypes.length > 0",
                    "          ? indent([",
                    "              hardline,",
                    "              join(",
                    "                hardline,",
                    "                printSequence(path, options, print, \"operationTypes\")",
                    "              ),",
                    "            ])",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "",
                    "    case \"OperationTypeDefinition\":",
                    "      return [node.operation, \": \", print(\"type\")];",
                    "",
                    "    case \"FragmentSpread\":",
                    "      return [\"...\", print(\"name\"), printDirectives(path, print, node)];",
                    "",
                    "    case \"InlineFragment\":",
                    "      return [",
                    "        \"...\",",
                    "        node.typeCondition ? [\" on \", print(\"typeCondition\")] : \"\",",
                    "        printDirectives(path, print, node),",
                    "        \" \",",
                    "        print(\"selectionSet\"),",
                    "      ];",
                    "",
                    "    case \"UnionTypeExtension\":",
                    "    case \"UnionTypeDefinition\":",
                    "      return group([",
                    "        printDescription(path, options, print),",
                    "        group([",
                    "          node.kind === \"UnionTypeExtension\" ? \"extend \" : \"\",",
                    "          \"union \",",
                    "          print(\"name\"),",
                    "          printDirectives(path, print, node),",
                    "          node.types.length > 0",
                    "            ? [",
                    "                \" =\",",
                    "                ifBreak(\"\", \" \"),",
                    "                indent([",
                    "                  ifBreak([line, \"  \"]),",
                    "                  join([line, \"| \"], path.map(print, \"types\")),",
                    "                ]),",
                    "              ]",
                    "            : \"\",",
                    "        ]),",
                    "      ]);",
                    "",
                    "    case \"ScalarTypeExtension\":",
                    "    case \"ScalarTypeDefinition\":",
                    "      return [",
                    "        printDescription(path, options, print),",
                    "        node.kind === \"ScalarTypeExtension\" ? \"extend \" : \"\",",
                    "        \"scalar \",",
                    "        print(\"name\"),",
                    "        printDirectives(path, print, node),",
                    "      ];",
                    "",
                    "    case \"NonNullType\":",
                    "      return [print(\"type\"), \"!\"];",
                    "",
                    "    case \"ListType\":",
                    "      return [\"[\", print(\"type\"), \"]\"];",
                    "",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"Graphql\", \"kind\");",
                    "  }",
                    "}",
                    "",
                    "function printDirectives(path, print, node) {",
                    "  if (node.directives.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const printed = join(line, path.map(print, \"directives\"));",
                    "",
                    "  if (",
                    "    node.kind === \"FragmentDefinition\" ||",
                    "    node.kind === \"OperationDefinition\"",
                    "  ) {",
                    "    return group([line, printed]);",
                    "  }",
                    "",
                    "  return [\" \", group(indent([softline, printed]))];",
                    "}",
                    "",
                    "function printSequence(path, options, print, property) {",
                    "  return path.map(({ isLast, node }) => {",
                    "    const printed = print();",
                    "",
                    "    if (!isLast && isNextLineEmpty(options.originalText, locEnd(node))) {",
                    "      return [printed, hardline];",
                    "    }",
                    "",
                    "    return printed;",
                    "  }, property);",
                    "}",
                    "",
                    "function canAttachComment(node) {",
                    "  return node.kind !== \"Comment\";",
                    "}",
                    "",
                    "function printComment(commentPath) {",
                    "  const comment = commentPath.node;",
                    "  if (comment.kind === \"Comment\") {",
                    "    return \"#\" + comment.value.trimEnd();",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                    "}",
                    "",
                    "function printInterfaces(path, options, print) {",
                    "  const { node } = path;",
                    "  const parts = [];",
                    "  const { interfaces } = node;",
                    "  const printed = path.map(print, \"interfaces\");",
                    "",
                    "  for (let index = 0; index < interfaces.length; index++) {",
                    "    const interfaceNode = interfaces[index];",
                    "    parts.push(printed[index]);",
                    "    const nextInterfaceNode = interfaces[index + 1];",
                    "    if (nextInterfaceNode) {",
                    "      const textBetween = options.originalText.slice(",
                    "        interfaceNode.loc.end,",
                    "        nextInterfaceNode.loc.start",
                    "      );",
                    "      const hasComment = textBetween.includes(\"#\");",
                    "",
                    "      parts.push(\" &\", hasComment ? line : \" \");",
                    "    }",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function printVariableDefinitions(path, print) {",
                    "  const { node } = path;",
                    "  if (!isNonEmptyArray(node.variableDefinitions)) {",
                    "    return \"\";",
                    "  }",
                    "  return group([",
                    "    \"(\",",
                    "    indent([",
                    "      softline,",
                    "      join(",
                    "        [ifBreak(\"\", \", \"), softline],",
                    "        path.map(print, \"variableDefinitions\")",
                    "      ),",
                    "    ]),",
                    "    softline,",
                    "    \")\",",
                    "  ]);",
                    "}",
                    "",
                    "function clean(node, newNode /* , parent */) {",
                    "  // We print single line `\"\"\" string \"\"\"` as multiple line string,",
                    "  // and the parser ignores space in multiple line string",
                    "  if (node.kind === \"StringValue\" && node.block && !node.value.includes(\"\\n\")) {",
                    "    newNode.value = newNode.value.trim();",
                    "  }",
                    "}",
                    "clean.ignoredProperties = new Set([\"loc\", \"comments\"]);",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const { node } = path;",
                    "  return node?.comments?.some(",
                    "    (comment) => comment.value.trim() === \"prettier-ignore\"",
                    "  );",
                    "}",
                    "",
                    "const printer = {",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  insertPragma,",
                    "  printComment,",
                    "  canAttachComment,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export { QueryDocumentKeys as default } from \"graphql/language/ast.mjs\";"
                ]
            },
            "print": {
                "description.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { hardline, line } from \"../../document/builders.js\";",
                        "",
                        "function printDescription(path, options, print) {",
                        "  const { node } = path;",
                        "  if (!node.description) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const parts = [print(\"description\")];",
                        "  if (node.kind === \"InputValueDefinition\" && !node.description.block) {",
                        "    parts.push(line);",
                        "  } else {",
                        "    parts.push(hardline);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export default printDescription;"
                    ]
                }
            }
        },
        "language-handlebars": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import htmlWhitespaceUtils from \"../utils/html-whitespace-utils.js\";",
                    "",
                    "function clean(ast, newNode /*, parent*/) {",
                    "  // (Glimmer/HTML) ignore TextNode",
                    "  if (ast.type === \"TextNode\") {",
                    "    const trimmed = ast.chars.trim();",
                    "    if (!trimmed) {",
                    "      return null;",
                    "    }",
                    "    newNode.chars = htmlWhitespaceUtils.split(trimmed).join(\" \");",
                    "  }",
                    "",
                    "  // `class` is reformatted",
                    "  if (ast.type === \"AttrNode\" && ast.name.toLowerCase() === \"class\") {",
                    "    delete newNode.value;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = new Set([\"loc\", \"selfClosing\"]);",
                    "",
                    "export default clean;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.evaluate.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "html-void-elements.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { voidMap } from \"@glimmer/syntax/dist/commonjs/es2017/lib/generation/printer.js\";",
                    "",
                    "export default Object.keys(voidMap);"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-glimmer.js\";",
                    "",
                    "export const printers = {",
                    "  glimmer: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-glimmer.js\"),",
                    "    parserNames: [\"glimmer\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.Handlebars, () => ({",
                    "    parsers: [\"glimmer\"],",
                    "    vscodeLanguageIds: [\"handlebars\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(node) {",
                    "  return node.loc.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.loc.end.offset;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "parser-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/*",
                    "  The module version `@glimmer/syntax/dist/modules/es2017/lib/parser/tokenizer-event-handlers.js`",
                    "  can't be be imported since it use `.js` extension, and don't have `type: module` in `package.json`",
                    "  We'll replace it during build",
                    "  */",
                    "import { preprocess as parseGlimmer } from \"@glimmer/syntax/dist/commonjs/es2017/lib/parser/tokenizer-event-handlers.js\";",
                    "import { LinesAndColumns } from \"lines-and-columns\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "",
                    "/* from the following template: `non-escaped mustache \\\\{{helper}}`",
                    " * glimmer parser will produce an AST missing a backslash",
                    " * so here we add it back",
                    " * */",
                    "function addBackslash(node) {",
                    "  const childrenOrBody = node.children ?? node.body;",
                    "  if (childrenOrBody) {",
                    "    for (let i = 0; i < childrenOrBody.length - 1; i++) {",
                    "      if (",
                    "        childrenOrBody[i].type === \"TextNode\" &&",
                    "        childrenOrBody[i + 1].type === \"MustacheStatement\"",
                    "      ) {",
                    "        childrenOrBody[i].chars = childrenOrBody[i].chars.replace(",
                    "          /\\\\$/,",
                    "          \"\\\\\\\\\"",
                    "        );",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "// Combine plugins to reduce traverse https://github.com/glimmerjs/glimmer-vm/blob/cdfb8f93d7ff0b504c8e9eab293f656a9b942025/packages/%40glimmer/syntax/lib/parser/tokenizer-event-handlers.ts#L442-L451",
                    "function createPlugin(text) {",
                    "  const lines = new LinesAndColumns(text);",
                    "  const calculateOffset = ({ line, column }) =>",
                    "    lines.indexForLocation({ line: line - 1, column });",
                    "",
                    "  // Add `loc.{start,end}.offset`",
                    "  const addOffset = (node) => {",
                    "    const { start, end } = node.loc;",
                    "    start.offset = calculateOffset(start);",
                    "    end.offset = calculateOffset(end);",
                    "  };",
                    "",
                    "  return (/* options*/) => ({",
                    "    name: \"prettierParsePlugin\",",
                    "    visitor: {",
                    "      All(node) {",
                    "        addOffset(node);",
                    "        addBackslash(node);",
                    "      },",
                    "    },",
                    "  });",
                    "}",
                    "",
                    "function parse(text /*, options */) {",
                    "  let ast;",
                    "  try {",
                    "    ast = parseGlimmer(text, {",
                    "      mode: \"codemod\",",
                    "      plugins: { ast: [createPlugin(text)] },",
                    "    });",
                    "  } catch (error) {",
                    "    const location = getErrorLocation(error);",
                    "",
                    "    if (location) {",
                    "      const message = getErrorMessage(error);",
                    "",
                    "      throw createError(message, { loc: location, cause: error });",
                    "    }",
                    "",
                    "    /* c8 ignore next */",
                    "    throw error;",
                    "  }",
                    "",
                    "  return ast;",
                    "}",
                    "",
                    "function getErrorMessage(error) {",
                    "  const { message } = error;",
                    "  const lines = message.split(\"\\n\");",
                    "",
                    "  /*",
                    "  This kind of errors are like:",
                    "",
                    "  ```",
                    "  Parse error on line 2:",
                    "  <A >x, {{@name}",
                    "  --------------^",
                    "  Expecting ...",
                    "  ```",
                    "  */",
                    "  if (",
                    "    lines.length >= 4 &&",
                    "    /^Parse error on line \\d+:$/.test(lines[0]) &&",
                    "    /^-*\\^$/.test(lines.at(-2))",
                    "  ) {",
                    "    return lines.at(-1);",
                    "  }",
                    "",
                    "  /*",
                    "  This kind of errors are like:",
                    "",
                    "  ```",
                    "  Unclosed element \\`@name\\`:",
                    "",
                    "  |",
                    "  |  <{@name>",
                    "  |",
                    "",
                    "  (error occurred in 'an unknown module' @ line 3 : column 0)",
                    "  ```",
                    "  */",
                    "  if (",
                    "    lines.length >= 4 &&",
                    "    /:\\s?$/.test(lines[0]) &&",
                    "    /^\\(error occurred in '.*?' @ line \\d+ : column \\d+\\)$/.test(",
                    "      lines.at(-1)",
                    "    ) &&",
                    "    lines[1] === \"\" &&",
                    "    lines.at(-2) === \"\" &&",
                    "    lines.slice(2, -2).every((line) => line.startsWith(\"|\"))",
                    "  ) {",
                    "    return lines[0].trim().slice(0, -1);",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  return message;",
                    "}",
                    "",
                    "function getErrorLocation(error) {",
                    "  const { location, hash } = error;",
                    "  if (location) {",
                    "    const { start, end } = location;",
                    "    if (typeof end.line !== \"number\") {",
                    "      return { start };",
                    "    }",
                    "    return location;",
                    "  }",
                    "",
                    "  if (hash) {",
                    "    const {",
                    "      loc: { last_line, last_column },",
                    "    } = hash;",
                    "    return { start: { line: last_line, column: last_column + 1 } };",
                    "  }",
                    "}",
                    "",
                    "export const glimmer = {",
                    "  parse,",
                    "  astFormat: \"glimmer\",",
                    "  locStart,",
                    "  locEnd,",
                    "};"
                ]
            },
            "printer-glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  dedent,",
                    "  fill,",
                    "  group,",
                    "  hardline,",
                    "  ifBreak,",
                    "  indent,",
                    "  join,",
                    "  line,",
                    "  softline,",
                    "} from \"../document/builders.js\";",
                    "import { replaceEndOfLine } from \"../document/utils.js\";",
                    "import getPreferredQuote from \"../utils/get-preferred-quote.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import htmlWhitespaceUtils from \"../utils/html-whitespace-utils.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import clean from \"./clean.js\";",
                    "import { hasPrettierIgnore, isVoidElement, isWhitespaceNode } from \"./utils.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                    " */",
                    "",
                    "const NEWLINES_TO_PRESERVE_MAX = 2;",
                    "",
                    "// Formatter based on @glimmerjs/syntax's built-in test formatter:",
                    "// https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts",
                    "",
                    "function print(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"Block\":",
                    "    case \"Program\":",
                    "    case \"Template\":",
                    "      return group(path.map(print, \"body\"));",
                    "",
                    "    case \"ElementNode\": {",
                    "      const startingTag = group(printStartingTag(path, print));",
                    "",
                    "      const escapeNextElementNode =",
                    "        options.htmlWhitespaceSensitivity === \"ignore\" &&",
                    "        path.next?.type === \"ElementNode\"",
                    "          ? softline",
                    "          : \"\";",
                    "",
                    "      if (isVoidElement(node)) {",
                    "        return [startingTag, escapeNextElementNode];",
                    "      }",
                    "",
                    "      const endingTag = [\"</\", node.tag, \">\"];",
                    "",
                    "      if (node.children.length === 0) {",
                    "        return [startingTag, indent(endingTag), escapeNextElementNode];",
                    "      }",
                    "",
                    "      if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "        return [",
                    "          startingTag,",
                    "          indent(printChildren(path, options, print)),",
                    "          hardline,",
                    "          indent(endingTag),",
                    "          escapeNextElementNode,",
                    "        ];",
                    "      }",
                    "",
                    "      return [",
                    "        startingTag,",
                    "        indent(group(printChildren(path, options, print))),",
                    "        indent(endingTag),",
                    "        escapeNextElementNode,",
                    "      ];",
                    "    }",
                    "",
                    "    case \"BlockStatement\":",
                    "      if (isElseIfLike(path)) {",
                    "        return [",
                    "          printElseIfLikeBlock(path, print),",
                    "          printProgram(path, print, options),",
                    "          printInverse(path, print, options),",
                    "        ];",
                    "      }",
                    "",
                    "      return [",
                    "        printOpenBlock(path, print),",
                    "        group([",
                    "          printProgram(path, print, options),",
                    "          printInverse(path, print, options),",
                    "          printCloseBlock(path, print, options),",
                    "        ]),",
                    "      ];",
                    "",
                    "    case \"ElementModifierStatement\":",
                    "      return group([\"{{\", printPathAndParams(path, print), \"}}\"]);",
                    "",
                    "    case \"MustacheStatement\":",
                    "      return group([",
                    "        printOpeningMustache(node),",
                    "        printPathAndParams(path, print),",
                    "        printClosingMustache(node),",
                    "      ]);",
                    "",
                    "    case \"SubExpression\":",
                    "      return group([",
                    "        \"(\",",
                    "        printSubExpressionPathAndParams(path, print),",
                    "        softline,",
                    "        \")\",",
                    "      ]);",
                    "",
                    "    case \"AttrNode\": {",
                    "      const { name, value } = node;",
                    "      const isText = value.type === \"TextNode\";",
                    "      const isEmptyText = isText && value.chars === \"\";",
                    "",
                    "      // If the text is empty and the value's loc start and end offsets are the",
                    "      // same, there is no value for this AttrNode and it should be printed",
                    "      // without the `=\"\"`. Example: `<img data-test>` -> `<img data-test>`",
                    "      if (isEmptyText && locStart(value) === locEnd(value)) {",
                    "        return name;",
                    "      }",
                    "",
                    "      // Let's assume quotes inside the content of text nodes are already",
                    "      // properly escaped with entities, otherwise the parse wouldn't have parsed them.",
                    "      const quote = isText",
                    "        ? getPreferredQuote(value.chars, options.singleQuote)",
                    "        : value.type === \"ConcatStatement\"",
                    "        ? getPreferredQuote(",
                    "            value.parts",
                    "              .map((part) => (part.type === \"TextNode\" ? part.chars : \"\"))",
                    "              .join(\"\"),",
                    "            options.singleQuote",
                    "          )",
                    "        : \"\";",
                    "",
                    "      const valueDoc = print(\"value\");",
                    "",
                    "      return [",
                    "        name,",
                    "        \"=\",",
                    "        quote,",
                    "        name === \"class\" && quote ? group(indent(valueDoc)) : valueDoc,",
                    "        quote,",
                    "      ];",
                    "    }",
                    "",
                    "    case \"ConcatStatement\":",
                    "      return path.map(print, \"parts\");",
                    "",
                    "    case \"Hash\":",
                    "      return join(line, path.map(print, \"pairs\"));",
                    "",
                    "    case \"HashPair\":",
                    "      return [node.key, \"=\", print(\"value\")];",
                    "",
                    "    case \"TextNode\": {",
                    "      /* if `{{my-component}}` (or any text containing \"{{\")",
                    "       * makes it to the TextNode, it means it was escaped,",
                    "       * so let's print it escaped, ie.; `\\{{my-component}}` */",
                    "      let text = node.chars.replaceAll(\"{{\", \"\\\\{{\");",
                    "",
                    "      const attrName = getCurrentAttributeName(path);",
                    "",
                    "      if (attrName) {",
                    "        // TODO: format style and srcset attributes",
                    "        if (attrName === \"class\") {",
                    "          const formattedClasses = text.trim().split(/\\s+/).join(\" \");",
                    "",
                    "          let leadingSpace = false;",
                    "          let trailingSpace = false;",
                    "",
                    "          if (path.parent.type === \"ConcatStatement\") {",
                    "            if (",
                    "              path.previous?.type === \"MustacheStatement\" &&",
                    "              /^\\s/.test(text)",
                    "            ) {",
                    "              leadingSpace = true;",
                    "            }",
                    "            if (",
                    "              path.next?.type === \"MustacheStatement\" &&",
                    "              /\\s$/.test(text) &&",
                    "              formattedClasses !== \"\"",
                    "            ) {",
                    "              trailingSpace = true;",
                    "            }",
                    "          }",
                    "",
                    "          return [",
                    "            leadingSpace ? line : \"\",",
                    "            formattedClasses,",
                    "            trailingSpace ? line : \"\",",
                    "          ];",
                    "        }",
                    "",
                    "        return replaceEndOfLine(text);",
                    "      }",
                    "",
                    "      const isWhitespaceOnly = htmlWhitespaceUtils.isWhitespaceOnly(text);",
                    "      const { isFirst, isLast } = path;",
                    "",
                    "      if (options.htmlWhitespaceSensitivity !== \"ignore\") {",
                    "        // let's remove the file's final newline",
                    "        // https://github.com/ember-cli/ember-new-output/blob/1a04c67ddd02ccb35e0ff41bb5cbce34b31173ef/.editorconfig#L16",
                    "        const shouldTrimTrailingNewlines =",
                    "          isLast && path.parent.type === \"Template\";",
                    "        const shouldTrimLeadingNewlines =",
                    "          isFirst && path.parent.type === \"Template\";",
                    "",
                    "        if (isWhitespaceOnly) {",
                    "          if (shouldTrimLeadingNewlines || shouldTrimTrailingNewlines) {",
                    "            return \"\";",
                    "          }",
                    "",
                    "          let breaks = [line];",
                    "",
                    "          const newlines = countNewLines(text);",
                    "          if (newlines) {",
                    "            breaks = generateHardlines(newlines);",
                    "          }",
                    "",
                    "          if (isLast) {",
                    "            breaks = breaks.map((newline) => dedent(newline));",
                    "          }",
                    "",
                    "          return breaks;",
                    "        }",
                    "",
                    "        const leadingWhitespace =",
                    "          htmlWhitespaceUtils.getLeadingWhitespace(text);",
                    "",
                    "        let leadBreaks = [];",
                    "        if (leadingWhitespace) {",
                    "          leadBreaks = [line];",
                    "",
                    "          const leadingNewlines = countNewLines(leadingWhitespace);",
                    "          if (leadingNewlines) {",
                    "            leadBreaks = generateHardlines(leadingNewlines);",
                    "          }",
                    "",
                    "          text = text.slice(leadingWhitespace.length);",
                    "        }",
                    "",
                    "        const tailingWhitespace =",
                    "          htmlWhitespaceUtils.getTrailingWhitespace(text);",
                    "        let trailBreaks = [];",
                    "        if (tailingWhitespace) {",
                    "          if (!shouldTrimTrailingNewlines) {",
                    "            trailBreaks = [line];",
                    "",
                    "            const trailingNewlines = countNewLines(tailingWhitespace);",
                    "            if (trailingNewlines) {",
                    "              trailBreaks = generateHardlines(trailingNewlines);",
                    "            }",
                    "",
                    "            if (isLast) {",
                    "              trailBreaks = trailBreaks.map((hardline) => dedent(hardline));",
                    "            }",
                    "          }",
                    "",
                    "          text = text.slice(0, -tailingWhitespace.length);",
                    "        }",
                    "",
                    "        return [...leadBreaks, fill(getTextValueParts(text)), ...trailBreaks];",
                    "      }",
                    "",
                    "      const lineBreaksCount = countNewLines(text);",
                    "",
                    "      let leadingLineBreaksCount = countLeadingNewLines(text);",
                    "      let trailingLineBreaksCount = countTrailingNewLines(text);",
                    "",
                    "      if (",
                    "        (isFirst || isLast) &&",
                    "        isWhitespaceOnly &&",
                    "        (path.parent.type === \"Block\" ||",
                    "          path.parent.type === \"ElementNode\" ||",
                    "          path.parent.type === \"Template\")",
                    "      ) {",
                    "        return \"\";",
                    "      }",
                    "",
                    "      if (isWhitespaceOnly && lineBreaksCount) {",
                    "        leadingLineBreaksCount = Math.min(",
                    "          lineBreaksCount,",
                    "          NEWLINES_TO_PRESERVE_MAX",
                    "        );",
                    "        trailingLineBreaksCount = 0;",
                    "      } else {",
                    "        if (",
                    "          path.next?.type === \"BlockStatement\" ||",
                    "          path.next?.type === \"ElementNode\"",
                    "        ) {",
                    "          trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);",
                    "        }",
                    "",
                    "        if (",
                    "          path.previous?.type === \"BlockStatement\" ||",
                    "          path.previous?.type === \"ElementNode\"",
                    "        ) {",
                    "          leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);",
                    "        }",
                    "      }",
                    "",
                    "      let leadingSpace = \"\";",
                    "      let trailingSpace = \"\";",
                    "",
                    "      if (",
                    "        trailingLineBreaksCount === 0 &&",
                    "        path.next?.type === \"MustacheStatement\"",
                    "      ) {",
                    "        trailingSpace = \" \";",
                    "      }",
                    "",
                    "      if (",
                    "        leadingLineBreaksCount === 0 &&",
                    "        path.previous?.type === \"MustacheStatement\"",
                    "      ) {",
                    "        leadingSpace = \" \";",
                    "      }",
                    "",
                    "      if (isFirst) {",
                    "        leadingLineBreaksCount = 0;",
                    "        leadingSpace = \"\";",
                    "      }",
                    "",
                    "      if (isLast) {",
                    "        trailingLineBreaksCount = 0;",
                    "        trailingSpace = \"\";",
                    "      }",
                    "",
                    "      if (htmlWhitespaceUtils.hasLeadingWhitespace(text)) {",
                    "        text = leadingSpace + htmlWhitespaceUtils.trimStart(text);",
                    "      }",
                    "",
                    "      if (htmlWhitespaceUtils.hasTrailingWhitespace(text)) {",
                    "        text = htmlWhitespaceUtils.trimEnd(text) + trailingSpace;",
                    "      }",
                    "",
                    "      return [",
                    "        ...generateHardlines(leadingLineBreaksCount),",
                    "        fill(getTextValueParts(text)),",
                    "        ...generateHardlines(trailingLineBreaksCount),",
                    "      ];",
                    "    }",
                    "    case \"MustacheCommentStatement\": {",
                    "      const start = locStart(node);",
                    "      const end = locEnd(node);",
                    "      // Starts with `{{~`",
                    "      const isLeftWhiteSpaceSensitive =",
                    "        options.originalText.charAt(start + 2) === \"~\";",
                    "      // Ends with `{{~`",
                    "      const isRightWhitespaceSensitive =",
                    "        options.originalText.charAt(end - 3) === \"~\";",
                    "",
                    "      const dashes = node.value.includes(\"}}\") ? \"--\" : \"\";",
                    "      return [",
                    "        \"{{\",",
                    "        isLeftWhiteSpaceSensitive ? \"~\" : \"\",",
                    "        \"!\",",
                    "        dashes,",
                    "        node.value,",
                    "        dashes,",
                    "        isRightWhitespaceSensitive ? \"~\" : \"\",",
                    "        \"}}\",",
                    "      ];",
                    "    }",
                    "    case \"PathExpression\":",
                    "      return node.original;",
                    "",
                    "    case \"BooleanLiteral\":",
                    "      return String(node.value);",
                    "",
                    "    case \"CommentStatement\":",
                    "      return [\"<!--\", node.value, \"-->\"];",
                    "",
                    "    case \"StringLiteral\":",
                    "      return printStringLiteral(path, options);",
                    "",
                    "    case \"NumberLiteral\":",
                    "      return String(node.value);",
                    "",
                    "    case \"UndefinedLiteral\":",
                    "      return \"undefined\";",
                    "",
                    "    case \"NullLiteral\":",
                    "      return \"null\";",
                    "",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"Handlebars\");",
                    "  }",
                    "}",
                    "",
                    "/* ElementNode print helpers */",
                    "",
                    "function sortByLoc(a, b) {",
                    "  return locStart(a) - locStart(b);",
                    "}",
                    "",
                    "function printStartingTag(path, print) {",
                    "  const { node } = path;",
                    "",
                    "  const types = [\"attributes\", \"modifiers\", \"comments\"].filter((property) =>",
                    "    isNonEmptyArray(node[property])",
                    "  );",
                    "  const attributes = types.flatMap((type) => node[type]).sort(sortByLoc);",
                    "",
                    "  for (const attributeType of types) {",
                    "    path.each(({ node }) => {",
                    "      const index = attributes.indexOf(node);",
                    "      attributes.splice(index, 1, [line, print()]);",
                    "    }, attributeType);",
                    "  }",
                    "",
                    "  if (isNonEmptyArray(node.blockParams)) {",
                    "    attributes.push(line, printBlockParams(node));",
                    "  }",
                    "",
                    "  return [\"<\", node.tag, indent(attributes), printStartingTagEndMarker(node)];",
                    "}",
                    "",
                    "function printChildren(path, options, print) {",
                    "  const { node } = path;",
                    "  const isEmpty = node.children.every((node) => isWhitespaceNode(node));",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\" && isEmpty) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return path.map(({ isFirst }) => {",
                    "    const printedChild = print();",
                    "",
                    "    if (isFirst && options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "      return [softline, printedChild];",
                    "    }",
                    "",
                    "    return printedChild;",
                    "  }, \"children\");",
                    "}",
                    "",
                    "function printStartingTagEndMarker(node) {",
                    "  if (isVoidElement(node)) {",
                    "    return ifBreak([softline, \"/>\"], [\" />\", softline]);",
                    "  }",
                    "",
                    "  return ifBreak([softline, \">\"], \">\");",
                    "}",
                    "",
                    "/* MustacheStatement print helpers */",
                    "",
                    "function printOpeningMustache(node) {",
                    "  const mustache = node.escaped === false ? \"{{{\" : \"{{\";",
                    "  const strip = node.strip?.open ? \"~\" : \"\";",
                    "  return [mustache, strip];",
                    "}",
                    "",
                    "function printClosingMustache(node) {",
                    "  const mustache = node.escaped === false ? \"}}}\" : \"}}\";",
                    "  const strip = node.strip?.close ? \"~\" : \"\";",
                    "  return [strip, mustache];",
                    "}",
                    "",
                    "/* BlockStatement print helpers */",
                    "",
                    "function printOpeningBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.openStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip, \"#\"];",
                    "}",
                    "",
                    "function printOpeningBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.openStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printClosingBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.closeStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip, \"/\"];",
                    "}",
                    "",
                    "function printClosingBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.closeStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printInverseBlockOpeningMustache(node) {",
                    "  const opening = printOpeningMustache(node);",
                    "  const strip = node.inverseStrip.open ? \"~\" : \"\";",
                    "  return [opening, strip];",
                    "}",
                    "",
                    "function printInverseBlockClosingMustache(node) {",
                    "  const closing = printClosingMustache(node);",
                    "  const strip = node.inverseStrip.close ? \"~\" : \"\";",
                    "  return [strip, closing];",
                    "}",
                    "",
                    "function printOpenBlock(path, print) {",
                    "  const { node } = path;",
                    "  /** @type {Doc[]} */",
                    "  const parts = [];",
                    "",
                    "  const paramsDoc = printParams(path, print);",
                    "  if (paramsDoc) {",
                    "    parts.push(group(paramsDoc));",
                    "  }",
                    "",
                    "  if (isNonEmptyArray(node.program.blockParams)) {",
                    "    parts.push(printBlockParams(node.program));",
                    "  }",
                    "",
                    "  return group([",
                    "    printOpeningBlockOpeningMustache(node),",
                    "    printPath(path, print),",
                    "    parts.length > 0 ? indent([line, join(line, parts)]) : \"\",",
                    "    softline,",
                    "    printOpeningBlockClosingMustache(node),",
                    "  ]);",
                    "}",
                    "",
                    "function printElseBlock(node, options) {",
                    "  return [",
                    "    options.htmlWhitespaceSensitivity === \"ignore\" ? hardline : \"\",",
                    "    printInverseBlockOpeningMustache(node),",
                    "    \"else\",",
                    "    printInverseBlockClosingMustache(node),",
                    "  ];",
                    "}",
                    "",
                    "function isElseIfLike(path) {",
                    "  const { grandparent, node } = path;",
                    "  return (",
                    "    grandparent?.inverse?.body.length === 1 &&",
                    "    grandparent.inverse.body[0] === node &&",
                    "    grandparent.inverse.body[0].path.parts[0] === grandparent.path.parts[0]",
                    "  );",
                    "}",
                    "",
                    "function printElseIfLikeBlock(path, print) {",
                    "  const { node, grandparent } = path;",
                    "  return group([",
                    "    printInverseBlockOpeningMustache(grandparent),",
                    "    [\"else\", \" \", grandparent.inverse.body[0].path.parts[0]],",
                    "    indent([",
                    "      line,",
                    "      group(printParams(path, print)),",
                    "      ...(isNonEmptyArray(node.program.blockParams)",
                    "        ? [line, printBlockParams(node.program)]",
                    "        : []),",
                    "    ]),",
                    "    softline,",
                    "    printInverseBlockClosingMustache(grandparent),",
                    "  ]);",
                    "}",
                    "",
                    "function printCloseBlock(path, print, options) {",
                    "  const { node } = path;",
                    "",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "    const escape = blockStatementHasOnlyWhitespaceInProgram(node)",
                    "      ? softline",
                    "      : hardline;",
                    "",
                    "    return [",
                    "      escape,",
                    "      printClosingBlockOpeningMustache(node),",
                    "      print(\"path\"),",
                    "      printClosingBlockClosingMustache(node),",
                    "    ];",
                    "  }",
                    "",
                    "  return [",
                    "    printClosingBlockOpeningMustache(node),",
                    "    print(\"path\"),",
                    "    printClosingBlockClosingMustache(node),",
                    "  ];",
                    "}",
                    "",
                    "function blockStatementHasOnlyWhitespaceInProgram(node) {",
                    "  return (",
                    "    node.type === \"BlockStatement\" &&",
                    "    node.program.body.every((node) => isWhitespaceNode(node))",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElseIfLike(node) {",
                    "  return (",
                    "    blockStatementHasElse(node) &&",
                    "    node.inverse.body.length === 1 &&",
                    "    node.inverse.body[0].type === \"BlockStatement\" &&",
                    "    node.inverse.body[0].path.parts[0] === node.path.parts[0]",
                    "  );",
                    "}",
                    "",
                    "function blockStatementHasElse(node) {",
                    "  return node.type === \"BlockStatement\" && node.inverse;",
                    "}",
                    "",
                    "function printProgram(path, print, options) {",
                    "  const { node } = path;",
                    "",
                    "  if (blockStatementHasOnlyWhitespaceInProgram(node)) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const program = print(\"program\");",
                    "",
                    "  if (options.htmlWhitespaceSensitivity === \"ignore\") {",
                    "    return indent([hardline, program]);",
                    "  }",
                    "",
                    "  return indent(program);",
                    "}",
                    "",
                    "function printInverse(path, print, options) {",
                    "  const { node } = path;",
                    "",
                    "  const inverse = print(\"inverse\");",
                    "  const printed =",
                    "    options.htmlWhitespaceSensitivity === \"ignore\"",
                    "      ? [hardline, inverse]",
                    "      : inverse;",
                    "",
                    "  if (blockStatementHasElseIfLike(node)) {",
                    "    return printed;",
                    "  }",
                    "",
                    "  if (blockStatementHasElse(node)) {",
                    "    return [printElseBlock(node, options), indent(printed)];",
                    "  }",
                    "",
                    "  return \"\";",
                    "}",
                    "",
                    "/* TextNode print helpers */",
                    "",
                    "function getTextValueParts(value) {",
                    "  return join(line, htmlWhitespaceUtils.split(value));",
                    "}",
                    "",
                    "function getCurrentAttributeName(path) {",
                    "  for (let depth = 0; depth < 2; depth++) {",
                    "    const parentNode = path.getParentNode(depth);",
                    "    if (parentNode?.type === \"AttrNode\") {",
                    "      return parentNode.name.toLowerCase();",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function countNewLines(string) {",
                    "  /* c8 ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  return string.split(\"\\n\").length - 1;",
                    "}",
                    "",
                    "function countLeadingNewLines(string) {",
                    "  /* c8 ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/^([^\\S\\n\\r]*[\\n\\r])+/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function countTrailingNewLines(string) {",
                    "  /* c8 ignore next */",
                    "  string = typeof string === \"string\" ? string : \"\";",
                    "  const newLines = (string.match(/([\\n\\r][^\\S\\n\\r]*)+$/g) || [])[0] || \"\";",
                    "  return countNewLines(newLines);",
                    "}",
                    "",
                    "function generateHardlines(number = 0) {",
                    "  return Array.from({",
                    "    length: Math.min(number, NEWLINES_TO_PRESERVE_MAX),",
                    "  }).fill(hardline);",
                    "}",
                    "",
                    "/* StringLiteral print helpers */",
                    "",
                    "/** @typedef {import(\"../utils/get-preferred-quote.js\").Quote} Quote */",
                    "",
                    "/**",
                    " * Prints a string literal with the correct surrounding quotes based on",
                    " * `options.singleQuote` and the number of escaped quotes contained in",
                    " * the string literal. This function is the glimmer equivalent of `printString`",
                    " * in `common/util`, but has differences because of the way escaped characters",
                    " * are treated in hbs string literals.",
                    " */",
                    "function printStringLiteral(path, options) {",
                    "  const {",
                    "    node: { value },",
                    "  } = path;",
                    "",
                    "  const quote = getPreferredQuote(",
                    "    value,",
                    "    needsOppositeQuote(path) ? !options.singleQuote : options.singleQuote",
                    "  );",
                    "",
                    "  return [quote, value.replaceAll(quote, `\\\\${quote}`), quote];",
                    "}",
                    "",
                    "function needsOppositeQuote(path) {",
                    "  const { ancestors } = path;",
                    "  const level = ancestors.findIndex((node) => node.type !== \"SubExpression\");",
                    "",
                    "  return (",
                    "    level !== -1 &&",
                    "    ancestors[level + 1].type === \"ConcatStatement\" &&",
                    "    ancestors[level + 2].type === \"AttrNode\"",
                    "  );",
                    "}",
                    "",
                    "/* SubExpression print helpers */",
                    "",
                    "function printSubExpressionPathAndParams(path, print) {",
                    "  const printed = printPath(path, print);",
                    "  const params = printParams(path, print);",
                    "",
                    "  if (!params) {",
                    "    return printed;",
                    "  }",
                    "",
                    "  return indent([printed, line, group(params)]);",
                    "}",
                    "",
                    "/* misc. print helpers */",
                    "",
                    "function printPathAndParams(path, print) {",
                    "  const pathDoc = printPath(path, print);",
                    "  const paramsDoc = printParams(path, print);",
                    "",
                    "  if (!paramsDoc) {",
                    "    return pathDoc;",
                    "  }",
                    "",
                    "  return [indent([pathDoc, line, paramsDoc]), softline];",
                    "}",
                    "",
                    "function printPath(path, print) {",
                    "  return print(\"path\");",
                    "}",
                    "",
                    "function printParams(path, print) {",
                    "  const { node } = path;",
                    "  const parts = [];",
                    "",
                    "  if (node.params.length > 0) {",
                    "    parts.push(...path.map(print, \"params\"));",
                    "  }",
                    "",
                    "  if (node.hash?.pairs.length > 0) {",
                    "    parts.push(print(\"hash\"));",
                    "  }",
                    "",
                    "  if (parts.length === 0) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  return join(line, parts);",
                    "}",
                    "",
                    "function printBlockParams(node) {",
                    "  return [\"as |\", node.blockParams.join(\" \"), \"|\"];",
                    "}",
                    "",
                    "const printer = {",
                    "  print,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import htmlVoidElements from \"./html-void-elements.evaluate.js\";",
                    "",
                    "function isUppercase(string) {",
                    "  return string.toUpperCase() === string;",
                    "}",
                    "",
                    "function isGlimmerComponent(node) {",
                    "  return (",
                    "    node.type === \"ElementNode\" &&",
                    "    typeof node.tag === \"string\" &&",
                    "    !node.tag.startsWith(\":\") &&",
                    "    (isUppercase(node.tag[0]) || node.tag.includes(\".\"))",
                    "  );",
                    "}",
                    "",
                    "const voidTags = new Set(htmlVoidElements);",
                    "// https://github.com/glimmerjs/glimmer-vm/blob/ec5648f3895b9ab8d085523be001553746221449/packages/%40glimmer/syntax/lib/generation/printer.ts#L44-L46",
                    "function isVoidTag(tag) {",
                    "  return voidTags.has(tag.toLowerCase()) && !isUppercase(tag[0]);",
                    "}",
                    "",
                    "function isVoidElement(node) {",
                    "  return (",
                    "    node.selfClosing === true ||",
                    "    isVoidTag(node.tag) ||",
                    "    (isGlimmerComponent(node) &&",
                    "      node.children.every((node) => isWhitespaceNode(node)))",
                    "  );",
                    "}",
                    "",
                    "function isWhitespaceNode(node) {",
                    "  return node.type === \"TextNode\" && !/\\S/.test(node.chars);",
                    "}",
                    "",
                    "function isPrettierIgnoreNode(node) {",
                    "  return (",
                    "    node?.type === \"MustacheCommentStatement\" &&",
                    "    typeof node.value === \"string\" &&",
                    "    node.value.trim() === \"prettier-ignore\"",
                    "  );",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  return (",
                    "    isPrettierIgnoreNode(path.node) ||",
                    "    (path.isInArray &&",
                    "      (path.key === \"children\" ||",
                    "        path.key === \"body\" ||",
                    "        path.key === \"parts\") &&",
                    "      isPrettierIgnoreNode(path.siblings[path.index - 2]))",
                    "  );",
                    "}",
                    "",
                    "export { hasPrettierIgnore, isVoidElement, isWhitespaceNode };"
                ]
            },
            "visitor-keys.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import visitorKeys from \"@glimmer/syntax/dist/commonjs/es2017/lib/v1/visitor-keys.js\";",
                    "",
                    "export default visitorKeys.default;"
                ]
            }
        },
        "language-html": {
            "ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const NODES_KEYS = {",
                    "  attrs: true,",
                    "  children: true,",
                    "};",
                    "",
                    "const NON_ENUMERABLE_PROPERTIES = new Set([\"parent\"]);",
                    "",
                    "// TODO: typechecking is problematic for this class because of this issue:",
                    "// https://github.com/microsoft/TypeScript/issues/26811",
                    "",
                    "class Node {",
                    "  constructor(nodeOrProperties = {}) {",
                    "    for (const property of new Set([",
                    "      ...NON_ENUMERABLE_PROPERTIES,",
                    "      ...Object.keys(nodeOrProperties),",
                    "    ])) {",
                    "      this.setProperty(property, nodeOrProperties[property]);",
                    "    }",
                    "  }",
                    "",
                    "  setProperty(property, value) {",
                    "    if (this[property] === value) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (property in NODES_KEYS) {",
                    "      value = value.map((node) => this.createChild(node));",
                    "    }",
                    "",
                    "    if (!NON_ENUMERABLE_PROPERTIES.has(property)) {",
                    "      this[property] = value;",
                    "      return;",
                    "    }",
                    "",
                    "    Object.defineProperty(this, property, {",
                    "      value,",
                    "      enumerable: false,",
                    "      configurable: true,",
                    "    });",
                    "  }",
                    "",
                    "  map(fn) {",
                    "    /** @type{any} */",
                    "    let newNode;",
                    "",
                    "    for (const NODES_KEY in NODES_KEYS) {",
                    "      const nodes = this[NODES_KEY];",
                    "      if (nodes) {",
                    "        const mappedNodes = mapNodesIfChanged(nodes, (node) => node.map(fn));",
                    "        if (newNode !== nodes) {",
                    "          if (!newNode) {",
                    "            // @ts-expect-error",
                    "            newNode = new Node({ parent: this.parent });",
                    "          }",
                    "          newNode.setProperty(NODES_KEY, mappedNodes);",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    if (newNode) {",
                    "      for (const key in this) {",
                    "        if (!(key in NODES_KEYS)) {",
                    "          newNode[key] = this[key];",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return fn(newNode || this);",
                    "  }",
                    "",
                    "  walk(fn) {",
                    "    for (const NODES_KEY in NODES_KEYS) {",
                    "      const nodes = this[NODES_KEY];",
                    "      if (nodes) {",
                    "        for (let i = 0; i < nodes.length; i++) {",
                    "          nodes[i].walk(fn);",
                    "        }",
                    "      }",
                    "    }",
                    "    fn(this);",
                    "  }",
                    "",
                    "  createChild(nodeOrProperties) {",
                    "    const node =",
                    "      nodeOrProperties instanceof Node",
                    "        ? nodeOrProperties.clone()",
                    "        : new Node(nodeOrProperties);",
                    "    node.setProperty(\"parent\", this);",
                    "    return node;",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [target]",
                    "   * @param {Object} [node]",
                    "   */",
                    "  insertChildBefore(target, node) {",
                    "    // @ts-expect-error",
                    "    this.children.splice(",
                    "      // @ts-expect-error",
                    "      this.children.indexOf(target),",
                    "      0,",
                    "      this.createChild(node)",
                    "    );",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [child]",
                    "   */",
                    "  removeChild(child) {",
                    "    // @ts-expect-error",
                    "    this.children.splice(this.children.indexOf(child), 1);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Node} [target]",
                    "   * @param {Object} [node]",
                    "   */",
                    "  replaceChild(target, node) {",
                    "    // @ts-expect-error",
                    "    this.children[this.children.indexOf(target)] = this.createChild(node);",
                    "  }",
                    "",
                    "  clone() {",
                    "    return new Node(this);",
                    "  }",
                    "",
                    "  get firstChild() {",
                    "    // @ts-expect-error",
                    "    return this.children?.[0];",
                    "  }",
                    "",
                    "  get lastChild() {",
                    "    // @ts-expect-error",
                    "    return this.children?.[this.children.length - 1];",
                    "  }",
                    "",
                    "  get prev() {",
                    "    // @ts-expect-error",
                    "    return this.parent?.children[this.parent.children.indexOf(this) - 1];",
                    "  }",
                    "",
                    "  get next() {",
                    "    // @ts-expect-error",
                    "    return this.parent?.children[this.parent.children.indexOf(this) + 1];",
                    "  }",
                    "",
                    "  // for element and attribute",
                    "  get rawName() {",
                    "    // @ts-expect-error",
                    "    return this.hasExplicitNamespace ? this.fullName : this.name;",
                    "  }",
                    "",
                    "  get fullName() {",
                    "    // @ts-expect-error",
                    "    return this.namespace ? this.namespace + \":\" + this.name : this.name;",
                    "  }",
                    "",
                    "  get attrMap() {",
                    "    return Object.fromEntries(",
                    "      // @ts-expect-error",
                    "      this.attrs.map((attr) => [attr.fullName, attr.value])",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function mapNodesIfChanged(nodes, fn) {",
                    "  const newNodes = nodes.map(fn);",
                    "  return newNodes.some((newNode, index) => newNode !== nodes[index])",
                    "    ? newNodes",
                    "    : nodes;",
                    "}",
                    "",
                    "export { Node };"
                ]
            },
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isFrontMatter from \"../utils/front-matter/is-front-matter.js\";",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"sourceSpan\",",
                    "  \"startSourceSpan\",",
                    "  \"endSourceSpan\",",
                    "  \"nameSpan\",",
                    "  \"valueSpan\",",
                    "  \"keySpan\",",
                    "  \"tagDefinition\",",
                    "  \"tokens\",",
                    "  \"valueTokens\",",
                    "]);",
                    "",
                    "function clean(ast, newNode) {",
                    "  if (ast.type === \"text\" || ast.type === \"comment\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // may be formatted by multiparser",
                    "  if (isFrontMatter(ast) || ast.type === \"yaml\" || ast.type === \"toml\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"attribute\") {",
                    "    delete newNode.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"docType\") {",
                    "    delete newNode.value;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "export default clean;"
                ]
            },
            "conditional-comment.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { ParseSourceSpan } from \"angular-html-parser\";",
                    "",
                    "// https://css-tricks.com/how-to-create-an-ie-only-stylesheet",
                    "",
                    "const parseFunctions = [",
                    "  {",
                    "    // <!--[if ... ]> ... <![endif]-->",
                    "    regex: /^(\\[if([^\\]]*)]>)(.*?)<!\\s*\\[endif]$/s,",
                    "    parse: parseIeConditionalStartEndComment,",
                    "  },",
                    "  {",
                    "    // <!--[if ... ]><!-->",
                    "    regex: /^\\[if([^\\]]*)]><!$/,",
                    "    parse: parseIeConditionalStartComment,",
                    "  },",
                    "  {",
                    "    // <!--<![endif]-->",
                    "    regex: /^<!\\s*\\[endif]$/,",
                    "    parse: parseIeConditionalEndComment,",
                    "  },",
                    "];",
                    "",
                    "function parseIeConditionalComment(node, parseHtml) {",
                    "  if (node.value) {",
                    "    for (const { regex, parse } of parseFunctions) {",
                    "      const match = node.value.match(regex);",
                    "      if (match) {",
                    "        return parse(node, parseHtml, match);",
                    "      }",
                    "    }",
                    "  }",
                    "  return null;",
                    "}",
                    "",
                    "function parseIeConditionalStartEndComment(node, parseHtml, match) {",
                    "  const [, openingTagSuffix, condition, data] = match;",
                    "  const offset = \"<!--\".length + openingTagSuffix.length;",
                    "  const contentStartSpan = node.sourceSpan.start.moveBy(offset);",
                    "  const contentEndSpan = contentStartSpan.moveBy(data.length);",
                    "  const [complete, children] = (() => {",
                    "    try {",
                    "      return [true, parseHtml(data, contentStartSpan).children];",
                    "    } catch {",
                    "      const text = {",
                    "        type: \"text\",",
                    "        value: data,",
                    "        sourceSpan: new ParseSourceSpan(contentStartSpan, contentEndSpan),",
                    "      };",
                    "      return [false, [text]];",
                    "    }",
                    "  })();",
                    "  return {",
                    "    type: \"ieConditionalComment\",",
                    "    complete,",
                    "    children,",
                    "    condition: condition.trim().replaceAll(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "    startSourceSpan: new ParseSourceSpan(",
                    "      node.sourceSpan.start,",
                    "      contentStartSpan",
                    "    ),",
                    "    endSourceSpan: new ParseSourceSpan(contentEndSpan, node.sourceSpan.end),",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalStartComment(node, parseHtml, match) {",
                    "  const [, condition] = match;",
                    "  return {",
                    "    type: \"ieConditionalStartComment\",",
                    "    condition: condition.trim().replaceAll(/\\s+/g, \" \"),",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "function parseIeConditionalEndComment(node /*, parseHtml, match */) {",
                    "  return {",
                    "    type: \"ieConditionalEndComment\",",
                    "    sourceSpan: node.sourceSpan,",
                    "  };",
                    "}",
                    "",
                    "export { parseIeConditionalComment };"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import htmlStyles from \"html-styles\";",
                    "",
                    "const getCssStyleTags = (property) =>",
                    "  Object.fromEntries(",
                    "    htmlStyles",
                    "      .filter((htmlStyle) => htmlStyle.style[property])",
                    "      .flatMap((htmlStyle) =>",
                    "        htmlStyle.selectorText",
                    "          .split(\",\")",
                    "          .map((selector) => selector.trim())",
                    "          .filter((selector) => /^[\\dA-Za-z]+$/.test(selector))",
                    "          .map((tagName) => [tagName, htmlStyle.style[property]])",
                    "      )",
                    "  );",
                    "",
                    "const CSS_DISPLAY_TAGS = {",
                    "  ...getCssStyleTags(\"display\"),",
                    "",
                    "  // TODO: send PR to upstream",
                    "  button: \"inline-block\",",
                    "",
                    "  // special cases for some css display=none elements",
                    "  template: \"inline\",",
                    "  source: \"block\",",
                    "  track: \"block\",",
                    "  script: \"block\",",
                    "  param: \"block\",",
                    "",
                    "  // `noscript` is inline",
                    "  // noscript: \"inline\",",
                    "",
                    "  // there's no css display for these elements but they behave these ways",
                    "  details: \"block\",",
                    "  summary: \"block\",",
                    "  dialog: \"block\",",
                    "  meter: \"inline-block\",",
                    "  progress: \"inline-block\",",
                    "  object: \"inline-block\",",
                    "  video: \"inline-block\",",
                    "  audio: \"inline-block\",",
                    "  select: \"inline-block\",",
                    "  option: \"block\",",
                    "  optgroup: \"block\",",
                    "",
                    "  // Missing",
                    "  search: \"block\",",
                    "};",
                    "const CSS_DISPLAY_DEFAULT = \"inline\";",
                    "const CSS_WHITE_SPACE_TAGS = getCssStyleTags(\"white-space\");",
                    "const CSS_WHITE_SPACE_DEFAULT = \"normal\";",
                    "",
                    "export {",
                    "  CSS_DISPLAY_TAGS,",
                    "  CSS_DISPLAY_DEFAULT,",
                    "  CSS_WHITE_SPACE_TAGS,",
                    "  CSS_WHITE_SPACE_DEFAULT,",
                    "};"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  breakParent,",
                    "  group,",
                    "  hardline,",
                    "  indent,",
                    "  line,",
                    "} from \"../document/builders.js\";",
                    "import printFrontMatter from \"../utils/front-matter/print.js\";",
                    "import {",
                    "  printClosingTag,",
                    "  printClosingTagSuffix,",
                    "  needsToBorrowPrevClosingTagEndMarker,",
                    "  printOpeningTagPrefix,",
                    "  printOpeningTag,",
                    "} from \"./print/tag.js\";",
                    "import {",
                    "  isScriptLikeTag,",
                    "  isVueNonHtmlBlock,",
                    "  inferElementParser,",
                    "  htmlTrimPreserveIndentation,",
                    "  dedentString,",
                    "} from \"./utils/index.js\";",
                    "import isVueSfcWithTypescriptScript from \"./utils/is-vue-sfc-with-typescript-script.js\";",
                    "import getNodeContent from \"./get-node-content.js\";",
                    "import printAttribute from \"./embed/attribute.js\";",
                    "",
                    "function embed(path, options) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"element\":",
                    "      if (isScriptLikeTag(node) || node.type === \"interpolation\") {",
                    "        // Fall through to \"text\"",
                    "        return;",
                    "      }",
                    "",
                    "      if (!node.isSelfClosing && isVueNonHtmlBlock(node, options)) {",
                    "        const parser = inferElementParser(node, options);",
                    "        if (!parser) {",
                    "          return;",
                    "        }",
                    "",
                    "        return async (textToDoc, print) => {",
                    "          const content = getNodeContent(node, options);",
                    "          let isEmpty = /^\\s*$/.test(content);",
                    "          let doc = \"\";",
                    "          if (!isEmpty) {",
                    "            doc = await textToDoc(htmlTrimPreserveIndentation(content), {",
                    "              parser,",
                    "              __embeddedInHtml: true,",
                    "            });",
                    "            isEmpty = doc === \"\";",
                    "          }",
                    "",
                    "          return [",
                    "            printOpeningTagPrefix(node, options),",
                    "            group(printOpeningTag(path, options, print)),",
                    "            isEmpty ? \"\" : hardline,",
                    "            doc,",
                    "            isEmpty ? \"\" : hardline,",
                    "            printClosingTag(node, options),",
                    "            printClosingTagSuffix(node, options),",
                    "          ];",
                    "        };",
                    "      }",
                    "      break;",
                    "",
                    "    case \"text\":",
                    "      if (isScriptLikeTag(node.parent)) {",
                    "        const parser = inferElementParser(node.parent, options);",
                    "        if (parser) {",
                    "          return async (textToDoc) => {",
                    "            const value =",
                    "              parser === \"markdown\"",
                    "                ? dedentString(node.value.replace(/^[^\\S\\n]*\\n/, \"\"))",
                    "                : node.value;",
                    "            const textToDocOptions = { parser, __embeddedInHtml: true };",
                    "            if (options.parser === \"html\" && parser === \"babel\") {",
                    "              let sourceType = \"script\";",
                    "              const { attrMap } = node.parent;",
                    "              if (",
                    "                attrMap &&",
                    "                (attrMap.type === \"module\" ||",
                    "                  (attrMap.type === \"text/babel\" &&",
                    "                    attrMap[\"data-type\"] === \"module\"))",
                    "              ) {",
                    "                sourceType = \"module\";",
                    "              }",
                    "              textToDocOptions.__babelSourceType = sourceType;",
                    "            }",
                    "",
                    "            return [",
                    "              breakParent,",
                    "              printOpeningTagPrefix(node, options),",
                    "              await textToDoc(value, textToDocOptions, {",
                    "                stripTrailingHardline: true,",
                    "              }),",
                    "              printClosingTagSuffix(node, options),",
                    "            ];",
                    "          };",
                    "        }",
                    "      } else if (node.parent.type === \"interpolation\") {",
                    "        return async (textToDoc) => {",
                    "          const textToDocOptions = {",
                    "            __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                    "            __embeddedInHtml: true,",
                    "          };",
                    "          if (options.parser === \"angular\") {",
                    "            textToDocOptions.parser = \"__ng_interpolation\";",
                    "            textToDocOptions.trailingComma = \"none\";",
                    "          } else if (options.parser === \"vue\") {",
                    "            textToDocOptions.parser = isVueSfcWithTypescriptScript(",
                    "              path,",
                    "              options",
                    "            )",
                    "              ? \"__vue_ts_expression\"",
                    "              : \"__vue_expression\";",
                    "          } else {",
                    "            textToDocOptions.parser = \"__js_expression\";",
                    "          }",
                    "",
                    "          return [",
                    "            indent([line, await textToDoc(node.value, textToDocOptions)]),",
                    "            node.parent.next &&",
                    "            needsToBorrowPrevClosingTagEndMarker(node.parent.next)",
                    "              ? \" \"",
                    "              : line,",
                    "          ];",
                    "        };",
                    "      }",
                    "      break;",
                    "",
                    "    case \"attribute\":",
                    "      return printAttribute(path, options);",
                    "",
                    "    case \"front-matter\":",
                    "      return (textToDoc) => printFrontMatter(node, textToDoc);",
                    "  }",
                    "}",
                    "",
                    "export default embed;"
                ]
            },
            "get-node-content.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  needsToBorrowParentClosingTagStartMarker,",
                    "  printClosingTagStartMarker,",
                    "  needsToBorrowLastChildClosingTagEndMarker,",
                    "  printClosingTagEndMarker,",
                    "  needsToBorrowParentOpeningTagEndMarker,",
                    "  printOpeningTagEndMarker,",
                    "} from \"./print/tag.js\";",
                    "",
                    "function getNodeContent(node, options) {",
                    "  if (!node.endSourceSpan) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  let start = node.startSourceSpan.end.offset;",
                    "  if (",
                    "    node.firstChild &&",
                    "    needsToBorrowParentOpeningTagEndMarker(node.firstChild)",
                    "  ) {",
                    "    start -= printOpeningTagEndMarker(node).length;",
                    "  }",
                    "",
                    "  let end = node.endSourceSpan.start.offset;",
                    "  if (",
                    "    node.lastChild &&",
                    "    needsToBorrowParentClosingTagStartMarker(node.lastChild)",
                    "  ) {",
                    "    end += printClosingTagStartMarker(node, options).length;",
                    "  } else if (needsToBorrowLastChildClosingTagEndMarker(node)) {",
                    "    end -= printClosingTagEndMarker(node.lastChild, options).length;",
                    "  }",
                    "",
                    "  return options.originalText.slice(start, end);",
                    "}",
                    "",
                    "export default getNodeContent;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-html.js\";",
                    "",
                    "export const printers = {",
                    "  html: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-html.js\"),",
                    "    parserNames: [\"html\", \"vue\", \"angular\", \"lwc\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.HTML, () => ({",
                    "    name: \"Angular\",",
                    "    parsers: [\"angular\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [\".component.html\"],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(linguistLanguages.HTML, (data) => ({",
                    "    parsers: [\"html\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [",
                    "      ...data.extensions,",
                    "      \".mjml\", // MJML is considered XML in Linguist but it should be formatted as HTML",
                    "    ],",
                    "  })),",
                    "  createLanguage(linguistLanguages.HTML, () => ({",
                    "    name: \"Lightning Web Components\",",
                    "    parsers: [\"lwc\"],",
                    "    vscodeLanguageIds: [\"html\"],",
                    "    extensions: [],",
                    "    filenames: [],",
                    "  })),",
                    "  createLanguage(linguistLanguages.Vue, () => ({",
                    "    parsers: [\"vue\"],",
                    "    vscodeLanguageIds: [\"vue\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(node) {",
                    "  return node.sourceSpan.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.sourceSpan.end.offset;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "const CATEGORY_HTML = \"HTML\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  bracketSameLine: commonOptions.bracketSameLine,",
                    "  htmlWhitespaceSensitivity: {",
                    "    category: CATEGORY_HTML,",
                    "    type: \"choice\",",
                    "    default: \"css\",",
                    "    description: \"How to handle whitespaces in HTML.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"css\",",
                    "        description: \"Respect the default value of CSS display property.\",",
                    "      },",
                    "      {",
                    "        value: \"strict\",",
                    "        description: \"Whitespaces are considered sensitive.\",",
                    "      },",
                    "      {",
                    "        value: \"ignore\",",
                    "        description: \"Whitespaces are considered insensitive.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  singleAttributePerLine: commonOptions.singleAttributePerLine,",
                    "  vueIndentScriptAndStyle: {",
                    "    category: CATEGORY_HTML,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent script and style tags in Vue files.\",",
                    "  },",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import {",
                    "  ParseSourceFile,",
                    "  ParseLocation,",
                    "  ParseSourceSpan,",
                    "  parse as parseHtml,",
                    "  RecursiveVisitor,",
                    "  visitAll,",
                    "  getHtmlTagDefinition,",
                    "  TagContentType,",
                    "} from \"angular-html-parser\";",
                    "import parseFrontMatter from \"../utils/front-matter/parse.js\";",
                    "import inferParser from \"../utils/infer-parser.js\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import HTML_TAGS from \"./utils/html-tag-names.evaluate.js\";",
                    "import HTML_ELEMENT_ATTRIBUTES from \"./utils/html-elements-attributes.evaluate.js\";",
                    "import isUnknownNamespace from \"./utils/is-unknown-namespace.js\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import { Node } from \"./ast.js\";",
                    "import { parseIeConditionalComment } from \"./conditional-comment.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "",
                    "/**",
                    " * @typedef {import('angular-html-parser')} AngularHtmlParser",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast.js').Node} AstNode",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast.js').Attribute} Attribute",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/ast.js').Element} Element",
                    " * @typedef {import('angular-html-parser/lib/compiler/src/ml_parser/parser.js').ParseTreeResult} ParserTreeResult",
                    " * @typedef {import('angular-html-parser').ParseOptions & {",
                    " *   name: 'html' | 'angular' | 'vue' | 'lwc';",
                    " *   normalizeTagName?: boolean;",
                    " *   normalizeAttributeName?: boolean;",
                    " *   shouldParseAsRawText?: (tagName: string, prefix: string, hasParent: boolean, attrs: Array<{",
                    " *      prefix: string;",
                    " *      name: string;",
                    " *      value?: string;",
                    " *   }>) => boolean;",
                    " * }} ParseOptions",
                    " * @typedef {{filepath?: string}} Options",
                    " */",
                    "",
                    "/**",
                    " * @param {string} input",
                    " * @param {ParseOptions} parseOptions",
                    " * @param {Options} options",
                    " */",
                    "function ngHtmlParser(input, parseOptions, options) {",
                    "  const {",
                    "    name,",
                    "    canSelfClose = true,",
                    "    normalizeTagName = false,",
                    "    normalizeAttributeName = false,",
                    "    allowHtmComponentClosingTags = false,",
                    "    isTagNameCaseSensitive = false,",
                    "    shouldParseAsRawText,",
                    "  } = parseOptions;",
                    "",
                    "  let { rootNodes, errors } = parseHtml(input, {",
                    "    canSelfClose,",
                    "    allowHtmComponentClosingTags,",
                    "    isTagNameCaseSensitive,",
                    "    getTagContentType: shouldParseAsRawText",
                    "      ? (...args) =>",
                    "          shouldParseAsRawText(...args) ? TagContentType.RAW_TEXT : undefined",
                    "      : undefined,",
                    "  });",
                    "",
                    "  if (name === \"vue\") {",
                    "    const isHtml = rootNodes.some(",
                    "      (node) =>",
                    "        (node.type === \"docType\" && node.value === \"html\") ||",
                    "        (node.type === \"element\" && node.name.toLowerCase() === \"html\")",
                    "    );",
                    "",
                    "    // If not Vue SFC, treat as html",
                    "    if (isHtml) {",
                    "      return ngHtmlParser(input, HTML_PARSE_OPTIONS, options);",
                    "    }",
                    "",
                    "    /** @type {ParserTreeResult | undefined} */",
                    "    let secondParseResult;",
                    "    const getHtmlParseResult = () =>",
                    "      (secondParseResult ??= parseHtml(input, {",
                    "        canSelfClose,",
                    "        allowHtmComponentClosingTags,",
                    "        isTagNameCaseSensitive,",
                    "      }));",
                    "",
                    "    const getNodeWithSameLocation = (node) =>",
                    "      getHtmlParseResult().rootNodes.find(",
                    "        ({ startSourceSpan }) =>",
                    "          startSourceSpan &&",
                    "          startSourceSpan.start.offset === node.startSourceSpan.start.offset",
                    "      ) ?? node;",
                    "    for (const [index, node] of rootNodes.entries()) {",
                    "      const { endSourceSpan, startSourceSpan } = node;",
                    "      const isVoidElement = endSourceSpan === null;",
                    "      if (isVoidElement) {",
                    "        errors = getHtmlParseResult().errors;",
                    "        rootNodes[index] = getNodeWithSameLocation(node);",
                    "      } else if (shouldParseVueRootNodeAsHtml(node, options)) {",
                    "        const error = getHtmlParseResult().errors.find(",
                    "          (error) =>",
                    "            error.span.start.offset > startSourceSpan.start.offset &&",
                    "            error.span.start.offset < endSourceSpan.end.offset",
                    "        );",
                    "        if (error) {",
                    "          throwParseError(error);",
                    "        }",
                    "        rootNodes[index] = getNodeWithSameLocation(node);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  if (errors.length > 0) {",
                    "    throwParseError(errors[0]);",
                    "  }",
                    "",
                    "  /**",
                    "   * @param {Attribute | Element} node",
                    "   */",
                    "  const restoreName = (node) => {",
                    "    const namespace = node.name.startsWith(\":\")",
                    "      ? node.name.slice(1).split(\":\")[0]",
                    "      : null;",
                    "    const rawName = node.nameSpan.toString();",
                    "    const hasExplicitNamespace =",
                    "      namespace !== null && rawName.startsWith(`${namespace}:`);",
                    "    const name = hasExplicitNamespace",
                    "      ? rawName.slice(namespace.length + 1)",
                    "      : rawName;",
                    "",
                    "    node.name = name;",
                    "    node.namespace = namespace;",
                    "    node.hasExplicitNamespace = hasExplicitNamespace;",
                    "  };",
                    "",
                    "  /**",
                    "   * @param {AstNode} node",
                    "   */",
                    "  const restoreNameAndValue = (node) => {",
                    "    switch (node.type) {",
                    "      case \"element\":",
                    "        restoreName(node);",
                    "        for (const attr of node.attrs) {",
                    "          restoreName(attr);",
                    "          if (!attr.valueSpan) {",
                    "            attr.value = null;",
                    "          } else {",
                    "            attr.value = attr.valueSpan.toString();",
                    "            if (/[\"']/.test(attr.value[0])) {",
                    "              attr.value = attr.value.slice(1, -1);",
                    "            }",
                    "          }",
                    "        }",
                    "        break;",
                    "      case \"comment\":",
                    "        node.value = node.sourceSpan",
                    "          .toString()",
                    "          .slice(\"<!--\".length, -\"-->\".length);",
                    "        break;",
                    "      case \"text\":",
                    "        node.value = node.sourceSpan.toString();",
                    "        break;",
                    "      // No default",
                    "    }",
                    "  };",
                    "",
                    "  const lowerCaseIfFn = (text, fn) => {",
                    "    const lowerCasedText = text.toLowerCase();",
                    "    return fn(lowerCasedText) ? lowerCasedText : text;",
                    "  };",
                    "  const normalizeName = (node) => {",
                    "    if (node.type === \"element\") {",
                    "      if (",
                    "        normalizeTagName &&",
                    "        (!node.namespace ||",
                    "          node.namespace === node.tagDefinition.implicitNamespacePrefix ||",
                    "          isUnknownNamespace(node))",
                    "      ) {",
                    "        node.name = lowerCaseIfFn(node.name, (lowerCasedName) =>",
                    "          HTML_TAGS.has(lowerCasedName)",
                    "        );",
                    "      }",
                    "",
                    "      if (normalizeAttributeName) {",
                    "        for (const attr of node.attrs) {",
                    "          if (!attr.namespace) {",
                    "            attr.name = lowerCaseIfFn(",
                    "              attr.name,",
                    "              (lowerCasedAttrName) =>",
                    "                HTML_ELEMENT_ATTRIBUTES.has(node.name) &&",
                    "                (HTML_ELEMENT_ATTRIBUTES.get(\"*\").has(lowerCasedAttrName) ||",
                    "                  HTML_ELEMENT_ATTRIBUTES.get(node.name).has(",
                    "                    lowerCasedAttrName",
                    "                  ))",
                    "            );",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  const fixSourceSpan = (node) => {",
                    "    if (node.sourceSpan && node.endSourceSpan) {",
                    "      node.sourceSpan = new ParseSourceSpan(",
                    "        node.sourceSpan.start,",
                    "        node.endSourceSpan.end",
                    "      );",
                    "    }",
                    "  };",
                    "",
                    "  /**",
                    "   * @param {AstNode} node",
                    "   */",
                    "  const addTagDefinition = (node) => {",
                    "    if (node.type === \"element\") {",
                    "      const tagDefinition = getHtmlTagDefinition(",
                    "        isTagNameCaseSensitive ? node.name : node.name.toLowerCase()",
                    "      );",
                    "      if (",
                    "        !node.namespace ||",
                    "        node.namespace === tagDefinition.implicitNamespacePrefix ||",
                    "        isUnknownNamespace(node)",
                    "      ) {",
                    "        node.tagDefinition = tagDefinition;",
                    "      } else {",
                    "        node.tagDefinition = getHtmlTagDefinition(\"\"); // the default one",
                    "      }",
                    "    }",
                    "  };",
                    "",
                    "  visitAll(",
                    "    new (class extends RecursiveVisitor {",
                    "      visit(node) {",
                    "        restoreNameAndValue(node);",
                    "        addTagDefinition(node);",
                    "        normalizeName(node);",
                    "        fixSourceSpan(node);",
                    "      }",
                    "    })(),",
                    "    rootNodes",
                    "  );",
                    "",
                    "  return rootNodes;",
                    "}",
                    "",
                    "function shouldParseVueRootNodeAsHtml(node, options) {",
                    "  if (node.type !== \"element\" || node.name !== \"template\") {",
                    "    return false;",
                    "  }",
                    "  const language = node.attrs.find((attr) => attr.name === \"lang\")?.value;",
                    "  return !language || inferParser(options, { language }) === \"html\";",
                    "}",
                    "",
                    "function throwParseError(error) {",
                    "  const {",
                    "    msg,",
                    "    span: { start, end },",
                    "  } = error;",
                    "  throw createError(msg, {",
                    "    loc: {",
                    "      start: { line: start.line + 1, column: start.col + 1 },",
                    "      end: { line: end.line + 1, column: end.col + 1 },",
                    "    },",
                    "    cause: error,",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {ParseOptions} parseOptions",
                    " * @param {Options} options",
                    " * @param {boolean} shouldParseFrontMatter",
                    " */",
                    "function parse(",
                    "  text,",
                    "  parseOptions,",
                    "  options = {},",
                    "  shouldParseFrontMatter = true",
                    ") {",
                    "  const { frontMatter, content } = shouldParseFrontMatter",
                    "    ? parseFrontMatter(text)",
                    "    : { frontMatter: null, content: text };",
                    "",
                    "  const file = new ParseSourceFile(text, options.filepath);",
                    "  const start = new ParseLocation(file, 0, 0, 0);",
                    "  const end = start.moveBy(text.length);",
                    "  const rawAst = {",
                    "    type: \"root\",",
                    "    sourceSpan: new ParseSourceSpan(start, end),",
                    "    children: ngHtmlParser(content, parseOptions, options),",
                    "  };",
                    "",
                    "  if (frontMatter) {",
                    "    const start = new ParseLocation(file, 0, 0, 0);",
                    "    const end = start.moveBy(frontMatter.raw.length);",
                    "    frontMatter.sourceSpan = new ParseSourceSpan(start, end);",
                    "    rawAst.children.unshift(frontMatter);",
                    "  }",
                    "",
                    "  const ast = new Node(rawAst);",
                    "",
                    "  const parseSubHtml = (subContent, startSpan) => {",
                    "    const { offset } = startSpan;",
                    "    const fakeContent = text.slice(0, offset).replaceAll(/[^\\n\\r]/g, \" \");",
                    "    const realContent = subContent;",
                    "    const subAst = parse(",
                    "      fakeContent + realContent,",
                    "      parseOptions,",
                    "      options,",
                    "      false",
                    "    );",
                    "    // @ts-expect-error",
                    "    subAst.sourceSpan = new ParseSourceSpan(",
                    "      startSpan,",
                    "      // @ts-expect-error",
                    "      subAst.children.at(-1).sourceSpan.end",
                    "    );",
                    "    // @ts-expect-error",
                    "    const firstText = subAst.children[0];",
                    "    if (firstText.length === offset) {",
                    "      /* c8 ignore next */ // @ts-expect-error",
                    "      subAst.children.shift();",
                    "    } else {",
                    "      firstText.sourceSpan = new ParseSourceSpan(",
                    "        firstText.sourceSpan.start.moveBy(offset),",
                    "        firstText.sourceSpan.end",
                    "      );",
                    "      firstText.value = firstText.value.slice(offset);",
                    "    }",
                    "    return subAst;",
                    "  };",
                    "",
                    "  ast.walk((node) => {",
                    "    if (node.type === \"comment\") {",
                    "      const ieConditionalComment = parseIeConditionalComment(",
                    "        node,",
                    "        parseSubHtml",
                    "      );",
                    "      if (ieConditionalComment) {",
                    "        node.parent.replaceChild(node, ieConditionalComment);",
                    "      }",
                    "    }",
                    "  });",
                    "",
                    "  return ast;",
                    "}",
                    "",
                    "/**",
                    " * @param {ParseOptions} parseOptions",
                    " */",
                    "function createParser(parseOptions) {",
                    "  return {",
                    "    parse: (text, options) => parse(text, parseOptions, options),",
                    "    hasPragma,",
                    "    astFormat: \"html\",",
                    "    locStart,",
                    "    locEnd,",
                    "  };",
                    "}",
                    "",
                    "/** @type {ParseOptions} */",
                    "const HTML_PARSE_OPTIONS = {",
                    "  name: \"html\",",
                    "  normalizeTagName: true,",
                    "  normalizeAttributeName: true,",
                    "  allowHtmComponentClosingTags: true,",
                    "};",
                    "",
                    "// HTML",
                    "export const html = createParser(HTML_PARSE_OPTIONS);",
                    "// Angular",
                    "export const angular = createParser({ name: \"angular\" });",
                    "// Vue",
                    "export const vue = createParser({",
                    "  name: \"vue\",",
                    "  isTagNameCaseSensitive: true,",
                    "  shouldParseAsRawText(tagName, prefix, hasParent, attrs) {",
                    "    return (",
                    "      tagName.toLowerCase() !== \"html\" &&",
                    "      !hasParent &&",
                    "      (tagName !== \"template\" ||",
                    "        attrs.some(",
                    "          ({ name, value }) =>",
                    "            name === \"lang\" &&",
                    "            value !== \"html\" &&",
                    "            value !== \"\" &&",
                    "            value !== undefined",
                    "        ))",
                    "    );",
                    "  },",
                    "});",
                    "// Lightning Web Components",
                    "export const lwc = createParser({ name: \"lwc\", canSelfClose: false });"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function hasPragma(text) {",
                    "  return /^\\s*<!--\\s*@(?:format|prettier)\\s*-->/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return \"<!-- @format -->\\n\\n\" + text;",
                    "}",
                    "",
                    "export { hasPragma, insertPragma };"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { ParseSourceSpan } from \"angular-html-parser/lib/compiler/src/parse_util.js\";",
                    "import htmlWhitespaceUtils from \"../utils/html-whitespace-utils.js\";",
                    "import {",
                    "  getLeadingAndTrailingHtmlWhitespace,",
                    "  canHaveInterpolation,",
                    "  getNodeCssStyleDisplay,",
                    "  isDanglingSpaceSensitiveNode,",
                    "  isIndentationSensitiveNode,",
                    "  isLeadingSpaceSensitiveNode,",
                    "  isTrailingSpaceSensitiveNode,",
                    "  isWhitespaceSensitiveNode,",
                    "} from \"./utils/index.js\";",
                    "",
                    "const PREPROCESS_PIPELINE = [",
                    "  removeIgnorableFirstLf,",
                    "  mergeIfConditionalStartEndCommentIntoElementOpeningTag,",
                    "  mergeCdataIntoText,",
                    "  extractInterpolation,",
                    "  extractWhitespaces,",
                    "  addCssDisplay,",
                    "  addIsSelfClosing,",
                    "  addHasHtmComponentClosingTag,",
                    "  addIsSpaceSensitive,",
                    "  mergeSimpleElementIntoText,",
                    "];",
                    "",
                    "function preprocess(ast, options) {",
                    "  for (const fn of PREPROCESS_PIPELINE) {",
                    "    fn(ast, options);",
                    "  }",
                    "  return ast;",
                    "}",
                    "",
                    "function removeIgnorableFirstLf(ast /*, options */) {",
                    "  ast.walk((node) => {",
                    "    if (",
                    "      node.type === \"element\" &&",
                    "      node.tagDefinition.ignoreFirstLf &&",
                    "      node.children.length > 0 &&",
                    "      node.children[0].type === \"text\" &&",
                    "      node.children[0].value[0] === \"\\n\"",
                    "    ) {",
                    "      const text = node.children[0];",
                    "      if (text.value.length === 1) {",
                    "        node.removeChild(text);",
                    "      } else {",
                    "        text.value = text.value.slice(1);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeIfConditionalStartEndCommentIntoElementOpeningTag(",
                    "  ast /*, options */",
                    ") {",
                    "  /**",
                    "   *     <!--[if ...]><!--><target><!--<![endif]-->",
                    "   */",
                    "  const isTarget = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.prev?.type === \"ieConditionalStartComment\" &&",
                    "    node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset &&",
                    "    node.firstChild?.type === \"ieConditionalEndComment\" &&",
                    "    node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (!isTarget(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const ieConditionalStartComment = child.prev;",
                    "        const ieConditionalEndComment = child.firstChild;",
                    "",
                    "        // ieConditionalStartComment",
                    "        node.removeChild(ieConditionalStartComment);",
                    "        i--; // because a node was removed",
                    "",
                    "        const startSourceSpan = new ParseSourceSpan(",
                    "          ieConditionalStartComment.sourceSpan.start,",
                    "          ieConditionalEndComment.sourceSpan.end",
                    "        );",
                    "        const sourceSpan = new ParseSourceSpan(",
                    "          startSourceSpan.start,",
                    "          child.sourceSpan.end",
                    "        );",
                    "",
                    "        child.condition = ieConditionalStartComment.condition;",
                    "        child.sourceSpan = sourceSpan;",
                    "        child.startSourceSpan = startSourceSpan;",
                    "        child.removeChild(ieConditionalEndComment);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeNodeIntoText(ast, shouldMerge, getValue) {",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "",
                    "        if (child.type !== \"text\" && !shouldMerge(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        if (child.type !== \"text\") {",
                    "          child.type = \"text\";",
                    "          child.value = getValue(child);",
                    "        }",
                    "",
                    "        const prevChild = child.prev;",
                    "        if (!prevChild || prevChild.type !== \"text\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        prevChild.value += child.value;",
                    "        prevChild.sourceSpan = new ParseSourceSpan(",
                    "          prevChild.sourceSpan.start,",
                    "          child.sourceSpan.end",
                    "        );",
                    "",
                    "        node.removeChild(child);",
                    "        i--; // because a node was removed",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function mergeCdataIntoText(ast /*, options */) {",
                    "  return mergeNodeIntoText(",
                    "    ast,",
                    "    (node) => node.type === \"cdata\",",
                    "    (node) => `<![CDATA[${node.value}]]>`",
                    "  );",
                    "}",
                    "",
                    "function mergeSimpleElementIntoText(ast /*, options */) {",
                    "  const isSimpleElement = (node) =>",
                    "    node.type === \"element\" &&",
                    "    node.attrs.length === 0 &&",
                    "    node.children.length === 1 &&",
                    "    node.firstChild.type === \"text\" &&",
                    "    !htmlWhitespaceUtils.hasWhitespaceCharacter(node.children[0].value) &&",
                    "    !node.firstChild.hasLeadingSpaces &&",
                    "    !node.firstChild.hasTrailingSpaces &&",
                    "    node.isLeadingSpaceSensitive &&",
                    "    !node.hasLeadingSpaces &&",
                    "    node.isTrailingSpaceSensitive &&",
                    "    !node.hasTrailingSpaces &&",
                    "    node.prev?.type === \"text\" &&",
                    "    node.next?.type === \"text\";",
                    "  ast.walk((node) => {",
                    "    if (node.children) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (!isSimpleElement(child)) {",
                    "          continue;",
                    "        }",
                    "",
                    "        const prevChild = child.prev;",
                    "        const nextChild = child.next;",
                    "        prevChild.value +=",
                    "          `<${child.rawName}>` +",
                    "          child.firstChild.value +",
                    "          `</${child.rawName}>` +",
                    "          nextChild.value;",
                    "        prevChild.sourceSpan = new ParseSourceSpan(",
                    "          prevChild.sourceSpan.start,",
                    "          nextChild.sourceSpan.end",
                    "        );",
                    "        prevChild.isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive;",
                    "        prevChild.hasTrailingSpaces = nextChild.hasTrailingSpaces;",
                    "",
                    "        node.removeChild(child);",
                    "        i--; // because a node was removed",
                    "        node.removeChild(nextChild);",
                    "      }",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "function extractInterpolation(ast, options) {",
                    "  if (options.parser === \"html\") {",
                    "    return;",
                    "  }",
                    "",
                    "  const interpolationRegex = /{{(.+?)}}/s;",
                    "  ast.walk((node) => {",
                    "    if (!canHaveInterpolation(node)) {",
                    "      return;",
                    "    }",
                    "",
                    "    for (const child of node.children) {",
                    "      if (child.type !== \"text\") {",
                    "        continue;",
                    "      }",
                    "",
                    "      let startSourceSpan = child.sourceSpan.start;",
                    "      let endSourceSpan = null;",
                    "      const components = child.value.split(interpolationRegex);",
                    "      for (",
                    "        let i = 0;",
                    "        i < components.length;",
                    "        i++, startSourceSpan = endSourceSpan",
                    "      ) {",
                    "        const value = components[i];",
                    "",
                    "        if (i % 2 === 0) {",
                    "          endSourceSpan = startSourceSpan.moveBy(value.length);",
                    "          if (value.length > 0) {",
                    "            node.insertChildBefore(child, {",
                    "              type: \"text\",",
                    "              value,",
                    "              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "            });",
                    "          }",
                    "          continue;",
                    "        }",
                    "",
                    "        endSourceSpan = startSourceSpan.moveBy(value.length + 4); // `{{` + `}}`",
                    "        node.insertChildBefore(child, {",
                    "          type: \"interpolation\",",
                    "          sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),",
                    "          children:",
                    "            value.length === 0",
                    "              ? []",
                    "              : [",
                    "                  {",
                    "                    type: \"text\",",
                    "                    value,",
                    "                    sourceSpan: new ParseSourceSpan(",
                    "                      startSourceSpan.moveBy(2),",
                    "                      endSourceSpan.moveBy(-2)",
                    "                    ),",
                    "                  },",
                    "                ],",
                    "        });",
                    "      }",
                    "",
                    "      node.removeChild(child);",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * - add `hasLeadingSpaces` field",
                    " * - add `hasTrailingSpaces` field",
                    " * - add `hasDanglingSpaces` field for parent nodes",
                    " * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes",
                    " * - remove insensitive whitespaces",
                    " */",
                    "function extractWhitespaces(ast /*, options*/) {",
                    "  ast.walk((node) => {",
                    "    if (!node.children) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (",
                    "      node.children.length === 0 ||",
                    "      (node.children.length === 1 &&",
                    "        node.children[0].type === \"text\" &&",
                    "        htmlWhitespaceUtils.trim(node.children[0].value).length === 0)",
                    "    ) {",
                    "      node.hasDanglingSpaces = node.children.length > 0;",
                    "      node.children = [];",
                    "      return;",
                    "    }",
                    "",
                    "    const isWhitespaceSensitive = isWhitespaceSensitiveNode(node);",
                    "    const isIndentationSensitive = isIndentationSensitiveNode(node);",
                    "",
                    "    if (!isWhitespaceSensitive) {",
                    "      for (let i = 0; i < node.children.length; i++) {",
                    "        const child = node.children[i];",
                    "        if (child.type !== \"text\") {",
                    "          continue;",
                    "        }",
                    "",
                    "        const { leadingWhitespace, text, trailingWhitespace } =",
                    "          getLeadingAndTrailingHtmlWhitespace(child.value);",
                    "",
                    "        const prevChild = child.prev;",
                    "        const nextChild = child.next;",
                    "",
                    "        if (!text) {",
                    "          node.removeChild(child);",
                    "          i--; // because a node was removed",
                    "",
                    "          if (leadingWhitespace || trailingWhitespace) {",
                    "            if (prevChild) {",
                    "              prevChild.hasTrailingSpaces = true;",
                    "            }",
                    "            if (nextChild) {",
                    "              nextChild.hasLeadingSpaces = true;",
                    "            }",
                    "          }",
                    "        } else {",
                    "          child.value = text;",
                    "          child.sourceSpan = new ParseSourceSpan(",
                    "            child.sourceSpan.start.moveBy(leadingWhitespace.length),",
                    "            child.sourceSpan.end.moveBy(-trailingWhitespace.length)",
                    "          );",
                    "",
                    "          if (leadingWhitespace) {",
                    "            if (prevChild) {",
                    "              prevChild.hasTrailingSpaces = true;",
                    "            }",
                    "            child.hasLeadingSpaces = true;",
                    "          }",
                    "          if (trailingWhitespace) {",
                    "            child.hasTrailingSpaces = true;",
                    "            if (nextChild) {",
                    "              nextChild.hasLeadingSpaces = true;",
                    "            }",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    node.isWhitespaceSensitive = isWhitespaceSensitive;",
                    "    node.isIndentationSensitive = isIndentationSensitive;",
                    "  });",
                    "}",
                    "",
                    "function addIsSelfClosing(ast /*, options */) {",
                    "  ast.walk((node) => {",
                    "    node.isSelfClosing =",
                    "      !node.children ||",
                    "      (node.type === \"element\" &&",
                    "        (node.tagDefinition.isVoid ||",
                    "          // self-closing",
                    "          (node.endSourceSpan &&",
                    "            node.startSourceSpan.start === node.endSourceSpan.start &&",
                    "            node.startSourceSpan.end === node.endSourceSpan.end)));",
                    "  });",
                    "}",
                    "",
                    "function addHasHtmComponentClosingTag(ast, options) {",
                    "  ast.walk((node) => {",
                    "    if (node.type !== \"element\") {",
                    "      return;",
                    "    }",
                    "",
                    "    node.hasHtmComponentClosingTag =",
                    "      node.endSourceSpan &&",
                    "      /^<\\s*\\/\\s*\\/\\s*>$/.test(",
                    "        options.originalText.slice(",
                    "          node.endSourceSpan.start.offset,",
                    "          node.endSourceSpan.end.offset",
                    "        )",
                    "      );",
                    "  });",
                    "}",
                    "",
                    "function addCssDisplay(ast, options) {",
                    "  ast.walk((node) => {",
                    "    node.cssDisplay = getNodeCssStyleDisplay(node, options);",
                    "  });",
                    "}",
                    "",
                    "/**",
                    " * - add `isLeadingSpaceSensitive` field",
                    " * - add `isTrailingSpaceSensitive` field",
                    " * - add `isDanglingSpaceSensitive` field for parent nodes",
                    " */",
                    "function addIsSpaceSensitive(ast, options) {",
                    "  ast.walk((node) => {",
                    "    const { children } = node;",
                    "    if (!children) {",
                    "      return;",
                    "    }",
                    "    if (children.length === 0) {",
                    "      node.isDanglingSpaceSensitive = isDanglingSpaceSensitiveNode(node);",
                    "      return;",
                    "    }",
                    "    for (const child of children) {",
                    "      child.isLeadingSpaceSensitive = isLeadingSpaceSensitiveNode(",
                    "        child,",
                    "        options",
                    "      );",
                    "      child.isTrailingSpaceSensitive = isTrailingSpaceSensitiveNode(",
                    "        child,",
                    "        options",
                    "      );",
                    "    }",
                    "    for (let index = 0; index < children.length; index++) {",
                    "      const child = children[index];",
                    "      child.isLeadingSpaceSensitive =",
                    "        index === 0",
                    "          ? child.isLeadingSpaceSensitive",
                    "          : child.prev.isTrailingSpaceSensitive &&",
                    "            child.isLeadingSpaceSensitive;",
                    "      child.isTrailingSpaceSensitive =",
                    "        index === children.length - 1",
                    "          ? child.isTrailingSpaceSensitive",
                    "          : child.next.isLeadingSpaceSensitive &&",
                    "            child.isTrailingSpaceSensitive;",
                    "    }",
                    "  });",
                    "}",
                    "",
                    "export default preprocess;"
                ]
            },
            "printer-html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                    " */",
                    "",
                    "import { fill, group, hardline } from \"../document/builders.js\";",
                    "import { cleanDoc, replaceEndOfLine } from \"../document/utils.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import getPreferredQuote from \"../utils/get-preferred-quote.js\";",
                    "import clean from \"./clean.js\";",
                    "import { unescapeQuoteEntities, getTextValueParts } from \"./utils/index.js\";",
                    "import preprocess from \"./print-preprocess.js\";",
                    "import { insertPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import embed from \"./embed.js\";",
                    "import {",
                    "  printClosingTagSuffix,",
                    "  printClosingTagEnd,",
                    "  printOpeningTagPrefix,",
                    "  printOpeningTagStart,",
                    "} from \"./print/tag.js\";",
                    "import { printElement } from \"./print/element.js\";",
                    "import { printChildren } from \"./print/children.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return replaceEndOfLine(node.raw);",
                    "    case \"root\":",
                    "      if (options.__onHtmlRoot) {",
                    "        options.__onHtmlRoot(node);",
                    "      }",
                    "      return [group(printChildren(path, options, print)), hardline];",
                    "    case \"element\":",
                    "    case \"ieConditionalComment\":",
                    "      return printElement(path, options, print);",
                    "",
                    "    case \"ieConditionalStartComment\":",
                    "    case \"ieConditionalEndComment\":",
                    "      return [printOpeningTagStart(node), printClosingTagEnd(node)];",
                    "    case \"interpolation\":",
                    "      return [",
                    "        printOpeningTagStart(node, options),",
                    "        ...path.map(print, \"children\"),",
                    "        printClosingTagEnd(node, options),",
                    "      ];",
                    "    case \"text\": {",
                    "      if (node.parent.type === \"interpolation\") {",
                    "        // replace the trailing literalline with hardline for better readability",
                    "        const trailingNewlineRegex = /\\n[^\\S\\n]*$/;",
                    "        const hasTrailingNewline = trailingNewlineRegex.test(node.value);",
                    "        const value = hasTrailingNewline",
                    "          ? node.value.replace(trailingNewlineRegex, \"\")",
                    "          : node.value;",
                    "        return [replaceEndOfLine(value), hasTrailingNewline ? hardline : \"\"];",
                    "      }",
                    "",
                    "      const printed = cleanDoc([",
                    "        printOpeningTagPrefix(node, options),",
                    "        ...getTextValueParts(node),",
                    "        printClosingTagSuffix(node, options),",
                    "      ]);",
                    "",
                    "      if (Array.isArray(printed)) {",
                    "        return fill(printed);",
                    "      }",
                    "",
                    "      return printed;",
                    "    }",
                    "    case \"docType\":",
                    "      return [",
                    "        group([",
                    "          printOpeningTagStart(node, options),",
                    "          \" \",",
                    "          node.value.replace(/^html\\b/i, \"html\").replaceAll(/\\s+/g, \" \"),",
                    "        ]),",
                    "        printClosingTagEnd(node, options),",
                    "      ];",
                    "    case \"comment\":",
                    "      return [",
                    "        printOpeningTagPrefix(node, options),",
                    "        replaceEndOfLine(",
                    "          options.originalText.slice(locStart(node), locEnd(node))",
                    "        ),",
                    "        printClosingTagSuffix(node, options),",
                    "      ];",
                    "",
                    "    case \"attribute\": {",
                    "      if (node.value === null) {",
                    "        return node.rawName;",
                    "      }",
                    "      const value = unescapeQuoteEntities(node.value);",
                    "      const quote = getPreferredQuote(value, '\"');",
                    "      return [",
                    "        node.rawName,",
                    "        \"=\",",
                    "        quote,",
                    "        replaceEndOfLine(",
                    "          quote === '\"'",
                    "            ? value.replaceAll('\"', \"&quot;\")",
                    "            : value.replaceAll(\"'\", \"&apos;\")",
                    "        ),",
                    "        quote,",
                    "      ];",
                    "    }",
                    "    case \"cdata\": // Transformed into `text`",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"HTML\");",
                    "  }",
                    "}",
                    "",
                    "const printer = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  insertPragma,",
                    "  massageAstNode: clean,",
                    "  embed,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = {",
                    "  \"front-matter\": [],",
                    "  root: [\"children\"],",
                    "  element: [\"attrs\", \"children\"],",
                    "  ieConditionalComment: [\"children\"],",
                    "  ieConditionalStartComment: [],",
                    "  ieConditionalEndComment: [],",
                    "  interpolation: [\"children\"],",
                    "  text: [\"children\"],",
                    "  docType: [],",
                    "  comment: [],",
                    "  attribute: [],",
                    "  cdata: [],",
                    "};",
                    "",
                    "export default visitorKeys;"
                ]
            },
            "embed": {
                "angular-attributes.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  getUnescapedAttributeValue,",
                        "  getTextValueParts,",
                        "} from \"../utils/index.js\";",
                        "import { fill } from \"../../document/builders.js\";",
                        "import {",
                        "  formatAttributeValue,",
                        "  printExpand,",
                        "  shouldHugJsExpression,",
                        "} from \"./utils.js\";",
                        "import {",
                        "  interpolationRegex as angularInterpolationRegex,",
                        "  printAngularInterpolation,",
                        "} from \"./angular-interpolation.js\";",
                        "",
                        "function createAngularPrinter({ parser }) {",
                        "  return (textToDoc, print, path /*, options*/) =>",
                        "    formatAttributeValue(",
                        "      getUnescapedAttributeValue(path.node),",
                        "      textToDoc,",
                        "      {",
                        "        parser,",
                        "        // angular does not allow trailing comma",
                        "        trailingComma: \"none\",",
                        "      },",
                        "      shouldHugJsExpression",
                        "    );",
                        "}",
                        "",
                        "const printNgAction = createAngularPrinter({ parser: \"__ng_action\" });",
                        "const printNgBinding = createAngularPrinter({ parser: \"__ng_binding\" });",
                        "const printNgDirective = createAngularPrinter({ parser: \"__ng_directive\" });",
                        "",
                        "function printAngularAttribute(path, options) {",
                        "  if (options.parser !== \"angular\") {",
                        "    return;",
                        "  }",
                        "",
                        "  const { node } = path;",
                        "  const attributeName = node.fullName;",
                        "",
                        "  /**",
                        "   *     (click)=\"angularStatement\"",
                        "   *     on-click=\"angularStatement\"",
                        "   */",
                        "  if (",
                        "    (attributeName.startsWith(\"(\") && attributeName.endsWith(\")\")) ||",
                        "    attributeName.startsWith(\"on-\")",
                        "  ) {",
                        "    return printNgAction;",
                        "  }",
                        "",
                        "  /**",
                        "   *     [target]=\"angularExpression\"",
                        "   *     bind-target=\"angularExpression\"",
                        "   *     [(target)]=\"angularExpression\"",
                        "   *     bindon-target=\"angularExpression\"",
                        "   */",
                        "  if (",
                        "    (attributeName.startsWith(\"[\") && attributeName.endsWith(\"]\")) ||",
                        "    /^bind(?:on)?-/.test(attributeName) ||",
                        "    // Unofficial rudimentary support for some of the most used directives of AngularJS 1.x",
                        "    /^ng-(?:if|show|hide|class|style)$/.test(attributeName)",
                        "  ) {",
                        "    return printNgBinding;",
                        "  }",
                        "",
                        "  /**",
                        "   *     *directive=\"angularDirective\"",
                        "   */",
                        "  if (attributeName.startsWith(\"*\")) {",
                        "    return printNgDirective;",
                        "  }",
                        "",
                        "  const value = getUnescapedAttributeValue(node);",
                        "",
                        "  /**",
                        "   *     i18n=\"longDescription\"",
                        "   *     i18n-attr=\"longDescription\"",
                        "   */",
                        "  if (/^i18n(?:-.+)?$/.test(attributeName)) {",
                        "    return () =>",
                        "      printExpand(",
                        "        fill(getTextValueParts(node, value.trim())),",
                        "        !value.includes(\"@@\")",
                        "      );",
                        "  }",
                        "",
                        "  if (angularInterpolationRegex.test(value)) {",
                        "    return (textToDoc) => printAngularInterpolation(value, textToDoc);",
                        "  }",
                        "}",
                        "",
                        "export default printAngularAttribute;"
                    ]
                },
                "angular-interpolation.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { group, indent, line } from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import { formatAttributeValue } from \"./utils.js\";",
                        "",
                        "const interpolationRegex = /{{(.+?)}}/s;",
                        "",
                        "async function printAngularInterpolation(text, textToDoc) {",
                        "  const parts = [];",
                        "  for (const [index, part] of text.split(interpolationRegex).entries()) {",
                        "    if (index % 2 === 0) {",
                        "      parts.push(replaceEndOfLine(part));",
                        "    } else {",
                        "      try {",
                        "        parts.push(",
                        "          group([",
                        "            \"{{\",",
                        "            indent([",
                        "              line,",
                        "              await formatAttributeValue(part, textToDoc, {",
                        "                parser: \"__ng_interpolation\",",
                        "                __isInHtmlInterpolation: true, // to avoid unexpected `}}`",
                        "                trailingComma: \"none\",",
                        "              }),",
                        "            ]),",
                        "            line,",
                        "            \"}}\",",
                        "          ])",
                        "        );",
                        "      } catch {",
                        "        parts.push(\"{{\", replaceEndOfLine(part), \"}}\");",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export { interpolationRegex, printAngularInterpolation };"
                    ]
                },
                "attribute.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { group } from \"../../document/builders.js\";",
                        "import { mapDoc } from \"../../document/utils.js\";",
                        "import printSrcset from \"./srcset.js\";",
                        "import printClassNames from \"./class-names.js\";",
                        "import { printStyleAttribute } from \"./style.js\";",
                        "import printVueAttribute from \"./vue-attributes.js\";",
                        "import printAngularAttribute from \"./angular-attributes.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path.js\")} AstPath",
                        " */",
                        "",
                        "function printAttribute(path, options) {",
                        "  const { node } = path;",
                        "",
                        "  if (!node.value) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (",
                        "    // lit-html: html`<my-element obj=${obj}></my-element>`",
                        "    /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(",
                        "      options.originalText.slice(",
                        "        node.valueSpan.start.offset,",
                        "        node.valueSpan.end.offset",
                        "      )",
                        "    ) || // lwc: html`<my-element data-for={value}></my-element>`",
                        "    (options.parser === \"lwc\" &&",
                        "      node.value.startsWith(\"{\") &&",
                        "      node.value.endsWith(\"}\"))",
                        "  ) {",
                        "    return [node.rawName, \"=\", node.value];",
                        "  }",
                        "",
                        "  for (const getValuePrinter of [",
                        "    printSrcset,",
                        "    printStyleAttribute,",
                        "    printClassNames,",
                        "    printVueAttribute,",
                        "    printAngularAttribute,",
                        "  ]) {",
                        "    const printValue = getValuePrinter(path, options);",
                        "    if (printValue) {",
                        "      return printAttributeWithValuePrinter(printValue);",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {(textToDoc, print, path, options) => Promise<Doc>} printValue",
                        " * @returns {(textToDoc, print, path, options) => Promise<Doc>}",
                        " */",
                        "function printAttributeWithValuePrinter(printValue) {",
                        "  return async (textToDoc, print, path, options) => {",
                        "    let valueDoc = await printValue(textToDoc, print, path, options);",
                        "",
                        "    if (!valueDoc) {",
                        "      return;",
                        "    }",
                        "",
                        "    valueDoc = mapDoc(valueDoc, (doc) =>",
                        "      typeof doc === \"string\" ? doc.replaceAll('\"', \"&quot;\") : doc",
                        "    );",
                        "",
                        "    return [path.node.rawName, '=\"', group(valueDoc), '\"'];",
                        "  };",
                        "}",
                        "",
                        "export default printAttribute;"
                    ]
                },
                "class-names.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { getUnescapedAttributeValue } from \"../utils/index.js\";",
                        "",
                        "function printClassNames(path, options) {",
                        "  const { node } = path;",
                        "  const value = getUnescapedAttributeValue(node);",
                        "  if (",
                        "    node.fullName === \"class\" &&",
                        "    !options.parentParser &&",
                        "    !value.includes(\"{{\")",
                        "  ) {",
                        "    return () => value.trim().split(/\\s+/).join(\" \");",
                        "  }",
                        "}",
                        "",
                        "export default printClassNames;"
                    ]
                },
                "srcset.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import parseSrcset from \"@prettier/parse-srcset\";",
                        "import { ifBreak, join, line } from \"../../document/builders.js\";",
                        "import { getUnescapedAttributeValue } from \"../utils/index.js\";",
                        "import { printExpand } from \"./utils.js\";",
                        "",
                        "function printSrcset(path /*, options*/) {",
                        "  if (",
                        "    path.node.fullName === \"srcset\" &&",
                        "    (path.parent.fullName === \"img\" || path.parent.fullName === \"source\")",
                        "  ) {",
                        "    return () => printSrcsetValue(getUnescapedAttributeValue(path.node));",
                        "  }",
                        "}",
                        "",
                        "function printSrcsetValue(value) {",
                        "  const srcset = parseSrcset(value);",
                        "",
                        "  const hasW = srcset.some(({ width }) => width);",
                        "  const hasH = srcset.some(({ height }) => height);",
                        "  const hasX = srcset.some(({ density }) => density);",
                        "",
                        "  if (hasW + hasH + hasX > 1) {",
                        "    throw new Error(\"Mixed descriptor in srcset is not supported\");",
                        "  }",
                        "",
                        "  const key = hasW ? \"width\" : hasH ? \"height\" : \"density\";",
                        "  const unit = hasW ? \"w\" : hasH ? \"h\" : \"x\";",
                        "",
                        "  const urls = srcset.map((src) => src.source.value);",
                        "  const maxUrlLength = Math.max(...urls.map((url) => url.length));",
                        "",
                        "  const descriptors = srcset.map((src) =>",
                        "    src[key] ? String(src[key].value) : \"\"",
                        "  );",
                        "  const descriptorLeftLengths = descriptors.map((descriptor) => {",
                        "    const index = descriptor.indexOf(\".\");",
                        "    return index === -1 ? descriptor.length : index;",
                        "  });",
                        "  const maxDescriptorLeftLength = Math.max(...descriptorLeftLengths);",
                        "",
                        "  return printExpand(",
                        "    join(",
                        "      [\",\", line],",
                        "      urls.map((url, index) => {",
                        "        const parts = [url];",
                        "",
                        "        const descriptor = descriptors[index];",
                        "        if (descriptor) {",
                        "          const urlPadding = maxUrlLength - url.length + 1;",
                        "          const descriptorPadding =",
                        "            maxDescriptorLeftLength - descriptorLeftLengths[index];",
                        "",
                        "          const alignment = \" \".repeat(urlPadding + descriptorPadding);",
                        "          parts.push(ifBreak(alignment, \" \"), descriptor + unit);",
                        "        }",
                        "",
                        "        return parts;",
                        "      })",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "export default printSrcset;"
                    ]
                },
                "style.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { getUnescapedAttributeValue } from \"../utils/index.js\";",
                        "import { printExpand } from \"./utils.js\";",
                        "",
                        "function printStyleAttribute(path, options) {",
                        "  const { node } = path;",
                        "  const text = getUnescapedAttributeValue(path.node).trim();",
                        "  if (",
                        "    node.fullName === \"style\" &&",
                        "    !options.parentParser &&",
                        "    !text.includes(\"{{\")",
                        "  ) {",
                        "    return async (textToDoc) =>",
                        "      printExpand(",
                        "        await textToDoc(text, { parser: \"css\", __isHTMLStyleAttribute: true })",
                        "      );",
                        "  }",
                        "}",
                        "",
                        "export { printStyleAttribute };"
                    ]
                },
                "utils.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { group, indent, softline } from \"../../document/builders.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "function printExpand(doc, canHaveTrailingWhitespace = true) {",
                        "  return [indent([softline, doc]), canHaveTrailingWhitespace ? softline : \"\"];",
                        "}",
                        "",
                        "function shouldHugJsExpression(ast, options) {",
                        "  const rootNode =",
                        "    ast.type === \"NGRoot\"",
                        "      ? ast.node.type === \"NGMicrosyntax\" &&",
                        "        ast.node.body.length === 1 &&",
                        "        ast.node.body[0].type === \"NGMicrosyntaxExpression\"",
                        "        ? ast.node.body[0].expression",
                        "        : ast.node",
                        "      : ast.type === \"JsExpressionRoot\"",
                        "      ? ast.node",
                        "      : ast;",
                        "  return (",
                        "    rootNode &&",
                        "    (rootNode.type === \"ObjectExpression\" ||",
                        "      rootNode.type === \"ArrayExpression\" ||",
                        "      ((options.parser === \"__vue_expression\" ||",
                        "        options.parser === \"__vue_ts_expression\") &&",
                        "        (rootNode.type === \"TemplateLiteral\" ||",
                        "          rootNode.type === \"StringLiteral\")))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {string} code",
                        " * @param {Function} textToDoc",
                        " * @param {*} options",
                        " * @param {(ast: any, options: any) => boolean} [shouldHugJsExpression]",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "async function formatAttributeValue(",
                        "  code,",
                        "  textToDoc,",
                        "  options,",
                        "  shouldHugJsExpression",
                        ") {",
                        "  options = {",
                        "    // strictly prefer single quote to avoid unnecessary html entity escape",
                        "    __isInHtmlAttribute: true,",
                        "    __embeddedInHtml: true,",
                        "    ...options,",
                        "  };",
                        "",
                        "  let shouldHug = true;",
                        "  if (shouldHugJsExpression) {",
                        "    options.__onHtmlBindingRoot = (ast, options) => {",
                        "      shouldHug = shouldHugJsExpression(ast, options);",
                        "    };",
                        "  }",
                        "",
                        "  const doc = await textToDoc(code, options, textToDoc);",
                        "",
                        "  return shouldHug ? group(doc) : printExpand(doc);",
                        "}",
                        "",
                        "export { printExpand, formatAttributeValue, shouldHugJsExpression };"
                    ]
                },
                "vue-attributes.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  isVueSlotAttribute,",
                        "  isVueSfcBindingsAttribute,",
                        "  getUnescapedAttributeValue,",
                        "} from \"../utils/index.js\";",
                        "import isVueSfcWithTypescriptScript from \"../utils/is-vue-sfc-with-typescript-script.js\";",
                        "import { printVueVForDirective } from \"./vue-v-for-directive.js\";",
                        "import { formatAttributeValue, shouldHugJsExpression } from \"./utils.js\";",
                        "import {",
                        "  printVueBindings,",
                        "  isVueEventBindingExpression,",
                        "} from \"./vue-bindings.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path.js\")} AstPath",
                        " */",
                        "",
                        "function printVueAttribute(path, options) {",
                        "  if (options.parser !== \"vue\") {",
                        "    return;",
                        "  }",
                        "  const { node } = path;",
                        "  const attributeName = node.fullName;",
                        "",
                        "  if (attributeName === \"v-for\") {",
                        "    return printVueVForDirective;",
                        "  }",
                        "",
                        "  const value = getUnescapedAttributeValue(node);",
                        "  const parseWithTs = isVueSfcWithTypescriptScript(path, options);",
                        "",
                        "  if (isVueSlotAttribute(node) || isVueSfcBindingsAttribute(node, options)) {",
                        "    return (textToDoc) => printVueBindings(value, textToDoc, { parseWithTs });",
                        "  }",
                        "",
                        "  /**",
                        "   *     @click=\"jsStatement\"",
                        "   *     @click=\"jsExpression\"",
                        "   *     v-on:click=\"jsStatement\"",
                        "   *     v-on:click=\"jsExpression\"",
                        "   */",
                        "  if (attributeName.startsWith(\"@\") || attributeName.startsWith(\"v-on:\")) {",
                        "    return (textToDoc) =>",
                        "      printVueVOnDirective(value, textToDoc, { parseWithTs });",
                        "  }",
                        "",
                        "  /**",
                        "   *     :class=\"vueExpression\"",
                        "   *     v-bind:id=\"vueExpression\"",
                        "   */",
                        "  if (attributeName.startsWith(\":\") || attributeName.startsWith(\"v-bind:\")) {",
                        "    return (textToDoc) =>",
                        "      printVueVBindDirective(value, textToDoc, { parseWithTs });",
                        "  }",
                        "",
                        "  /**",
                        "   *     v-if=\"jsExpression\"",
                        "   */",
                        "  if (attributeName.startsWith(\"v-\")) {",
                        "    return (textToDoc) => printExpression(value, textToDoc, { parseWithTs });",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "function printVueVOnDirective(text, textToDoc, { parseWithTs }) {",
                        "  if (isVueEventBindingExpression(text)) {",
                        "    return printExpression(text, textToDoc, { parseWithTs });",
                        "  }",
                        "",
                        "  return formatAttributeValue(",
                        "    text,",
                        "    textToDoc,",
                        "    { parser: parseWithTs ? \"__vue_ts_event_binding\" : \"__vue_event_binding\" },",
                        "    shouldHugJsExpression",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "function printVueVBindDirective(text, textToDoc, { parseWithTs }) {",
                        "  return formatAttributeValue(",
                        "    text,",
                        "    textToDoc,",
                        "    { parser: parseWithTs ? \"__vue_ts_expression\" : \"__vue_expression\" },",
                        "    shouldHugJsExpression",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "function printExpression(text, textToDoc, { parseWithTs }) {",
                        "  return formatAttributeValue(",
                        "    text,",
                        "    textToDoc,",
                        "    { parser: parseWithTs ? \"__ts_expression\" : \"__js_expression\" },",
                        "    shouldHugJsExpression",
                        "  );",
                        "}",
                        "",
                        "export default printVueAttribute;"
                    ]
                },
                "vue-bindings.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { formatAttributeValue } from \"./utils.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "/**",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "function printVueBindings(text, textToDoc, { parseWithTs }) {",
                        "  return formatAttributeValue(`function _(${text}) {}`, textToDoc, {",
                        "    parser: parseWithTs ? \"babel-ts\" : \"babel\",",
                        "    __isVueBindings: true,",
                        "  });",
                        "}",
                        "",
                        "function isVueEventBindingExpression(eventBindingValue) {",
                        "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/codegen/events.js#L3-L4",
                        "  // arrow function or anonymous function",
                        "  const fnExpRE = /^(?:[\\w$]+|\\([^)]*\\))\\s*=>|^function\\s*\\(/;",
                        "  // simple member expression chain (a, a.b, a['b'], a[\"b\"], a[0], a[b])",
                        "  const simplePathRE =",
                        "    /^[$A-Z_a-z][\\w$]*(?:\\.[$A-Z_a-z][\\w$]*|\\['[^']*']|\\[\"[^\"]*\"]|\\[\\d+]|\\[[$A-Z_a-z][\\w$]*])*$/;",
                        "",
                        "  // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/helpers.js#L104",
                        "  const value = eventBindingValue.trim();",
                        "",
                        "  return fnExpRE.test(value) || simplePathRE.test(value);",
                        "}",
                        "",
                        "export { isVueEventBindingExpression, printVueBindings };"
                    ]
                },
                "vue-v-for-directive.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { group } from \"../../document/builders.js\";",
                        "import { getUnescapedAttributeValue } from \"../utils/index.js\";",
                        "import isVueSfcWithTypescriptScript from \"../utils/is-vue-sfc-with-typescript-script.js\";",
                        "import { formatAttributeValue } from \"./utils.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "/**",
                        " *     v-for=\"... in ...\"",
                        " *     v-for=\"... of ...\"",
                        " *     v-for=\"(..., ...) in ...\"",
                        " *     v-for=\"(..., ...) of ...\"",
                        " *",
                        " * @param {*} options",
                        " * @returns {Promise<Doc>}",
                        " */",
                        "async function printVueVForDirective(textToDoc, print, path, options) {",
                        "  const value = getUnescapedAttributeValue(path.node);",
                        "  const { left, operator, right } = parseVueVForDirective(value);",
                        "  const parseWithTs = isVueSfcWithTypescriptScript(path, options);",
                        "  return [",
                        "    group(",
                        "      await formatAttributeValue(`function _(${left}) {}`, textToDoc, {",
                        "        parser: parseWithTs ? \"babel-ts\" : \"babel\",",
                        "        __isVueForBindingLeft: true,",
                        "      })",
                        "    ),",
                        "    \" \",",
                        "    operator,",
                        "    \" \",",
                        "    await formatAttributeValue(right, textToDoc, {",
                        "      parser: parseWithTs ? \"__ts_expression\" : \"__js_expression\",",
                        "    }),",
                        "  ];",
                        "}",
                        "",
                        "// modified from https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/parser/index.js#L370-L387",
                        "function parseVueVForDirective(value) {",
                        "  const forAliasRE = /(.*?)\\s+(in|of)\\s+(.*)/s;",
                        "  const forIteratorRE = /,([^,\\]}]*)(?:,([^,\\]}]*))?$/;",
                        "  const stripParensRE = /^\\(|\\)$/g;",
                        "",
                        "  const inMatch = value.match(forAliasRE);",
                        "  if (!inMatch) {",
                        "    return;",
                        "  }",
                        "",
                        "  const res = {};",
                        "  res.for = inMatch[3].trim();",
                        "  if (!res.for) {",
                        "    return;",
                        "  }",
                        "",
                        "  const alias = inMatch[1].trim().replaceAll(stripParensRE, \"\");",
                        "  const iteratorMatch = alias.match(forIteratorRE);",
                        "  if (iteratorMatch) {",
                        "    res.alias = alias.replace(forIteratorRE, \"\");",
                        "    res.iterator1 = iteratorMatch[1].trim();",
                        "    if (iteratorMatch[2]) {",
                        "      res.iterator2 = iteratorMatch[2].trim();",
                        "    }",
                        "  } else {",
                        "    res.alias = alias;",
                        "  }",
                        "",
                        "  const left = [res.alias, res.iterator1, res.iterator2];",
                        "  if (",
                        "    left.some(",
                        "      (part, index) =>",
                        "        !part && (index === 0 || left.slice(index + 1).some(Boolean))",
                        "    )",
                        "  ) {",
                        "    return;",
                        "  }",
                        "",
                        "  return {",
                        "    left: left.filter(Boolean).join(\",\"),",
                        "    operator: inMatch[2],",
                        "    right: res.for,",
                        "  };",
                        "}",
                        "",
                        "export { printVueVForDirective };"
                    ]
                }
            },
            "print": {
                "children.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  breakParent,",
                        "  group,",
                        "  ifBreak,",
                        "  line,",
                        "  softline,",
                        "  hardline,",
                        "} from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import {",
                        "  forceBreakChildren,",
                        "  forceNextEmptyLine,",
                        "  isTextLikeNode,",
                        "  hasPrettierIgnore,",
                        "  preferHardlineAsLeadingSpaces,",
                        "} from \"../utils/index.js\";",
                        "import {",
                        "  printOpeningTagPrefix,",
                        "  needsToBorrowNextOpeningTagStartMarker,",
                        "  printOpeningTagStartMarker,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  printClosingTagEndMarker,",
                        "  printClosingTagSuffix,",
                        "  needsToBorrowParentClosingTagStartMarker,",
                        "} from \"./tag.js\";",
                        "",
                        "function printChild(childPath, options, print) {",
                        "  const child = childPath.node;",
                        "",
                        "  if (hasPrettierIgnore(child)) {",
                        "    return [",
                        "      printOpeningTagPrefix(child, options),",
                        "      replaceEndOfLine(",
                        "        options.originalText.slice(",
                        "          locStart(child) +",
                        "            (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev)",
                        "              ? printOpeningTagStartMarker(child).length",
                        "              : 0),",
                        "          locEnd(child) -",
                        "            (child.next && needsToBorrowPrevClosingTagEndMarker(child.next)",
                        "              ? printClosingTagEndMarker(child, options).length",
                        "              : 0)",
                        "        )",
                        "      ),",
                        "      printClosingTagSuffix(child, options),",
                        "    ];",
                        "  }",
                        "",
                        "  return print();",
                        "}",
                        "",
                        "function printBetweenLine(prevNode, nextNode) {",
                        "  return isTextLikeNode(prevNode) && isTextLikeNode(nextNode)",
                        "    ? prevNode.isTrailingSpaceSensitive",
                        "      ? prevNode.hasTrailingSpaces",
                        "        ? preferHardlineAsLeadingSpaces(nextNode)",
                        "          ? hardline",
                        "          : line",
                        "        : \"\"",
                        "      : preferHardlineAsLeadingSpaces(nextNode)",
                        "      ? hardline",
                        "      : softline",
                        "    : (needsToBorrowNextOpeningTagStartMarker(prevNode) &&",
                        "        (hasPrettierIgnore(nextNode) ||",
                        "          /**",
                        "           *     123<a",
                        "           *          ~",
                        "           *       ><b>",
                        "           */",
                        "          nextNode.firstChild ||",
                        "          /**",
                        "           *     123<!--",
                        "           *            ~",
                        "           *     -->",
                        "           */",
                        "          nextNode.isSelfClosing ||",
                        "          /**",
                        "           *     123<span",
                        "           *             ~",
                        "           *       attr",
                        "           */",
                        "          (nextNode.type === \"element\" && nextNode.attrs.length > 0))) ||",
                        "      /**",
                        "       *     <img",
                        "       *       src=\"long\"",
                        "       *                 ~",
                        "       *     />123",
                        "       */",
                        "      (prevNode.type === \"element\" &&",
                        "        prevNode.isSelfClosing &&",
                        "        needsToBorrowPrevClosingTagEndMarker(nextNode))",
                        "    ? \"\"",
                        "    : !nextNode.isLeadingSpaceSensitive ||",
                        "      preferHardlineAsLeadingSpaces(nextNode) ||",
                        "      /**",
                        "       *       Want to write us a letter? Use our<a",
                        "       *         ><b><a>mailing address</a></b></a",
                        "       *                                          ~",
                        "       *       >.",
                        "       */",
                        "      (needsToBorrowPrevClosingTagEndMarker(nextNode) &&",
                        "        prevNode.lastChild &&",
                        "        needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) &&",
                        "        prevNode.lastChild.lastChild &&",
                        "        needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild))",
                        "    ? hardline",
                        "    : nextNode.hasLeadingSpaces",
                        "    ? line",
                        "    : softline;",
                        "}",
                        "",
                        "function printChildren(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (forceBreakChildren(node)) {",
                        "    return [",
                        "      breakParent,",
                        "",
                        "      ...path.map((childPath) => {",
                        "        const childNode = childPath.node;",
                        "        const prevBetweenLine = !childNode.prev",
                        "          ? \"\"",
                        "          : printBetweenLine(childNode.prev, childNode);",
                        "        return [",
                        "          !prevBetweenLine",
                        "            ? \"\"",
                        "            : [",
                        "                prevBetweenLine,",
                        "                forceNextEmptyLine(childNode.prev) ? hardline : \"\",",
                        "              ],",
                        "          printChild(childPath, options, print),",
                        "        ];",
                        "      }, \"children\"),",
                        "    ];",
                        "  }",
                        "",
                        "  const groupIds = node.children.map(() => Symbol(\"\"));",
                        "  return path.map((childPath, childIndex) => {",
                        "    const childNode = childPath.node;",
                        "",
                        "    if (isTextLikeNode(childNode)) {",
                        "      if (childNode.prev && isTextLikeNode(childNode.prev)) {",
                        "        const prevBetweenLine = printBetweenLine(childNode.prev, childNode);",
                        "        if (prevBetweenLine) {",
                        "          if (forceNextEmptyLine(childNode.prev)) {",
                        "            return [hardline, hardline, printChild(childPath, options, print)];",
                        "          }",
                        "          return [prevBetweenLine, printChild(childPath, options, print)];",
                        "        }",
                        "      }",
                        "      return printChild(childPath, options, print);",
                        "    }",
                        "",
                        "    const prevParts = [];",
                        "    const leadingParts = [];",
                        "    const trailingParts = [];",
                        "    const nextParts = [];",
                        "",
                        "    const prevBetweenLine = childNode.prev",
                        "      ? printBetweenLine(childNode.prev, childNode)",
                        "      : \"\";",
                        "",
                        "    const nextBetweenLine = childNode.next",
                        "      ? printBetweenLine(childNode, childNode.next)",
                        "      : \"\";",
                        "",
                        "    if (prevBetweenLine) {",
                        "      if (forceNextEmptyLine(childNode.prev)) {",
                        "        prevParts.push(hardline, hardline);",
                        "      } else if (prevBetweenLine === hardline) {",
                        "        prevParts.push(hardline);",
                        "      } else if (isTextLikeNode(childNode.prev)) {",
                        "        leadingParts.push(prevBetweenLine);",
                        "      } else {",
                        "        leadingParts.push(",
                        "          ifBreak(\"\", softline, {",
                        "            groupId: groupIds[childIndex - 1],",
                        "          })",
                        "        );",
                        "      }",
                        "    }",
                        "",
                        "    if (nextBetweenLine) {",
                        "      if (forceNextEmptyLine(childNode)) {",
                        "        if (isTextLikeNode(childNode.next)) {",
                        "          nextParts.push(hardline, hardline);",
                        "        }",
                        "      } else if (nextBetweenLine === hardline) {",
                        "        if (isTextLikeNode(childNode.next)) {",
                        "          nextParts.push(hardline);",
                        "        }",
                        "      } else {",
                        "        trailingParts.push(nextBetweenLine);",
                        "      }",
                        "    }",
                        "",
                        "    return [",
                        "      ...prevParts,",
                        "      group([",
                        "        ...leadingParts,",
                        "        group([printChild(childPath, options, print), ...trailingParts], {",
                        "          id: groupIds[childIndex],",
                        "        }),",
                        "      ]),",
                        "      ...nextParts,",
                        "    ];",
                        "  }, \"children\");",
                        "}",
                        "",
                        "export { printChildren };"
                    ]
                },
                "element.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  breakParent,",
                        "  dedentToRoot,",
                        "  group,",
                        "  ifBreak,",
                        "  indentIfBreak,",
                        "  indent,",
                        "  line,",
                        "  softline,",
                        "} from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import getNodeContent from \"../get-node-content.js\";",
                        "import {",
                        "  shouldPreserveContent,",
                        "  isScriptLikeTag,",
                        "  isVueCustomBlock,",
                        "  forceBreakContent,",
                        "} from \"../utils/index.js\";",
                        "import {",
                        "  printOpeningTagPrefix,",
                        "  printOpeningTag,",
                        "  printClosingTagSuffix,",
                        "  printClosingTag,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  needsToBorrowLastChildClosingTagEndMarker,",
                        "} from \"./tag.js\";",
                        "import { printChildren } from \"./children.js\";",
                        "",
                        "function printElement(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (shouldPreserveContent(node, options)) {",
                        "    return [",
                        "      printOpeningTagPrefix(node, options),",
                        "      group(printOpeningTag(path, options, print)),",
                        "      replaceEndOfLine(getNodeContent(node, options)),",
                        "      ...printClosingTag(node, options),",
                        "      printClosingTagSuffix(node, options),",
                        "    ];",
                        "  }",
                        "  /**",
                        "   * do not break:",
                        "   *",
                        "   *     <div>{{",
                        "   *         ~",
                        "   *       interpolation",
                        "   *     }}</div>",
                        "   *            ~",
                        "   *",
                        "   * exception: break if the opening tag breaks",
                        "   *",
                        "   *     <div",
                        "   *       long",
                        "   *           ~",
                        "   *       >{{",
                        "   *         interpolation",
                        "   *       }}</div",
                        "   *              ~",
                        "   *     >",
                        "   */",
                        "  const shouldHugContent =",
                        "    node.children.length === 1 &&",
                        "    node.firstChild.type === \"interpolation\" &&",
                        "    node.firstChild.isLeadingSpaceSensitive &&",
                        "    !node.firstChild.hasLeadingSpaces &&",
                        "    node.lastChild.isTrailingSpaceSensitive &&",
                        "    !node.lastChild.hasTrailingSpaces;",
                        "",
                        "  const attrGroupId = Symbol(\"element-attr-group-id\");",
                        "",
                        "  const printTag = (doc) =>",
                        "    group([",
                        "      group(printOpeningTag(path, options, print), { id: attrGroupId }),",
                        "      doc,",
                        "      printClosingTag(node, options),",
                        "    ]);",
                        "",
                        "  const printChildrenDoc = (childrenDoc) => {",
                        "    if (shouldHugContent) {",
                        "      return indentIfBreak(childrenDoc, { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      (isScriptLikeTag(node) || isVueCustomBlock(node, options)) &&",
                        "      node.parent.type === \"root\" &&",
                        "      options.parser === \"vue\" &&",
                        "      !options.vueIndentScriptAndStyle",
                        "    ) {",
                        "      return childrenDoc;",
                        "    }",
                        "    return indent(childrenDoc);",
                        "  };",
                        "",
                        "  const printLineBeforeChildren = () => {",
                        "    if (shouldHugContent) {",
                        "      return ifBreak(softline, \"\", { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      node.firstChild.hasLeadingSpaces &&",
                        "      node.firstChild.isLeadingSpaceSensitive",
                        "    ) {",
                        "      return line;",
                        "    }",
                        "    if (",
                        "      node.firstChild.type === \"text\" &&",
                        "      node.isWhitespaceSensitive &&",
                        "      node.isIndentationSensitive",
                        "    ) {",
                        "      return dedentToRoot(softline);",
                        "    }",
                        "    return softline;",
                        "  };",
                        "",
                        "  const printLineAfterChildren = () => {",
                        "    const needsToBorrow = node.next",
                        "      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                        "      : needsToBorrowLastChildClosingTagEndMarker(node.parent);",
                        "    if (needsToBorrow) {",
                        "      if (",
                        "        node.lastChild.hasTrailingSpaces &&",
                        "        node.lastChild.isTrailingSpaceSensitive",
                        "      ) {",
                        "        return \" \";",
                        "      }",
                        "      return \"\";",
                        "    }",
                        "    if (shouldHugContent) {",
                        "      return ifBreak(softline, \"\", { groupId: attrGroupId });",
                        "    }",
                        "    if (",
                        "      node.lastChild.hasTrailingSpaces &&",
                        "      node.lastChild.isTrailingSpaceSensitive",
                        "    ) {",
                        "      return line;",
                        "    }",
                        "    if (",
                        "      (node.lastChild.type === \"comment\" ||",
                        "        (node.lastChild.type === \"text\" &&",
                        "          node.isWhitespaceSensitive &&",
                        "          node.isIndentationSensitive)) &&",
                        "      new RegExp(",
                        "        `\\\\n[\\\\t ]{${options.tabWidth * (path.ancestors.length - 1)}}$`",
                        "      ).test(node.lastChild.value)",
                        "    ) {",
                        "      return \"\";",
                        "    }",
                        "    return softline;",
                        "  };",
                        "",
                        "  if (node.children.length === 0) {",
                        "    return printTag(",
                        "      node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line : \"\"",
                        "    );",
                        "  }",
                        "",
                        "  return printTag([",
                        "    forceBreakContent(node) ? breakParent : \"\",",
                        "    printChildrenDoc([",
                        "      printLineBeforeChildren(),",
                        "      printChildren(path, options, print),",
                        "    ]),",
                        "    printLineAfterChildren(),",
                        "  ]);",
                        "}",
                        "",
                        "export { printElement };"
                    ]
                },
                "tag.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "import assert from \"node:assert\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  indent,",
                        "  join,",
                        "  line,",
                        "  softline,",
                        "  hardline,",
                        "} from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import {",
                        "  isTextLikeNode,",
                        "  getLastDescendant,",
                        "  isPreLikeNode,",
                        "  hasPrettierIgnore,",
                        "  shouldPreserveContent,",
                        "  isVueSfcBlock,",
                        "} from \"../utils/index.js\";",
                        "",
                        "function printClosingTag(node, options) {",
                        "  return [",
                        "    node.isSelfClosing ? \"\" : printClosingTagStart(node, options),",
                        "    printClosingTagEnd(node, options),",
                        "  ];",
                        "}",
                        "",
                        "function printClosingTagStart(node, options) {",
                        "  return node.lastChild &&",
                        "    needsToBorrowParentClosingTagStartMarker(node.lastChild)",
                        "    ? \"\"",
                        "    : [",
                        "        printClosingTagPrefix(node, options),",
                        "        printClosingTagStartMarker(node, options),",
                        "      ];",
                        "}",
                        "",
                        "function printClosingTagEnd(node, options) {",
                        "  return (",
                        "    node.next",
                        "      ? needsToBorrowPrevClosingTagEndMarker(node.next)",
                        "      : needsToBorrowLastChildClosingTagEndMarker(node.parent)",
                        "  )",
                        "    ? \"\"",
                        "    : [",
                        "        printClosingTagEndMarker(node, options),",
                        "        printClosingTagSuffix(node, options),",
                        "      ];",
                        "}",
                        "",
                        "function printClosingTagPrefix(node, options) {",
                        "  return needsToBorrowLastChildClosingTagEndMarker(node)",
                        "    ? printClosingTagEndMarker(node.lastChild, options)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printClosingTagSuffix(node, options) {",
                        "  return needsToBorrowParentClosingTagStartMarker(node)",
                        "    ? printClosingTagStartMarker(node.parent, options)",
                        "    : needsToBorrowNextOpeningTagStartMarker(node)",
                        "    ? printOpeningTagStartMarker(node.next)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printClosingTagStartMarker(node, options) {",
                        "  assert(!node.isSelfClosing);",
                        "  /* c8 ignore next 3 */",
                        "  if (shouldNotPrintClosingTag(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "      return \"<!\";",
                        "    case \"element\":",
                        "      if (node.hasHtmComponentClosingTag) {",
                        "        return \"<//\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return `</${node.rawName}`;",
                        "  }",
                        "}",
                        "",
                        "function printClosingTagEndMarker(node, options) {",
                        "  if (shouldNotPrintClosingTag(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"ieConditionalEndComment\":",
                        "      return \"[endif]-->\";",
                        "    case \"ieConditionalStartComment\":",
                        "      return \"]><!-->\";",
                        "    case \"interpolation\":",
                        "      return \"}}\";",
                        "    case \"element\":",
                        "      if (node.isSelfClosing) {",
                        "        return \"/>\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return \">\";",
                        "  }",
                        "}",
                        "",
                        "function shouldNotPrintClosingTag(node, options) {",
                        "  return (",
                        "    !node.isSelfClosing &&",
                        "    !node.endSourceSpan &&",
                        "    (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options))",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowPrevClosingTagEndMarker(node) {",
                        "  /**",
                        "   *     <p></p",
                        "   *     >123",
                        "   *     ^",
                        "   *",
                        "   *     <p></p",
                        "   *     ><a",
                        "   *     ^",
                        "   */",
                        "  return (",
                        "    node.prev &&",
                        "    node.prev.type !== \"docType\" &&",
                        "    !isTextLikeNode(node.prev) &&",
                        "    node.isLeadingSpaceSensitive &&",
                        "    !node.hasLeadingSpaces",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowLastChildClosingTagEndMarker(node) {",
                        "  /**",
                        "   *     <p",
                        "   *       ><a></a",
                        "   *       ></p",
                        "   *       ^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    node.lastChild?.isTrailingSpaceSensitive &&",
                        "    !node.lastChild.hasTrailingSpaces &&",
                        "    !isTextLikeNode(getLastDescendant(node.lastChild)) &&",
                        "    !isPreLikeNode(node)",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowParentClosingTagStartMarker(node) {",
                        "  /**",
                        "   *     <p>",
                        "   *       123</p",
                        "   *          ^^^",
                        "   *     >",
                        "   *",
                        "   *         123</b",
                        "   *       ></a",
                        "   *        ^^^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    !node.next &&",
                        "    !node.hasTrailingSpaces &&",
                        "    node.isTrailingSpaceSensitive &&",
                        "    isTextLikeNode(getLastDescendant(node))",
                        "  );",
                        "}",
                        "",
                        "function needsToBorrowNextOpeningTagStartMarker(node) {",
                        "  /**",
                        "   *     123<p",
                        "   *        ^^",
                        "   *     >",
                        "   */",
                        "  return (",
                        "    node.next &&",
                        "    !isTextLikeNode(node.next) &&",
                        "    isTextLikeNode(node) &&",
                        "    node.isTrailingSpaceSensitive &&",
                        "    !node.hasTrailingSpaces",
                        "  );",
                        "}",
                        "",
                        "function getPrettierIgnoreAttributeCommentData(value) {",
                        "  const match = value.trim().match(/^prettier-ignore-attribute(?:\\s+(.+))?$/s);",
                        "",
                        "  if (!match) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!match[1]) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return match[1].split(/\\s+/);",
                        "}",
                        "",
                        "function needsToBorrowParentOpeningTagEndMarker(node) {",
                        "  /**",
                        "   *     <p",
                        "   *       >123",
                        "   *       ^",
                        "   *",
                        "   *     <p",
                        "   *       ><a",
                        "   *       ^",
                        "   */",
                        "  return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;",
                        "}",
                        "",
                        "function printAttributes(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (!isNonEmptyArray(node.attrs)) {",
                        "    return node.isSelfClosing",
                        "      ? /**",
                        "         *     <br />",
                        "         *        ^",
                        "         */",
                        "        \" \"",
                        "      : \"\";",
                        "  }",
                        "",
                        "  const ignoreAttributeData =",
                        "    node.prev?.type === \"comment\" &&",
                        "    getPrettierIgnoreAttributeCommentData(node.prev.value);",
                        "",
                        "  const hasPrettierIgnoreAttribute =",
                        "    typeof ignoreAttributeData === \"boolean\"",
                        "      ? () => ignoreAttributeData",
                        "      : Array.isArray(ignoreAttributeData)",
                        "      ? (attribute) => ignoreAttributeData.includes(attribute.rawName)",
                        "      : () => false;",
                        "",
                        "  const printedAttributes = path.map(",
                        "    ({ node: attribute }) =>",
                        "      hasPrettierIgnoreAttribute(attribute)",
                        "        ? replaceEndOfLine(",
                        "            options.originalText.slice(locStart(attribute), locEnd(attribute))",
                        "          )",
                        "        : print(),",
                        "    \"attrs\"",
                        "  );",
                        "",
                        "  const forceNotToBreakAttrContent =",
                        "    node.type === \"element\" &&",
                        "    node.fullName === \"script\" &&",
                        "    node.attrs.length === 1 &&",
                        "    node.attrs[0].fullName === \"src\" &&",
                        "    node.children.length === 0;",
                        "",
                        "  const shouldPrintAttributePerLine =",
                        "    options.singleAttributePerLine &&",
                        "    node.attrs.length > 1 &&",
                        "    !isVueSfcBlock(node, options);",
                        "  const attributeLine = shouldPrintAttributePerLine ? hardline : line;",
                        "",
                        "  /** @type {Doc[]} */",
                        "  const parts = [",
                        "    indent([",
                        "      forceNotToBreakAttrContent ? \" \" : line,",
                        "      join(attributeLine, printedAttributes),",
                        "    ]),",
                        "  ];",
                        "",
                        "  if (",
                        "    /**",
                        "     *     123<a",
                        "     *       attr",
                        "     *           ~",
                        "     *       >456",
                        "     */",
                        "    (node.firstChild &&",
                        "      needsToBorrowParentOpeningTagEndMarker(node.firstChild)) ||",
                        "    /**",
                        "     *     <span",
                        "     *       >123<meta",
                        "     *                ~",
                        "     *     /></span>",
                        "     */",
                        "    (node.isSelfClosing &&",
                        "      needsToBorrowLastChildClosingTagEndMarker(node.parent)) ||",
                        "    forceNotToBreakAttrContent",
                        "  ) {",
                        "    parts.push(node.isSelfClosing ? \" \" : \"\");",
                        "  } else {",
                        "    parts.push(",
                        "      options.bracketSameLine",
                        "        ? node.isSelfClosing",
                        "          ? \" \"",
                        "          : \"\"",
                        "        : node.isSelfClosing",
                        "        ? line",
                        "        : softline",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printOpeningTagEnd(node) {",
                        "  return node.firstChild &&",
                        "    needsToBorrowParentOpeningTagEndMarker(node.firstChild)",
                        "    ? \"\"",
                        "    : printOpeningTagEndMarker(node);",
                        "}",
                        "",
                        "function printOpeningTag(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  return [",
                        "    printOpeningTagStart(node, options),",
                        "    printAttributes(path, options, print),",
                        "    node.isSelfClosing ? \"\" : printOpeningTagEnd(node),",
                        "  ];",
                        "}",
                        "",
                        "function printOpeningTagStart(node, options) {",
                        "  return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev)",
                        "    ? \"\"",
                        "    : [printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)];",
                        "}",
                        "",
                        "function printOpeningTagPrefix(node, options) {",
                        "  return needsToBorrowParentOpeningTagEndMarker(node)",
                        "    ? printOpeningTagEndMarker(node.parent)",
                        "    : needsToBorrowPrevClosingTagEndMarker(node)",
                        "    ? printClosingTagEndMarker(node.prev, options)",
                        "    : \"\";",
                        "}",
                        "",
                        "function printOpeningTagStartMarker(node) {",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"ieConditionalStartComment\":",
                        "      return `<!--[if ${node.condition}`;",
                        "    case \"ieConditionalEndComment\":",
                        "      return \"<!--<!\";",
                        "    case \"interpolation\":",
                        "      return \"{{\";",
                        "    case \"docType\":",
                        "      return node.value === \"html\" ? \"<!doctype\" : \"<!DOCTYPE\";",
                        "    case \"element\":",
                        "      if (node.condition) {",
                        "        return `<!--[if ${node.condition}]><!--><${node.rawName}`;",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return `<${node.rawName}`;",
                        "  }",
                        "}",
                        "",
                        "function printOpeningTagEndMarker(node) {",
                        "  assert(!node.isSelfClosing);",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "      return \"]>\";",
                        "    case \"element\":",
                        "      if (node.condition) {",
                        "        return \"><!--<![endif]-->\";",
                        "      }",
                        "    // fall through",
                        "    default:",
                        "      return \">\";",
                        "  }",
                        "}",
                        "",
                        "export {",
                        "  printClosingTag,",
                        "  printClosingTagStart,",
                        "  printClosingTagStartMarker,",
                        "  printClosingTagEndMarker,",
                        "  printClosingTagSuffix,",
                        "  printClosingTagEnd,",
                        "  needsToBorrowLastChildClosingTagEndMarker,",
                        "  needsToBorrowParentClosingTagStartMarker,",
                        "  needsToBorrowPrevClosingTagEndMarker,",
                        "  printOpeningTag,",
                        "  printOpeningTagStart,",
                        "  printOpeningTagPrefix,",
                        "  printOpeningTagStartMarker,",
                        "  printOpeningTagEndMarker,",
                        "  needsToBorrowNextOpeningTagStartMarker,",
                        "  needsToBorrowParentOpeningTagEndMarker,",
                        "};"
                    ]
                }
            },
            "utils": {
                "html-elements-attributes.evaluate.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { htmlElementAttributes } from \"html-element-attributes\";",
                        "",
                        "const HTML_ELEMENT_ATTRIBUTES = new Map(",
                        "  Object.entries(htmlElementAttributes).map(([tagName, attributes]) => [",
                        "    tagName,",
                        "    new Set(attributes),",
                        "  ])",
                        ");",
                        "",
                        "export default HTML_ELEMENT_ATTRIBUTES;"
                    ]
                },
                "html-tag-names.evaluate.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { htmlTagNames } from \"html-tag-names\";",
                        "",
                        "const HTML_TAGS = new Set(htmlTagNames);",
                        "",
                        "export default HTML_TAGS;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " */",
                        "",
                        "import isFrontMatter from \"../../utils/front-matter/is-front-matter.js\";",
                        "import inferParser from \"../../utils/infer-parser.js\";",
                        "import { line, hardline, join } from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import {",
                        "  CSS_DISPLAY_TAGS,",
                        "  CSS_DISPLAY_DEFAULT,",
                        "  CSS_WHITE_SPACE_TAGS,",
                        "  CSS_WHITE_SPACE_DEFAULT,",
                        "} from \"../constants.evaluate.js\";",
                        "import htmlWhitespaceUtils from \"../../utils/html-whitespace-utils.js\";",
                        "import isUnknownNamespace from \"./is-unknown-namespace.js\";",
                        "",
                        "const htmlTrimLeadingBlankLines = (string) =>",
                        "  string.replaceAll(/^[\\t\\f\\r ]*\\n/g, \"\");",
                        "const htmlTrimPreserveIndentation = (string) =>",
                        "  htmlTrimLeadingBlankLines(htmlWhitespaceUtils.trimEnd(string));",
                        "const getLeadingAndTrailingHtmlWhitespace = (string) => {",
                        "  let text = string;",
                        "  const leadingWhitespace = htmlWhitespaceUtils.getLeadingWhitespace(text);",
                        "  if (leadingWhitespace) {",
                        "    text = text.slice(leadingWhitespace.length);",
                        "  }",
                        "  const trailingWhitespace = htmlWhitespaceUtils.getTrailingWhitespace(text);",
                        "  if (trailingWhitespace) {",
                        "    text = text.slice(0, -trailingWhitespace.length);",
                        "  }",
                        "",
                        "  return {",
                        "    leadingWhitespace,",
                        "    trailingWhitespace,",
                        "    text,",
                        "  };",
                        "};",
                        "",
                        "function shouldPreserveContent(node, options) {",
                        "  // unterminated node in ie conditional comment",
                        "  // e.g. <!--[if lt IE 9]><html><![endif]-->",
                        "  if (",
                        "    node.type === \"ieConditionalComment\" &&",
                        "    node.lastChild &&",
                        "    !node.lastChild.isSelfClosing &&",
                        "    !node.lastChild.endSourceSpan",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // incomplete html in ie conditional comment",
                        "  // e.g. <!--[if lt IE 9]></div><![endif]-->",
                        "  if (node.type === \"ieConditionalComment\" && !node.complete) {",
                        "    return true;",
                        "  }",
                        "",
                        "  // TODO: handle non-text children in <pre>",
                        "  if (",
                        "    isPreLikeNode(node) &&",
                        "    node.children.some(",
                        "      (child) => child.type !== \"text\" && child.type !== \"interpolation\"",
                        "    )",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    isVueNonHtmlBlock(node, options) &&",
                        "    !isScriptLikeTag(node) &&",
                        "    node.type !== \"interpolation\"",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function hasPrettierIgnore(node) {",
                        "  /* c8 ignore next 3 */",
                        "  if (node.type === \"attribute\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (!node.parent) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!node.prev) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return isPrettierIgnore(node.prev);",
                        "}",
                        "",
                        "function isPrettierIgnore(node) {",
                        "  return node.type === \"comment\" && node.value.trim() === \"prettier-ignore\";",
                        "}",
                        "",
                        "/** there's no opening/closing tag or it's considered not breakable */",
                        "function isTextLikeNode(node) {",
                        "  return node.type === \"text\" || node.type === \"comment\";",
                        "}",
                        "",
                        "function isScriptLikeTag(node) {",
                        "  return (",
                        "    node.type === \"element\" &&",
                        "    (node.fullName === \"script\" ||",
                        "      node.fullName === \"style\" ||",
                        "      node.fullName === \"svg:style\" ||",
                        "      node.fullName === \"svg:script\" ||",
                        "      (isUnknownNamespace(node) &&",
                        "        (node.name === \"script\" || node.name === \"style\")))",
                        "  );",
                        "}",
                        "",
                        "function canHaveInterpolation(node) {",
                        "  return node.children && !isScriptLikeTag(node);",
                        "}",
                        "",
                        "function isWhitespaceSensitiveNode(node) {",
                        "  return (",
                        "    isScriptLikeTag(node) ||",
                        "    node.type === \"interpolation\" ||",
                        "    isIndentationSensitiveNode(node)",
                        "  );",
                        "}",
                        "",
                        "function isIndentationSensitiveNode(node) {",
                        "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                        "}",
                        "",
                        "function isLeadingSpaceSensitiveNode(node, options) {",
                        "  const isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();",
                        "",
                        "  if (",
                        "    isLeadingSpaceSensitive &&",
                        "    !node.prev &&",
                        "    node.parent?.tagDefinition?.ignoreFirstLf",
                        "  ) {",
                        "    return node.type === \"interpolation\";",
                        "  }",
                        "",
                        "  return isLeadingSpaceSensitive;",
                        "",
                        "  function _isLeadingSpaceSensitiveNode() {",
                        "    if (isFrontMatter(node)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (",
                        "      (node.type === \"text\" || node.type === \"interpolation\") &&",
                        "      node.prev &&",
                        "      (node.prev.type === \"text\" || node.prev.type === \"interpolation\")",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "",
                        "    if (!node.parent || node.parent.cssDisplay === \"none\") {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (isPreLikeNode(node.parent)) {",
                        "      return true;",
                        "    }",
                        "",
                        "    if (",
                        "      !node.prev &&",
                        "      (node.parent.type === \"root\" ||",
                        "        (isPreLikeNode(node) && node.parent) ||",
                        "        isScriptLikeTag(node.parent) ||",
                        "        isVueCustomBlock(node.parent, options) ||",
                        "        !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (",
                        "      node.prev &&",
                        "      !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return true;",
                        "  }",
                        "}",
                        "",
                        "function isTrailingSpaceSensitiveNode(node, options) {",
                        "  if (isFrontMatter(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    (node.type === \"text\" || node.type === \"interpolation\") &&",
                        "    node.next &&",
                        "    (node.next.type === \"text\" || node.next.type === \"interpolation\")",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!node.parent || node.parent.cssDisplay === \"none\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isPreLikeNode(node.parent)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    !node.next &&",
                        "    (node.parent.type === \"root\" ||",
                        "      (isPreLikeNode(node) && node.parent) ||",
                        "      isScriptLikeTag(node.parent) ||",
                        "      isVueCustomBlock(node.parent, options) ||",
                        "      !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    node.next &&",
                        "    !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "function isDanglingSpaceSensitiveNode(node) {",
                        "  return (",
                        "    isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) &&",
                        "    !isScriptLikeTag(node)",
                        "  );",
                        "}",
                        "",
                        "function forceNextEmptyLine(node) {",
                        "  return (",
                        "    isFrontMatter(node) ||",
                        "    (node.next &&",
                        "      node.sourceSpan.end &&",
                        "      node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line)",
                        "  );",
                        "}",
                        "",
                        "/** firstChild leadingSpaces and lastChild trailingSpaces */",
                        "function forceBreakContent(node) {",
                        "  return (",
                        "    forceBreakChildren(node) ||",
                        "    (node.type === \"element\" &&",
                        "      node.children.length > 0 &&",
                        "      ([\"body\", \"script\", \"style\"].includes(node.name) ||",
                        "        node.children.some((child) => hasNonTextChild(child)))) ||",
                        "    (node.firstChild &&",
                        "      node.firstChild === node.lastChild &&",
                        "      node.firstChild.type !== \"text\" &&",
                        "      hasLeadingLineBreak(node.firstChild) &&",
                        "      (!node.lastChild.isTrailingSpaceSensitive ||",
                        "        hasTrailingLineBreak(node.lastChild)))",
                        "  );",
                        "}",
                        "",
                        "/** spaces between children */",
                        "function forceBreakChildren(node) {",
                        "  return (",
                        "    node.type === \"element\" &&",
                        "    node.children.length > 0 &&",
                        "    ([\"html\", \"head\", \"ul\", \"ol\", \"select\"].includes(node.name) ||",
                        "      (node.cssDisplay.startsWith(\"table\") && node.cssDisplay !== \"table-cell\"))",
                        "  );",
                        "}",
                        "",
                        "function preferHardlineAsLeadingSpaces(node) {",
                        "  return (",
                        "    preferHardlineAsSurroundingSpaces(node) ||",
                        "    (node.prev && preferHardlineAsTrailingSpaces(node.prev)) ||",
                        "    hasSurroundingLineBreak(node)",
                        "  );",
                        "}",
                        "",
                        "function preferHardlineAsTrailingSpaces(node) {",
                        "  return (",
                        "    preferHardlineAsSurroundingSpaces(node) ||",
                        "    (node.type === \"element\" && node.fullName === \"br\") ||",
                        "    hasSurroundingLineBreak(node)",
                        "  );",
                        "}",
                        "",
                        "function hasSurroundingLineBreak(node) {",
                        "  return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);",
                        "}",
                        "",
                        "function hasLeadingLineBreak(node) {",
                        "  return (",
                        "    node.hasLeadingSpaces &&",
                        "    (node.prev",
                        "      ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line",
                        "      : node.parent.type === \"root\" ||",
                        "        node.parent.startSourceSpan.end.line < node.sourceSpan.start.line)",
                        "  );",
                        "}",
                        "",
                        "function hasTrailingLineBreak(node) {",
                        "  return (",
                        "    node.hasTrailingSpaces &&",
                        "    (node.next",
                        "      ? node.next.sourceSpan.start.line > node.sourceSpan.end.line",
                        "      : node.parent.type === \"root\" ||",
                        "        (node.parent.endSourceSpan &&",
                        "          node.parent.endSourceSpan.start.line > node.sourceSpan.end.line))",
                        "  );",
                        "}",
                        "",
                        "function preferHardlineAsSurroundingSpaces(node) {",
                        "  switch (node.type) {",
                        "    case \"ieConditionalComment\":",
                        "    case \"comment\":",
                        "    case \"directive\":",
                        "      return true;",
                        "    case \"element\":",
                        "      return [\"script\", \"select\"].includes(node.name);",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function getLastDescendant(node) {",
                        "  return node.lastChild ? getLastDescendant(node.lastChild) : node;",
                        "}",
                        "",
                        "function hasNonTextChild(node) {",
                        "  return node.children?.some((child) => child.type !== \"text\");",
                        "}",
                        "",
                        "function inferParserByTypeAttribute(type) {",
                        "  if (!type) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (type) {",
                        "    case \"module\":",
                        "    case \"text/javascript\":",
                        "    case \"text/babel\":",
                        "    case \"application/javascript\":",
                        "      return \"babel\";",
                        "",
                        "    case \"application/x-typescript\":",
                        "      return \"typescript\";",
                        "",
                        "    case \"text/markdown\":",
                        "      return \"markdown\";",
                        "",
                        "    case \"text/html\":",
                        "      return \"html\";",
                        "",
                        "    case \"text/x-handlebars-template\":",
                        "      return \"glimmer\";",
                        "",
                        "    default:",
                        "      if (",
                        "        type.endsWith(\"json\") ||",
                        "        type.endsWith(\"importmap\") ||",
                        "        type === \"speculationrules\"",
                        "      ) {",
                        "        return \"json\";",
                        "      }",
                        "  }",
                        "}",
                        "",
                        "function inferScriptParser(node, options) {",
                        "  const { name, attrMap } = node;",
                        "",
                        "  if (name !== \"script\" || Object.hasOwn(attrMap, \"src\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  const { type, lang } = node.attrMap;",
                        "",
                        "  if (!lang && !type) {",
                        "    return \"babel\";",
                        "  }",
                        "",
                        "  return (",
                        "    inferParser(options, { language: lang }) ?? inferParserByTypeAttribute(type)",
                        "  );",
                        "}",
                        "",
                        "function inferVueSfcBlockParser(node, options) {",
                        "  if (!isVueNonHtmlBlock(node, options)) {",
                        "    return;",
                        "  }",
                        "  const { attrMap } = node;",
                        "",
                        "  if (Object.hasOwn(attrMap, \"src\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  const { type, lang } = attrMap;",
                        "",
                        "  return (",
                        "    inferParser(options, { language: lang }) ?? inferParserByTypeAttribute(type)",
                        "  );",
                        "}",
                        "",
                        "function inferStyleParser(node, options) {",
                        "  if (node.name !== \"style\") {",
                        "    return;",
                        "  }",
                        "  const { lang } = node.attrMap;",
                        "  return lang ? inferParser(options, { language: lang }) : \"css\";",
                        "}",
                        "",
                        "function inferElementParser(node, options) {",
                        "  return (",
                        "    inferScriptParser(node, options) ??",
                        "    inferStyleParser(node, options) ??",
                        "    inferVueSfcBlockParser(node, options)",
                        "  );",
                        "}",
                        "",
                        "function isBlockLikeCssDisplay(cssDisplay) {",
                        "  return (",
                        "    cssDisplay === \"block\" ||",
                        "    cssDisplay === \"list-item\" ||",
                        "    cssDisplay.startsWith(\"table\")",
                        "  );",
                        "}",
                        "",
                        "function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                        "}",
                        "",
                        "function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                        "}",
                        "",
                        "function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay);",
                        "}",
                        "",
                        "function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay);",
                        "}",
                        "",
                        "function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {",
                        "  return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== \"inline-block\";",
                        "}",
                        "",
                        "function isPreLikeNode(node) {",
                        "  return getNodeCssStyleWhiteSpace(node).startsWith(\"pre\");",
                        "}",
                        "",
                        "function hasParent(node, fn) {",
                        "  let current = node;",
                        "",
                        "  while (current) {",
                        "    if (fn(current)) {",
                        "      return true;",
                        "    }",
                        "",
                        "    current = current.parent;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function getNodeCssStyleDisplay(node, options) {",
                        "  // Every root block in Vue SFC is a block",
                        "  if (isVueSfcBlock(node, options)) {",
                        "    return \"block\";",
                        "  }",
                        "",
                        "  if (node.prev?.type === \"comment\") {",
                        "    // <!-- display: block -->",
                        "    const match = node.prev.value.match(/^\\s*display:\\s*([a-z]+)\\s*$/);",
                        "    if (match) {",
                        "      return match[1];",
                        "    }",
                        "  }",
                        "",
                        "  let isInSvgForeignObject = false;",
                        "  if (node.type === \"element\" && node.namespace === \"svg\") {",
                        "    if (hasParent(node, (parent) => parent.fullName === \"svg:foreignObject\")) {",
                        "      isInSvgForeignObject = true;",
                        "    } else {",
                        "      return node.name === \"svg\" ? \"inline-block\" : \"block\";",
                        "    }",
                        "  }",
                        "",
                        "  switch (options.htmlWhitespaceSensitivity) {",
                        "    case \"strict\":",
                        "      return \"inline\";",
                        "    case \"ignore\":",
                        "      return \"block\";",
                        "    default:",
                        "      return (",
                        "        (node.type === \"element\" &&",
                        "          (!node.namespace ||",
                        "            isInSvgForeignObject ||",
                        "            isUnknownNamespace(node)) &&",
                        "          CSS_DISPLAY_TAGS[node.name]) ||",
                        "        CSS_DISPLAY_DEFAULT",
                        "      );",
                        "  }",
                        "}",
                        "",
                        "function getNodeCssStyleWhiteSpace(node) {",
                        "  return (",
                        "    (node.type === \"element\" &&",
                        "      (!node.namespace || isUnknownNamespace(node)) &&",
                        "      CSS_WHITE_SPACE_TAGS[node.name]) ||",
                        "    CSS_WHITE_SPACE_DEFAULT",
                        "  );",
                        "}",
                        "",
                        "function getMinIndentation(text) {",
                        "  let minIndentation = Number.POSITIVE_INFINITY;",
                        "",
                        "  for (const lineText of text.split(\"\\n\")) {",
                        "    if (lineText.length === 0) {",
                        "      continue;",
                        "    }",
                        "",
                        "    const indentation = htmlWhitespaceUtils.getLeadingWhitespaceCount(lineText);",
                        "    if (indentation === 0) {",
                        "      return 0;",
                        "    }",
                        "",
                        "    if (lineText.length === indentation) {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (indentation < minIndentation) {",
                        "      minIndentation = indentation;",
                        "    }",
                        "  }",
                        "",
                        "  return minIndentation === Number.POSITIVE_INFINITY ? 0 : minIndentation;",
                        "}",
                        "",
                        "function dedentString(text, minIndent = getMinIndentation(text)) {",
                        "  return minIndent === 0",
                        "    ? text",
                        "    : text",
                        "        .split(\"\\n\")",
                        "        .map((lineText) => lineText.slice(minIndent))",
                        "        .join(\"\\n\");",
                        "}",
                        "",
                        "function unescapeQuoteEntities(text) {",
                        "  return text.replaceAll(\"&apos;\", \"'\").replaceAll(\"&quot;\", '\"');",
                        "}",
                        "",
                        "function getUnescapedAttributeValue(node) {",
                        "  return unescapeQuoteEntities(node.value);",
                        "}",
                        "",
                        "// top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block",
                        "// See https://vue-loader.vuejs.org/spec.html for detail",
                        "const vueRootElementsSet = new Set([\"template\", \"style\", \"script\"]);",
                        "function isVueCustomBlock(node, options) {",
                        "  return isVueSfcBlock(node, options) && !vueRootElementsSet.has(node.fullName);",
                        "}",
                        "",
                        "function isVueSfcBlock(node, options) {",
                        "  return (",
                        "    options.parser === \"vue\" &&",
                        "    node.type === \"element\" &&",
                        "    node.parent.type === \"root\" &&",
                        "    node.fullName.toLowerCase() !== \"html\"",
                        "  );",
                        "}",
                        "",
                        "function isVueNonHtmlBlock(node, options) {",
                        "  return (",
                        "    isVueSfcBlock(node, options) &&",
                        "    (isVueCustomBlock(node, options) ||",
                        "      (node.attrMap.lang && node.attrMap.lang !== \"html\"))",
                        "  );",
                        "}",
                        "",
                        "function isVueSlotAttribute(attribute) {",
                        "  const attributeName = attribute.fullName;",
                        "  return (",
                        "    attributeName.charAt(0) === \"#\" ||",
                        "    attributeName === \"slot-scope\" ||",
                        "    attributeName === \"v-slot\" ||",
                        "    attributeName.startsWith(\"v-slot:\")",
                        "  );",
                        "}",
                        "",
                        "function isVueSfcBindingsAttribute(attribute, options) {",
                        "  const element = attribute.parent;",
                        "  if (!isVueSfcBlock(element, options)) {",
                        "    return false;",
                        "  }",
                        "  const tagName = element.fullName;",
                        "  const attributeName = attribute.fullName;",
                        "",
                        "  return (",
                        "    // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-script-setup.md",
                        "    (tagName === \"script\" && attributeName === \"setup\") ||",
                        "    // https://github.com/vuejs/rfcs/blob/sfc-improvements/active-rfcs/0000-sfc-style-variables.md",
                        "    (tagName === \"style\" && attributeName === \"vars\")",
                        "  );",
                        "}",
                        "",
                        "function getTextValueParts(node, value = node.value) {",
                        "  return node.parent.isWhitespaceSensitive",
                        "    ? node.parent.isIndentationSensitive",
                        "      ? replaceEndOfLine(value)",
                        "      : replaceEndOfLine(",
                        "          dedentString(htmlTrimPreserveIndentation(value)),",
                        "          hardline",
                        "        )",
                        "    : join(line, htmlWhitespaceUtils.split(value));",
                        "}",
                        "",
                        "function isVueScriptTag(node, options) {",
                        "  return isVueSfcBlock(node, options) && node.name === \"script\";",
                        "}",
                        "",
                        "export {",
                        "  htmlTrimPreserveIndentation,",
                        "  getLeadingAndTrailingHtmlWhitespace,",
                        "  canHaveInterpolation,",
                        "  dedentString,",
                        "  forceBreakChildren,",
                        "  forceBreakContent,",
                        "  forceNextEmptyLine,",
                        "  getLastDescendant,",
                        "  getNodeCssStyleDisplay,",
                        "  getNodeCssStyleWhiteSpace,",
                        "  hasPrettierIgnore,",
                        "  inferElementParser,",
                        "  isVueCustomBlock,",
                        "  isVueNonHtmlBlock,",
                        "  isVueScriptTag,",
                        "  isVueSlotAttribute,",
                        "  isVueSfcBindingsAttribute,",
                        "  isVueSfcBlock,",
                        "  isDanglingSpaceSensitiveNode,",
                        "  isIndentationSensitiveNode,",
                        "  isLeadingSpaceSensitiveNode,",
                        "  isPreLikeNode,",
                        "  isScriptLikeTag,",
                        "  isTextLikeNode,",
                        "  isTrailingSpaceSensitiveNode,",
                        "  isWhitespaceSensitiveNode,",
                        "  isUnknownNamespace,",
                        "  preferHardlineAsLeadingSpaces,",
                        "  preferHardlineAsTrailingSpaces,",
                        "  shouldPreserveContent,",
                        "  unescapeQuoteEntities,",
                        "  getTextValueParts,",
                        "  htmlWhitespaceUtils,",
                        "  getUnescapedAttributeValue,",
                        "};"
                    ]
                },
                "is-unknown-namespace.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isUnknownNamespace(node) {",
                        "  return (",
                        "    node.type === \"element\" &&",
                        "    !node.hasExplicitNamespace &&",
                        "    ![\"html\", \"svg\"].includes(node.namespace)",
                        "  );",
                        "}",
                        "",
                        "export default isUnknownNamespace;"
                    ]
                },
                "is-vue-sfc-with-typescript-script.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { isVueScriptTag } from \"./index.js\";",
                        "",
                        "const cache = new WeakMap();",
                        "function isVueSfcWithTypescriptScript(path, options) {",
                        "  const { root } = path;",
                        "  if (!cache.has(root)) {",
                        "    cache.set(",
                        "      root,",
                        "      root.children.some(",
                        "        (child) =>",
                        "          isVueScriptTag(child, options) &&",
                        "          [\"ts\", \"typescript\"].includes(child.attrMap.lang)",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  return cache.get(root);",
                        "}",
                        "",
                        "export default isVueSfcWithTypescriptScript;"
                    ]
                }
            }
        },
        "language-js": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isBlockComment from \"./utils/is-block-comment.js\";",
                    "import { isArrayOrTupleExpression } from \"./utils/index.js\";",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"range\",",
                    "  \"raw\",",
                    "  \"comments\",",
                    "  \"leadingComments\",",
                    "  \"trailingComments\",",
                    "  \"innerComments\",",
                    "  \"extra\",",
                    "  \"start\",",
                    "  \"end\",",
                    "  \"loc\",",
                    "  \"flags\",",
                    "  \"errors\",",
                    "  \"tokens\",",
                    "]);",
                    "",
                    "const removeTemplateElementsValue = (node) => {",
                    "  for (const templateElement of node.quasis) {",
                    "    delete templateElement.value;",
                    "  }",
                    "};",
                    "",
                    "function clean(ast, newObj, parent) {",
                    "  if (ast.type === \"Program\") {",
                    "    delete newObj.sourceType;",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"BigIntLiteral\" ||",
                    "      ast.type === \"BigIntLiteralTypeAnnotation\") &&",
                    "    newObj.value",
                    "  ) {",
                    "    newObj.value = newObj.value.toLowerCase();",
                    "  }",
                    "  if (",
                    "    (ast.type === \"BigIntLiteral\" || ast.type === \"Literal\") &&",
                    "    newObj.bigint",
                    "  ) {",
                    "    newObj.bigint = newObj.bigint.toLowerCase();",
                    "  }",
                    "",
                    "  if (ast.type === \"DecimalLiteral\") {",
                    "    newObj.value = Number(newObj.value);",
                    "  }",
                    "  if (ast.type === \"Literal\" && newObj.decimal) {",
                    "    newObj.decimal = Number(newObj.decimal);",
                    "  }",
                    "",
                    "  // We remove extra `;` and add them when needed",
                    "  if (ast.type === \"EmptyStatement\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We move text around, including whitespaces and add {\" \"}",
                    "  if (ast.type === \"JSXText\") {",
                    "    return null;",
                    "  }",
                    "  if (",
                    "    ast.type === \"JSXExpressionContainer\" &&",
                    "    (ast.expression.type === \"Literal\" ||",
                    "      ast.expression.type === \"StringLiteral\") &&",
                    "    ast.expression.value === \" \"",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "",
                    "  // We change {'key': value} into {key: value}.",
                    "  // And {key: value} into {'key': value}.",
                    "  // Also for (some) number keys.",
                    "  if (",
                    "    (ast.type === \"Property\" ||",
                    "      ast.type === \"ObjectProperty\" ||",
                    "      ast.type === \"MethodDefinition\" ||",
                    "      ast.type === \"ClassProperty\" ||",
                    "      ast.type === \"ClassMethod\" ||",
                    "      ast.type === \"PropertyDefinition\" ||",
                    "      ast.type === \"TSDeclareMethod\" ||",
                    "      ast.type === \"TSPropertySignature\" ||",
                    "      ast.type === \"ObjectTypeProperty\") &&",
                    "    typeof ast.key === \"object\" &&",
                    "    ast.key &&",
                    "    (ast.key.type === \"Literal\" ||",
                    "      ast.key.type === \"NumericLiteral\" ||",
                    "      ast.key.type === \"StringLiteral\" ||",
                    "      ast.key.type === \"Identifier\")",
                    "  ) {",
                    "    delete newObj.key;",
                    "  }",
                    "",
                    "  // Remove raw and cooked values from TemplateElement when it's CSS",
                    "  // styled-jsx",
                    "  if (",
                    "    ast.type === \"JSXElement\" &&",
                    "    ast.openingElement.name.name === \"style\" &&",
                    "    ast.openingElement.attributes.some((attr) => attr.name.name === \"jsx\")",
                    "  ) {",
                    "    for (const { type, expression } of newObj.children) {",
                    "      if (",
                    "        type === \"JSXExpressionContainer\" &&",
                    "        expression.type === \"TemplateLiteral\"",
                    "      ) {",
                    "        removeTemplateElementsValue(expression);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  // CSS template literals in css prop",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.name.name === \"css\" &&",
                    "    ast.value.type === \"JSXExpressionContainer\" &&",
                    "    ast.value.expression.type === \"TemplateLiteral\"",
                    "  ) {",
                    "    removeTemplateElementsValue(newObj.value.expression);",
                    "  }",
                    "",
                    "  // We change quotes",
                    "  if (",
                    "    ast.type === \"JSXAttribute\" &&",
                    "    ast.value?.type === \"Literal\" &&",
                    "    /[\"']|&quot;|&apos;/.test(ast.value.value)",
                    "  ) {",
                    "    newObj.value.value = newObj.value.value.replaceAll(",
                    "      /[\"']|&quot;|&apos;/g,",
                    "      '\"'",
                    "    );",
                    "  }",
                    "",
                    "  // Angular Components: Inline HTML template and Inline CSS styles",
                    "  const expression = ast.expression || ast.callee;",
                    "  if (",
                    "    ast.type === \"Decorator\" &&",
                    "    expression.type === \"CallExpression\" &&",
                    "    expression.callee.name === \"Component\" &&",
                    "    expression.arguments.length === 1",
                    "  ) {",
                    "    const astProps = ast.expression.arguments[0].properties;",
                    "    for (const [",
                    "      index,",
                    "      prop,",
                    "    ] of newObj.expression.arguments[0].properties.entries()) {",
                    "      switch (astProps[index].key.name) {",
                    "        case \"styles\":",
                    "          if (isArrayOrTupleExpression(prop.value)) {",
                    "            removeTemplateElementsValue(prop.value.elements[0]);",
                    "          }",
                    "          break;",
                    "        case \"template\":",
                    "          if (prop.value.type === \"TemplateLiteral\") {",
                    "            removeTemplateElementsValue(prop.value);",
                    "          }",
                    "          break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  // styled-components, graphql, markdown",
                    "  if (",
                    "    ast.type === \"TaggedTemplateExpression\" &&",
                    "    (ast.tag.type === \"MemberExpression\" ||",
                    "      (ast.tag.type === \"Identifier\" &&",
                    "        (ast.tag.name === \"gql\" ||",
                    "          ast.tag.name === \"graphql\" ||",
                    "          ast.tag.name === \"css\" ||",
                    "          ast.tag.name === \"md\" ||",
                    "          ast.tag.name === \"markdown\" ||",
                    "          ast.tag.name === \"html\")) ||",
                    "      ast.tag.type === \"CallExpression\")",
                    "  ) {",
                    "    removeTemplateElementsValue(newObj.quasi);",
                    "  }",
                    "  if (ast.type === \"TemplateLiteral\") {",
                    "    // This checks for a leading comment that is exactly `/* GraphQL */`",
                    "    // In order to be in line with other implementations of this comment tag",
                    "    // we will not trim the comment value and we will expect exactly one space on",
                    "    // either side of the GraphQL string",
                    "    // Also see ./embed.js",
                    "    const hasLanguageComment = ast.leadingComments?.some(",
                    "      (comment) =>",
                    "        isBlockComment(comment) &&",
                    "        [\"GraphQL\", \"HTML\"].some(",
                    "          (languageName) => comment.value === ` ${languageName} `",
                    "        )",
                    "    );",
                    "    if (",
                    "      hasLanguageComment ||",
                    "      (parent.type === \"CallExpression\" && parent.callee.name === \"graphql\") ||",
                    "      // TODO: check parser",
                    "      // `flow` and `typescript` don't have `leadingComments`",
                    "      !ast.leadingComments",
                    "    ) {",
                    "      removeTemplateElementsValue(newObj);",
                    "    }",
                    "  }",
                    "",
                    "  // Prettier removes degenerate union and intersection types with only one member.",
                    "  if (",
                    "    (ast.type === \"TSIntersectionType\" || ast.type === \"TSUnionType\") &&",
                    "    ast.types.length === 1",
                    "  ) {",
                    "    return newObj.types[0];",
                    "  }",
                    "",
                    "  // We print `(a?.b!).c` as `(a?.b)!.c`, but `typescript` parse them differently",
                    "  if (",
                    "    ast.type === \"ChainExpression\" &&",
                    "    ast.expression.type === \"TSNonNullExpression\"",
                    "  ) {",
                    "    // Ideally, we should swap these two nodes, but `type` is the only difference",
                    "    [newObj.type, newObj.expression.type] = [",
                    "      newObj.expression.type,",
                    "      newObj.type,",
                    "    ];",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "export default clean;"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.JavaScript, (data) => ({",
                    "    parsers: [",
                    "      \"babel\",",
                    "      \"acorn\",",
                    "      \"espree\",",
                    "      \"meriyah\",",
                    "      \"babel-flow\",",
                    "      \"babel-ts\",",
                    "      \"flow\",",
                    "      \"typescript\",",
                    "    ],",
                    "    vscodeLanguageIds: [\"javascript\", \"mongo\"],",
                    "    interpreters: [",
                    "      ...data.interpreters,",
                    "      // https://github.com/google/zx",
                    "      \"zx\",",
                    "    ],",
                    "    extensions: [",
                    "      ...data.extensions.filter((extension) => extension !== \".jsx\"),",
                    "      // WeiXin Script (Weixin Mini Programs)",
                    "      // https://developers.weixin.qq.com/miniprogram/en/dev/framework/view/wxs/",
                    "      \".wxs\",",
                    "    ],",
                    "  })),",
                    "  createLanguage(linguistLanguages.JavaScript, () => ({",
                    "    name: \"Flow\",",
                    "    parsers: [\"flow\", \"babel-flow\"],",
                    "    vscodeLanguageIds: [\"javascript\"],",
                    "    aliases: [],",
                    "    filenames: [],",
                    "    extensions: [\".js.flow\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.JavaScript, () => ({",
                    "    name: \"JSX\",",
                    "    parsers: [",
                    "      \"babel\",",
                    "      \"babel-flow\",",
                    "      \"babel-ts\",",
                    "      \"flow\",",
                    "      \"typescript\",",
                    "      \"espree\",",
                    "      \"meriyah\",",
                    "    ],",
                    "    vscodeLanguageIds: [\"javascriptreact\"],",
                    "    aliases: undefined,",
                    "    filenames: undefined,",
                    "    extensions: [\".jsx\"],",
                    "    group: \"JavaScript\",",
                    "    interpreters: undefined,",
                    "    tmScope: \"source.js.jsx\",",
                    "    aceMode: \"javascript\",",
                    "    codemirrorMode: \"jsx\",",
                    "    codemirrorMimeType: \"text/jsx\",",
                    "    color: undefined,",
                    "  })),",
                    "  createLanguage(linguistLanguages.TypeScript, () => ({",
                    "    parsers: [\"typescript\", \"babel-ts\"],",
                    "    vscodeLanguageIds: [\"typescript\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.TSX, () => ({",
                    "    parsers: [\"typescript\", \"babel-ts\"],",
                    "    vscodeLanguageIds: [\"typescriptreact\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./types/estree.js\").Node} Node",
                    " */",
                    "",
                    "function locStart(node) {",
                    "  const start = node.range ? node.range[0] : node.start;",
                    "",
                    "  // Handle nodes with decorators. They should start at the first decorator",
                    "  const decorators = node.declaration?.decorators ?? node.decorators;",
                    "  if (isNonEmptyArray(decorators)) {",
                    "    return Math.min(locStart(decorators[0]), start);",
                    "  }",
                    "",
                    "  return start;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.range ? node.range[1] : node.end;",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLocStart(nodeA, nodeB) {",
                    "  const nodeAStart = locStart(nodeA);",
                    "  return Number.isInteger(nodeAStart) && nodeAStart === locStart(nodeB);",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLocEnd(nodeA, nodeB) {",
                    "  const nodeAEnd = locEnd(nodeA);",
                    "  return Number.isInteger(nodeAEnd) && nodeAEnd === locEnd(nodeB);",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} nodeA",
                    " * @param {Node} nodeB",
                    " * @returns {boolean}",
                    " */",
                    "function hasSameLoc(nodeA, nodeB) {",
                    "  return hasSameLocStart(nodeA, nodeB) && hasSameLocEnd(nodeA, nodeB);",
                    "}",
                    "",
                    "export { locStart, locEnd, hasSameLocStart, hasSameLoc };"
                ]
            },
            "needs-parens.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import {",
                    "  getFunctionParameters,",
                    "  getLeftSidePathName,",
                    "  hasNakedLeftSide,",
                    "  hasNode,",
                    "  isBitwiseOperator,",
                    "  startsWithNoLookaheadToken,",
                    "  shouldFlatten,",
                    "  getPrecedence,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  isObjectProperty,",
                    "  isTSTypeExpression,",
                    "  isArrayOrTupleExpression,",
                    "  isObjectOrRecordExpression,",
                    "  createTypeCheckFunction,",
                    "} from \"./utils/index.js\";",
                    "",
                    "function needsParens(path, options) {",
                    "  if (path.isRoot) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const { node, key, parent } = path;",
                    "",
                    "  // to avoid unexpected `}}` in HTML interpolations",
                    "  if (",
                    "    options.__isInHtmlInterpolation &&",
                    "    !options.bracketSpacing &&",
                    "    endsWithRightBracket(node) &&",
                    "    isFollowedByRightBracket(path)",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Only statements don't need parentheses.",
                    "  if (isStatement(node)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // Identifiers never need parentheses.",
                    "  if (node.type === \"Identifier\") {",
                    "    // ...unless those identifiers are embed placeholders. They might be substituted by complex",
                    "    // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):",
                    "    //     let tpl = html`<script> f((${expr}) / 2); </script>`;",
                    "    // If the inner JS formatter removes the parens, the expression might change its meaning:",
                    "    //     f((a + b) / 2)  vs  f(a + b / 2)",
                    "    if (",
                    "      node.extra?.parenthesized &&",
                    "      /^PRETTIER_HTML_PLACEHOLDER_\\d+_\\d+_IN_JS$/.test(node.name)",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    // `for ((async) of []);` and `for ((let) of []);`",
                    "    if (",
                    "      key === \"left\" &&",
                    "      ((node.name === \"async\" && !parent.await) || node.name === \"let\") &&",
                    "      parent.type === \"ForOfStatement\"",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "",
                    "    // `for ((let.a) of []);`",
                    "    if (node.name === \"let\") {",
                    "      const expression = path.findAncestor(",
                    "        (node) => node.type === \"ForOfStatement\"",
                    "      )?.left;",
                    "      if (",
                    "        expression &&",
                    "        startsWithNoLookaheadToken(",
                    "          expression,",
                    "          (leftmostNode) => leftmostNode === node",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "",
                    "    // `(let)[a] = 1`",
                    "    if (",
                    "      key === \"object\" &&",
                    "      node.name === \"let\" &&",
                    "      parent.type === \"MemberExpression\" &&",
                    "      parent.computed &&",
                    "      !parent.optional",
                    "    ) {",
                    "      const statement = path.findAncestor(",
                    "        (node) =>",
                    "          node.type === \"ExpressionStatement\" ||",
                    "          node.type === \"ForStatement\" ||",
                    "          node.type === \"ForInStatement\"",
                    "      );",
                    "      const expression = !statement",
                    "        ? undefined",
                    "        : statement.type === \"ExpressionStatement\"",
                    "        ? statement.expression",
                    "        : statement.type === \"ForStatement\"",
                    "        ? statement.init",
                    "        : statement.left;",
                    "      if (",
                    "        expression &&",
                    "        startsWithNoLookaheadToken(",
                    "          expression,",
                    "          (leftmostNode) => leftmostNode === node",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    }",
                    "",
                    "    return false;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"ObjectExpression\" ||",
                    "    node.type === \"FunctionExpression\" ||",
                    "    node.type === \"ClassExpression\" ||",
                    "    node.type === \"DoExpression\"",
                    "  ) {",
                    "    const expression = path.findAncestor(",
                    "      (node) => node.type === \"ExpressionStatement\"",
                    "    )?.expression;",
                    "    if (",
                    "      expression &&",
                    "      startsWithNoLookaheadToken(",
                    "        expression,",
                    "        (leftmostNode) => leftmostNode === node",
                    "      )",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  if (node.type === \"ObjectExpression\") {",
                    "    const arrowFunctionBody = path.findAncestor(",
                    "      (node) => node.type === \"ArrowFunctionExpression\"",
                    "    )?.body;",
                    "    if (",
                    "      arrowFunctionBody &&",
                    "      arrowFunctionBody.type !== \"SequenceExpression\" && // these have parens added anyway",
                    "      arrowFunctionBody.type !== \"AssignmentExpression\" &&",
                    "      startsWithNoLookaheadToken(",
                    "        arrowFunctionBody,",
                    "        (leftmostNode) => leftmostNode === node",
                    "      )",
                    "    ) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  switch (parent.type) {",
                    "    case \"ParenthesizedExpression\":",
                    "      return false;",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\":",
                    "      // Add parens around the extends clause of a class. It is needed for almost",
                    "      // all expressions.",
                    "      if (",
                    "        key === \"superClass\" &&",
                    "        (node.type === \"ArrowFunctionExpression\" ||",
                    "          node.type === \"AssignmentExpression\" ||",
                    "          node.type === \"AwaitExpression\" ||",
                    "          node.type === \"BinaryExpression\" ||",
                    "          node.type === \"ConditionalExpression\" ||",
                    "          node.type === \"LogicalExpression\" ||",
                    "          node.type === \"NewExpression\" ||",
                    "          node.type === \"ObjectExpression\" ||",
                    "          node.type === \"SequenceExpression\" ||",
                    "          node.type === \"TaggedTemplateExpression\" ||",
                    "          node.type === \"UnaryExpression\" ||",
                    "          node.type === \"UpdateExpression\" ||",
                    "          node.type === \"YieldExpression\" ||",
                    "          node.type === \"TSNonNullExpression\" ||",
                    "          (node.type === \"ClassExpression\" && isNonEmptyArray(node.decorators)))",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      break;",
                    "",
                    "    case \"ExportDefaultDeclaration\":",
                    "      return (",
                    "        // `export default function` or `export default class` can't be followed by",
                    "        // anything after. So an expression like `export default (function(){}).toString()`",
                    "        // needs to be followed by a parentheses",
                    "        shouldWrapFunctionForExportDefault(path, options) ||",
                    "        // `export default (foo, bar)` also needs parentheses",
                    "        node.type === \"SequenceExpression\"",
                    "      );",
                    "",
                    "    case \"Decorator\":",
                    "      if (key === \"expression\") {",
                    "        if (isMemberExpression(node) && node.computed) {",
                    "          return true;",
                    "        }",
                    "",
                    "        let hasCallExpression = false;",
                    "        let hasMemberExpression = false;",
                    "        let current = node;",
                    "        while (current) {",
                    "          switch (current.type) {",
                    "            case \"MemberExpression\":",
                    "              hasMemberExpression = true;",
                    "              current = current.object;",
                    "              break;",
                    "            case \"CallExpression\":",
                    "              if (",
                    "                /** @(x().y) */ hasMemberExpression ||",
                    "                /** @(x().y()) */ hasCallExpression",
                    "              ) {",
                    "                return options.parser !== \"typescript\";",
                    "              }",
                    "              hasCallExpression = true;",
                    "              current = current.callee;",
                    "              break;",
                    "            case \"Identifier\":",
                    "              return false;",
                    "            case \"TaggedTemplateExpression\":",
                    "              // babel-parser cannot parse",
                    "              //   @foo`bar`",
                    "              return options.parser !== \"typescript\";",
                    "            default:",
                    "              return true;",
                    "          }",
                    "        }",
                    "        return true;",
                    "      }",
                    "      break;",
                    "",
                    "    case \"TypeAnnotation\":",
                    "      if (",
                    "        path.match(",
                    "          undefined,",
                    "          undefined,",
                    "          (node, key) =>",
                    "            key === \"returnType\" && node.type === \"ArrowFunctionExpression\"",
                    "        ) &&",
                    "        includesFunctionTypeInObjectType(node)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "      break;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"UpdateExpression\":",
                    "      if (parent.type === \"UnaryExpression\") {",
                    "        return (",
                    "          node.prefix &&",
                    "          ((node.operator === \"++\" && parent.operator === \"+\") ||",
                    "            (node.operator === \"--\" && parent.operator === \"-\"))",
                    "        );",
                    "      }",
                    "    // else fallthrough",
                    "    case \"UnaryExpression\":",
                    "      switch (parent.type) {",
                    "        case \"UnaryExpression\":",
                    "          return (",
                    "            node.operator === parent.operator &&",
                    "            (node.operator === \"+\" || node.operator === \"-\")",
                    "          );",
                    "",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"BinaryExpression\":",
                    "          return key === \"left\" && parent.operator === \"**\";",
                    "",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"BinaryExpression\":",
                    "      if (parent.type === \"UpdateExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      // We add parentheses to any `a in b` inside `ForStatement` initializer",
                    "      // https://github.com/prettier/prettier/issues/907#issuecomment-284304321",
                    "      if (node.operator === \"in\" && isPathInForStatementInitializer(path)) {",
                    "        return true;",
                    "      }",
                    "      if (node.operator === \"|>\" && node.extra?.parenthesized) {",
                    "        const grandParent = path.grandparent;",
                    "        if (",
                    "          grandParent.type === \"BinaryExpression\" &&",
                    "          grandParent.operator === \"|>\"",
                    "        ) {",
                    "          return true;",
                    "        }",
                    "      }",
                    "",
                    "    // fallthrough",
                    "    case \"TSTypeAssertion\":",
                    "    case \"TSAsExpression\":",
                    "    case \"TSSatisfiesExpression\":",
                    "    case \"LogicalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "          // examples:",
                    "          //   foo as unknown as Bar",
                    "          //   foo satisfies unknown satisfies Bar",
                    "          //   foo satisfies unknown as Bar",
                    "          //   foo as unknown satisfies Bar",
                    "          return !isTSTypeExpression(node);",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return isTSTypeExpression(node);",
                    "",
                    "        case \"CallExpression\":",
                    "        case \"NewExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"ClassExpression\":",
                    "        case \"ClassDeclaration\":",
                    "          return key === \"superClass\";",
                    "",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"SpreadElement\":",
                    "        case \"BindExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"UpdateExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        case \"AssignmentExpression\":",
                    "        case \"AssignmentPattern\":",
                    "          return (",
                    "            key === \"left\" &&",
                    "            (node.type === \"TSTypeAssertion\" || isTSTypeExpression(node))",
                    "          );",
                    "",
                    "        case \"LogicalExpression\":",
                    "          if (node.type === \"LogicalExpression\") {",
                    "            return parent.operator !== node.operator;",
                    "          }",
                    "        // else fallthrough",
                    "",
                    "        case \"BinaryExpression\": {",
                    "          const { operator, type } = node;",
                    "          if (!operator && type !== \"TSTypeAssertion\") {",
                    "            return true;",
                    "          }",
                    "",
                    "          const precedence = getPrecedence(operator);",
                    "          const parentOperator = parent.operator;",
                    "          const parentPrecedence = getPrecedence(parentOperator);",
                    "",
                    "          if (parentPrecedence > precedence) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (key === \"right\" && parentPrecedence === precedence) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (",
                    "            parentPrecedence === precedence &&",
                    "            !shouldFlatten(parentOperator, operator)",
                    "          ) {",
                    "            return true;",
                    "          }",
                    "",
                    "          if (parentPrecedence < precedence && operator === \"%\") {",
                    "            return parentOperator === \"+\" || parentOperator === \"-\";",
                    "          }",
                    "",
                    "          // Add parenthesis when working with bitwise operators",
                    "          // It's not strictly needed but helps with code understanding",
                    "          if (isBitwiseOperator(parentOperator)) {",
                    "            return true;",
                    "          }",
                    "",
                    "          return false;",
                    "        }",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"SequenceExpression\":",
                    "      switch (parent.type) {",
                    "        case \"ReturnStatement\":",
                    "          return false;",
                    "",
                    "        case \"ForStatement\":",
                    "          // Although parentheses wouldn't hurt around sequence",
                    "          // expressions in the head of for loops, traditional style",
                    "          // dictates that e.g. i++, j++ should not be wrapped with",
                    "          // parentheses.",
                    "          return false;",
                    "",
                    "        case \"ExpressionStatement\":",
                    "          return key !== \"expression\";",
                    "",
                    "        case \"ArrowFunctionExpression\":",
                    "          // We do need parentheses, but SequenceExpressions are handled",
                    "          // specially when printing bodies of arrow functions.",
                    "          return key !== \"body\";",
                    "",
                    "        default:",
                    "          // Otherwise err on the side of overparenthesization, adding",
                    "          // explicit exceptions above if this proves overzealous.",
                    "          return true;",
                    "      }",
                    "",
                    "    case \"YieldExpression\":",
                    "      if (parent.type === \"AwaitExpression\") {",
                    "        return true;",
                    "      }",
                    "    // else fallthrough",
                    "    case \"AwaitExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"BindExpression\":",
                    "          return true;",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return key === \"test\";",
                    "",
                    "        case \"BinaryExpression\":",
                    "          if (!node.argument && parent.operator === \"|>\") {",
                    "            return false;",
                    "          }",
                    "",
                    "          return true;",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"TSFunctionType\":",
                    "      if (",
                    "        path.match(",
                    "          (node) => node.type === \"TSFunctionType\",",
                    "          (node, key) =>",
                    "            key === \"typeAnnotation\" && node.type === \"TSTypeAnnotation\",",
                    "          (node, key) =>",
                    "            key === \"returnType\" && node.type === \"ArrowFunctionExpression\"",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSConditionalType\":",
                    "    case \"TSConstructorType\":",
                    "      if (key === \"extendsType\" && parent.type === \"TSConditionalType\") {",
                    "        if (node.type === \"TSConditionalType\") {",
                    "          return true;",
                    "        }",
                    "",
                    "        let { typeAnnotation } = node.returnType || node.typeAnnotation;",
                    "",
                    "        if (",
                    "          typeAnnotation.type === \"TSTypePredicate\" &&",
                    "          typeAnnotation.typeAnnotation",
                    "        ) {",
                    "          typeAnnotation = typeAnnotation.typeAnnotation.typeAnnotation;",
                    "        }",
                    "",
                    "        if (",
                    "          typeAnnotation.type === \"TSInferType\" &&",
                    "          typeAnnotation.typeParameter.constraint",
                    "        ) {",
                    "          return true;",
                    "        }",
                    "      }",
                    "",
                    "      if (key === \"checkType\" && parent.type === \"TSConditionalType\") {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSUnionType\":",
                    "    case \"TSIntersectionType\":",
                    "      if (",
                    "        (parent.type === \"TSUnionType\" ||",
                    "          parent.type === \"TSIntersectionType\") &&",
                    "        parent.types.length > 1 &&",
                    "        (!node.types || node.types.length > 1)",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSInferType\":",
                    "      if (node.type === \"TSInferType\" && parent.type === \"TSRestType\") {",
                    "        return false;",
                    "      }",
                    "    // fallthrough",
                    "    case \"TSTypeOperator\":",
                    "      return (",
                    "        parent.type === \"TSArrayType\" ||",
                    "        parent.type === \"TSOptionalType\" ||",
                    "        parent.type === \"TSRestType\" ||",
                    "        (key === \"objectType\" && parent.type === \"TSIndexedAccessType\") ||",
                    "        parent.type === \"TSTypeOperator\" ||",
                    "        (parent.type === \"TSTypeAnnotation\" &&",
                    "          path.grandparent.type.startsWith(\"TSJSDoc\"))",
                    "      );",
                    "    case \"TSTypeQuery\":",
                    "      return (",
                    "        (key === \"objectType\" && parent.type === \"TSIndexedAccessType\") ||",
                    "        (key === \"elementType\" && parent.type === \"TSArrayType\")",
                    "      );",
                    "    // Same as `TSTypeQuery`, but for Flow syntax",
                    "    case \"TypeofTypeAnnotation\":",
                    "      return (",
                    "        (key === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\")) ||",
                    "        (key === \"elementType\" && parent.type === \"ArrayTypeAnnotation\")",
                    "      );",
                    "    case \"ArrayTypeAnnotation\":",
                    "      return parent.type === \"NullableTypeAnnotation\";",
                    "",
                    "    case \"IntersectionTypeAnnotation\":",
                    "    case \"UnionTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        parent.type === \"NullableTypeAnnotation\" ||",
                    "        parent.type === \"IntersectionTypeAnnotation\" ||",
                    "        parent.type === \"UnionTypeAnnotation\" ||",
                    "        (key === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\"))",
                    "      );",
                    "    case \"InferTypeAnnotation\":",
                    "    case \"NullableTypeAnnotation\":",
                    "      return (",
                    "        parent.type === \"ArrayTypeAnnotation\" ||",
                    "        (key === \"objectType\" &&",
                    "          (parent.type === \"IndexedAccessType\" ||",
                    "            parent.type === \"OptionalIndexedAccessType\"))",
                    "      );",
                    "",
                    "    case \"FunctionTypeAnnotation\": {",
                    "      if (",
                    "        path.match(",
                    "          undefined,",
                    "          (node, key) =>",
                    "            key === \"typeAnnotation\" && node.type === \"TypeAnnotation\",",
                    "          (node, key) =>",
                    "            key === \"returnType\" && node.type === \"ArrowFunctionExpression\"",
                    "        )",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "",
                    "      const ancestor =",
                    "        parent.type === \"NullableTypeAnnotation\" ? path.grandparent : parent;",
                    "",
                    "      return (",
                    "        ancestor.type === \"UnionTypeAnnotation\" ||",
                    "        ancestor.type === \"IntersectionTypeAnnotation\" ||",
                    "        ancestor.type === \"ArrayTypeAnnotation\" ||",
                    "        (key === \"objectType\" &&",
                    "          (ancestor.type === \"IndexedAccessType\" ||",
                    "            ancestor.type === \"OptionalIndexedAccessType\")) ||",
                    "        (key === \"checkType\" && parent.type === \"ConditionalTypeAnnotation\") ||",
                    "        (key === \"extendsType\" &&",
                    "          parent.type === \"ConditionalTypeAnnotation\" &&",
                    "          node.returnType.type === \"InferTypeAnnotation\" &&",
                    "          node.returnType.typeParameter.bound) ||",
                    "        // We should check ancestor's parent to know whether the parentheses",
                    "        // are really needed, but since ??T doesn't make sense this check",
                    "        // will almost never be true.",
                    "        ancestor.type === \"NullableTypeAnnotation\" ||",
                    "        // See #5283",
                    "        (parent.type === \"FunctionTypeParam\" &&",
                    "          parent.name === null &&",
                    "          getFunctionParameters(node).some(",
                    "            (param) => param.typeAnnotation?.type === \"NullableTypeAnnotation\"",
                    "          ))",
                    "      );",
                    "    }",
                    "",
                    "    case \"ConditionalTypeAnnotation\":",
                    "      if (",
                    "        key === \"extendsType\" &&",
                    "        parent.type === \"ConditionalTypeAnnotation\" &&",
                    "        node.type === \"ConditionalTypeAnnotation\"",
                    "      ) {",
                    "        return true;",
                    "      }",
                    "",
                    "      if (key === \"checkType\" && parent.type === \"ConditionalTypeAnnotation\") {",
                    "        return true;",
                    "      }",
                    "",
                    "    // fallthrough",
                    "    case \"OptionalIndexedAccessType\":",
                    "      return key === \"objectType\" && parent.type === \"IndexedAccessType\";",
                    "",
                    "    case \"StringLiteral\":",
                    "    case \"NumericLiteral\":",
                    "    case \"Literal\":",
                    "      if (",
                    "        typeof node.value === \"string\" &&",
                    "        parent.type === \"ExpressionStatement\" &&",
                    "        !parent.directive",
                    "      ) {",
                    "        // To avoid becoming a directive",
                    "        const grandParent = path.grandparent;",
                    "",
                    "        return (",
                    "          grandParent.type === \"Program\" ||",
                    "          grandParent.type === \"BlockStatement\"",
                    "        );",
                    "      }",
                    "",
                    "      return (",
                    "        key === \"object\" &&",
                    "        parent.type === \"MemberExpression\" &&",
                    "        typeof node.value === \"number\"",
                    "      );",
                    "",
                    "    case \"AssignmentExpression\": {",
                    "      const grandParent = path.grandparent;",
                    "",
                    "      if (key === \"body\" && parent.type === \"ArrowFunctionExpression\") {",
                    "        return true;",
                    "      }",
                    "",
                    "      if (",
                    "        key === \"key\" &&",
                    "        (parent.type === \"ClassProperty\" ||",
                    "          parent.type === \"PropertyDefinition\") &&",
                    "        parent.computed",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        (key === \"init\" || key === \"update\") &&",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"ExpressionStatement\") {",
                    "        return node.left.type === \"ObjectPattern\";",
                    "      }",
                    "",
                    "      if (key === \"key\" && parent.type === \"TSPropertySignature\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"AssignmentExpression\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        parent.type === \"SequenceExpression\" &&",
                    "        grandParent.type === \"ForStatement\" &&",
                    "        (grandParent.init === parent || grandParent.update === parent)",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (",
                    "        key === \"value\" &&",
                    "        parent.type === \"Property\" &&",
                    "        grandParent.type === \"ObjectPattern\" &&",
                    "        grandParent.properties.includes(parent)",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "",
                    "      if (parent.type === \"NGChainedExpression\") {",
                    "        return false;",
                    "      }",
                    "",
                    "      return true;",
                    "    }",
                    "    case \"ConditionalExpression\":",
                    "      switch (parent.type) {",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"SpreadElement\":",
                    "        case \"BinaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"NGPipeExpression\":",
                    "        case \"ExportDefaultDeclaration\":",
                    "        case \"AwaitExpression\":",
                    "        case \"JSXSpreadAttribute\":",
                    "        case \"TSTypeAssertion\":",
                    "        case \"TypeCastExpression\":",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "          return true;",
                    "",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return key === \"test\";",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"FunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.",
                    "          // Is necessary if it is `expression` of `ExpressionStatement`.",
                    "          return key === \"callee\";",
                    "        case \"TaggedTemplateExpression\":",
                    "          return true; // This is basically a kind of IIFE.",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ArrowFunctionExpression\":",
                    "      switch (parent.type) {",
                    "        case \"BinaryExpression\":",
                    "          return parent.operator !== \"|>\" || node.extra?.parenthesized;",
                    "        case \"NewExpression\":",
                    "        case \"CallExpression\":",
                    "        case \"OptionalCallExpression\":",
                    "          return key === \"callee\";",
                    "",
                    "        case \"MemberExpression\":",
                    "        case \"OptionalMemberExpression\":",
                    "          return key === \"object\";",
                    "",
                    "        case \"TSAsExpression\":",
                    "        case \"TSSatisfiesExpression\":",
                    "        case \"TSNonNullExpression\":",
                    "        case \"BindExpression\":",
                    "        case \"TaggedTemplateExpression\":",
                    "        case \"UnaryExpression\":",
                    "        case \"LogicalExpression\":",
                    "        case \"AwaitExpression\":",
                    "        case \"TSTypeAssertion\":",
                    "          return true;",
                    "",
                    "        case \"ConditionalExpression\":",
                    "          return key === \"test\";",
                    "",
                    "        default:",
                    "          return false;",
                    "      }",
                    "",
                    "    case \"ClassExpression\":",
                    "      switch (parent.type) {",
                    "        case \"NewExpression\":",
                    "          return key === \"callee\";",
                    "        default:",
                    "          return false;",
                    "      }",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"OptionalCallExpression\":",
                    "    case \"CallExpression\":",
                    "    case \"MemberExpression\":",
                    "      if (shouldAddParenthesesToChainElement(path)) {",
                    "        return true;",
                    "      }",
                    "",
                    "    // fallthrough",
                    "    case \"TaggedTemplateExpression\":",
                    "    case \"TSNonNullExpression\":",
                    "      if (",
                    "        key === \"callee\" &&",
                    "        (parent.type === \"BindExpression\" || parent.type === \"NewExpression\")",
                    "      ) {",
                    "        let object = node;",
                    "        while (object) {",
                    "          switch (object.type) {",
                    "            case \"CallExpression\":",
                    "            case \"OptionalCallExpression\":",
                    "              return true;",
                    "            case \"MemberExpression\":",
                    "            case \"OptionalMemberExpression\":",
                    "            case \"BindExpression\":",
                    "              object = object.object;",
                    "              break;",
                    "            // tagged templates are basically member expressions from a grammar perspective",
                    "            // see https://tc39.github.io/ecma262/#prod-MemberExpression",
                    "            case \"TaggedTemplateExpression\":",
                    "              object = object.tag;",
                    "              break;",
                    "            case \"TSNonNullExpression\":",
                    "              object = object.expression;",
                    "              break;",
                    "            default:",
                    "              return false;",
                    "          }",
                    "        }",
                    "      }",
                    "      return false;",
                    "",
                    "    case \"BindExpression\":",
                    "      return (",
                    "        (key === \"callee\" &&",
                    "          (parent.type === \"BindExpression\" ||",
                    "            parent.type === \"NewExpression\")) ||",
                    "        (key === \"object\" && isMemberExpression(parent))",
                    "      );",
                    "    case \"NGPipeExpression\":",
                    "      if (",
                    "        parent.type === \"NGRoot\" ||",
                    "        parent.type === \"NGMicrosyntaxExpression\" ||",
                    "        (parent.type === \"ObjectProperty\" &&",
                    "          // Preserve parens for compatibility with AngularJS expressions",
                    "          !node.extra?.parenthesized) ||",
                    "        isArrayOrTupleExpression(parent) ||",
                    "        (key === \"arguments\" && isCallExpression(parent)) ||",
                    "        (key === \"right\" && parent.type === \"NGPipeExpression\") ||",
                    "        (key === \"property\" && parent.type === \"MemberExpression\") ||",
                    "        parent.type === \"AssignmentExpression\"",
                    "      ) {",
                    "        return false;",
                    "      }",
                    "      return true;",
                    "    case \"JSXFragment\":",
                    "    case \"JSXElement\":",
                    "      return (",
                    "        key === \"callee\" ||",
                    "        (key === \"left\" &&",
                    "          parent.type === \"BinaryExpression\" &&",
                    "          parent.operator === \"<\") ||",
                    "        (!isArrayOrTupleExpression(parent) &&",
                    "          parent.type !== \"ArrowFunctionExpression\" &&",
                    "          parent.type !== \"AssignmentExpression\" &&",
                    "          parent.type !== \"AssignmentPattern\" &&",
                    "          parent.type !== \"BinaryExpression\" &&",
                    "          parent.type !== \"NewExpression\" &&",
                    "          parent.type !== \"ConditionalExpression\" &&",
                    "          parent.type !== \"ExpressionStatement\" &&",
                    "          parent.type !== \"JsExpressionRoot\" &&",
                    "          parent.type !== \"JSXAttribute\" &&",
                    "          parent.type !== \"JSXElement\" &&",
                    "          parent.type !== \"JSXExpressionContainer\" &&",
                    "          parent.type !== \"JSXFragment\" &&",
                    "          parent.type !== \"LogicalExpression\" &&",
                    "          !isCallExpression(parent) &&",
                    "          !isObjectProperty(parent) &&",
                    "          parent.type !== \"ReturnStatement\" &&",
                    "          parent.type !== \"ThrowStatement\" &&",
                    "          parent.type !== \"TypeCastExpression\" &&",
                    "          parent.type !== \"VariableDeclarator\" &&",
                    "          parent.type !== \"YieldExpression\")",
                    "      );",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "const isStatement = createTypeCheckFunction([",
                    "  \"BlockStatement\",",
                    "  \"BreakStatement\",",
                    "  \"ClassBody\",",
                    "  \"ClassDeclaration\",",
                    "  \"ClassMethod\",",
                    "  \"ClassProperty\",",
                    "  \"PropertyDefinition\",",
                    "  \"ClassPrivateProperty\",",
                    "  \"ContinueStatement\",",
                    "  \"DebuggerStatement\",",
                    "  \"DeclareClass\",",
                    "  \"DeclareExportAllDeclaration\",",
                    "  \"DeclareExportDeclaration\",",
                    "  \"DeclareFunction\",",
                    "  \"DeclareInterface\",",
                    "  \"DeclareModule\",",
                    "  \"DeclareModuleExports\",",
                    "  \"DeclareVariable\",",
                    "  \"DeclareEnum\",",
                    "  \"DoWhileStatement\",",
                    "  \"EnumDeclaration\",",
                    "  \"ExportAllDeclaration\",",
                    "  \"ExportDefaultDeclaration\",",
                    "  \"ExportNamedDeclaration\",",
                    "  \"ExpressionStatement\",",
                    "  \"ForInStatement\",",
                    "  \"ForOfStatement\",",
                    "  \"ForStatement\",",
                    "  \"FunctionDeclaration\",",
                    "  \"IfStatement\",",
                    "  \"ImportDeclaration\",",
                    "  \"InterfaceDeclaration\",",
                    "  \"LabeledStatement\",",
                    "  \"MethodDefinition\",",
                    "  \"ReturnStatement\",",
                    "  \"SwitchStatement\",",
                    "  \"ThrowStatement\",",
                    "  \"TryStatement\",",
                    "  \"TSDeclareFunction\",",
                    "  \"TSEnumDeclaration\",",
                    "  \"TSImportEqualsDeclaration\",",
                    "  \"TSInterfaceDeclaration\",",
                    "  \"TSModuleDeclaration\",",
                    "  \"TSNamespaceExportDeclaration\",",
                    "  \"TypeAlias\",",
                    "  \"VariableDeclaration\",",
                    "  \"WhileStatement\",",
                    "  \"WithStatement\",",
                    "]);",
                    "",
                    "function isPathInForStatementInitializer(path) {",
                    "  let i = 0;",
                    "  let { node } = path;",
                    "  while (node) {",
                    "    const parent = path.getParentNode(i++);",
                    "    if (parent?.type === \"ForStatement\" && parent.init === node) {",
                    "      return true;",
                    "    }",
                    "    node = parent;",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function includesFunctionTypeInObjectType(node) {",
                    "  return hasNode(",
                    "    node,",
                    "    (node) =>",
                    "      node.type === \"ObjectTypeAnnotation\" &&",
                    "      hasNode(node, (node) => node.type === \"FunctionTypeAnnotation\")",
                    "  );",
                    "}",
                    "",
                    "function endsWithRightBracket(node) {",
                    "  return isObjectOrRecordExpression(node);",
                    "}",
                    "",
                    "function isFollowedByRightBracket(path) {",
                    "  const { parent, key } = path;",
                    "  switch (parent.type) {",
                    "    case \"NGPipeExpression\":",
                    "      if (key === \"arguments\" && path.isLast) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ObjectProperty\":",
                    "      if (key === \"value\") {",
                    "        return path.callParent(() => path.key === \"properties\" && path.isLast);",
                    "      }",
                    "      break;",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "      if (key === \"right\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"ConditionalExpression\":",
                    "      if (key === \"alternate\") {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "    case \"UnaryExpression\":",
                    "      if (parent.prefix) {",
                    "        return path.callParent(isFollowedByRightBracket);",
                    "      }",
                    "      break;",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function shouldWrapFunctionForExportDefault(path, options) {",
                    "  const { node, parent } = path;",
                    "",
                    "  if (node.type === \"FunctionExpression\" || node.type === \"ClassExpression\") {",
                    "    return (",
                    "      parent.type === \"ExportDefaultDeclaration\" ||",
                    "      // in some cases the function is already wrapped",
                    "      // (e.g. `export default (function() {})();`)",
                    "      // in this case we don't need to add extra parens",
                    "      !needsParens(path, options)",
                    "    );",
                    "  }",
                    "",
                    "  if (",
                    "    !hasNakedLeftSide(node) ||",
                    "    (parent.type !== \"ExportDefaultDeclaration\" && needsParens(path, options))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return path.call(",
                    "    () => shouldWrapFunctionForExportDefault(path, options),",
                    "    ...getLeftSidePathName(node)",
                    "  );",
                    "}",
                    "",
                    "/*",
                    "Matches following cases:",
                    "",
                    "```js",
                    "(a?.b).c;",
                    "(a?.()).b;",
                    "(a?.b!).c;",
                    "(a?.()!).b;",
                    "(a?.b)!.c;",
                    "(a?.())!.b;",
                    "",
                    "(a?.b)();",
                    "(a?.())();",
                    "",
                    "new (a?.b)();",
                    "new (a?.())();",
                    "```",
                    "*/",
                    "function shouldAddParenthesesToChainElement(path) {",
                    "  // Babel, this was implemented before #13735, can use `path.match` as estree does",
                    "  const { node, parent, grandparent, key } = path;",
                    "  if (",
                    "    (node.type === \"OptionalMemberExpression\" ||",
                    "      node.type === \"OptionalCallExpression\") &&",
                    "    ((key === \"object\" && parent.type === \"MemberExpression\") ||",
                    "      (key === \"callee\" &&",
                    "        (parent.type === \"CallExpression\" ||",
                    "          parent.type === \"NewExpression\")) ||",
                    "      (parent.type === \"TSNonNullExpression\" &&",
                    "        grandparent.type === \"MemberExpression\" &&",
                    "        grandparent.object === parent))",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // ESTree, same logic as babel",
                    "  if (",
                    "    path.match(",
                    "      () => node.type === \"CallExpression\" || node.type === \"MemberExpression\",",
                    "      (node, name) => name === \"expression\" && node.type === \"ChainExpression\"",
                    "    ) &&",
                    "    (path.match(",
                    "      undefined,",
                    "      undefined,",
                    "      (node, name) =>",
                    "        (name === \"callee\" &&",
                    "          ((node.type === \"CallExpression\" && !node.optional) ||",
                    "            node.type === \"NewExpression\")) ||",
                    "        (name === \"object\" &&",
                    "          node.type === \"MemberExpression\" &&",
                    "          !node.optional)",
                    "    ) ||",
                    "      path.match(",
                    "        undefined,",
                    "        undefined,",
                    "        (node, name) =>",
                    "          name === \"expression\" && node.type === \"TSNonNullExpression\",",
                    "        (node, name) => name === \"object\" && node.type === \"MemberExpression\"",
                    "      ))",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Babel treat `(a?.b!).c` and `(a?.b)!.c` the same, https://github.com/babel/babel/discussions/15077",
                    "  // Use this to align with babel",
                    "  if (",
                    "    path.match(",
                    "      () => node.type === \"CallExpression\" || node.type === \"MemberExpression\",",
                    "      (node, name) =>",
                    "        name === \"expression\" && node.type === \"TSNonNullExpression\",",
                    "      (node, name) => name === \"expression\" && node.type === \"ChainExpression\",",
                    "      (node, name) => name === \"object\" && node.type === \"MemberExpression\"",
                    "    )",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // This function only handle cases above",
                    "  return false;",
                    "}",
                    "",
                    "export default needsParens;"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "const CATEGORY_JAVASCRIPT = \"JavaScript\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  arrowParens: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"always\",",
                    "    description: \"Include parentheses around a sole arrow function parameter.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"always\",",
                    "        description: \"Always include parens. Example: `(x) => x`\",",
                    "      },",
                    "      {",
                    "        value: \"avoid\",",
                    "        description: \"Omit parens when possible. Example: `x => x`\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  bracketSameLine: commonOptions.bracketSameLine,",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  jsxBracketSameLine: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    description: \"Put > on the last line instead of at a new line.\",",
                    "    deprecated: \"2.4.0\",",
                    "  },",
                    "  semi: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: true,",
                    "    description: \"Print semicolons.\",",
                    "    oppositeDescription:",
                    "      \"Do not print semicolons, except at the beginning of lines which may need them.\",",
                    "  },",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  jsxSingleQuote: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Use single quotes in JSX.\",",
                    "  },",
                    "  quoteProps: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"as-needed\",",
                    "    description: \"Change when properties in objects are quoted.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"as-needed\",",
                    "        description: \"Only add quotes around object properties where required.\",",
                    "      },",
                    "      {",
                    "        value: \"consistent\",",
                    "        description:",
                    "          \"If at least one property in an object requires quotes, quote all properties.\",",
                    "      },",
                    "      {",
                    "        value: \"preserve\",",
                    "        description: \"Respect the input use of quotes in object properties.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "  trailingComma: {",
                    "    category: CATEGORY_JAVASCRIPT,",
                    "    type: \"choice\",",
                    "    default: \"all\",",
                    "    description: \"Print trailing commas wherever possible when multi-line.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"all\",",
                    "        description:",
                    "          \"Trailing commas wherever possible (including function arguments).\",",
                    "      },",
                    "      {",
                    "        value: \"es5\",",
                    "        description:",
                    "          \"Trailing commas where valid in ES5 (objects, arrays, etc.)\",",
                    "      },",
                    "      { value: \"none\", description: \"No trailing commas.\" },",
                    "    ],",
                    "  },",
                    "  singleAttributePerLine: commonOptions.singleAttributePerLine,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { parseWithComments, strip, extract, print } from \"jest-docblock\";",
                    "import { normalizeEndOfLine } from \"../common/end-of-line.js\";",
                    "import getShebang from \"./utils/get-shebang.js\";",
                    "",
                    "function parseDocBlock(text) {",
                    "  const shebang = getShebang(text);",
                    "  if (shebang) {",
                    "    text = text.slice(shebang.length + 1);",
                    "  }",
                    "",
                    "  const docBlock = extract(text);",
                    "  const { pragmas, comments } = parseWithComments(docBlock);",
                    "",
                    "  return { shebang, text, pragmas, comments };",
                    "}",
                    "",
                    "function hasPragma(text) {",
                    "  const { pragmas } = parseDocBlock(text);",
                    "  return Object.hasOwn(pragmas, \"prettier\") || Object.hasOwn(pragmas, \"format\");",
                    "}",
                    "",
                    "function insertPragma(originalText) {",
                    "  const { shebang, text, pragmas, comments } = parseDocBlock(originalText);",
                    "  const strippedText = strip(text);",
                    "",
                    "  let docBlock = print({",
                    "    pragmas: {",
                    "      format: \"\",",
                    "      ...pragmas,",
                    "    },",
                    "    comments: comments.trimStart(),",
                    "  });",
                    "",
                    "  // normalise newlines (mitigate use of os.EOL by jest-docblock)",
                    "  // Only needed in development version on Windows,",
                    "  // bundler will hack `jest-docblock` enforce it to use `\\n` in production",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    docBlock = normalizeEndOfLine(docBlock);",
                    "  }",
                    "",
                    "  return (",
                    "    (shebang ? `${shebang}\\n` : \"\") +",
                    "    docBlock +",
                    "    (strippedText.startsWith(\"\\n\") ? \"\\n\" : \"\\n\\n\") +",
                    "    strippedText",
                    "  );",
                    "}",
                    "",
                    "export { hasPragma, insertPragma };"
                ]
            },
            "printer-estree.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// TODO(azz): anything that imports from main shouldn't be in a `language-*` dir.",
                    "import { printDanglingComments } from \"../main/comments/print.js\";",
                    "import printIgnored from \"../main/print-ignored.js\";",
                    "import hasNewline from \"../utils/has-newline.js\";",
                    "import {",
                    "  join,",
                    "  line,",
                    "  hardline,",
                    "  softline,",
                    "  group,",
                    "  indent,",
                    "} from \"../document/builders.js\";",
                    "import { replaceEndOfLine, inheritLabel } from \"../document/utils.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "",
                    "import pathNeedsParens from \"./needs-parens.js\";",
                    "import {",
                    "  hasComment,",
                    "  CommentCheckFlags,",
                    "  isNextLineEmpty,",
                    "  needsHardlineAfterDanglingComment,",
                    "  isCallExpression,",
                    "  isMemberExpression,",
                    "  isArrayOrTupleExpression,",
                    "  isObjectOrRecordExpression,",
                    "  startsWithNoLookaheadToken,",
                    "  createTypeCheckFunction,",
                    "} from \"./utils/index.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import isBlockComment from \"./utils/is-block-comment.js\";",
                    "import isIgnored from \"./utils/is-ignored.js\";",
                    "",
                    "import { printHtmlBinding } from \"./print/html-binding.js\";",
                    "import { printAngular } from \"./print/angular.js\";",
                    "import { printJsx } from \"./print/jsx.js\";",
                    "import { printFlow } from \"./print/flow.js\";",
                    "import { printTypescript } from \"./print/typescript.js\";",
                    "import {",
                    "  printOptionalToken,",
                    "  printBindExpressionCallee,",
                    "  adjustClause,",
                    "  printRestSpread,",
                    "  printDefiniteToken,",
                    "  printDeclareToken,",
                    "} from \"./print/misc.js\";",
                    "import {",
                    "  printImportDeclaration,",
                    "  printExportDeclaration,",
                    "  printModuleSpecifier,",
                    "} from \"./print/module.js\";",
                    "import { printTernary } from \"./print/ternary.js\";",
                    "import {",
                    "  printTaggedTemplateLiteral,",
                    "  printTemplateLiteral,",
                    "} from \"./print/template-literal.js\";",
                    "import { printArray } from \"./print/array.js\";",
                    "import { printObject } from \"./print/object.js\";",
                    "import {",
                    "  printClass,",
                    "  printClassMethod,",
                    "  printClassProperty,",
                    "  printClassBody,",
                    "} from \"./print/class.js\";",
                    "import { printProperty } from \"./print/property.js\";",
                    "import {",
                    "  printFunction,",
                    "  printArrowFunction,",
                    "  printMethod,",
                    "  printReturnStatement,",
                    "  printThrowStatement,",
                    "} from \"./print/function.js\";",
                    "import { printCallExpression } from \"./print/call-expression.js\";",
                    "import {",
                    "  printVariableDeclarator,",
                    "  printAssignmentExpression,",
                    "} from \"./print/assignment.js\";",
                    "import { printBinaryishExpression } from \"./print/binaryish.js\";",
                    "import { printStatementSequence } from \"./print/statement.js\";",
                    "import { printMemberExpression } from \"./print/member.js\";",
                    "import { printBlock, printBlockBody } from \"./print/block.js\";",
                    "import { printLiteral } from \"./print/literal.js\";",
                    "import { printDecorators } from \"./print/decorators.js\";",
                    "import { printTypeAnnotationProperty } from \"./print/type-annotation.js\";",
                    "import { shouldPrintLeadingSemicolon } from \"./print/semicolon.js\";",
                    "import { printExpressionStatement } from \"./print/expression-statement.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"../common/ast-path.js\").default} AstPath",
                    " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                    " */",
                    "",
                    "// Their decorators are handled themselves, and they don't need parentheses or leading semicolons",
                    "const shouldPrintDirectly = createTypeCheckFunction([",
                    "  \"ClassMethod\",",
                    "  \"ClassPrivateMethod\",",
                    "  \"ClassProperty\",",
                    "  \"ClassAccessorProperty\",",
                    "  \"AccessorProperty\",",
                    "  \"TSAbstractAccessorProperty\",",
                    "  \"PropertyDefinition\",",
                    "  \"TSAbstractPropertyDefinition\",",
                    "  \"ClassPrivateProperty\",",
                    "  \"MethodDefinition\",",
                    "  \"TSAbstractMethodDefinition\",",
                    "  \"TSDeclareMethod\",",
                    "]);",
                    "",
                    "/**",
                    " * @param {AstPath} path",
                    " * @param {*} options",
                    " * @param {*} print",
                    " * @param {*} [args]",
                    " * @returns {Doc}",
                    " */",
                    "function genericPrint(path, options, print, args) {",
                    "  const doc = printPathNoParens(path, options, print, args);",
                    "  if (!doc) {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  const { node } = path;",
                    "  if (shouldPrintDirectly(node)) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  const hasDecorators = isNonEmptyArray(node.decorators);",
                    "  const decoratorsDoc = printDecorators(path, options, print);",
                    "  const isClassExpression = node.type === \"ClassExpression\";",
                    "  // Nodes (except `ClassExpression`) with decorators can't have parentheses and don't need leading semicolons",
                    "  if (hasDecorators && !isClassExpression) {",
                    "    return inheritLabel(doc, (doc) => group([decoratorsDoc, doc]));",
                    "  }",
                    "",
                    "  const needsParens = pathNeedsParens(path, options);",
                    "  const needsSemi = shouldPrintLeadingSemicolon(path, options);",
                    "",
                    "  if (!decoratorsDoc && !needsParens && !needsSemi) {",
                    "    return doc;",
                    "  }",
                    "",
                    "  return inheritLabel(doc, (doc) => [",
                    "    needsSemi ? \";\" : \"\",",
                    "    needsParens ? \"(\" : \"\",",
                    "    needsParens && isClassExpression && hasDecorators",
                    "      ? [indent([line, decoratorsDoc, doc]), line]",
                    "      : [decoratorsDoc, doc],",
                    "    needsParens ? \")\" : \"\",",
                    "  ]);",
                    "}",
                    "",
                    "/**",
                    " * @param {AstPath} path",
                    " * @param {*} options",
                    " * @param {*} print",
                    " * @param {*} [args]",
                    " * @returns {Doc}",
                    " */",
                    "function printPathNoParens(path, options, print, args) {",
                    "  if (isIgnored(path)) {",
                    "    return printIgnored(path, options);",
                    "  }",
                    "",
                    "  for (const printer of [",
                    "    printLiteral,",
                    "    printHtmlBinding,",
                    "    printAngular,",
                    "    printJsx,",
                    "    printFlow,",
                    "    printTypescript,",
                    "  ]) {",
                    "    const printed = printer(path, options, print);",
                    "    if (printed !== undefined) {",
                    "      return printed;",
                    "    }",
                    "  }",
                    "",
                    "  const { node } = path;",
                    "  const semi = options.semi ? \";\" : \"\";",
                    "  /** @type{Doc[]} */",
                    "  let parts = [];",
                    "",
                    "  switch (node.type) {",
                    "    case \"JsExpressionRoot\":",
                    "      return print(\"node\");",
                    "    case \"JsonRoot\":",
                    "      return [print(\"node\"), hardline];",
                    "    case \"File\":",
                    "      return print(\"program\");",
                    "",
                    "    case \"Program\":",
                    "      return printBlockBody(path, options, print);",
                    "    // Babel extension.",
                    "    case \"EmptyStatement\":",
                    "      return \"\";",
                    "    case \"ExpressionStatement\":",
                    "      return printExpressionStatement(path, options, print);",
                    "",
                    "    case \"ChainExpression\":",
                    "      return print(\"expression\");",
                    "",
                    "    // Babel non-standard node. Used for Closure-style type casts. See postprocess.js.",
                    "    case \"ParenthesizedExpression\": {",
                    "      const shouldHug =",
                    "        !hasComment(node.expression) &&",
                    "        (isObjectOrRecordExpression(node.expression) ||",
                    "          isArrayOrTupleExpression(node.expression));",
                    "      if (shouldHug) {",
                    "        return [\"(\", print(\"expression\"), \")\"];",
                    "      }",
                    "      return group([",
                    "        \"(\",",
                    "        indent([softline, print(\"expression\")]),",
                    "        softline,",
                    "        \")\",",
                    "      ]);",
                    "    }",
                    "    case \"AssignmentExpression\":",
                    "      return printAssignmentExpression(path, options, print);",
                    "    case \"VariableDeclarator\":",
                    "      return printVariableDeclarator(path, options, print);",
                    "    case \"BinaryExpression\":",
                    "    case \"LogicalExpression\":",
                    "      return printBinaryishExpression(path, options, print);",
                    "    case \"AssignmentPattern\":",
                    "      return [print(\"left\"), \" = \", print(\"right\")];",
                    "    case \"OptionalMemberExpression\":",
                    "    case \"MemberExpression\":",
                    "      return printMemberExpression(path, options, print);",
                    "",
                    "    case \"MetaProperty\":",
                    "      return [print(\"meta\"), \".\", print(\"property\")];",
                    "    case \"BindExpression\":",
                    "      if (node.object) {",
                    "        parts.push(print(\"object\"));",
                    "      }",
                    "",
                    "      parts.push(",
                    "        group(",
                    "          indent([softline, printBindExpressionCallee(path, options, print)])",
                    "        )",
                    "      );",
                    "",
                    "      return parts;",
                    "    case \"Identifier\":",
                    "      return [",
                    "        node.name,",
                    "        printOptionalToken(path),",
                    "        printDefiniteToken(path),",
                    "        printTypeAnnotationProperty(path, print),",
                    "      ];",
                    "",
                    "    case \"V8IntrinsicIdentifier\":",
                    "      return [\"%\", node.name];",
                    "    case \"SpreadElement\":",
                    "    case \"SpreadElementPattern\":",
                    "    case \"SpreadPropertyPattern\":",
                    "    case \"RestElement\":",
                    "      return printRestSpread(path, print);",
                    "    case \"FunctionDeclaration\":",
                    "    case \"FunctionExpression\":",
                    "      return printFunction(path, print, options, args);",
                    "    case \"ArrowFunctionExpression\":",
                    "      return printArrowFunction(path, options, print, args);",
                    "    case \"YieldExpression\":",
                    "      parts.push(\"yield\");",
                    "",
                    "      if (node.delegate) {",
                    "        parts.push(\"*\");",
                    "      }",
                    "      if (node.argument) {",
                    "        parts.push(\" \", print(\"argument\"));",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"AwaitExpression\":",
                    "      parts.push(\"await\");",
                    "      if (node.argument) {",
                    "        parts.push(\" \", print(\"argument\"));",
                    "        const { parent } = path;",
                    "        if (",
                    "          (isCallExpression(parent) && parent.callee === node) ||",
                    "          (isMemberExpression(parent) && parent.object === node)",
                    "        ) {",
                    "          parts = [indent([softline, ...parts]), softline];",
                    "          // avoid printing `await (await` on one line",
                    "          const parentAwaitOrBlock = path.findAncestor(",
                    "            (node) =>",
                    "              node.type === \"AwaitExpression\" || node.type === \"BlockStatement\"",
                    "          );",
                    "          if (",
                    "            parentAwaitOrBlock?.type !== \"AwaitExpression\" ||",
                    "            !startsWithNoLookaheadToken(",
                    "              parentAwaitOrBlock.argument,",
                    "              (leftmostNode) => leftmostNode === node",
                    "            )",
                    "          ) {",
                    "            return group(parts);",
                    "          }",
                    "        }",
                    "      }",
                    "      return parts;",
                    "",
                    "    case \"ExportDefaultDeclaration\":",
                    "    case \"ExportNamedDeclaration\":",
                    "    case \"ExportAllDeclaration\":",
                    "      return printExportDeclaration(path, options, print);",
                    "    case \"ImportDeclaration\":",
                    "      return printImportDeclaration(path, options, print);",
                    "    case \"ImportSpecifier\":",
                    "    case \"ExportSpecifier\":",
                    "    case \"ImportNamespaceSpecifier\":",
                    "    case \"ExportNamespaceSpecifier\":",
                    "    case \"ImportDefaultSpecifier\":",
                    "    case \"ExportDefaultSpecifier\":",
                    "      return printModuleSpecifier(path, options, print);",
                    "    case \"ImportAttribute\":",
                    "      return [print(\"key\"), \": \", print(\"value\")];",
                    "    case \"Import\":",
                    "      return \"import\";",
                    "    case \"BlockStatement\":",
                    "    case \"StaticBlock\":",
                    "      return printBlock(path, options, print);",
                    "    case \"ClassBody\":",
                    "      return printClassBody(path, options, print);",
                    "    case \"ThrowStatement\":",
                    "      return printThrowStatement(path, options, print);",
                    "    case \"ReturnStatement\":",
                    "      return printReturnStatement(path, options, print);",
                    "    case \"NewExpression\":",
                    "    case \"ImportExpression\":",
                    "    case \"OptionalCallExpression\":",
                    "    case \"CallExpression\":",
                    "      return printCallExpression(path, options, print);",
                    "",
                    "    case \"ObjectExpression\":",
                    "    case \"ObjectPattern\":",
                    "    case \"RecordExpression\":",
                    "      return printObject(path, options, print);",
                    "    // Babel 6",
                    "    case \"ObjectProperty\": // Non-standard AST node type.",
                    "    case \"Property\":",
                    "      if (node.method || node.kind === \"get\" || node.kind === \"set\") {",
                    "        return printMethod(path, options, print);",
                    "      }",
                    "      return printProperty(path, options, print);",
                    "    case \"ObjectMethod\":",
                    "      return printMethod(path, options, print);",
                    "    case \"Decorator\":",
                    "      return [\"@\", print(\"expression\")];",
                    "    case \"ArrayExpression\":",
                    "    case \"ArrayPattern\":",
                    "    case \"TupleExpression\":",
                    "      return printArray(path, options, print);",
                    "    case \"SequenceExpression\": {",
                    "      const { parent } = path;",
                    "      if (",
                    "        parent.type === \"ExpressionStatement\" ||",
                    "        parent.type === \"ForStatement\"",
                    "      ) {",
                    "        // For ExpressionStatements and for-loop heads, which are among",
                    "        // the few places a SequenceExpression appears unparenthesized, we want",
                    "        // to indent expressions after the first.",
                    "        const parts = [];",
                    "        path.each(({ isFirst }) => {",
                    "          if (isFirst) {",
                    "            parts.push(print());",
                    "          } else {",
                    "            parts.push(\",\", indent([line, print()]));",
                    "          }",
                    "        }, \"expressions\");",
                    "        return group(parts);",
                    "      }",
                    "      return group(join([\",\", line], path.map(print, \"expressions\")));",
                    "    }",
                    "    case \"ThisExpression\":",
                    "      return \"this\";",
                    "    case \"Super\":",
                    "      return \"super\";",
                    "    case \"Directive\":",
                    "      return [print(\"value\"), semi]; // Babel 6",
                    "    case \"UnaryExpression\":",
                    "      parts.push(node.operator);",
                    "",
                    "      if (/[a-z]$/.test(node.operator)) {",
                    "        parts.push(\" \");",
                    "      }",
                    "",
                    "      if (hasComment(node.argument)) {",
                    "        parts.push(",
                    "          group([\"(\", indent([softline, print(\"argument\")]), softline, \")\"])",
                    "        );",
                    "      } else {",
                    "        parts.push(print(\"argument\"));",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"UpdateExpression\":",
                    "      parts.push(print(\"argument\"), node.operator);",
                    "",
                    "      if (node.prefix) {",
                    "        parts.reverse();",
                    "      }",
                    "",
                    "      return parts;",
                    "    case \"ConditionalExpression\":",
                    "      return printTernary(path, options, print);",
                    "    case \"VariableDeclaration\": {",
                    "      const printed = path.map(print, \"declarations\");",
                    "",
                    "      // We generally want to terminate all variable declarations with a",
                    "      // semicolon, except when they in the () part of for loops.",
                    "      const parentNode = path.parent;",
                    "",
                    "      const isParentForLoop =",
                    "        parentNode.type === \"ForStatement\" ||",
                    "        parentNode.type === \"ForInStatement\" ||",
                    "        parentNode.type === \"ForOfStatement\";",
                    "",
                    "      const hasValue = node.declarations.some((decl) => decl.init);",
                    "",
                    "      let firstVariable;",
                    "      if (printed.length === 1 && !hasComment(node.declarations[0])) {",
                    "        firstVariable = printed[0];",
                    "      } else if (printed.length > 0) {",
                    "        // Indent first var to comply with eslint one-var rule",
                    "        firstVariable = indent(printed[0]);",
                    "      }",
                    "",
                    "      parts = [",
                    "        printDeclareToken(path),",
                    "        node.kind,",
                    "        firstVariable ? [\" \", firstVariable] : \"\",",
                    "        indent(",
                    "          printed",
                    "            .slice(1)",
                    "            .map((p) => [",
                    "              \",\",",
                    "              hasValue && !isParentForLoop ? hardline : line,",
                    "              p,",
                    "            ])",
                    "        ),",
                    "      ];",
                    "",
                    "      if (!(isParentForLoop && parentNode.body !== node)) {",
                    "        parts.push(semi);",
                    "      }",
                    "",
                    "      return group(parts);",
                    "    }",
                    "    case \"WithStatement\":",
                    "      return group([",
                    "        \"with (\",",
                    "        print(\"object\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "    case \"IfStatement\": {",
                    "      const con = adjustClause(node.consequent, print(\"consequent\"));",
                    "      const opening = group([",
                    "        \"if (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        con,",
                    "      ]);",
                    "",
                    "      parts.push(opening);",
                    "",
                    "      if (node.alternate) {",
                    "        const commentOnOwnLine =",
                    "          hasComment(",
                    "            node.consequent,",
                    "            CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                    "          ) || needsHardlineAfterDanglingComment(node);",
                    "        const elseOnSameLine =",
                    "          node.consequent.type === \"BlockStatement\" && !commentOnOwnLine;",
                    "        parts.push(elseOnSameLine ? \" \" : hardline);",
                    "",
                    "        if (hasComment(node, CommentCheckFlags.Dangling)) {",
                    "          parts.push(",
                    "            printDanglingComments(path, options),",
                    "            commentOnOwnLine ? hardline : \" \"",
                    "          );",
                    "        }",
                    "",
                    "        parts.push(",
                    "          \"else\",",
                    "          group(",
                    "            adjustClause(",
                    "              node.alternate,",
                    "              print(\"alternate\"),",
                    "              node.alternate.type === \"IfStatement\"",
                    "            )",
                    "          )",
                    "        );",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    case \"ForStatement\": {",
                    "      const body = adjustClause(node.body, print(\"body\"));",
                    "",
                    "      // We want to keep dangling comments above the loop to stay consistent.",
                    "      // Any comment positioned between the for statement and the parentheses",
                    "      // is going to be printed before the statement.",
                    "      const dangling = printDanglingComments(path, options);",
                    "      const printedComments = dangling ? [dangling, softline] : \"\";",
                    "",
                    "      if (!node.init && !node.test && !node.update) {",
                    "        return [printedComments, group([\"for (;;)\", body])];",
                    "      }",
                    "",
                    "      return [",
                    "        printedComments,",
                    "        group([",
                    "          \"for (\",",
                    "          group([",
                    "            indent([",
                    "              softline,",
                    "              print(\"init\"),",
                    "              \";\",",
                    "              line,",
                    "              print(\"test\"),",
                    "              \";\",",
                    "              line,",
                    "              print(\"update\"),",
                    "            ]),",
                    "            softline,",
                    "          ]),",
                    "          \")\",",
                    "          body,",
                    "        ]),",
                    "      ];",
                    "    }",
                    "    case \"WhileStatement\":",
                    "      return group([",
                    "        \"while (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "    case \"ForInStatement\":",
                    "      return group([",
                    "        \"for (\",",
                    "        print(\"left\"),",
                    "        \" in \",",
                    "        print(\"right\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "",
                    "    case \"ForOfStatement\":",
                    "      return group([",
                    "        \"for\",",
                    "        node.await ? \" await\" : \"\",",
                    "        \" (\",",
                    "        print(\"left\"),",
                    "        \" of \",",
                    "        print(\"right\"),",
                    "        \")\",",
                    "        adjustClause(node.body, print(\"body\")),",
                    "      ]);",
                    "",
                    "    case \"DoWhileStatement\": {",
                    "      const clause = adjustClause(node.body, print(\"body\"));",
                    "      const doBody = group([\"do\", clause]);",
                    "      parts = [doBody];",
                    "",
                    "      if (node.body.type === \"BlockStatement\") {",
                    "        parts.push(\" \");",
                    "      } else {",
                    "        parts.push(hardline);",
                    "      }",
                    "      parts.push(",
                    "        \"while (\",",
                    "        group([indent([softline, print(\"test\")]), softline]),",
                    "        \")\",",
                    "        semi",
                    "      );",
                    "",
                    "      return parts;",
                    "    }",
                    "    case \"DoExpression\":",
                    "      return [node.async ? \"async \" : \"\", \"do \", print(\"body\")];",
                    "    case \"BreakStatement\":",
                    "    case \"ContinueStatement\":",
                    "      parts.push(node.type === \"BreakStatement\" ? \"break\" : \"continue\");",
                    "",
                    "      if (node.label) {",
                    "        parts.push(\" \", print(\"label\"));",
                    "      }",
                    "",
                    "      parts.push(semi);",
                    "",
                    "      return parts;",
                    "    case \"LabeledStatement\":",
                    "      if (node.body.type === \"EmptyStatement\") {",
                    "        return [print(\"label\"), \":;\"];",
                    "      }",
                    "",
                    "      return [print(\"label\"), \": \", print(\"body\")];",
                    "    case \"TryStatement\":",
                    "      return [",
                    "        \"try \",",
                    "        print(\"block\"),",
                    "        node.handler ? [\" \", print(\"handler\")] : \"\",",
                    "        node.finalizer ? [\" finally \", print(\"finalizer\")] : \"\",",
                    "      ];",
                    "    case \"CatchClause\":",
                    "      if (node.param) {",
                    "        const parameterHasComments = hasComment(",
                    "          node.param,",
                    "          (comment) =>",
                    "            !isBlockComment(comment) ||",
                    "            (comment.leading &&",
                    "              hasNewline(options.originalText, locEnd(comment))) ||",
                    "            (comment.trailing &&",
                    "              hasNewline(options.originalText, locStart(comment), {",
                    "                backwards: true,",
                    "              }))",
                    "        );",
                    "        const param = print(\"param\");",
                    "",
                    "        return [",
                    "          \"catch \",",
                    "          parameterHasComments",
                    "            ? [\"(\", indent([softline, param]), softline, \") \"]",
                    "            : [\"(\", param, \") \"],",
                    "          print(\"body\"),",
                    "        ];",
                    "      }",
                    "",
                    "      return [\"catch \", print(\"body\")];",
                    "    // Note: ignoring n.lexical because it has no printing consequences.",
                    "    case \"SwitchStatement\":",
                    "      return [",
                    "        group([",
                    "          \"switch (\",",
                    "          indent([softline, print(\"discriminant\")]),",
                    "          softline,",
                    "          \")\",",
                    "        ]),",
                    "        \" {\",",
                    "        node.cases.length > 0",
                    "          ? indent([",
                    "              hardline,",
                    "              join(",
                    "                hardline,",
                    "                path.map(",
                    "                  ({ node, isLast }) => [",
                    "                    print(),",
                    "                    !isLast && isNextLineEmpty(node, options) ? hardline : \"\",",
                    "                  ],",
                    "                  \"cases\"",
                    "                )",
                    "              ),",
                    "            ])",
                    "          : \"\",",
                    "        hardline,",
                    "        \"}\",",
                    "      ];",
                    "    case \"SwitchCase\": {",
                    "      if (node.test) {",
                    "        parts.push(\"case \", print(\"test\"), \":\");",
                    "      } else {",
                    "        parts.push(\"default:\");",
                    "      }",
                    "",
                    "      if (hasComment(node, CommentCheckFlags.Dangling)) {",
                    "        parts.push(\" \", printDanglingComments(path, options));",
                    "      }",
                    "",
                    "      const consequent = node.consequent.filter(",
                    "        (node) => node.type !== \"EmptyStatement\"",
                    "      );",
                    "",
                    "      if (consequent.length > 0) {",
                    "        const cons = printStatementSequence(path, options, print, \"consequent\");",
                    "",
                    "        parts.push(",
                    "          consequent.length === 1 && consequent[0].type === \"BlockStatement\"",
                    "            ? [\" \", cons]",
                    "            : indent([hardline, cons])",
                    "        );",
                    "      }",
                    "",
                    "      return parts;",
                    "    }",
                    "    // JSX extensions below.",
                    "    case \"DebuggerStatement\":",
                    "      return [\"debugger\", semi];",
                    "",
                    "    case \"ClassDeclaration\":",
                    "    case \"ClassExpression\":",
                    "      return printClass(path, options, print);",
                    "    case \"ClassMethod\":",
                    "    case \"ClassPrivateMethod\":",
                    "    case \"MethodDefinition\":",
                    "      return printClassMethod(path, options, print);",
                    "    case \"ClassProperty\":",
                    "    case \"PropertyDefinition\":",
                    "    case \"ClassPrivateProperty\":",
                    "    case \"ClassAccessorProperty\":",
                    "    case \"AccessorProperty\":",
                    "      return printClassProperty(path, options, print);",
                    "    case \"TemplateElement\":",
                    "      return replaceEndOfLine(node.value.raw);",
                    "    case \"TemplateLiteral\":",
                    "      return printTemplateLiteral(path, print, options);",
                    "    case \"TaggedTemplateExpression\":",
                    "      return printTaggedTemplateLiteral(print);",
                    "    case \"PrivateIdentifier\":",
                    "      return [\"#\", node.name];",
                    "    case \"PrivateName\":",
                    "      return [\"#\", print(\"id\")];",
                    "",
                    "    // For hack-style pipeline",
                    "    case \"TopicReference\":",
                    "      return \"%\";",
                    "",
                    "    case \"ArgumentPlaceholder\":",
                    "      return \"?\";",
                    "",
                    "    case \"ModuleExpression\": {",
                    "      parts.push(\"module {\");",
                    "      const printed = print(\"body\");",
                    "      if (printed) {",
                    "        parts.push(indent([hardline, printed]), hardline);",
                    "      }",
                    "      parts.push(\"}\");",
                    "      return parts;",
                    "    }",
                    "",
                    "    case \"InterpreterDirective\": // Printed as comment",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"ESTree\");",
                    "  }",
                    "}",
                    "",
                    "export const experimentalFeatures = {",
                    "  // TODO: Make this default behavior",
                    "  avoidAstMutation: true,",
                    "};",
                    "export { genericPrint as print };",
                    "export * from \"./comments/printer-methods.js\";",
                    "export { default as embed } from \"./embed/index.js\";",
                    "export { default as massageAstNode } from \"./clean.js\";",
                    "export { insertPragma } from \"./pragma.js\";",
                    "export { default as getVisitorKeys } from \"./traverse/get-visitor-keys.js\";"
                ]
            },
            "comments": {
                "handle-comments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import getNextNonSpaceNonCommentCharacter from \"../../utils/get-next-non-space-non-comment-character.js\";",
                        "import getNextNonSpaceNonCommentCharacterIndex from \"../../utils/get-next-non-space-non-comment-character-index.js\";",
                        "import hasNewlineInRange from \"../../utils/has-newline-in-range.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  addLeadingComment,",
                        "  addTrailingComment,",
                        "  addDanglingComment,",
                        "} from \"../../main/comments/utils.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  isPrettierIgnoreComment,",
                        "  isCallLikeExpression,",
                        "  getCallArguments,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isObjectProperty,",
                        "  isLineComment,",
                        "  markerForIfWithoutBlockAndSameLineComment,",
                        "  createTypeCheckFunction,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import isBlockComment from \"../utils/is-block-comment.js\";",
                        "import isTypeCastComment from \"../utils/is-type-cast-comment.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " * @typedef {import(\"../types/estree.js\").Comment} Comment",
                        " *",
                        " * @typedef {Object} CommentContext",
                        " * @property {Comment} comment",
                        " * @property {Node} precedingNode",
                        " * @property {Node} enclosingNode",
                        " * @property {Node} followingNode",
                        " * @property {string} text",
                        " * @property {any} options",
                        " * @property {Node} ast",
                        " * @property {boolean} isLastComment",
                        " */",
                        "",
                        "/**",
                        " * @param {CommentContext} context",
                        " * @returns {boolean}",
                        " */",
                        "function handleOwnLineComment(context) {",
                        "  return [",
                        "    handleIgnoreComments,",
                        "    handleLastFunctionArgComments,",
                        "    handleMemberExpressionComments,",
                        "    handleIfStatementComments,",
                        "    handleWhileComments,",
                        "    handleTryStatementComments,",
                        "    handleClassComments,",
                        "    handleForComments,",
                        "    handleUnionTypeComments,",
                        "    handleOnlyComments,",
                        "    handleModuleSpecifiersComments,",
                        "    handleAssignmentPatternComments,",
                        "    handleMethodNameComments,",
                        "    handleLabeledStatementComments,",
                        "    handleBreakAndContinueStatementComments,",
                        "  ].some((fn) => fn(context));",
                        "}",
                        "",
                        "/**",
                        " * @param {CommentContext} context",
                        " * @returns {boolean}",
                        " */",
                        "function handleEndOfLineComment(context) {",
                        "  return [",
                        "    handleClosureTypeCastComments,",
                        "    handleLastFunctionArgComments,",
                        "    handleConditionalExpressionComments,",
                        "    handleModuleSpecifiersComments,",
                        "    handleIfStatementComments,",
                        "    handleWhileComments,",
                        "    handleTryStatementComments,",
                        "    handleClassComments,",
                        "    handleLabeledStatementComments,",
                        "    handleCallExpressionComments,",
                        "    handlePropertyComments,",
                        "    handleOnlyComments,",
                        "    handleVariableDeclaratorComments,",
                        "    handleBreakAndContinueStatementComments,",
                        "    handleSwitchDefaultCaseComments,",
                        "  ].some((fn) => fn(context));",
                        "}",
                        "",
                        "/**",
                        " * @param {CommentContext} context",
                        " * @returns {boolean}",
                        " */",
                        "function handleRemainingComment(context) {",
                        "  return [",
                        "    handleIgnoreComments,",
                        "    handleIfStatementComments,",
                        "    handleWhileComments,",
                        "    handleObjectPropertyAssignment,",
                        "    handleCommentInEmptyParens,",
                        "    handleMethodNameComments,",
                        "    handleOnlyComments,",
                        "    handleCommentAfterArrowParams,",
                        "    handleFunctionNameComments,",
                        "    handleTSMappedTypeComments,",
                        "    handleBreakAndContinueStatementComments,",
                        "    handleTSFunctionTrailingComments,",
                        "  ].some((fn) => fn(context));",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {void}",
                        " */",
                        "function addBlockStatementFirstComment(node, comment) {",
                        "  // @ts-expect-error",
                        "  const firstNonEmptyNode = (node.body || node.properties).find(",
                        "    ({ type }) => type !== \"EmptyStatement\"",
                        "  );",
                        "  if (firstNonEmptyNode) {",
                        "    addLeadingComment(firstNonEmptyNode, comment);",
                        "  } else {",
                        "    addDanglingComment(node, comment);",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {void}",
                        " */",
                        "function addBlockOrNotComment(node, comment) {",
                        "  if (node.type === \"BlockStatement\") {",
                        "    addBlockStatementFirstComment(node, comment);",
                        "  } else {",
                        "    addLeadingComment(node, comment);",
                        "  }",
                        "}",
                        "",
                        "function handleClosureTypeCastComments({ comment, followingNode }) {",
                        "  if (followingNode && isTypeCastComment(comment)) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "// There are often comments before the else clause of if statements like",
                        "//",
                        "//   if (1) { ... }",
                        "//   // comment",
                        "//   else { ... }",
                        "//",
                        "// They are being attached as leading comments of the BlockExpression which",
                        "// is not well printed. What we want is to instead move the comment inside",
                        "// of the block and make it leadingComment of the first element of the block",
                        "// or dangling comment of the block if there is nothing inside",
                        "//",
                        "//   if (1) { ... }",
                        "//   else {",
                        "//     // comment",
                        "//     ...",
                        "//   }",
                        "function handleIfStatementComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  if (enclosingNode?.type !== \"IfStatement\" || !followingNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // We unfortunately have no way using the AST or location of nodes to know",
                        "  // if the comment is positioned before the condition parenthesis:",
                        "  //   if (a /* comment */) {}",
                        "  // The only workaround I found is to look at the next character to see if",
                        "  // it is a ).",
                        "  const nextCharacter = getNextNonSpaceNonCommentCharacter(",
                        "    text,",
                        "    locEnd(comment)",
                        "  );",
                        "  if (nextCharacter === \")\") {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  // Comments before `else`:",
                        "  // - treat as trailing comments of the consequent, if it's a BlockStatement",
                        "  // - treat as a dangling comment otherwise",
                        "  if (",
                        "    precedingNode === enclosingNode.consequent &&",
                        "    followingNode === enclosingNode.alternate",
                        "  ) {",
                        "    if (precedingNode.type === \"BlockStatement\") {",
                        "      addTrailingComment(precedingNode, comment);",
                        "    } else {",
                        "      const isSingleLineComment =",
                        "        comment.type === \"SingleLine\" ||",
                        "        comment.loc.start.line === comment.loc.end.line;",
                        "      const isSameLineComment =",
                        "        comment.loc.start.line === precedingNode.loc.start.line;",
                        "      if (isSingleLineComment && isSameLineComment) {",
                        "        // example:",
                        "        //   if (cond1) expr1; // comment A",
                        "        //   else if (cond2) expr2; // comment A",
                        "        //   else expr3;",
                        "        addDanglingComment(",
                        "          precedingNode,",
                        "          comment,",
                        "          markerForIfWithoutBlockAndSameLineComment",
                        "        );",
                        "      } else {",
                        "        addDanglingComment(enclosingNode, comment);",
                        "      }",
                        "    }",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"BlockStatement\") {",
                        "    addBlockStatementFirstComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"IfStatement\") {",
                        "    addBlockOrNotComment(followingNode.consequent, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  // For comments positioned after the condition parenthesis in an if statement",
                        "  // before the consequent without brackets on, such as",
                        "  // if (a) /* comment */ true,",
                        "  // we look at the next character to see if the following node",
                        "  // is the consequent for the if statement",
                        "  if (enclosingNode.consequent === followingNode) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleWhileComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  if (enclosingNode?.type !== \"WhileStatement\" || !followingNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // We unfortunately have no way using the AST or location of nodes to know",
                        "  // if the comment is positioned before the condition parenthesis:",
                        "  //   while (a /* comment */) {}",
                        "  // The only workaround I found is to look at the next character to see if",
                        "  // it is a ).",
                        "  const nextCharacter = getNextNonSpaceNonCommentCharacter(",
                        "    text,",
                        "    locEnd(comment)",
                        "  );",
                        "  if (nextCharacter === \")\") {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"BlockStatement\") {",
                        "    addBlockStatementFirstComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (enclosingNode.body === followingNode) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "// Same as IfStatement but for TryStatement",
                        "function handleTryStatementComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    (enclosingNode?.type !== \"TryStatement\" &&",
                        "      enclosingNode?.type !== \"CatchClause\") ||",
                        "    !followingNode",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (enclosingNode.type === \"CatchClause\" && precedingNode) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"BlockStatement\") {",
                        "    addBlockStatementFirstComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"TryStatement\") {",
                        "    addBlockOrNotComment(followingNode.finalizer, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"CatchClause\") {",
                        "    addBlockOrNotComment(followingNode.body, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleMemberExpressionComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    isMemberExpression(enclosingNode) &&",
                        "    followingNode?.type === \"Identifier\"",
                        "  ) {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleConditionalExpressionComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  const isSameLineAsPrecedingNode =",
                        "    precedingNode &&",
                        "    !hasNewlineInRange(text, locEnd(precedingNode), locStart(comment));",
                        "",
                        "  if (",
                        "    (!precedingNode || !isSameLineAsPrecedingNode) &&",
                        "    (enclosingNode?.type === \"ConditionalExpression\" ||",
                        "      enclosingNode?.type === \"TSConditionalType\") &&",
                        "    followingNode",
                        "  ) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleObjectPropertyAssignment({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "}) {",
                        "  if (",
                        "    isObjectProperty(enclosingNode) &&",
                        "    enclosingNode.shorthand &&",
                        "    enclosingNode.key === precedingNode &&",
                        "    enclosingNode.value.type === \"AssignmentPattern\"",
                        "  ) {",
                        "    addTrailingComment(enclosingNode.value.left, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "const classLikeNodeTypes = new Set([",
                        "  \"ClassDeclaration\",",
                        "  \"ClassExpression\",",
                        "  \"DeclareClass\",",
                        "  \"DeclareInterface\",",
                        "  \"InterfaceDeclaration\",",
                        "  \"TSInterfaceDeclaration\",",
                        "]);",
                        "function handleClassComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (classLikeNodeTypes.has(enclosingNode?.type)) {",
                        "    if (",
                        "      isNonEmptyArray(enclosingNode.decorators) &&",
                        "      !(followingNode?.type === \"Decorator\")",
                        "    ) {",
                        "      addTrailingComment(enclosingNode.decorators.at(-1), comment);",
                        "      return true;",
                        "    }",
                        "",
                        "    if (enclosingNode.body && followingNode === enclosingNode.body) {",
                        "      addBlockStatementFirstComment(enclosingNode.body, comment);",
                        "      return true;",
                        "    }",
                        "",
                        "    // Don't add leading comments to `implements`, `extends`, `mixins` to",
                        "    // avoid printing the comment after the keyword.",
                        "    if (followingNode) {",
                        "      if (",
                        "        enclosingNode.superClass &&",
                        "        followingNode === enclosingNode.superClass &&",
                        "        precedingNode &&",
                        "        (precedingNode === enclosingNode.id ||",
                        "          precedingNode === enclosingNode.typeParameters)",
                        "      ) {",
                        "        addTrailingComment(precedingNode, comment);",
                        "        return true;",
                        "      }",
                        "",
                        "      for (const prop of [\"implements\", \"extends\", \"mixins\"]) {",
                        "        if (enclosingNode[prop] && followingNode === enclosingNode[prop][0]) {",
                        "          if (",
                        "            precedingNode &&",
                        "            (precedingNode === enclosingNode.id ||",
                        "              precedingNode === enclosingNode.typeParameters ||",
                        "              precedingNode === enclosingNode.superClass)",
                        "          ) {",
                        "            addTrailingComment(precedingNode, comment);",
                        "          } else {",
                        "            addDanglingComment(enclosingNode, comment, prop);",
                        "          }",
                        "          return true;",
                        "        }",
                        "      }",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "const propertyLikeNodeTypes = new Set([",
                        "  \"ClassMethod\",",
                        "  \"ClassProperty\",",
                        "  \"PropertyDefinition\",",
                        "  \"TSAbstractPropertyDefinition\",",
                        "  \"TSAbstractMethodDefinition\",",
                        "  \"TSDeclareMethod\",",
                        "  \"MethodDefinition\",",
                        "  \"ClassAccessorProperty\",",
                        "  \"AccessorProperty\",",
                        "  \"TSAbstractAccessorProperty\",",
                        "]);",
                        "function handleMethodNameComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  text,",
                        "}) {",
                        "  // This is only needed for estree parsers (flow, typescript) to attach",
                        "  // after a method name:",
                        "  // obj = { fn /*comment*/() {} };",
                        "  if (",
                        "    enclosingNode &&",
                        "    precedingNode &&",
                        "    getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) === \"(\" &&",
                        "    // \"MethodDefinition\" is handled in getCommentChildNodes",
                        "    (enclosingNode.type === \"Property\" ||",
                        "      enclosingNode.type === \"TSDeclareMethod\" ||",
                        "      enclosingNode.type === \"TSAbstractMethodDefinition\") &&",
                        "    precedingNode.type === \"Identifier\" &&",
                        "    enclosingNode.key === precedingNode &&",
                        "    // special Property case: { key: /*comment*/(value) };",
                        "    // comment should be attached to value instead of key",
                        "    getNextNonSpaceNonCommentCharacter(text, locEnd(precedingNode)) !== \":\"",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  // Print comments between decorators and class methods as a trailing comment",
                        "  // on the decorator node instead of the method node",
                        "  if (",
                        "    precedingNode?.type === \"Decorator\" &&",
                        "    propertyLikeNodeTypes.has(enclosingNode?.type)",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "const functionLikeNodeTypes = new Set([",
                        "  \"FunctionDeclaration\",",
                        "  \"FunctionExpression\",",
                        "  \"ClassMethod\",",
                        "  \"MethodDefinition\",",
                        "  \"ObjectMethod\",",
                        "]);",
                        "function handleFunctionNameComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  text,",
                        "}) {",
                        "  if (getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) !== \"(\") {",
                        "    return false;",
                        "  }",
                        "  if (precedingNode && functionLikeNodeTypes.has(enclosingNode?.type)) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleCommentAfterArrowParams({ comment, enclosingNode, text }) {",
                        "  if (!(enclosingNode?.type === \"ArrowFunctionExpression\")) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const index = getNextNonSpaceNonCommentCharacterIndex(text, locEnd(comment));",
                        "  if (index !== false && text.slice(index, index + 2) === \"=>\") {",
                        "    addDanglingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleCommentInEmptyParens({ comment, enclosingNode, text }) {",
                        "  if (getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) !== \")\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  // Only add dangling comments to fix the case when no params are present,",
                        "  // i.e. a function without any argument.",
                        "  if (",
                        "    enclosingNode &&",
                        "    ((isRealFunctionLikeNode(enclosingNode) &&",
                        "      getFunctionParameters(enclosingNode).length === 0) ||",
                        "      (isCallLikeExpression(enclosingNode) &&",
                        "        getCallArguments(enclosingNode).length === 0))",
                        "  ) {",
                        "    addDanglingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  if (",
                        "    (enclosingNode?.type === \"MethodDefinition\" ||",
                        "      enclosingNode?.type === \"TSAbstractMethodDefinition\") &&",
                        "    getFunctionParameters(enclosingNode.value).length === 0",
                        "  ) {",
                        "    addDanglingComment(enclosingNode.value, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleLastFunctionArgComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  // Flow function type definitions",
                        "  if (",
                        "    precedingNode?.type === \"FunctionTypeParam\" &&",
                        "    enclosingNode?.type === \"FunctionTypeAnnotation\" &&",
                        "    followingNode?.type !== \"FunctionTypeParam\"",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  // Real functions and TypeScript function type definitions",
                        "  if (",
                        "    (precedingNode?.type === \"Identifier\" ||",
                        "      precedingNode?.type === \"AssignmentPattern\") &&",
                        "    enclosingNode &&",
                        "    isRealFunctionLikeNode(enclosingNode) &&",
                        "    getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) === \")\"",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    enclosingNode?.type === \"FunctionDeclaration\" &&",
                        "    followingNode?.type === \"BlockStatement\"",
                        "  ) {",
                        "    const functionParamRightParenIndex = (() => {",
                        "      const parameters = getFunctionParameters(enclosingNode);",
                        "      if (parameters.length > 0) {",
                        "        return getNextNonSpaceNonCommentCharacterIndex(",
                        "          text,",
                        "          locEnd(parameters.at(-1))",
                        "        );",
                        "      }",
                        "      const functionParamLeftParenIndex =",
                        "        getNextNonSpaceNonCommentCharacterIndex(text, locEnd(enclosingNode.id));",
                        "      return (",
                        "        functionParamLeftParenIndex !== false &&",
                        "        getNextNonSpaceNonCommentCharacterIndex(",
                        "          text,",
                        "          functionParamLeftParenIndex + 1",
                        "        )",
                        "      );",
                        "    })();",
                        "    if (locStart(comment) > functionParamRightParenIndex) {",
                        "      addBlockStatementFirstComment(followingNode, comment);",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleLabeledStatementComments({ comment, enclosingNode }) {",
                        "  if (enclosingNode?.type === \"LabeledStatement\") {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleBreakAndContinueStatementComments({ comment, enclosingNode }) {",
                        "  if (",
                        "    (enclosingNode?.type === \"ContinueStatement\" ||",
                        "      enclosingNode?.type === \"BreakStatement\") &&",
                        "    !enclosingNode.label",
                        "  ) {",
                        "    addTrailingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleCallExpressionComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "}) {",
                        "  if (",
                        "    isCallExpression(enclosingNode) &&",
                        "    precedingNode &&",
                        "    enclosingNode.callee === precedingNode &&",
                        "    enclosingNode.arguments.length > 0",
                        "  ) {",
                        "    addLeadingComment(enclosingNode.arguments[0], comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleUnionTypeComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    enclosingNode?.type === \"UnionTypeAnnotation\" ||",
                        "    enclosingNode?.type === \"TSUnionType\"",
                        "  ) {",
                        "    if (isPrettierIgnoreComment(comment)) {",
                        "      followingNode.prettierIgnore = true;",
                        "      comment.unignore = true;",
                        "    }",
                        "    if (precedingNode) {",
                        "      addTrailingComment(precedingNode, comment);",
                        "      return true;",
                        "    }",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    (followingNode?.type === \"UnionTypeAnnotation\" ||",
                        "      followingNode?.type === \"TSUnionType\") &&",
                        "    isPrettierIgnoreComment(comment)",
                        "  ) {",
                        "    followingNode.types[0].prettierIgnore = true;",
                        "    comment.unignore = true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handlePropertyComments({ comment, enclosingNode }) {",
                        "  if (isObjectProperty(enclosingNode)) {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleOnlyComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  ast,",
                        "  isLastComment,",
                        "}) {",
                        "  // With Flow the enclosingNode is undefined so use the AST instead.",
                        "  if (ast?.body?.length === 0) {",
                        "    if (isLastComment) {",
                        "      addDanglingComment(ast, comment);",
                        "    } else {",
                        "      addLeadingComment(ast, comment);",
                        "    }",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    enclosingNode?.type === \"Program\" &&",
                        "    enclosingNode.body.length === 0 &&",
                        "    !isNonEmptyArray(enclosingNode.directives)",
                        "  ) {",
                        "    if (isLastComment) {",
                        "      addDanglingComment(enclosingNode, comment);",
                        "    } else {",
                        "      addLeadingComment(enclosingNode, comment);",
                        "    }",
                        "    return true;",
                        "  }",
                        "",
                        "  if (",
                        "    followingNode?.type === \"Program\" &&",
                        "    followingNode.body.length === 0 &&",
                        "    enclosingNode?.type === \"ModuleExpression\"",
                        "  ) {",
                        "    addDanglingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleForComments({ comment, enclosingNode }) {",
                        "  if (",
                        "    enclosingNode?.type === \"ForInStatement\" ||",
                        "    enclosingNode?.type === \"ForOfStatement\"",
                        "  ) {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleModuleSpecifiersComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  text,",
                        "}) {",
                        "  if (",
                        "    enclosingNode?.type === \"ImportSpecifier\" ||",
                        "    enclosingNode?.type === \"ExportSpecifier\"",
                        "  ) {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  const isImportDeclaration =",
                        "    precedingNode?.type === \"ImportSpecifier\" &&",
                        "    enclosingNode?.type === \"ImportDeclaration\";",
                        "  const isExportDeclaration =",
                        "    precedingNode?.type === \"ExportSpecifier\" &&",
                        "    enclosingNode?.type === \"ExportNamedDeclaration\";",
                        "  if (",
                        "    (isImportDeclaration || isExportDeclaration) &&",
                        "    hasNewline(text, locEnd(comment))",
                        "  ) {",
                        "    addTrailingComment(precedingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleAssignmentPatternComments({ comment, enclosingNode }) {",
                        "  if (enclosingNode?.type === \"AssignmentPattern\") {",
                        "    addLeadingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "const assignmentLikeNodeTypes = new Set([",
                        "  \"VariableDeclarator\",",
                        "  \"AssignmentExpression\",",
                        "  \"TypeAlias\",",
                        "  \"TSTypeAliasDeclaration\",",
                        "]);",
                        "const complexExprNodeTypes = new Set([",
                        "  \"ObjectExpression\",",
                        "  \"RecordExpression\",",
                        "  \"ArrayExpression\",",
                        "  \"TupleExpression\",",
                        "  \"TemplateLiteral\",",
                        "  \"TaggedTemplateExpression\",",
                        "  \"ObjectTypeAnnotation\",",
                        "  \"TSTypeLiteral\",",
                        "]);",
                        "function handleVariableDeclaratorComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    assignmentLikeNodeTypes.has(enclosingNode?.type) &&",
                        "    followingNode &&",
                        "    (complexExprNodeTypes.has(followingNode.type) || isBlockComment(comment))",
                        "  ) {",
                        "    addLeadingComment(followingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleTSFunctionTrailingComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "  text,",
                        "}) {",
                        "  if (",
                        "    !followingNode &&",
                        "    (enclosingNode?.type === \"TSMethodSignature\" ||",
                        "      enclosingNode?.type === \"TSDeclareFunction\" ||",
                        "      enclosingNode?.type === \"TSAbstractMethodDefinition\") &&",
                        "    getNextNonSpaceNonCommentCharacter(text, locEnd(comment)) === \";\"",
                        "  ) {",
                        "    addTrailingComment(enclosingNode, comment);",
                        "    return true;",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function handleIgnoreComments({ comment, enclosingNode, followingNode }) {",
                        "  if (",
                        "    isPrettierIgnoreComment(comment) &&",
                        "    enclosingNode?.type === \"TSMappedType\" &&",
                        "    followingNode?.type === \"TSTypeParameter\" &&",
                        "    followingNode.constraint",
                        "  ) {",
                        "    enclosingNode.prettierIgnore = true;",
                        "    comment.unignore = true;",
                        "    return true;",
                        "  }",
                        "}",
                        "",
                        "function handleTSMappedTypeComments({",
                        "  comment,",
                        "  precedingNode,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (enclosingNode?.type !== \"TSMappedType\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (followingNode?.type === \"TSTypeParameter\" && followingNode.name) {",
                        "    addLeadingComment(followingNode.name, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  if (precedingNode?.type === \"TSTypeParameter\" && precedingNode.constraint) {",
                        "    addTrailingComment(precedingNode.constraint, comment);",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function handleSwitchDefaultCaseComments({",
                        "  comment,",
                        "  enclosingNode,",
                        "  followingNode,",
                        "}) {",
                        "  if (",
                        "    !enclosingNode ||",
                        "    enclosingNode.type !== \"SwitchCase\" ||",
                        "    enclosingNode.test ||",
                        "    !followingNode ||",
                        "    followingNode !== enclosingNode.consequent[0]",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (followingNode.type === \"BlockStatement\" && isLineComment(comment)) {",
                        "    addBlockStatementFirstComment(followingNode, comment);",
                        "  } else {",
                        "    addDanglingComment(enclosingNode, comment);",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isRealFunctionLikeNode = createTypeCheckFunction([",
                        "  \"ArrowFunctionExpression\",",
                        "  \"FunctionExpression\",",
                        "  \"FunctionDeclaration\",",
                        "  \"ObjectMethod\",",
                        "  \"ClassMethod\",",
                        "  \"TSDeclareFunction\",",
                        "  \"TSCallSignatureDeclaration\",",
                        "  \"TSConstructSignatureDeclaration\",",
                        "  \"TSMethodSignature\",",
                        "  \"TSConstructorType\",",
                        "  \"TSFunctionType\",",
                        "  \"TSDeclareMethod\",",
                        "]);",
                        "",
                        "export {",
                        "  handleOwnLineComment as ownLine,",
                        "  handleEndOfLineComment as endOfLine,",
                        "  handleRemainingComment as remaining,",
                        "};"
                    ]
                },
                "printer-methods.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  hasNodeIgnoreComment,",
                        "  isJsxElement,",
                        "} from \"../utils/index.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " */",
                        "",
                        "const nodeTypesCanNotAttachComment = new Set([",
                        "  \"EmptyStatement\",",
                        "  \"TemplateElement\",",
                        "  // In ESTree `import` is a token, `import(\"foo\")`",
                        "  \"Import\",",
                        "  // There is no similar node in Babel AST",
                        "  // ```ts",
                        "  // class Foo {",
                        "  //   bar();",
                        "  //      ^^^ TSEmptyBodyFunctionExpression",
                        "  // }",
                        "  // ```",
                        "  \"TSEmptyBodyFunctionExpression\",",
                        "  // There is no similar node in Babel AST, `a?.b`",
                        "  \"ChainExpression\",",
                        "]);",
                        "function canAttachComment(node) {",
                        "  return !nodeTypesCanNotAttachComment.has(node.type);",
                        "}",
                        "",
                        "/**",
                        " * @param {any} node",
                        " * @returns {Node[] | void}",
                        " */",
                        "function getCommentChildNodes(node, options) {",
                        "  // Prevent attaching comments to FunctionExpression in this case:",
                        "  //     class Foo {",
                        "  //       bar() // comment",
                        "  //       {",
                        "  //         baz();",
                        "  //       }",
                        "  //     }",
                        "  if (",
                        "    (options.parser === \"typescript\" ||",
                        "      options.parser === \"flow\" ||",
                        "      options.parser === \"acorn\" ||",
                        "      options.parser === \"espree\" ||",
                        "      options.parser === \"meriyah\" ||",
                        "      options.parser === \"__babel_estree\") &&",
                        "    node.type === \"MethodDefinition\" &&",
                        "    node.value?.type === \"FunctionExpression\" &&",
                        "    getFunctionParameters(node.value).length === 0 &&",
                        "    !node.value.returnType &&",
                        "    !isNonEmptyArray(node.value.typeParameters) &&",
                        "    node.value.body",
                        "  ) {",
                        "    return [...(node.decorators || []), node.key, node.value.body];",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function willPrintOwnComments(path) {",
                        "  const { node, parent } = path;",
                        "  return (",
                        "    (isJsxElement(node) ||",
                        "      (parent &&",
                        "        (parent.type === \"JSXSpreadAttribute\" ||",
                        "          parent.type === \"JSXSpreadChild\" ||",
                        "          parent.type === \"UnionTypeAnnotation\" ||",
                        "          parent.type === \"TSUnionType\" ||",
                        "          ((parent.type === \"ClassDeclaration\" ||",
                        "            parent.type === \"ClassExpression\") &&",
                        "            parent.superClass === node)))) &&",
                        "    (!hasNodeIgnoreComment(node) ||",
                        "      parent.type === \"UnionTypeAnnotation\" ||",
                        "      parent.type === \"TSUnionType\")",
                        "  );",
                        "}",
                        "",
                        "function isGap(text, { parser }) {",
                        "  if (parser === \"flow\" || parser === \"babel-flow\") {",
                        "    // Example: (a /* b */ /* : c */)",
                        "    //                gap ^^^^",
                        "    text = text.replaceAll(/[\\s(]/g, \"\");",
                        "    return text === \"\" || text === \"/*\" || text === \"/*::\";",
                        "  }",
                        "}",
                        "",
                        "export * as handleComments from \"./handle-comments.js\";",
                        "export { printComment } from \"../print/comment.js\";",
                        "export { default as isBlockComment } from \"../utils/is-block-comment.js\";",
                        "export { canAttachComment, getCommentChildNodes, willPrintOwnComments, isGap };"
                    ]
                }
            },
            "embed": {
                "css.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import { indent, hardline, softline } from \"../../document/builders.js\";",
                        "import { mapDoc, replaceEndOfLine, cleanDoc } from \"../../document/utils.js\";",
                        "import { printTemplateExpressions } from \"../print/template-literal.js\";",
                        "import { isAngularComponentStyles } from \"./utils.js\";",
                        "",
                        "async function printEmbedCss(textToDoc, print, path /*, options*/) {",
                        "  const { node } = path;",
                        "",
                        "  // Get full template literal with expressions replaced by placeholders",
                        "  const rawQuasis = node.quasis.map((q) => q.value.raw);",
                        "  let placeholderID = 0;",
                        "  const text = rawQuasis.reduce(",
                        "    (prevVal, currVal, idx) =>",
                        "      idx === 0",
                        "        ? currVal",
                        "        : prevVal +",
                        "          \"@prettier-placeholder-\" +",
                        "          placeholderID++ +",
                        "          \"-id\" +",
                        "          currVal,",
                        "    \"\"",
                        "  );",
                        "  const quasisDoc = await textToDoc(text, { parser: \"scss\" });",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  const newDoc = replacePlaceholders(quasisDoc, expressionDocs);",
                        "  /* c8 ignore next 3 */",
                        "  if (!newDoc) {",
                        "    throw new Error(\"Couldn't insert all the expressions\");",
                        "  }",
                        "  return [\"`\", indent([hardline, newDoc]), softline, \"`\"];",
                        "}",
                        "",
                        "// Search all the placeholders in the quasisDoc tree",
                        "// and replace them with the expression docs one by one",
                        "// returns a new doc with all the placeholders replaced,",
                        "// or null if it couldn't replace any expression",
                        "function replacePlaceholders(quasisDoc, expressionDocs) {",
                        "  if (!isNonEmptyArray(expressionDocs)) {",
                        "    return quasisDoc;",
                        "  }",
                        "  let replaceCounter = 0;",
                        "  const newDoc = mapDoc(cleanDoc(quasisDoc), (doc) => {",
                        "    if (typeof doc !== \"string\" || !doc.includes(\"@prettier-placeholder\")) {",
                        "      return doc;",
                        "    }",
                        "    // When we have multiple placeholders in one line, like:",
                        "    // ${Child}${Child2}:not(:first-child)",
                        "    return doc.split(/@prettier-placeholder-(\\d+)-id/).map((component, idx) => {",
                        "      // The placeholder is always at odd indices",
                        "      if (idx % 2 === 0) {",
                        "        return replaceEndOfLine(component);",
                        "      }",
                        "",
                        "      // The component will always be a number at odd index",
                        "      replaceCounter++;",
                        "      return expressionDocs[component];",
                        "    });",
                        "  });",
                        "  return expressionDocs.length === replaceCounter ? newDoc : null;",
                        "}",
                        "",
                        "/**",
                        " * Template literal in these contexts:",
                        " * <style jsx>{`div{color:red}`}</style>",
                        " * css``",
                        " * css.global``",
                        " * css.resolve``",
                        " */",
                        "function isStyledJsx({ node, parent, grandparent }) {",
                        "  return (",
                        "    (grandparent &&",
                        "      node.quasis &&",
                        "      parent.type === \"JSXExpressionContainer\" &&",
                        "      grandparent.type === \"JSXElement\" &&",
                        "      grandparent.openingElement.name.name === \"style\" &&",
                        "      grandparent.openingElement.attributes.some(",
                        "        (attribute) => attribute.name.name === \"jsx\"",
                        "      )) ||",
                        "    (parent?.type === \"TaggedTemplateExpression\" &&",
                        "      parent.tag.type === \"Identifier\" &&",
                        "      parent.tag.name === \"css\") ||",
                        "    (parent?.type === \"TaggedTemplateExpression\" &&",
                        "      parent.tag.type === \"MemberExpression\" &&",
                        "      parent.tag.object.name === \"css\" &&",
                        "      (parent.tag.property.name === \"global\" ||",
                        "        parent.tag.property.name === \"resolve\"))",
                        "  );",
                        "}",
                        "",
                        "function isStyledIdentifier(node) {",
                        "  return node.type === \"Identifier\" && node.name === \"styled\";",
                        "}",
                        "",
                        "function isStyledExtend(node) {",
                        "  return /^[A-Z]/.test(node.object.name) && node.property.name === \"extend\";",
                        "}",
                        "",
                        "/**",
                        " * styled-components template literals",
                        " */",
                        "function isStyledComponents({ parent }) {",
                        "  if (!parent || parent.type !== \"TaggedTemplateExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  const tag =",
                        "    parent.tag.type === \"ParenthesizedExpression\"",
                        "      ? parent.tag.expression",
                        "      : parent.tag;",
                        "",
                        "  switch (tag.type) {",
                        "    case \"MemberExpression\":",
                        "      return (",
                        "        // styled.foo``",
                        "        isStyledIdentifier(tag.object) ||",
                        "        // Component.extend``",
                        "        isStyledExtend(tag)",
                        "      );",
                        "",
                        "    case \"CallExpression\":",
                        "      return (",
                        "        // styled(Component)``",
                        "        isStyledIdentifier(tag.callee) ||",
                        "        (tag.callee.type === \"MemberExpression\" &&",
                        "          ((tag.callee.object.type === \"MemberExpression\" &&",
                        "            // styled.foo.attrs({})``",
                        "            (isStyledIdentifier(tag.callee.object.object) ||",
                        "              // Component.extend.attrs({})``",
                        "              isStyledExtend(tag.callee.object))) ||",
                        "            // styled(Component).attrs({})``",
                        "            (tag.callee.object.type === \"CallExpression\" &&",
                        "              isStyledIdentifier(tag.callee.object.callee))))",
                        "      );",
                        "",
                        "    case \"Identifier\":",
                        "      // css``",
                        "      return tag.name === \"css\";",
                        "",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * JSX element with CSS prop",
                        " */",
                        "function isCssProp({ parent, grandparent }) {",
                        "  return (",
                        "    grandparent?.type === \"JSXAttribute\" &&",
                        "    parent.type === \"JSXExpressionContainer\" &&",
                        "    grandparent.name.type === \"JSXIdentifier\" &&",
                        "    grandparent.name.name === \"css\"",
                        "  );",
                        "}",
                        "",
                        "function printCss(path /*, options*/) {",
                        "  if (",
                        "    isStyledJsx(path) ||",
                        "    isStyledComponents(path) ||",
                        "    isCssProp(path) ||",
                        "    isAngularComponentStyles(path)",
                        "  ) {",
                        "    return printEmbedCss;",
                        "  }",
                        "}",
                        "",
                        "export default printCss;"
                    ]
                },
                "graphql.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { indent, join, hardline } from \"../../document/builders.js\";",
                        "import {",
                        "  escapeTemplateCharacters,",
                        "  printTemplateExpressions,",
                        "} from \"../print/template-literal.js\";",
                        "import { hasLanguageComment } from \"./utils.js\";",
                        "",
                        "async function printEmbedGraphQL(textToDoc, print, path /*, options*/) {",
                        "  const { node } = path;",
                        "",
                        "  const numQuasis = node.quasis.length;",
                        "",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "  const parts = [];",
                        "",
                        "  for (let i = 0; i < numQuasis; i++) {",
                        "    const templateElement = node.quasis[i];",
                        "    const isFirst = i === 0;",
                        "    const isLast = i === numQuasis - 1;",
                        "    const text = templateElement.value.cooked;",
                        "",
                        "    const lines = text.split(\"\\n\");",
                        "    const numLines = lines.length;",
                        "    const expressionDoc = expressionDocs[i];",
                        "",
                        "    const startsWithBlankLine =",
                        "      numLines > 2 && lines[0].trim() === \"\" && lines[1].trim() === \"\";",
                        "    const endsWithBlankLine =",
                        "      numLines > 2 &&",
                        "      lines[numLines - 1].trim() === \"\" &&",
                        "      lines[numLines - 2].trim() === \"\";",
                        "",
                        "    const commentsAndWhitespaceOnly = lines.every((line) =>",
                        "      /^\\s*(?:#[^\\n\\r]*)?$/.test(line)",
                        "    );",
                        "",
                        "    // Bail out if an interpolation occurs within a comment.",
                        "    if (!isLast && /#[^\\n\\r]*$/.test(lines[numLines - 1])) {",
                        "      return null;",
                        "    }",
                        "",
                        "    let doc = null;",
                        "",
                        "    if (commentsAndWhitespaceOnly) {",
                        "      doc = printGraphqlComments(lines);",
                        "    } else {",
                        "      doc = await textToDoc(text, { parser: \"graphql\" });",
                        "    }",
                        "",
                        "    if (doc) {",
                        "      doc = escapeTemplateCharacters(doc, false);",
                        "      if (!isFirst && startsWithBlankLine) {",
                        "        parts.push(\"\");",
                        "      }",
                        "      parts.push(doc);",
                        "      if (!isLast && endsWithBlankLine) {",
                        "        parts.push(\"\");",
                        "      }",
                        "    } else if (!isFirst && !isLast && startsWithBlankLine) {",
                        "      parts.push(\"\");",
                        "    }",
                        "",
                        "    if (expressionDoc) {",
                        "      parts.push(expressionDoc);",
                        "    }",
                        "  }",
                        "",
                        "  return [\"`\", indent([hardline, join(hardline, parts)]), hardline, \"`\"];",
                        "}",
                        "",
                        "function printGraphqlComments(lines) {",
                        "  const parts = [];",
                        "  let seenComment = false;",
                        "",
                        "  const array = lines.map((textLine) => textLine.trim());",
                        "  for (const [i, textLine] of array.entries()) {",
                        "    // Lines are either whitespace only, or a comment (with potential whitespace",
                        "    // around it). Drop whitespace-only lines.",
                        "    if (textLine === \"\") {",
                        "      continue;",
                        "    }",
                        "",
                        "    if (array[i - 1] === \"\" && seenComment) {",
                        "      // If a non-first comment is preceded by a blank (whitespace only) line,",
                        "      // add in a blank line.",
                        "      parts.push([hardline, textLine]);",
                        "    } else {",
                        "      parts.push(textLine);",
                        "    }",
                        "",
                        "    seenComment = true;",
                        "  }",
                        "",
                        "  // If `lines` was whitespace only, return `null`.",
                        "  return parts.length === 0 ? null : join(hardline, parts);",
                        "}",
                        "",
                        "/*",
                        " * react-relay and graphql-tag",
                        " * graphql`...`",
                        " * graphql.experimental`...`",
                        " * gql`...`",
                        " * GraphQL comment block",
                        " *",
                        " * This intentionally excludes Relay Classic tags, as Prettier does not",
                        " * support Relay Classic formatting.",
                        " */",
                        "function isGraphQL({ node, parent }) {",
                        "  return (",
                        "    hasLanguageComment(node, \"GraphQL\") ||",
                        "    (parent &&",
                        "      ((parent.type === \"TaggedTemplateExpression\" &&",
                        "        ((parent.tag.type === \"MemberExpression\" &&",
                        "          parent.tag.object.name === \"graphql\" &&",
                        "          parent.tag.property.name === \"experimental\") ||",
                        "          (parent.tag.type === \"Identifier\" &&",
                        "            (parent.tag.name === \"gql\" || parent.tag.name === \"graphql\")))) ||",
                        "        (parent.type === \"CallExpression\" &&",
                        "          parent.callee.type === \"Identifier\" &&",
                        "          parent.callee.name === \"graphql\")))",
                        "  );",
                        "}",
                        "",
                        "function printGraphql(path /*, options*/) {",
                        "  if (isGraphQL(path)) {",
                        "    return printEmbedGraphQL;",
                        "  }",
                        "}",
                        "",
                        "export default printGraphql;"
                    ]
                },
                "html.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  indent,",
                        "  line,",
                        "  hardline,",
                        "  group,",
                        "  label,",
                        "} from \"../../document/builders.js\";",
                        "import { mapDoc } from \"../../document/utils.js\";",
                        "import {",
                        "  printTemplateExpressions,",
                        "  uncookTemplateElementValue,",
                        "} from \"../print/template-literal.js\";",
                        "import { isAngularComponentTemplate, hasLanguageComment } from \"./utils.js\";",
                        "",
                        "// The counter is needed to distinguish nested embeds.",
                        "let htmlTemplateLiteralCounter = 0;",
                        "async function printEmbedHtmlLike(parser, textToDoc, print, path, options) {",
                        "  const { node } = path;",
                        "  const counter = htmlTemplateLiteralCounter;",
                        "  htmlTemplateLiteralCounter = (htmlTemplateLiteralCounter + 1) >>> 0;",
                        "",
                        "  const composePlaceholder = (index) =>",
                        "    `PRETTIER_HTML_PLACEHOLDER_${index}_${counter}_IN_JS`;",
                        "",
                        "  const text = node.quasis",
                        "    .map((quasi, index, quasis) =>",
                        "      index === quasis.length - 1",
                        "        ? quasi.value.cooked",
                        "        : quasi.value.cooked + composePlaceholder(index)",
                        "    )",
                        "    .join(\"\");",
                        "",
                        "  const expressionDocs = printTemplateExpressions(path, print);",
                        "",
                        "  const placeholderRegex = new RegExp(composePlaceholder(\"(\\\\d+)\"), \"g\");",
                        "  let topLevelCount = 0;",
                        "  const doc = await textToDoc(text, {",
                        "    parser,",
                        "    __onHtmlRoot(root) {",
                        "      topLevelCount = root.children.length;",
                        "    },",
                        "  });",
                        "",
                        "  const contentDoc = mapDoc(doc, (doc) => {",
                        "    if (typeof doc !== \"string\") {",
                        "      return doc;",
                        "    }",
                        "",
                        "    const parts = [];",
                        "",
                        "    const components = doc.split(placeholderRegex);",
                        "    for (let i = 0; i < components.length; i++) {",
                        "      let component = components[i];",
                        "",
                        "      if (i % 2 === 0) {",
                        "        if (component) {",
                        "          component = uncookTemplateElementValue(component);",
                        "          if (options.__embeddedInHtml) {",
                        "            component = component.replaceAll(/<\\/(?=script\\b)/gi, \"<\\\\/\");",
                        "          }",
                        "          parts.push(component);",
                        "        }",
                        "        continue;",
                        "      }",
                        "",
                        "      const placeholderIndex = Number(component);",
                        "      parts.push(expressionDocs[placeholderIndex]);",
                        "    }",
                        "",
                        "    return parts;",
                        "  });",
                        "",
                        "  const leadingWhitespace = /^\\s/.test(text) ? \" \" : \"\";",
                        "  const trailingWhitespace = /\\s$/.test(text) ? \" \" : \"\";",
                        "",
                        "  const linebreak =",
                        "    options.htmlWhitespaceSensitivity === \"ignore\"",
                        "      ? hardline",
                        "      : leadingWhitespace && trailingWhitespace",
                        "      ? line",
                        "      : null;",
                        "",
                        "  if (linebreak) {",
                        "    return group([\"`\", indent([linebreak, group(contentDoc)]), linebreak, \"`\"]);",
                        "  }",
                        "",
                        "  return label(",
                        "    { hug: false },",
                        "    group([",
                        "      \"`\",",
                        "      leadingWhitespace,",
                        "      topLevelCount > 1 ? indent(group(contentDoc)) : group(contentDoc),",
                        "      trailingWhitespace,",
                        "      \"`\",",
                        "    ])",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " *     - html`...`",
                        " *     - HTML comment block",
                        " */",
                        "function isHtml(path) {",
                        "  return (",
                        "    hasLanguageComment(path.node, \"HTML\") ||",
                        "    path.match(",
                        "      (node) => node.type === \"TemplateLiteral\",",
                        "      (node, name) =>",
                        "        node.type === \"TaggedTemplateExpression\" &&",
                        "        node.tag.type === \"Identifier\" &&",
                        "        node.tag.name === \"html\" &&",
                        "        name === \"quasi\"",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "const printEmbedHtml = printEmbedHtmlLike.bind(undefined, \"html\");",
                        "const printEmbedAngular = printEmbedHtmlLike.bind(undefined, \"angular\");",
                        "",
                        "function printHtml(path /*, options*/) {",
                        "  if (isHtml(path)) {",
                        "    return printEmbedHtml;",
                        "  }",
                        "",
                        "  if (isAngularComponentTemplate(path)) {",
                        "    return printEmbedAngular;",
                        "  }",
                        "}",
                        "",
                        "export default printHtml;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { label } from \"../../document/builders.js\";",
                        "import printCss from \"./css.js\";",
                        "import printGraphQL from \"./graphql.js\";",
                        "import printHtml from \"./html.js\";",
                        "import printMarkdown from \"./markdown.js\";",
                        "",
                        "function embed(path) {",
                        "  const { node } = path;",
                        "",
                        "  if (",
                        "    node.type !== \"TemplateLiteral\" ||",
                        "    // Bail out if any of the quasis have an invalid escape sequence",
                        "    // (which would make the `cooked` value be `null`)",
                        "    hasInvalidCookedValue(node)",
                        "  ) {",
                        "    return;",
                        "  }",
                        "",
                        "  let embedder;",
                        "  for (const getEmbedder of [",
                        "    printCss,",
                        "    printGraphQL,",
                        "    printHtml,",
                        "    printMarkdown,",
                        "  ]) {",
                        "    embedder = getEmbedder(path);",
                        "",
                        "    if (!embedder) {",
                        "      continue;",
                        "    }",
                        "",
                        "    // Special case: whitespace-only template literals",
                        "    if (node.quasis.length === 1 && node.quasis[0].value.raw.trim() === \"\") {",
                        "      return \"``\";",
                        "    }",
                        "",
                        "    return async (...args) => {",
                        "      const doc = await embedder(...args);",
                        "      return doc && label({ embed: true, ...doc.label }, doc);",
                        "    };",
                        "  }",
                        "}",
                        "",
                        "function hasInvalidCookedValue({ quasis }) {",
                        "  return quasis.some(({ value: { cooked } }) => cooked === null);",
                        "}",
                        "",
                        "export default embed;"
                    ]
                },
                "markdown.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  indent,",
                        "  softline,",
                        "  literalline,",
                        "  dedentToRoot,",
                        "} from \"../../document/builders.js\";",
                        "import { escapeTemplateCharacters } from \"../print/template-literal.js\";",
                        "",
                        "async function printEmbedMarkdown(textToDoc, print, path /*, options*/) {",
                        "  const { node } = path;",
                        "  let text = node.quasis[0].value.raw.replaceAll(",
                        "    /((?:\\\\\\\\)*)\\\\`/g,",
                        "    (_, backslashes) => \"\\\\\".repeat(backslashes.length / 2) + \"`\"",
                        "  );",
                        "  const indentation = getIndentation(text);",
                        "  const hasIndent = indentation !== \"\";",
                        "  if (hasIndent) {",
                        "    text = text.replaceAll(new RegExp(`^${indentation}`, \"gm\"), \"\");",
                        "  }",
                        "  const doc = escapeTemplateCharacters(",
                        "    await textToDoc(text, { parser: \"markdown\", __inJsTemplate: true }),",
                        "    true",
                        "  );",
                        "  return [",
                        "    \"`\",",
                        "    hasIndent ? indent([softline, doc]) : [literalline, dedentToRoot(doc)],",
                        "    softline,",
                        "    \"`\",",
                        "  ];",
                        "}",
                        "",
                        "function getIndentation(str) {",
                        "  const firstMatchedIndent = str.match(/^([^\\S\\n]*)\\S/m);",
                        "  return firstMatchedIndent === null ? \"\" : firstMatchedIndent[1];",
                        "}",
                        "",
                        "function printMarkdown(path /*, options*/) {",
                        "  if (isMarkdown(path)) {",
                        "    return printEmbedMarkdown;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * md`...`",
                        " * markdown`...`",
                        " */",
                        "function isMarkdown({ node, parent }) {",
                        "  return (",
                        "    parent?.type === \"TaggedTemplateExpression\" &&",
                        "    node.quasis.length === 1 &&",
                        "    parent.tag.type === \"Identifier\" &&",
                        "    (parent.tag.name === \"md\" || parent.tag.name === \"markdown\")",
                        "  );",
                        "}",
                        "",
                        "export default printMarkdown;"
                    ]
                },
                "utils.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isObjectProperty,",
                        "  isArrayOrTupleExpression,",
                        "} from \"../utils/index.js\";",
                        "",
                        "const angularComponentObjectExpressionPredicates = [",
                        "  (node, name) => node.type === \"ObjectExpression\" && name === \"properties\",",
                        "  (node, name) =>",
                        "    node.type === \"CallExpression\" &&",
                        "    node.callee.type === \"Identifier\" &&",
                        "    node.callee.name === \"Component\" &&",
                        "    name === \"arguments\",",
                        "  (node, name) => node.type === \"Decorator\" && name === \"expression\",",
                        "];",
                        "",
                        "/**",
                        " * Angular Components can have:",
                        " * - Inline HTML template",
                        " * - Inline CSS styles",
                        " *",
                        " * ...which are both within template literals somewhere",
                        " * inside of the Component decorator factory.",
                        " *",
                        " * E.g.",
                        " * @Component({",
                        " *  template: `<div>...</div>`,",
                        " *  styles: [`h1 { color: blue; }`]",
                        " * })",
                        " */",
                        "function isAngularComponentStyles(path) {",
                        "  return path.match(",
                        "    (node) => node.type === \"TemplateLiteral\",",
                        "    (node, name) => isArrayOrTupleExpression(node) && name === \"elements\",",
                        "    (node, name) =>",
                        "      isObjectProperty(node) &&",
                        "      node.key.type === \"Identifier\" &&",
                        "      node.key.name === \"styles\" &&",
                        "      name === \"value\",",
                        "    ...angularComponentObjectExpressionPredicates",
                        "  );",
                        "}",
                        "function isAngularComponentTemplate(path) {",
                        "  return path.match(",
                        "    (node) => node.type === \"TemplateLiteral\",",
                        "    (node, name) =>",
                        "      isObjectProperty(node) &&",
                        "      node.key.type === \"Identifier\" &&",
                        "      node.key.name === \"template\" &&",
                        "      name === \"value\",",
                        "    ...angularComponentObjectExpressionPredicates",
                        "  );",
                        "}",
                        "",
                        "function hasLanguageComment(node, languageName) {",
                        "  // This checks for a leading comment that is exactly `/* GraphQL */`",
                        "  // In order to be in line with other implementations of this comment tag",
                        "  // we will not trim the comment value and we will expect exactly one space on",
                        "  // either side of the GraphQL string",
                        "  // Also see ./clean.js",
                        "  return hasComment(",
                        "    node,",
                        "    CommentCheckFlags.Block | CommentCheckFlags.Leading,",
                        "    ({ value }) => value === ` ${languageName} `",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  isAngularComponentStyles,",
                        "  isAngularComponentTemplate,",
                        "  hasLanguageComment,",
                        "};"
                    ]
                }
            },
            "parse": {
                "acorn.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { createRequire } from \"node:module\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import getSourceType from \"./utils/get-source-type.js\";",
                        "",
                        "const require = createRequire(import.meta.url);",
                        "",
                        "/** @type {import(\"acorn\").Options} */",
                        "const parseOptions = {",
                        "  ecmaVersion: \"latest\",",
                        "  // sourceType: \"module\",",
                        "  allowReturnOutsideFunction: true,",
                        "  // allowImportExportEverywhere: true,",
                        "  allowSuperOutsideMethod: true,",
                        "  locations: true,",
                        "  ranges: true,",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, loc } = error;",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (!loc) {",
                        "    return error;",
                        "  }",
                        "",
                        "  const { line, column } = loc;",
                        "",
                        "  return createError(message.replace(/ \\(\\d+:\\d+\\)$/, \"\"), {",
                        "    loc: {",
                        "      start: { line, column: column + 1 },",
                        "    },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "let parser;",
                        "const getParser = () => {",
                        "  if (!parser) {",
                        "    const { Parser: AcornParser } = require(\"acorn\");",
                        "    const acornJsx = require(\"acorn-jsx\");",
                        "    parser = AcornParser.extend(acornJsx());",
                        "  }",
                        "  return parser;",
                        "};",
                        "",
                        "function parseWithOptions(text, sourceType) {",
                        "  const parser = getParser();",
                        "",
                        "  const comments = [];",
                        "  const tokens = [];",
                        "",
                        "  /** @type {any} */",
                        "  const ast = parser.parse(text, {",
                        "    ...parseOptions,",
                        "    sourceType,",
                        "    allowImportExportEverywhere: sourceType === \"module\",",
                        "    onComment: comments,",
                        "    onToken: tokens,",
                        "  });",
                        "  ast.comments = comments;",
                        "  ast.tokens = tokens;",
                        "",
                        "  return ast;",
                        "}",
                        "",
                        "function parse(text, options = {}) {",
                        "  const sourceType = getSourceType(options);",
                        "  const combinations = (sourceType ? [sourceType] : [\"module\", \"script\"]).map(",
                        "    (sourceType) => () => parseWithOptions(text, sourceType)",
                        "  );",
                        "",
                        "  let ast;",
                        "  try {",
                        "    ast = tryCombinations(combinations);",
                        "  } catch ({ errors: [error] }) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  return postprocess(ast, { text });",
                        "}",
                        "",
                        "export const acorn = createParser(parse);"
                    ]
                },
                "angular.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  parseAction,",
                        "  parseBinding,",
                        "  parseInterpolationExpression,",
                        "  parseTemplateBindings,",
                        "} from \"angular-estree-parser\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "",
                        "/**",
                        " * @param {parseAction | parseBinding | parseInterpolationExpression | parseTemplateBindings} parseMethod",
                        " */",
                        "function createParser(parseMethod) {",
                        "  return {",
                        "    astFormat: \"estree\",",
                        "    parse(text) {",
                        "      const node = parseMethod(text);",
                        "",
                        "      return {",
                        "        type: \"NGRoot\",",
                        "        node:",
                        "          parseMethod === parseAction && node.type !== \"NGChainedExpression\"",
                        "            ? { ...node, type: \"NGChainedExpression\", expressions: [node] }",
                        "            : node,",
                        "      };",
                        "    },",
                        "    locStart,",
                        "    locEnd,",
                        "  };",
                        "}",
                        "",
                        "export const __ng_action = createParser(parseAction);",
                        "export const __ng_binding = createParser(parseBinding);",
                        "export const __ng_interpolation = createParser(parseInterpolationExpression);",
                        "export const __ng_directive = createParser(parseTemplateBindings);"
                    ]
                },
                "babel.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { parse as babelParse, parseExpression } from \"@babel/parser\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import getShebang from \"../utils/get-shebang.js\";",
                        "import getNextNonSpaceNonCommentCharacterIndex from \"../../utils/get-next-non-space-non-comment-character-index.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import createBabelParseError from \"./utils/create-babel-parse-error.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import getSourceType from \"./utils/get-source-type.js\";",
                        "import wrapBabelExpression from \"./utils/wrap-babel-expression.js\";",
                        "",
                        "const createBabelParser = (options) => createParser(createParse(options));",
                        "",
                        "/**",
                        " * @typedef {import(\"@babel/parser\").parse | import(\"@babel/parser\").parseExpression} Parse",
                        " * @typedef {import(\"@babel/parser\").ParserOptions} ParserOptions",
                        " * @typedef {import(\"@babel/parser\").ParserPlugin} ParserPlugin",
                        " */",
                        "",
                        "/** @type {ParserOptions} */",
                        "const parseOptions = {",
                        "  sourceType: \"module\",",
                        "  allowImportExportEverywhere: true,",
                        "  allowReturnOutsideFunction: true,",
                        "  allowNewTargetOutsideFunction: true,",
                        "  allowSuperOutsideMethod: true,",
                        "  allowUndeclaredExports: true,",
                        "  errorRecovery: true,",
                        "  createParenthesizedExpressions: true,",
                        "  plugins: [",
                        "    // When adding a plugin, please add a test in `tests/format/js/babel-plugins`,",
                        "    // To remove plugins, remove it here and run `yarn test tests/format/js/babel-plugins` to verify",
                        "    \"doExpressions\",",
                        "    \"exportDefaultFrom\",",
                        "    \"functionBind\",",
                        "    \"functionSent\",",
                        "    \"throwExpressions\",",
                        "    \"partialApplication\",",
                        "    \"decorators\",",
                        "    \"importAssertions\",",
                        "    \"decimal\",",
                        "    \"moduleBlocks\",",
                        "    \"asyncDoExpressions\",",
                        "    \"regexpUnicodeSets\",",
                        "    \"destructuringPrivate\",",
                        "    \"decoratorAutoAccessors\",",
                        "    \"importReflection\",",
                        "    \"explicitResourceManagement\",",
                        "  ],",
                        "  tokens: true,",
                        "  ranges: true,",
                        "};",
                        "",
                        "/** @type {ParserPlugin} */",
                        "const recordAndTuplePlugin = [\"recordAndTuple\", { syntaxType: \"hash\" }];",
                        "",
                        "/** @type {ParserPlugin} */",
                        "const v8intrinsicPlugin = \"v8intrinsic\";",
                        "",
                        "/** @type {Array<ParserPlugin>} */",
                        "const pipelineOperatorPlugins = [",
                        "  [\"pipelineOperator\", { proposal: \"hack\", topicToken: \"%\" }],",
                        "  [\"pipelineOperator\", { proposal: \"minimal\" }],",
                        "  [\"pipelineOperator\", { proposal: \"fsharp\" }],",
                        "];",
                        "const appendPlugins = (plugins, options = parseOptions) => ({",
                        "  ...options,",
                        "  plugins: [...options.plugins, ...plugins],",
                        "});",
                        "",
                        "// Similar to babel",
                        "// https://github.com/babel/babel/pull/7934/files#diff-a739835084910b0ee3ea649df5a4d223R67",
                        "const FLOW_PRAGMA_REGEX = /@(?:no)?flow\\b/;",
                        "function isFlowFile(text, options) {",
                        "  if (options.filepath?.endsWith(\".js.flow\")) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const shebang = getShebang(text);",
                        "  if (shebang) {",
                        "    text = text.slice(shebang.length);",
                        "  }",
                        "",
                        "  const firstNonSpaceNonCommentCharacterIndex =",
                        "    getNextNonSpaceNonCommentCharacterIndex(text, 0);",
                        "",
                        "  if (firstNonSpaceNonCommentCharacterIndex !== false) {",
                        "    text = text.slice(0, firstNonSpaceNonCommentCharacterIndex);",
                        "  }",
                        "",
                        "  return FLOW_PRAGMA_REGEX.test(text);",
                        "}",
                        "",
                        "function parseWithOptions(parse, text, options) {",
                        "  const ast = parse(text, options);",
                        "  const error = ast.errors.find(",
                        "    (error) => !allowedMessageCodes.has(error.reasonCode)",
                        "  );",
                        "  if (error) {",
                        "    throw error;",
                        "  }",
                        "  return ast;",
                        "}",
                        "",
                        "function createParse({ isExpression = false, optionsCombinations }) {",
                        "  return (text, options = {}) => {",
                        "    if (",
                        "      (options.parser === \"babel\" || options.parser === \"__babel_estree\") &&",
                        "      isFlowFile(text, options)",
                        "    ) {",
                        "      options.parser = \"babel-flow\";",
                        "      return babelFlow.parse(text, options);",
                        "    }",
                        "",
                        "    let combinations = optionsCombinations;",
                        "    const sourceType = options.__babelSourceType ?? getSourceType(options);",
                        "    if (sourceType === \"script\") {",
                        "      combinations = combinations.map((options) => ({",
                        "        ...options,",
                        "        sourceType: \"script\",",
                        "      }));",
                        "    }",
                        "",
                        "    if (/#[[{]/.test(text)) {",
                        "      combinations = combinations.map((options) =>",
                        "        appendPlugins([recordAndTuplePlugin], options)",
                        "      );",
                        "    }",
                        "",
                        "    const shouldEnableV8intrinsicPlugin = /%[A-Z]/.test(text);",
                        "    if (text.includes(\"|>\")) {",
                        "      const conflictsPlugins = shouldEnableV8intrinsicPlugin",
                        "        ? [...pipelineOperatorPlugins, v8intrinsicPlugin]",
                        "        : pipelineOperatorPlugins;",
                        "      combinations = conflictsPlugins.flatMap((pipelineOperatorPlugin) =>",
                        "        combinations.map((options) =>",
                        "          appendPlugins([pipelineOperatorPlugin], options)",
                        "        )",
                        "      );",
                        "    } else if (shouldEnableV8intrinsicPlugin) {",
                        "      combinations = combinations.map((options) =>",
                        "        appendPlugins([v8intrinsicPlugin], options)",
                        "      );",
                        "    }",
                        "",
                        "    /** @type {Parse} */",
                        "    const parseFunction = isExpression ? parseExpression : babelParse;",
                        "",
                        "    let ast;",
                        "    try {",
                        "      ast = tryCombinations(",
                        "        combinations.map(",
                        "          (options) => () => parseWithOptions(parseFunction, text, options)",
                        "        )",
                        "      );",
                        "    } catch ({ errors: [error] }) {",
                        "      throw createBabelParseError(error);",
                        "    }",
                        "",
                        "    if (isExpression) {",
                        "      ast = wrapBabelExpression(ast, { text, rootMarker: options.rootMarker });",
                        "    }",
                        "",
                        "    return postprocess(ast, { parser: \"babel\", text });",
                        "  };",
                        "}",
                        "",
                        "// Error codes are defined in",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/parser/error-message.js",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/typescript/index.js#L69-L153",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/flow/index.js#L51-L140",
                        "//  - https://github.com/babel/babel/blob/v7.14.0/packages/babel-parser/src/plugins/jsx/index.js#L23-L39",
                        "const allowedMessageCodes = new Set([",
                        "  \"StrictNumericEscape\",",
                        "  \"StrictWith\",",
                        "  \"StrictOctalLiteral\",",
                        "  \"StrictDelete\",",
                        "  \"StrictEvalArguments\",",
                        "  \"StrictEvalArgumentsBinding\",",
                        "  \"StrictFunction\",",
                        "",
                        "  \"EmptyTypeArguments\",",
                        "  \"EmptyTypeParameters\",",
                        "  \"ConstructorHasTypeParameters\",",
                        "",
                        "  \"UnsupportedParameterPropertyKind\",",
                        "",
                        "  \"MixedLabeledAndUnlabeledElements\",",
                        "",
                        "  \"DuplicateAccessibilityModifier\",",
                        "",
                        "  \"DecoratorExportClass\",",
                        "  \"ParamDupe\",",
                        "  \"InvalidDecimal\",",
                        "  \"RestTrailingComma\",",
                        "  \"UnsupportedParameterDecorator\",",
                        "  \"UnterminatedJsxContent\",",
                        "  \"UnexpectedReservedWord\",",
                        "  \"ModuleAttributesWithDuplicateKeys\",",
                        "  \"LineTerminatorBeforeArrow\",",
                        "  \"InvalidEscapeSequenceTemplate\",",
                        "  \"NonAbstractClassHasAbstractMethod\",",
                        "  \"OptionalTypeBeforeRequired\",",
                        "  \"PatternIsOptional\",",
                        "  \"OptionalBindingPattern\",",
                        "  \"DeclareClassFieldHasInitializer\",",
                        "  \"TypeImportCannotSpecifyDefaultAndNamed\",",
                        "  \"DeclareFunctionHasImplementation\",",
                        "  \"ConstructorClassField\",",
                        "",
                        "  \"VarRedeclaration\",",
                        "  \"InvalidPrivateFieldResolution\",",
                        "  \"DuplicateExport\",",
                        "]);",
                        "",
                        "const babelParserOptionsCombinations = [appendPlugins([\"jsx\"])];",
                        "const babel = createBabelParser({",
                        "  optionsCombinations: babelParserOptionsCombinations,",
                        "});",
                        "const babelTs = createBabelParser({",
                        "  optionsCombinations: [",
                        "    appendPlugins([\"jsx\", \"typescript\"]),",
                        "    appendPlugins([\"typescript\"]),",
                        "  ],",
                        "});",
                        "const babelExpression = createBabelParser({",
                        "  isExpression: true,",
                        "  optionsCombinations: [appendPlugins([\"jsx\"])],",
                        "});",
                        "const babelTSExpression = createBabelParser({",
                        "  isExpression: true,",
                        "  optionsCombinations: [appendPlugins([\"typescript\"])],",
                        "});",
                        "const babelFlow = createBabelParser({",
                        "  optionsCombinations: [",
                        "    appendPlugins([",
                        "      \"jsx\",",
                        "      [\"flow\", { all: true, enums: true }],",
                        "      \"flowComments\",",
                        "    ]),",
                        "  ],",
                        "});",
                        "const babelEstree = createBabelParser({",
                        "  optionsCombinations: babelParserOptionsCombinations.map((options) =>",
                        "    appendPlugins([\"estree\"], options)",
                        "  ),",
                        "});",
                        "",
                        "export default {",
                        "  babel,",
                        "  \"babel-flow\": babelFlow,",
                        "  \"babel-ts\": babelTs,",
                        "  /** @internal */",
                        "  __js_expression: babelExpression,",
                        "  __ts_expression: babelTSExpression,",
                        "  /** for vue filter */",
                        "  __vue_expression: babelExpression,",
                        "  /** for vue filter written in TS */",
                        "  __vue_ts_expression: babelTSExpression,",
                        "  /** for vue event binding to handle semicolon */",
                        "  __vue_event_binding: babel,",
                        "  /** for vue event binding written in TS to handle semicolon */",
                        "  __vue_ts_event_binding: babelTs,",
                        "  /** verify that we can print this AST */",
                        "  __babel_estree: babelEstree,",
                        "};"
                    ]
                },
                "espree.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { createRequire } from \"node:module\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import getSourceType from \"./utils/get-source-type.js\";",
                        "",
                        "const require = createRequire(import.meta.url);",
                        "",
                        "/** @type {import(\"espree\").Options} */",
                        "const parseOptions = {",
                        "  ecmaVersion: \"latest\",",
                        "  range: true,",
                        "  loc: true,",
                        "  comment: true,",
                        "  tokens: true,",
                        "  sourceType: \"module\",",
                        "  ecmaFeatures: {",
                        "    jsx: true,",
                        "    globalReturn: true,",
                        "    impliedStrict: false,",
                        "  },",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, lineNumber, column } = error;",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (typeof lineNumber !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, {",
                        "    loc: { start: { line: lineNumber, column } },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "function parse(text, options = {}) {",
                        "  const { parse: espreeParse } = require(\"espree\");",
                        "",
                        "  const sourceType = getSourceType(options);",
                        "  const combinations = (sourceType ? [sourceType] : [\"module\", \"script\"]).map(",
                        "    (/** @type {\"module\"|\"script\"} */ sourceType) => () =>",
                        "      espreeParse(text, { ...parseOptions, sourceType })",
                        "  );",
                        "",
                        "  let ast;",
                        "  try {",
                        "    ast = tryCombinations(combinations);",
                        "  } catch ({ errors: [error] }) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  return postprocess(ast, { text });",
                        "}",
                        "",
                        "export const espree = createParser(parse);"
                    ]
                },
                "flow.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import flowParser from \"flow-parser\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import replaceHashbang from \"./utils/replace-hashbang.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "",
                        "// https://github.com/facebook/flow/tree/main/packages/flow-parser#options",
                        "// Keep this sync with `/scripts/sync-flow-test.js`",
                        "const parseOptions = {",
                        "  // `all_comments` (boolean, default `true`) - include a list of all comments from the whole program",
                        "  // all_comments: true,",
                        "  // `comments` (boolean, default `true`) - attach comments to AST nodes (`leadingComments` and `trailingComments`)",
                        "  comments: false,",
                        "  // `enums` (boolean, default `false`) - enable parsing of Flow enums",
                        "  enums: true,",
                        "  // `esproposal_decorators` (boolean, default `false`) - enable parsing of decorators",
                        "  esproposal_decorators: true,",
                        "  // `esproposal_export_star_as` (boolean, default `false`) - enable parsing of `export * as` syntax",
                        "  esproposal_export_star_as: true,",
                        "  // `types` (boolean, default `true`) - enable parsing of Flow types",
                        "  // types: true,",
                        "  // `use_strict` (boolean, default `false`) - treat the file as strict, without needing a \"use strict\" directive",
                        "  // use_strict: false,",
                        "  // `tokens` (boolean, default `false`) - include a list of all parsed tokens in a top-level `tokens` property",
                        "  tokens: true,",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const {",
                        "    message,",
                        "    loc: { start, end },",
                        "  } = error;",
                        "",
                        "  return createError(message, {",
                        "    loc: {",
                        "      start: { line: start.line, column: start.column + 1 },",
                        "      end: { line: end.line, column: end.column + 1 },",
                        "    },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "function parse(text) {",
                        "  const ast = flowParser.parse(replaceHashbang(text), parseOptions);",
                        "  const [error] = ast.errors;",
                        "  if (error) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  return postprocess(ast, { text });",
                        "}",
                        "",
                        "export const flow = createParser(parse);"
                    ]
                },
                "meriyah.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { parse as meriyahParse } from \"meriyah\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import getSourceType from \"./utils/get-source-type.js\";",
                        "",
                        "// https://github.com/meriyah/meriyah/blob/4676f60b6c149d7082bde2c9147f9ae2359c8075/src/parser.ts#L185",
                        "const parseOptions = {",
                        "  // Allow module code",
                        "  // module: true,",
                        "  // Enable stage 3 support (ESNext)",
                        "  next: true,",
                        "  // Enable start and end offsets to each node",
                        "  ranges: true,",
                        "  // Enable web compatibility",
                        "  webcompat: true,",
                        "  // Enable line/column location information to each node",
                        "  loc: true,",
                        "  // Attach raw property to each literal and identifier node",
                        "  raw: true,",
                        "  // Enabled directives",
                        "  directives: true,",
                        "  // Allow return in the global scope",
                        "  globalReturn: true,",
                        "  // Enable implied strict mode",
                        "  impliedStrict: false,",
                        "  // Enable non-standard parenthesized expression node",
                        "  preserveParens: false,",
                        "  // Enable lexical binding and scope tracking",
                        "  lexical: false,",
                        "  // Adds a source attribute in every nodes loc object when the locations option is `true`",
                        "  // source: '',",
                        "  // Distinguish Identifier from IdentifierPattern",
                        "  identifierPattern: false,",
                        "  // Enable React JSX parsing",
                        "  jsx: true,",
                        "  // Allow edge cases that deviate from the spec",
                        "  specDeviation: true,",
                        "  // Creates unique key for in ObjectPattern when key value are same",
                        "  uniqueKeyInPattern: false,",
                        "};",
                        "",
                        "function parseWithOptions(text, sourceType) {",
                        "  const comments = [];",
                        "  const tokens = [];",
                        "",
                        "  /** @type {any} */",
                        "  const ast = meriyahParse(text, {",
                        "    ...parseOptions,",
                        "    module: sourceType === \"module\",",
                        "    onComment: comments,",
                        "    onToken: tokens,",
                        "  });",
                        "  ast.comments = comments;",
                        "  ast.tokens = tokens;",
                        "",
                        "  return ast;",
                        "}",
                        "",
                        "function createParseError(error) {",
                        "  let { message, line, column } = error;",
                        "",
                        "  const matches = message.match(",
                        "    /^\\[(?<line>\\d+):(?<column>\\d+)]: (?<message>.*)$/",
                        "  )?.groups;",
                        "",
                        "  if (matches) {",
                        "    message = matches.message;",
                        "",
                        "    /* c8 ignore next 4 */",
                        "    if (typeof line !== \"number\") {",
                        "      line = Number(matches.line);",
                        "      column = Number(matches.column);",
                        "    }",
                        "  }",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (typeof line !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, {",
                        "    loc: { start: { line, column } },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "function parse(text, options = {}) {",
                        "  const sourceType = getSourceType(options);",
                        "  const combinations = (sourceType ? [sourceType] : [\"module\", \"script\"]).map(",
                        "    (sourceType) => () => parseWithOptions(text, sourceType)",
                        "  );",
                        "",
                        "  let ast;",
                        "  try {",
                        "    ast = tryCombinations(combinations);",
                        "  } catch ({ errors: [error] }) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  return postprocess(ast, { parser: \"meriyah\", text });",
                        "}",
                        "",
                        "export const meriyah = createParser(parse);"
                    ]
                },
                "typescript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { parseWithNodeMaps } from \"@typescript-eslint/typescript-estree/dist/parser.js\";",
                        "import createError from \"../../common/parser-create-error.js\";",
                        "import tryCombinations from \"../../utils/try-combinations.js\";",
                        "import createParser from \"./utils/create-parser.js\";",
                        "import replaceHashbang from \"./utils/replace-hashbang.js\";",
                        "import postprocess from \"./postprocess/index.js\";",
                        "import { throwErrorForInvalidNodes } from \"./postprocess/typescript.js\";",
                        "",
                        "/** @type {import(\"@typescript-eslint/typescript-estree\").TSESTreeOptions} */",
                        "const parseOptions = {",
                        "  // `jest@<=26.4.2` rely on `loc`",
                        "  // https://github.com/facebook/jest/issues/10444",
                        "  // Set `loc` and `range` to `true` also prevent AST traverse",
                        "  // https://github.com/typescript-eslint/typescript-eslint/blob/733b3598c17d3a712cf6f043115587f724dbe3ef/packages/typescript-estree/src/ast-converter.ts#L38",
                        "  loc: true,",
                        "  range: true,",
                        "  comment: true,",
                        "  jsx: true,",
                        "  tokens: true,",
                        "  loggerFn: false,",
                        "  project: [],",
                        "};",
                        "",
                        "function createParseError(error) {",
                        "  const { message, lineNumber, column } = error;",
                        "",
                        "  /* c8 ignore next 3 */",
                        "  if (typeof lineNumber !== \"number\") {",
                        "    return error;",
                        "  }",
                        "",
                        "  return createError(message, {",
                        "    loc: {",
                        "      start: { line: lineNumber, column: column + 1 },",
                        "    },",
                        "    cause: error,",
                        "  });",
                        "}",
                        "",
                        "function parse(text) {",
                        "  const textToParse = replaceHashbang(text);",
                        "  const jsx = isProbablyJsx(text);",
                        "",
                        "  let result;",
                        "  try {",
                        "    result = tryCombinations([",
                        "      // Try passing with our best guess first.",
                        "      () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx }),",
                        "      // But if we get it wrong, try the opposite.",
                        "      () => parseWithNodeMaps(textToParse, { ...parseOptions, jsx: !jsx }),",
                        "    ]);",
                        "  } catch ({",
                        "    errors: [",
                        "      // Suppose our guess is correct, throw the first error",
                        "      error,",
                        "    ],",
                        "  }) {",
                        "    throw createParseError(error);",
                        "  }",
                        "",
                        "  throwErrorForInvalidNodes(result, text);",
                        "",
                        "  return postprocess(result.ast, { parser: \"typescript\", text });",
                        "}",
                        "",
                        "/**",
                        " * Use a naive regular expression to detect JSX",
                        " */",
                        "function isProbablyJsx(text) {",
                        "  return new RegExp(",
                        "    [",
                        "      \"(?:^[^\\\"'`]*</)\", // Contains \"</\" when probably not in a string",
                        "      \"|\",",
                        "      \"(?:^[^/]{2}.*/>)\", // Contains \"/>\" on line not starting with \"//\"",
                        "    ].join(\"\"),",
                        "    \"m\"",
                        "  ).test(text);",
                        "}",
                        "",
                        "export const typescript = createParser(parse);"
                    ]
                },
                "postprocess": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { locStart, locEnd } from \"../../loc.js\";",
                            "import isTypeCastComment from \"../../utils/is-type-cast-comment.js\";",
                            "import isNonEmptyArray from \"../../../utils/is-non-empty-array.js\";",
                            "import isBlockComment from \"../../utils/is-block-comment.js\";",
                            "import isIndentableBlockComment from \"../../utils/is-indentable-block-comment.js\";",
                            "import visitNode from \"./visit-node.js\";",
                            "import throwSyntaxError from \"./throw-ts-syntax-error.js\";",
                            "",
                            "/**",
                            " * @param {{",
                            " *   text: string,",
                            " *   parser?: string,",
                            " * }} options",
                            " */",
                            "function postprocess(ast, options) {",
                            "  const { parser, text } = options;",
                            "",
                            "  // `InterpreterDirective` from babel parser",
                            "  // Other parsers parse it as comment, babel treat it as comment too",
                            "  // https://github.com/babel/babel/issues/15116",
                            "  if (ast.type === \"File\" && ast.program.interpreter) {",
                            "    const {",
                            "      program: { interpreter },",
                            "      comments,",
                            "    } = ast;",
                            "    delete ast.program.interpreter;",
                            "    comments.unshift(interpreter);",
                            "  }",
                            "",
                            "  // Keep Babel's non-standard ParenthesizedExpression nodes only if they have Closure-style type cast comments.",
                            "  if (parser === \"babel\") {",
                            "    const startOffsetsOfTypeCastedNodes = new Set();",
                            "",
                            "    // Comments might be attached not directly to ParenthesizedExpression but to its ancestor.",
                            "    // E.g.: /** @type {Foo} */ (foo).bar();",
                            "    // Let's use the fact that those ancestors and ParenthesizedExpression have the same start offset.",
                            "",
                            "    ast = visitNode(ast, (node) => {",
                            "      if (node.leadingComments?.some(isTypeCastComment)) {",
                            "        startOffsetsOfTypeCastedNodes.add(locStart(node));",
                            "      }",
                            "    });",
                            "",
                            "    ast = visitNode(ast, (node) => {",
                            "      if (node.type === \"ParenthesizedExpression\") {",
                            "        const { expression } = node;",
                            "",
                            "        // Align range with `flow`",
                            "        if (expression.type === \"TypeCastExpression\") {",
                            "          expression.range = node.range;",
                            "          return expression;",
                            "        }",
                            "",
                            "        const start = locStart(node);",
                            "        if (!startOffsetsOfTypeCastedNodes.has(start)) {",
                            "          expression.extra = { ...expression.extra, parenthesized: true };",
                            "          return expression;",
                            "        }",
                            "      }",
                            "    });",
                            "  }",
                            "",
                            "  ast = visitNode(ast, (node) => {",
                            "    switch (node.type) {",
                            "      case \"LogicalExpression\":",
                            "        // We remove unneeded parens around same-operator LogicalExpressions",
                            "        if (isUnbalancedLogicalTree(node)) {",
                            "          return rebalanceLogicalTree(node);",
                            "        }",
                            "        break;",
                            "",
                            "      // fix unexpected locEnd caused by --no-semi style",
                            "      case \"VariableDeclaration\": {",
                            "        const lastDeclaration = node.declarations.at(-1);",
                            "        if (lastDeclaration?.init) {",
                            "          overrideLocEnd(node, lastDeclaration);",
                            "        }",
                            "        break;",
                            "      }",
                            "      // remove redundant TypeScript nodes",
                            "      case \"TSParenthesizedType\":",
                            "        return node.typeAnnotation;",
                            "",
                            "      case \"TSTypeParameter\":",
                            "        // babel-ts",
                            "        if (typeof node.name === \"string\") {",
                            "          const start = locStart(node);",
                            "          node.name = {",
                            "            type: \"Identifier\",",
                            "            name: node.name,",
                            "            range: [start, start + node.name.length],",
                            "          };",
                            "        }",
                            "        break;",
                            "      case \"ObjectExpression\":",
                            "        // #12963",
                            "        if (parser === \"typescript\") {",
                            "          const invalidProperty = node.properties.find(",
                            "            (property) =>",
                            "              property.type === \"Property\" &&",
                            "              property.value.type === \"TSEmptyBodyFunctionExpression\"",
                            "          );",
                            "          if (invalidProperty) {",
                            "            throwSyntaxError(invalidProperty.value, \"Unexpected token.\");",
                            "          }",
                            "        }",
                            "        break;",
                            "      case \"TSInterfaceDeclaration\":",
                            "        if (isNonEmptyArray(node.implements)) {",
                            "          throwSyntaxError(",
                            "            node.implements[0],",
                            "            \"Interface declaration cannot have 'implements' clause.\"",
                            "          );",
                            "        }",
                            "        break;",
                            "",
                            "      case \"TSPropertySignature\":",
                            "        if (node.initializer) {",
                            "          throwSyntaxError(",
                            "            node.initializer,",
                            "            \"An interface property cannot have an initializer.\"",
                            "          );",
                            "        }",
                            "        break;",
                            "",
                            "      // For hack-style pipeline",
                            "      case \"TopicReference\":",
                            "        ast.extra = { ...ast.extra, __isUsingHackPipeline: true };",
                            "        break;",
                            "",
                            "      // TODO: Remove this when https://github.com/meriyah/meriyah/issues/200 get fixed",
                            "      case \"ExportAllDeclaration\": {",
                            "        const { exported } = node;",
                            "        if (parser === \"meriyah\" && exported?.type === \"Identifier\") {",
                            "          const raw = text.slice(locStart(exported), locEnd(exported));",
                            "          if (raw.startsWith('\"') || raw.startsWith(\"'\")) {",
                            "            node.exported = {",
                            "              ...node.exported,",
                            "              type: \"Literal\",",
                            "              value: node.exported.name,",
                            "              raw,",
                            "            };",
                            "          }",
                            "        }",
                            "        break;",
                            "      }",
                            "      // In Flow parser, it doesn't generate union/intersection types for single type",
                            "      case \"TSUnionType\":",
                            "      case \"TSIntersectionType\":",
                            "        if (node.types.length === 1) {",
                            "          return node.types[0];",
                            "        }",
                            "        break;",
                            "    }",
                            "  });",
                            "",
                            "  if (isNonEmptyArray(ast.comments)) {",
                            "    let followingComment = ast.comments.at(-1);",
                            "    for (let i = ast.comments.length - 2; i >= 0; i--) {",
                            "      const comment = ast.comments[i];",
                            "      if (",
                            "        locEnd(comment) === locStart(followingComment) &&",
                            "        isBlockComment(comment) &&",
                            "        isBlockComment(followingComment) &&",
                            "        isIndentableBlockComment(comment) &&",
                            "        isIndentableBlockComment(followingComment)",
                            "      ) {",
                            "        ast.comments.splice(i + 1, 1);",
                            "        comment.value += \"*//*\" + followingComment.value;",
                            "        comment.range = [locStart(comment), locEnd(followingComment)];",
                            "      }",
                            "      followingComment = comment;",
                            "    }",
                            "  }",
                            "",
                            "  // In `typescript`/`espree`/`flow`, `Program` doesn't count whitespace and comments",
                            "  // See https://github.com/eslint/espree/issues/488",
                            "  if (ast.type === \"Program\") {",
                            "    ast.range = [0, text.length];",
                            "  }",
                            "  return ast;",
                            "",
                            "  /**",
                            "   * - `toOverrideNode` must be the last thing in `toBeOverriddenNode`",
                            "   * - do nothing if there's a semicolon on `toOverrideNode.end` (no need to fix)",
                            "   */",
                            "  function overrideLocEnd(toBeOverriddenNode, toOverrideNode) {",
                            "    if (text[locEnd(toOverrideNode)] === \";\") {",
                            "      return;",
                            "    }",
                            "    toBeOverriddenNode.range = [",
                            "      locStart(toBeOverriddenNode),",
                            "      locEnd(toOverrideNode),",
                            "    ];",
                            "  }",
                            "}",
                            "",
                            "function isUnbalancedLogicalTree(node) {",
                            "  return (",
                            "    node.type === \"LogicalExpression\" &&",
                            "    node.right.type === \"LogicalExpression\" &&",
                            "    node.operator === node.right.operator",
                            "  );",
                            "}",
                            "",
                            "function rebalanceLogicalTree(node) {",
                            "  if (!isUnbalancedLogicalTree(node)) {",
                            "    return node;",
                            "  }",
                            "",
                            "  return rebalanceLogicalTree({",
                            "    type: \"LogicalExpression\",",
                            "    operator: node.operator,",
                            "    left: rebalanceLogicalTree({",
                            "      type: \"LogicalExpression\",",
                            "      operator: node.operator,",
                            "      left: node.left,",
                            "      right: node.right.left,",
                            "      range: [locStart(node.left), locEnd(node.right.left)],",
                            "    }),",
                            "    right: node.right.right,",
                            "    range: [locStart(node), locEnd(node)],",
                            "  });",
                            "}",
                            "",
                            "export default postprocess;"
                        ]
                    },
                    "throw-ts-syntax-error.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import createError from \"../../../common/parser-create-error.js\";",
                            "",
                            "function throwSyntaxError(node, message) {",
                            "  const { start, end } = node.loc;",
                            "  throw createError(message, {",
                            "    loc: {",
                            "      start: { line: start.line, column: start.column + 1 },",
                            "      end: { line: end.line, column: end.column + 1 },",
                            "    },",
                            "  });",
                            "}",
                            "",
                            "export default throwSyntaxError;"
                        ]
                    },
                    "typescript.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import ts from \"typescript\";",
                            "import isNonEmptyArray from \"../../../utils/is-non-empty-array.js\";",
                            "import visitNode from \"./visit-node.js\";",
                            "import throwTsSyntaxError from \"./throw-ts-syntax-error.js\";",
                            "",
                            "function getTsNodeLocation(nodeOrToken) {",
                            "  const sourceFile =",
                            "    // @ts-expect-error -- internal?",
                            "    ts.getSourceFileOfNode(nodeOrToken);",
                            "  const position =",
                            "    // @ts-expect-error -- internal?",
                            "    ts.rangeOfNode(nodeOrToken);",
                            "  const [start, end] = [position.pos, position.end].map((position) => {",
                            "    const { line, character: column } =",
                            "      sourceFile.getLineAndCharacterOfPosition(position);",
                            "    return { line: line + 1, column };",
                            "  });",
                            "",
                            "  return { start, end };",
                            "}",
                            "",
                            "function throwErrorOnTsNode(node, message) {",
                            "  throwTsSyntaxError({ loc: getTsNodeLocation(node) }, message);",
                            "}",
                            "",
                            "// Values of abstract property is removed since `@typescript-eslint/typescript-estree` v5",
                            "// https://github.com/typescript-eslint/typescript-eslint/releases/tag/v5.0.0",
                            "function throwErrorForInvalidAbstractProperty(tsNode, esTreeNode) {",
                            "  if (",
                            "    !(",
                            "      tsNode.kind === ts.SyntaxKind.PropertyDeclaration &&",
                            "      tsNode.initializer &&",
                            "      esTreeNode.value === null &&",
                            "      tsNode.modifiers?.some(",
                            "        (modifier) => modifier.kind === ts.SyntaxKind.AbstractKeyword",
                            "      )",
                            "    )",
                            "  ) {",
                            "    return;",
                            "  }",
                            "",
                            "  throwTsSyntaxError(",
                            "    esTreeNode,",
                            "    \"Abstract property cannot have an initializer\"",
                            "  );",
                            "}",
                            "",
                            "function nodeCanBeDecorated(node) {",
                            "  return [true, false].some((useLegacyDecorators) =>",
                            "    // @ts-expect-error -- internal?",
                            "    ts.nodeCanBeDecorated(",
                            "      useLegacyDecorators,",
                            "      node,",
                            "      node.parent,",
                            "      node.parent.parent",
                            "    )",
                            "  );",
                            "}",
                            "",
                            "// Based on `checkGrammarModifiers` function in `typescript`",
                            "function throwErrorForInvalidModifier(node) {",
                            "  const { modifiers } = node;",
                            "  if (!isNonEmptyArray(modifiers)) {",
                            "    return;",
                            "  }",
                            "",
                            "  const { SyntaxKind } = ts;",
                            "",
                            "  for (const modifier of modifiers) {",
                            "    if (ts.isDecorator(modifier) && !nodeCanBeDecorated(node)) {",
                            "      if (",
                            "        node.kind === SyntaxKind.MethodDeclaration &&",
                            "        // @ts-expect-error -- internal?",
                            "        !ts.nodeIsPresent(node.body)",
                            "      ) {",
                            "        throwErrorOnTsNode(",
                            "          modifier,",
                            "          \"A decorator can only decorate a method implementation, not an overload.\"",
                            "        );",
                            "      }",
                            "",
                            "      throwErrorOnTsNode(modifier, \"Decorators are not valid here.\");",
                            "    }",
                            "",
                            "    if (modifier.kind !== SyntaxKind.ReadonlyKeyword) {",
                            "      if (",
                            "        node.kind === SyntaxKind.PropertySignature ||",
                            "        node.kind === SyntaxKind.MethodSignature",
                            "      ) {",
                            "        throwErrorOnTsNode(",
                            "          modifier,",
                            "          `'${ts.tokenToString(",
                            "            modifier.kind",
                            "          )}' modifier cannot appear on a type member`",
                            "        );",
                            "      }",
                            "",
                            "      if (",
                            "        node.kind === SyntaxKind.IndexSignature &&",
                            "        (modifier.kind !== SyntaxKind.StaticKeyword ||",
                            "          !ts.isClassLike(node.parent))",
                            "      ) {",
                            "        throwErrorOnTsNode(",
                            "          modifier,",
                            "          `'${ts.tokenToString(",
                            "            modifier.kind",
                            "          )}' modifier cannot appear on an index signature`",
                            "        );",
                            "      }",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind !== SyntaxKind.InKeyword &&",
                            "      modifier.kind !== SyntaxKind.OutKeyword &&",
                            "      modifier.kind !== SyntaxKind.ConstKeyword &&",
                            "      node.kind === SyntaxKind.TypeParameter",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier cannot appear on a type parameter`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      (modifier.kind === SyntaxKind.InKeyword ||",
                            "        modifier.kind === SyntaxKind.OutKeyword) &&",
                            "      (node.kind !== SyntaxKind.TypeParameter ||",
                            "        !(",
                            "          ts.isInterfaceDeclaration(node.parent) ||",
                            "          ts.isClassLike(node.parent) ||",
                            "          ts.isTypeAliasDeclaration(node.parent)",
                            "        ))",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier can only appear on a type parameter of a class, interface or type alias`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind === SyntaxKind.ReadonlyKeyword &&",
                            "      node.kind !== SyntaxKind.PropertyDeclaration &&",
                            "      node.kind !== SyntaxKind.PropertySignature &&",
                            "      node.kind !== SyntaxKind.IndexSignature &&",
                            "      node.kind !== SyntaxKind.Parameter",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        \"'readonly' modifier can only appear on a property declaration or index signature.\"",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind === SyntaxKind.DeclareKeyword &&",
                            "      ts.isClassLike(node.parent) &&",
                            "      !ts.isPropertyDeclaration(node)",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier cannot appear on class elements of this kind.`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind === SyntaxKind.AbstractKeyword &&",
                            "      node.kind !== SyntaxKind.ClassDeclaration &&",
                            "      node.kind !== SyntaxKind.ConstructorType &&",
                            "      node.kind !== SyntaxKind.MethodDeclaration &&",
                            "      node.kind !== SyntaxKind.PropertyDeclaration &&",
                            "      node.kind !== SyntaxKind.GetAccessor &&",
                            "      node.kind !== SyntaxKind.SetAccessor",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier can only appear on a class, method, or property declaration.`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      (modifier.kind === SyntaxKind.StaticKeyword ||",
                            "        modifier.kind === SyntaxKind.PublicKeyword ||",
                            "        modifier.kind === SyntaxKind.ProtectedKeyword ||",
                            "        modifier.kind === SyntaxKind.PrivateKeyword) &&",
                            "      (node.parent.kind === SyntaxKind.ModuleBlock ||",
                            "        node.parent.kind === SyntaxKind.SourceFile)",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier cannot appear on a module or namespace element.`",
                            "      );",
                            "    }",
                            "",
                            "    if (",
                            "      modifier.kind === SyntaxKind.AccessorKeyword &&",
                            "      node.kind !== SyntaxKind.PropertyDeclaration",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        \"'accessor' modifier can only appear on a property declaration.\"",
                            "      );",
                            "    }",
                            "",
                            "    // `checkGrammarAsyncModifier` function in `typescript`",
                            "    if (",
                            "      modifier.kind === SyntaxKind.AsyncKeyword &&",
                            "      node.kind !== SyntaxKind.MethodDeclaration &&",
                            "      node.kind !== SyntaxKind.FunctionDeclaration &&",
                            "      node.kind !== SyntaxKind.FunctionExpression &&",
                            "      node.kind !== SyntaxKind.ArrowFunction",
                            "    ) {",
                            "      throwErrorOnTsNode(modifier, \"'async' modifier cannot be used here.\");",
                            "    }",
                            "",
                            "    // `checkGrammarModifiers` function in `typescript`",
                            "    if (",
                            "      node.kind === SyntaxKind.Parameter &&",
                            "      (modifier.kind === SyntaxKind.StaticKeyword ||",
                            "        modifier.kind === SyntaxKind.ExportKeyword ||",
                            "        modifier.kind === SyntaxKind.DeclareKeyword ||",
                            "        modifier.kind === SyntaxKind.AsyncKeyword)",
                            "    ) {",
                            "      throwErrorOnTsNode(",
                            "        modifier,",
                            "        `'${ts.tokenToString(",
                            "          modifier.kind",
                            "        )}' modifier cannot appear on a parameter.`",
                            "      );",
                            "    }",
                            "",
                            "    // `checkParameter` function in `typescript`",
                            "    if (",
                            "      node.kind === SyntaxKind.Parameter &&",
                            "      // @ts-expect-error -- internal?",
                            "      ts.hasSyntacticModifier(node, ts.ModifierFlags.ParameterPropertyModifier)",
                            "    ) {",
                            "      const func =",
                            "        // @ts-expect-error -- internal?",
                            "        ts.getContainingFunction(node);",
                            "      if (",
                            "        !(",
                            "          func.kind === SyntaxKind.Constructor &&",
                            "          // @ts-expect-error -- internal?",
                            "          ts.nodeIsPresent(func.body)",
                            "        )",
                            "      ) {",
                            "        throwErrorOnTsNode(",
                            "          modifier,",
                            "          \"A parameter property is only allowed in a constructor implementation.\"",
                            "        );",
                            "      }",
                            "    }",
                            "  }",
                            "}",
                            "",
                            "function getTsNode(node, tsParseResult) {",
                            "  const { esTreeNodeToTSNodeMap, tsNodeToESTreeNodeMap } = tsParseResult;",
                            "  const tsNode = esTreeNodeToTSNodeMap.get(node);",
                            "  if (!tsNode) {",
                            "    return;",
                            "  }",
                            "",
                            "  const esTreeNode = tsNodeToESTreeNodeMap.get(tsNode);",
                            "  if (esTreeNode !== node) {",
                            "    return;",
                            "  }",
                            "",
                            "  return tsNode;",
                            "}",
                            "",
                            "// `isModifierKind` in `typescript`",
                            "const POSSIBLE_MODIFIERS = [",
                            "  \"abstract\",",
                            "  \"accessor\",",
                            "  \"async\",",
                            "  \"const\",",
                            "  \"declare\",",
                            "  \"default\",",
                            "  \"export\",",
                            "  \"in\",",
                            "  \"out\",",
                            "  \"override\",",
                            "  \"private\",",
                            "  \"protected\",",
                            "  \"public\",",
                            "  \"readonly\",",
                            "  \"static\",",
                            "];",
                            "",
                            "const decoratorOrModifierRegExp = new RegExp(",
                            "  [\"@\", ...POSSIBLE_MODIFIERS].join(\"|\")",
                            ");",
                            "",
                            "function throwErrorForInvalidNodes(tsParseResult, text) {",
                            "  if (!decoratorOrModifierRegExp.test(text)) {",
                            "    return;",
                            "  }",
                            "",
                            "  visitNode(tsParseResult.ast, (esTreeNode) => {",
                            "    const tsNode = getTsNode(esTreeNode, tsParseResult);",
                            "    if (!tsNode) {",
                            "      return;",
                            "    }",
                            "",
                            "    throwErrorForInvalidAbstractProperty(tsNode, esTreeNode);",
                            "    throwErrorForInvalidModifier(tsNode);",
                            "  });",
                            "}",
                            "",
                            "export {",
                            "  throwErrorForInvalidNodes,",
                            "  // For test",
                            "  POSSIBLE_MODIFIERS,",
                            "};"
                        ]
                    },
                    "visit-node.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import getVisitorKeys from \"../../traverse/get-visitor-keys.js\";",
                            "",
                            "function visitNode(node, fn) {",
                            "  if (!(node !== null && typeof node === \"object\")) {",
                            "    return node;",
                            "  }",
                            "",
                            "  if (Array.isArray(node)) {",
                            "    // As of Node.js 16 using raw for loop over Array.entries provides a",
                            "    // measurable difference in performance. Array.entries returns an iterator",
                            "    // of arrays.",
                            "    for (let i = 0; i < node.length; i++) {",
                            "      node[i] = visitNode(node[i], fn);",
                            "    }",
                            "    return node;",
                            "  }",
                            "",
                            "  const keys = getVisitorKeys(node);",
                            "  for (let i = 0; i < keys.length; i++) {",
                            "    node[keys[i]] = visitNode(node[keys[i]], fn);",
                            "  }",
                            "",
                            "  return fn(node) || node;",
                            "}",
                            "",
                            "export default visitNode;"
                        ]
                    }
                },
                "utils": {
                    "create-babel-parse-error.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import createError from \"../../../common/parser-create-error.js\";",
                            "",
                            "function createBabelParseError(error) {",
                            "  // babel error prints (line:column) with cols that are zero indexed",
                            "  // so we need our custom error",
                            "  const { message, loc } = error;",
                            "",
                            "  return createError(message.replace(/ \\(.*\\)$/, \"\"), {",
                            "    loc: {",
                            "      start: {",
                            "        line: loc ? loc.line : 0,",
                            "        column: loc ? loc.column + 1 : 0,",
                            "      },",
                            "    },",
                            "    cause: error,",
                            "  });",
                            "}",
                            "",
                            "export default createBabelParseError;"
                        ]
                    },
                    "create-parser.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "import { hasPragma } from \"../../pragma.js\";",
                            "import { locStart, locEnd } from \"../../loc.js\";",
                            "",
                            "function createParser(options) {",
                            "  options = typeof options === \"function\" ? { parse: options } : options;",
                            "",
                            "  return {",
                            "    astFormat: \"estree\",",
                            "    hasPragma,",
                            "    locStart,",
                            "    locEnd,",
                            "    ...options,",
                            "  };",
                            "}",
                            "",
                            "export default createParser;"
                        ]
                    },
                    "get-source-type.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "/** @returns {\"module\" | \"script\" | undefined} */",
                            "function getSourceType(options) {",
                            "  let { filepath } = options;",
                            "  if (!filepath) {",
                            "    return;",
                            "  }",
                            "  filepath = filepath.toLowerCase();",
                            "",
                            "  if (filepath.endsWith(\".cjs\")) {",
                            "    return \"script\";",
                            "  }",
                            "",
                            "  if (filepath.endsWith(\".mjs\")) {",
                            "    return \"module\";",
                            "  }",
                            "}",
                            "",
                            "export default getSourceType;"
                        ]
                    },
                    "replace-hashbang.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "// Replace `#!` with `//` so `typescript`, `flow`, and `espree` can parse it as line comment",
                            "// Inspired by ESLint parse function https://github.com/eslint/eslint/blob/9d6063add931f0803cae1676d5df307baf114360/lib/linter/linter.js#L635",
                            "function replaceHashbang(text) {",
                            "  if (text.charAt(0) === \"#\" && text.charAt(1) === \"!\") {",
                            "    return \"//\" + text.slice(2);",
                            "  }",
                            "",
                            "  return text;",
                            "}",
                            "",
                            "export default replaceHashbang;"
                        ]
                    },
                    "wrap-babel-expression.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "/**",
                            " * @param {{",
                            " *   text: string,",
                            " *   type?: string,",
                            " *   rootMarker?: string,",
                            " * }} options",
                            " */",
                            "function wrapBabelExpression(expression, options) {",
                            "  const { type = \"JsExpressionRoot\", rootMarker, text } = options;",
                            "",
                            "  const { tokens, comments } = expression;",
                            "  delete expression.tokens;",
                            "  delete expression.comments;",
                            "",
                            "  return {",
                            "    tokens,",
                            "    comments,",
                            "    type,",
                            "    node: expression,",
                            "    range: [0, text.length],",
                            "    rootMarker,",
                            "  };",
                            "}",
                            "",
                            "export default wrapBabelExpression;"
                        ]
                    }
                }
            },
            "print": {
                "angular.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { join, line, group } from \"../../document/builders.js\";",
                        "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                        "import {",
                        "  hasNode,",
                        "  hasComment,",
                        "  getComments,",
                        "  createTypeCheckFunction,",
                        "} from \"../utils/index.js\";",
                        "import { printBinaryishExpression } from \"./binaryish.js\";",
                        "",
                        "/** @typedef {import(\"../../common/ast-path.js\").default} AstPath */",
                        "",
                        "function printAngular(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  // Angular nodes always starts with `NG`",
                        "  if (!node.type.startsWith(\"NG\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"NGRoot\":",
                        "      return [",
                        "        print(\"node\"),",
                        "        hasComment(node.node)",
                        "          ? \" //\" + getComments(node.node)[0].value.trimEnd()",
                        "          : \"\",",
                        "      ];",
                        "    case \"NGPipeExpression\":",
                        "      return printBinaryishExpression(path, options, print);",
                        "    case \"NGChainedExpression\":",
                        "      return group(",
                        "        join(",
                        "          [\";\", line],",
                        "          path.map(",
                        "            () => (hasNgSideEffect(path) ? print() : [\"(\", print(), \")\"]),",
                        "            \"expressions\"",
                        "          )",
                        "        )",
                        "      );",
                        "    case \"NGEmptyExpression\":",
                        "      return \"\";",
                        "    case \"NGMicrosyntax\":",
                        "      return path.map(",
                        "        () => [",
                        "          path.isFirst ? \"\" : isNgForOf(path) ? \" \" : [\";\", line],",
                        "          print(),",
                        "        ],",
                        "        \"body\"",
                        "      );",
                        "    case \"NGMicrosyntaxKey\":",
                        "      return /^[$_a-z][\\w$]*(?:-[$_a-z][\\w$])*$/i.test(node.name)",
                        "        ? node.name",
                        "        : JSON.stringify(node.name);",
                        "    case \"NGMicrosyntaxExpression\":",
                        "      return [",
                        "        print(\"expression\"),",
                        "        node.alias === null ? \"\" : [\" as \", print(\"alias\")],",
                        "      ];",
                        "    case \"NGMicrosyntaxKeyedExpression\": {",
                        "      const { index, parent } = path;",
                        "      const shouldNotPrintColon =",
                        "        isNgForOf(path) ||",
                        "        (((index === 1 &&",
                        "          (node.key.name === \"then\" || node.key.name === \"else\")) ||",
                        "          (index === 2 &&",
                        "            node.key.name === \"else\" &&",
                        "            parent.body[index - 1].type === \"NGMicrosyntaxKeyedExpression\" &&",
                        "            parent.body[index - 1].key.name === \"then\")) &&",
                        "          parent.body[0].type === \"NGMicrosyntaxExpression\");",
                        "      return [",
                        "        print(\"key\"),",
                        "        shouldNotPrintColon ? \" \" : \": \",",
                        "        print(\"expression\"),",
                        "      ];",
                        "    }",
                        "    case \"NGMicrosyntaxLet\":",
                        "      return [",
                        "        \"let \",",
                        "        print(\"key\"),",
                        "        node.value === null ? \"\" : [\" = \", print(\"value\")],",
                        "      ];",
                        "    case \"NGMicrosyntaxAs\":",
                        "      return [print(\"key\"), \" as \", print(\"alias\")];",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      throw new UnexpectedNodeError(node, \"Angular\");",
                        "  }",
                        "}",
                        "",
                        "function isNgForOf({ node, index, parent }) {",
                        "  return (",
                        "    node.type === \"NGMicrosyntaxKeyedExpression\" &&",
                        "    node.key.name === \"of\" &&",
                        "    index === 1 &&",
                        "    parent.body[0].type === \"NGMicrosyntaxLet\" &&",
                        "    parent.body[0].value === null",
                        "  );",
                        "}",
                        "",
                        "const hasSideEffect = createTypeCheckFunction([",
                        "  \"CallExpression\",",
                        "  \"OptionalCallExpression\",",
                        "  \"AssignmentExpression\",",
                        "]);",
                        "/** identify if an angular expression seems to have side effects */",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function hasNgSideEffect({ node }) {",
                        "  return hasNode(node, hasSideEffect);",
                        "}",
                        "",
                        "export { printAngular };"
                    ]
                },
                "array.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  line,",
                        "  softline,",
                        "  hardline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "  fill,",
                        "} from \"../../document/builders.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import {",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "  isNumericLiteral,",
                        "  isSignedNumericLiteral,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import { locStart } from \"../loc.js\";",
                        "",
                        "import { printOptionalToken } from \"./misc.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "function printEmptyArray(path, options, openBracket, closeBracket) {",
                        "  const { node } = path;",
                        "  if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    return [openBracket, closeBracket];",
                        "  }",
                        "  return group([",
                        "    openBracket,",
                        "    printDanglingComments(path, options, { indent: true }),",
                        "    softline,",
                        "    closeBracket,",
                        "  ]);",
                        "}",
                        "",
                        "/*",
                        "- `ArrayExpression`",
                        "- `TupleExpression`",
                        "- `ArrayPattern`",
                        "- `TSTupleType`(TypeScript)",
                        "- `TupleTypeAnnotation`(Flow)",
                        "*/",
                        "function printArray(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "",
                        "  const openBracket = node.type === \"TupleExpression\" ? \"#[\" : \"[\";",
                        "  const closeBracket = \"]\";",
                        "  const elementsProperty =",
                        "    // TODO: Remove `types` when babel changes AST of `TupleTypeAnnotation`",
                        "    node.type === \"TupleTypeAnnotation\" && node.types",
                        "      ? \"types\"",
                        "      : node.type === \"TSTupleType\" || node.type === \"TupleTypeAnnotation\"",
                        "      ? \"elementTypes\"",
                        "      : \"elements\";",
                        "  const elements = node[elementsProperty];",
                        "  if (elements.length === 0) {",
                        "    parts.push(printEmptyArray(path, options, openBracket, closeBracket));",
                        "  } else {",
                        "    const lastElem = elements.at(-1);",
                        "    const canHaveTrailingComma = lastElem?.type !== \"RestElement\";",
                        "",
                        "    // JavaScript allows you to have empty elements in an array which",
                        "    // changes its length based on the number of commas. The algorithm",
                        "    // is that if the last argument is null, we need to force insert",
                        "    // a comma to ensure JavaScript recognizes it.",
                        "    //   [,].length === 1",
                        "    //   [1,].length === 1",
                        "    //   [1,,].length === 2",
                        "    //",
                        "    // Note that getLast returns null if the array is empty, but",
                        "    // we already check for an empty array just above so we are safe",
                        "    const needsForcedTrailingComma = lastElem === null;",
                        "",
                        "    const groupId = Symbol(\"array\");",
                        "",
                        "    const shouldBreak =",
                        "      !options.__inJestEach &&",
                        "      elements.length > 1 &&",
                        "      elements.every((element, i, elements) => {",
                        "        const elementType = element?.type;",
                        "        if (",
                        "          !isArrayOrTupleExpression(element) &&",
                        "          !isObjectOrRecordExpression(element)",
                        "        ) {",
                        "          return false;",
                        "        }",
                        "",
                        "        const nextElement = elements[i + 1];",
                        "        if (nextElement && elementType !== nextElement.type) {",
                        "          return false;",
                        "        }",
                        "",
                        "        const itemsKey = isArrayOrTupleExpression(element)",
                        "          ? \"elements\"",
                        "          : \"properties\";",
                        "",
                        "        return element[itemsKey] && element[itemsKey].length > 1;",
                        "      });",
                        "",
                        "    const shouldUseConciseFormatting = isConciselyPrintedArray(node, options);",
                        "",
                        "    const trailingComma = !canHaveTrailingComma",
                        "      ? \"\"",
                        "      : needsForcedTrailingComma",
                        "      ? \",\"",
                        "      : !shouldPrintComma(options)",
                        "      ? \"\"",
                        "      : shouldUseConciseFormatting",
                        "      ? ifBreak(\",\", \"\", { groupId })",
                        "      : ifBreak(\",\");",
                        "",
                        "    parts.push(",
                        "      group(",
                        "        [",
                        "          openBracket,",
                        "          indent([",
                        "            softline,",
                        "            shouldUseConciseFormatting",
                        "              ? printArrayItemsConcisely(path, options, print, trailingComma)",
                        "              : [",
                        "                  printArrayItems(path, options, elementsProperty, print),",
                        "                  trailingComma,",
                        "                ],",
                        "            printDanglingComments(path, options),",
                        "          ]),",
                        "          softline,",
                        "          closeBracket,",
                        "        ],",
                        "        { shouldBreak, id: groupId }",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printOptionalToken(path),",
                        "    printTypeAnnotationProperty(path, print)",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function isConciselyPrintedArray(node, options) {",
                        "  return (",
                        "    isArrayOrTupleExpression(node) &&",
                        "    node.elements.length > 1 &&",
                        "    node.elements.every(",
                        "      (element) =>",
                        "        element &&",
                        "        (isNumericLiteral(element) ||",
                        "          (isSignedNumericLiteral(element) && !hasComment(element.argument))) &&",
                        "        !hasComment(",
                        "          element,",
                        "          CommentCheckFlags.Trailing | CommentCheckFlags.Line,",
                        "          (comment) =>",
                        "            !hasNewline(options.originalText, locStart(comment), {",
                        "              backwards: true,",
                        "            })",
                        "        )",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function printArrayItems(path, options, elementsProperty, print) {",
                        "  const parts = [];",
                        "",
                        "  path.each(({ node, isLast }) => {",
                        "    parts.push(node ? group(print()) : \"\");",
                        "",
                        "    if (!isLast) {",
                        "      parts.push([",
                        "        \",\",",
                        "        line,",
                        "        node && isNextLineEmpty(node, options) ? softline : \"\",",
                        "      ]);",
                        "    }",
                        "  }, elementsProperty);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrayItemsConcisely(path, options, print, trailingComma) {",
                        "  const parts = [];",
                        "",
                        "  path.each(({ node, isLast, next }) => {",
                        "    parts.push([print(), isLast ? trailingComma : \",\"]);",
                        "",
                        "    if (!isLast) {",
                        "      parts.push(",
                        "        isNextLineEmpty(node, options)",
                        "          ? [hardline, hardline]",
                        "          : hasComment(next, CommentCheckFlags.Leading | CommentCheckFlags.Line)",
                        "          ? hardline",
                        "          : line",
                        "      );",
                        "    }",
                        "  }, \"elements\");",
                        "",
                        "  return fill(parts);",
                        "}",
                        "",
                        "export { printArray, isConciselyPrintedArray };"
                    ]
                },
                "assignment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import getStringWidth from \"../../utils/get-string-width.js\";",
                        "import {",
                        "  line,",
                        "  group,",
                        "  indent,",
                        "  indentIfBreak,",
                        "  lineSuffixBoundary,",
                        "} from \"../../document/builders.js\";",
                        "import { cleanDoc, willBreak, canBreak } from \"../../document/utils.js\";",
                        "import {",
                        "  hasLeadingOwnLineComment,",
                        "  isBinaryish,",
                        "  isStringLiteral,",
                        "  isNumericLiteral,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  getCallArguments,",
                        "  rawText,",
                        "  hasComment,",
                        "  isSignedNumericLiteral,",
                        "  isObjectProperty,",
                        "  createTypeCheckFunction,",
                        "} from \"../utils/index.js\";",
                        "import { shouldInlineLogicalExpression } from \"./binaryish.js\";",
                        "import { printCallExpression } from \"./call-expression.js\";",
                        "import { isLiteral } from \"./literal.js\";",
                        "",
                        "function printAssignment(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  leftDoc,",
                        "  operator,",
                        "  rightPropertyName",
                        ") {",
                        "  const layout = chooseLayout(path, options, print, leftDoc, rightPropertyName);",
                        "",
                        "  const rightDoc = rightPropertyName",
                        "    ? print(rightPropertyName, { assignmentLayout: layout })",
                        "    : \"\";",
                        "",
                        "  switch (layout) {",
                        "    // First break after operator, then the sides are broken independently on their own lines",
                        "    case \"break-after-operator\":",
                        "      return group([group(leftDoc), operator, group(indent([line, rightDoc]))]);",
                        "",
                        "    // First break right-hand side, then left-hand side",
                        "    case \"never-break-after-operator\":",
                        "      return group([group(leftDoc), operator, \" \", rightDoc]);",
                        "",
                        "    // First break right-hand side, then after operator",
                        "    case \"fluid\": {",
                        "      const groupId = Symbol(\"assignment\");",
                        "      return group([",
                        "        group(leftDoc),",
                        "        operator,",
                        "        group(indent(line), { id: groupId }),",
                        "        lineSuffixBoundary,",
                        "        indentIfBreak(rightDoc, { groupId }),",
                        "      ]);",
                        "    }",
                        "",
                        "    case \"break-lhs\":",
                        "      return group([leftDoc, operator, \" \", group(rightDoc)]);",
                        "",
                        "    // Parts of assignment chains aren't wrapped in groups.",
                        "    // Once one of them breaks, the chain breaks too.",
                        "    case \"chain\":",
                        "      return [group(leftDoc), operator, line, rightDoc];",
                        "",
                        "    case \"chain-tail\":",
                        "      return [group(leftDoc), operator, indent([line, rightDoc])];",
                        "",
                        "    case \"chain-tail-arrow-chain\":",
                        "      return [group(leftDoc), operator, rightDoc];",
                        "",
                        "    case \"only-left\":",
                        "      return leftDoc;",
                        "  }",
                        "}",
                        "",
                        "function printAssignmentExpression(path, options, print) {",
                        "  const { node } = path;",
                        "  return printAssignment(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    print(\"left\"),",
                        "    [\" \", node.operator],",
                        "    \"right\"",
                        "  );",
                        "}",
                        "",
                        "function printVariableDeclarator(path, options, print) {",
                        "  return printAssignment(path, options, print, print(\"id\"), \" =\", \"init\");",
                        "}",
                        "",
                        "function chooseLayout(path, options, print, leftDoc, rightPropertyName) {",
                        "  const { node } = path;",
                        "  const rightNode = node[rightPropertyName];",
                        "",
                        "  if (!rightNode) {",
                        "    return \"only-left\";",
                        "  }",
                        "",
                        "  // Short assignment chains (only 2 segments) are NOT formatted as chains.",
                        "  //   1) a = b = c; (expression statements)",
                        "  //   2) var/let/const a = b = c;",
                        "",
                        "  const isTail = !isAssignment(rightNode);",
                        "  const shouldUseChainFormatting = path.match(",
                        "    isAssignment,",
                        "    isAssignmentOrVariableDeclarator,",
                        "    (node) =>",
                        "      !isTail ||",
                        "      (node.type !== \"ExpressionStatement\" &&",
                        "        node.type !== \"VariableDeclaration\")",
                        "  );",
                        "  if (shouldUseChainFormatting) {",
                        "    return !isTail",
                        "      ? \"chain\"",
                        "      : rightNode.type === \"ArrowFunctionExpression\" &&",
                        "        rightNode.body.type === \"ArrowFunctionExpression\"",
                        "      ? \"chain-tail-arrow-chain\"",
                        "      : \"chain-tail\";",
                        "  }",
                        "  const isHeadOfLongChain = !isTail && isAssignment(rightNode.right);",
                        "",
                        "  if (",
                        "    isHeadOfLongChain ||",
                        "    hasLeadingOwnLineComment(options.originalText, rightNode)",
                        "  ) {",
                        "    return \"break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    (rightNode.type === \"CallExpression\" &&",
                        "      rightNode.callee.name === \"require\") ||",
                        "    // do not put values on a separate line from the key in json",
                        "    options.parser === \"json5\" ||",
                        "    options.parser === \"json\"",
                        "  ) {",
                        "    return \"never-break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    isComplexDestructuring(node) ||",
                        "    isComplexTypeAliasParams(node) ||",
                        "    hasComplexTypeAnnotation(node) ||",
                        "    (isArrowFunctionVariableDeclarator(node) && canBreak(leftDoc))",
                        "  ) {",
                        "    return \"break-lhs\";",
                        "  }",
                        "",
                        "  // wrapping object properties with very short keys usually doesn't add much value",
                        "  const hasShortKey = isObjectPropertyWithShortKey(node, leftDoc, options);",
                        "",
                        "  if (",
                        "    path.call(",
                        "      () => shouldBreakAfterOperator(path, options, print, hasShortKey),",
                        "      rightPropertyName",
                        "    )",
                        "  ) {",
                        "    return \"break-after-operator\";",
                        "  }",
                        "",
                        "  if (",
                        "    hasShortKey ||",
                        "    rightNode.type === \"TemplateLiteral\" ||",
                        "    rightNode.type === \"TaggedTemplateExpression\" ||",
                        "    rightNode.type === \"BooleanLiteral\" ||",
                        "    isNumericLiteral(rightNode) ||",
                        "    rightNode.type === \"ClassExpression\"",
                        "  ) {",
                        "    return \"never-break-after-operator\";",
                        "  }",
                        "",
                        "  return \"fluid\";",
                        "}",
                        "",
                        "function shouldBreakAfterOperator(path, options, print, hasShortKey) {",
                        "  const rightNode = path.node;",
                        "",
                        "  if (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (rightNode.type) {",
                        "    case \"StringLiteralTypeAnnotation\":",
                        "    case \"SequenceExpression\":",
                        "      return true;",
                        "    case \"ConditionalExpression\": {",
                        "      const { test } = rightNode;",
                        "      return isBinaryish(test) && !shouldInlineLogicalExpression(test);",
                        "    }",
                        "    case \"ClassExpression\":",
                        "      return isNonEmptyArray(rightNode.decorators);",
                        "  }",
                        "",
                        "  if (hasShortKey) {",
                        "    return false;",
                        "  }",
                        "",
                        "  let node = rightNode;",
                        "  const propertiesForPath = [];",
                        "  for (;;) {",
                        "    if (node.type === \"UnaryExpression\") {",
                        "      node = node.argument;",
                        "      propertiesForPath.push(\"argument\");",
                        "    } else if (node.type === \"TSNonNullExpression\") {",
                        "      node = node.expression;",
                        "      propertiesForPath.push(\"expression\");",
                        "    } else {",
                        "      break;",
                        "    }",
                        "  }",
                        "  if (",
                        "    isStringLiteral(node) ||",
                        "    path.call(",
                        "      () => isPoorlyBreakableMemberOrCallChain(path, options, print),",
                        "      ...propertiesForPath",
                        "    )",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "// prefer to break destructuring assignment",
                        "// if it includes default values or non-shorthand properties",
                        "function isComplexDestructuring(node) {",
                        "  if (isAssignmentOrVariableDeclarator(node)) {",
                        "    const leftNode = node.left || node.id;",
                        "    return (",
                        "      leftNode.type === \"ObjectPattern\" &&",
                        "      leftNode.properties.length > 2 &&",
                        "      leftNode.properties.some(",
                        "        (property) =>",
                        "          isObjectProperty(property) &&",
                        "          (!property.shorthand || property.value?.type === \"AssignmentPattern\")",
                        "      )",
                        "    );",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function isAssignment(node) {",
                        "  return node.type === \"AssignmentExpression\";",
                        "}",
                        "",
                        "function isAssignmentOrVariableDeclarator(node) {",
                        "  return isAssignment(node) || node.type === \"VariableDeclarator\";",
                        "}",
                        "",
                        "function isComplexTypeAliasParams(node) {",
                        "  const typeParams = getTypeParametersFromTypeAlias(node);",
                        "  if (isNonEmptyArray(typeParams)) {",
                        "    const constraintPropertyName =",
                        "      node.type === \"TSTypeAliasDeclaration\" ? \"constraint\" : \"bound\";",
                        "    if (",
                        "      typeParams.length > 1 &&",
                        "      typeParams.some((param) => param[constraintPropertyName] || param.default)",
                        "    ) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "const isTypeAlias = createTypeCheckFunction([",
                        "  \"TSTypeAliasDeclaration\",",
                        "  \"TypeAlias\",",
                        "]);",
                        "function getTypeParametersFromTypeAlias(node) {",
                        "  if (isTypeAlias(node)) {",
                        "    return node.typeParameters?.params;",
                        "  }",
                        "}",
                        "",
                        "function hasComplexTypeAnnotation(node) {",
                        "  if (node.type !== \"VariableDeclarator\") {",
                        "    return false;",
                        "  }",
                        "  const { typeAnnotation } = node.id;",
                        "  if (!typeAnnotation || !typeAnnotation.typeAnnotation) {",
                        "    return false;",
                        "  }",
                        "  const typeParams = getTypeParametersFromTypeReference(",
                        "    typeAnnotation.typeAnnotation",
                        "  );",
                        "  return (",
                        "    isNonEmptyArray(typeParams) &&",
                        "    typeParams.length > 1 &&",
                        "    typeParams.some(",
                        "      (param) =>",
                        "        isNonEmptyArray(getTypeParametersFromTypeReference(param)) ||",
                        "        param.type === \"TSConditionalType\"",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "function isArrowFunctionVariableDeclarator(node) {",
                        "  return (",
                        "    node.type === \"VariableDeclarator\" &&",
                        "    node.init?.type === \"ArrowFunctionExpression\"",
                        "  );",
                        "}",
                        "",
                        "const isTypeReference = createTypeCheckFunction([",
                        "  \"TSTypeReference\",",
                        "  \"GenericTypeAnnotation\",",
                        "]);",
                        "function getTypeParametersFromTypeReference(node) {",
                        "  if (isTypeReference(node)) {",
                        "    return node.typeParameters?.params;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * A chain with no calls at all or whose calls are all without arguments or with lone short arguments,",
                        " * excluding chains printed by `printMemberChain`",
                        " */",
                        "function isPoorlyBreakableMemberOrCallChain(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  deep = false",
                        ") {",
                        "  const { node } = path;",
                        "  const goDeeper = () =>",
                        "    isPoorlyBreakableMemberOrCallChain(path, options, print, true);",
                        "",
                        "  if (node.type === \"ChainExpression\" || node.type === \"TSNonNullExpression\") {",
                        "    return path.call(goDeeper, \"expression\");",
                        "  }",
                        "",
                        "  if (isCallExpression(node)) {",
                        "    /** @type {any} TODO */",
                        "    const doc = printCallExpression(path, options, print);",
                        "    if (doc.label?.memberChain) {",
                        "      return false;",
                        "    }",
                        "",
                        "    const args = getCallArguments(node);",
                        "    const isPoorlyBreakableCall =",
                        "      args.length === 0 ||",
                        "      (args.length === 1 && isLoneShortArgument(args[0], options));",
                        "    if (!isPoorlyBreakableCall) {",
                        "      return false;",
                        "    }",
                        "",
                        "    if (isCallExpressionWithComplexTypeArguments(node, print)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    return path.call(goDeeper, \"callee\");",
                        "  }",
                        "",
                        "  if (isMemberExpression(node)) {",
                        "    return path.call(goDeeper, \"object\");",
                        "  }",
                        "",
                        "  return deep && (node.type === \"Identifier\" || node.type === \"ThisExpression\");",
                        "}",
                        "",
                        "const LONE_SHORT_ARGUMENT_THRESHOLD_RATE = 0.25;",
                        "",
                        "function isLoneShortArgument(node, { printWidth }) {",
                        "  if (hasComment(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const threshold = printWidth * LONE_SHORT_ARGUMENT_THRESHOLD_RATE;",
                        "",
                        "  if (",
                        "    node.type === \"ThisExpression\" ||",
                        "    (node.type === \"Identifier\" && node.name.length <= threshold) ||",
                        "    (isSignedNumericLiteral(node) && !hasComment(node.argument))",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  const regexpPattern =",
                        "    (node.type === \"Literal\" && \"regex\" in node && node.regex.pattern) ||",
                        "    (node.type === \"RegExpLiteral\" && node.pattern);",
                        "",
                        "  if (regexpPattern) {",
                        "    return regexpPattern.length <= threshold;",
                        "  }",
                        "",
                        "  if (isStringLiteral(node)) {",
                        "    return rawText(node).length <= threshold;",
                        "  }",
                        "",
                        "  if (node.type === \"TemplateLiteral\") {",
                        "    return (",
                        "      node.expressions.length === 0 &&",
                        "      node.quasis[0].value.raw.length <= threshold &&",
                        "      !node.quasis[0].value.raw.includes(\"\\n\")",
                        "    );",
                        "  }",
                        "",
                        "  return isLiteral(node);",
                        "}",
                        "",
                        "function isObjectPropertyWithShortKey(node, keyDoc, options) {",
                        "  if (!isObjectProperty(node)) {",
                        "    return false;",
                        "  }",
                        "  // TODO: for performance, it might make sense to use a more lightweight",
                        "  // version of cleanDoc, such that it would stop once it detects that",
                        "  // the doc can't be reduced to a string.",
                        "  keyDoc = cleanDoc(keyDoc);",
                        "  const MIN_OVERLAP_FOR_BREAK = 3;",
                        "  //    - insufficient overlap for a line break",
                        "  // key1: longValue1,",
                        "  //    - overlap is long enough to break",
                        "  // key2abcd:",
                        "  //   longValue2",
                        "  return (",
                        "    typeof keyDoc === \"string\" &&",
                        "    getStringWidth(keyDoc) < options.tabWidth + MIN_OVERLAP_FOR_BREAK",
                        "  );",
                        "}",
                        "",
                        "function isCallExpressionWithComplexTypeArguments(node, print) {",
                        "  const typeArgs = getTypeArgumentsFromCallExpression(node);",
                        "  if (isNonEmptyArray(typeArgs)) {",
                        "    if (typeArgs.length > 1) {",
                        "      return true;",
                        "    }",
                        "    if (typeArgs.length === 1) {",
                        "      const firstArg = typeArgs[0];",
                        "      if (",
                        "        firstArg.type === \"TSUnionType\" ||",
                        "        firstArg.type === \"UnionTypeAnnotation\" ||",
                        "        firstArg.type === \"TSIntersectionType\" ||",
                        "        firstArg.type === \"IntersectionTypeAnnotation\" ||",
                        "        firstArg.type === \"TSTypeLiteral\" ||",
                        "        firstArg.type === \"ObjectTypeAnnotation\"",
                        "      ) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "    const typeArgsKeyName = node.typeParameters",
                        "      ? \"typeParameters\"",
                        "      : \"typeArguments\";",
                        "    if (willBreak(print(typeArgsKeyName))) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "function getTypeArgumentsFromCallExpression(node) {",
                        "  return (node.typeParameters ?? node.typeArguments)?.params;",
                        "}",
                        "",
                        "export {",
                        "  printVariableDeclarator,",
                        "  printAssignmentExpression,",
                        "  printAssignment,",
                        "  isArrowFunctionVariableDeclarator,",
                        "};"
                    ]
                },
                "binaryish.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printComments } from \"../../main/comments/print.js\";",
                        "import { DOC_TYPE_FILL, DOC_TYPE_GROUP } from \"../../document/constants.js\";",
                        "import {",
                        "  join,",
                        "  line,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  align,",
                        "  indentIfBreak,",
                        "} from \"../../document/builders.js\";",
                        "import { cleanDoc, getDocParts } from \"../../document/utils.js\";",
                        "import {",
                        "  hasLeadingOwnLineComment,",
                        "  isBinaryish,",
                        "  isJsxElement,",
                        "  shouldFlatten,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isObjectProperty,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "",
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "let uid = 0;",
                        "function printBinaryishExpression(path, options, print) {",
                        "  const { node, parent, grandparent, key } = path;",
                        "  const isInsideParenthesis =",
                        "    key !== \"body\" &&",
                        "    (parent.type === \"IfStatement\" ||",
                        "      parent.type === \"WhileStatement\" ||",
                        "      parent.type === \"SwitchStatement\" ||",
                        "      parent.type === \"DoWhileStatement\");",
                        "  const isHackPipeline =",
                        "    node.operator === \"|>\" && path.root.extra?.__isUsingHackPipeline;",
                        "",
                        "  const parts = printBinaryishExpressions(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    /* isNested */ false,",
                        "    isInsideParenthesis",
                        "  );",
                        "",
                        "  //   if (",
                        "  //     this.hasPlugin(\"dynamicImports\") && this.lookahead().type === tt.parenLeft",
                        "  //   ) {",
                        "  //",
                        "  // looks super weird, we want to break the children if the parent breaks",
                        "  //",
                        "  //   if (",
                        "  //     this.hasPlugin(\"dynamicImports\") &&",
                        "  //     this.lookahead().type === tt.parenLeft",
                        "  //   ) {",
                        "  if (isInsideParenthesis) {",
                        "    return parts;",
                        "  }",
                        "",
                        "  if (isHackPipeline) {",
                        "    return group(parts);",
                        "  }",
                        "",
                        "  // Break between the parens in",
                        "  // unaries or in a member or specific call expression, i.e.",
                        "  //",
                        "  //   (",
                        "  //     a &&",
                        "  //     b &&",
                        "  //     c",
                        "  //   ).call()",
                        "  if (",
                        "    (isCallExpression(parent) && parent.callee === node) ||",
                        "    parent.type === \"UnaryExpression\" ||",
                        "    (isMemberExpression(parent) && !parent.computed)",
                        "  ) {",
                        "    return group([indent([softline, ...parts]), softline]);",
                        "  }",
                        "",
                        "  // Avoid indenting sub-expressions in some cases where the first sub-expression is already",
                        "  // indented accordingly. We should indent sub-expressions where the first case isn't indented.",
                        "  const shouldNotIndent =",
                        "    parent.type === \"ReturnStatement\" ||",
                        "    parent.type === \"ThrowStatement\" ||",
                        "    (parent.type === \"JSXExpressionContainer\" &&",
                        "      grandparent.type === \"JSXAttribute\") ||",
                        "    (node.operator !== \"|\" && parent.type === \"JsExpressionRoot\") ||",
                        "    (node.type !== \"NGPipeExpression\" &&",
                        "      ((parent.type === \"NGRoot\" && options.parser === \"__ng_binding\") ||",
                        "        (parent.type === \"NGMicrosyntaxExpression\" &&",
                        "          grandparent.type === \"NGMicrosyntax\" &&",
                        "          grandparent.body.length === 1))) ||",
                        "    (node === parent.body && parent.type === \"ArrowFunctionExpression\") ||",
                        "    (node !== parent.body && parent.type === \"ForStatement\") ||",
                        "    (parent.type === \"ConditionalExpression\" &&",
                        "      grandparent.type !== \"ReturnStatement\" &&",
                        "      grandparent.type !== \"ThrowStatement\" &&",
                        "      !isCallExpression(grandparent)) ||",
                        "    parent.type === \"TemplateLiteral\";",
                        "",
                        "  const shouldIndentIfInlining =",
                        "    parent.type === \"AssignmentExpression\" ||",
                        "    parent.type === \"VariableDeclarator\" ||",
                        "    parent.type === \"ClassProperty\" ||",
                        "    parent.type === \"PropertyDefinition\" ||",
                        "    parent.type === \"TSAbstractPropertyDefinition\" ||",
                        "    parent.type === \"ClassPrivateProperty\" ||",
                        "    isObjectProperty(parent);",
                        "",
                        "  const samePrecedenceSubExpression =",
                        "    isBinaryish(node.left) && shouldFlatten(node.operator, node.left.operator);",
                        "",
                        "  if (",
                        "    shouldNotIndent ||",
                        "    (shouldInlineLogicalExpression(node) && !samePrecedenceSubExpression) ||",
                        "    (!shouldInlineLogicalExpression(node) && shouldIndentIfInlining)",
                        "  ) {",
                        "    return group(parts);",
                        "  }",
                        "",
                        "  if (parts.length === 0) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // If the right part is a JSX node, we include it in a separate group to",
                        "  // prevent it breaking the whole chain, so we can print the expression like:",
                        "  //",
                        "  //   foo && bar && (",
                        "  //     <Foo>",
                        "  //       <Bar />",
                        "  //     </Foo>",
                        "  //   )",
                        "",
                        "  const hasJsx = isJsxElement(node.right);",
                        "",
                        "  const firstGroupIndex = parts.findIndex(",
                        "    (part) =>",
                        "      typeof part !== \"string\" &&",
                        "      !Array.isArray(part) &&",
                        "      part.type === DOC_TYPE_GROUP",
                        "  );",
                        "",
                        "  // Separate the leftmost expression, possibly with its leading comments.",
                        "  const headParts = parts.slice(",
                        "    0,",
                        "    firstGroupIndex === -1 ? 1 : firstGroupIndex + 1",
                        "  );",
                        "",
                        "  const rest = parts.slice(headParts.length, hasJsx ? -1 : undefined);",
                        "",
                        "  const groupId = Symbol(\"logicalChain-\" + ++uid);",
                        "",
                        "  const chain = group(",
                        "    [",
                        "      // Don't include the initial expression in the indentation",
                        "      // level. The first item is guaranteed to be the first",
                        "      // left-most expression.",
                        "      ...headParts,",
                        "      indent(rest),",
                        "    ],",
                        "    { id: groupId }",
                        "  );",
                        "",
                        "  if (!hasJsx) {",
                        "    return chain;",
                        "  }",
                        "",
                        "  const jsxPart = parts.at(-1);",
                        "  return group([chain, indentIfBreak(jsxPart, { groupId })]);",
                        "}",
                        "",
                        "// For binary expressions to be consistent, we need to group",
                        "// subsequent operators with the same precedence level under a single",
                        "// group. Otherwise they will be nested such that some of them break",
                        "// onto new lines but not all. Operators with the same precedence",
                        "// level should either all break or not. Because we group them by",
                        "// precedence level and the AST is structured based on precedence",
                        "// level, things are naturally broken up correctly, i.e. `&&` is",
                        "// broken before `+`.",
                        "function printBinaryishExpressions(",
                        "  path,",
                        "  print,",
                        "  options,",
                        "  isNested,",
                        "  isInsideParenthesis",
                        ") {",
                        "  const { node } = path;",
                        "",
                        "  // Simply print the node normally.",
                        "  if (!isBinaryish(node)) {",
                        "    return [group(print())];",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  let parts = [];",
                        "",
                        "  // We treat BinaryExpression and LogicalExpression nodes the same.",
                        "",
                        "  // Put all operators with the same precedence level in the same",
                        "  // group. The reason we only need to do this with the `left`",
                        "  // expression is because given an expression like `1 + 2 - 3`, it",
                        "  // is always parsed like `((1 + 2) - 3)`, meaning the `left` side",
                        "  // is where the rest of the expression will exist. Binary",
                        "  // expressions on the right side mean they have a difference",
                        "  // precedence level and should be treated as a separate group, so",
                        "  // print them normally. (This doesn't hold for the `**` operator,",
                        "  // which is unique in that it is right-associative.)",
                        "  if (shouldFlatten(node.operator, node.left.operator)) {",
                        "    // Flatten them out by recursively calling this function.",
                        "    parts = path.call(",
                        "      (left) =>",
                        "        printBinaryishExpressions(",
                        "          left,",
                        "          print,",
                        "          options,",
                        "          /* isNested */ true,",
                        "          isInsideParenthesis",
                        "        ),",
                        "      \"left\"",
                        "    );",
                        "  } else {",
                        "    parts.push(group(print(\"left\")));",
                        "  }",
                        "",
                        "  const shouldInline = shouldInlineLogicalExpression(node);",
                        "  const lineBeforeOperator =",
                        "    (node.operator === \"|>\" ||",
                        "      node.type === \"NGPipeExpression\" ||",
                        "      isVueFilterSequenceExpression(path, options)) &&",
                        "    !hasLeadingOwnLineComment(options.originalText, node.right);",
                        "",
                        "  const operator = node.type === \"NGPipeExpression\" ? \"|\" : node.operator;",
                        "  const rightSuffix =",
                        "    node.type === \"NGPipeExpression\" && node.arguments.length > 0",
                        "      ? group(",
                        "          indent([",
                        "            line,",
                        "            \": \",",
                        "            join(",
                        "              [line, \": \"],",
                        "              path.map(() => align(2, group(print())), \"arguments\")",
                        "            ),",
                        "          ])",
                        "        )",
                        "      : \"\";",
                        "",
                        "  /** @type {Doc} */",
                        "  let right;",
                        "  if (shouldInline) {",
                        "    right = [operator, \" \", print(\"right\"), rightSuffix];",
                        "  } else {",
                        "    const isHackPipeline =",
                        "      operator === \"|>\" && path.root.extra?.__isUsingHackPipeline;",
                        "    const rightContent = isHackPipeline",
                        "      ? path.call(",
                        "          (left) =>",
                        "            printBinaryishExpressions(",
                        "              left,",
                        "              print,",
                        "              options,",
                        "              /* isNested */ true,",
                        "              isInsideParenthesis",
                        "            ),",
                        "          \"right\"",
                        "        )",
                        "      : print(\"right\");",
                        "    right = [",
                        "      lineBeforeOperator ? line : \"\",",
                        "      operator,",
                        "      lineBeforeOperator ? \" \" : line,",
                        "      rightContent,",
                        "      rightSuffix,",
                        "    ];",
                        "  }",
                        "",
                        "  // If there's only a single binary expression, we want to create a group",
                        "  // in order to avoid having a small right part like -1 be on its own line.",
                        "  const { parent } = path;",
                        "  const shouldBreak = hasComment(",
                        "    node.left,",
                        "    CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "  );",
                        "  const shouldGroup =",
                        "    shouldBreak ||",
                        "    (!(isInsideParenthesis && node.type === \"LogicalExpression\") &&",
                        "      parent.type !== node.type &&",
                        "      node.left.type !== node.type &&",
                        "      node.right.type !== node.type);",
                        "",
                        "  parts.push(",
                        "    lineBeforeOperator ? \"\" : \" \",",
                        "    shouldGroup ? group(right, { shouldBreak }) : right",
                        "  );",
                        "",
                        "  // The root comments are already printed, but we need to manually print",
                        "  // the other ones since we don't call the normal print on BinaryExpression,",
                        "  // only for the left and right parts",
                        "  if (isNested && hasComment(node)) {",
                        "    const printed = cleanDoc(printComments(path, parts, options));",
                        "    /* c8 ignore next 3 */",
                        "    if (Array.isArray(printed) || printed.type === DOC_TYPE_FILL) {",
                        "      return getDocParts(printed);",
                        "    }",
                        "",
                        "    return [printed];",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldInlineLogicalExpression(node) {",
                        "  if (node.type !== \"LogicalExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    isObjectOrRecordExpression(node.right) &&",
                        "    node.right.properties.length > 0",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (isArrayOrTupleExpression(node.right) && node.right.elements.length > 0) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (isJsxElement(node.right)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "const isBitwiseOrExpression = (node) =>",
                        "  node.type === \"BinaryExpression\" && node.operator === \"|\";",
                        "",
                        "function isVueFilterSequenceExpression(path, options) {",
                        "  return (",
                        "    (options.parser === \"__vue_expression\" ||",
                        "      options.parser === \"__vue_ts_expression\") &&",
                        "    isBitwiseOrExpression(path.node) &&",
                        "    !path.hasAncestor(",
                        "      (node) => !isBitwiseOrExpression(node) && node.type !== \"JsExpressionRoot\"",
                        "    )",
                        "  );",
                        "}",
                        "",
                        "export { printBinaryishExpression, shouldInlineLogicalExpression };"
                    ]
                },
                "block.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import { hardline, indent } from \"../../document/builders.js\";",
                        "import {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} from \"../utils/index.js\";",
                        "import { printStatementSequence } from \"./statement.js\";",
                        "",
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "/*",
                        "- `BlockStatement`",
                        "- `StaticBlock`",
                        "- `TSModuleBlock` (TypeScript)",
                        "*/",
                        "function printBlock(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  if (node.type === \"StaticBlock\") {",
                        "    parts.push(\"static \");",
                        "  }",
                        "",
                        "  parts.push(\"{\");",
                        "  const printed = printBlockBody(path, options, print);",
                        "  if (printed) {",
                        "    parts.push(indent([hardline, printed]), hardline);",
                        "  } else {",
                        "    const { parent } = path;",
                        "    const parentParent = path.grandparent;",
                        "    if (",
                        "      !(",
                        "        parent.type === \"ArrowFunctionExpression\" ||",
                        "        parent.type === \"FunctionExpression\" ||",
                        "        parent.type === \"FunctionDeclaration\" ||",
                        "        parent.type === \"ObjectMethod\" ||",
                        "        parent.type === \"ClassMethod\" ||",
                        "        parent.type === \"ClassPrivateMethod\" ||",
                        "        parent.type === \"ForStatement\" ||",
                        "        parent.type === \"WhileStatement\" ||",
                        "        parent.type === \"DoWhileStatement\" ||",
                        "        parent.type === \"DoExpression\" ||",
                        "        (parent.type === \"CatchClause\" && !parentParent.finalizer) ||",
                        "        parent.type === \"TSModuleDeclaration\" ||",
                        "        parent.type === \"TSDeclareFunction\" ||",
                        "        node.type === \"StaticBlock\"",
                        "      )",
                        "    ) {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  parts.push(\"}\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "/*",
                        "- `Program`",
                        "- `BlockStatement`",
                        "- `StaticBlock`",
                        "- `TSModuleBlock` (TypeScript)",
                        "*/",
                        "function printBlockBody(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  const hasDirectives = isNonEmptyArray(node.directives);",
                        "  const hasBody = node.body.some((node) => node.type !== \"EmptyStatement\");",
                        "  const hasDanglingComments = hasComment(node, CommentCheckFlags.Dangling);",
                        "",
                        "  if (!hasDirectives && !hasBody && !hasDanglingComments) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const parts = [];",
                        "  // Babel",
                        "  if (hasDirectives) {",
                        "    parts.push(printStatementSequence(path, options, print, \"directives\"));",
                        "",
                        "    if (hasBody || hasDanglingComments) {",
                        "      parts.push(hardline);",
                        "      if (isNextLineEmpty(node.directives.at(-1), options)) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  if (hasBody) {",
                        "    parts.push(printStatementSequence(path, options, print, \"body\"));",
                        "  }",
                        "",
                        "  if (hasDanglingComments) {",
                        "    parts.push(printDanglingComments(path, options));",
                        "  }",
                        "",
                        "  if (node.type === \"Program\" && path.parent?.type !== \"ModuleExpression\") {",
                        "    parts.push(hardline);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export { printBlock, printBlockBody };"
                    ]
                },
                "call-arguments.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isFunctionCompositionArgs,",
                        "  isJsxElement,",
                        "  isLongCurriedCallExpression,",
                        "  shouldPrintComma,",
                        "  getCallArguments,",
                        "  iterateCallArgumentsPath,",
                        "  isNextLineEmpty,",
                        "  isCallExpression,",
                        "  isStringLiteral,",
                        "  isObjectProperty,",
                        "  getCallArgumentSelector,",
                        "  isSimpleCallArgument,",
                        "  isBinaryish,",
                        "  isRegExpLiteral,",
                        "  isSimpleType,",
                        "  isCallLikeExpression,",
                        "  isTSTypeExpression,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "",
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  conditionalGroup,",
                        "  ifBreak,",
                        "  breakParent,",
                        "} from \"../../document/builders.js\";",
                        "import { willBreak } from \"../../document/utils.js\";",
                        "",
                        "import { ArgExpansionBailout } from \"../../common/errors.js\";",
                        "import { isConciselyPrintedArray } from \"./array.js\";",
                        "",
                        "function printCallArguments(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  const args = getCallArguments(node);",
                        "  if (args.length === 0) {",
                        "    return [\"(\", printDanglingComments(path, options), \")\"];",
                        "  }",
                        "",
                        "  // useEffect(() => { ... }, [foo, bar, baz])",
                        "  if (isReactHookCallWithDepsArray(args)) {",
                        "    return [\"(\", print([\"arguments\", 0]), \", \", print([\"arguments\", 1]), \")\"];",
                        "  }",
                        "",
                        "  let anyArgEmptyLine = false;",
                        "  const lastArgIndex = args.length - 1;",
                        "  const printedArguments = [];",
                        "  iterateCallArgumentsPath(path, ({ node: arg }, index) => {",
                        "    let argDoc = print();",
                        "",
                        "    if (index === lastArgIndex) {",
                        "      // do nothing",
                        "    } else if (isNextLineEmpty(arg, options)) {",
                        "      anyArgEmptyLine = true;",
                        "      argDoc = [argDoc, \",\", hardline, hardline];",
                        "    } else {",
                        "      argDoc = [argDoc, \",\", line];",
                        "    }",
                        "",
                        "    printedArguments.push(argDoc);",
                        "  });",
                        "",
                        "  // Dynamic imports cannot have trailing commas",
                        "  const isDynamicImport =",
                        "    node.type === \"ImportExpression\" || node.callee.type === \"Import\";",
                        "  const maybeTrailingComma =",
                        "    !isDynamicImport && shouldPrintComma(options, \"all\") ? \",\" : \"\";",
                        "",
                        "  function allArgsBrokenOut() {",
                        "    return group(",
                        "      [\"(\", indent([line, ...printedArguments]), maybeTrailingComma, line, \")\"],",
                        "      { shouldBreak: true }",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    anyArgEmptyLine ||",
                        "    (path.parent.type !== \"Decorator\" && isFunctionCompositionArgs(args))",
                        "  ) {",
                        "    return allArgsBrokenOut();",
                        "  }",
                        "",
                        "  if (shouldExpandFirstArg(args)) {",
                        "    const tailArgs = printedArguments.slice(1);",
                        "    if (tailArgs.some(willBreak)) {",
                        "      return allArgsBrokenOut();",
                        "    }",
                        "    let firstArg;",
                        "    try {",
                        "      firstArg = print(getCallArgumentSelector(node, 0), {",
                        "        expandFirstArg: true,",
                        "      });",
                        "    } catch (caught) {",
                        "      if (caught instanceof ArgExpansionBailout) {",
                        "        return allArgsBrokenOut();",
                        "      }",
                        "      /* c8 ignore next */",
                        "      throw caught;",
                        "    }",
                        "",
                        "    if (willBreak(firstArg)) {",
                        "      return [",
                        "        breakParent,",
                        "        conditionalGroup([",
                        "          [\"(\", group(firstArg, { shouldBreak: true }), \", \", ...tailArgs, \")\"],",
                        "          allArgsBrokenOut(),",
                        "        ]),",
                        "      ];",
                        "    }",
                        "",
                        "    return conditionalGroup([",
                        "      [\"(\", firstArg, \", \", ...tailArgs, \")\"],",
                        "      [\"(\", group(firstArg, { shouldBreak: true }), \", \", ...tailArgs, \")\"],",
                        "      allArgsBrokenOut(),",
                        "    ]);",
                        "  }",
                        "",
                        "  if (shouldExpandLastArg(args, printedArguments, options)) {",
                        "    const headArgs = printedArguments.slice(0, -1);",
                        "    if (headArgs.some(willBreak)) {",
                        "      return allArgsBrokenOut();",
                        "    }",
                        "    let lastArg;",
                        "    try {",
                        "      lastArg = print(getCallArgumentSelector(node, -1), {",
                        "        expandLastArg: true,",
                        "      });",
                        "    } catch (caught) {",
                        "      if (caught instanceof ArgExpansionBailout) {",
                        "        return allArgsBrokenOut();",
                        "      }",
                        "      /* c8 ignore next */",
                        "      throw caught;",
                        "    }",
                        "",
                        "    if (willBreak(lastArg)) {",
                        "      return [",
                        "        breakParent,",
                        "        conditionalGroup([",
                        "          [\"(\", ...headArgs, group(lastArg, { shouldBreak: true }), \")\"],",
                        "          allArgsBrokenOut(),",
                        "        ]),",
                        "      ];",
                        "    }",
                        "",
                        "    return conditionalGroup([",
                        "      [\"(\", ...headArgs, lastArg, \")\"],",
                        "      [\"(\", ...headArgs, group(lastArg, { shouldBreak: true }), \")\"],",
                        "      allArgsBrokenOut(),",
                        "    ]);",
                        "  }",
                        "",
                        "  const contents = [",
                        "    \"(\",",
                        "    indent([softline, ...printedArguments]),",
                        "    ifBreak(maybeTrailingComma),",
                        "    softline,",
                        "    \")\",",
                        "  ];",
                        "  if (isLongCurriedCallExpression(path)) {",
                        "    // By not wrapping the arguments in a group, the printer prioritizes",
                        "    // breaking up these arguments rather than the args of the parent call.",
                        "    return contents;",
                        "  }",
                        "",
                        "  return group(contents, {",
                        "    shouldBreak: printedArguments.some(willBreak) || anyArgEmptyLine,",
                        "  });",
                        "}",
                        "",
                        "function couldExpandArg(arg, arrowChainRecursion = false) {",
                        "  return (",
                        "    (isObjectOrRecordExpression(arg) &&",
                        "      (arg.properties.length > 0 || hasComment(arg))) ||",
                        "    (isArrayOrTupleExpression(arg) &&",
                        "      (arg.elements.length > 0 || hasComment(arg))) ||",
                        "    (arg.type === \"TSTypeAssertion\" && couldExpandArg(arg.expression)) ||",
                        "    (isTSTypeExpression(arg) && couldExpandArg(arg.expression)) ||",
                        "    arg.type === \"FunctionExpression\" ||",
                        "    (arg.type === \"ArrowFunctionExpression\" &&",
                        "      // we want to avoid breaking inside composite return types but not simple keywords",
                        "      // https://github.com/prettier/prettier/issues/4070",
                        "      // export class Thing implements OtherThing {",
                        "      //   do: (type: Type) => Provider<Prop> = memoize(",
                        "      //     (type: ObjectType): Provider<Opts> => {}",
                        "      //   );",
                        "      // }",
                        "      // https://github.com/prettier/prettier/issues/6099",
                        "      // app.get(\"/\", (req, res): void => {",
                        "      //   res.send(\"Hello World!\");",
                        "      // });",
                        "      (!arg.returnType ||",
                        "        !arg.returnType.typeAnnotation ||",
                        "        arg.returnType.typeAnnotation.type !== \"TSTypeReference\" ||",
                        "        // https://github.com/prettier/prettier/issues/7542",
                        "        isNonEmptyBlockStatement(arg.body)) &&",
                        "      (arg.body.type === \"BlockStatement\" ||",
                        "        (arg.body.type === \"ArrowFunctionExpression\" &&",
                        "          couldExpandArg(arg.body, true)) ||",
                        "        isObjectOrRecordExpression(arg.body) ||",
                        "        isArrayOrTupleExpression(arg.body) ||",
                        "        (!arrowChainRecursion &&",
                        "          (isCallExpression(arg.body) ||",
                        "            arg.body.type === \"ConditionalExpression\")) ||",
                        "        isJsxElement(arg.body))) ||",
                        "    arg.type === \"DoExpression\" ||",
                        "    arg.type === \"ModuleExpression\"",
                        "  );",
                        "}",
                        "",
                        "function shouldExpandLastArg(args, argDocs, options) {",
                        "  const lastArg = args.at(-1);",
                        "",
                        "  if (args.length === 1) {",
                        "    const lastArgDoc = argDocs.at(-1);",
                        "    if (lastArgDoc.label?.embed && lastArgDoc.label?.hug !== false) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  const penultimateArg = args.at(-2);",
                        "  return (",
                        "    !hasComment(lastArg, CommentCheckFlags.Leading) &&",
                        "    !hasComment(lastArg, CommentCheckFlags.Trailing) &&",
                        "    couldExpandArg(lastArg) &&",
                        "    // If the last two arguments are of the same type,",
                        "    // disable last element expansion.",
                        "    (!penultimateArg || penultimateArg.type !== lastArg.type) &&",
                        "    // useMemo(() => func(), [foo, bar, baz])",
                        "    (args.length !== 2 ||",
                        "      penultimateArg.type !== \"ArrowFunctionExpression\" ||",
                        "      !isArrayOrTupleExpression(lastArg)) &&",
                        "    !(args.length > 1 && isConciselyPrintedArray(lastArg, options))",
                        "  );",
                        "}",
                        "",
                        "function shouldExpandFirstArg(args) {",
                        "  if (args.length !== 2) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const [firstArg, secondArg] = args;",
                        "",
                        "  if (",
                        "    firstArg.type === \"ModuleExpression\" &&",
                        "    isTypeModuleObjectExpression(secondArg)",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return (",
                        "    !hasComment(firstArg) &&",
                        "    (firstArg.type === \"FunctionExpression\" ||",
                        "      (firstArg.type === \"ArrowFunctionExpression\" &&",
                        "        firstArg.body.type === \"BlockStatement\")) &&",
                        "    secondArg.type !== \"FunctionExpression\" &&",
                        "    secondArg.type !== \"ArrowFunctionExpression\" &&",
                        "    secondArg.type !== \"ConditionalExpression\" &&",
                        "    isHopefullyShortCallArgument(secondArg) &&",
                        "    !couldExpandArg(secondArg)",
                        "  );",
                        "}",
                        "",
                        "// A hack to fix most manifestations of",
                        "// https://github.com/prettier/prettier/issues/2456",
                        "// https://github.com/prettier/prettier/issues/5172",
                        "// https://github.com/prettier/prettier/issues/12892",
                        "// A proper (printWidth-aware) fix for those would require a complex change in the doc printer.",
                        "function isHopefullyShortCallArgument(node) {",
                        "  if (node.type === \"ParenthesizedExpression\") {",
                        "    return isHopefullyShortCallArgument(node.expression);",
                        "  }",
                        "",
                        "  if (isTSTypeExpression(node)) {",
                        "    let { typeAnnotation } = node;",
                        "    if (typeAnnotation.type === \"TSArrayType\") {",
                        "      typeAnnotation = typeAnnotation.elementType;",
                        "      if (typeAnnotation.type === \"TSArrayType\") {",
                        "        typeAnnotation = typeAnnotation.elementType;",
                        "      }",
                        "    }",
                        "    if (",
                        "      (typeAnnotation.type === \"GenericTypeAnnotation\" ||",
                        "        typeAnnotation.type === \"TSTypeReference\") &&",
                        "      typeAnnotation.typeParameters?.params.length === 1",
                        "    ) {",
                        "      typeAnnotation = typeAnnotation.typeParameters.params[0];",
                        "    }",
                        "    return (",
                        "      isSimpleType(typeAnnotation) && isSimpleCallArgument(node.expression, 1)",
                        "    );",
                        "  }",
                        "",
                        "  if (isCallLikeExpression(node) && getCallArguments(node).length > 1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isBinaryish(node)) {",
                        "    return (",
                        "      isSimpleCallArgument(node.left, 1) && isSimpleCallArgument(node.right, 1)",
                        "    );",
                        "  }",
                        "",
                        "  return isRegExpLiteral(node) || isSimpleCallArgument(node);",
                        "}",
                        "",
                        "function isReactHookCallWithDepsArray(args) {",
                        "  return (",
                        "    args.length === 2 &&",
                        "    args[0].type === \"ArrowFunctionExpression\" &&",
                        "    getFunctionParameters(args[0]).length === 0 &&",
                        "    args[0].body.type === \"BlockStatement\" &&",
                        "    args[1].type === \"ArrayExpression\" &&",
                        "    !args.some((arg) => hasComment(arg))",
                        "  );",
                        "}",
                        "",
                        "function isNonEmptyBlockStatement(node) {",
                        "  return (",
                        "    node.type === \"BlockStatement\" &&",
                        "    (node.body.some((node) => node.type !== \"EmptyStatement\") ||",
                        "      hasComment(node, CommentCheckFlags.Dangling))",
                        "  );",
                        "}",
                        "",
                        "// { type: \"module\" }",
                        "function isTypeModuleObjectExpression(node) {",
                        "  return (",
                        "    node.type === \"ObjectExpression\" &&",
                        "    node.properties.length === 1 &&",
                        "    isObjectProperty(node.properties[0]) &&",
                        "    node.properties[0].key.type === \"Identifier\" &&",
                        "    node.properties[0].key.name === \"type\" &&",
                        "    isStringLiteral(node.properties[0].value) &&",
                        "    node.properties[0].value.value === \"module\"",
                        "  );",
                        "}",
                        "",
                        "export default printCallArguments;"
                    ]
                },
                "call-expression.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { join, group } from \"../../document/builders.js\";",
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import {",
                        "  getCallArguments,",
                        "  isCallExpression,",
                        "  isMemberish,",
                        "  isStringLiteral,",
                        "  isTemplateOnItsOwnLine,",
                        "  isTestCall,",
                        "  iterateCallArgumentsPath,",
                        "} from \"../utils/index.js\";",
                        "import printMemberChain from \"./member-chain.js\";",
                        "import printCallArguments from \"./call-arguments.js\";",
                        "import { printOptionalToken, printFunctionTypeParameters } from \"./misc.js\";",
                        "",
                        "function printCallExpression(path, options, print) {",
                        "  const { node, parent } = path;",
                        "  const isNew = node.type === \"NewExpression\";",
                        "  const isDynamicImport = node.type === \"ImportExpression\";",
                        "",
                        "  const optional = printOptionalToken(path);",
                        "  const args = getCallArguments(node);",
                        "",
                        "  const isTemplateLiteralSingleArg =",
                        "    args.length === 1 && isTemplateOnItsOwnLine(args[0], options.originalText);",
                        "",
                        "  if (",
                        "    isTemplateLiteralSingleArg ||",
                        "    // Dangling comments are not handled, all these special cases should have arguments #9668",
                        "    (args.length > 0 &&",
                        "      !isNew &&",
                        "      !isDynamicImport &&",
                        "      // We want to keep CommonJS- and AMD-style require calls, and AMD-style",
                        "      // define calls, as a unit.",
                        "      // e.g. `define([\"some/lib\"], (lib) => {`",
                        "      (isCommonsJsOrAmdCall(node, parent) ||",
                        "        // Keep test declarations on a single line",
                        "        // e.g. `it('long name', () => {`",
                        "        isTestCall(node, parent)))",
                        "  ) {",
                        "    const printed = [];",
                        "    iterateCallArgumentsPath(path, () => {",
                        "      printed.push(print());",
                        "    });",
                        "    if (!(isTemplateLiteralSingleArg && printed[0].label?.embed)) {",
                        "      return [",
                        "        isNew ? \"new \" : \"\",",
                        "        print(\"callee\"),",
                        "        optional,",
                        "        printFunctionTypeParameters(path, options, print),",
                        "        \"(\",",
                        "        join(\", \", printed),",
                        "        \")\",",
                        "      ];",
                        "    }",
                        "  }",
                        "",
                        "  // We detect calls on member lookups and possibly print them in a",
                        "  // special chain format. See `printMemberChain` for more info.",
                        "  if (",
                        "    !isDynamicImport &&",
                        "    !isNew &&",
                        "    isMemberish(node.callee) &&",
                        "    !path.call((path) => pathNeedsParens(path, options), \"callee\")",
                        "  ) {",
                        "    return printMemberChain(path, options, print);",
                        "  }",
                        "",
                        "  const contents = [",
                        "    isNew ? \"new \" : \"\",",
                        "    isDynamicImport ? \"import\" : print(\"callee\"),",
                        "    optional,",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    printCallArguments(path, options, print),",
                        "  ];",
                        "",
                        "  // We group here when the callee is itself a call expression.",
                        "  // See `isLongCurriedCallExpression` for more info.",
                        "  if (isDynamicImport || isCallExpression(node.callee)) {",
                        "    return group(contents);",
                        "  }",
                        "",
                        "  return contents;",
                        "}",
                        "",
                        "function isCommonsJsOrAmdCall(node, parentNode) {",
                        "  if (node.callee.type !== \"Identifier\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (node.callee.name === \"require\") {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.callee.name === \"define\") {",
                        "    const args = getCallArguments(node);",
                        "    return (",
                        "      parentNode.type === \"ExpressionStatement\" &&",
                        "      (args.length === 1 ||",
                        "        (args.length === 2 && args[0].type === \"ArrayExpression\") ||",
                        "        (args.length === 3 &&",
                        "          isStringLiteral(args[0]) &&",
                        "          args[1].type === \"ArrayExpression\"))",
                        "    );",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "export { printCallExpression };"
                    ]
                },
                "class.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import createGroupIdMapper from \"../../utils/create-group-id-mapper.js\";",
                        "import {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "} from \"../../main/comments/print.js\";",
                        "import {",
                        "  join,",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  createTypeCheckFunction,",
                        "  isNextLineEmpty,",
                        "} from \"../utils/index.js\";",
                        "import { getTypeParametersGroupId } from \"./type-parameters.js\";",
                        "import { printMethod } from \"./function.js\";",
                        "import {",
                        "  printOptionalToken,",
                        "  printDefiniteToken,",
                        "  printDeclareToken,",
                        "  printAbstractToken,",
                        "  printTypeScriptAccessibilityToken,",
                        "} from \"./misc.js\";",
                        "import { printPropertyKey } from \"./property.js\";",
                        "import { printAssignment } from \"./assignment.js\";",
                        "import { printClassMemberDecorators } from \"./decorators.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "const isClassProperty = createTypeCheckFunction([",
                        "  \"ClassProperty\",",
                        "  \"PropertyDefinition\",",
                        "  \"ClassPrivateProperty\",",
                        "  \"ClassAccessorProperty\",",
                        "  \"AccessorProperty\",",
                        "  \"TSAbstractPropertyDefinition\",",
                        "  \"TSAbstractAccessorProperty\",",
                        "]);",
                        "",
                        "/*",
                        "- `ClassDeclaration`",
                        "- `ClassExpression`",
                        "- `DeclareClass`(flow)",
                        "*/",
                        "function printClass(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type {Doc[]} */",
                        "  const parts = [printDeclareToken(path), printAbstractToken(path), \"class\"];",
                        "",
                        "  // Keep old behaviour of extends in same line",
                        "  // If there is only on extends and there are not comments",
                        "  const groupMode =",
                        "    hasComment(node.id, CommentCheckFlags.Trailing) ||",
                        "    hasComment(node.typeParameters, CommentCheckFlags.Trailing) ||",
                        "    hasComment(node.superClass) ||",
                        "    isNonEmptyArray(node.extends) || // DeclareClass",
                        "    isNonEmptyArray(node.mixins) ||",
                        "    isNonEmptyArray(node.implements);",
                        "",
                        "  const partsGroup = [];",
                        "  const extendsParts = [];",
                        "",
                        "  if (node.id) {",
                        "    partsGroup.push(\" \", print(\"id\"));",
                        "  }",
                        "",
                        "  partsGroup.push(print(\"typeParameters\"));",
                        "",
                        "  if (node.superClass) {",
                        "    const printed = [",
                        "      printSuperClass(path, options, print),",
                        "      print(\"superTypeParameters\"),",
                        "    ];",
                        "    const printedWithComments = path.call(",
                        "      (superClass) => [\"extends \", printComments(superClass, printed, options)],",
                        "      \"superClass\"",
                        "    );",
                        "    if (groupMode) {",
                        "      extendsParts.push(line, group(printedWithComments));",
                        "    } else {",
                        "      extendsParts.push(\" \", printedWithComments);",
                        "    }",
                        "  } else {",
                        "    extendsParts.push(printHeritageClauses(path, options, print, \"extends\"));",
                        "  }",
                        "",
                        "  extendsParts.push(",
                        "    printHeritageClauses(path, options, print, \"mixins\"),",
                        "    printHeritageClauses(path, options, print, \"implements\")",
                        "  );",
                        "",
                        "  if (groupMode) {",
                        "    let printedPartsGroup;",
                        "    if (shouldIndentOnlyHeritageClauses(node)) {",
                        "      printedPartsGroup = [...partsGroup, indent(extendsParts)];",
                        "    } else {",
                        "      printedPartsGroup = indent([...partsGroup, extendsParts]);",
                        "    }",
                        "    parts.push(group(printedPartsGroup, { id: getHeritageGroupId(node) }));",
                        "  } else {",
                        "    parts.push(...partsGroup, ...extendsParts);",
                        "  }",
                        "",
                        "  parts.push(\" \", print(\"body\"));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "const getHeritageGroupId = createGroupIdMapper(\"heritageGroup\");",
                        "",
                        "function printHardlineAfterHeritage(node) {",
                        "  return ifBreak(hardline, \"\", { groupId: getHeritageGroupId(node) });",
                        "}",
                        "",
                        "function hasMultipleHeritage(node) {",
                        "  return (",
                        "    [\"extends\", \"mixins\", \"implements\"].reduce(",
                        "      (count, key) => count + (Array.isArray(node[key]) ? node[key].length : 0),",
                        "      node.superClass ? 1 : 0",
                        "    ) > 1",
                        "  );",
                        "}",
                        "",
                        "function shouldIndentOnlyHeritageClauses(node) {",
                        "  return (",
                        "    node.typeParameters &&",
                        "    !hasComment(",
                        "      node.typeParameters,",
                        "      CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "    ) &&",
                        "    !hasMultipleHeritage(node)",
                        "  );",
                        "}",
                        "",
                        "function printHeritageClauses(path, options, print, listName) {",
                        "  const { node } = path;",
                        "  if (!isNonEmptyArray(node[listName])) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const printedLeadingComments = printDanglingComments(path, options, {",
                        "    marker: listName,",
                        "  });",
                        "  return [",
                        "    shouldIndentOnlyHeritageClauses(node)",
                        "      ? ifBreak(\" \", line, {",
                        "          groupId: getTypeParametersGroupId(node.typeParameters),",
                        "        })",
                        "      : line,",
                        "    printedLeadingComments,",
                        "    printedLeadingComments && hardline,",
                        "    listName,",
                        "    group(indent([line, join([\",\", line], path.map(print, listName))])),",
                        "  ];",
                        "}",
                        "",
                        "function printSuperClass(path, options, print) {",
                        "  const printed = print(\"superClass\");",
                        "  const { parent } = path;",
                        "  if (parent.type === \"AssignmentExpression\") {",
                        "    return group(",
                        "      ifBreak([\"(\", indent([softline, printed]), softline, \")\"], printed)",
                        "    );",
                        "  }",
                        "  return printed;",
                        "}",
                        "",
                        "function printClassMethod(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  if (isNonEmptyArray(node.decorators)) {",
                        "    parts.push(printClassMemberDecorators(path, options, print));",
                        "  }",
                        "",
                        "  parts.push(printTypeScriptAccessibilityToken(node));",
                        "",
                        "  if (node.static) {",
                        "    parts.push(\"static \");",
                        "  }",
                        "",
                        "  parts.push(printAbstractToken(path));",
                        "",
                        "  if (node.override) {",
                        "    parts.push(\"override \");",
                        "  }",
                        "",
                        "  parts.push(printMethod(path, options, print));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printClassProperty(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "",
                        "  if (isNonEmptyArray(node.decorators)) {",
                        "    parts.push(printClassMemberDecorators(path, options, print));",
                        "  }",
                        "",
                        "  parts.push(printTypeScriptAccessibilityToken(node), printDeclareToken(path));",
                        "",
                        "  if (node.static) {",
                        "    parts.push(\"static \");",
                        "  }",
                        "",
                        "  parts.push(printAbstractToken(path));",
                        "",
                        "  if (node.override) {",
                        "    parts.push(\"override \");",
                        "  }",
                        "  if (node.readonly) {",
                        "    parts.push(\"readonly \");",
                        "  }",
                        "  if (node.variance) {",
                        "    parts.push(print(\"variance\"));",
                        "  }",
                        "  if (",
                        "    node.type === \"ClassAccessorProperty\" ||",
                        "    node.type === \"AccessorProperty\" ||",
                        "    node.type === \"TSAbstractAccessorProperty\"",
                        "  ) {",
                        "    parts.push(\"accessor \");",
                        "  }",
                        "  parts.push(",
                        "    printPropertyKey(path, options, print),",
                        "    printOptionalToken(path),",
                        "    printDefiniteToken(path),",
                        "    printTypeAnnotationProperty(path, print)",
                        "  );",
                        "",
                        "  const isAbstractProperty =",
                        "    node.type === \"TSAbstractPropertyDefinition\" ||",
                        "    node.type === \"TSAbstractAccessorProperty\";",
                        "",
                        "  return [",
                        "    printAssignment(",
                        "      path,",
                        "      options,",
                        "      print,",
                        "      parts,",
                        "      \" =\",",
                        "      isAbstractProperty ? undefined : \"value\"",
                        "    ),",
                        "    semi,",
                        "  ];",
                        "}",
                        "",
                        "function printClassBody(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  path.each(({ node, next, isLast }) => {",
                        "    parts.push(print());",
                        "",
                        "    if (",
                        "      !options.semi &&",
                        "      isClassProperty(node) &&",
                        "      shouldPrintSemicolonAfterClassProperty(node, next)",
                        "    ) {",
                        "      parts.push(\";\");",
                        "    }",
                        "",
                        "    if (!isLast) {",
                        "      parts.push(hardline);",
                        "",
                        "      if (isNextLineEmpty(node, options)) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, \"body\");",
                        "",
                        "  if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    parts.push(printDanglingComments(path, options));",
                        "  }",
                        "",
                        "  return [",
                        "    isNonEmptyArray(node.body) ? printHardlineAfterHeritage(path.parent) : \"\",",
                        "    \"{\",",
                        "    parts.length > 0 ? [indent([hardline, parts]), hardline] : \"\",",
                        "    \"}\",",
                        "  ];",
                        "}",
                        "",
                        "/**",
                        " * @returns {boolean}",
                        " */",
                        "function shouldPrintSemicolonAfterClassProperty(node, nextNode) {",
                        "  const { type, name } = node.key;",
                        "  if (",
                        "    !node.computed &&",
                        "    type === \"Identifier\" &&",
                        "    (name === \"static\" || name === \"get\" || name === \"set\") &&",
                        "    !node.value &&",
                        "    !node.typeAnnotation",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!nextNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (",
                        "    nextNode.static ||",
                        "    nextNode.accessibility // TypeScript",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (!nextNode.computed) {",
                        "    const name = nextNode.key?.name;",
                        "    if (name === \"in\" || name === \"instanceof\") {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  // Flow variance sigil +/- requires semi if there's no",
                        "  // \"declare\" or \"static\" keyword before it.",
                        "  if (",
                        "    isClassProperty(nextNode) &&",
                        "    nextNode.variance &&",
                        "    !nextNode.static &&",
                        "    !nextNode.declare",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (nextNode.type) {",
                        "    case \"ClassProperty\":",
                        "    case \"PropertyDefinition\":",
                        "    case \"TSAbstractPropertyDefinition\":",
                        "      return nextNode.computed;",
                        "    case \"MethodDefinition\":",
                        "    case \"TSAbstractMethodDefinition\":",
                        "    case \"ClassMethod\":",
                        "    case \"ClassPrivateMethod\": {",
                        "      // Babel",
                        "      const isAsync = nextNode.value ? nextNode.value.async : nextNode.async;",
                        "      if (isAsync || nextNode.kind === \"get\" || nextNode.kind === \"set\") {",
                        "        return false;",
                        "      }",
                        "",
                        "      const isGenerator = nextNode.value",
                        "        ? nextNode.value.generator",
                        "        : nextNode.generator;",
                        "      if (nextNode.computed || isGenerator) {",
                        "        return true;",
                        "      }",
                        "",
                        "      return false;",
                        "    }",
                        "",
                        "    case \"TSIndexSignature\":",
                        "      return true;",
                        "  }",
                        "",
                        "  /* c8 ignore next */",
                        "  return false;",
                        "}",
                        "",
                        "export {",
                        "  printClass,",
                        "  printClassMethod,",
                        "  printClassProperty,",
                        "  printHardlineAfterHeritage,",
                        "  printClassBody,",
                        "};"
                    ]
                },
                "comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { join, hardline } from \"../../document/builders.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "",
                        "import { isLineComment } from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import isBlockComment from \"../utils/is-block-comment.js\";",
                        "import isIndentableBlockComment from \"../utils/is-indentable-block-comment.js\";",
                        "",
                        "function printComment(commentPath, options) {",
                        "  const comment = commentPath.node;",
                        "",
                        "  if (isLineComment(comment)) {",
                        "    // Supports `//`, `#!`, `<!--`, and `-->`",
                        "    return options.originalText",
                        "      .slice(locStart(comment), locEnd(comment))",
                        "      .trimEnd();",
                        "  }",
                        "",
                        "  if (isBlockComment(comment)) {",
                        "    if (isIndentableBlockComment(comment)) {",
                        "      return printIndentableBlockComment(comment);",
                        "    }",
                        "",
                        "    return [\"/*\", replaceEndOfLine(comment.value), \"*/\"];",
                        "  }",
                        "",
                        "  /* c8 ignore next */",
                        "  throw new Error(\"Not a comment: \" + JSON.stringify(comment));",
                        "}",
                        "",
                        "function printIndentableBlockComment(comment) {",
                        "  const lines = comment.value.split(\"\\n\");",
                        "",
                        "  return [",
                        "    \"/*\",",
                        "    join(",
                        "      hardline,",
                        "      lines.map((line, index) =>",
                        "        index === 0",
                        "          ? line.trimEnd()",
                        "          : \" \" + (index < lines.length - 1 ? line.trim() : line.trimStart())",
                        "      )",
                        "    ),",
                        "    \"*/\",",
                        "  ];",
                        "}",
                        "",
                        "export { printComment, isIndentableBlockComment };"
                    ]
                },
                "decorators.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isIgnored from \"../utils/is-ignored.js\";",
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  join,",
                        "  breakParent,",
                        "  group,",
                        "} from \"../../document/builders.js\";",
                        "import { locEnd, hasSameLocStart } from \"../loc.js\";",
                        "import { isExportDeclaration } from \"../utils/index.js\";",
                        "",
                        "function printClassMemberDecorators(path, options, print) {",
                        "  const { node } = path;",
                        "  return group([",
                        "    join(line, path.map(print, \"decorators\")),",
                        "    hasNewlineBetweenOrAfterDecorators(node, options) ? hardline : line,",
                        "  ]);",
                        "}",
                        "",
                        "function printDecoratorsBeforeExport(path, options, print) {",
                        "  // Only print decorators here if they were written before the export,",
                        "  // otherwise they are printed by the node.declaration",
                        "  if (!hasDecoratorsBeforeExport(path.node)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // Export declarations are responsible for printing any decorators",
                        "  // that logically apply to node.declaration.",
                        "  return [",
                        "    join(hardline, path.map(print, \"declaration\", \"decorators\")),",
                        "    hardline,",
                        "  ];",
                        "}",
                        "",
                        "function printDecorators(path, options, print) {",
                        "  const { node, parent } = path;",
                        "  const { decorators } = node;",
                        "",
                        "  if (",
                        "    !isNonEmptyArray(decorators) ||",
                        "    // If the parent node is an export declaration and the decorator",
                        "    // was written before the export, the export will be responsible",
                        "    // for printing the decorators.",
                        "    hasDecoratorsBeforeExport(parent) ||",
                        "    // Decorators already printed in ignored node",
                        "    isIgnored(path)",
                        "  ) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const shouldBreak =",
                        "    node.type === \"ClassExpression\" ||",
                        "    node.type === \"ClassDeclaration\" ||",
                        "    hasNewlineBetweenOrAfterDecorators(node, options);",
                        "",
                        "  return [",
                        "    path.key === \"declaration\" && isExportDeclaration(parent)",
                        "      ? hardline",
                        "      : shouldBreak",
                        "      ? breakParent",
                        "      : \"\",",
                        "    join(line, path.map(print, \"decorators\")),",
                        "    line,",
                        "  ];",
                        "}",
                        "",
                        "function hasNewlineBetweenOrAfterDecorators(node, options) {",
                        "  return node.decorators.some((decorator) =>",
                        "    hasNewline(options.originalText, locEnd(decorator))",
                        "  );",
                        "}",
                        "",
                        "function hasDecoratorsBeforeExport(node) {",
                        "  if (",
                        "    node.type !== \"ExportDefaultDeclaration\" &&",
                        "    node.type !== \"ExportNamedDeclaration\" &&",
                        "    node.type !== \"DeclareExportDeclaration\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const decorators = node.declaration?.decorators;",
                        "",
                        "  return isNonEmptyArray(decorators) && hasSameLocStart(node, decorators[0]);",
                        "}",
                        "",
                        "export {",
                        "  printDecorators,",
                        "  printClassMemberDecorators,",
                        "  printDecoratorsBeforeExport,",
                        "  hasDecoratorsBeforeExport,",
                        "};"
                    ]
                },
                "enum.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDeclareToken } from \"./misc.js\";",
                        "import { printObject } from \"./object.js\";",
                        "",
                        "function printEnumMembers(path, print, options) {",
                        "  return printObject(path, options, print);",
                        "}",
                        "",
                        "/*",
                        "- `EnumBooleanMember`(flow)",
                        "- `EnumNumberMember`(flow)",
                        "- `EnumStringMember`(flow)",
                        "- `EnumDefaultedMember`(flow)",
                        "- `TSEnumMember`(TypeScript)",
                        "*/",
                        "function printEnumMember(path, print) {",
                        "  const { node } = path;",
                        "",
                        "  let idDoc = print(\"id\");",
                        "",
                        "  if (node.computed) {",
                        "    idDoc = [\"[\", idDoc, \"]\"];",
                        "  }",
                        "",
                        "  let initializerDoc = \"\";",
                        "",
                        "  // `TSEnumMember`",
                        "  if (node.initializer) {",
                        "    initializerDoc = print(\"initializer\");",
                        "  }",
                        "",
                        "  // Flow",
                        "  if (node.init) {",
                        "    initializerDoc = print(\"init\");",
                        "  }",
                        "",
                        "  if (!initializerDoc) {",
                        "    return idDoc;",
                        "  }",
                        "",
                        "  return [idDoc, \" = \", initializerDoc];",
                        "}",
                        "",
                        "/*",
                        "- `EnumBooleanBody`(flow)",
                        "- `EnumNumberBody`(flow)",
                        "- `EnumStringBody`(flow)",
                        "- `EnumSymbolBody`(flow)",
                        "*/",
                        "function printEnumBody(path, print, options) {",
                        "  const { node } = path;",
                        "  let type;",
                        "",
                        "  if (node.type === \"EnumSymbolBody\" || node.explicitType) {",
                        "    switch (node.type) {",
                        "      case \"EnumBooleanBody\":",
                        "        type = \"boolean\";",
                        "        break;",
                        "      case \"EnumNumberBody\":",
                        "        type = \"number\";",
                        "        break;",
                        "      case \"EnumStringBody\":",
                        "        type = \"string\";",
                        "        break;",
                        "      case \"EnumSymbolBody\":",
                        "        type = \"symbol\";",
                        "        break;",
                        "    }",
                        "  }",
                        "",
                        "  return [type ? `of ${type} ` : \"\", printEnumMembers(path, print, options)];",
                        "}",
                        "",
                        "/*",
                        "- `DeclareEnum`(flow)",
                        "- `EnumDeclaration`(flow)",
                        "- `TSEnumDeclaration`(TypeScript)",
                        "*/",
                        "function printEnumDeclaration(path, print, options) {",
                        "  const { node } = path;",
                        "  return [",
                        "    printDeclareToken(path),",
                        "    node.const ? \"const \" : \"\",",
                        "    \"enum \",",
                        "    print(\"id\"),",
                        "    \" \",",
                        "    node.type === \"TSEnumDeclaration\"",
                        "      ? printEnumMembers(path, print, options)",
                        "      : print(\"body\"),",
                        "  ];",
                        "}",
                        "",
                        "export { printEnumDeclaration, printEnumMember, printEnumBody };"
                    ]
                },
                "expression-statement.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  markerForIfWithoutBlockAndSameLineComment,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "} from \"../utils/index.js\";",
                        "import {",
                        "  isSingleJsxExpressionStatementInMarkdown,",
                        "  isSingleVueEventBindingExpressionStatement,",
                        "  isVueEventBindingExpression,",
                        "} from \"./semicolon.js\";",
                        "",
                        "function printExpressionStatement(path, options, print) {",
                        "  const parts = [print(\"expression\")];",
                        "",
                        "  if (isSingleVueEventBindingExpressionStatement(path, options)) {",
                        "    if (isVueEventBindingExpression(path.node.expression)) {",
                        "      parts.push(\";\");",
                        "    }",
                        "  } else if (isSingleJsxExpressionStatementInMarkdown(path, options)) {",
                        "    // Do not append semicolon after the only JSX element in a program",
                        "  } else if (options.semi) {",
                        "    parts.push(\";\");",
                        "  }",
                        "",
                        "  if (",
                        "    hasComment(",
                        "      path.node,",
                        "      CommentCheckFlags.Dangling,",
                        "      ({ marker }) => marker === markerForIfWithoutBlockAndSameLineComment",
                        "    )",
                        "  ) {",
                        "    parts.push(",
                        "      \" \",",
                        "      printDanglingComments(path, options, {",
                        "        marker: markerForIfWithoutBlockAndSameLineComment,",
                        "      })",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export { printExpressionStatement };"
                    ]
                },
                "flow.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "import assert from \"node:assert\";",
                        "import printString from \"../../utils/print-string.js\";",
                        "import printNumber from \"../../utils/print-number.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import {",
                        "  isFunctionNotation,",
                        "  isGetterOrSetter,",
                        "  rawText,",
                        "} from \"../utils/index.js\";",
                        "import isFlowKeywordType from \"../utils/is-flow-keyword-type.js\";",
                        "import { printClass } from \"./class.js\";",
                        "import {",
                        "  printOpaqueType,",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printInferType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printIndexedAccessType,",
                        "  printRestType,",
                        "  printNamedTupleMember,",
                        "  printTypeAnnotation,",
                        "  printTypeAnnotationProperty,",
                        "  printArrayType,",
                        "  printTypeQuery,",
                        "} from \"./type-annotation.js\";",
                        "import { printInterface } from \"./interface.js\";",
                        "import { printTypeParameter, printTypeParameters } from \"./type-parameters.js\";",
                        "import { printExportDeclaration } from \"./module.js\";",
                        "import { printArray } from \"./array.js\";",
                        "import { printObject } from \"./object.js\";",
                        "import { printPropertyKey } from \"./property.js\";",
                        "import {",
                        "  printEnumDeclaration,",
                        "  printEnumBody,",
                        "  printEnumMember,",
                        "} from \"./enum.js\";",
                        "import { printBigInt } from \"./literal.js\";",
                        "import {",
                        "  printOptionalToken,",
                        "  printRestSpread,",
                        "  printDeclareToken,",
                        "} from \"./misc.js\";",
                        "import { printTernary } from \"./ternary.js\";",
                        "import { printFlowMappedTypeProperty } from \"./mapped-type.js\";",
                        "",
                        "function printFlow(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (isFlowKeywordType(node)) {",
                        "    // Flow keyword types ends with `TypeAnnotation`",
                        "    return node.type.slice(0, -14).toLowerCase();",
                        "  }",
                        "",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "",
                        "  switch (node.type) {",
                        "    case \"DeclareClass\":",
                        "      return printClass(path, options, print);",
                        "    case \"DeclareFunction\":",
                        "      return [",
                        "        printDeclareToken(path),",
                        "        \"function \",",
                        "        print(\"id\"),",
                        "        node.predicate ? \" \" : \"\",",
                        "        print(\"predicate\"),",
                        "        semi,",
                        "      ];",
                        "    case \"DeclareModule\":",
                        "      return [\"declare module \", print(\"id\"), \" \", print(\"body\")];",
                        "    case \"DeclareModuleExports\":",
                        "      return [",
                        "        \"declare module.exports\",",
                        "        printTypeAnnotationProperty(path, print),",
                        "        semi,",
                        "      ];",
                        "    case \"DeclareVariable\":",
                        "      return [",
                        "        printDeclareToken(path),",
                        "        // TODO: Only use `node.kind` when babel update AST",
                        "        node.kind ?? \"var\",",
                        "        \" \",",
                        "        print(\"id\"),",
                        "        semi,",
                        "      ];",
                        "    case \"DeclareExportDeclaration\":",
                        "    case \"DeclareExportAllDeclaration\":",
                        "      return printExportDeclaration(path, options, print);",
                        "    case \"DeclareOpaqueType\":",
                        "    case \"OpaqueType\":",
                        "      return printOpaqueType(path, options, print);",
                        "",
                        "    case \"DeclareTypeAlias\":",
                        "    case \"TypeAlias\":",
                        "      return printTypeAlias(path, options, print);",
                        "",
                        "    case \"IntersectionTypeAnnotation\":",
                        "      return printIntersectionType(path, options, print);",
                        "    case \"UnionTypeAnnotation\":",
                        "      return printUnionType(path, options, print);",
                        "    case \"ConditionalTypeAnnotation\":",
                        "      return printTernary(path, options, print);",
                        "    case \"InferTypeAnnotation\":",
                        "      return printInferType(path, options, print);",
                        "    case \"FunctionTypeAnnotation\":",
                        "      return printFunctionType(path, options, print);",
                        "    case \"TupleTypeAnnotation\":",
                        "      return printArray(path, options, print);",
                        "    case \"TupleTypeLabeledElement\":",
                        "      return printNamedTupleMember(path, options, print);",
                        "    case \"TupleTypeSpreadElement\":",
                        "      return printRestType(path, options, print);",
                        "    case \"GenericTypeAnnotation\":",
                        "      return [",
                        "        print(\"id\"),",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"IndexedAccessType\":",
                        "    case \"OptionalIndexedAccessType\":",
                        "      return printIndexedAccessType(path, options, print);",
                        "    // Type Annotations for Facebook Flow, typically stripped out or",
                        "    // transformed away before printing.",
                        "    case \"TypeAnnotation\":",
                        "      return printTypeAnnotation(path, options, print);",
                        "    case \"TypeParameter\":",
                        "      return printTypeParameter(path, options, print);",
                        "    case \"TypeofTypeAnnotation\":",
                        "      return printTypeQuery(path, print);",
                        "    case \"ExistsTypeAnnotation\":",
                        "      return \"*\";",
                        "    case \"ArrayTypeAnnotation\":",
                        "      return printArrayType(print);",
                        "",
                        "    case \"DeclareEnum\":",
                        "    case \"EnumDeclaration\":",
                        "      return printEnumDeclaration(path, print, options);",
                        "",
                        "    case \"EnumBooleanBody\":",
                        "    case \"EnumNumberBody\":",
                        "    case \"EnumStringBody\":",
                        "    case \"EnumSymbolBody\":",
                        "      return printEnumBody(path, print, options);",
                        "",
                        "    case \"EnumBooleanMember\":",
                        "    case \"EnumNumberMember\":",
                        "    case \"EnumStringMember\":",
                        "    case \"EnumDefaultedMember\":",
                        "      return printEnumMember(path, print);",
                        "",
                        "    case \"FunctionTypeParam\": {",
                        "      const name = node.name",
                        "        ? print(\"name\")",
                        "        : path.parent.this === node",
                        "        ? \"this\"",
                        "        : \"\";",
                        "      return [",
                        "        name,",
                        "        printOptionalToken(path),",
                        "        // `flow` doesn't wrap the `typeAnnotation` with `TypeAnnotation`, so the colon",
                        "        // needs to be added separately.",
                        "        name ? \": \" : \"\",",
                        "        print(\"typeAnnotation\"),",
                        "      ];",
                        "    }",
                        "",
                        "    case \"DeclareInterface\":",
                        "    case \"InterfaceDeclaration\":",
                        "    case \"InterfaceTypeAnnotation\":",
                        "      return printInterface(path, options, print);",
                        "    case \"ClassImplements\":",
                        "    case \"InterfaceExtends\":",
                        "      return [print(\"id\"), print(\"typeParameters\")];",
                        "    case \"NullableTypeAnnotation\":",
                        "      return [\"?\", print(\"typeAnnotation\")];",
                        "    case \"Variance\": {",
                        "      const { kind } = node;",
                        "      assert.ok(kind === \"plus\" || kind === \"minus\");",
                        "      return kind === \"plus\" ? \"+\" : \"-\";",
                        "    }",
                        "    case \"KeyofTypeAnnotation\":",
                        "      return [\"keyof \", print(\"argument\")];",
                        "    case \"ObjectTypeCallProperty\":",
                        "      return [node.static ? \"static \" : \"\", print(\"value\")];",
                        "    case \"ObjectTypeMappedTypeProperty\":",
                        "      return printFlowMappedTypeProperty(path, options, print);",
                        "    case \"ObjectTypeIndexer\":",
                        "      return [",
                        "        node.static ? \"static \" : \"\",",
                        "        node.variance ? print(\"variance\") : \"\",",
                        "        \"[\",",
                        "        print(\"id\"),",
                        "        node.id ? \": \" : \"\",",
                        "        print(\"key\"),",
                        "        \"]: \",",
                        "        print(\"value\"),",
                        "      ];",
                        "",
                        "    case \"ObjectTypeProperty\": {",
                        "      let modifier = \"\";",
                        "",
                        "      if (node.proto) {",
                        "        modifier = \"proto \";",
                        "      } else if (node.static) {",
                        "        modifier = \"static \";",
                        "      }",
                        "",
                        "      return [",
                        "        modifier,",
                        "        isGetterOrSetter(node) ? node.kind + \" \" : \"\",",
                        "        node.variance ? print(\"variance\") : \"\",",
                        "        printPropertyKey(path, options, print),",
                        "        printOptionalToken(path),",
                        "        isFunctionNotation(node) ? \"\" : \": \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    }",
                        "    case \"ObjectTypeAnnotation\":",
                        "      return printObject(path, options, print);",
                        "    case \"ObjectTypeInternalSlot\":",
                        "      return [",
                        "        node.static ? \"static \" : \"\",",
                        "        \"[[\",",
                        "        print(\"id\"),",
                        "        \"]]\",",
                        "        printOptionalToken(path),",
                        "        node.method ? \"\" : \": \",",
                        "        print(\"value\"),",
                        "      ];",
                        "    // Same as `RestElement`",
                        "    case \"ObjectTypeSpreadProperty\":",
                        "      return printRestSpread(path, print);",
                        "    case \"QualifiedTypeofIdentifier\":",
                        "    case \"QualifiedTypeIdentifier\":",
                        "      return [print(\"qualification\"), \".\", print(\"id\")];",
                        "",
                        "    case \"NullLiteralTypeAnnotation\":",
                        "      return \"null\";",
                        "    case \"BooleanLiteralTypeAnnotation\":",
                        "      return String(node.value);",
                        "    case \"StringLiteralTypeAnnotation\":",
                        "      return replaceEndOfLine(printString(rawText(node), options));",
                        "    case \"NumberLiteralTypeAnnotation\":",
                        "      return printNumber(node.raw ?? node.extra.raw);",
                        "    case \"BigIntLiteralTypeAnnotation\":",
                        "      return printBigInt(node.raw ?? node.extra.raw);",
                        "    case \"TypeCastExpression\":",
                        "      return [",
                        "        \"(\",",
                        "        print(\"expression\"),",
                        "        printTypeAnnotationProperty(path, print),",
                        "        \")\",",
                        "      ];",
                        "",
                        "    case \"TypeParameterDeclaration\":",
                        "    case \"TypeParameterInstantiation\":",
                        "      return printTypeParameters(path, options, print, \"params\");",
                        "",
                        "    case \"InferredPredicate\":",
                        "      return \"%checks\";",
                        "    case \"DeclaredPredicate\":",
                        "      return [\"%checks(\", print(\"value\"), \")\"];",
                        "  }",
                        "}",
                        "",
                        "export { printFlow };"
                    ]
                },
                "function-parameters.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import getNextNonSpaceNonCommentCharacter from \"../../utils/get-next-non-space-non-comment-character.js\";",
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import { removeLines, willBreak } from \"../../document/utils.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  iterateFunctionParametersPath,",
                        "  isSimpleType,",
                        "  isTestCall,",
                        "  isTypeAnnotationAFunction,",
                        "  isObjectType,",
                        "  isObjectTypePropertyAFunction,",
                        "  hasRestParameter,",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  isNextLineEmpty,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import { locEnd } from \"../loc.js\";",
                        "import { ArgExpansionBailout } from \"../../common/errors.js\";",
                        "import { printFunctionTypeParameters } from \"./misc.js\";",
                        "",
                        "/** @typedef {import(\"../../common/ast-path.js\").default} AstPath */",
                        "",
                        "function printFunctionParameters(",
                        "  path,",
                        "  print,",
                        "  options,",
                        "  expandArg,",
                        "  printTypeParams",
                        ") {",
                        "  const functionNode = path.node;",
                        "  const parameters = getFunctionParameters(functionNode);",
                        "  const typeParams = printTypeParams",
                        "    ? printFunctionTypeParameters(path, options, print)",
                        "    : \"\";",
                        "",
                        "  if (parameters.length === 0) {",
                        "    return [",
                        "      typeParams,",
                        "      \"(\",",
                        "      printDanglingComments(path, options, {",
                        "        filter: (comment) =>",
                        "          getNextNonSpaceNonCommentCharacter(",
                        "            options.originalText,",
                        "            locEnd(comment)",
                        "          ) === \")\",",
                        "      }),",
                        "      \")\",",
                        "    ];",
                        "  }",
                        "",
                        "  const { parent } = path;",
                        "  const isParametersInTestCall = isTestCall(parent);",
                        "  const shouldHugParameters = shouldHugTheOnlyFunctionParameter(functionNode);",
                        "  const printed = [];",
                        "  iterateFunctionParametersPath(path, (parameterPath, index) => {",
                        "    const isLastParameter = index === parameters.length - 1;",
                        "    if (isLastParameter && functionNode.rest) {",
                        "      printed.push(\"...\");",
                        "    }",
                        "    printed.push(print());",
                        "    if (isLastParameter) {",
                        "      return;",
                        "    }",
                        "    printed.push(\",\");",
                        "    if (isParametersInTestCall || shouldHugParameters) {",
                        "      printed.push(\" \");",
                        "    } else if (isNextLineEmpty(parameters[index], options)) {",
                        "      printed.push(hardline, hardline);",
                        "    } else {",
                        "      printed.push(line);",
                        "    }",
                        "  });",
                        "",
                        "  // If the parent is a call with the first/last argument expansion and this is the",
                        "  // params of the first/last argument, we don't want the arguments to break and instead",
                        "  // want the whole expression to be on a new line.",
                        "  //",
                        "  // Good:                 Bad:",
                        "  //   verylongcall(         verylongcall((",
                        "  //     (a, b) => {           a,",
                        "  //     }                     b,",
                        "  //   )                     ) => {",
                        "  //                         })",
                        "  if (expandArg && !isDecoratedFunction(path)) {",
                        "    if (willBreak(typeParams) || willBreak(printed)) {",
                        "      // Removing lines in this case leads to broken or ugly output",
                        "      throw new ArgExpansionBailout();",
                        "    }",
                        "    return group([removeLines(typeParams), \"(\", removeLines(printed), \")\"]);",
                        "  }",
                        "",
                        "  // Single object destructuring should hug",
                        "  //",
                        "  // function({",
                        "  //   a,",
                        "  //   b,",
                        "  //   c",
                        "  // }) {}",
                        "  const hasNotParameterDecorator = parameters.every((node) => !node.decorators);",
                        "  if (shouldHugParameters && hasNotParameterDecorator) {",
                        "    return [typeParams, \"(\", ...printed, \")\"];",
                        "  }",
                        "",
                        "  // don't break in specs, eg; `it(\"should maintain parens around done even when long\", (done) => {})`",
                        "  if (isParametersInTestCall) {",
                        "    return [typeParams, \"(\", ...printed, \")\"];",
                        "  }",
                        "",
                        "  const isFlowShorthandWithOneArg =",
                        "    (isObjectTypePropertyAFunction(parent) ||",
                        "      isTypeAnnotationAFunction(parent) ||",
                        "      parent.type === \"TypeAlias\" ||",
                        "      parent.type === \"UnionTypeAnnotation\" ||",
                        "      parent.type === \"TSUnionType\" ||",
                        "      parent.type === \"IntersectionTypeAnnotation\" ||",
                        "      (parent.type === \"FunctionTypeAnnotation\" &&",
                        "        parent.returnType === functionNode)) &&",
                        "    parameters.length === 1 &&",
                        "    parameters[0].name === null &&",
                        "    // `type q = (this: string) => void;`",
                        "    functionNode.this !== parameters[0] &&",
                        "    parameters[0].typeAnnotation &&",
                        "    functionNode.typeParameters === null &&",
                        "    isSimpleType(parameters[0].typeAnnotation) &&",
                        "    !functionNode.rest;",
                        "",
                        "  if (isFlowShorthandWithOneArg) {",
                        "    if (options.arrowParens === \"always\") {",
                        "      return [\"(\", ...printed, \")\"];",
                        "    }",
                        "    return printed;",
                        "  }",
                        "",
                        "  return [",
                        "    typeParams,",
                        "    \"(\",",
                        "    indent([softline, ...printed]),",
                        "    ifBreak(",
                        "      !hasRestParameter(functionNode) && shouldPrintComma(options, \"all\")",
                        "        ? \",\"",
                        "        : \"\"",
                        "    ),",
                        "    softline,",
                        "    \")\",",
                        "  ];",
                        "}",
                        "",
                        "function shouldHugTheOnlyFunctionParameter(node) {",
                        "  if (!node) {",
                        "    return false;",
                        "  }",
                        "  const parameters = getFunctionParameters(node);",
                        "  if (parameters.length !== 1) {",
                        "    return false;",
                        "  }",
                        "  const [parameter] = parameters;",
                        "  return (",
                        "    !hasComment(parameter) &&",
                        "    (parameter.type === \"ObjectPattern\" ||",
                        "      parameter.type === \"ArrayPattern\" ||",
                        "      (parameter.type === \"Identifier\" &&",
                        "        parameter.typeAnnotation &&",
                        "        (parameter.typeAnnotation.type === \"TypeAnnotation\" ||",
                        "          parameter.typeAnnotation.type === \"TSTypeAnnotation\") &&",
                        "        isObjectType(parameter.typeAnnotation.typeAnnotation)) ||",
                        "      (parameter.type === \"FunctionTypeParam\" &&",
                        "        isObjectType(parameter.typeAnnotation) &&",
                        "        parameter !== node.rest) ||",
                        "      (parameter.type === \"AssignmentPattern\" &&",
                        "        (parameter.left.type === \"ObjectPattern\" ||",
                        "          parameter.left.type === \"ArrayPattern\") &&",
                        "        (parameter.right.type === \"Identifier\" ||",
                        "          (isObjectOrRecordExpression(parameter.right) &&",
                        "            parameter.right.properties.length === 0) ||",
                        "          (isArrayOrTupleExpression(parameter.right) &&",
                        "            parameter.right.elements.length === 0))))",
                        "  );",
                        "}",
                        "",
                        "function getReturnTypeNode(functionNode) {",
                        "  let returnTypeNode;",
                        "  if (functionNode.returnType) {",
                        "    returnTypeNode = functionNode.returnType;",
                        "    if (returnTypeNode.typeAnnotation) {",
                        "      returnTypeNode = returnTypeNode.typeAnnotation;",
                        "    }",
                        "  } else if (functionNode.typeAnnotation) {",
                        "    returnTypeNode = functionNode.typeAnnotation;",
                        "  }",
                        "  return returnTypeNode;",
                        "}",
                        "",
                        "// When parameters are grouped, the return type annotation breaks first.",
                        "function shouldGroupFunctionParameters(functionNode, returnTypeDoc) {",
                        "  const returnTypeNode = getReturnTypeNode(functionNode);",
                        "  if (!returnTypeNode) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const typeParameters = functionNode.typeParameters?.params;",
                        "  if (typeParameters) {",
                        "    if (typeParameters.length > 1) {",
                        "      return false;",
                        "    }",
                        "    if (typeParameters.length === 1) {",
                        "      const typeParameter = typeParameters[0];",
                        "      if (typeParameter.constraint || typeParameter.default) {",
                        "        return false;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return (",
                        "    getFunctionParameters(functionNode).length === 1 &&",
                        "    (isObjectType(returnTypeNode) || willBreak(returnTypeDoc))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * The \"decorated function\" pattern.",
                        " * The arrow function should be kept hugged even if its signature breaks.",
                        " *",
                        " * ```",
                        " * const decoratedFn = decorator(param1, param2)((",
                        " *   ...",
                        " * ) => {",
                        " *   ...",
                        " * });",
                        " * ```",
                        " * @param {AstPath} path",
                        " */",
                        "function isDecoratedFunction(path) {",
                        "  return path.match(",
                        "    (node) =>",
                        "      node.type === \"ArrowFunctionExpression\" &&",
                        "      node.body.type === \"BlockStatement\",",
                        "    (node, name) => {",
                        "      if (",
                        "        node.type === \"CallExpression\" &&",
                        "        name === \"arguments\" &&",
                        "        node.arguments.length === 1 &&",
                        "        node.callee.type === \"CallExpression\"",
                        "      ) {",
                        "        const decorator = node.callee.callee;",
                        "        return (",
                        "          decorator.type === \"Identifier\" ||",
                        "          (decorator.type === \"MemberExpression\" &&",
                        "            !decorator.computed &&",
                        "            decorator.object.type === \"Identifier\" &&",
                        "            decorator.property.type === \"Identifier\")",
                        "        );",
                        "      }",
                        "      return false;",
                        "    },",
                        "    (node, name) =>",
                        "      (node.type === \"VariableDeclarator\" && name === \"init\") ||",
                        "      (node.type === \"ExportDefaultDeclaration\" && name === \"declaration\") ||",
                        "      (node.type === \"TSExportAssignment\" && name === \"expression\") ||",
                        "      (node.type === \"AssignmentExpression\" &&",
                        "        name === \"right\" &&",
                        "        node.left.type === \"MemberExpression\" &&",
                        "        node.left.object.type === \"Identifier\" &&",
                        "        node.left.object.name === \"module\" &&",
                        "        node.left.property.type === \"Identifier\" &&",
                        "        node.left.property.name === \"exports\"),",
                        "    (node) =>",
                        "      node.type !== \"VariableDeclaration\" ||",
                        "      (node.kind === \"const\" && node.declarations.length === 1)",
                        "  );",
                        "}",
                        "",
                        "function shouldBreakFunctionParameters(functionNode) {",
                        "  const parameters = getFunctionParameters(functionNode);",
                        "  return (",
                        "    parameters.length > 1 &&",
                        "    parameters.some((parameter) => parameter.type === \"TSParameterProperty\")",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  printFunctionParameters,",
                        "  shouldHugTheOnlyFunctionParameter,",
                        "  shouldGroupFunctionParameters,",
                        "  shouldBreakFunctionParameters,",
                        "};"
                    ]
                },
                "function.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "import assert from \"node:assert\";",
                        "import {",
                        "  printDanglingComments,",
                        "  printCommentsSeparately,",
                        "} from \"../../main/comments/print.js\";",
                        "import getNextNonSpaceNonCommentCharacterIndex from \"../../utils/get-next-non-space-non-comment-character-index.js\";",
                        "import {",
                        "  line,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  dedent,",
                        "  ifBreak,",
                        "  hardline,",
                        "  join,",
                        "  indentIfBreak,",
                        "} from \"../../document/builders.js\";",
                        "import { removeLines, willBreak } from \"../../document/utils.js\";",
                        "import { ArgExpansionBailout } from \"../../common/errors.js\";",
                        "import {",
                        "  getFunctionParameters,",
                        "  hasLeadingOwnLineComment,",
                        "  isJsxElement,",
                        "  isTemplateOnItsOwnLine,",
                        "  shouldPrintComma,",
                        "  startsWithNoLookaheadToken,",
                        "  isBinaryish,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isCallLikeExpression,",
                        "  isCallExpression,",
                        "  getCallArguments,",
                        "  hasNakedLeftSide,",
                        "  getLeftSide,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import { locEnd } from \"../loc.js\";",
                        "import {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "  shouldBreakFunctionParameters,",
                        "} from \"./function-parameters.js\";",
                        "import { printPropertyKey } from \"./property.js\";",
                        "import { printFunctionTypeParameters, printDeclareToken } from \"./misc.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "const isMethod = (node) =>",
                        "  node.type === \"ObjectMethod\" ||",
                        "  node.type === \"ClassMethod\" ||",
                        "  node.type === \"ClassPrivateMethod\" ||",
                        "  node.type === \"MethodDefinition\" ||",
                        "  node.type === \"TSAbstractMethodDefinition\" ||",
                        "  node.type === \"TSDeclareMethod\" ||",
                        "  ((node.type === \"Property\" || node.type === \"ObjectProperty\") &&",
                        "    (node.method || node.kind === \"get\" || node.kind === \"set\"));",
                        "",
                        "const isMethodValue = (path) =>",
                        "  path.node.type === \"FunctionExpression\" &&",
                        "  path.key === \"value\" &&",
                        "  isMethod(path.parent);",
                        "",
                        "/*",
                        "- \"FunctionDeclaration\"",
                        "- \"FunctionExpression\"",
                        "- `TSDeclareFunction`(TypeScript)",
                        "*/",
                        "function printFunction(path, print, options, args) {",
                        "  if (isMethodValue(path)) {",
                        "    return printMethodValue(path, options, print);",
                        "  }",
                        "",
                        "  const { node } = path;",
                        "",
                        "  let expandArg = false;",
                        "  if (",
                        "    (node.type === \"FunctionDeclaration\" ||",
                        "      node.type === \"FunctionExpression\") &&",
                        "    args?.expandLastArg",
                        "  ) {",
                        "    const { parent } = path;",
                        "    if (",
                        "      isCallExpression(parent) &&",
                        "      (getCallArguments(parent).length > 1 ||",
                        "        getFunctionParameters(node).every(",
                        "          (param) => param.type === \"Identifier\" && !param.typeAnnotation",
                        "        ))",
                        "    ) {",
                        "      expandArg = true;",
                        "    }",
                        "  }",
                        "",
                        "  const parts = [",
                        "    printDeclareToken(path),",
                        "    node.async ? \"async \" : \"\",",
                        "    `function${node.generator ? \"*\" : \"\"} `,",
                        "    node.id ? print(\"id\") : \"\",",
                        "  ];",
                        "",
                        "  const parametersDoc = printFunctionParameters(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    expandArg",
                        "  );",
                        "  const returnTypeDoc = printReturnType(path, print);",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "",
                        "  parts.push(",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    group([",
                        "      shouldGroupParameters ? group(parametersDoc) : parametersDoc,",
                        "      returnTypeDoc,",
                        "    ]),",
                        "    node.body ? \" \" : \"\",",
                        "    print(\"body\")",
                        "  );",
                        "",
                        "  if (options.semi && (node.declare || !node.body)) {",
                        "    parts.push(\";\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "/*",
                        "- `ObjectMethod`",
                        "- `Property`",
                        "- `ObjectProperty`",
                        "- `ClassMethod`",
                        "- `ClassPrivateMethod`",
                        "- `MethodDefinition",
                        "- `TSAbstractMethodDefinition` (TypeScript)",
                        "- `TSDeclareMethod` (TypeScript)",
                        "*/",
                        "function printMethod(path, options, print) {",
                        "  const { node } = path;",
                        "  const { kind } = node;",
                        "  const value = node.value || node;",
                        "  const parts = [];",
                        "",
                        "  if (!kind || kind === \"init\" || kind === \"method\" || kind === \"constructor\") {",
                        "    if (value.async) {",
                        "      parts.push(\"async \");",
                        "    }",
                        "  } else {",
                        "    assert.ok(kind === \"get\" || kind === \"set\");",
                        "",
                        "    parts.push(kind, \" \");",
                        "  }",
                        "",
                        "  // A `getter`/`setter` can't be a generator, but it's recoverable",
                        "  if (value.generator) {",
                        "    parts.push(\"*\");",
                        "  }",
                        "",
                        "  parts.push(",
                        "    printPropertyKey(path, options, print),",
                        "    node.optional || node.key.optional ? \"?\" : \"\",",
                        "    node === value ? printMethodValue(path, options, print) : print(\"value\")",
                        "  );",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printMethodValue(path, options, print) {",
                        "  const { node } = path;",
                        "  const parametersDoc = printFunctionParameters(path, print, options);",
                        "  const returnTypeDoc = printReturnType(path, print);",
                        "  const shouldBreakParameters = shouldBreakFunctionParameters(node);",
                        "  const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "    node,",
                        "    returnTypeDoc",
                        "  );",
                        "  const parts = [",
                        "    printFunctionTypeParameters(path, options, print),",
                        "    group([",
                        "      shouldBreakParameters",
                        "        ? group(parametersDoc, { shouldBreak: true })",
                        "        : shouldGroupParameters",
                        "        ? group(parametersDoc)",
                        "        : parametersDoc,",
                        "      returnTypeDoc,",
                        "    ]),",
                        "  ];",
                        "",
                        "  if (node.body) {",
                        "    parts.push(\" \", print(\"body\"));",
                        "  } else {",
                        "    parts.push(options.semi ? \";\" : \"\");",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrowFunctionSignature(path, options, print, args) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  if (node.async) {",
                        "    parts.push(\"async \");",
                        "  }",
                        "",
                        "  if (shouldPrintParamsWithoutParens(path, options)) {",
                        "    parts.push(print([\"params\", 0]));",
                        "  } else {",
                        "    const expandArg = args?.expandLastArg || args?.expandFirstArg;",
                        "    let returnTypeDoc = printReturnType(path, print);",
                        "    if (expandArg) {",
                        "      if (willBreak(returnTypeDoc)) {",
                        "        throw new ArgExpansionBailout();",
                        "      }",
                        "      returnTypeDoc = group(removeLines(returnTypeDoc));",
                        "    }",
                        "    parts.push(",
                        "      group([",
                        "        printFunctionParameters(",
                        "          path,",
                        "          print,",
                        "          options,",
                        "          expandArg,",
                        "          /* printTypeParams */ true",
                        "        ),",
                        "        returnTypeDoc,",
                        "      ])",
                        "    );",
                        "  }",
                        "",
                        "  const dangling = printDanglingComments(path, options, {",
                        "    filter(comment) {",
                        "      const nextCharacter = getNextNonSpaceNonCommentCharacterIndex(",
                        "        options.originalText,",
                        "        locEnd(comment)",
                        "      );",
                        "      return (",
                        "        nextCharacter !== false &&",
                        "        options.originalText.slice(nextCharacter, nextCharacter + 2) === \"=>\"",
                        "      );",
                        "    },",
                        "  });",
                        "  if (dangling) {",
                        "    parts.push(\" \", dangling);",
                        "  }",
                        "  return parts;",
                        "}",
                        "",
                        "function printArrowChain(",
                        "  path,",
                        "  args,",
                        "  signatures,",
                        "  shouldBreak,",
                        "  bodyDoc,",
                        "  tailNode",
                        ") {",
                        "  const { parent, key } = path;",
                        "  const isCallee = isCallLikeExpression(parent) && key === \"callee\";",
                        "  const isAssignmentRhs = Boolean(args?.assignmentLayout);",
                        "  const shouldPutBodyOnSeparateLine =",
                        "    tailNode.body.type !== \"BlockStatement\" &&",
                        "    !isObjectOrRecordExpression(tailNode.body) &&",
                        "    tailNode.body.type !== \"SequenceExpression\";",
                        "  const shouldBreakBeforeChain =",
                        "    (isCallee && shouldPutBodyOnSeparateLine) ||",
                        "    args?.assignmentLayout === \"chain-tail-arrow-chain\";",
                        "",
                        "  const groupId = Symbol(\"arrow-chain\");",
                        "",
                        "  if ((isCallLikeExpression(parent) && !isCallee) || isBinaryish(parent)) {",
                        "    signatures = [dedent(signatures[0]), ...signatures.slice(1)];",
                        "  }",
                        "",
                        "  // We handle sequence expressions as the body of arrows specially,",
                        "  // so that the required parentheses end up on their own lines.",
                        "  if (tailNode.body.type === \"SequenceExpression\") {",
                        "    bodyDoc = group([\"(\", indent([softline, bodyDoc]), softline, \")\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    group(",
                        "      indent([",
                        "        isCallee || isAssignmentRhs ? softline : \"\",",
                        "        group(join([\" =>\", line], signatures), { shouldBreak }),",
                        "      ]),",
                        "      { id: groupId, shouldBreak: shouldBreakBeforeChain }",
                        "    ),",
                        "    \" =>\",",
                        "    indentIfBreak(",
                        "      shouldPutBodyOnSeparateLine ? indent([line, bodyDoc]) : [\" \", bodyDoc],",
                        "      { groupId }",
                        "    ),",
                        "    isCallee ? ifBreak(softline, \"\", { groupId }) : \"\",",
                        "  ]);",
                        "}",
                        "",
                        "function printArrowFunction(path, options, print, args) {",
                        "  let { node } = path;",
                        "  /** @type {Doc[]} */",
                        "  const signatures = [];",
                        "  const body = [];",
                        "  let chainShouldBreak = false;",
                        "",
                        "  (function rec() {",
                        "    const doc = printArrowFunctionSignature(path, options, print, args);",
                        "    if (signatures.length === 0) {",
                        "      signatures.push(doc);",
                        "    } else {",
                        "      const { leading, trailing } = printCommentsSeparately(path, options);",
                        "      signatures.push([leading, doc]);",
                        "      body.unshift(trailing);",
                        "    }",
                        "",
                        "    chainShouldBreak =",
                        "      chainShouldBreak ||",
                        "      // Always break the chain if:",
                        "      (node.returnType && getFunctionParameters(node).length > 0) ||",
                        "      node.typeParameters ||",
                        "      getFunctionParameters(node).some((param) => param.type !== \"Identifier\");",
                        "",
                        "    if (node.body.type !== \"ArrowFunctionExpression\" || args?.expandLastArg) {",
                        "      body.unshift(print(\"body\", args));",
                        "    } else {",
                        "      node = node.body;",
                        "      path.call(rec, \"body\");",
                        "    }",
                        "  })();",
                        "",
                        "  if (signatures.length > 1) {",
                        "    return printArrowChain(",
                        "      path,",
                        "      args,",
                        "      signatures,",
                        "      chainShouldBreak,",
                        "      body,",
                        "      node",
                        "    );",
                        "  }",
                        "",
                        "  const parts = signatures;",
                        "  parts.push(\" =>\");",
                        "",
                        "  // We want to always keep these types of nodes on the same line",
                        "  // as the arrow.",
                        "  if (",
                        "    !hasLeadingOwnLineComment(options.originalText, node.body) &&",
                        "    (isArrayOrTupleExpression(node.body) ||",
                        "      isObjectOrRecordExpression(node.body) ||",
                        "      node.body.type === \"BlockStatement\" ||",
                        "      isJsxElement(node.body) ||",
                        "      (body[0].label?.hug !== false &&",
                        "        (body[0].label?.embed ||",
                        "          isTemplateOnItsOwnLine(node.body, options.originalText))) ||",
                        "      node.body.type === \"ArrowFunctionExpression\" ||",
                        "      node.body.type === \"DoExpression\")",
                        "  ) {",
                        "    return group([...parts, \" \", body]);",
                        "  }",
                        "",
                        "  // We handle sequence expressions as the body of arrows specially,",
                        "  // so that the required parentheses end up on their own lines.",
                        "  if (node.body.type === \"SequenceExpression\") {",
                        "    return group([",
                        "      ...parts,",
                        "      group([\" (\", indent([softline, body]), softline, \")\"]),",
                        "    ]);",
                        "  }",
                        "",
                        "  // if the arrow function is expanded as last argument, we are adding a",
                        "  // level of indentation and need to add a softline to align the closing )",
                        "  // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)",
                        "  // we should align the expression's closing } with the line with the opening {.",
                        "  const shouldAddSoftLine =",
                        "    (args?.expandLastArg || path.parent.type === \"JSXExpressionContainer\") &&",
                        "    !hasComment(node);",
                        "",
                        "  const printTrailingComma =",
                        "    args?.expandLastArg && shouldPrintComma(options, \"all\");",
                        "",
                        "  // In order to avoid confusion between",
                        "  // a => a ? a : a",
                        "  // a <= a ? a : a",
                        "  const shouldAddParens =",
                        "    node.body.type === \"ConditionalExpression\" &&",
                        "    !startsWithNoLookaheadToken(",
                        "      node.body,",
                        "      (node) => node.type === \"ObjectExpression\"",
                        "    );",
                        "",
                        "  return group([",
                        "    ...parts,",
                        "    group([",
                        "      indent([",
                        "        line,",
                        "        shouldAddParens ? ifBreak(\"\", \"(\") : \"\",",
                        "        body,",
                        "        shouldAddParens ? ifBreak(\"\", \")\") : \"\",",
                        "      ]),",
                        "      shouldAddSoftLine",
                        "        ? [ifBreak(printTrailingComma ? \",\" : \"\"), softline]",
                        "        : \"\",",
                        "    ]),",
                        "  ]);",
                        "}",
                        "",
                        "function canPrintParamsWithoutParens(node) {",
                        "  const parameters = getFunctionParameters(node);",
                        "  return (",
                        "    parameters.length === 1 &&",
                        "    !node.typeParameters &&",
                        "    !hasComment(node, CommentCheckFlags.Dangling) &&",
                        "    parameters[0].type === \"Identifier\" &&",
                        "    !parameters[0].typeAnnotation &&",
                        "    !hasComment(parameters[0]) &&",
                        "    !parameters[0].optional &&",
                        "    !node.predicate &&",
                        "    !node.returnType",
                        "  );",
                        "}",
                        "",
                        "function shouldPrintParamsWithoutParens(path, options) {",
                        "  if (options.arrowParens === \"always\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (options.arrowParens === \"avoid\") {",
                        "    const { node } = path;",
                        "    return canPrintParamsWithoutParens(node);",
                        "  }",
                        "",
                        "  // Fallback default; should be unreachable",
                        "  /* c8 ignore next */",
                        "  return false;",
                        "}",
                        "",
                        "/** @returns {Doc} */",
                        "function printReturnType(path, print) {",
                        "  const { node } = path;",
                        "  const returnType = printTypeAnnotationProperty(path, print, \"returnType\");",
                        "",
                        "  const parts = [returnType];",
                        "",
                        "  if (node.predicate) {",
                        "    // The return type will already add the colon, but otherwise we",
                        "    // need to do it ourselves",
                        "    parts.push(node.returnType ? \" \" : \": \", print(\"predicate\"));",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "// `ReturnStatement` and `ThrowStatement`",
                        "function printReturnOrThrowArgument(path, options, print) {",
                        "  const { node } = path;",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const parts = [];",
                        "",
                        "  if (node.argument) {",
                        "    let argumentDoc = print(\"argument\");",
                        "",
                        "    if (returnArgumentHasLeadingComment(options, node.argument)) {",
                        "      argumentDoc = [\"(\", indent([hardline, argumentDoc]), hardline, \")\"];",
                        "    } else if (",
                        "      isBinaryish(node.argument) ||",
                        "      node.argument.type === \"SequenceExpression\"",
                        "    ) {",
                        "      argumentDoc = group([",
                        "        ifBreak(\"(\"),",
                        "        indent([softline, argumentDoc]),",
                        "        softline,",
                        "        ifBreak(\")\"),",
                        "      ]);",
                        "    }",
                        "",
                        "    parts.push(\" \", argumentDoc);",
                        "  }",
                        "",
                        "  const hasDanglingComments = hasComment(node, CommentCheckFlags.Dangling);",
                        "  const shouldPrintSemiBeforeComments =",
                        "    semi &&",
                        "    hasDanglingComments &&",
                        "    hasComment(node, CommentCheckFlags.Last | CommentCheckFlags.Line);",
                        "",
                        "  if (shouldPrintSemiBeforeComments) {",
                        "    parts.push(semi);",
                        "  }",
                        "",
                        "  if (hasDanglingComments) {",
                        "    parts.push(\" \", printDanglingComments(path, options));",
                        "  }",
                        "",
                        "  if (!shouldPrintSemiBeforeComments) {",
                        "    parts.push(semi);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printReturnStatement(path, options, print) {",
                        "  return [\"return\", printReturnOrThrowArgument(path, options, print)];",
                        "}",
                        "",
                        "function printThrowStatement(path, options, print) {",
                        "  return [\"throw\", printReturnOrThrowArgument(path, options, print)];",
                        "}",
                        "",
                        "// This recurses the return argument, looking for the first token",
                        "// (the leftmost leaf node) and, if it (or its parents) has any",
                        "// leadingComments, returns true (so it can be wrapped in parens).",
                        "function returnArgumentHasLeadingComment(options, argument) {",
                        "  if (hasLeadingOwnLineComment(options.originalText, argument)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (hasNakedLeftSide(argument)) {",
                        "    let leftMost = argument;",
                        "    let newLeftMost;",
                        "    while ((newLeftMost = getLeftSide(leftMost))) {",
                        "      leftMost = newLeftMost;",
                        "",
                        "      if (hasLeadingOwnLineComment(options.originalText, leftMost)) {",
                        "        return true;",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "export {",
                        "  printFunction,",
                        "  printArrowFunction,",
                        "  printMethod,",
                        "  printReturnStatement,",
                        "  printThrowStatement,",
                        "  printMethodValue,",
                        "  shouldPrintParamsWithoutParens,",
                        "};"
                    ]
                },
                "html-binding.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  join,",
                        "  line,",
                        "  group,",
                        "  softline,",
                        "  indent,",
                        "} from \"../../document/builders.js\";",
                        "",
                        "function printHtmlBinding(path, options, print) {",
                        "  const { node, isRoot } = path;",
                        "",
                        "  if (isRoot) {",
                        "    options.__onHtmlBindingRoot?.(node, options);",
                        "  }",
                        "",
                        "  if (node.type !== \"File\") {",
                        "    return;",
                        "  }",
                        "",
                        "  if (options.__isVueBindings || options.__isVueForBindingLeft) {",
                        "    const parameterDocs = path.map(print, \"program\", \"body\", 0, \"params\");",
                        "",
                        "    if (parameterDocs.length === 1) {",
                        "      return parameterDocs[0];",
                        "    }",
                        "",
                        "    const doc = join([\",\", line], parameterDocs);",
                        "",
                        "    return options.__isVueForBindingLeft",
                        "      ? [\"(\", indent([softline, group(doc)]), softline, \")\"]",
                        "      : doc;",
                        "  }",
                        "}",
                        "",
                        "export { printHtmlBinding };"
                    ]
                },
                "interface.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import { join, line, group, indent, ifBreak } from \"../../document/builders.js\";",
                        "import { hasComment, identity, CommentCheckFlags } from \"../utils/index.js\";",
                        "import { getTypeParametersGroupId } from \"./type-parameters.js\";",
                        "import { printDeclareToken } from \"./misc.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "/*",
                        "- `TSInterfaceDeclaration`(TypeScript)",
                        "- `DeclareInterface`(flow)",
                        "- `InterfaceDeclaration`(flow)",
                        "- `InterfaceTypeAnnotation`(flow)",
                        "*/",
                        "function printInterface(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type {Doc[]} */",
                        "  const parts = [printDeclareToken(path), \"interface\"];",
                        "",
                        "  const partsGroup = [];",
                        "  const extendsParts = [];",
                        "",
                        "  if (node.type !== \"InterfaceTypeAnnotation\") {",
                        "    partsGroup.push(\" \", print(\"id\"), print(\"typeParameters\"));",
                        "  }",
                        "",
                        "  const shouldIndentOnlyHeritageClauses =",
                        "    node.typeParameters &&",
                        "    !hasComment(",
                        "      node.typeParameters,",
                        "      CommentCheckFlags.Trailing | CommentCheckFlags.Line",
                        "    );",
                        "",
                        "  if (isNonEmptyArray(node.extends)) {",
                        "    extendsParts.push(",
                        "      shouldIndentOnlyHeritageClauses",
                        "        ? ifBreak(\" \", line, {",
                        "            groupId: getTypeParametersGroupId(node.typeParameters),",
                        "          })",
                        "        : line,",
                        "      \"extends \",",
                        "      (node.extends.length === 1 ? identity : indent)(",
                        "        join([\",\", line], path.map(print, \"extends\"))",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    hasComment(node.id, CommentCheckFlags.Trailing) ||",
                        "    isNonEmptyArray(node.extends)",
                        "  ) {",
                        "    if (shouldIndentOnlyHeritageClauses) {",
                        "      parts.push(group([...partsGroup, indent(extendsParts)]));",
                        "    } else {",
                        "      parts.push(group(indent([...partsGroup, ...extendsParts])));",
                        "    }",
                        "  } else {",
                        "    parts.push(...partsGroup, ...extendsParts);",
                        "  }",
                        "",
                        "  parts.push(\" \", print(\"body\"));",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "export { printInterface };"
                    ]
                },
                "jsx.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  printComments,",
                        "  printDanglingComments,",
                        "} from \"../../main/comments/print.js\";",
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  conditionalGroup,",
                        "  fill,",
                        "  ifBreak,",
                        "  lineSuffixBoundary,",
                        "  join,",
                        "  cursor,",
                        "} from \"../../document/builders.js\";",
                        "import { willBreak, replaceEndOfLine } from \"../../document/utils.js\";",
                        "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                        "import getPreferredQuote from \"../../utils/get-preferred-quote.js\";",
                        "import WhitespaceUtils from \"../../utils/whitespace-utils.js\";",
                        "import {",
                        "  isJsxElement,",
                        "  rawText,",
                        "  isCallExpression,",
                        "  isStringLiteral,",
                        "  isBinaryish,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  hasNodeIgnoreComment,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import { willPrintOwnComments } from \"../comments/printer-methods.js\";",
                        "",
                        "/*",
                        "Only the following are treated as whitespace inside JSX.",
                        "",
                        "- U+0020 SPACE",
                        "- U+000A LF",
                        "- U+000D CR",
                        "- U+0009 TAB",
                        "*/",
                        "const jsxWhitespaceUtils = new WhitespaceUtils(\" \\n\\r\\t\");",
                        "",
                        "const isEmptyStringOrAnyLine = (doc) =>",
                        "  doc === \"\" || doc === line || doc === hardline || doc === softline;",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " * @typedef {import(\"../types/estree.js\").JSXElement} JSXElement",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "// JSX expands children from the inside-out, instead of the outside-in.",
                        "// This is both to break children before attributes,",
                        "// and to ensure that when children break, their parents do as well.",
                        "//",
                        "// Any element that is written without any newlines and fits on a single line",
                        "// is left that way.",
                        "// Not only that, any user-written-line containing multiple JSX siblings",
                        "// should also be kept on one line if possible,",
                        "// so each user-written-line is wrapped in its own group.",
                        "//",
                        "// Elements that contain newlines or don't fit on a single line (recursively)",
                        "// are fully-split, using hardline and shouldBreak: true.",
                        "//",
                        "// To support that case properly, all leading and trailing spaces",
                        "// are stripped from the list of children, and replaced with a single hardline.",
                        "function printJsxElementInternal(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (node.type === \"JSXElement\" && isEmptyJsxElement(node)) {",
                        "    return [print(\"openingElement\"), print(\"closingElement\")];",
                        "  }",
                        "",
                        "  const openingLines =",
                        "    node.type === \"JSXElement\"",
                        "      ? print(\"openingElement\")",
                        "      : print(\"openingFragment\");",
                        "  const closingLines =",
                        "    node.type === \"JSXElement\"",
                        "      ? print(\"closingElement\")",
                        "      : print(\"closingFragment\");",
                        "",
                        "  if (",
                        "    node.children.length === 1 &&",
                        "    node.children[0].type === \"JSXExpressionContainer\" &&",
                        "    (node.children[0].expression.type === \"TemplateLiteral\" ||",
                        "      node.children[0].expression.type === \"TaggedTemplateExpression\")",
                        "  ) {",
                        "    return [openingLines, ...path.map(print, \"children\"), closingLines];",
                        "  }",
                        "",
                        "  // Convert `{\" \"}` to text nodes containing a space.",
                        "  // This makes it easy to turn them into `jsxWhitespace` which",
                        "  // can then print as either a space or `{\" \"}` when breaking.",
                        "  node.children = node.children.map((child) => {",
                        "    if (isJsxWhitespaceExpression(child)) {",
                        "      return {",
                        "        type: \"JSXText\",",
                        "        value: \" \",",
                        "        raw: \" \",",
                        "      };",
                        "    }",
                        "    return child;",
                        "  });",
                        "",
                        "  const containsTag = node.children.some(isJsxElement);",
                        "  const containsMultipleExpressions =",
                        "    node.children.filter((child) => child.type === \"JSXExpressionContainer\")",
                        "      .length > 1;",
                        "  const containsMultipleAttributes =",
                        "    node.type === \"JSXElement\" && node.openingElement.attributes.length > 1;",
                        "",
                        "  // Record any breaks. Should never go from true to false, only false to true.",
                        "  let forcedBreak =",
                        "    willBreak(openingLines) ||",
                        "    containsTag ||",
                        "    containsMultipleAttributes ||",
                        "    containsMultipleExpressions;",
                        "",
                        "  const isMdxBlock = path.parent.rootMarker === \"mdx\";",
                        "",
                        "  const rawJsxWhitespace = options.singleQuote ? \"{' '}\" : '{\" \"}';",
                        "  const jsxWhitespace = isMdxBlock",
                        "    ? \" \"",
                        "    : ifBreak([rawJsxWhitespace, softline], \" \");",
                        "",
                        "  const isFacebookTranslationTag = node.openingElement?.name?.name === \"fbt\";",
                        "",
                        "  const children = printJsxChildren(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    jsxWhitespace,",
                        "    isFacebookTranslationTag",
                        "  );",
                        "",
                        "  const containsText = node.children.some((child) =>",
                        "    isMeaningfulJsxText(child)",
                        "  );",
                        "",
                        "  // We can end up we multiple whitespace elements with empty string",
                        "  // content between them.",
                        "  // We need to remove empty whitespace and softlines before JSX whitespace",
                        "  // to get the correct output.",
                        "  for (let i = children.length - 2; i >= 0; i--) {",
                        "    const isPairOfEmptyStrings = children[i] === \"\" && children[i + 1] === \"\";",
                        "    const isPairOfHardlines =",
                        "      children[i] === hardline &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === hardline;",
                        "    const isLineFollowedByJsxWhitespace =",
                        "      (children[i] === softline || children[i] === hardline) &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === jsxWhitespace;",
                        "    const isJsxWhitespaceFollowedByLine =",
                        "      children[i] === jsxWhitespace &&",
                        "      children[i + 1] === \"\" &&",
                        "      (children[i + 2] === softline || children[i + 2] === hardline);",
                        "    const isDoubleJsxWhitespace =",
                        "      children[i] === jsxWhitespace &&",
                        "      children[i + 1] === \"\" &&",
                        "      children[i + 2] === jsxWhitespace;",
                        "    const isPairOfHardOrSoftLines =",
                        "      (children[i] === softline &&",
                        "        children[i + 1] === \"\" &&",
                        "        children[i + 2] === hardline) ||",
                        "      (children[i] === hardline &&",
                        "        children[i + 1] === \"\" &&",
                        "        children[i + 2] === softline);",
                        "",
                        "    if (",
                        "      (isPairOfHardlines && containsText) ||",
                        "      isPairOfEmptyStrings ||",
                        "      isLineFollowedByJsxWhitespace ||",
                        "      isDoubleJsxWhitespace ||",
                        "      isPairOfHardOrSoftLines",
                        "    ) {",
                        "      children.splice(i, 2);",
                        "    } else if (isJsxWhitespaceFollowedByLine) {",
                        "      children.splice(i + 1, 2);",
                        "    }",
                        "  }",
                        "",
                        "  // Trim trailing lines (or empty strings)",
                        "  while (children.length > 0 && isEmptyStringOrAnyLine(children.at(-1))) {",
                        "    children.pop();",
                        "  }",
                        "",
                        "  // Trim leading lines (or empty strings)",
                        "  while (",
                        "    children.length > 1 &&",
                        "    isEmptyStringOrAnyLine(children[0]) &&",
                        "    isEmptyStringOrAnyLine(children[1])",
                        "  ) {",
                        "    children.shift();",
                        "    children.shift();",
                        "  }",
                        "",
                        "  // Tweak how we format children if outputting this element over multiple lines.",
                        "  // Also detect whether we will force this element to output over multiple lines.",
                        "  const multilineChildren = [];",
                        "  for (const [i, child] of children.entries()) {",
                        "    // There are a number of situations where we need to ensure we display",
                        "    // whitespace as `{\" \"}` when outputting this element over multiple lines.",
                        "    if (child === jsxWhitespace) {",
                        "      if (i === 1 && children[i - 1] === \"\") {",
                        "        if (children.length === 2) {",
                        "          // Solitary whitespace",
                        "          multilineChildren.push(rawJsxWhitespace);",
                        "          continue;",
                        "        }",
                        "        // Leading whitespace",
                        "        multilineChildren.push([rawJsxWhitespace, hardline]);",
                        "        continue;",
                        "      } else if (i === children.length - 1) {",
                        "        // Trailing whitespace",
                        "        multilineChildren.push(rawJsxWhitespace);",
                        "        continue;",
                        "      } else if (children[i - 1] === \"\" && children[i - 2] === hardline) {",
                        "        // Whitespace after line break",
                        "        multilineChildren.push(rawJsxWhitespace);",
                        "        continue;",
                        "      }",
                        "    }",
                        "",
                        "    multilineChildren.push(child);",
                        "",
                        "    if (willBreak(child)) {",
                        "      forcedBreak = true;",
                        "    }",
                        "  }",
                        "",
                        "  // If there is text we use `fill` to fit as much onto each line as possible.",
                        "  // When there is no text (just tags and expressions) we use `group`",
                        "  // to output each on a separate line.",
                        "  /** @type {Doc} */",
                        "  let content = containsText",
                        "    ? fill(multilineChildren)",
                        "    : group(multilineChildren, { shouldBreak: true });",
                        "",
                        "  /*",
                        "  `printJsxChildren` won't call `print` on `JSXText`",
                        "  When the cursorNode is inside `cursor` won't get print.",
                        "  */",
                        "  if (",
                        "    options.cursorNode?.type === \"JSXText\" &&",
                        "    node.children.includes(options.cursorNode)",
                        "  ) {",
                        "    content = [cursor, content, cursor];",
                        "  }",
                        "",
                        "  if (isMdxBlock) {",
                        "    return content;",
                        "  }",
                        "",
                        "  const multiLineElem = group([",
                        "    openingLines,",
                        "    indent([hardline, content]),",
                        "    hardline,",
                        "    closingLines,",
                        "  ]);",
                        "",
                        "  if (forcedBreak) {",
                        "    return multiLineElem;",
                        "  }",
                        "",
                        "  return conditionalGroup([",
                        "    group([openingLines, ...children, closingLines]),",
                        "    multiLineElem,",
                        "  ]);",
                        "}",
                        "",
                        "// JSX Children are strange, mostly for two reasons:",
                        "// 1. JSX reads newlines into string values, instead of skipping them like JS",
                        "// 2. up to one whitespace between elements within a line is significant,",
                        "//    but not between lines.",
                        "//",
                        "// Leading, trailing, and lone whitespace all need to",
                        "// turn themselves into the rather ugly `{' '}` when breaking.",
                        "//",
                        "// We print JSX using the `fill` doc primitive.",
                        "// This requires that we give it an array of alternating",
                        "// content and whitespace elements.",
                        "// To ensure this we add dummy `\"\"` content elements as needed.",
                        "function printJsxChildren(",
                        "  path,",
                        "  options,",
                        "  print,",
                        "  jsxWhitespace,",
                        "  isFacebookTranslationTag",
                        ") {",
                        "  const parts = [];",
                        "  path.each(({ node, next }) => {",
                        "    if (node.type === \"JSXText\") {",
                        "      const text = rawText(node);",
                        "",
                        "      // Contains a non-whitespace character",
                        "      if (isMeaningfulJsxText(node)) {",
                        "        const words = jsxWhitespaceUtils.split(",
                        "          text,",
                        "          /* captureWhitespace */ true",
                        "        );",
                        "",
                        "        // Starts with whitespace",
                        "        if (words[0] === \"\") {",
                        "          parts.push(\"\");",
                        "          words.shift();",
                        "          if (/\\n/.test(words[0])) {",
                        "            parts.push(",
                        "              separatorWithWhitespace(",
                        "                isFacebookTranslationTag,",
                        "                words[1],",
                        "                node,",
                        "                next",
                        "              )",
                        "            );",
                        "          } else {",
                        "            parts.push(jsxWhitespace);",
                        "          }",
                        "          words.shift();",
                        "        }",
                        "",
                        "        let endWhitespace;",
                        "        // Ends with whitespace",
                        "        if (words.at(-1) === \"\") {",
                        "          words.pop();",
                        "          endWhitespace = words.pop();",
                        "        }",
                        "",
                        "        // This was whitespace only without a new line.",
                        "        if (words.length === 0) {",
                        "          return;",
                        "        }",
                        "",
                        "        for (const [i, word] of words.entries()) {",
                        "          if (i % 2 === 1) {",
                        "            parts.push(line);",
                        "          } else {",
                        "            parts.push(word);",
                        "          }",
                        "        }",
                        "",
                        "        if (endWhitespace !== undefined) {",
                        "          if (/\\n/.test(endWhitespace)) {",
                        "            parts.push(",
                        "              separatorWithWhitespace(",
                        "                isFacebookTranslationTag,",
                        "                parts.at(-1),",
                        "                node,",
                        "                next",
                        "              )",
                        "            );",
                        "          } else {",
                        "            parts.push(jsxWhitespace);",
                        "          }",
                        "        } else {",
                        "          parts.push(",
                        "            separatorNoWhitespace(",
                        "              isFacebookTranslationTag,",
                        "              parts.at(-1),",
                        "              node,",
                        "              next",
                        "            )",
                        "          );",
                        "        }",
                        "      } else if (/\\n/.test(text)) {",
                        "        // Keep (up to one) blank line between tags/expressions/text.",
                        "        // Note: We don't keep blank lines between text elements.",
                        "        if (text.match(/\\n/g).length > 1) {",
                        "          parts.push(\"\", hardline);",
                        "        }",
                        "      } else {",
                        "        parts.push(\"\", jsxWhitespace);",
                        "      }",
                        "    } else {",
                        "      const printedChild = print();",
                        "      parts.push(printedChild);",
                        "",
                        "      const directlyFollowedByMeaningfulText =",
                        "        next && isMeaningfulJsxText(next);",
                        "      if (directlyFollowedByMeaningfulText) {",
                        "        const trimmed = jsxWhitespaceUtils.trim(rawText(next));",
                        "        const [firstWord] = jsxWhitespaceUtils.split(trimmed);",
                        "        parts.push(",
                        "          separatorNoWhitespace(isFacebookTranslationTag, firstWord, node, next)",
                        "        );",
                        "      } else {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, \"children\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function separatorNoWhitespace(",
                        "  isFacebookTranslationTag,",
                        "  child,",
                        "  childNode,",
                        "  nextNode",
                        ") {",
                        "  if (isFacebookTranslationTag) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  if (",
                        "    (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                        "    (nextNode?.type === \"JSXElement\" && !nextNode.closingElement)",
                        "  ) {",
                        "    return child.length === 1 ? softline : hardline;",
                        "  }",
                        "",
                        "  return softline;",
                        "}",
                        "",
                        "function separatorWithWhitespace(",
                        "  isFacebookTranslationTag,",
                        "  child,",
                        "  childNode,",
                        "  nextNode",
                        ") {",
                        "  if (isFacebookTranslationTag) {",
                        "    return hardline;",
                        "  }",
                        "",
                        "  if (child.length === 1) {",
                        "    return (childNode.type === \"JSXElement\" && !childNode.closingElement) ||",
                        "      (nextNode?.type === \"JSXElement\" && !nextNode.closingElement)",
                        "      ? hardline",
                        "      : softline;",
                        "  }",
                        "",
                        "  return hardline;",
                        "}",
                        "",
                        "const NO_WRAP_PARENTS = new Set([",
                        "  \"ArrayExpression\",",
                        "  \"TupleExpression\",",
                        "  \"JSXAttribute\",",
                        "  \"JSXElement\",",
                        "  \"JSXExpressionContainer\",",
                        "  \"JSXFragment\",",
                        "  \"ExpressionStatement\",",
                        "  \"CallExpression\",",
                        "  \"OptionalCallExpression\",",
                        "  \"ConditionalExpression\",",
                        "  \"JsExpressionRoot\",",
                        "]);",
                        "function maybeWrapJsxElementInParens(path, elem, options) {",
                        "  const { parent } = path;",
                        "",
                        "  if (NO_WRAP_PARENTS.has(parent.type)) {",
                        "    return elem;",
                        "  }",
                        "",
                        "  const shouldBreak = path.match(",
                        "    undefined,",
                        "    (node) => node.type === \"ArrowFunctionExpression\",",
                        "    isCallExpression,",
                        "    (node) => node.type === \"JSXExpressionContainer\"",
                        "  );",
                        "",
                        "  const needsParens = pathNeedsParens(path, options);",
                        "",
                        "  return group(",
                        "    [",
                        "      needsParens ? \"\" : ifBreak(\"(\"),",
                        "      indent([softline, elem]),",
                        "      softline,",
                        "      needsParens ? \"\" : ifBreak(\")\"),",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "function printJsxAttribute(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "  parts.push(print(\"name\"));",
                        "",
                        "  if (node.value) {",
                        "    let res;",
                        "    if (isStringLiteral(node.value)) {",
                        "      const raw = rawText(node.value);",
                        "      // Remove enclosing quotes and unescape",
                        "      // all quotes so we get an accurate preferred quote",
                        "      let final = raw",
                        "        .slice(1, -1)",
                        "        .replaceAll(\"&apos;\", \"'\")",
                        "        .replaceAll(\"&quot;\", '\"');",
                        "      const quote = getPreferredQuote(final, options.jsxSingleQuote);",
                        "      final =",
                        "        quote === '\"'",
                        "          ? final.replaceAll('\"', \"&quot;\")",
                        "          : final.replaceAll(\"'\", \"&apos;\");",
                        "      res = path.call(",
                        "        () =>",
                        "          printComments(path, replaceEndOfLine(quote + final + quote), options),",
                        "        \"value\"",
                        "      );",
                        "    } else {",
                        "      res = print(\"value\");",
                        "    }",
                        "    parts.push(\"=\", res);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJsxExpressionContainer(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  const shouldInline = (node, parent) =>",
                        "    node.type === \"JSXEmptyExpression\" ||",
                        "    (!hasComment(node) &&",
                        "      (isArrayOrTupleExpression(node) ||",
                        "        isObjectOrRecordExpression(node) ||",
                        "        node.type === \"ArrowFunctionExpression\" ||",
                        "        (node.type === \"AwaitExpression\" &&",
                        "          (shouldInline(node.argument, node) ||",
                        "            node.argument.type === \"JSXElement\")) ||",
                        "        isCallExpression(node) ||",
                        "        (node.type === \"ChainExpression\" &&",
                        "          isCallExpression(node.expression)) ||",
                        "        node.type === \"FunctionExpression\" ||",
                        "        node.type === \"TemplateLiteral\" ||",
                        "        node.type === \"TaggedTemplateExpression\" ||",
                        "        node.type === \"DoExpression\" ||",
                        "        (isJsxElement(parent) &&",
                        "          (node.type === \"ConditionalExpression\" || isBinaryish(node)))));",
                        "",
                        "  if (shouldInline(node.expression, path.parent)) {",
                        "    return group([\"{\", print(\"expression\"), lineSuffixBoundary, \"}\"]);",
                        "  }",
                        "",
                        "  return group([",
                        "    \"{\",",
                        "    indent([softline, print(\"expression\")]),",
                        "    softline,",
                        "    lineSuffixBoundary,",
                        "    \"}\",",
                        "  ]);",
                        "}",
                        "",
                        "function printJsxOpeningElement(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  const nameHasComments =",
                        "    hasComment(node.name) || hasComment(node.typeParameters);",
                        "",
                        "  // Don't break self-closing elements with no attributes and no comments",
                        "  if (node.selfClosing && node.attributes.length === 0 && !nameHasComments) {",
                        "    return [\"<\", print(\"name\"), print(\"typeParameters\"), \" />\"];",
                        "  }",
                        "",
                        "  // don't break up opening elements with a single long text attribute",
                        "  if (",
                        "    node.attributes?.length === 1 &&",
                        "    node.attributes[0].value &&",
                        "    isStringLiteral(node.attributes[0].value) &&",
                        "    !node.attributes[0].value.value.includes(\"\\n\") &&",
                        "    // We should break for the following cases:",
                        "    // <div",
                        "    //   // comment",
                        "    //   attr=\"value\"",
                        "    // >",
                        "    // <div",
                        "    //   attr=\"value\"",
                        "    //   // comment",
                        "    // >",
                        "    !nameHasComments &&",
                        "    !hasComment(node.attributes[0])",
                        "  ) {",
                        "    return group([",
                        "      \"<\",",
                        "      print(\"name\"),",
                        "      print(\"typeParameters\"),",
                        "      \" \",",
                        "      ...path.map(print, \"attributes\"),",
                        "      node.selfClosing ? \" />\" : \">\",",
                        "    ]);",
                        "  }",
                        "",
                        "  // We should print the opening element expanded if any prop value is a",
                        "  // string literal with newlines",
                        "  const shouldBreak = node.attributes?.some(",
                        "    (attr) =>",
                        "      attr.value &&",
                        "      isStringLiteral(attr.value) &&",
                        "      attr.value.value.includes(\"\\n\")",
                        "  );",
                        "",
                        "  const attributeLine =",
                        "    options.singleAttributePerLine && node.attributes.length > 1",
                        "      ? hardline",
                        "      : line;",
                        "",
                        "  return group(",
                        "    [",
                        "      \"<\",",
                        "      print(\"name\"),",
                        "      print(\"typeParameters\"),",
                        "      indent(path.map(() => [attributeLine, print()], \"attributes\")),",
                        "      ...printEndOfOpeningTag(node, options, nameHasComments),",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "function printEndOfOpeningTag(node, options, nameHasComments) {",
                        "  if (node.selfClosing) {",
                        "    return [line, \"/>\"];",
                        "  }",
                        "  const bracketSameLine = shouldPrintBracketSameLine(",
                        "    node,",
                        "    options,",
                        "    nameHasComments",
                        "  );",
                        "  if (bracketSameLine) {",
                        "    return [\">\"];",
                        "  }",
                        "  return [softline, \">\"];",
                        "}",
                        "",
                        "function shouldPrintBracketSameLine(node, options, nameHasComments) {",
                        "  const lastAttrHasTrailingComments =",
                        "    node.attributes.length > 0 &&",
                        "    hasComment(node.attributes.at(-1), CommentCheckFlags.Trailing);",
                        "  return (",
                        "    // Simple tags (no attributes and no comment in tag name) should be",
                        "    // kept unbroken regardless of `bracketSameLine`.",
                        "    // jsxBracketSameLine is deprecated in favour of bracketSameLine,",
                        "    // but is still needed for backwards compatibility.",
                        "    (node.attributes.length === 0 && !nameHasComments) ||",
                        "    ((options.bracketSameLine || options.jsxBracketSameLine) &&",
                        "      // We should print the bracket in a new line for the following cases:",
                        "      // <div",
                        "      //   // comment",
                        "      // >",
                        "      // <div",
                        "      //   attr // comment",
                        "      // >",
                        "      (!nameHasComments || node.attributes.length > 0) &&",
                        "      !lastAttrHasTrailingComments)",
                        "  );",
                        "}",
                        "",
                        "function printJsxClosingElement(path, options, print) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "",
                        "  parts.push(\"</\");",
                        "",
                        "  const printed = print(\"name\");",
                        "  if (",
                        "    hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Line)",
                        "  ) {",
                        "    parts.push(indent([hardline, printed]), hardline);",
                        "  } else if (",
                        "    hasComment(node.name, CommentCheckFlags.Leading | CommentCheckFlags.Block)",
                        "  ) {",
                        "    parts.push(\" \", printed);",
                        "  } else {",
                        "    parts.push(printed);",
                        "  }",
                        "",
                        "  parts.push(\">\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printJsxOpeningClosingFragment(path, options /*, print*/) {",
                        "  const { node } = path;",
                        "  const nodeHasComment = hasComment(node);",
                        "  const hasOwnLineComment = hasComment(node, CommentCheckFlags.Line);",
                        "  const isOpeningFragment = node.type === \"JSXOpeningFragment\";",
                        "  return [",
                        "    isOpeningFragment ? \"<\" : \"</\",",
                        "    indent([",
                        "      hasOwnLineComment",
                        "        ? hardline",
                        "        : nodeHasComment && !isOpeningFragment",
                        "        ? \" \"",
                        "        : \"\",",
                        "      printDanglingComments(path, options),",
                        "    ]),",
                        "    hasOwnLineComment ? hardline : \"\",",
                        "    \">\",",
                        "  ];",
                        "}",
                        "",
                        "function printJsxElement(path, options, print) {",
                        "  const elem = printComments(",
                        "    path,",
                        "    printJsxElementInternal(path, options, print),",
                        "    options",
                        "  );",
                        "  return maybeWrapJsxElementInParens(path, elem, options);",
                        "}",
                        "",
                        "function printJsxEmptyExpression(path, options /*, print*/) {",
                        "  const { node } = path;",
                        "  const requiresHardline = hasComment(node, CommentCheckFlags.Line);",
                        "",
                        "  return [",
                        "    printDanglingComments(path, options, { indent: requiresHardline }),",
                        "    requiresHardline ? hardline : \"\",",
                        "  ];",
                        "}",
                        "",
                        "// `JSXSpreadAttribute` and `JSXSpreadChild`",
                        "function printJsxSpreadAttributeOrChild(path, options, print) {",
                        "  const { node } = path;",
                        "  return [",
                        "    \"{\",",
                        "    path.call(",
                        "      ({ node }) => {",
                        "        const printed = [\"...\", print()];",
                        "        if (!hasComment(node) || !willPrintOwnComments(path)) {",
                        "          return printed;",
                        "        }",
                        "        return [",
                        "          indent([softline, printComments(path, printed, options)]),",
                        "          softline,",
                        "        ];",
                        "      },",
                        "      node.type === \"JSXSpreadAttribute\" ? \"argument\" : \"expression\"",
                        "    ),",
                        "    \"}\",",
                        "  ];",
                        "}",
                        "",
                        "function printJsx(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  // JSX nodes always starts with `JSX`",
                        "  if (!node.type.startsWith(\"JSX\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"JSXAttribute\":",
                        "      return printJsxAttribute(path, options, print);",
                        "    case \"JSXIdentifier\":",
                        "      return node.name;",
                        "    case \"JSXNamespacedName\":",
                        "      return join(\":\", [print(\"namespace\"), print(\"name\")]);",
                        "    case \"JSXMemberExpression\":",
                        "      return join(\".\", [print(\"object\"), print(\"property\")]);",
                        "    case \"JSXSpreadAttribute\":",
                        "    case \"JSXSpreadChild\":",
                        "      return printJsxSpreadAttributeOrChild(path, options, print);",
                        "    case \"JSXExpressionContainer\":",
                        "      return printJsxExpressionContainer(path, options, print);",
                        "    case \"JSXFragment\":",
                        "    case \"JSXElement\":",
                        "      return printJsxElement(path, options, print);",
                        "    case \"JSXOpeningElement\":",
                        "      return printJsxOpeningElement(path, options, print);",
                        "    case \"JSXClosingElement\":",
                        "      return printJsxClosingElement(path, options, print);",
                        "    case \"JSXOpeningFragment\":",
                        "    case \"JSXClosingFragment\":",
                        "      return printJsxOpeningClosingFragment(path, options /*, print*/);",
                        "    case \"JSXEmptyExpression\":",
                        "      return printJsxEmptyExpression(path, options /*, print*/);",
                        "    case \"JSXText\":",
                        "      /* c8 ignore next */",
                        "      throw new Error(\"JSXText should be handled by JSXElement\");",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      throw new UnexpectedNodeError(node, \"JSX\");",
                        "  }",
                        "}",
                        "",
                        "/**",
                        " * @param {JSXElement} node",
                        " * @returns {boolean}",
                        " */",
                        "function isEmptyJsxElement(node) {",
                        "  if (node.children.length === 0) {",
                        "    return true;",
                        "  }",
                        "  if (node.children.length > 1) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // if there is one text child and does not contain any meaningful text",
                        "  // we can treat the element as empty.",
                        "  const child = node.children[0];",
                        "  return child.type === \"JSXText\" && !isMeaningfulJsxText(child);",
                        "}",
                        "",
                        "// Meaningful if it contains non-whitespace characters,",
                        "// or it contains whitespace without a new line.",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isMeaningfulJsxText(node) {",
                        "  return (",
                        "    node.type === \"JSXText\" &&",
                        "    (jsxWhitespaceUtils.hasNonWhitespaceCharacter(rawText(node)) ||",
                        "      !/\\n/.test(rawText(node)))",
                        "  );",
                        "}",
                        "",
                        "// Detect an expression node representing `{\" \"}`",
                        "function isJsxWhitespaceExpression(node) {",
                        "  return (",
                        "    node.type === \"JSXExpressionContainer\" &&",
                        "    isStringLiteral(node.expression) &&",
                        "    node.expression.value === \" \" &&",
                        "    !hasComment(node.expression)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function hasJsxIgnoreComment(path) {",
                        "  const { node, parent } = path;",
                        "  if (!isJsxElement(node) || !isJsxElement(parent)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // TODO: Use `Array#findLast` when we drop support for Node.js<18",
                        "  // Lookup the previous sibling, ignoring any empty JSXText elements",
                        "  const { index, siblings } = path;",
                        "  let prevSibling;",
                        "  for (let i = index; i > 0; i--) {",
                        "    const candidate = siblings[i - 1];",
                        "    if (candidate.type === \"JSXText\" && !isMeaningfulJsxText(candidate)) {",
                        "      continue;",
                        "    }",
                        "    prevSibling = candidate;",
                        "    break;",
                        "  }",
                        "",
                        "  return (",
                        "    prevSibling?.type === \"JSXExpressionContainer\" &&",
                        "    prevSibling.expression.type === \"JSXEmptyExpression\" &&",
                        "    hasNodeIgnoreComment(prevSibling.expression)",
                        "  );",
                        "}",
                        "",
                        "export { hasJsxIgnoreComment, printJsx };"
                    ]
                },
                "literal.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import printString from \"../../utils/print-string.js\";",
                        "import printNumber from \"../../utils/print-number.js\";",
                        "import { replaceEndOfLine } from \"../../document/utils.js\";",
                        "import { createTypeCheckFunction } from \"../utils/index.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " */",
                        "",
                        "function printLiteral(path, options /*, print*/) {",
                        "  const { node } = path;",
                        "",
                        "  switch (node.type) {",
                        "    case \"RegExpLiteral\": // Babel 6 Literal split",
                        "      return printRegex(node);",
                        "    case \"BigIntLiteral\":",
                        "      return printBigInt(node.extra.raw);",
                        "    case \"NumericLiteral\": // Babel 6 Literal split",
                        "      return printNumber(node.extra.raw);",
                        "    case \"StringLiteral\": // Babel 6 Literal split",
                        "      return replaceEndOfLine(printString(node.extra.raw, options));",
                        "    case \"NullLiteral\": // Babel 6 Literal split",
                        "      return \"null\";",
                        "    case \"BooleanLiteral\": // Babel 6 Literal split",
                        "      return String(node.value);",
                        "    case \"DecimalLiteral\":",
                        "      return printNumber(node.value) + \"m\";",
                        "    case \"DirectiveLiteral\":",
                        "      return printDirective(node.extra.raw, options);",
                        "    case \"Literal\": {",
                        "      if (node.regex) {",
                        "        return printRegex(node.regex);",
                        "      }",
                        "",
                        "      if (node.bigint) {",
                        "        return printBigInt(node.raw);",
                        "      }",
                        "",
                        "      if (node.decimal) {",
                        "        return printNumber(node.decimal) + \"m\";",
                        "      }",
                        "",
                        "      const { value } = node;",
                        "",
                        "      if (typeof value === \"number\") {",
                        "        return printNumber(node.raw);",
                        "      }",
                        "",
                        "      if (typeof value === \"string\") {",
                        "        return isDirective(path)",
                        "          ? printDirective(node.raw, options)",
                        "          : replaceEndOfLine(printString(node.raw, options));",
                        "      }",
                        "      return String(value);",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "function isDirective(path) {",
                        "  if (path.key !== \"expression\") {",
                        "    return;",
                        "  }",
                        "",
                        "  const { parent } = path;",
                        "  return parent.type === \"ExpressionStatement\" && parent.directive;",
                        "}",
                        "",
                        "function printBigInt(raw) {",
                        "  return raw.toLowerCase();",
                        "}",
                        "",
                        "function printRegex({ pattern, flags }) {",
                        "  flags = [...flags].sort().join(\"\");",
                        "  return `/${pattern}/${flags}`;",
                        "}",
                        "",
                        "function printDirective(rawText, options) {",
                        "  const rawContent = rawText.slice(1, -1);",
                        "",
                        "  // Check for the alternate quote, to determine if we're allowed to swap",
                        "  // the quotes on a DirectiveLiteral.",
                        "  if (rawContent.includes('\"') || rawContent.includes(\"'\")) {",
                        "    return rawText;",
                        "  }",
                        "",
                        "  const enclosingQuote = options.singleQuote ? \"'\" : '\"';",
                        "",
                        "  // Directives are exact code unit sequences, which means that you can't",
                        "  // change the escape sequences they use.",
                        "  // See https://github.com/prettier/prettier/issues/1555",
                        "  // and https://tc39.github.io/ecma262/#directive-prologue",
                        "  return enclosingQuote + rawContent + enclosingQuote;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isLiteral = createTypeCheckFunction([",
                        "  \"Literal\",",
                        "  // Babel, flow uses `BigIntLiteral` too",
                        "  \"BigIntLiteral\",",
                        "  \"BooleanLiteral\",",
                        "  \"DecimalLiteral\",",
                        "  \"DirectiveLiteral\",",
                        "  \"NullLiteral\",",
                        "  \"NumericLiteral\",",
                        "  \"RegExpLiteral\",",
                        "  \"StringLiteral\",",
                        "]);",
                        "",
                        "export { printLiteral, printBigInt, isLiteral };"
                    ]
                },
                "mapped-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import hasNewlineInRange from \"../../utils/has-newline-in-range.js\";",
                        "import { locStart } from \"../loc.js\";",
                        "import {",
                        "  group,",
                        "  softline,",
                        "  indent,",
                        "  ifBreak,",
                        "  line,",
                        "} from \"../../document/builders.js\";",
                        "",
                        "/**",
                        " * @param {string | null} optional",
                        " * @returns {string}",
                        " */",
                        "function printFlowMappedTypeOptionalModifier(optional) {",
                        "  switch (optional) {",
                        "    case null:",
                        "      return \"\";",
                        "    case \"PlusOptional\":",
                        "      return \"+?\";",
                        "    case \"MinusOptional\":",
                        "      return \"-?\";",
                        "    case \"Optional\":",
                        "      return \"?\";",
                        "  }",
                        "}",
                        "",
                        "function printFlowMappedTypeProperty(path, options, print) {",
                        "  const { node } = path;",
                        "  return group([",
                        "    node.variance ? print(\"variance\") : \"\",",
                        "    \"[\",",
                        "    indent([print(\"keyTparam\"), \" in \", print(\"sourceType\")]),",
                        "    \"]\",",
                        "    printFlowMappedTypeOptionalModifier(node.optional),",
                        "    \": \",",
                        "    print(\"propType\"),",
                        "  ]);",
                        "}",
                        "",
                        "/**",
                        " * @param {string} tokenNode",
                        " * @param {string} keyword",
                        " * @returns {string}",
                        " */",
                        "function printTypeScriptMappedTypeModifier(tokenNode, keyword) {",
                        "  if (tokenNode === \"+\" || tokenNode === \"-\") {",
                        "    return tokenNode + keyword;",
                        "  }",
                        "",
                        "  return keyword;",
                        "}",
                        "",
                        "function printTypescriptMappedType(path, options, print) {",
                        "  const { node } = path;",
                        "  // Break after `{` like `printObject`",
                        "  const shouldBreak = hasNewlineInRange(",
                        "    options.originalText,",
                        "    locStart(node),",
                        "    // Ideally, this should be the next token after `{`, but there is no node starts with it.",
                        "    locStart(node.typeParameter)",
                        "  );",
                        "",
                        "  return group(",
                        "    [",
                        "      \"{\",",
                        "      indent([",
                        "        options.bracketSpacing ? line : softline,",
                        "        group([",
                        "          print(\"typeParameter\"),",
                        "          node.optional",
                        "            ? printTypeScriptMappedTypeModifier(node.optional, \"?\")",
                        "            : \"\",",
                        "          node.typeAnnotation ? \": \" : \"\",",
                        "          print(\"typeAnnotation\"),",
                        "        ]),",
                        "        options.semi ? ifBreak(\";\") : \"\",",
                        "      ]),",
                        "      printDanglingComments(path, options),",
                        "      options.bracketSpacing ? line : softline,",
                        "      \"}\",",
                        "    ],",
                        "    { shouldBreak }",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  printFlowMappedTypeProperty,",
                        "  printTypeScriptMappedTypeModifier,",
                        "  printTypescriptMappedType,",
                        "};"
                    ]
                },
                "member-chain.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printComments } from \"../../main/comments/print.js\";",
                        "import isNextLineEmptyAfterIndex from \"../../utils/is-next-line-empty.js\";",
                        "import getNextNonSpaceNonCommentCharacterIndex from \"../../utils/get-next-non-space-non-comment-character-index.js\";",
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import {",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isFunctionOrArrowExpression,",
                        "  isLongCurriedCallExpression,",
                        "  isMemberish,",
                        "  isNumericLiteral,",
                        "  isSimpleCallArgument,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "} from \"../utils/index.js\";",
                        "import { locEnd } from \"../loc.js\";",
                        "",
                        "import {",
                        "  join,",
                        "  hardline,",
                        "  group,",
                        "  indent,",
                        "  conditionalGroup,",
                        "  breakParent,",
                        "  label,",
                        "} from \"../../document/builders.js\";",
                        "import { willBreak } from \"../../document/utils.js\";",
                        "import printCallArguments from \"./call-arguments.js\";",
                        "import { printMemberLookup } from \"./member.js\";",
                        "import {",
                        "  printOptionalToken,",
                        "  printFunctionTypeParameters,",
                        "  printBindExpressionCallee,",
                        "} from \"./misc.js\";",
                        "",
                        "// We detect calls on member expressions specially to format a",
                        "// common pattern better. The pattern we are looking for is this:",
                        "//",
                        "// arr",
                        "//   .map(x => x + 1)",
                        "//   .filter(x => x > 10)",
                        "//   .some(x => x % 2)",
                        "//",
                        "// The way it is structured in the AST is via a nested sequence of",
                        "// MemberExpression and CallExpression. We need to traverse the AST",
                        "// and make groups out of it to print it in the desired way.",
                        "function printMemberChain(path, options, print) {",
                        "  const { parent } = path;",
                        "  const isExpressionStatement =",
                        "    !parent || parent.type === \"ExpressionStatement\";",
                        "",
                        "  // The first phase is to linearize the AST by traversing it down.",
                        "  //",
                        "  //   a().b()",
                        "  // has the following AST structure:",
                        "  //   CallExpression(MemberExpression(CallExpression(Identifier)))",
                        "  // and we transform it into",
                        "  //   [Identifier, CallExpression, MemberExpression, CallExpression]",
                        "  const printedNodes = [];",
                        "",
                        "  // Here we try to retain one typed empty line after each call expression or",
                        "  // the first group whether it is in parentheses or not",
                        "  function shouldInsertEmptyLineAfter(node) {",
                        "    const { originalText } = options;",
                        "    const nextCharIndex = getNextNonSpaceNonCommentCharacterIndex(",
                        "      originalText,",
                        "      locEnd(node)",
                        "    );",
                        "    const nextChar = originalText.charAt(nextCharIndex);",
                        "",
                        "    // if it is cut off by a parenthesis, we only account for one typed empty",
                        "    // line after that parenthesis",
                        "    if (nextChar === \")\") {",
                        "      return (",
                        "        nextCharIndex !== false &&",
                        "        isNextLineEmptyAfterIndex(originalText, nextCharIndex + 1)",
                        "      );",
                        "    }",
                        "",
                        "    return isNextLineEmpty(node, options);",
                        "  }",
                        "",
                        "  function rec(path) {",
                        "    const { node } = path;",
                        "    if (",
                        "      isCallExpression(node) &&",
                        "      (isMemberish(node.callee) || isCallExpression(node.callee))",
                        "    ) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: [",
                        "          printComments(",
                        "            path,",
                        "            [",
                        "              printOptionalToken(path),",
                        "              printFunctionTypeParameters(path, options, print),",
                        "              printCallArguments(path, options, print),",
                        "            ],",
                        "            options",
                        "          ),",
                        "          shouldInsertEmptyLineAfter(node) ? hardline : \"\",",
                        "        ],",
                        "      });",
                        "      path.call((callee) => rec(callee), \"callee\");",
                        "    } else if (isMemberish(node)) {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        needsParens: pathNeedsParens(path, options),",
                        "        printed: printComments(",
                        "          path,",
                        "          isMemberExpression(node)",
                        "            ? printMemberLookup(path, options, print)",
                        "            : printBindExpressionCallee(path, options, print),",
                        "          options",
                        "        ),",
                        "      });",
                        "      path.call((object) => rec(object), \"object\");",
                        "    } else if (node.type === \"TSNonNullExpression\") {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: printComments(path, \"!\", options),",
                        "      });",
                        "      path.call((expression) => rec(expression), \"expression\");",
                        "    } else {",
                        "      printedNodes.unshift({",
                        "        node,",
                        "        printed: print(),",
                        "      });",
                        "    }",
                        "  }",
                        "  // Note: the comments of the root node have already been printed, so we",
                        "  // need to extract this first call without printing them as they would",
                        "  // if handled inside of the recursive call.",
                        "  const { node } = path;",
                        "  printedNodes.unshift({",
                        "    node,",
                        "    printed: [",
                        "      printOptionalToken(path),",
                        "      printFunctionTypeParameters(path, options, print),",
                        "      printCallArguments(path, options, print),",
                        "    ],",
                        "  });",
                        "",
                        "  if (node.callee) {",
                        "    path.call((callee) => rec(callee), \"callee\");",
                        "  }",
                        "",
                        "  // Once we have a linear list of printed nodes, we want to create groups out",
                        "  // of it.",
                        "  //",
                        "  //   a().b.c().d().e",
                        "  // will be grouped as",
                        "  //   [",
                        "  //     [Identifier, CallExpression],",
                        "  //     [MemberExpression, MemberExpression, CallExpression],",
                        "  //     [MemberExpression, CallExpression],",
                        "  //     [MemberExpression],",
                        "  //   ]",
                        "  // so that we can print it as",
                        "  //   a()",
                        "  //     .b.c()",
                        "  //     .d()",
                        "  //     .e",
                        "",
                        "  // The first group is the first node followed by",
                        "  //   - as many CallExpression as possible",
                        "  //       < fn()()() >.something()",
                        "  //   - as many array accessors as possible",
                        "  //       < fn()[0][1][2] >.something()",
                        "  //   - then, as many MemberExpression as possible but the last one",
                        "  //       < this.items >.something()",
                        "  const groups = [];",
                        "  let currentGroup = [printedNodes[0]];",
                        "  let i = 1;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (",
                        "      printedNodes[i].node.type === \"TSNonNullExpression\" ||",
                        "      isCallExpression(printedNodes[i].node) ||",
                        "      (isMemberExpression(printedNodes[i].node) &&",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property))",
                        "    ) {",
                        "      currentGroup.push(printedNodes[i]);",
                        "    } else {",
                        "      break;",
                        "    }",
                        "  }",
                        "  if (!isCallExpression(printedNodes[0].node)) {",
                        "    for (; i + 1 < printedNodes.length; ++i) {",
                        "      if (",
                        "        isMemberish(printedNodes[i].node) &&",
                        "        isMemberish(printedNodes[i + 1].node)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "      } else {",
                        "        break;",
                        "      }",
                        "    }",
                        "  }",
                        "  groups.push(currentGroup);",
                        "  currentGroup = [];",
                        "",
                        "  // Then, each following group is a sequence of MemberExpression followed by",
                        "  // a sequence of CallExpression. To compute it, we keep adding things to the",
                        "  // group until we has seen a CallExpression in the past and reach a",
                        "  // MemberExpression",
                        "  let hasSeenCallExpression = false;",
                        "  for (; i < printedNodes.length; ++i) {",
                        "    if (hasSeenCallExpression && isMemberish(printedNodes[i].node)) {",
                        "      // [0] should be appended at the end of the group instead of the",
                        "      // beginning of the next one",
                        "      if (",
                        "        printedNodes[i].node.computed &&",
                        "        isNumericLiteral(printedNodes[i].node.property)",
                        "      ) {",
                        "        currentGroup.push(printedNodes[i]);",
                        "        continue;",
                        "      }",
                        "",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "",
                        "    if (",
                        "      isCallExpression(printedNodes[i].node) ||",
                        "      printedNodes[i].node.type === \"ImportExpression\"",
                        "    ) {",
                        "      hasSeenCallExpression = true;",
                        "    }",
                        "    currentGroup.push(printedNodes[i]);",
                        "",
                        "    if (hasComment(printedNodes[i].node, CommentCheckFlags.Trailing)) {",
                        "      groups.push(currentGroup);",
                        "      currentGroup = [];",
                        "      hasSeenCallExpression = false;",
                        "    }",
                        "  }",
                        "  if (currentGroup.length > 0) {",
                        "    groups.push(currentGroup);",
                        "  }",
                        "",
                        "  // There are cases like Object.keys(), Observable.of(), _.values() where",
                        "  // they are the subject of all the chained calls and therefore should",
                        "  // be kept on the same line:",
                        "  //",
                        "  //   Object.keys(items)",
                        "  //     .filter(x => x)",
                        "  //     .map(x => x)",
                        "  //",
                        "  // In order to detect those cases, we use an heuristic: if the first",
                        "  // node is an identifier with the name starting with a capital",
                        "  // letter or just a sequence of _$. The rationale is that they are",
                        "  // likely to be factories.",
                        "  function isFactory(name) {",
                        "    return /^[A-Z]|^[$_]+$/.test(name);",
                        "  }",
                        "",
                        "  // In case the Identifier is shorter than tab width, we can keep the",
                        "  // first call in a single line, if it's an ExpressionStatement.",
                        "  //",
                        "  //   d3.scaleLinear()",
                        "  //     .domain([0, 100])",
                        "  //     .range([0, width]);",
                        "  //",
                        "  function isShort(name) {",
                        "    return name.length <= options.tabWidth;",
                        "  }",
                        "",
                        "  function shouldNotWrap(groups) {",
                        "    const hasComputed = groups[1][0]?.node.computed;",
                        "",
                        "    if (groups[0].length === 1) {",
                        "      const firstNode = groups[0][0].node;",
                        "      return (",
                        "        firstNode.type === \"ThisExpression\" ||",
                        "        (firstNode.type === \"Identifier\" &&",
                        "          (isFactory(firstNode.name) ||",
                        "            (isExpressionStatement && isShort(firstNode.name)) ||",
                        "            hasComputed))",
                        "      );",
                        "    }",
                        "",
                        "    const lastNode = groups[0].at(-1).node;",
                        "    return (",
                        "      isMemberExpression(lastNode) &&",
                        "      lastNode.property.type === \"Identifier\" &&",
                        "      (isFactory(lastNode.property.name) || hasComputed)",
                        "    );",
                        "  }",
                        "",
                        "  const shouldMerge =",
                        "    groups.length >= 2 &&",
                        "    !hasComment(groups[1][0].node) &&",
                        "    shouldNotWrap(groups);",
                        "",
                        "  function printGroup(printedGroup) {",
                        "    const printed = printedGroup.map((tuple) => tuple.printed);",
                        "    // Checks if the last node (i.e. the parent node) needs parens and print",
                        "    // accordingly",
                        "    if (printedGroup.length > 0 && printedGroup.at(-1).needsParens) {",
                        "      return [\"(\", ...printed, \")\"];",
                        "    }",
                        "    return printed;",
                        "  }",
                        "",
                        "  function printIndentedGroup(groups) {",
                        "    /* c8 ignore next 3 */",
                        "    if (groups.length === 0) {",
                        "      return \"\";",
                        "    }",
                        "    return indent(group([hardline, join(hardline, groups.map(printGroup))]));",
                        "  }",
                        "",
                        "  const printedGroups = groups.map(printGroup);",
                        "  const oneLine = printedGroups;",
                        "",
                        "  const cutoff = shouldMerge ? 3 : 2;",
                        "  const flatGroups = groups.flat();",
                        "",
                        "  const nodeHasComment =",
                        "    flatGroups",
                        "      .slice(1, -1)",
                        "      .some((node) => hasComment(node.node, CommentCheckFlags.Leading)) ||",
                        "    flatGroups",
                        "      .slice(0, -1)",
                        "      .some((node) => hasComment(node.node, CommentCheckFlags.Trailing)) ||",
                        "    (groups[cutoff] &&",
                        "      hasComment(groups[cutoff][0].node, CommentCheckFlags.Leading));",
                        "",
                        "  // If we only have a single `.`, we shouldn't do anything fancy and just",
                        "  // render everything concatenated together.",
                        "  if (groups.length <= cutoff && !nodeHasComment) {",
                        "    if (isLongCurriedCallExpression(path)) {",
                        "      return oneLine;",
                        "    }",
                        "    return group(oneLine);",
                        "  }",
                        "",
                        "  // Find out the last node in the first group and check if it has an",
                        "  // empty line after",
                        "  const lastNodeBeforeIndent = groups[shouldMerge ? 1 : 0].at(-1).node;",
                        "  const shouldHaveEmptyLineBeforeIndent =",
                        "    !isCallExpression(lastNodeBeforeIndent) &&",
                        "    shouldInsertEmptyLineAfter(lastNodeBeforeIndent);",
                        "",
                        "  const expanded = [",
                        "    printGroup(groups[0]),",
                        "    shouldMerge ? groups.slice(1, 2).map(printGroup) : \"\",",
                        "    shouldHaveEmptyLineBeforeIndent ? hardline : \"\",",
                        "    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1)),",
                        "  ];",
                        "",
                        "  const callExpressions = printedNodes",
                        "    .map(({ node }) => node)",
                        "    .filter(isCallExpression);",
                        "",
                        "  function lastGroupWillBreakAndOtherCallsHaveFunctionArguments() {",
                        "    const lastGroupNode = groups.at(-1).at(-1).node;",
                        "    const lastGroupDoc = printedGroups.at(-1);",
                        "    return (",
                        "      isCallExpression(lastGroupNode) &&",
                        "      willBreak(lastGroupDoc) &&",
                        "      callExpressions",
                        "        .slice(0, -1)",
                        "        .some((node) => node.arguments.some(isFunctionOrArrowExpression))",
                        "    );",
                        "  }",
                        "",
                        "  let result;",
                        "",
                        "  // We don't want to print in one line if at least one of these conditions occurs:",
                        "  //  * the chain has comments,",
                        "  //  * the chain is an expression statement and all the arguments are literal-like (\"fluent configuration\" pattern),",
                        "  //  * the chain is longer than 2 calls and has non-trivial arguments or more than 2 arguments in any call but the first one,",
                        "  //  * any group but the last one has a hard line,",
                        "  //  * the last call's arguments have a hard line and other calls have non-trivial arguments.",
                        "  if (",
                        "    nodeHasComment ||",
                        "    (callExpressions.length > 2 &&",
                        "      callExpressions.some(",
                        "        (expr) => !expr.arguments.every((arg) => isSimpleCallArgument(arg))",
                        "      )) ||",
                        "    printedGroups.slice(0, -1).some(willBreak) ||",
                        "    lastGroupWillBreakAndOtherCallsHaveFunctionArguments()",
                        "  ) {",
                        "    result = group(expanded);",
                        "  } else {",
                        "    result = [",
                        "      // We only need to check `oneLine` because if `expanded` is chosen",
                        "      // that means that the parent group has already been broken",
                        "      // naturally",
                        "      willBreak(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent : \"\",",
                        "      conditionalGroup([oneLine, expanded]),",
                        "    ];",
                        "  }",
                        "",
                        "  return label({ memberChain: true }, result);",
                        "}",
                        "",
                        "export default printMemberChain;"
                    ]
                },
                "member.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { softline, group, indent, label } from \"../../document/builders.js\";",
                        "import {",
                        "  isNumericLiteral,",
                        "  isMemberExpression,",
                        "  isCallExpression,",
                        "} from \"../utils/index.js\";",
                        "import { printOptionalToken } from \"./misc.js\";",
                        "",
                        "function printMemberExpression(path, options, print) {",
                        "  const objectDoc = print(\"object\");",
                        "  const lookupDoc = printMemberLookup(path, options, print);",
                        "  const { node, parent } = path;",
                        "  const firstNonMemberParent = path.findAncestor(",
                        "    (node) => !(isMemberExpression(node) || node.type === \"TSNonNullExpression\")",
                        "  );",
                        "",
                        "  const shouldInline =",
                        "    (firstNonMemberParent &&",
                        "      (firstNonMemberParent.type === \"NewExpression\" ||",
                        "        firstNonMemberParent.type === \"BindExpression\" ||",
                        "        (firstNonMemberParent.type === \"AssignmentExpression\" &&",
                        "          firstNonMemberParent.left.type !== \"Identifier\"))) ||",
                        "    node.computed ||",
                        "    (node.object.type === \"Identifier\" &&",
                        "      node.property.type === \"Identifier\" &&",
                        "      !isMemberExpression(parent)) ||",
                        "    ((parent.type === \"AssignmentExpression\" ||",
                        "      parent.type === \"VariableDeclarator\") &&",
                        "      ((isCallExpression(node.object) && node.object.arguments.length > 0) ||",
                        "        (node.object.type === \"TSNonNullExpression\" &&",
                        "          isCallExpression(node.object.expression) &&",
                        "          node.object.expression.arguments.length > 0) ||",
                        "        objectDoc.label?.memberChain));",
                        "",
                        "  return label(objectDoc.label, [",
                        "    objectDoc,",
                        "    shouldInline ? lookupDoc : group(indent([softline, lookupDoc])),",
                        "  ]);",
                        "}",
                        "",
                        "function printMemberLookup(path, options, print) {",
                        "  const property = print(\"property\");",
                        "  const { node } = path;",
                        "  const optional = printOptionalToken(path);",
                        "",
                        "  if (!node.computed) {",
                        "    return [optional, \".\", property];",
                        "  }",
                        "",
                        "  if (!node.property || isNumericLiteral(node.property)) {",
                        "    return [optional, \"[\", property, \"]\"];",
                        "  }",
                        "",
                        "  return group([optional, \"[\", indent([softline, property]), softline, \"]\"]);",
                        "}",
                        "",
                        "export { printMemberExpression, printMemberLookup };"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { indent, line } from \"../../document/builders.js\";",
                        "import { isCallExpression, isMemberExpression } from \"../utils/index.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {Doc}",
                        " */",
                        "function printOptionalToken(path) {",
                        "  const { node } = path;",
                        "  if (",
                        "    !node.optional ||",
                        "    // It's an optional computed method parsed by typescript-estree.",
                        "    // \"?\" is printed in `printMethod`.",
                        "    (node.type === \"Identifier\" && node === path.parent.key)",
                        "  ) {",
                        "    return \"\";",
                        "  }",
                        "  if (",
                        "    isCallExpression(node) ||",
                        "    (isMemberExpression(node) && node.computed) ||",
                        "    node.type === \"OptionalIndexedAccessType\"",
                        "  ) {",
                        "    return \"?.\";",
                        "  }",
                        "  return \"?\";",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {Doc}",
                        " */",
                        "function printDefiniteToken(path) {",
                        "  return path.node.definite ||",
                        "    path.match(",
                        "      undefined,",
                        "      (node, name) =>",
                        "        name === \"id\" && node.type === \"VariableDeclarator\" && node.definite",
                        "    )",
                        "    ? \"!\"",
                        "    : \"\";",
                        "}",
                        "",
                        "const flowDeclareNodeTypes = new Set([",
                        "  \"DeclareClass\",",
                        "  \"DeclareFunction\",",
                        "  \"DeclareVariable\",",
                        "  \"DeclareExportDeclaration\",",
                        "  \"DeclareExportAllDeclaration\",",
                        "  \"DeclareOpaqueType\",",
                        "  \"DeclareTypeAlias\",",
                        "  \"DeclareEnum\",",
                        "  \"DeclareInterface\",",
                        "]);",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {Doc}",
                        " */",
                        "function printDeclareToken(path) {",
                        "  const { node } = path;",
                        "",
                        "  return (",
                        "    // TypeScript",
                        "    node.declare ||",
                        "      // Flow",
                        "      (flowDeclareNodeTypes.has(node.type) &&",
                        "        path.parent.type !== \"DeclareExportDeclaration\")",
                        "      ? \"declare \"",
                        "      : \"\"",
                        "  );",
                        "}",
                        "",
                        "const tsAbstractNodeTypes = new Set([",
                        "  \"TSAbstractMethodDefinition\",",
                        "  \"TSAbstractPropertyDefinition\",",
                        "  \"TSAbstractAccessorProperty\",",
                        "]);",
                        "/**",
                        " * @param {AstPath} param0",
                        " * @returns {Doc}",
                        " */",
                        "function printAbstractToken({ node }) {",
                        "  return node.abstract || tsAbstractNodeTypes.has(node.type) ? \"abstract \" : \"\";",
                        "}",
                        "",
                        "function printFunctionTypeParameters(path, options, print) {",
                        "  const fun = path.node;",
                        "  if (fun.typeArguments) {",
                        "    return print(\"typeArguments\");",
                        "  }",
                        "  if (fun.typeParameters) {",
                        "    return print(\"typeParameters\");",
                        "  }",
                        "  return \"\";",
                        "}",
                        "",
                        "function printBindExpressionCallee(path, options, print) {",
                        "  return [\"::\", print(\"callee\")];",
                        "}",
                        "",
                        "function adjustClause(node, clause, forceSpace) {",
                        "  if (node.type === \"EmptyStatement\") {",
                        "    return \";\";",
                        "  }",
                        "",
                        "  if (node.type === \"BlockStatement\" || forceSpace) {",
                        "    return [\" \", clause];",
                        "  }",
                        "",
                        "  return indent([line, clause]);",
                        "}",
                        "",
                        "function printRestSpread(path, print) {",
                        "  return [\"...\", print(\"argument\"), printTypeAnnotationProperty(path, print)];",
                        "}",
                        "",
                        "function printTypeScriptAccessibilityToken(node) {",
                        "  return node.accessibility ? node.accessibility + \" \" : \"\";",
                        "}",
                        "",
                        "export {",
                        "  printOptionalToken,",
                        "  printDefiniteToken,",
                        "  printDeclareToken,",
                        "  printAbstractToken,",
                        "  printFunctionTypeParameters,",
                        "  printBindExpressionCallee,",
                        "  printRestSpread,",
                        "  adjustClause,",
                        "  printTypeScriptAccessibilityToken,",
                        "};"
                    ]
                },
                "module.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                        "import {",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  join,",
                        "  line,",
                        "  ifBreak,",
                        "  hardline,",
                        "} from \"../../document/builders.js\";",
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "",
                        "import {",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  shouldPrintComma,",
                        "  needsHardlineAfterDanglingComment,",
                        "  isStringLiteral,",
                        "  rawText,",
                        "  createTypeCheckFunction,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, hasSameLoc } from \"../loc.js\";",
                        "import { printDecoratorsBeforeExport } from \"./decorators.js\";",
                        "import { printDeclareToken } from \"./misc.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "function printImportDeclaration(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type{Doc[]} */",
                        "  return [",
                        "    \"import\",",
                        "    node.module ? \" module\" : \"\",",
                        "    printImportKind(node),",
                        "    printModuleSpecifiers(path, options, print),",
                        "    printModuleSource(path, options, print),",
                        "    printImportAssertions(path, options, print),",
                        "    options.semi ? \";\" : \"\",",
                        "  ];",
                        "}",
                        "",
                        "const isDefaultExport = (node) =>",
                        "  node.type === \"ExportDefaultDeclaration\" ||",
                        "  (node.type === \"DeclareExportDeclaration\" && node.default);",
                        "",
                        "/*",
                        "- `ExportDefaultDeclaration`",
                        "- `ExportNamedDeclaration`",
                        "- `DeclareExportDeclaration`(flow)",
                        "- `ExportAllDeclaration`",
                        "- `DeclareExportAllDeclaration`(flow)",
                        "*/",
                        "function printExportDeclaration(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [",
                        "    printDecoratorsBeforeExport(path, options, print),",
                        "    printDeclareToken(path),",
                        "    \"export\",",
                        "    isDefaultExport(node) ? \" default\" : \"\",",
                        "  ];",
                        "",
                        "  const { declaration, exported } = node;",
                        "",
                        "  if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    parts.push(\" \", printDanglingComments(path, options));",
                        "",
                        "    if (needsHardlineAfterDanglingComment(node)) {",
                        "      parts.push(hardline);",
                        "    }",
                        "  }",
                        "",
                        "  if (declaration) {",
                        "    parts.push(\" \", print(\"declaration\"));",
                        "  } else {",
                        "    parts.push(printExportKind(node));",
                        "",
                        "    if (",
                        "      node.type === \"ExportAllDeclaration\" ||",
                        "      node.type === \"DeclareExportAllDeclaration\"",
                        "    ) {",
                        "      parts.push(\" *\");",
                        "      if (exported) {",
                        "        parts.push(\" as \", print(\"exported\"));",
                        "      }",
                        "    } else {",
                        "      parts.push(printModuleSpecifiers(path, options, print));",
                        "    }",
                        "",
                        "    parts.push(",
                        "      printModuleSource(path, options, print),",
                        "      printImportAssertions(path, options, print)",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(printSemicolonAfterExportDeclaration(node, options));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "const shouldOmitSemicolon = createTypeCheckFunction([",
                        "  \"ClassDeclaration\",",
                        "  \"FunctionDeclaration\",",
                        "  \"TSInterfaceDeclaration\",",
                        "  \"DeclareClass\",",
                        "  \"DeclareFunction\",",
                        "  \"TSDeclareFunction\",",
                        "  \"EnumDeclaration\",",
                        "]);",
                        "function printSemicolonAfterExportDeclaration(node, options) {",
                        "  if (",
                        "    options.semi &&",
                        "    (!node.declaration ||",
                        "      (isDefaultExport(node) && !shouldOmitSemicolon(node.declaration)))",
                        "  ) {",
                        "    return \";\";",
                        "  }",
                        "",
                        "  return \"\";",
                        "}",
                        "",
                        "function printImportOrExportKind(kind, spaceBeforeKind = true) {",
                        "  return kind && kind !== \"value\"",
                        "    ? `${spaceBeforeKind ? \" \" : \"\"}${kind}${spaceBeforeKind ? \"\" : \" \"}`",
                        "    : \"\";",
                        "}",
                        "",
                        "function printImportKind(node, spaceBeforeKind) {",
                        "  return printImportOrExportKind(node.importKind, spaceBeforeKind);",
                        "}",
                        "",
                        "function printExportKind(node) {",
                        "  return printImportOrExportKind(node.exportKind);",
                        "}",
                        "",
                        "function printModuleSource(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (!node.source) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [];",
                        "  if (!shouldNotPrintSpecifiers(node, options)) {",
                        "    parts.push(\" from\");",
                        "  }",
                        "  parts.push(\" \", print(\"source\"));",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printModuleSpecifiers(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (shouldNotPrintSpecifiers(node, options)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  /** @type{Doc[]} */",
                        "  const parts = [\" \"];",
                        "",
                        "  if (isNonEmptyArray(node.specifiers)) {",
                        "    const standaloneSpecifiers = [];",
                        "    const groupedSpecifiers = [];",
                        "",
                        "    path.each(() => {",
                        "      const specifierType = path.node.type;",
                        "      if (",
                        "        specifierType === \"ExportNamespaceSpecifier\" ||",
                        "        specifierType === \"ExportDefaultSpecifier\" ||",
                        "        specifierType === \"ImportNamespaceSpecifier\" ||",
                        "        specifierType === \"ImportDefaultSpecifier\"",
                        "      ) {",
                        "        standaloneSpecifiers.push(print());",
                        "      } else if (",
                        "        specifierType === \"ExportSpecifier\" ||",
                        "        specifierType === \"ImportSpecifier\"",
                        "      ) {",
                        "        groupedSpecifiers.push(print());",
                        "      } else {",
                        "        /* c8 ignore next 3 */",
                        "        throw new UnexpectedNodeError(node, \"specifier\");",
                        "      }",
                        "    }, \"specifiers\");",
                        "",
                        "    parts.push(join(\", \", standaloneSpecifiers));",
                        "",
                        "    if (groupedSpecifiers.length > 0) {",
                        "      if (standaloneSpecifiers.length > 0) {",
                        "        parts.push(\", \");",
                        "      }",
                        "",
                        "      const canBreak =",
                        "        groupedSpecifiers.length > 1 ||",
                        "        standaloneSpecifiers.length > 0 ||",
                        "        node.specifiers.some((node) => hasComment(node));",
                        "",
                        "      if (canBreak) {",
                        "        parts.push(",
                        "          group([",
                        "            \"{\",",
                        "            indent([",
                        "              options.bracketSpacing ? line : softline,",
                        "              join([\",\", line], groupedSpecifiers),",
                        "            ]),",
                        "            ifBreak(shouldPrintComma(options) ? \",\" : \"\"),",
                        "            options.bracketSpacing ? line : softline,",
                        "            \"}\",",
                        "          ])",
                        "        );",
                        "      } else {",
                        "        parts.push([",
                        "          \"{\",",
                        "          options.bracketSpacing ? \" \" : \"\",",
                        "          ...groupedSpecifiers,",
                        "          options.bracketSpacing ? \" \" : \"\",",
                        "          \"}\",",
                        "        ]);",
                        "      }",
                        "    }",
                        "  } else {",
                        "    parts.push(\"{}\");",
                        "  }",
                        "  return parts;",
                        "}",
                        "",
                        "function shouldNotPrintSpecifiers(node, options) {",
                        "  const { type, importKind, source, specifiers } = node;",
                        "",
                        "  if (",
                        "    type !== \"ImportDeclaration\" ||",
                        "    isNonEmptyArray(specifiers) ||",
                        "    importKind === \"type\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // TODO: check tokens",
                        "  return !/{\\s*}/.test(",
                        "    options.originalText.slice(locStart(node), locStart(source))",
                        "  );",
                        "}",
                        "",
                        "function printImportAssertions(path, options, print) {",
                        "  const { node } = path;",
                        "  if (!isNonEmptyArray(node.assertions)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  return [",
                        "    \" assert {\",",
                        "    options.bracketSpacing ? \" \" : \"\",",
                        "    join(\", \", path.map(print, \"assertions\")),",
                        "    options.bracketSpacing ? \" \" : \"\",",
                        "    \"}\",",
                        "  ];",
                        "}",
                        "",
                        "function printModuleSpecifier(path, options, print) {",
                        "  const { node } = path;",
                        "  const { type } = node;",
                        "",
                        "  const isImportSpecifier = type.startsWith(\"Import\");",
                        "  const leftSideProperty = isImportSpecifier ? \"imported\" : \"local\";",
                        "  const rightSideProperty = isImportSpecifier ? \"local\" : \"exported\";",
                        "  const leftSideNode = node[leftSideProperty];",
                        "  const rightSideNode = node[rightSideProperty];",
                        "  let left = \"\";",
                        "  let right = \"\";",
                        "  if (",
                        "    type === \"ExportNamespaceSpecifier\" ||",
                        "    type === \"ImportNamespaceSpecifier\"",
                        "  ) {",
                        "    left = \"*\";",
                        "  } else if (leftSideNode) {",
                        "    left = print(leftSideProperty);",
                        "  }",
                        "",
                        "  if (rightSideNode && !isShorthandSpecifier(node)) {",
                        "    right = print(rightSideProperty);",
                        "  }",
                        "",
                        "  return [",
                        "    printImportOrExportKind(",
                        "      type === \"ImportSpecifier\" ? node.importKind : node.exportKind,",
                        "      /* spaceBeforeKind */ false",
                        "    ),",
                        "    left,",
                        "    left && right ? \" as \" : \"\",",
                        "    right,",
                        "  ];",
                        "}",
                        "",
                        "function isShorthandSpecifier(specifier) {",
                        "  if (",
                        "    specifier.type !== \"ImportSpecifier\" &&",
                        "    specifier.type !== \"ExportSpecifier\"",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const {",
                        "    local,",
                        "    [specifier.type === \"ImportSpecifier\" ? \"imported\" : \"exported\"]:",
                        "      importedOrExported,",
                        "  } = specifier;",
                        "",
                        "  if (",
                        "    local.type !== importedOrExported.type ||",
                        "    !hasSameLoc(local, importedOrExported)",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isStringLiteral(local)) {",
                        "    return (",
                        "      local.value === importedOrExported.value &&",
                        "      rawText(local) === rawText(importedOrExported)",
                        "    );",
                        "  }",
                        "",
                        "  switch (local.type) {",
                        "    case \"Identifier\":",
                        "      return local.name === importedOrExported.name;",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "export {",
                        "  printImportDeclaration,",
                        "  printExportDeclaration,",
                        "  printModuleSpecifier,",
                        "  printImportKind,",
                        "};"
                    ]
                },
                "object.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  line,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "  hardline,",
                        "} from \"../../document/builders.js\";",
                        "import hasNewlineInRange from \"../../utils/has-newline-in-range.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import {",
                        "  shouldPrintComma,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  isNextLineEmpty,",
                        "  isObjectType,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "",
                        "import { printOptionalToken } from \"./misc.js\";",
                        "import { shouldHugTheOnlyFunctionParameter } from \"./function-parameters.js\";",
                        "import { printHardlineAfterHeritage } from \"./class.js\";",
                        "import { printTypeAnnotationProperty } from \"./type-annotation.js\";",
                        "",
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "function printObject(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const { node } = path;",
                        "",
                        "  const isTypeAnnotation = node.type === \"ObjectTypeAnnotation\";",
                        "  const isEnumBody =",
                        "    node.type === \"TSEnumDeclaration\" ||",
                        "    node.type === \"EnumBooleanBody\" ||",
                        "    node.type === \"EnumNumberBody\" ||",
                        "    node.type === \"EnumStringBody\" ||",
                        "    node.type === \"EnumSymbolBody\";",
                        "  const fields = [",
                        "    node.type === \"TSTypeLiteral\" || isEnumBody",
                        "      ? \"members\"",
                        "      : node.type === \"TSInterfaceBody\"",
                        "      ? \"body\"",
                        "      : \"properties\",",
                        "  ];",
                        "  if (isTypeAnnotation) {",
                        "    fields.push(\"indexers\", \"callProperties\", \"internalSlots\");",
                        "  }",
                        "",
                        "  // Unfortunately, things grouped together in the ast can be",
                        "  // interleaved in the source code. So we need to reorder them before",
                        "  // printing them.",
                        "  const propsAndLoc = fields.flatMap((field) =>",
                        "    path.map(",
                        "      ({ node }) => ({",
                        "        node,",
                        "        printed: print(),",
                        "        loc: locStart(node),",
                        "      }),",
                        "      field",
                        "    )",
                        "  );",
                        "",
                        "  if (fields.length > 1) {",
                        "    propsAndLoc.sort((a, b) => a.loc - b.loc);",
                        "  }",
                        "",
                        "  const { parent, key } = path;",
                        "  const isFlowInterfaceLikeBody =",
                        "    isTypeAnnotation &&",
                        "    key === \"body\" &&",
                        "    (parent.type === \"InterfaceDeclaration\" ||",
                        "      parent.type === \"DeclareInterface\" ||",
                        "      parent.type === \"DeclareClass\");",
                        "  const shouldBreak =",
                        "    node.type === \"TSInterfaceBody\" ||",
                        "    isEnumBody ||",
                        "    isFlowInterfaceLikeBody ||",
                        "    (node.type === \"ObjectPattern\" &&",
                        "      parent.type !== \"FunctionDeclaration\" &&",
                        "      parent.type !== \"FunctionExpression\" &&",
                        "      parent.type !== \"ArrowFunctionExpression\" &&",
                        "      parent.type !== \"ObjectMethod\" &&",
                        "      parent.type !== \"ClassMethod\" &&",
                        "      parent.type !== \"ClassPrivateMethod\" &&",
                        "      parent.type !== \"AssignmentPattern\" &&",
                        "      parent.type !== \"CatchClause\" &&",
                        "      node.properties.some(",
                        "        (property) =>",
                        "          property.value &&",
                        "          (property.value.type === \"ObjectPattern\" ||",
                        "            property.value.type === \"ArrayPattern\")",
                        "      )) ||",
                        "    (node.type !== \"ObjectPattern\" &&",
                        "      propsAndLoc.length > 0 &&",
                        "      hasNewlineInRange(",
                        "        options.originalText,",
                        "        locStart(node),",
                        "        propsAndLoc[0].loc",
                        "      ));",
                        "",
                        "  const separator = isFlowInterfaceLikeBody",
                        "    ? \";\"",
                        "    : node.type === \"TSInterfaceBody\" || node.type === \"TSTypeLiteral\"",
                        "    ? ifBreak(semi, \";\")",
                        "    : \",\";",
                        "  const leftBrace =",
                        "    node.type === \"RecordExpression\" ? \"#{\" : node.exact ? \"{|\" : \"{\";",
                        "  const rightBrace = node.exact ? \"|}\" : \"}\";",
                        "",
                        "  /** @type {Doc[]} */",
                        "  let separatorParts = [];",
                        "  const props = propsAndLoc.map((prop) => {",
                        "    const result = [...separatorParts, group(prop.printed)];",
                        "    separatorParts = [separator, line];",
                        "    if (",
                        "      (prop.node.type === \"TSPropertySignature\" ||",
                        "        prop.node.type === \"TSMethodSignature\" ||",
                        "        prop.node.type === \"TSConstructSignatureDeclaration\") &&",
                        "      hasComment(prop.node, CommentCheckFlags.PrettierIgnore)",
                        "    ) {",
                        "      separatorParts.shift();",
                        "    }",
                        "    if (isNextLineEmpty(prop.node, options)) {",
                        "      separatorParts.push(hardline);",
                        "    }",
                        "    return result;",
                        "  });",
                        "",
                        "  if (node.inexact || node.hasUnknownMembers) {",
                        "    let printed;",
                        "    if (hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      const hasLineComments = hasComment(node, CommentCheckFlags.Line);",
                        "      const printedDanglingComments = printDanglingComments(path, options);",
                        "      printed = [",
                        "        printedDanglingComments,",
                        "        hasLineComments ||",
                        "        hasNewline(options.originalText, locEnd(getComments(node).at(-1)))",
                        "          ? hardline",
                        "          : line,",
                        "        \"...\",",
                        "      ];",
                        "    } else {",
                        "      printed = [\"...\"];",
                        "    }",
                        "    props.push([...separatorParts, ...printed]);",
                        "  }",
                        "",
                        "  const lastElem = propsAndLoc.at(-1)?.node;",
                        "",
                        "  const canHaveTrailingSeparator = !(",
                        "    node.inexact ||",
                        "    node.hasUnknownMembers ||",
                        "    (lastElem &&",
                        "      (lastElem.type === \"RestElement\" ||",
                        "        ((lastElem.type === \"TSPropertySignature\" ||",
                        "          lastElem.type === \"TSCallSignatureDeclaration\" ||",
                        "          lastElem.type === \"TSMethodSignature\" ||",
                        "          lastElem.type === \"TSConstructSignatureDeclaration\") &&",
                        "          hasComment(lastElem, CommentCheckFlags.PrettierIgnore))))",
                        "  );",
                        "",
                        "  let content;",
                        "  if (props.length === 0) {",
                        "    if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "      return [leftBrace, rightBrace, printTypeAnnotationProperty(path, print)];",
                        "    }",
                        "",
                        "    content = group([",
                        "      leftBrace,",
                        "      printDanglingComments(path, options, { indent: true }),",
                        "      softline,",
                        "      rightBrace,",
                        "      printOptionalToken(path),",
                        "      printTypeAnnotationProperty(path, print),",
                        "    ]);",
                        "  } else {",
                        "    content = [",
                        "      isFlowInterfaceLikeBody && isNonEmptyArray(node.properties)",
                        "        ? printHardlineAfterHeritage(parent)",
                        "        : \"\",",
                        "      leftBrace,",
                        "      indent([options.bracketSpacing ? line : softline, ...props]),",
                        "      ifBreak(",
                        "        canHaveTrailingSeparator &&",
                        "          (separator !== \",\" || shouldPrintComma(options))",
                        "          ? separator",
                        "          : \"\"",
                        "      ),",
                        "      options.bracketSpacing ? line : softline,",
                        "      rightBrace,",
                        "      printOptionalToken(path),",
                        "      printTypeAnnotationProperty(path, print),",
                        "    ];",
                        "  }",
                        "",
                        "  // If we inline the object as first argument of the parent, we don't want",
                        "  // to create another group so that the object breaks before the return",
                        "  // type",
                        "  if (",
                        "    path.match(",
                        "      (node) => node.type === \"ObjectPattern\" && !node.decorators,",
                        "      shouldHugTheOnlyParameter",
                        "    ) ||",
                        "    (isObjectType(node) &&",
                        "      (path.match(",
                        "        undefined,",
                        "        (node, name) => name === \"typeAnnotation\",",
                        "        (node, name) => name === \"typeAnnotation\",",
                        "        shouldHugTheOnlyParameter",
                        "      ) ||",
                        "        path.match(",
                        "          undefined,",
                        "          (node, name) =>",
                        "            node.type === \"FunctionTypeParam\" && name === \"typeAnnotation\",",
                        "          shouldHugTheOnlyParameter",
                        "        ))) ||",
                        "    // Assignment printing logic (printAssignment) is responsible",
                        "    // for adding a group if needed",
                        "    (!shouldBreak &&",
                        "      path.match(",
                        "        (node) => node.type === \"ObjectPattern\",",
                        "        (node) =>",
                        "          node.type === \"AssignmentExpression\" ||",
                        "          node.type === \"VariableDeclarator\"",
                        "      ))",
                        "  ) {",
                        "    return content;",
                        "  }",
                        "",
                        "  return group(content, { shouldBreak });",
                        "}",
                        "",
                        "function shouldHugTheOnlyParameter(node, name) {",
                        "  return (",
                        "    (name === \"params\" ||",
                        "      name === \"parameters\" ||",
                        "      name === \"this\" ||",
                        "      name === \"rest\") &&",
                        "    shouldHugTheOnlyFunctionParameter(node)",
                        "  );",
                        "}",
                        "",
                        "export { printObject };"
                    ]
                },
                "property.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printComments } from \"../../main/comments/print.js\";",
                        "import printString from \"../../utils/print-string.js\";",
                        "import printNumber from \"../../utils/print-number.js\";",
                        "import {",
                        "  isNumericLiteral,",
                        "  isSimpleNumber,",
                        "  isStringLiteral,",
                        "  isStringPropSafeToUnquote,",
                        "  rawText,",
                        "} from \"../utils/index.js\";",
                        "import { printAssignment } from \"./assignment.js\";",
                        "",
                        "const needsQuoteProps = new WeakMap();",
                        "",
                        "function printPropertyKey(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  if (node.computed) {",
                        "    return [\"[\", print(\"key\"), \"]\"];",
                        "  }",
                        "",
                        "  const { parent } = path;",
                        "  const { key } = node;",
                        "",
                        "  if (options.quoteProps === \"consistent\" && !needsQuoteProps.has(parent)) {",
                        "    const objectHasStringProp = (",
                        "      parent.properties ||",
                        "      parent.body ||",
                        "      parent.members",
                        "    ).some(",
                        "      (prop) =>",
                        "        !prop.computed &&",
                        "        prop.key &&",
                        "        isStringLiteral(prop.key) &&",
                        "        !isStringPropSafeToUnquote(prop, options)",
                        "    );",
                        "    needsQuoteProps.set(parent, objectHasStringProp);",
                        "  }",
                        "",
                        "  if (",
                        "    (key.type === \"Identifier\" ||",
                        "      (isNumericLiteral(key) &&",
                        "        isSimpleNumber(printNumber(rawText(key))) &&",
                        "        // Avoid converting 999999999999999999999 to 1e+21, 0.99999999999999999 to 1 and 1.0 to 1.",
                        "        String(key.value) === printNumber(rawText(key)) &&",
                        "        // Quoting number keys is safe in JS and Flow, but not in TypeScript (as",
                        "        // mentioned in `isStringPropSafeToUnquote`).",
                        "        !(options.parser === \"typescript\" || options.parser === \"babel-ts\"))) &&",
                        "    (options.parser === \"json\" ||",
                        "      (options.quoteProps === \"consistent\" && needsQuoteProps.get(parent)))",
                        "  ) {",
                        "    // a -> \"a\"",
                        "    // 1 -> \"1\"",
                        "    // 1.5 -> \"1.5\"",
                        "    const prop = printString(",
                        "      JSON.stringify(",
                        "        key.type === \"Identifier\" ? key.name : key.value.toString()",
                        "      ),",
                        "      options",
                        "    );",
                        "    return path.call((keyPath) => printComments(keyPath, prop, options), \"key\");",
                        "  }",
                        "",
                        "  if (",
                        "    isStringPropSafeToUnquote(node, options) &&",
                        "    (options.quoteProps === \"as-needed\" ||",
                        "      (options.quoteProps === \"consistent\" && !needsQuoteProps.get(parent)))",
                        "  ) {",
                        "    // 'a' -> a",
                        "    // '1' -> 1",
                        "    // '1.5' -> 1.5",
                        "    return path.call(",
                        "      (keyPath) =>",
                        "        printComments(",
                        "          keyPath,",
                        "          /^\\d/.test(key.value) ? printNumber(key.value) : key.value,",
                        "          options",
                        "        ),",
                        "      \"key\"",
                        "    );",
                        "  }",
                        "",
                        "  return print(\"key\");",
                        "}",
                        "",
                        "function printProperty(path, options, print) {",
                        "  const { node } = path;",
                        "  if (node.shorthand) {",
                        "    return print(\"value\");",
                        "  }",
                        "",
                        "  return printAssignment(",
                        "    path,",
                        "    options,",
                        "    print,",
                        "    printPropertyKey(path, options, print),",
                        "    \":\",",
                        "    \"value\"",
                        "  );",
                        "}",
                        "",
                        "export { printProperty, printPropertyKey };"
                    ]
                },
                "semicolon.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import {",
                        "  getLeftSidePathName,",
                        "  hasNakedLeftSide,",
                        "  isJsxElement,",
                        "} from \"../utils/index.js\";",
                        "import { shouldPrintParamsWithoutParens } from \"./function.js\";",
                        "",
                        "function shouldPrintLeadingSemicolon(path, options) {",
                        "  if (",
                        "    options.semi ||",
                        "    isSingleJsxExpressionStatementInMarkdown(path, options) ||",
                        "    isSingleVueEventBindingExpressionStatement(path, options)",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const { node, key, parent } = path;",
                        "  if (",
                        "    node.type === \"ExpressionStatement\" &&",
                        "    // `Program.directives` don't need leading semicolon",
                        "    ((key === \"body\" &&",
                        "      (parent.type === \"Program\" ||",
                        "        parent.type === \"BlockStatement\" ||",
                        "        parent.type === \"StaticBlock\" ||",
                        "        parent.type === \"TSModuleBlock\")) ||",
                        "      (key === \"consequent\" && parent.type === \"SwitchCase\")) &&",
                        "    path.call(() => expressionNeedsASIProtection(path, options), \"expression\")",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function expressionNeedsASIProtection(path, options) {",
                        "  const { node } = path;",
                        "  switch (node.type) {",
                        "    case \"ParenthesizedExpression\":",
                        "    case \"TypeCastExpression\":",
                        "    case \"ArrayExpression\":",
                        "    case \"ArrayPattern\":",
                        "    case \"TemplateLiteral\":",
                        "    case \"TemplateElement\":",
                        "    case \"RegExpLiteral\":",
                        "      return true;",
                        "    case \"ArrowFunctionExpression\":",
                        "      if (!shouldPrintParamsWithoutParens(path, options)) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "",
                        "    case \"UnaryExpression\": {",
                        "      const { prefix, operator } = node;",
                        "      if (prefix && (operator === \"+\" || operator === \"-\")) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "    }",
                        "    case \"BindExpression\":",
                        "      if (!node.object) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "",
                        "    case \"Literal\":",
                        "      if (node.regex) {",
                        "        return true;",
                        "      }",
                        "      break;",
                        "",
                        "    default:",
                        "      if (isJsxElement(node)) {",
                        "        return true;",
                        "      }",
                        "  }",
                        "",
                        "  if (pathNeedsParens(path, options)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (!hasNakedLeftSide(node)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return path.call(",
                        "    () => expressionNeedsASIProtection(path, options),",
                        "    ...getLeftSidePathName(node)",
                        "  );",
                        "}",
                        "",
                        "function isSingleJsxExpressionStatementInMarkdown({ node, parent }, options) {",
                        "  return (",
                        "    (options.parentParser === \"markdown\" || options.parentParser === \"mdx\") &&",
                        "    node.type === \"ExpressionStatement\" &&",
                        "    isJsxElement(node.expression) &&",
                        "    parent.type === \"Program\" &&",
                        "    parent.body.length === 1",
                        "  );",
                        "}",
                        "",
                        "// based on /src/language-html/syntax-vue.js isVueEventBindingExpression()",
                        "function isVueEventBindingExpression(node) {",
                        "  switch (node.type) {",
                        "    case \"MemberExpression\":",
                        "      switch (node.property.type) {",
                        "        case \"Identifier\":",
                        "        case \"NumericLiteral\":",
                        "        case \"StringLiteral\":",
                        "          return isVueEventBindingExpression(node.object);",
                        "      }",
                        "      return false;",
                        "    case \"Identifier\":",
                        "      return true;",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "function isSingleVueEventBindingExpressionStatement({ node, parent }, options) {",
                        "  return (",
                        "    (options.parser === \"__vue_event_binding\" ||",
                        "      options.parser === \"__vue_ts_event_binding\") &&",
                        "    node.type === \"ExpressionStatement\" &&",
                        "    parent.type === \"Program\" &&",
                        "    parent.body.length === 1",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  shouldPrintLeadingSemicolon,",
                        "  isSingleJsxExpressionStatementInMarkdown,",
                        "  isSingleVueEventBindingExpressionStatement,",
                        "  isVueEventBindingExpression,",
                        "};"
                    ]
                },
                "statement.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { hardline } from \"../../document/builders.js\";",
                        "import { isNextLineEmpty } from \"../utils/index.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path.js\")} AstPath",
                        " */",
                        "",
                        "/*",
                        "- `Program` (\"directives\" and \"body\")",
                        "- `BlockStatement`",
                        "- `StaticBlock`",
                        "- `SwitchCase` (\"consequent\")",
                        "- `TSModuleBlock` (TypeScript)",
                        "*/",
                        "function printStatementSequence(path, options, print, property) {",
                        "  const { node } = path;",
                        "  const parts = [];",
                        "  const lastStatement = getLastStatement(node[property]);",
                        "",
                        "  path.each(({ node }) => {",
                        "    // Skip printing EmptyStatement nodes to avoid leaving stray",
                        "    // semicolons lying around.",
                        "    if (node.type === \"EmptyStatement\") {",
                        "      return;",
                        "    }",
                        "",
                        "    parts.push(print());",
                        "",
                        "    if (node !== lastStatement) {",
                        "      parts.push(hardline);",
                        "",
                        "      if (isNextLineEmpty(node, options)) {",
                        "        parts.push(hardline);",
                        "      }",
                        "    }",
                        "  }, property);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function getLastStatement(statements) {",
                        "  for (let i = statements.length - 1; i >= 0; i--) {",
                        "    const statement = statements[i];",
                        "    if (statement.type !== \"EmptyStatement\") {",
                        "      return statement;",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "export { printStatementSequence };"
                    ]
                },
                "template-literal.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import getStringWidth from \"../../utils/get-string-width.js\";",
                        "import getIndentSize from \"../../utils/get-indent-size.js\";",
                        "import {",
                        "  join,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  align,",
                        "  lineSuffixBoundary,",
                        "  addAlignmentToDoc,",
                        "  label,",
                        "} from \"../../document/builders.js\";",
                        "import { printDocToString } from \"../../document/printer.js\";",
                        "import { mapDoc } from \"../../document/utils.js\";",
                        "import {",
                        "  isBinaryish,",
                        "  isSimpleTemplateLiteral,",
                        "  hasComment,",
                        "  isMemberExpression,",
                        "  isTSTypeExpression,",
                        "} from \"../utils/index.js\";",
                        "",
                        "function printTemplateLiteral(path, print, options) {",
                        "  const { node } = path;",
                        "  const isTemplateLiteral = node.type === \"TemplateLiteral\";",
                        "",
                        "  if (isTemplateLiteral && isJestEachTemplateLiteral(path)) {",
                        "    const printed = printJestEachTemplateLiteral(path, options, print);",
                        "    if (printed) {",
                        "      return printed;",
                        "    }",
                        "  }",
                        "  let expressionsKey = \"expressions\";",
                        "  if (node.type === \"TSTemplateLiteralType\") {",
                        "    expressionsKey = \"types\";",
                        "  }",
                        "  const parts = [];",
                        "",
                        "  let expressionDocs = path.map(print, expressionsKey);",
                        "  const isSimple = isSimpleTemplateLiteral(node);",
                        "",
                        "  if (isSimple) {",
                        "    expressionDocs = expressionDocs.map(",
                        "      (doc) =>",
                        "        printDocToString(doc, {",
                        "          ...options,",
                        "          printWidth: Number.POSITIVE_INFINITY,",
                        "        }).formatted",
                        "    );",
                        "  }",
                        "",
                        "  parts.push(lineSuffixBoundary, \"`\");",
                        "",
                        "  let previousQuasiIndentSize = 0;",
                        "  path.each(({ index, node: quasi }) => {",
                        "    parts.push(print());",
                        "",
                        "    if (quasi.tail) {",
                        "      return;",
                        "    }",
                        "",
                        "    // For a template literal of the following form:",
                        "    //   `someQuery {",
                        "    //     ${call({",
                        "    //       a,",
                        "    //       b,",
                        "    //     })}",
                        "    //   }`",
                        "    // the expression is on its own line (there is a \\n in the previous",
                        "    // quasi literal), therefore we want to indent the JavaScript",
                        "    // expression inside at the beginning of ${ instead of the beginning",
                        "    // of the `.",
                        "    const { tabWidth } = options;",
                        "    const text = quasi.value.raw;",
                        "    const indentSize = text.includes(\"\\n\")",
                        "      ? getIndentSize(text, tabWidth)",
                        "      : previousQuasiIndentSize;",
                        "    previousQuasiIndentSize = indentSize;",
                        "",
                        "    let expressionDoc = expressionDocs[index];",
                        "",
                        "    if (!isSimple) {",
                        "      const expression = node[expressionsKey][index];",
                        "      // Breaks at the template element boundaries (${ and }) are preferred to breaking",
                        "      // in the middle of a MemberExpression",
                        "      if (",
                        "        hasComment(expression) ||",
                        "        isMemberExpression(expression) ||",
                        "        expression.type === \"ConditionalExpression\" ||",
                        "        expression.type === \"SequenceExpression\" ||",
                        "        isTSTypeExpression(expression) ||",
                        "        isBinaryish(expression)",
                        "      ) {",
                        "        expressionDoc = [indent([softline, expressionDoc]), softline];",
                        "      }",
                        "    }",
                        "",
                        "    const aligned =",
                        "      indentSize === 0 && text.endsWith(\"\\n\")",
                        "        ? align(Number.NEGATIVE_INFINITY, expressionDoc)",
                        "        : addAlignmentToDoc(expressionDoc, indentSize, tabWidth);",
                        "",
                        "    parts.push(group([\"${\", aligned, lineSuffixBoundary, \"}\"]));",
                        "  }, \"quasis\");",
                        "",
                        "  parts.push(\"`\");",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printTaggedTemplateLiteral(print) {",
                        "  const quasiDoc = print(\"quasi\");",
                        "  return label(quasiDoc.label && { tagged: true, ...quasiDoc.label }, [",
                        "    print(\"tag\"),",
                        "    print(\"typeParameters\"),",
                        "    lineSuffixBoundary,",
                        "    quasiDoc,",
                        "  ]);",
                        "}",
                        "",
                        "function printJestEachTemplateLiteral(path, options, print) {",
                        "  /**",
                        "   * a    | b    | expected",
                        "   * ${1} | ${1} | ${2}",
                        "   * ${1} | ${2} | ${3}",
                        "   * ${2} | ${1} | ${3}",
                        "   */",
                        "  const { node } = path;",
                        "  const headerNames = node.quasis[0].value.raw.trim().split(/\\s*\\|\\s*/);",
                        "  if (",
                        "    headerNames.length > 1 ||",
                        "    headerNames.some((headerName) => headerName.length > 0)",
                        "  ) {",
                        "    options.__inJestEach = true;",
                        "    const expressions = path.map(print, \"expressions\");",
                        "    options.__inJestEach = false;",
                        "    const parts = [];",
                        "    const stringifiedExpressions = expressions.map(",
                        "      (doc) =>",
                        "        \"${\" +",
                        "        printDocToString(doc, {",
                        "          ...options,",
                        "          printWidth: Number.POSITIVE_INFINITY,",
                        "          endOfLine: \"lf\",",
                        "        }).formatted +",
                        "        \"}\"",
                        "    );",
                        "",
                        "    const tableBody = [{ hasLineBreak: false, cells: [] }];",
                        "    for (let i = 1; i < node.quasis.length; i++) {",
                        "      const row = tableBody.at(-1);",
                        "      const correspondingExpression = stringifiedExpressions[i - 1];",
                        "",
                        "      row.cells.push(correspondingExpression);",
                        "      if (correspondingExpression.includes(\"\\n\")) {",
                        "        row.hasLineBreak = true;",
                        "      }",
                        "",
                        "      if (node.quasis[i].value.raw.includes(\"\\n\")) {",
                        "        tableBody.push({ hasLineBreak: false, cells: [] });",
                        "      }",
                        "    }",
                        "",
                        "    const maxColumnCount = Math.max(",
                        "      headerNames.length,",
                        "      ...tableBody.map((row) => row.cells.length)",
                        "    );",
                        "",
                        "    const maxColumnWidths = Array.from({ length: maxColumnCount }).fill(0);",
                        "    const table = [",
                        "      { cells: headerNames },",
                        "      ...tableBody.filter((row) => row.cells.length > 0),",
                        "    ];",
                        "    for (const { cells } of table.filter((row) => !row.hasLineBreak)) {",
                        "      for (const [index, cell] of cells.entries()) {",
                        "        maxColumnWidths[index] = Math.max(",
                        "          maxColumnWidths[index],",
                        "          getStringWidth(cell)",
                        "        );",
                        "      }",
                        "    }",
                        "",
                        "    parts.push(",
                        "      lineSuffixBoundary,",
                        "      \"`\",",
                        "      indent([",
                        "        hardline,",
                        "        join(",
                        "          hardline,",
                        "          table.map((row) =>",
                        "            join(",
                        "              \" | \",",
                        "              row.cells.map((cell, index) =>",
                        "                row.hasLineBreak",
                        "                  ? cell",
                        "                  : cell +",
                        "                    \" \".repeat(maxColumnWidths[index] - getStringWidth(cell))",
                        "              )",
                        "            )",
                        "          )",
                        "        ),",
                        "      ]),",
                        "      hardline,",
                        "      \"`\"",
                        "    );",
                        "    return parts;",
                        "  }",
                        "}",
                        "",
                        "function printTemplateExpression(path, print) {",
                        "  const { node } = path;",
                        "  let printed = print();",
                        "  if (hasComment(node)) {",
                        "    printed = group([indent([softline, printed]), softline]);",
                        "  }",
                        "  return [\"${\", printed, lineSuffixBoundary, \"}\"];",
                        "}",
                        "",
                        "function printTemplateExpressions(path, print) {",
                        "  return path.map(",
                        "    (path) => printTemplateExpression(path, print),",
                        "    \"expressions\"",
                        "  );",
                        "}",
                        "",
                        "function escapeTemplateCharacters(doc, raw) {",
                        "  return mapDoc(doc, (currentDoc) => {",
                        "    if (typeof currentDoc === \"string\") {",
                        "      return raw",
                        "        ? currentDoc.replaceAll(/(\\\\*)`/g, \"$1$1\\\\`\")",
                        "        : uncookTemplateElementValue(currentDoc);",
                        "    }",
                        "",
                        "    return currentDoc;",
                        "  });",
                        "}",
                        "",
                        "function uncookTemplateElementValue(cookedValue) {",
                        "  return cookedValue.replaceAll(/([\\\\`]|\\${)/g, \"\\\\$1\");",
                        "}",
                        "",
                        "function isJestEachTemplateLiteral({ node, parent }) {",
                        "  /**",
                        "   * describe.each`table`(name, fn)",
                        "   * describe.only.each`table`(name, fn)",
                        "   * describe.skip.each`table`(name, fn)",
                        "   * test.each`table`(name, fn)",
                        "   * test.only.each`table`(name, fn)",
                        "   * test.skip.each`table`(name, fn)",
                        "   *",
                        "   * Ref: https://github.com/facebook/jest/pull/6102",
                        "   */",
                        "  const jestEachTriggerRegex = /^[fx]?(?:describe|it|test)$/;",
                        "  return (",
                        "    parent.type === \"TaggedTemplateExpression\" &&",
                        "    parent.quasi === node &&",
                        "    parent.tag.type === \"MemberExpression\" &&",
                        "    parent.tag.property.type === \"Identifier\" &&",
                        "    parent.tag.property.name === \"each\" &&",
                        "    ((parent.tag.object.type === \"Identifier\" &&",
                        "      jestEachTriggerRegex.test(parent.tag.object.name)) ||",
                        "      (parent.tag.object.type === \"MemberExpression\" &&",
                        "        parent.tag.object.property.type === \"Identifier\" &&",
                        "        (parent.tag.object.property.name === \"only\" ||",
                        "          parent.tag.object.property.name === \"skip\") &&",
                        "        parent.tag.object.object.type === \"Identifier\" &&",
                        "        jestEachTriggerRegex.test(parent.tag.object.object.name)))",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  printTemplateLiteral,",
                        "  printTaggedTemplateLiteral,",
                        "  printTemplateExpressions,",
                        "  escapeTemplateCharacters,",
                        "  uncookTemplateElementValue,",
                        "};"
                    ]
                },
                "ternary.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import hasNewlineInRange from \"../../utils/has-newline-in-range.js\";",
                        "import {",
                        "  isJsxElement,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isTSTypeExpression,",
                        "  hasComment,",
                        "} from \"../utils/index.js\";",
                        "import { locStart, locEnd } from \"../loc.js\";",
                        "import isBlockComment from \"../utils/is-block-comment.js\";",
                        "import {",
                        "  line,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  align,",
                        "  ifBreak,",
                        "  dedent,",
                        "  breakParent,",
                        "} from \"../../document/builders.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " *",
                        " * @typedef {any} Options - Prettier options (TBD ...)",
                        " */",
                        "",
                        "// If we have nested conditional expressions, we want to print them in JSX mode",
                        "// if there's at least one JSXElement somewhere in the tree.",
                        "//",
                        "// A conditional expression chain like this should be printed in normal mode,",
                        "// because there aren't JSXElements anywhere in it:",
                        "//",
                        "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : \"Unknown\";",
                        "//",
                        "// But a conditional expression chain like this should be printed in JSX mode,",
                        "// because there is a JSXElement in the last ConditionalExpression:",
                        "//",
                        "// isA ? \"A\" : isB ? \"B\" : isC ? \"C\" : <span className=\"warning\">Unknown</span>;",
                        "//",
                        "// This type of ConditionalExpression chain is structured like this in the AST:",
                        "//",
                        "// ConditionalExpression {",
                        "//   test: ...,",
                        "//   consequent: ...,",
                        "//   alternate: ConditionalExpression {",
                        "//     test: ...,",
                        "//     consequent: ...,",
                        "//     alternate: ConditionalExpression {",
                        "//       test: ...,",
                        "//       consequent: ...,",
                        "//       alternate: ...,",
                        "//     }",
                        "//   }",
                        "// }",
                        "function conditionalExpressionChainContainsJsx(node) {",
                        "  // Given this code:",
                        "  //",
                        "  // // Using a ConditionalExpression as the consequent is uncommon, but should",
                        "  // // be handled.",
                        "  // A ? B : C ? D : E ? F ? G : H : I",
                        "  //",
                        "  // which has this AST:",
                        "  //",
                        "  // ConditionalExpression {",
                        "  //   test: Identifier(A),",
                        "  //   consequent: Identifier(B),",
                        "  //   alternate: ConditionalExpression {",
                        "  //     test: Identifier(C),",
                        "  //     consequent: Identifier(D),",
                        "  //     alternate: ConditionalExpression {",
                        "  //       test: Identifier(E),",
                        "  //       consequent: ConditionalExpression {",
                        "  //         test: Identifier(F),",
                        "  //         consequent: Identifier(G),",
                        "  //         alternate: Identifier(H),",
                        "  //       },",
                        "  //       alternate: Identifier(I),",
                        "  //     }",
                        "  //   }",
                        "  // }",
                        "  //",
                        "  // We don't care about whether each node was the test, consequent, or alternate",
                        "  // We are only checking if there's any JSXElements inside.",
                        "  const conditionalExpressions = [node];",
                        "  for (let index = 0; index < conditionalExpressions.length; index++) {",
                        "    const conditionalExpression = conditionalExpressions[index];",
                        "    for (const property of [\"test\", \"consequent\", \"alternate\"]) {",
                        "      const node = conditionalExpression[property];",
                        "",
                        "      if (isJsxElement(node)) {",
                        "        return true;",
                        "      }",
                        "",
                        "      if (node.type === \"ConditionalExpression\") {",
                        "        conditionalExpressions.push(node);",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function printTernaryTest(path, options, print) {",
                        "  const { node } = path;",
                        "  const isConditionalExpression = node.type === \"ConditionalExpression\";",
                        "  const alternateNodePropertyName = isConditionalExpression",
                        "    ? \"alternate\"",
                        "    : \"falseType\";",
                        "",
                        "  const { parent } = path;",
                        "",
                        "  const printed = isConditionalExpression",
                        "    ? print(\"test\")",
                        "    : [print(\"checkType\"), \" \", \"extends\", \" \", print(\"extendsType\")];",
                        "  /**",
                        "   *     a",
                        "   *       ? b",
                        "   *       : multiline",
                        "   *         test",
                        "   *         node",
                        "   *       ^^ align(2)",
                        "   *       ? d",
                        "   *       : e",
                        "   */",
                        "  if (parent.type === node.type && parent[alternateNodePropertyName] === node) {",
                        "    return align(2, printed);",
                        "  }",
                        "  return printed;",
                        "}",
                        "",
                        "const ancestorNameMap = new Map([",
                        "  [\"AssignmentExpression\", \"right\"],",
                        "  [\"VariableDeclarator\", \"init\"],",
                        "  [\"ReturnStatement\", \"argument\"],",
                        "  [\"ThrowStatement\", \"argument\"],",
                        "  [\"UnaryExpression\", \"argument\"],",
                        "  [\"YieldExpression\", \"argument\"],",
                        "]);",
                        "function shouldExtraIndentForConditionalExpression(path) {",
                        "  const { node } = path;",
                        "  if (node.type !== \"ConditionalExpression\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  let parent;",
                        "  let child = node;",
                        "  for (let ancestorCount = 0; !parent; ancestorCount++) {",
                        "    const node = path.getParentNode(ancestorCount);",
                        "",
                        "    if (",
                        "      (node.type === \"ChainExpression\" && node.expression === child) ||",
                        "      (isCallExpression(node) && node.callee === child) ||",
                        "      (isMemberExpression(node) && node.object === child) ||",
                        "      (node.type === \"TSNonNullExpression\" && node.expression === child)",
                        "    ) {",
                        "      child = node;",
                        "      continue;",
                        "    }",
                        "",
                        "    // Reached chain root",
                        "",
                        "    if (",
                        "      (node.type === \"NewExpression\" && node.callee === child) ||",
                        "      (isTSTypeExpression(node) && node.expression === child)",
                        "    ) {",
                        "      parent = path.getParentNode(ancestorCount + 1);",
                        "      child = node;",
                        "    } else {",
                        "      parent = node;",
                        "    }",
                        "  }",
                        "",
                        "  // Do not add indent to direct `ConditionalExpression`",
                        "  if (child === node) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return parent[ancestorNameMap.get(parent.type)] === child;",
                        "}",
                        "",
                        "/**",
                        " * The following is the shared logic for",
                        " * ternary operators, namely ConditionalExpression,",
                        " * ConditionalTypeAnnotation and TSConditionalType",
                        " * @param {AstPath} path - The path to the ConditionalExpression/TSConditionalType node.",
                        " * @param {Options} options - Prettier options",
                        " * @param {Function} print - Print function to call recursively",
                        " * @returns {Doc}",
                        " */",
                        "function printTernary(path, options, print) {",
                        "  const { node } = path;",
                        "  const isConditionalExpression = node.type === \"ConditionalExpression\";",
                        "  const consequentNodePropertyName = isConditionalExpression",
                        "    ? \"consequent\"",
                        "    : \"trueType\";",
                        "  const alternateNodePropertyName = isConditionalExpression",
                        "    ? \"alternate\"",
                        "    : \"falseType\";",
                        "  const testNodePropertyNames = isConditionalExpression",
                        "    ? [\"test\"]",
                        "    : [\"checkType\", \"extendsType\"];",
                        "  const consequentNode = node[consequentNodePropertyName];",
                        "  const alternateNode = node[alternateNodePropertyName];",
                        "  const parts = [];",
                        "",
                        "  // We print a ConditionalExpression in either \"JSX mode\" or \"normal mode\".",
                        "  // See `tests/format/jsx/conditional-expression.js` for more info.",
                        "  let jsxMode = false;",
                        "  const { parent } = path;",
                        "  const isParentTest =",
                        "    parent.type === node.type &&",
                        "    testNodePropertyNames.some((prop) => parent[prop] === node);",
                        "  let forceNoIndent = parent.type === node.type && !isParentTest;",
                        "",
                        "  // Find the outermost non-ConditionalExpression parent, and the outermost",
                        "  // ConditionalExpression parent. We'll use these to determine if we should",
                        "  // print in JSX mode.",
                        "  let currentParent;",
                        "  let previousParent;",
                        "  let i = 0;",
                        "  do {",
                        "    previousParent = currentParent || node;",
                        "    currentParent = path.getParentNode(i);",
                        "    i++;",
                        "  } while (",
                        "    currentParent &&",
                        "    currentParent.type === node.type &&",
                        "    testNodePropertyNames.every(",
                        "      (prop) => currentParent[prop] !== previousParent",
                        "    )",
                        "  );",
                        "  const firstNonConditionalParent = currentParent || parent;",
                        "  const lastConditionalParent = previousParent;",
                        "",
                        "  if (",
                        "    isConditionalExpression &&",
                        "    (isJsxElement(node[testNodePropertyNames[0]]) ||",
                        "      isJsxElement(consequentNode) ||",
                        "      isJsxElement(alternateNode) ||",
                        "      conditionalExpressionChainContainsJsx(lastConditionalParent))",
                        "  ) {",
                        "    jsxMode = true;",
                        "    forceNoIndent = true;",
                        "",
                        "    // Even though they don't need parens, we wrap (almost) everything in",
                        "    // parens when using ?: within JSX, because the parens are analogous to",
                        "    // curly braces in an if statement.",
                        "    const wrap = (doc) => [",
                        "      ifBreak(\"(\"),",
                        "      indent([softline, doc]),",
                        "      softline,",
                        "      ifBreak(\")\"),",
                        "    ];",
                        "",
                        "    // The only things we don't wrap are:",
                        "    // * Nested conditional expressions in alternates",
                        "    // * null",
                        "    // * undefined",
                        "    const isNil = (node) =>",
                        "      node.type === \"NullLiteral\" ||",
                        "      (node.type === \"Literal\" && node.value === null) ||",
                        "      (node.type === \"Identifier\" && node.name === \"undefined\");",
                        "",
                        "    parts.push(",
                        "      \" ? \",",
                        "      isNil(consequentNode)",
                        "        ? print(consequentNodePropertyName)",
                        "        : wrap(print(consequentNodePropertyName)),",
                        "      \" : \",",
                        "      alternateNode.type === node.type || isNil(alternateNode)",
                        "        ? print(alternateNodePropertyName)",
                        "        : wrap(print(alternateNodePropertyName))",
                        "    );",
                        "  } else {",
                        "    // normal mode",
                        "    const part = [",
                        "      line,",
                        "      \"? \",",
                        "      consequentNode.type === node.type ? ifBreak(\"\", \"(\") : \"\",",
                        "      align(2, print(consequentNodePropertyName)),",
                        "      consequentNode.type === node.type ? ifBreak(\"\", \")\") : \"\",",
                        "      line,",
                        "      \": \",",
                        "      alternateNode.type === node.type",
                        "        ? print(alternateNodePropertyName)",
                        "        : align(2, print(alternateNodePropertyName)),",
                        "    ];",
                        "    parts.push(",
                        "      parent.type !== node.type ||",
                        "        parent[alternateNodePropertyName] === node ||",
                        "        isParentTest",
                        "        ? part",
                        "        : options.useTabs",
                        "        ? dedent(indent(part))",
                        "        : align(Math.max(0, options.tabWidth - 2), part)",
                        "    );",
                        "  }",
                        "",
                        "  // We want a whole chain of ConditionalExpressions to all",
                        "  // break if any of them break. That means we should only group around the",
                        "  // outer-most ConditionalExpression.",
                        "  const shouldBreak = [",
                        "    consequentNodePropertyName,",
                        "    alternateNodePropertyName,",
                        "    ...testNodePropertyNames,",
                        "  ].some((property) =>",
                        "    hasComment(",
                        "      node[property],",
                        "      (comment) =>",
                        "        isBlockComment(comment) &&",
                        "        hasNewlineInRange(",
                        "          options.originalText,",
                        "          locStart(comment),",
                        "          locEnd(comment)",
                        "        )",
                        "    )",
                        "  );",
                        "  const maybeGroup = (doc) =>",
                        "    parent === firstNonConditionalParent",
                        "      ? group(doc, { shouldBreak })",
                        "      : shouldBreak",
                        "      ? [doc, breakParent]",
                        "      : doc;",
                        "",
                        "  // Break the closing paren to keep the chain right after it:",
                        "  // (a",
                        "  //   ? b",
                        "  //   : c",
                        "  // ).call()",
                        "  const breakClosingParen =",
                        "    !jsxMode &&",
                        "    (isMemberExpression(parent) ||",
                        "      (parent.type === \"NGPipeExpression\" && parent.left === node)) &&",
                        "    !parent.computed;",
                        "",
                        "  const shouldExtraIndent = shouldExtraIndentForConditionalExpression(path);",
                        "",
                        "  const result = maybeGroup([",
                        "    printTernaryTest(path, options, print),",
                        "    forceNoIndent ? parts : indent(parts),",
                        "    isConditionalExpression && breakClosingParen && !shouldExtraIndent",
                        "      ? softline",
                        "      : \"\",",
                        "  ]);",
                        "",
                        "  return isParentTest || shouldExtraIndent",
                        "    ? group([indent([softline, result]), softline])",
                        "    : result;",
                        "}",
                        "",
                        "export { printTernary };"
                    ]
                },
                "type-annotation.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  group,",
                        "  join,",
                        "  line,",
                        "  softline,",
                        "  indent,",
                        "  align,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import pathNeedsParens from \"../needs-parens.js\";",
                        "import { hasSameLocStart } from \"../loc.js\";",
                        "import {",
                        "  isSimpleType,",
                        "  isObjectType,",
                        "  hasLeadingOwnLineComment,",
                        "  isObjectTypePropertyAFunction,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "} from \"../utils/index.js\";",
                        "import { printAssignment } from \"./assignment.js\";",
                        "import {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} from \"./function-parameters.js\";",
                        "import {",
                        "  printOptionalToken,",
                        "  printDeclareToken,",
                        "  printAbstractToken,",
                        "} from \"./misc.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "function shouldHugType(node) {",
                        "  if (isSimpleType(node) || isObjectType(node)) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.type === \"UnionTypeAnnotation\" || node.type === \"TSUnionType\") {",
                        "    const voidCount = node.types.filter(",
                        "      (node) =>",
                        "        node.type === \"VoidTypeAnnotation\" ||",
                        "        node.type === \"TSVoidKeyword\" ||",
                        "        node.type === \"NullLiteralTypeAnnotation\" ||",
                        "        node.type === \"TSNullKeyword\"",
                        "    ).length;",
                        "",
                        "    const hasObject = node.types.some(",
                        "      (node) =>",
                        "        node.type === \"ObjectTypeAnnotation\" ||",
                        "        node.type === \"TSTypeLiteral\" ||",
                        "        // This is a bit aggressive but captures Array<{x}>",
                        "        node.type === \"GenericTypeAnnotation\" ||",
                        "        node.type === \"TSTypeReference\"",
                        "    );",
                        "",
                        "    const hasComments = node.types.some((node) => hasComment(node));",
                        "",
                        "    if (node.types.length - 1 === voidCount && hasObject && !hasComments) {",
                        "      return true;",
                        "    }",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "/*",
                        "- `DeclareOpaqueType`(flow)",
                        "- `OpaqueType`(flow)",
                        "*/",
                        "function printOpaqueType(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const { node } = path;",
                        "  const parts = [",
                        "    printDeclareToken(path),",
                        "    \"opaque type \",",
                        "    print(\"id\"),",
                        "    print(\"typeParameters\"),",
                        "  ];",
                        "",
                        "  if (node.supertype) {",
                        "    parts.push(\": \", print(\"supertype\"));",
                        "  }",
                        "",
                        "  if (node.impltype) {",
                        "    parts.push(\" = \", print(\"impltype\"));",
                        "  }",
                        "",
                        "  parts.push(semi);",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "/*",
                        "- `DeclareTypeAlias`(flow)",
                        "- `TypeAlias`(flow)",
                        "- `TSTypeAliasDeclaration`(TypeScript)",
                        "*/",
                        "function printTypeAlias(path, options, print) {",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const { node } = path;",
                        "  const parts = [printDeclareToken(path)];",
                        "",
                        "  parts.push(\"type \", print(\"id\"), print(\"typeParameters\"));",
                        "  const rightPropertyName =",
                        "    node.type === \"TSTypeAliasDeclaration\" ? \"typeAnnotation\" : \"right\";",
                        "  return [",
                        "    printAssignment(path, options, print, parts, \" =\", rightPropertyName),",
                        "    semi,",
                        "  ];",
                        "}",
                        "",
                        "// `TSIntersectionType` and `IntersectionTypeAnnotation`",
                        "function printIntersectionType(path, options, print) {",
                        "  const { node } = path;",
                        "  const types = path.map(print, \"types\");",
                        "  const result = [];",
                        "  let wasIndented = false;",
                        "  for (let i = 0; i < types.length; ++i) {",
                        "    if (i === 0) {",
                        "      result.push(types[i]);",
                        "    } else if (isObjectType(node.types[i - 1]) && isObjectType(node.types[i])) {",
                        "      // If both are objects, don't indent",
                        "      result.push([\" & \", wasIndented ? indent(types[i]) : types[i]]);",
                        "    } else if (",
                        "      !isObjectType(node.types[i - 1]) &&",
                        "      !isObjectType(node.types[i])",
                        "    ) {",
                        "      // If no object is involved, go to the next line if it breaks",
                        "      result.push(indent([\" &\", line, types[i]]));",
                        "    } else {",
                        "      // If you go from object to non-object or vis-versa, then inline it",
                        "      if (i > 1) {",
                        "        wasIndented = true;",
                        "      }",
                        "      result.push(\" & \", i > 1 ? indent(types[i]) : types[i]);",
                        "    }",
                        "  }",
                        "  return group(result);",
                        "}",
                        "",
                        "// `TSUnionType` and `UnionTypeAnnotation`",
                        "function printUnionType(path, options, print) {",
                        "  const { node } = path;",
                        "  // single-line variation",
                        "  // A | B | C",
                        "",
                        "  // multi-line variation",
                        "  // | A",
                        "  // | B",
                        "  // | C",
                        "",
                        "  const { parent } = path;",
                        "",
                        "  // If there's a leading comment, the parent is doing the indentation",
                        "  const shouldIndent =",
                        "    parent.type !== \"TypeParameterInstantiation\" &&",
                        "    parent.type !== \"TSTypeParameterInstantiation\" &&",
                        "    parent.type !== \"GenericTypeAnnotation\" &&",
                        "    parent.type !== \"TSTypeReference\" &&",
                        "    parent.type !== \"TSTypeAssertion\" &&",
                        "    parent.type !== \"TupleTypeAnnotation\" &&",
                        "    parent.type !== \"TSTupleType\" &&",
                        "    !(",
                        "      parent.type === \"FunctionTypeParam\" &&",
                        "      !parent.name &&",
                        "      path.grandparent.this !== parent",
                        "    ) &&",
                        "    !(",
                        "      (parent.type === \"TypeAlias\" ||",
                        "        parent.type === \"VariableDeclarator\" ||",
                        "        parent.type === \"TSTypeAliasDeclaration\") &&",
                        "      hasLeadingOwnLineComment(options.originalText, node)",
                        "    );",
                        "",
                        "  // {",
                        "  //   a: string",
                        "  // } | null | void",
                        "  // should be inlined and not be printed in the multi-line variant",
                        "  const shouldHug = shouldHugType(node);",
                        "",
                        "  // We want to align the children but without its comment, so it looks like",
                        "  // | child1",
                        "  // // comment",
                        "  // | child2",
                        "  const printed = path.map((typePath) => {",
                        "    let printedType = print();",
                        "    if (!shouldHug) {",
                        "      printedType = align(2, printedType);",
                        "    }",
                        "    return printComments(typePath, printedType, options);",
                        "  }, \"types\");",
                        "",
                        "  if (shouldHug) {",
                        "    return join(\" | \", printed);",
                        "  }",
                        "",
                        "  const shouldAddStartLine =",
                        "    shouldIndent && !hasLeadingOwnLineComment(options.originalText, node);",
                        "",
                        "  const code = [",
                        "    ifBreak([shouldAddStartLine ? line : \"\", \"| \"]),",
                        "    join([line, \"| \"], printed),",
                        "  ];",
                        "",
                        "  if (pathNeedsParens(path, options)) {",
                        "    return group([indent(code), softline]);",
                        "  }",
                        "",
                        "  if (parent.type === \"TupleTypeAnnotation\" || parent.type === \"TSTupleType\") {",
                        "    const elementTypes =",
                        "      parent[",
                        "        // TODO: Remove `types` when babel changes AST of `TupleTypeAnnotation`",
                        "        parent.type === \"TupleTypeAnnotation\" && parent.types",
                        "          ? \"types\"",
                        "          : \"elementTypes\"",
                        "      ];",
                        "",
                        "    if (elementTypes.length > 1) {",
                        "      return group([",
                        "        indent([ifBreak([\"(\", softline]), code]),",
                        "        softline,",
                        "        ifBreak(\")\"),",
                        "      ]);",
                        "    }",
                        "  }",
                        "",
                        "  return group(shouldIndent ? indent(code) : code);",
                        "}",
                        "",
                        "/*",
                        "`FunctionTypeAnnotation` is ambiguous:",
                        "- `declare function foo(a: B): void;`",
                        "- `var A: (a: B) => void;`",
                        "*/",
                        "function isFlowArrowFunctionTypeAnnotation(path) {",
                        "  const { node, parent } = path;",
                        "  return (",
                        "    node.type === \"FunctionTypeAnnotation\" &&",
                        "    (isObjectTypePropertyAFunction(parent) ||",
                        "      !(",
                        "        ((parent.type === \"ObjectTypeProperty\" ||",
                        "          parent.type === \"ObjectTypeInternalSlot\") &&",
                        "          !parent.variance &&",
                        "          !parent.optional &&",
                        "          hasSameLocStart(parent, node)) ||",
                        "        parent.type === \"ObjectTypeCallProperty\" ||",
                        "        path.getParentNode(2)?.type === \"DeclareFunction\"",
                        "      ))",
                        "  );",
                        "}",
                        "",
                        "/*",
                        "- `TSFunctionType` (TypeScript)",
                        "- `TSCallSignatureDeclaration` (TypeScript)",
                        "- `TSConstructorType` (TypeScript)",
                        "- `TSConstructSignatureDeclaration` (TypeScript)",
                        "- `FunctionTypeAnnotation` (Flow)",
                        "*/",
                        "function printFunctionType(path, options, print) {",
                        "  const { node } = path;",
                        "  /** @type {Doc[]} */",
                        "  const parts = [",
                        "    // `TSConstructorType` only",
                        "    printAbstractToken(path),",
                        "  ];",
                        "",
                        "  if (",
                        "    node.type === \"TSConstructorType\" ||",
                        "    node.type === \"TSConstructSignatureDeclaration\"",
                        "  ) {",
                        "    parts.push(\"new \");",
                        "  }",
                        "",
                        "  let parametersDoc = printFunctionParameters(",
                        "    path,",
                        "    print,",
                        "    options,",
                        "    /* expandArg */ false,",
                        "    /* printTypeParams */ true",
                        "  );",
                        "",
                        "  const returnTypeDoc = [];",
                        "  // `flow` doesn't wrap the `returnType` with `TypeAnnotation`, so the colon",
                        "  // needs to be added separately.",
                        "  if (node.type === \"FunctionTypeAnnotation\") {",
                        "    returnTypeDoc.push(",
                        "      isFlowArrowFunctionTypeAnnotation(path) ? \" => \" : \": \",",
                        "      print(\"returnType\")",
                        "    );",
                        "  } else {",
                        "    returnTypeDoc.push(",
                        "      printTypeAnnotationProperty(",
                        "        path,",
                        "        print,",
                        "        node.returnType ? \"returnType\" : \"typeAnnotation\"",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  if (shouldGroupFunctionParameters(node, returnTypeDoc)) {",
                        "    parametersDoc = group(parametersDoc);",
                        "  }",
                        "",
                        "  parts.push(parametersDoc, returnTypeDoc);",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "/*",
                        "- `TSIndexedAccessType`(TypeScript)",
                        "- `IndexedAccessType`(flow)",
                        "- `OptionalIndexedAccessType`(flow)",
                        "*/",
                        "function printIndexedAccessType(path, options, print) {",
                        "  return [",
                        "    print(\"objectType\"),",
                        "    printOptionalToken(path),",
                        "    \"[\",",
                        "    print(\"indexType\"),",
                        "    \"]\",",
                        "  ];",
                        "}",
                        "",
                        "/*",
                        "- `TSInferType`(TypeScript)",
                        "- `InferTypeAnnotation`(flow)",
                        "*/",
                        "function printInferType(path, options, print) {",
                        "  return [\"infer \", print(\"typeParameter\")];",
                        "}",
                        "",
                        "// `TSJSDocNullableType`, `TSJSDocNonNullableType`",
                        "function printJSDocType(path, print, token) {",
                        "  const { node } = path;",
                        "  return [",
                        "    node.postfix ? \"\" : token,",
                        "    printTypeAnnotationProperty(path, print),",
                        "    node.postfix ? token : \"\",",
                        "  ];",
                        "}",
                        "",
                        "/*",
                        "- `TSRestType`(TypeScript)",
                        "- `TupleTypeSpreadElement`(flow)",
                        "*/",
                        "function printRestType(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  return [",
                        "    \"...\",",
                        "    ...(node.type === \"TupleTypeSpreadElement\" && node.label",
                        "      ? [print(\"label\"), \": \"]",
                        "      : []),",
                        "    print(\"typeAnnotation\"),",
                        "  ];",
                        "}",
                        "",
                        "/*",
                        "- `TSNamedTupleMember`(TypeScript)",
                        "- `TupleTypeLabeledElement`(flow)",
                        "*/",
                        "function printNamedTupleMember(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  return [",
                        "    // `TupleTypeLabeledElement` only",
                        "    node.variance ? print(\"variance\") : \"\",",
                        "    print(\"label\"),",
                        "    node.optional ? \"?\" : \"\",",
                        "    \": \",",
                        "    print(\"elementType\"),",
                        "  ];",
                        "}",
                        "",
                        "/*",
                        "Normally the `(TS)TypeAnnotation` node starts with `:` token.",
                        "If we print `:` in parent node, `cursorNodeDiff` in `/src/main/core.js` will consider `:` is removed, cause cursor moves, see #12491.",
                        "Token *before* `(TS)TypeAnnotation.typeAnnotation` should be printed in `getTypeAnnotationFirstToken` function.",
                        "*/",
                        "const typeAnnotationNodesCheckedLeadingComments = new WeakSet();",
                        "function printTypeAnnotationProperty(",
                        "  path,",
                        "  print,",
                        "  propertyName = \"typeAnnotation\"",
                        ") {",
                        "  const {",
                        "    node: { [propertyName]: typeAnnotation },",
                        "  } = path;",
                        "",
                        "  if (!typeAnnotation) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  let shouldPrintLeadingSpace = false;",
                        "",
                        "  if (",
                        "    typeAnnotation.type === \"TSTypeAnnotation\" ||",
                        "    typeAnnotation.type === \"TypeAnnotation\"",
                        "  ) {",
                        "    const firstToken = path.call(getTypeAnnotationFirstToken, propertyName);",
                        "",
                        "    if (",
                        "      firstToken === \"=>\" ||",
                        "      (firstToken === \":\" &&",
                        "        hasComment(typeAnnotation, CommentCheckFlags.Leading))",
                        "    ) {",
                        "      shouldPrintLeadingSpace = true;",
                        "    }",
                        "",
                        "    typeAnnotationNodesCheckedLeadingComments.add(typeAnnotation);",
                        "  }",
                        "",
                        "  return shouldPrintLeadingSpace",
                        "    ? [\" \", print(propertyName)]",
                        "    : print(propertyName);",
                        "}",
                        "",
                        "const getTypeAnnotationFirstToken = (path) => {",
                        "  if (",
                        "    // TypeScript",
                        "    path.match(",
                        "      (node) => node.type === \"TSTypeAnnotation\",",
                        "      (node, key) =>",
                        "        (key === \"returnType\" || key === \"typeAnnotation\") &&",
                        "        (node.type === \"TSFunctionType\" || node.type === \"TSConstructorType\")",
                        "    )",
                        "  ) {",
                        "    return \"=>\";",
                        "  }",
                        "",
                        "  if (",
                        "    // TypeScript",
                        "    path.match(",
                        "      (node) => node.type === \"TSTypeAnnotation\",",
                        "      (node, key) =>",
                        "        key === \"typeAnnotation\" &&",
                        "        (node.type === \"TSJSDocNullableType\" ||",
                        "          node.type === \"TSJSDocNonNullableType\" ||",
                        "          node.type === \"TSTypePredicate\")",
                        "    ) ||",
                        "    /*",
                        "    Flow",
                        "",
                        "    ```js",
                        "    declare function foo(): void;",
                        "                        ^^^^^^^^ `TypeAnnotation`",
                        "    ```",
                        "    */",
                        "    path.match(",
                        "      (node) => node.type === \"TypeAnnotation\",",
                        "      (node, key) => key === \"typeAnnotation\" && node.type === \"Identifier\",",
                        "      (node, key) => key === \"id\" && node.type === \"DeclareFunction\"",
                        "    ) ||",
                        "    /*",
                        "    Flow",
                        "",
                        "    ```js",
                        "    type A = () => infer R extends string;",
                        "                                   ^^^^^^ `TypeAnnotation`",
                        "    ```",
                        "    */",
                        "    path.match(",
                        "      (node) => node.type === \"TypeAnnotation\",",
                        "      (node, key) =>",
                        "        key === \"bound\" &&",
                        "        node.type === \"TypeParameter\" &&",
                        "        node.usesExtendsBound",
                        "    )",
                        "  ) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  return \":\";",
                        "};",
                        "",
                        "/*",
                        "- `TSTypeAnnotation` (TypeScript)",
                        "- `TypeAnnotation` (Flow)",
                        "*/",
                        "function printTypeAnnotation(path, options, print) {",
                        "  // We need print space before leading comments,",
                        "  // `printTypeAnnotationProperty` is responsible for it.",
                        "  /* c8 ignore start */",
                        "  if (process.env.NODE_ENV !== \"production\") {",
                        "    const { node } = path;",
                        "",
                        "    if (!typeAnnotationNodesCheckedLeadingComments.has(node)) {",
                        "      throw Object.assign(",
                        "        new Error(",
                        "          `'${node.type}' should be printed by '${printTypeAnnotationProperty.name}' function.`",
                        "        ),",
                        "        { parentNode: path.parent, propertyName: path.key }",
                        "      );",
                        "    }",
                        "  }",
                        "  /* c8 ignore stop */",
                        "",
                        "  const token = getTypeAnnotationFirstToken(path);",
                        "  return token",
                        "    ? [token, \" \", print(\"typeAnnotation\")]",
                        "    : print(\"typeAnnotation\");",
                        "}",
                        "",
                        "/*",
                        "- `TSArrayType`",
                        "- `ArrayTypeAnnotation`",
                        "*/",
                        "function printArrayType(print) {",
                        "  return [print(\"elementType\"), \"[]\"];",
                        "}",
                        "",
                        "/*",
                        "- `TSTypeQuery`",
                        "- `TypeofTypeAnnotation`",
                        "*/",
                        "function printTypeQuery({ node }, print) {",
                        "  return [",
                        "    \"typeof \",",
                        "    ...(node.type === \"TSTypeQuery\"",
                        "      ? [print(\"exprName\"), print(\"typeParameters\")]",
                        "      : [print(\"argument\")]),",
                        "  ];",
                        "}",
                        "",
                        "export {",
                        "  printOpaqueType,",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printIndexedAccessType,",
                        "  printInferType,",
                        "  shouldHugType,",
                        "  printJSDocType,",
                        "  printRestType,",
                        "  printNamedTupleMember,",
                        "  printTypeAnnotationProperty,",
                        "  printTypeAnnotation,",
                        "  printArrayType,",
                        "  printTypeQuery,",
                        "};"
                    ]
                },
                "type-parameters.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { printDanglingComments } from \"../../main/comments/print.js\";",
                        "import {",
                        "  join,",
                        "  line,",
                        "  hardline,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  isTestCall,",
                        "  hasComment,",
                        "  CommentCheckFlags,",
                        "  isTSXFile,",
                        "  shouldPrintComma,",
                        "  getFunctionParameters,",
                        "  isObjectType,",
                        "} from \"../utils/index.js\";",
                        "import createGroupIdMapper from \"../../utils/create-group-id-mapper.js\";",
                        "import {",
                        "  printTypeAnnotationProperty,",
                        "  shouldHugType,",
                        "} from \"./type-annotation.js\";",
                        "import { isArrowFunctionVariableDeclarator } from \"./assignment.js\";",
                        "import { printTypeScriptMappedTypeModifier } from \"./mapped-type.js\";",
                        "",
                        "const getTypeParametersGroupId = createGroupIdMapper(\"typeParameters\");",
                        "",
                        "function printTypeParameters(path, options, print, paramsKey) {",
                        "  const { node } = path;",
                        "",
                        "  if (!node[paramsKey]) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  // for TypeParameterDeclaration typeParameters is a single node",
                        "  if (!Array.isArray(node[paramsKey])) {",
                        "    return print(paramsKey);",
                        "  }",
                        "",
                        "  const grandparent = path.getNode(2);",
                        "  const isParameterInTestCall = grandparent && isTestCall(grandparent);",
                        "",
                        "  const isArrowFunctionVariable = path.match(",
                        "    (node) =>",
                        "      !(node[paramsKey].length === 1 && isObjectType(node[paramsKey][0])),",
                        "    undefined,",
                        "    (node, name) => name === \"typeAnnotation\",",
                        "    (node) => node.type === \"Identifier\",",
                        "    isArrowFunctionVariableDeclarator",
                        "  );",
                        "",
                        "  const shouldInline =",
                        "    node[paramsKey].length === 0 ||",
                        "    (!isArrowFunctionVariable &&",
                        "      (isParameterInTestCall ||",
                        "        (node[paramsKey].length === 1 &&",
                        "          (node[paramsKey][0].type === \"NullableTypeAnnotation\" ||",
                        "            shouldHugType(node[paramsKey][0])))));",
                        "",
                        "  if (shouldInline) {",
                        "    return [",
                        "      \"<\",",
                        "      join(\", \", path.map(print, paramsKey)),",
                        "      printDanglingCommentsForInline(path, options),",
                        "      \">\",",
                        "    ];",
                        "  }",
                        "",
                        "  // Keep comma if the file extension is .tsx and",
                        "  // has one type parameter that isn't extend with any types.",
                        "  // Because, otherwise formatted result will be invalid as tsx.",
                        "  const trailingComma =",
                        "    node.type === \"TSTypeParameterInstantiation\" // https://github.com/microsoft/TypeScript/issues/21984",
                        "      ? \"\"",
                        "      : getFunctionParameters(node).length === 1 &&",
                        "        isTSXFile(options) &&",
                        "        !node[paramsKey][0].constraint &&",
                        "        path.parent.type === \"ArrowFunctionExpression\"",
                        "      ? \",\"",
                        "      : shouldPrintComma(options)",
                        "      ? ifBreak(\",\")",
                        "      : \"\";",
                        "",
                        "  return group(",
                        "    [",
                        "      \"<\",",
                        "      indent([softline, join([\",\", line], path.map(print, paramsKey))]),",
                        "      trailingComma,",
                        "      softline,",
                        "      \">\",",
                        "    ],",
                        "    { id: getTypeParametersGroupId(node) }",
                        "  );",
                        "}",
                        "",
                        "function printDanglingCommentsForInline(path, options) {",
                        "  const { node } = path;",
                        "  if (!hasComment(node, CommentCheckFlags.Dangling)) {",
                        "    return \"\";",
                        "  }",
                        "  const hasOnlyBlockComments = !hasComment(node, CommentCheckFlags.Line);",
                        "  const printed = printDanglingComments(path, options, {",
                        "    indent: !hasOnlyBlockComments,",
                        "  });",
                        "  if (hasOnlyBlockComments) {",
                        "    return printed;",
                        "  }",
                        "  return [printed, hardline];",
                        "}",
                        "",
                        "function printTypeParameter(path, options, print) {",
                        "  const { node, parent } = path;",
                        "",
                        "  /**",
                        "   * @type {import(\"../../document/builders.js\").Doc[]}",
                        "   */",
                        "  const parts = [node.type === \"TSTypeParameter\" && node.const ? \"const \" : \"\"];",
                        "",
                        "  const name = node.type === \"TSTypeParameter\" ? print(\"name\") : node.name;",
                        "",
                        "  if (parent.type === \"TSMappedType\") {",
                        "    if (parent.readonly) {",
                        "      parts.push(",
                        "        printTypeScriptMappedTypeModifier(parent.readonly, \"readonly\"),",
                        "        \" \"",
                        "      );",
                        "    }",
                        "    parts.push(\"[\", name);",
                        "    if (node.constraint) {",
                        "      parts.push(\" in \", print(\"constraint\"));",
                        "    }",
                        "    if (parent.nameType) {",
                        "      parts.push(",
                        "        \" as \",",
                        "        path.callParent(() => print(\"nameType\"))",
                        "      );",
                        "    }",
                        "    parts.push(\"]\");",
                        "    return parts;",
                        "  }",
                        "",
                        "  if (node.variance) {",
                        "    parts.push(print(\"variance\"));",
                        "  }",
                        "",
                        "  if (node.in) {",
                        "    parts.push(\"in \");",
                        "  }",
                        "",
                        "  if (node.out) {",
                        "    parts.push(\"out \");",
                        "  }",
                        "",
                        "  parts.push(name);",
                        "",
                        "  if (node.bound) {",
                        "    if (node.usesExtendsBound) {",
                        "      parts.push(\" extends \");",
                        "    }",
                        "",
                        "    parts.push(printTypeAnnotationProperty(path, print, \"bound\"));",
                        "  }",
                        "",
                        "  if (node.constraint) {",
                        "    parts.push(\" extends\", indent([line, print(\"constraint\")]));",
                        "  }",
                        "",
                        "  if (node.default) {",
                        "    parts.push(\" = \", print(\"default\"));",
                        "  }",
                        "",
                        "  return group(parts);",
                        "}",
                        "",
                        "export { printTypeParameter, printTypeParameters, getTypeParametersGroupId };"
                    ]
                },
                "typescript.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  join,",
                        "  softline,",
                        "  group,",
                        "  indent,",
                        "  conditionalGroup,",
                        "  ifBreak,",
                        "} from \"../../document/builders.js\";",
                        "import UnexpectedNodeError from \"../../utils/unexpected-node-error.js\";",
                        "import {",
                        "  isStringLiteral,",
                        "  shouldPrintComma,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "} from \"../utils/index.js\";",
                        "import isTsKeywordType from \"../utils/is-ts-keyword-type.js\";",
                        "import { locStart } from \"../loc.js\";",
                        "",
                        "import {",
                        "  printOptionalToken,",
                        "  printDeclareToken,",
                        "  printTypeScriptAccessibilityToken,",
                        "} from \"./misc.js\";",
                        "import { printTernary } from \"./ternary.js\";",
                        "import {",
                        "  printFunctionParameters,",
                        "  shouldGroupFunctionParameters,",
                        "} from \"./function-parameters.js\";",
                        "import { printTemplateLiteral } from \"./template-literal.js\";",
                        "import { printArray } from \"./array.js\";",
                        "import { printObject } from \"./object.js\";",
                        "import { printClassProperty, printClassMethod } from \"./class.js\";",
                        "import { printTypeParameter, printTypeParameters } from \"./type-parameters.js\";",
                        "import { printPropertyKey } from \"./property.js\";",
                        "import { printFunction, printMethodValue } from \"./function.js\";",
                        "import { printInterface } from \"./interface.js\";",
                        "import { printBlock } from \"./block.js\";",
                        "import {",
                        "  printTypeAlias,",
                        "  printIntersectionType,",
                        "  printUnionType,",
                        "  printFunctionType,",
                        "  printIndexedAccessType,",
                        "  printInferType,",
                        "  printJSDocType,",
                        "  printRestType,",
                        "  printNamedTupleMember,",
                        "  printTypeAnnotation,",
                        "  printTypeAnnotationProperty,",
                        "  printArrayType,",
                        "  printTypeQuery,",
                        "} from \"./type-annotation.js\";",
                        "import { printEnumDeclaration, printEnumMember } from \"./enum.js\";",
                        "import { printImportKind } from \"./module.js\";",
                        "import { printTypescriptMappedType } from \"./mapped-type.js\";",
                        "",
                        "function printTypescript(path, options, print) {",
                        "  const { node } = path;",
                        "",
                        "  // TypeScript nodes always starts with `TS`",
                        "  if (!node.type.startsWith(\"TS\")) {",
                        "    return;",
                        "  }",
                        "",
                        "  if (isTsKeywordType(node)) {",
                        "    // TS keyword types stars with `TS`, ends with `Keyword`",
                        "    return node.type.slice(2, -7).toLowerCase();",
                        "  }",
                        "",
                        "  const semi = options.semi ? \";\" : \"\";",
                        "  const parts = [];",
                        "",
                        "  switch (node.type) {",
                        "    case \"TSThisType\":",
                        "      return \"this\";",
                        "    case \"TSTypeAssertion\": {",
                        "      const shouldBreakAfterCast = !(",
                        "        isArrayOrTupleExpression(node.expression) ||",
                        "        isObjectOrRecordExpression(node.expression)",
                        "      );",
                        "",
                        "      const castGroup = group([",
                        "        \"<\",",
                        "        indent([softline, print(\"typeAnnotation\")]),",
                        "        softline,",
                        "        \">\",",
                        "      ]);",
                        "",
                        "      const exprContents = [",
                        "        ifBreak(\"(\"),",
                        "        indent([softline, print(\"expression\")]),",
                        "        softline,",
                        "        ifBreak(\")\"),",
                        "      ];",
                        "",
                        "      if (shouldBreakAfterCast) {",
                        "        return conditionalGroup([",
                        "          [castGroup, print(\"expression\")],",
                        "          [castGroup, group(exprContents, { shouldBreak: true })],",
                        "          [castGroup, print(\"expression\")],",
                        "        ]);",
                        "      }",
                        "      return group([castGroup, print(\"expression\")]);",
                        "    }",
                        "    case \"TSDeclareFunction\":",
                        "      return printFunction(path, print, options);",
                        "    case \"TSExportAssignment\":",
                        "      return [\"export = \", print(\"expression\"), semi];",
                        "    case \"TSModuleBlock\":",
                        "      return printBlock(path, options, print);",
                        "    case \"TSInterfaceBody\":",
                        "    case \"TSTypeLiteral\":",
                        "      return printObject(path, options, print);",
                        "    case \"TSTypeAliasDeclaration\":",
                        "      return printTypeAlias(path, options, print);",
                        "    case \"TSQualifiedName\":",
                        "      return [print(\"left\"), \".\", print(\"right\")];",
                        "    case \"TSAbstractMethodDefinition\":",
                        "    case \"TSDeclareMethod\":",
                        "      return printClassMethod(path, options, print);",
                        "    case \"TSAbstractAccessorProperty\":",
                        "    case \"TSAbstractPropertyDefinition\":",
                        "      return printClassProperty(path, options, print);",
                        "    case \"TSInterfaceHeritage\":",
                        "    case \"TSClassImplements\":",
                        "    case \"TSExpressionWithTypeArguments\": // Babel AST",
                        "    case \"TSInstantiationExpression\":",
                        "      return [print(\"expression\"), print(\"typeParameters\")];",
                        "    case \"TSTemplateLiteralType\":",
                        "      return printTemplateLiteral(path, print, options);",
                        "    case \"TSNamedTupleMember\":",
                        "      return printNamedTupleMember(path, options, print);",
                        "    case \"TSRestType\":",
                        "      return printRestType(path, options, print);",
                        "    case \"TSOptionalType\":",
                        "      return [print(\"typeAnnotation\"), \"?\"];",
                        "    case \"TSInterfaceDeclaration\":",
                        "      return printInterface(path, options, print);",
                        "    case \"TSTypeParameterDeclaration\":",
                        "    case \"TSTypeParameterInstantiation\":",
                        "      return printTypeParameters(path, options, print, \"params\");",
                        "    case \"TSTypeParameter\":",
                        "      return printTypeParameter(path, options, print);",
                        "    case \"TSAsExpression\":",
                        "    case \"TSSatisfiesExpression\": {",
                        "      const operator = node.type === \"TSAsExpression\" ? \"as\" : \"satisfies\";",
                        "      parts.push(print(\"expression\"), ` ${operator} `, print(\"typeAnnotation\"));",
                        "      const { parent } = path;",
                        "      if (",
                        "        (isCallExpression(parent) && parent.callee === node) ||",
                        "        (isMemberExpression(parent) && parent.object === node)",
                        "      ) {",
                        "        return group([indent([softline, ...parts]), softline]);",
                        "      }",
                        "      return parts;",
                        "    }",
                        "    case \"TSArrayType\":",
                        "      return printArrayType(print);",
                        "    case \"TSPropertySignature\":",
                        "      return [",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        printPropertyKey(path, options, print),",
                        "        printOptionalToken(path),",
                        "        printTypeAnnotationProperty(path, print),",
                        "      ];",
                        "",
                        "    case \"TSParameterProperty\":",
                        "      return [",
                        "        printTypeScriptAccessibilityToken(node),",
                        "        node.static ? \"static \" : \"\",",
                        "        node.override ? \"override \" : \"\",",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        print(\"parameter\"),",
                        "      ];",
                        "",
                        "    case \"TSTypeQuery\":",
                        "      return printTypeQuery(path, print);",
                        "    case \"TSIndexSignature\": {",
                        "      // The typescript parser accepts multiple parameters here. If you're",
                        "      // using them, it makes sense to have a trailing comma. But if you",
                        "      // aren't, this is more like a computed property name than an array.",
                        "      // So we leave off the trailing comma when there's just one parameter.",
                        "      const trailingComma =",
                        "        node.parameters.length > 1",
                        "          ? ifBreak(shouldPrintComma(options) ? \",\" : \"\")",
                        "          : \"\";",
                        "",
                        "      const parametersGroup = group([",
                        "        indent([",
                        "          softline,",
                        "          join([\", \", softline], path.map(print, \"parameters\")),",
                        "        ]),",
                        "        trailingComma,",
                        "        softline,",
                        "      ]);",
                        "",
                        "      const isClassMember =",
                        "        path.parent.type === \"ClassBody\" && path.key === \"body\";",
                        "",
                        "      return [",
                        "        // `static` only allowed in class member",
                        "        isClassMember && node.static ? \"static \" : \"\",",
                        "        node.readonly ? \"readonly \" : \"\",",
                        "        \"[\",",
                        "        node.parameters ? parametersGroup : \"\",",
                        "        \"]\",",
                        "        printTypeAnnotationProperty(path, print),",
                        "        isClassMember ? semi : \"\",",
                        "      ];",
                        "    }",
                        "    case \"TSTypePredicate\":",
                        "      return [",
                        "        node.asserts ? \"asserts \" : \"\",",
                        "        print(\"parameterName\"),",
                        "        node.typeAnnotation",
                        "          ? [\" is \", printTypeAnnotationProperty(path, print)]",
                        "          : \"\",",
                        "      ];",
                        "    case \"TSNonNullExpression\":",
                        "      return [print(\"expression\"), \"!\"];",
                        "    case \"TSImportType\":",
                        "      return [",
                        "        !node.isTypeOf ? \"\" : \"typeof \",",
                        "        \"import(\",",
                        "        print(node.parameter ? \"parameter\" : \"argument\"),",
                        "        \")\",",
                        "        !node.qualifier ? \"\" : [\".\", print(\"qualifier\")],",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"TSLiteralType\":",
                        "      return print(\"literal\");",
                        "    case \"TSIndexedAccessType\":",
                        "      return printIndexedAccessType(path, options, print);",
                        "",
                        "    case \"TSTypeOperator\":",
                        "      return [node.operator, \" \", print(\"typeAnnotation\")];",
                        "",
                        "    case \"TSMappedType\":",
                        "      return printTypescriptMappedType(path, options, print);",
                        "",
                        "    case \"TSMethodSignature\": {",
                        "      const kind = node.kind && node.kind !== \"method\" ? `${node.kind} ` : \"\";",
                        "      parts.push(",
                        "        printTypeScriptAccessibilityToken(node),",
                        "        kind,",
                        "        node.computed ? \"[\" : \"\",",
                        "        print(\"key\"),",
                        "        node.computed ? \"]\" : \"\",",
                        "        printOptionalToken(path)",
                        "      );",
                        "",
                        "      const parametersDoc = printFunctionParameters(",
                        "        path,",
                        "        print,",
                        "        options,",
                        "        /* expandArg */ false,",
                        "        /* printTypeParams */ true",
                        "      );",
                        "",
                        "      const returnTypePropertyName = node.returnType",
                        "        ? \"returnType\"",
                        "        : \"typeAnnotation\";",
                        "      const returnTypeNode = node[returnTypePropertyName];",
                        "      const returnTypeDoc = returnTypeNode",
                        "        ? printTypeAnnotationProperty(path, print, returnTypePropertyName)",
                        "        : \"\";",
                        "      const shouldGroupParameters = shouldGroupFunctionParameters(",
                        "        node,",
                        "        returnTypeDoc",
                        "      );",
                        "",
                        "      parts.push(shouldGroupParameters ? group(parametersDoc) : parametersDoc);",
                        "",
                        "      if (returnTypeNode) {",
                        "        parts.push(group(returnTypeDoc));",
                        "      }",
                        "",
                        "      return group(parts);",
                        "    }",
                        "    case \"TSNamespaceExportDeclaration\":",
                        "      return [\"export as namespace \", print(\"id\"), options.semi ? \";\" : \"\"];",
                        "    case \"TSEnumDeclaration\":",
                        "      return printEnumDeclaration(path, print, options);",
                        "",
                        "    case \"TSEnumMember\":",
                        "      return printEnumMember(path, print);",
                        "",
                        "    case \"TSImportEqualsDeclaration\":",
                        "      return [",
                        "        node.isExport ? \"export \" : \"\",",
                        "        \"import \",",
                        "        printImportKind(node, /* spaceBeforeKind */ false),",
                        "        print(\"id\"),",
                        "        \" = \",",
                        "        print(\"moduleReference\"),",
                        "        options.semi ? \";\" : \"\",",
                        "      ];",
                        "    case \"TSExternalModuleReference\":",
                        "      return [\"require(\", print(\"expression\"), \")\"];",
                        "    case \"TSModuleDeclaration\": {",
                        "      const { parent } = path;",
                        "      const parentIsDeclaration = parent.type === \"TSModuleDeclaration\";",
                        "      const bodyIsDeclaration = node.body?.type === \"TSModuleDeclaration\";",
                        "",
                        "      if (parentIsDeclaration) {",
                        "        parts.push(\".\");",
                        "      } else {",
                        "        parts.push(printDeclareToken(path));",
                        "",
                        "        // Global declaration looks like this:",
                        "        // (declare)? global { ... }",
                        "        const isGlobal =",
                        "          node.kind === \"global\" ||",
                        "          // TODO: Use `node.kind` when babel update AST",
                        "          // https://github.com/typescript-eslint/typescript-eslint/pull/6443",
                        "          node.global;",
                        "",
                        "        if (!isGlobal) {",
                        "          const kind =",
                        "            node.kind ??",
                        "            // TODO: Use `node.kind` when babel update AST",
                        "            (isStringLiteral(node.id) ||",
                        "            /(?:^|\\s)module(?:\\s|$)/.test(",
                        "              options.originalText.slice(locStart(node), locStart(node.id))",
                        "            )",
                        "              ? \"module\"",
                        "              : \"namespace\");",
                        "          parts.push(kind, \" \");",
                        "        }",
                        "      }",
                        "",
                        "      parts.push(print(\"id\"));",
                        "",
                        "      if (bodyIsDeclaration) {",
                        "        parts.push(print(\"body\"));",
                        "      } else if (node.body) {",
                        "        parts.push(\" \", group(print(\"body\")));",
                        "      } else {",
                        "        parts.push(semi);",
                        "      }",
                        "",
                        "      return parts;",
                        "    }",
                        "",
                        "    case \"TSConditionalType\":",
                        "      return printTernary(path, options, print);",
                        "",
                        "    case \"TSInferType\":",
                        "      return printInferType(path, options, print);",
                        "    case \"TSIntersectionType\":",
                        "      return printIntersectionType(path, options, print);",
                        "    case \"TSUnionType\":",
                        "      return printUnionType(path, options, print);",
                        "    case \"TSFunctionType\":",
                        "    case \"TSCallSignatureDeclaration\":",
                        "    case \"TSConstructorType\":",
                        "    case \"TSConstructSignatureDeclaration\":",
                        "      return printFunctionType(path, options, print);",
                        "    case \"TSTupleType\":",
                        "      return printArray(path, options, print);",
                        "    case \"TSTypeReference\":",
                        "      return [",
                        "        print(\"typeName\"),",
                        "        printTypeParameters(path, options, print, \"typeParameters\"),",
                        "      ];",
                        "    case \"TSTypeAnnotation\":",
                        "      return printTypeAnnotation(path, options, print);",
                        "    case \"TSEmptyBodyFunctionExpression\":",
                        "      return printMethodValue(path, options, print);",
                        "",
                        "    // These are not valid TypeScript. Printing them just for the sake of error recovery.",
                        "    case \"TSJSDocAllType\":",
                        "      return \"*\";",
                        "    case \"TSJSDocUnknownType\":",
                        "      return \"?\";",
                        "    case \"TSJSDocNullableType\":",
                        "      return printJSDocType(path, print, /* token */ \"?\");",
                        "    case \"TSJSDocNonNullableType\":",
                        "      return printJSDocType(path, print, /* token */ \"!\");",
                        "    case \"TSParenthesizedType\": // Removed in `../parse/postprocess.js`",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      throw new UnexpectedNodeError(node, \"TypeScript\");",
                        "  }",
                        "}",
                        "",
                        "export { printTypescript };"
                    ]
                }
            },
            "traverse": {
                "get-visitor-keys.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import createGetVisitorKeys from \"../../utils/create-get-visitor-keys.js\";",
                        "import visitorKeys from \"./visitor-keys.evaluate.js\";",
                        "",
                        "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                        "",
                        "export default getVisitorKeys;"
                    ]
                },
                "union-visitor-keys.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function unionVisitorKeys(all) {",
                        "  const result = {};",
                        "",
                        "  for (const [type, keys] of all.flatMap((keys) => Object.entries(keys))) {",
                        "    result[type] = [...new Set([...(result[type] ?? []), ...keys])];",
                        "  }",
                        "",
                        "  return result;",
                        "}",
                        "",
                        "export default unionVisitorKeys;"
                    ]
                },
                "visitor-keys.evaluate.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { VISITOR_KEYS as babelVisitorKeys } from \"@babel/types\";",
                        "import { visitorKeys as tsVisitorKeys } from \"@typescript-eslint/visitor-keys\";",
                        "import { VisitorKeys as flowVisitorKeys } from \"hermes-eslint\";",
                        "import unionVisitorKeys from \"./union-visitor-keys.js\";",
                        "",
                        "const angularVisitorKeys = {",
                        "  NGRoot: [\"node\"],",
                        "  NGPipeExpression: [\"left\", \"right\", \"arguments\"],",
                        "  NGChainedExpression: [\"expressions\"],",
                        "  NGEmptyExpression: [],",
                        "  NGMicrosyntax: [\"body\"],",
                        "  NGMicrosyntaxKey: [],",
                        "  NGMicrosyntaxExpression: [\"expression\", \"alias\"],",
                        "  NGMicrosyntaxKeyedExpression: [\"key\", \"expression\"],",
                        "  NGMicrosyntaxLet: [\"key\", \"value\"],",
                        "  NGMicrosyntaxAs: [\"key\", \"alias\"],",
                        "};",
                        "",
                        "const additionalVisitorKeys = {",
                        "  // Prettier",
                        "  JsExpressionRoot: [\"node\"],",
                        "  JsonRoot: [\"node\"],",
                        "",
                        "  // TypeScript",
                        "  TSJSDocAllType: [],",
                        "  TSJSDocUnknownType: [],",
                        "  TSJSDocNullableType: [\"typeAnnotation\"],",
                        "  TSJSDocNonNullableType: [\"typeAnnotation\"],",
                        "",
                        "  // Flow",
                        "  ClassProperty: [\"variance\"],",
                        "  ClassPrivateProperty: [\"variance\"],",
                        "  ConditionalTypeAnnotation: [",
                        "    \"checkType\",",
                        "    \"extendsType\",",
                        "    \"trueType\",",
                        "    \"falseType\",",
                        "  ],",
                        "  DeclareEnum: flowVisitorKeys.EnumDeclaration,",
                        "  InferTypeAnnotation: [\"typeParameter\"],",
                        "  KeyofTypeAnnotation: [\"argument\"],",
                        "  ObjectTypeMappedTypeProperty: [",
                        "    \"keyTparam\",",
                        "    \"propType\",",
                        "    \"sourceType\",",
                        "    \"variance\",",
                        "  ],",
                        "  QualifiedTypeofIdentifier: [\"id\", \"qualification\"],",
                        "  TupleTypeAnnotation: [\"elementTypes\"],",
                        "  TupleTypeSpreadElement: [\"label\", \"typeAnnotation\"],",
                        "  TupleTypeLabeledElement: [\"label\", \"elementType\", \"variance\"],",
                        "  NeverTypeAnnotation: [],",
                        "  UndefinedTypeAnnotation: [],",
                        "  UnknownTypeAnnotation: [],",
                        "};",
                        "",
                        "const excludeKeys = {",
                        "  // From `tsVisitorKeys`",
                        "  MethodDefinition: [\"typeParameters\"],",
                        "  TSPropertySignature: [\"initializer\"],",
                        "",
                        "  // From `flowVisitorKeys`",
                        "  ArrowFunctionExpression: [\"id\"],",
                        "  DeclareOpaqueType: [\"impltype\"],",
                        "  FunctionExpression: [\"predicate\"],",
                        "  // TODO: Remove `types` when babel changes AST of `TupleTypeAnnotation`",
                        "  // Flow parser changed `.types` to `.elementTypes` https://github.com/facebook/flow/commit/5b60e6a81dc277dfab2e88fa3737a4dc9aafdcab",
                        "  // TupleTypeAnnotation: [\"types\"],",
                        "  PropertyDefinition: [\"tsModifiers\"],",
                        "",
                        "  // From `babelVisitorKeys`",
                        "  DeclareInterface: [\"mixins\", \"implements\"],",
                        "  InterfaceDeclaration: [\"mixins\", \"implements\"],",
                        "};",
                        "",
                        "const visitorKeys = Object.fromEntries(",
                        "  Object.entries(",
                        "    unionVisitorKeys([",
                        "      babelVisitorKeys,",
                        "      tsVisitorKeys,",
                        "      flowVisitorKeys,",
                        "      angularVisitorKeys,",
                        "      additionalVisitorKeys,",
                        "    ])",
                        "  ).map(([type, keys]) => [",
                        "    type,",
                        "    excludeKeys[type]",
                        "      ? keys.filter((key) => !excludeKeys[type].includes(key))",
                        "      : keys,",
                        "  ])",
                        ");",
                        "",
                        "export default visitorKeys;"
                    ]
                }
            },
            "types": {
                "estree.d.ts": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as ESTree from \"estree\";",
                        "import * as Babel from \"@babel/types\";",
                        "import { TSESTree } from \"@typescript-eslint/typescript-estree\";",
                        "import { ESTree as Meriyah } from \"meriyah\";",
                        "import * as NGTree from \"angular-estree-parser/lib/types.js\";",
                        "",
                        "type AdditionalFields = {",
                        "  extra?: {",
                        "    parenthesized?: boolean;",
                        "    raw?: string;",
                        "  };",
                        "  comments?: Comment[];",
                        "  trailingComments?: ReadonlyArray<Comment> | Comment[];",
                        "  leadingComments?: ReadonlyArray<Comment> | Comment[];",
                        "};",
                        "",
                        "export type Comment = (",
                        "  | ESTree.Comment",
                        "  | Babel.Comment",
                        "  | TSESTree.Comment",
                        "  | Meriyah.Comment",
                        ") & {",
                        "  printed?: boolean;",
                        "  trailing?: boolean;",
                        "  leading?: boolean;",
                        "};",
                        "",
                        "export type Node = (ESTree.Node | Babel.Node | TSESTree.Node | NGTree.NGNode) &",
                        "  AdditionalFields;",
                        "",
                        "export type TemplateLiteral = (",
                        "  | ESTree.TemplateLiteral",
                        "  | Babel.TemplateLiteral",
                        "  | TSESTree.TemplateLiteral",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type CallExpression = (",
                        "  | ESTree.CallExpression",
                        "  | Babel.CallExpression",
                        "  | TSESTree.CallExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type OptionalCallExpression = Babel.OptionalCallExpression &",
                        "  AdditionalFields;",
                        "",
                        "export type MemberExpression = (",
                        "  | ESTree.MemberExpression",
                        "  | Babel.MemberExpression",
                        "  | TSESTree.MemberExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type OptionalMemberExpression = Babel.OptionalMemberExpression &",
                        "  AdditionalFields;",
                        "",
                        "export type Expression = (",
                        "  | ESTree.Expression",
                        "  | Babel.Expression",
                        "  | TSESTree.Expression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type BindExpression = Babel.BindExpression & AdditionalFields;",
                        "",
                        "export type Property = (ESTree.Property | Babel.Property | TSESTree.Property) &",
                        "  AdditionalFields;",
                        "",
                        "export type ClassPrivateProperty = Babel.ClassPrivateProperty &",
                        "  AdditionalFields;",
                        "",
                        "export type ObjectTypeProperty = Babel.ObjectTypeProperty & AdditionalFields;",
                        "",
                        "export type JSXElement = (Babel.JSXElement | TSESTree.JSXElement) &",
                        "  AdditionalFields;",
                        "",
                        "export type TaggedTemplateExpression = (",
                        "  | ESTree.TaggedTemplateExpression",
                        "  | Babel.TaggedTemplateExpression",
                        "  | TSESTree.TaggedTemplateExpression",
                        ") &",
                        "  AdditionalFields;",
                        "",
                        "export type Literal = (ESTree.Literal | Babel.Literal | TSESTree.Literal) &",
                        "  AdditionalFields;",
                        "",
                        "export { ESTree, Babel, TSESTree, NGTree };"
                    ]
                }
            },
            "utils": {
                "create-type-check-function.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function createTypeCheckFunction(types) {",
                        "  types = new Set(types);",
                        "  return (node) => types.has(node?.type);",
                        "}",
                        "",
                        "export default createTypeCheckFunction;"
                    ]
                },
                "get-shebang.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function getShebang(text) {",
                        "  if (!text.startsWith(\"#!\")) {",
                        "    return \"\";",
                        "  }",
                        "  const index = text.indexOf(\"\\n\");",
                        "  if (index === -1) {",
                        "    return text;",
                        "  }",
                        "  return text.slice(0, index);",
                        "}",
                        "",
                        "export default getShebang;"
                    ]
                },
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isEs5IdentifierName from \"@prettier/is-es5-identifier-name\";",
                        "import { hasDescendant } from \"../../utils/ast-utils.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import isNextLineEmptyAfterIndex from \"../../utils/is-next-line-empty.js\";",
                        "import getStringWidth from \"../../utils/get-string-width.js\";",
                        "import { locStart, locEnd, hasSameLocStart } from \"../loc.js\";",
                        "import getVisitorKeys from \"../traverse/get-visitor-keys.js\";",
                        "import createTypeCheckFunction from \"./create-type-check-function.js\";",
                        "import isBlockComment from \"./is-block-comment.js\";",
                        "import isNodeMatches from \"./is-node-matches.js\";",
                        "import isFlowKeywordType from \"./is-flow-keyword-type.js\";",
                        "import isTsKeywordType from \"./is-ts-keyword-type.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " * @typedef {import(\"../types/estree.js\").TemplateLiteral} TemplateLiteral",
                        " * @typedef {import(\"../types/estree.js\").Comment} Comment",
                        " * @typedef {import(\"../types/estree.js\").MemberExpression} MemberExpression",
                        " * @typedef {import(\"../types/estree.js\").OptionalMemberExpression} OptionalMemberExpression",
                        " * @typedef {import(\"../types/estree.js\").CallExpression} CallExpression",
                        " * @typedef {import(\"../types/estree.js\").OptionalCallExpression} OptionalCallExpression",
                        " * @typedef {import(\"../types/estree.js\").Expression} Expression",
                        " * @typedef {import(\"../types/estree.js\").Property} Property",
                        " * @typedef {import(\"../types/estree.js\").ObjectTypeProperty} ObjectTypeProperty",
                        " * @typedef {import(\"../types/estree.js\").TaggedTemplateExpression} TaggedTemplateExpression",
                        " * @typedef {import(\"../types/estree.js\").Literal} Literal",
                        " *",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " */",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {(Node) => boolean} predicate",
                        " * @returns {boolean}",
                        " */",
                        "function hasNode(node, predicate) {",
                        "  return predicate(node) || hasDescendant(node, { getVisitorKeys, predicate });",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasNakedLeftSide(node) {",
                        "  return (",
                        "    node.type === \"AssignmentExpression\" ||",
                        "    node.type === \"BinaryExpression\" ||",
                        "    node.type === \"LogicalExpression\" ||",
                        "    node.type === \"NGPipeExpression\" ||",
                        "    node.type === \"ConditionalExpression\" ||",
                        "    isCallExpression(node) ||",
                        "    isMemberExpression(node) ||",
                        "    node.type === \"SequenceExpression\" ||",
                        "    node.type === \"TaggedTemplateExpression\" ||",
                        "    node.type === \"BindExpression\" ||",
                        "    (node.type === \"UpdateExpression\" && !node.prefix) ||",
                        "    isTSTypeExpression(node) ||",
                        "    node.type === \"TSNonNullExpression\" ||",
                        "    node.type === \"ChainExpression\"",
                        "  );",
                        "}",
                        "",
                        "function getLeftSide(node) {",
                        "  if (node.expressions) {",
                        "    return node.expressions[0];",
                        "  }",
                        "  return (",
                        "    node.left ??",
                        "    node.test ??",
                        "    node.callee ??",
                        "    node.object ??",
                        "    node.tag ??",
                        "    node.argument ??",
                        "    node.expression",
                        "  );",
                        "}",
                        "",
                        "function getLeftSidePathName(node) {",
                        "  if (node.expressions) {",
                        "    return [\"expressions\", 0];",
                        "  }",
                        "  if (node.left) {",
                        "    return [\"left\"];",
                        "  }",
                        "  if (node.test) {",
                        "    return [\"test\"];",
                        "  }",
                        "  if (node.object) {",
                        "    return [\"object\"];",
                        "  }",
                        "  if (node.callee) {",
                        "    return [\"callee\"];",
                        "  }",
                        "  if (node.tag) {",
                        "    return [\"tag\"];",
                        "  }",
                        "  if (node.argument) {",
                        "    return [\"argument\"];",
                        "  }",
                        "  if (node.expression) {",
                        "    return [\"expression\"];",
                        "  }",
                        "  throw new Error(\"Unexpected node has no left side.\");",
                        "}",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "const isLineComment = createTypeCheckFunction([",
                        "  \"Line\",",
                        "  \"CommentLine\",",
                        "  // `meriyah` has `SingleLine`, `HashbangComment`, `HTMLOpen`, and `HTMLClose`",
                        "  \"SingleLine\",",
                        "  \"HashbangComment\",",
                        "  \"HTMLOpen\",",
                        "  \"HTMLClose\",",
                        "  // `espree`",
                        "  \"Hashbang\",",
                        "  // Babel hashbang",
                        "  \"InterpreterDirective\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isExportDeclaration = createTypeCheckFunction([",
                        "  \"ExportDefaultDeclaration\",",
                        "  \"DeclareExportDeclaration\",",
                        "  \"ExportNamedDeclaration\",",
                        "  \"ExportAllDeclaration\",",
                        "  \"DeclareExportAllDeclaration\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isArrayOrTupleExpression = createTypeCheckFunction([",
                        "  \"ArrayExpression\",",
                        "  \"TupleExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isObjectOrRecordExpression = createTypeCheckFunction([",
                        "  \"ObjectExpression\",",
                        "  \"RecordExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isNumericLiteral(node) {",
                        "  return (",
                        "    node.type === \"NumericLiteral\" ||",
                        "    (node.type === \"Literal\" && typeof node.value === \"number\")",
                        "  );",
                        "}",
                        "",
                        "function isSignedNumericLiteral(node) {",
                        "  return (",
                        "    node.type === \"UnaryExpression\" &&",
                        "    (node.operator === \"+\" || node.operator === \"-\") &&",
                        "    isNumericLiteral(node.argument)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isStringLiteral(node) {",
                        "  return (",
                        "    node.type === \"StringLiteral\" ||",
                        "    (node.type === \"Literal\" && typeof node.value === \"string\")",
                        "  );",
                        "}",
                        "",
                        "function isRegExpLiteral(node) {",
                        "  return (",
                        "    node.type === \"RegExpLiteral\" ||",
                        "    (node.type === \"Literal\" && Boolean(node.regex))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isObjectType = createTypeCheckFunction([",
                        "  \"ObjectTypeAnnotation\",",
                        "  \"TSTypeLiteral\",",
                        "  \"TSMappedType\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isFunctionOrArrowExpression = createTypeCheckFunction([",
                        "  \"FunctionExpression\",",
                        "  \"ArrowFunctionExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isFunctionOrArrowExpressionWithBody(node) {",
                        "  return (",
                        "    node.type === \"FunctionExpression\" ||",
                        "    (node.type === \"ArrowFunctionExpression\" &&",
                        "      node.body.type === \"BlockStatement\")",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * Note: `inject` is used in AngularJS 1.x, `async` and `fakeAsync` in",
                        " * Angular 2+, although `async` is deprecated and replaced by `waitForAsync`",
                        " * since Angular 12.",
                        " *",
                        " * example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-",
                        " *",
                        " * @param {CallExpression} node",
                        " * @returns {boolean}",
                        " */",
                        "function isAngularTestWrapper(node) {",
                        "  return (",
                        "    isCallExpression(node) &&",
                        "    node.callee.type === \"Identifier\" &&",
                        "    [\"async\", \"inject\", \"fakeAsync\", \"waitForAsync\"].includes(node.callee.name)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isJsxElement = createTypeCheckFunction([\"JSXElement\", \"JSXFragment\"]);",
                        "",
                        "function isGetterOrSetter(node) {",
                        "  return node.kind === \"get\" || node.kind === \"set\";",
                        "}",
                        "",
                        "// TODO: This is a bad hack and we need a better way to distinguish between",
                        "// arrow functions and otherwise",
                        "function isFunctionNotation(node) {",
                        "  return isGetterOrSetter(node) || hasSameLocStart(node, node.value);",
                        "}",
                        "",
                        "// Hack to differentiate between the following two which have the same ast",
                        "// type T = { method: () => void };",
                        "// type T = { method(): void };",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isObjectTypePropertyAFunction(node) {",
                        "  return (",
                        "    (node.type === \"ObjectTypeProperty\" ||",
                        "      node.type === \"ObjectTypeInternalSlot\") &&",
                        "    node.value.type === \"FunctionTypeAnnotation\" &&",
                        "    !node.static &&",
                        "    !isFunctionNotation(node)",
                        "  );",
                        "}",
                        "",
                        "// Hack to differentiate between the following two which have the same ast",
                        "// declare function f(a): void;",
                        "// var f: (a) => void;",
                        "function isTypeAnnotationAFunction(node) {",
                        "  return (",
                        "    (node.type === \"TypeAnnotation\" || node.type === \"TSTypeAnnotation\") &&",
                        "    node.typeAnnotation.type === \"FunctionTypeAnnotation\" &&",
                        "    !node.static &&",
                        "    !hasSameLocStart(node, node.typeAnnotation)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isBinaryish = createTypeCheckFunction([",
                        "  \"BinaryExpression\",",
                        "  \"LogicalExpression\",",
                        "  \"NGPipeExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isMemberish(node) {",
                        "  return (",
                        "    isMemberExpression(node) ||",
                        "    (node.type === \"BindExpression\" && Boolean(node.object))",
                        "  );",
                        "}",
                        "",
                        "const isSimpleTypeAnnotation = createTypeCheckFunction([",
                        "  \"TSThisType\",",
                        "  // literals",
                        "  \"NullLiteralTypeAnnotation\",",
                        "  \"BooleanLiteralTypeAnnotation\",",
                        "  \"StringLiteralTypeAnnotation\",",
                        "  \"BigIntLiteralTypeAnnotation\",",
                        "  \"NumberLiteralTypeAnnotation\",",
                        "  \"TSLiteralType\",",
                        "  \"TSTemplateLiteralType\",",
                        "]);",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleType(node) {",
                        "  return (",
                        "    isTsKeywordType(node) ||",
                        "    isFlowKeywordType(node) ||",
                        "    isSimpleTypeAnnotation(node) ||",
                        "    ((node.type === \"GenericTypeAnnotation\" ||",
                        "      node.type === \"TSTypeReference\") &&",
                        "      !node.typeParameters)",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {CallExpression} node",
                        " * @returns {boolean}",
                        " */",
                        "function isUnitTestSetUp(node) {",
                        "  const unitTestSetUpRe = /^(?:before|after)(?:Each|All)$/;",
                        "  return (",
                        "    node.callee.type === \"Identifier\" &&",
                        "    node.arguments.length === 1 &&",
                        "    unitTestSetUpRe.test(node.callee.name)",
                        "  );",
                        "}",
                        "",
                        "const testCallCalleePatterns = [",
                        "  \"it\",",
                        "  \"it.only\",",
                        "  \"it.skip\",",
                        "  \"describe\",",
                        "  \"describe.only\",",
                        "  \"describe.skip\",",
                        "  \"test\",",
                        "  \"test.only\",",
                        "  \"test.skip\",",
                        "  \"test.step\",",
                        "  \"test.describe\",",
                        "  \"test.describe.only\",",
                        "  \"test.describe.parallel\",",
                        "  \"test.describe.parallel.only\",",
                        "  \"test.describe.serial\",",
                        "  \"test.describe.serial.only\",",
                        "  \"skip\",",
                        "  \"xit\",",
                        "  \"xdescribe\",",
                        "  \"xtest\",",
                        "  \"fit\",",
                        "  \"fdescribe\",",
                        "  \"ftest\",",
                        "];",
                        "",
                        "function isTestCallCallee(node) {",
                        "  return isNodeMatches(node, testCallCalleePatterns);",
                        "}",
                        "",
                        "// eg; `describe(\"some string\", (done) => {})`",
                        "function isTestCall(node, parent) {",
                        "  if (node.type !== \"CallExpression\") {",
                        "    return false;",
                        "  }",
                        "  if (node.arguments.length === 1) {",
                        "    if (isAngularTestWrapper(node) && parent && isTestCall(parent)) {",
                        "      return isFunctionOrArrowExpression(node.arguments[0]);",
                        "    }",
                        "",
                        "    if (isUnitTestSetUp(node)) {",
                        "      return isAngularTestWrapper(node.arguments[0]);",
                        "    }",
                        "  } else if (",
                        "    (node.arguments.length === 2 || node.arguments.length === 3) &&",
                        "    (node.arguments[0].type === \"TemplateLiteral\" ||",
                        "      isStringLiteral(node.arguments[0])) &&",
                        "    isTestCallCallee(node.callee)",
                        "  ) {",
                        "    // it(\"name\", () => { ... }, 2500)",
                        "    if (node.arguments[2] && !isNumericLiteral(node.arguments[2])) {",
                        "      return false;",
                        "    }",
                        "    return (",
                        "      (node.arguments.length === 2",
                        "        ? isFunctionOrArrowExpression(node.arguments[1])",
                        "        : isFunctionOrArrowExpressionWithBody(node.arguments[1]) &&",
                        "          getFunctionParameters(node.arguments[1]).length <= 1) ||",
                        "      isAngularTestWrapper(node.arguments[1])",
                        "    );",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isCallExpression = createTypeCheckFunction([",
                        "  \"CallExpression\",",
                        "  \"OptionalCallExpression\",",
                        "]);",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isMemberExpression = createTypeCheckFunction([",
                        "  \"MemberExpression\",",
                        "  \"OptionalMemberExpression\",",
                        "]);",
                        "",
                        "/**",
                        " *",
                        " * @param {any} node",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleTemplateLiteral(node) {",
                        "  let expressionsKey = \"expressions\";",
                        "  if (node.type === \"TSTemplateLiteralType\") {",
                        "    expressionsKey = \"types\";",
                        "  }",
                        "  const expressions = node[expressionsKey];",
                        "",
                        "  if (expressions.length === 0) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return expressions.every((expr) => {",
                        "    // Disallow comments since printDocToString can't print them here",
                        "    if (hasComment(expr)) {",
                        "      return false;",
                        "    }",
                        "",
                        "    // Allow `x` and `this`",
                        "    if (expr.type === \"Identifier\" || expr.type === \"ThisExpression\") {",
                        "      return true;",
                        "    }",
                        "",
                        "    if (expr.type === \"ChainExpression\") {",
                        "      expr = expr.expression;",
                        "    }",
                        "",
                        "    // Allow `a.b.c`, `a.b[c]`, and `this.x.y`",
                        "    if (isMemberExpression(expr)) {",
                        "      let head = expr;",
                        "      while (isMemberExpression(head)) {",
                        "        if (",
                        "          head.property.type !== \"Identifier\" &&",
                        "          head.property.type !== \"Literal\" &&",
                        "          head.property.type !== \"StringLiteral\" &&",
                        "          head.property.type !== \"NumericLiteral\"",
                        "        ) {",
                        "          return false;",
                        "        }",
                        "        head = head.object;",
                        "        if (hasComment(head)) {",
                        "          return false;",
                        "        }",
                        "      }",
                        "",
                        "      if (head.type === \"Identifier\" || head.type === \"ThisExpression\") {",
                        "        return true;",
                        "      }",
                        "",
                        "      return false;",
                        "    }",
                        "",
                        "    return false;",
                        "  });",
                        "}",
                        "",
                        "/**",
                        " * @param {string} text",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function hasLeadingOwnLineComment(text, node) {",
                        "  if (isJsxElement(node)) {",
                        "    return hasNodeIgnoreComment(node);",
                        "  }",
                        "",
                        "  return hasComment(node, CommentCheckFlags.Leading, (comment) =>",
                        "    hasNewline(text, locEnd(comment))",
                        "  );",
                        "}",
                        "",
                        "// Note: Quoting/unquoting numbers in TypeScript is not safe.",
                        "//",
                        "// let a = { 1: 1, 2: 2 }",
                        "// let b = { '1': 1, '2': 2 }",
                        "//",
                        "// declare let aa: keyof typeof a;",
                        "// declare let bb: keyof typeof b;",
                        "//",
                        "// aa = bb;",
                        "// ^^",
                        "// Type '\"1\" | \"2\"' is not assignable to type '1 | 2'.",
                        "//   Type '\"1\"' is not assignable to type '1 | 2'.(2322)",
                        "//",
                        "// And in Flow, you get:",
                        "//",
                        "// const x = {",
                        "//   0: 1",
                        "//   ^ Non-string literal property keys not supported. [unsupported-syntax]",
                        "// }",
                        "//",
                        "// Angular does not support unquoted numbers in expressions.",
                        "//",
                        "// So we play it safe and only unquote numbers for the JavaScript parsers.",
                        "// (Vue supports unquoted numbers in expressions, but lets keep it simple.)",
                        "//",
                        "// Identifiers can be unquoted in more circumstances, though.",
                        "function isStringPropSafeToUnquote(node, options) {",
                        "  return (",
                        "    options.parser !== \"json\" &&",
                        "    isStringLiteral(node.key) &&",
                        "    rawText(node.key).slice(1, -1) === node.key.value &&",
                        "    ((isEs5IdentifierName(node.key.value) &&",
                        "      // With `--strictPropertyInitialization`, TS treats properties with quoted names differently than unquoted ones.",
                        "      // See https://github.com/microsoft/TypeScript/pull/20075",
                        "      !(",
                        "        (options.parser === \"babel-ts\" && node.type === \"ClassProperty\") ||",
                        "        (options.parser === \"typescript\" && node.type === \"PropertyDefinition\")",
                        "      )) ||",
                        "      (isSimpleNumber(node.key.value) &&",
                        "        String(Number(node.key.value)) === node.key.value &&",
                        "        (options.parser === \"babel\" ||",
                        "          options.parser === \"acorn\" ||",
                        "          options.parser === \"espree\" ||",
                        "          options.parser === \"meriyah\" ||",
                        "          options.parser === \"__babel_estree\")))",
                        "  );",
                        "}",
                        "",
                        "// Matches simple numbers like `123` and `2.5` but not `1_000`, `1e+100` or `0b10`.",
                        "function isSimpleNumber(numberString) {",
                        "  return /^(?:\\d+|\\d+\\.\\d+)$/.test(numberString);",
                        "}",
                        "",
                        "/**",
                        " * @param {TemplateLiteral} template",
                        " * @returns {boolean}",
                        " */",
                        "function templateLiteralHasNewLines(template) {",
                        "  return template.quasis.some((quasi) => quasi.value.raw.includes(\"\\n\"));",
                        "}",
                        "",
                        "/**",
                        " * @param {TemplateLiteral | TaggedTemplateExpression} node",
                        " * @param {string} text",
                        " * @returns {boolean}",
                        " */",
                        "function isTemplateOnItsOwnLine(node, text) {",
                        "  return (",
                        "    ((node.type === \"TemplateLiteral\" && templateLiteralHasNewLines(node)) ||",
                        "      (node.type === \"TaggedTemplateExpression\" &&",
                        "        templateLiteralHasNewLines(node.quasi))) &&",
                        "    !hasNewline(text, locStart(node), { backwards: true })",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "function needsHardlineAfterDanglingComment(node) {",
                        "  if (!hasComment(node)) {",
                        "    return false;",
                        "  }",
                        "  const lastDanglingComment = getComments(node, CommentCheckFlags.Dangling).at(",
                        "    -1",
                        "  );",
                        "  return lastDanglingComment && !isBlockComment(lastDanglingComment);",
                        "}",
                        "",
                        "// Logic to check for args with multiple anonymous functions. For instance,",
                        "// the following call should be split on multiple lines for readability:",
                        "// source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))",
                        "function isFunctionCompositionArgs(args) {",
                        "  if (args.length <= 1) {",
                        "    return false;",
                        "  }",
                        "  let count = 0;",
                        "  for (const arg of args) {",
                        "    if (isFunctionOrArrowExpression(arg)) {",
                        "      count += 1;",
                        "      if (count > 1) {",
                        "        return true;",
                        "      }",
                        "    } else if (isCallExpression(arg)) {",
                        "      for (const childArg of arg.arguments) {",
                        "        if (isFunctionOrArrowExpression(childArg)) {",
                        "          return true;",
                        "        }",
                        "      }",
                        "    }",
                        "  }",
                        "  return false;",
                        "}",
                        "",
                        "// Logic to determine if a call is a long curried function call.",
                        "// See https://github.com/prettier/prettier/issues/1420.",
                        "//",
                        "// `connect(a, b, c)(d)`",
                        "// In the above call expression, the second call is the parent node and the",
                        "// first call is the current node.",
                        "/**",
                        " * @param {AstPath} path",
                        " * @returns {boolean}",
                        " */",
                        "function isLongCurriedCallExpression(path) {",
                        "  const { node, parent, key } = path;",
                        "  return (",
                        "    key === \"callee\" &&",
                        "    isCallExpression(node) &&",
                        "    isCallExpression(parent) &&",
                        "    parent.arguments.length > 0 &&",
                        "    node.arguments.length > parent.arguments.length",
                        "  );",
                        "}",
                        "",
                        "const simpleCallArgumentUnaryOperators = new Set([\"!\", \"-\", \"+\", \"~\"]);",
                        "",
                        "/**",
                        " * @param {any} node",
                        " * @param {number} depth",
                        " * @returns {boolean}",
                        " */",
                        "function isSimpleCallArgument(node, depth = 2) {",
                        "  if (depth <= 0) {",
                        "    return false;",
                        "  }",
                        "",
                        "  const isChildSimple = (child) => isSimpleCallArgument(child, depth - 1);",
                        "",
                        "  if (isRegExpLiteral(node)) {",
                        "    return getStringWidth(node.pattern ?? node.regex.pattern) <= 5;",
                        "  }",
                        "",
                        "  if (",
                        "    node.type === \"Literal\" ||",
                        "    node.type === \"BigIntLiteral\" ||",
                        "    node.type === \"DecimalLiteral\" ||",
                        "    node.type === \"BooleanLiteral\" ||",
                        "    node.type === \"NullLiteral\" ||",
                        "    node.type === \"NumericLiteral\" ||",
                        "    node.type === \"StringLiteral\" ||",
                        "    node.type === \"Identifier\" ||",
                        "    node.type === \"ThisExpression\" ||",
                        "    node.type === \"Super\" ||",
                        "    node.type === \"PrivateName\" ||",
                        "    node.type === \"PrivateIdentifier\" ||",
                        "    node.type === \"ArgumentPlaceholder\" ||",
                        "    node.type === \"Import\"",
                        "  ) {",
                        "    return true;",
                        "  }",
                        "",
                        "  if (node.type === \"TemplateLiteral\") {",
                        "    return (",
                        "      node.quasis.every((element) => !element.value.raw.includes(\"\\n\")) &&",
                        "      node.expressions.every(isChildSimple)",
                        "    );",
                        "  }",
                        "",
                        "  if (isObjectOrRecordExpression(node)) {",
                        "    return node.properties.every(",
                        "      (p) => !p.computed && (p.shorthand || (p.value && isChildSimple(p.value)))",
                        "    );",
                        "  }",
                        "",
                        "  if (isArrayOrTupleExpression(node)) {",
                        "    return node.elements.every((x) => x === null || isChildSimple(x));",
                        "  }",
                        "",
                        "  if (isCallLikeExpression(node)) {",
                        "    if (",
                        "      node.type === \"ImportExpression\" ||",
                        "      isSimpleCallArgument(node.callee, depth)",
                        "    ) {",
                        "      const args = getCallArguments(node);",
                        "      return args.length <= depth && args.every(isChildSimple);",
                        "    }",
                        "    return false;",
                        "  }",
                        "",
                        "  if (isMemberExpression(node)) {",
                        "    return (",
                        "      isSimpleCallArgument(node.object, depth) &&",
                        "      isSimpleCallArgument(node.property, depth)",
                        "    );",
                        "  }",
                        "",
                        "  if (",
                        "    (node.type === \"UnaryExpression\" &&",
                        "      simpleCallArgumentUnaryOperators.has(node.operator)) ||",
                        "    node.type === \"UpdateExpression\"",
                        "  ) {",
                        "    return isSimpleCallArgument(node.argument, depth);",
                        "  }",
                        "",
                        "  if (node.type === \"TSNonNullExpression\") {",
                        "    return isSimpleCallArgument(node.expression, depth);",
                        "  }",
                        "",
                        "  return false;",
                        "}",
                        "",
                        "function rawText(node) {",
                        "  return node.extra?.raw ?? node.raw;",
                        "}",
                        "",
                        "function identity(x) {",
                        "  return x;",
                        "}",
                        "",
                        "function isTSXFile(options) {",
                        "  return options.filepath && /\\.tsx$/i.test(options.filepath);",
                        "}",
                        "",
                        "/**",
                        " * @param {any} options",
                        " * @param {(\"es5\" | \"all\")} [level]",
                        " * @returns {boolean}",
                        " */",
                        "function shouldPrintComma(options, level = \"es5\") {",
                        "  return (",
                        "    (options.trailingComma === \"es5\" && level === \"es5\") ||",
                        "    (options.trailingComma === \"all\" && (level === \"all\" || level === \"es5\"))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * Tests if the leftmost node of the expression matches the predicate. E.g.,",
                        " * used to check whether an expression statement needs to be wrapped in extra",
                        " * parentheses because it starts with:",
                        " *",
                        " * - `{`",
                        " * - `function`, `class`, or `do {}`",
                        " * - `let[`",
                        " *",
                        " * Will be overzealous if there already are necessary grouping parentheses.",
                        " *",
                        " * @param {Node} node",
                        " * @param {(leftmostNode: Node) => boolean} predicate",
                        " * @returns {boolean}",
                        " */",
                        "function startsWithNoLookaheadToken(node, predicate) {",
                        "  switch (node.type) {",
                        "    case \"BinaryExpression\":",
                        "    case \"LogicalExpression\":",
                        "    case \"AssignmentExpression\":",
                        "    case \"NGPipeExpression\":",
                        "      return startsWithNoLookaheadToken(node.left, predicate);",
                        "    case \"MemberExpression\":",
                        "    case \"OptionalMemberExpression\":",
                        "      return startsWithNoLookaheadToken(node.object, predicate);",
                        "    case \"TaggedTemplateExpression\":",
                        "      if (node.tag.type === \"FunctionExpression\") {",
                        "        // IIFEs are always already parenthesized",
                        "        return false;",
                        "      }",
                        "      return startsWithNoLookaheadToken(node.tag, predicate);",
                        "    case \"CallExpression\":",
                        "    case \"OptionalCallExpression\":",
                        "      if (node.callee.type === \"FunctionExpression\") {",
                        "        // IIFEs are always already parenthesized",
                        "        return false;",
                        "      }",
                        "      return startsWithNoLookaheadToken(node.callee, predicate);",
                        "    case \"ConditionalExpression\":",
                        "      return startsWithNoLookaheadToken(node.test, predicate);",
                        "    case \"UpdateExpression\":",
                        "      return (",
                        "        !node.prefix && startsWithNoLookaheadToken(node.argument, predicate)",
                        "      );",
                        "    case \"BindExpression\":",
                        "      return node.object && startsWithNoLookaheadToken(node.object, predicate);",
                        "    case \"SequenceExpression\":",
                        "      return startsWithNoLookaheadToken(node.expressions[0], predicate);",
                        "    case \"ChainExpression\":",
                        "    case \"TSSatisfiesExpression\":",
                        "    case \"TSAsExpression\":",
                        "    case \"TSNonNullExpression\":",
                        "      return startsWithNoLookaheadToken(node.expression, predicate);",
                        "    default:",
                        "      return predicate(node);",
                        "  }",
                        "}",
                        "",
                        "const equalityOperators = {",
                        "  \"==\": true,",
                        "  \"!=\": true,",
                        "  \"===\": true,",
                        "  \"!==\": true,",
                        "};",
                        "const multiplicativeOperators = {",
                        "  \"*\": true,",
                        "  \"/\": true,",
                        "  \"%\": true,",
                        "};",
                        "const bitshiftOperators = {",
                        "  \">>\": true,",
                        "  \">>>\": true,",
                        "  \"<<\": true,",
                        "};",
                        "",
                        "function shouldFlatten(parentOp, nodeOp) {",
                        "  if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // ** is right-associative",
                        "  // x ** y ** z --> x ** (y ** z)",
                        "  if (parentOp === \"**\") {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x == y == z --> (x == y) == z",
                        "  if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x * y % z --> (x * y) % z",
                        "  if (",
                        "    (nodeOp === \"%\" && multiplicativeOperators[parentOp]) ||",
                        "    (parentOp === \"%\" && multiplicativeOperators[nodeOp])",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x * y / z --> (x * y) / z",
                        "  // x / y * z --> (x / y) * z",
                        "  if (",
                        "    nodeOp !== parentOp &&",
                        "    multiplicativeOperators[nodeOp] &&",
                        "    multiplicativeOperators[parentOp]",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  // x << y << z --> (x << y) << z",
                        "  if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {",
                        "    return false;",
                        "  }",
                        "",
                        "  return true;",
                        "}",
                        "",
                        "const PRECEDENCE = new Map(",
                        "  [",
                        "    [\"|>\"],",
                        "    [\"??\"],",
                        "    [\"||\"],",
                        "    [\"&&\"],",
                        "    [\"|\"],",
                        "    [\"^\"],",
                        "    [\"&\"],",
                        "    [\"==\", \"===\", \"!=\", \"!==\"],",
                        "    [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],",
                        "    [\">>\", \"<<\", \">>>\"],",
                        "    [\"+\", \"-\"],",
                        "    [\"*\", \"/\", \"%\"],",
                        "    [\"**\"],",
                        "  ].flatMap((operators, index) =>",
                        "    operators.map((operator) => [operator, index])",
                        "  )",
                        ");",
                        "function getPrecedence(operator) {",
                        "  return PRECEDENCE.get(operator);",
                        "}",
                        "",
                        "function isBitwiseOperator(operator) {",
                        "  return (",
                        "    Boolean(bitshiftOperators[operator]) ||",
                        "    operator === \"|\" ||",
                        "    operator === \"^\" ||",
                        "    operator === \"&\"",
                        "  );",
                        "}",
                        "",
                        "function hasRestParameter(node) {",
                        "  if (node.rest) {",
                        "    return true;",
                        "  }",
                        "  const parameters = getFunctionParameters(node);",
                        "  return parameters.at(-1)?.type === \"RestElement\";",
                        "}",
                        "",
                        "const functionParametersCache = new WeakMap();",
                        "function getFunctionParameters(node) {",
                        "  if (functionParametersCache.has(node)) {",
                        "    return functionParametersCache.get(node);",
                        "  }",
                        "  const parameters = [];",
                        "  if (node.this) {",
                        "    parameters.push(node.this);",
                        "  }",
                        "  // `params` vs `parameters` - see https://github.com/babel/babel/issues/9231",
                        "  if (Array.isArray(node.parameters)) {",
                        "    parameters.push(...node.parameters);",
                        "  } else if (Array.isArray(node.params)) {",
                        "    parameters.push(...node.params);",
                        "  }",
                        "  if (node.rest) {",
                        "    parameters.push(node.rest);",
                        "  }",
                        "  functionParametersCache.set(node, parameters);",
                        "  return parameters;",
                        "}",
                        "",
                        "function iterateFunctionParametersPath(path, iteratee) {",
                        "  const { node } = path;",
                        "  let index = 0;",
                        "  const callback = (childPath) => iteratee(childPath, index++);",
                        "  if (node.this) {",
                        "    path.call(callback, \"this\");",
                        "  }",
                        "  if (Array.isArray(node.parameters)) {",
                        "    path.each(callback, \"parameters\");",
                        "  } else if (Array.isArray(node.params)) {",
                        "    path.each(callback, \"params\");",
                        "  }",
                        "  if (node.rest) {",
                        "    path.call(callback, \"rest\");",
                        "  }",
                        "}",
                        "",
                        "const callArgumentsCache = new WeakMap();",
                        "function getCallArguments(node) {",
                        "  if (callArgumentsCache.has(node)) {",
                        "    return callArgumentsCache.get(node);",
                        "  }",
                        "",
                        "  let args = node.arguments;",
                        "  if (node.type === \"ImportExpression\") {",
                        "    args = [node.source];",
                        "",
                        "    if (node.attributes) {",
                        "      args.push(node.attributes);",
                        "    }",
                        "  }",
                        "",
                        "  callArgumentsCache.set(node, args);",
                        "  return args;",
                        "}",
                        "",
                        "function iterateCallArgumentsPath(path, iteratee) {",
                        "  const { node } = path;",
                        "  if (node.type === \"ImportExpression\") {",
                        "    path.call((sourcePath) => iteratee(sourcePath, 0), \"source\");",
                        "",
                        "    if (node.attributes) {",
                        "      path.call((sourcePath) => iteratee(sourcePath, 1), \"attributes\");",
                        "    }",
                        "  } else {",
                        "    path.each(iteratee, \"arguments\");",
                        "  }",
                        "}",
                        "",
                        "function getCallArgumentSelector(node, index) {",
                        "  if (node.type === \"ImportExpression\") {",
                        "    if (index === 0 || index === (node.attributes ? -2 : -1)) {",
                        "      return \"source\";",
                        "    }",
                        "    if (node.attributes && (index === 1 || index === -1)) {",
                        "      return \"attributes\";",
                        "    }",
                        "    throw new RangeError(\"Invalid argument index\");",
                        "  }",
                        "  if (index < 0) {",
                        "    index = node.arguments.length + index;",
                        "  }",
                        "  /* c8 ignore next 3 */",
                        "  if (index < 0 || index >= node.arguments.length) {",
                        "    throw new RangeError(\"Invalid argument index\");",
                        "  }",
                        "  return [\"arguments\", index];",
                        "}",
                        "",
                        "function isPrettierIgnoreComment(comment) {",
                        "  return comment.value.trim() === \"prettier-ignore\" && !comment.unignore;",
                        "}",
                        "",
                        "function hasNodeIgnoreComment(node) {",
                        "  return (",
                        "    node?.prettierIgnore || hasComment(node, CommentCheckFlags.PrettierIgnore)",
                        "  );",
                        "}",
                        "",
                        "/** @enum {number} */",
                        "const CommentCheckFlags = {",
                        "  /** Check comment is a leading comment */",
                        "  Leading: 1 << 1,",
                        "  /** Check comment is a trailing comment */",
                        "  Trailing: 1 << 2,",
                        "  /** Check comment is a dangling comment */",
                        "  Dangling: 1 << 3,",
                        "  /** Check comment is a block comment */",
                        "  Block: 1 << 4,",
                        "  /** Check comment is a line comment */",
                        "  Line: 1 << 5,",
                        "  /** Check comment is a `prettier-ignore` comment */",
                        "  PrettierIgnore: 1 << 6,",
                        "  /** Check comment is the first attached comment */",
                        "  First: 1 << 7,",
                        "  /** Check comment is the last attached comment */",
                        "  Last: 1 << 8,",
                        "};",
                        "",
                        "const getCommentTestFunction = (flags, fn) => {",
                        "  if (typeof flags === \"function\") {",
                        "    fn = flags;",
                        "    flags = 0;",
                        "  }",
                        "  if (flags || fn) {",
                        "    return (comment, index, comments) =>",
                        "      !(",
                        "        (flags & CommentCheckFlags.Leading && !comment.leading) ||",
                        "        (flags & CommentCheckFlags.Trailing && !comment.trailing) ||",
                        "        (flags & CommentCheckFlags.Dangling &&",
                        "          (comment.leading || comment.trailing)) ||",
                        "        (flags & CommentCheckFlags.Block && !isBlockComment(comment)) ||",
                        "        (flags & CommentCheckFlags.Line && !isLineComment(comment)) ||",
                        "        (flags & CommentCheckFlags.First && index !== 0) ||",
                        "        (flags & CommentCheckFlags.Last && index !== comments.length - 1) ||",
                        "        (flags & CommentCheckFlags.PrettierIgnore &&",
                        "          !isPrettierIgnoreComment(comment)) ||",
                        "        (fn && !fn(comment))",
                        "      );",
                        "  }",
                        "};",
                        "/**",
                        " * @param {Node} node",
                        " * @param {number | function} [flags]",
                        " * @param {function} [fn]",
                        " * @returns {boolean}",
                        " */",
                        "function hasComment(node, flags, fn) {",
                        "  if (!isNonEmptyArray(node?.comments)) {",
                        "    return false;",
                        "  }",
                        "  const test = getCommentTestFunction(flags, fn);",
                        "  return test ? node.comments.some(test) : true;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @param {number | function} [flags]",
                        " * @param {function} [fn]",
                        " * @returns {Comment[]}",
                        " */",
                        "function getComments(node, flags, fn) {",
                        "  if (!Array.isArray(node?.comments)) {",
                        "    return [];",
                        "  }",
                        "  const test = getCommentTestFunction(flags, fn);",
                        "  return test ? node.comments.filter(test) : node.comments;",
                        "}",
                        "",
                        "/**",
                        " * @param {Node} node",
                        " * @returns {boolean}",
                        " */",
                        "const isNextLineEmpty = (node, { originalText }) =>",
                        "  isNextLineEmptyAfterIndex(originalText, locEnd(node));",
                        "",
                        "function isCallLikeExpression(node) {",
                        "  return (",
                        "    isCallExpression(node) ||",
                        "    node.type === \"NewExpression\" ||",
                        "    node.type === \"ImportExpression\"",
                        "  );",
                        "}",
                        "",
                        "function isObjectProperty(node) {",
                        "  return (",
                        "    node &&",
                        "    (node.type === \"ObjectProperty\" ||",
                        "      (node.type === \"Property\" && !node.method && node.kind === \"init\"))",
                        "  );",
                        "}",
                        "",
                        "/**",
                        " * This is used as a marker for dangling comments.",
                        " */",
                        "const markerForIfWithoutBlockAndSameLineComment = Symbol(",
                        "  \"ifWithoutBlockAndSameLineComment\"",
                        ");",
                        "",
                        "const isTSTypeExpression = createTypeCheckFunction([",
                        "  \"TSAsExpression\",",
                        "  \"TSSatisfiesExpression\",",
                        "]);",
                        "",
                        "export {",
                        "  getFunctionParameters,",
                        "  iterateFunctionParametersPath,",
                        "  getCallArguments,",
                        "  iterateCallArgumentsPath,",
                        "  getCallArgumentSelector,",
                        "  hasRestParameter,",
                        "  getLeftSide,",
                        "  getLeftSidePathName,",
                        "  hasLeadingOwnLineComment,",
                        "  hasNakedLeftSide,",
                        "  hasNode,",
                        "  hasNodeIgnoreComment,",
                        "  identity,",
                        "  isBinaryish,",
                        "  isCallLikeExpression,",
                        "  isLineComment,",
                        "  isPrettierIgnoreComment,",
                        "  isCallExpression,",
                        "  isMemberExpression,",
                        "  isExportDeclaration,",
                        "  isFunctionCompositionArgs,",
                        "  isFunctionNotation,",
                        "  isFunctionOrArrowExpression,",
                        "  isGetterOrSetter,",
                        "  isJsxElement,",
                        "  isLongCurriedCallExpression,",
                        "  isSimpleCallArgument,",
                        "  isMemberish,",
                        "  isNumericLiteral,",
                        "  isSignedNumericLiteral,",
                        "  isObjectProperty,",
                        "  isObjectType,",
                        "  isObjectTypePropertyAFunction,",
                        "  isRegExpLiteral,",
                        "  isSimpleType,",
                        "  isSimpleNumber,",
                        "  isSimpleTemplateLiteral,",
                        "  isStringLiteral,",
                        "  isStringPropSafeToUnquote,",
                        "  isTemplateOnItsOwnLine,",
                        "  isTestCall,",
                        "  isTSXFile,",
                        "  isTypeAnnotationAFunction,",
                        "  isNextLineEmpty,",
                        "  needsHardlineAfterDanglingComment,",
                        "  rawText,",
                        "  shouldPrintComma,",
                        "  isBitwiseOperator,",
                        "  shouldFlatten,",
                        "  startsWithNoLookaheadToken,",
                        "  getPrecedence,",
                        "  hasComment,",
                        "  getComments,",
                        "  CommentCheckFlags,",
                        "  markerForIfWithoutBlockAndSameLineComment,",
                        "  isTSTypeExpression,",
                        "  isArrayOrTupleExpression,",
                        "  isObjectOrRecordExpression,",
                        "  createTypeCheckFunction,",
                        "};"
                    ]
                },
                "is-block-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import createTypeCheckFunction from \"./create-type-check-function.js\";",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Comment} Comment",
                        " */",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "const isBlockComment = createTypeCheckFunction([",
                        "  \"Block\",",
                        "  \"CommentBlock\",",
                        "  // `meriyah`",
                        "  \"MultiLine\",",
                        "]);",
                        "",
                        "export default isBlockComment;"
                    ]
                },
                "is-flow-keyword-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import createTypeCheckFunction from \"./create-type-check-function.js\";",
                        "",
                        "const isFlowKeywordType = createTypeCheckFunction([",
                        "  \"AnyTypeAnnotation\",",
                        "  \"ThisTypeAnnotation\",",
                        "  \"NumberTypeAnnotation\",",
                        "  \"VoidTypeAnnotation\",",
                        "  \"BooleanTypeAnnotation\",",
                        "  \"BigIntTypeAnnotation\",",
                        "  \"SymbolTypeAnnotation\",",
                        "  \"StringTypeAnnotation\",",
                        "  \"NeverTypeAnnotation\",",
                        "  \"UndefinedTypeAnnotation\",",
                        "  \"UnknownTypeAnnotation\",",
                        "  // FLow only",
                        "  \"EmptyTypeAnnotation\",",
                        "  \"MixedTypeAnnotation\",",
                        "]);",
                        "",
                        "export default isFlowKeywordType;"
                    ]
                },
                "is-ignored.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { hasJsxIgnoreComment } from \"../print/jsx.js\";",
                        "import { hasNodeIgnoreComment } from \"../utils/index.js\";",
                        "",
                        "function isIgnored(path) {",
                        "  return hasNodeIgnoreComment(path.node) || hasJsxIgnoreComment(path);",
                        "}",
                        "",
                        "export default isIgnored;"
                    ]
                },
                "is-indentable-block-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isIndentableBlockComment(comment) {",
                        "  // If the comment has multiple lines and every line starts with a star",
                        "  // we can fix the indentation of each line. The stars in the `/*` and",
                        "  // `*/` delimiters are not included in the comment value, so add them",
                        "  // back first.",
                        "  const lines = `*${comment.value}*`.split(\"\\n\");",
                        "  return lines.length > 1 && lines.every((line) => line.trimStart()[0] === \"*\");",
                        "}",
                        "",
                        "export default isIndentableBlockComment;"
                    ]
                },
                "is-node-matches.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "// Copied from https://github.com/sindresorhus/eslint-plugin-unicorn/blob/d53d935951aa815c763fc9441aa452c763294715/rules/utils/is-node-matches.js",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Node} Node",
                        " */",
                        "",
                        "/**",
                        "Check if node matches object name or key path.",
                        "",
                        "@param {Node} node - The AST node to check.",
                        "@param {string} nameOrPath - The object name or key path.",
                        "@returns {boolean}",
                        "*/",
                        "function isNodeMatchesNameOrPath(node, nameOrPath) {",
                        "  const names = nameOrPath.split(\".\");",
                        "  for (let index = names.length - 1; index >= 0; index--) {",
                        "    const name = names[index];",
                        "",
                        "    if (index === 0) {",
                        "      return node.type === \"Identifier\" && node.name === name;",
                        "    }",
                        "",
                        "    if (",
                        "      node.type !== \"MemberExpression\" ||",
                        "      node.optional ||",
                        "      node.computed ||",
                        "      node.property.type !== \"Identifier\" ||",
                        "      node.property.name !== name",
                        "    ) {",
                        "      return false;",
                        "    }",
                        "",
                        "    node = node.object;",
                        "  }",
                        "}",
                        "",
                        "/**",
                        "Check if node matches any object name or key path.",
                        "",
                        "@param {Node} node - The AST node to check.",
                        "@param {string[]} nameOrPaths - The object name or key paths.",
                        "@returns {boolean}",
                        "*/",
                        "function isNodeMatches(node, nameOrPaths) {",
                        "  return nameOrPaths.some((nameOrPath) =>",
                        "    isNodeMatchesNameOrPath(node, nameOrPath)",
                        "  );",
                        "}",
                        "",
                        "export default isNodeMatches;"
                    ]
                },
                "is-ts-keyword-type.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/**",
                        " * @returns {boolean}",
                        " */",
                        "function isTsKeywordType({ type }) {",
                        "  return type.startsWith(\"TS\") && type.endsWith(\"Keyword\");",
                        "}",
                        "",
                        "export default isTsKeywordType;"
                    ]
                },
                "is-type-cast-comment.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import isBlockComment from \"./is-block-comment.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../types/estree.js\").Comment} Comment",
                        " */",
                        "",
                        "/**",
                        " * @param {Comment} comment",
                        " * @returns {boolean}",
                        " */",
                        "function isTypeCastComment(comment) {",
                        "  return (",
                        "    isBlockComment(comment) &&",
                        "    comment.value[0] === \"*\" &&",
                        "    // TypeScript expects the type to be enclosed in curly brackets, however",
                        "    // Closure Compiler accepts types in parens and even without any delimiters at all.",
                        "    // That's why we just search for \"@type\" and \"@satisfies\".",
                        "    /@(?:type|satisfies)\\b/.test(comment.value)",
                        "  );",
                        "}",
                        "",
                        "export default isTypeCastComment;"
                    ]
                }
            }
        },
        "language-json": {
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.JSON, () => ({",
                    "    name: \"JSON.stringify\",",
                    "    parsers: [\"json-stringify\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    extensions: [\".importmap\"], // .json file defaults to json instead of json-stringify",
                    "    filenames: [\"package.json\", \"package-lock.json\", \"composer.json\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.JSON, (data) => ({",
                    "    parsers: [\"json\"],",
                    "    vscodeLanguageIds: [\"json\"],",
                    "    extensions: data.extensions.filter((extension) => extension !== \".jsonl\"),",
                    "  })),",
                    "  createLanguage(linguistLanguages[\"JSON with Comments\"], (data) => ({",
                    "    parsers: [\"json\"],",
                    "    vscodeLanguageIds: [\"jsonc\"],",
                    "    filenames: [...data.filenames, \".eslintrc\", \".swcrc\"],",
                    "  })),",
                    "  createLanguage(linguistLanguages.JSON5, () => ({",
                    "    parsers: [\"json5\"],",
                    "    vscodeLanguageIds: [\"json5\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "parser-json.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { parseExpression } from \"@babel/parser\";",
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import createParser from \"../language-js/parse/utils/create-parser.js\";",
                    "import createBabelParseError from \"../language-js/parse/utils/create-babel-parse-error.js\";",
                    "import wrapBabelExpression from \"../language-js/parse/utils/wrap-babel-expression.js\";",
                    "",
                    "function createJsonParse(options = {}) {",
                    "  const { allowComments = true } = options;",
                    "",
                    "  return function parse(text) {",
                    "    let ast;",
                    "    try {",
                    "      ast = parseExpression(text, {",
                    "        tokens: true,",
                    "        ranges: true,",
                    "      });",
                    "    } catch (error) {",
                    "      if (",
                    "        error?.reasonCode === \"MissingPlugin\" ||",
                    "        error?.reasonCode === \"MissingOneOfPlugins\"",
                    "      ) {",
                    "        throw createBabelParseError({",
                    "          message: \"Unexpected token\",",
                    "          loc: error.loc,",
                    "        });",
                    "      }",
                    "",
                    "      throw createBabelParseError(error);",
                    "    }",
                    "",
                    "    // @ts-expect-error",
                    "    if (!allowComments && isNonEmptyArray(ast.comments)) {",
                    "      // @ts-expect-error",
                    "      throw createJsonError(ast.comments[0], \"Comment\");",
                    "    }",
                    "",
                    "    assertJsonNode(ast);",
                    "",
                    "    return wrapBabelExpression(ast, { type: \"JsonRoot\", text });",
                    "  };",
                    "}",
                    "",
                    "function createJsonError(node, description) {",
                    "  const [start, end] = [node.loc.start, node.loc.end].map(",
                    "    ({ line, column }) => ({",
                    "      line,",
                    "      column: column + 1,",
                    "    })",
                    "  );",
                    "  return createError(`${description} is not allowed in JSON.`, {",
                    "    loc: { start, end },",
                    "  });",
                    "}",
                    "",
                    "function assertJsonNode(node) {",
                    "  switch (node.type) {",
                    "    case \"ArrayExpression\":",
                    "      for (const element of node.elements) {",
                    "        if (element !== null) {",
                    "          assertJsonNode(element);",
                    "        }",
                    "      }",
                    "",
                    "      return;",
                    "    case \"ObjectExpression\":",
                    "      for (const property of node.properties) {",
                    "        assertJsonNode(property);",
                    "      }",
                    "",
                    "      return;",
                    "    case \"ObjectProperty\":",
                    "      if (node.computed) {",
                    "        throw createJsonError(node.key, \"Computed key\");",
                    "      }",
                    "",
                    "      if (node.shorthand) {",
                    "        throw createJsonError(node.key, \"Shorthand property\");",
                    "      }",
                    "",
                    "      if (node.key.type !== \"Identifier\") {",
                    "        assertJsonNode(node.key);",
                    "      }",
                    "",
                    "      assertJsonNode(node.value);",
                    "",
                    "      return;",
                    "    case \"UnaryExpression\": {",
                    "      const { operator, argument } = node;",
                    "      if (operator !== \"+\" && operator !== \"-\") {",
                    "        throw createJsonError(node, `Operator '${node.operator}'`);",
                    "      }",
                    "",
                    "      if (",
                    "        argument.type === \"NumericLiteral\" ||",
                    "        (argument.type === \"Identifier\" &&",
                    "          (argument.name === \"Infinity\" || argument.name === \"NaN\"))",
                    "      ) {",
                    "        return;",
                    "      }",
                    "",
                    "      throw createJsonError(",
                    "        argument,",
                    "        `Operator '${operator}' before '${argument.type}'`",
                    "      );",
                    "    }",
                    "    case \"Identifier\":",
                    "      if (",
                    "        // JSON5 https://spec.json5.org/#numbers",
                    "        node.name !== \"Infinity\" &&",
                    "        node.name !== \"NaN\" &&",
                    "        // JSON6 https://github.com/d3x0r/JSON6",
                    "        node.name !== \"undefined\"",
                    "      ) {",
                    "        throw createJsonError(node, `Identifier '${node.name}'`);",
                    "      }",
                    "",
                    "      return;",
                    "    case \"TemplateLiteral\":",
                    "      if (isNonEmptyArray(node.expressions)) {",
                    "        throw createJsonError(",
                    "          node.expressions[0],",
                    "          \"'TemplateLiteral' with expression\"",
                    "        );",
                    "      }",
                    "",
                    "      for (const element of node.quasis) {",
                    "        assertJsonNode(element);",
                    "      }",
                    "",
                    "      return;",
                    "    case \"NullLiteral\":",
                    "    case \"BooleanLiteral\":",
                    "    case \"NumericLiteral\":",
                    "    case \"StringLiteral\":",
                    "    case \"TemplateElement\":",
                    "      return;",
                    "    default:",
                    "      throw createJsonError(node, `'${node.type}'`);",
                    "  }",
                    "}",
                    "",
                    "const parseJson = createJsonParse();",
                    "",
                    "const jsonParsers = {",
                    "  json: createParser({",
                    "    parse: parseJson,",
                    "    hasPragma() {",
                    "      return true;",
                    "    },",
                    "  }),",
                    "  json5: createParser(parseJson),",
                    "  \"json-stringify\": createParser({",
                    "    parse: createJsonParse({ allowComments: false }),",
                    "    astFormat: \"estree-json\",",
                    "  }),",
                    "};",
                    "",
                    "export default jsonParsers;"
                ]
            },
            "printer-estree-json.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { hardline, indent, join } from \"../document/builders.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "  switch (node.type) {",
                    "    case \"JsonRoot\":",
                    "      return [print(\"node\"), hardline];",
                    "    case \"ArrayExpression\": {",
                    "      if (node.elements.length === 0) {",
                    "        return \"[]\";",
                    "      }",
                    "",
                    "      const printed = path.map(",
                    "        () => (path.node === null ? \"null\" : print()),",
                    "        \"elements\"",
                    "      );",
                    "",
                    "      return [",
                    "        \"[\",",
                    "        indent([hardline, join([\",\", hardline], printed)]),",
                    "        hardline,",
                    "        \"]\",",
                    "      ];",
                    "    }",
                    "    case \"ObjectExpression\":",
                    "      return node.properties.length === 0",
                    "        ? \"{}\"",
                    "        : [",
                    "            \"{\",",
                    "            indent([",
                    "              hardline,",
                    "              join([\",\", hardline], path.map(print, \"properties\")),",
                    "            ]),",
                    "            hardline,",
                    "            \"}\",",
                    "          ];",
                    "    case \"ObjectProperty\":",
                    "      return [print(\"key\"), \": \", print(\"value\")];",
                    "    case \"UnaryExpression\":",
                    "      return [node.operator === \"+\" ? \"\" : node.operator, print(\"argument\")];",
                    "    case \"NullLiteral\":",
                    "      return \"null\";",
                    "    case \"BooleanLiteral\":",
                    "      return node.value ? \"true\" : \"false\";",
                    "    case \"StringLiteral\":",
                    "      return JSON.stringify(node.value);",
                    "    case \"NumericLiteral\":",
                    "      return isObjectKey(path)",
                    "        ? JSON.stringify(String(node.value))",
                    "        : JSON.stringify(node.value);",
                    "    case \"Identifier\":",
                    "      return isObjectKey(path) ? JSON.stringify(node.name) : node.name;",
                    "    case \"TemplateLiteral\":",
                    "      // There is only one `TemplateElement`",
                    "      return print([\"quasis\", 0]);",
                    "    case \"TemplateElement\":",
                    "      return JSON.stringify(node.value.cooked);",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"JSON\");",
                    "  }",
                    "}",
                    "",
                    "function isObjectKey(path) {",
                    "  return path.key === \"key\" && path.parent.type === \"ObjectProperty\";",
                    "}",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"start\",",
                    "  \"end\",",
                    "  \"extra\",",
                    "  \"loc\",",
                    "  \"comments\",",
                    "  \"leadingComments\",",
                    "  \"trailingComments\",",
                    "  \"innerComments\",",
                    "  \"errors\",",
                    "  \"range\",",
                    "  \"tokens\",",
                    "]);",
                    "",
                    "function clean(node, newNode /*, parent*/) {",
                    "  const { type } = node;",
                    "  // We print quoted key",
                    "  if (type === \"ObjectProperty\") {",
                    "    const { key } = node;",
                    "    if (key.type === \"Identifier\") {",
                    "      newNode.key = { type: \"StringLiteral\", value: key.name };",
                    "    } else if (key.type === \"NumericLiteral\") {",
                    "      newNode.key = { type: \"StringLiteral\", value: String(key.value) };",
                    "    }",
                    "    return;",
                    "  }",
                    "  if (type === \"UnaryExpression\" && node.operator === \"+\") {",
                    "    return newNode.argument;",
                    "  }",
                    "  // We print holes in array as `null`",
                    "  if (type === \"ArrayExpression\") {",
                    "    for (const [index, element] of node.elements.entries()) {",
                    "      if (element === null) {",
                    "        newNode.elements.splice(index, 0, { type: \"NullLiteral\" });",
                    "      }",
                    "    }",
                    "    return;",
                    "  }",
                    "  // We print `TemplateLiteral` as string",
                    "  if (type === \"TemplateLiteral\") {",
                    "    return { type: \"StringLiteral\", value: node.quasis[0].value.cooked };",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "export { genericPrint as print, clean as massageAstNode };",
                    "export { default as getVisitorKeys } from \"./get-visitor-keys.js\";"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = {",
                    "  JsonRoot: [\"node\"],",
                    "  ArrayExpression: [\"elements\"],",
                    "  ObjectExpression: [\"properties\"],",
                    "  ObjectProperty: [\"key\", \"value\"],",
                    "  UnaryExpression: [\"argument\"],",
                    "  NullLiteral: [],",
                    "  BooleanLiteral: [],",
                    "  StringLiteral: [],",
                    "  NumericLiteral: [],",
                    "  Identifier: [],",
                    "  TemplateLiteral: [\"quasis\"],",
                    "  TemplateElement: [],",
                    "};",
                    "",
                    "export default visitorKeys;"
                ]
            }
        },
        "language-markdown": {
            "clean.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import collapseWhiteSpace from \"collapse-white-space\";",
                    "import isFrontMatter from \"../utils/front-matter/is-front-matter.js\";",
                    "import { startWithPragma } from \"./pragma.js\";",
                    "",
                    "const ignoredProperties = new Set([",
                    "  \"position\",",
                    "  \"raw\", // front-matter",
                    "]);",
                    "function clean(ast, newObj, parent) {",
                    "  // for codeblock",
                    "  if (",
                    "    ast.type === \"front-matter\" ||",
                    "    ast.type === \"code\" ||",
                    "    ast.type === \"yaml\" ||",
                    "    ast.type === \"import\" ||",
                    "    ast.type === \"export\" ||",
                    "    ast.type === \"jsx\"",
                    "  ) {",
                    "    delete newObj.value;",
                    "  }",
                    "",
                    "  if (ast.type === \"list\") {",
                    "    delete newObj.isAligned;",
                    "  }",
                    "",
                    "  if (ast.type === \"list\" || ast.type === \"listItem\") {",
                    "    delete newObj.spread;",
                    "  }",
                    "",
                    "  // texts can be splitted or merged",
                    "  if (ast.type === \"text\") {",
                    "    return null;",
                    "  }",
                    "",
                    "  if (ast.type === \"inlineCode\") {",
                    "    newObj.value = ast.value.replaceAll(\"\\n\", \" \");",
                    "  }",
                    "",
                    "  if (ast.type === \"wikiLink\") {",
                    "    newObj.value = ast.value.trim().replaceAll(/[\\t\\n]+/g, \" \");",
                    "  }",
                    "",
                    "  if (",
                    "    ast.type === \"definition\" ||",
                    "    ast.type === \"linkReference\" ||",
                    "    ast.type === \"imageReference\"",
                    "  ) {",
                    "    newObj.label = collapseWhiteSpace(ast.label);",
                    "  }",
                    "",
                    "  if (",
                    "    (ast.type === \"definition\" ||",
                    "      ast.type === \"link\" ||",
                    "      ast.type === \"image\") &&",
                    "    ast.title",
                    "  ) {",
                    "    newObj.title = ast.title.replaceAll(/\\\\(?=[\"')])/g, \"\");",
                    "  }",
                    "",
                    "  // for insert pragma",
                    "  if (",
                    "    parent?.type === \"root\" &&",
                    "    parent.children.length > 0 &&",
                    "    (parent.children[0] === ast ||",
                    "      (isFrontMatter(parent.children[0]) && parent.children[1] === ast)) &&",
                    "    ast.type === \"html\" &&",
                    "    startWithPragma(ast.value)",
                    "  ) {",
                    "    return null;",
                    "  }",
                    "}",
                    "",
                    "clean.ignoredProperties = ignoredProperties;",
                    "",
                    "export default clean;"
                ]
            },
            "constants.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import cjkRegex from \"cjk-regex\";",
                    "import regexpUtil from \"regexp-util\";",
                    "import unicodeRegex from \"unicode-regex\";",
                    "",
                    "const cjkPattern = `(?:${cjkRegex()",
                    "  .union(",
                    "    unicodeRegex({",
                    "      Script_Extensions: [\"Han\", \"Katakana\", \"Hiragana\", \"Hangul\", \"Bopomofo\"],",
                    "      General_Category: [",
                    "        \"Other_Letter\",",
                    "        \"Letter_Number\",",
                    "        \"Other_Symbol\",",
                    "        \"Modifier_Letter\",",
                    "        \"Modifier_Symbol\",",
                    "        \"Nonspacing_Mark\",",
                    "      ],",
                    "    })",
                    "  )",
                    "  .toString()})(?:${unicodeRegex({",
                    "  Block: [\"Variation_Selectors\", \"Variation_Selectors_Supplement\"],",
                    "}).toString()})?`;",
                    "",
                    "const kRegex = unicodeRegex({ Script: [\"Hangul\"] })",
                    "  .union(unicodeRegex({ Script_Extensions: [\"Hangul\"] }))",
                    "  .toRegExp();",
                    "",
                    "// http://spec.commonmark.org/0.25/#ascii-punctuation-character",
                    "const asciiPunctuationCharset =",
                    "  /* prettier-ignore */ regexpUtil.charset(",
                    "  \"!\", '\"', \"#\",  \"$\", \"%\", \"&\", \"'\", \"(\", \")\", \"*\",",
                    "  \"+\", \",\", \"-\",  \".\", \"/\", \":\", \";\", \"<\", \"=\", \">\",",
                    "  \"?\", \"@\", \"[\", \"\\\\\", \"]\", \"^\", \"_\", \"`\", \"{\", \"|\",",
                    "  \"}\", \"~\"",
                    ");",
                    "",
                    "// http://spec.commonmark.org/0.25/#punctuation-character",
                    "const punctuationCharset = unicodeRegex({",
                    "  // http://unicode.org/Public/5.1.0/ucd/UCD.html#General_Category_Values",
                    "  General_Category: [",
                    "    /* Pc */ \"Connector_Punctuation\",",
                    "    /* Pd */ \"Dash_Punctuation\",",
                    "    /* Pe */ \"Close_Punctuation\",",
                    "    /* Pf */ \"Final_Punctuation\",",
                    "    /* Pi */ \"Initial_Punctuation\",",
                    "    /* Po */ \"Other_Punctuation\",",
                    "    /* Ps */ \"Open_Punctuation\",",
                    "  ],",
                    "}).union(asciiPunctuationCharset);",
                    "",
                    "const punctuationPattern = punctuationCharset.toString();",
                    "",
                    "export { cjkPattern, kRegex, punctuationPattern };"
                ]
            },
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getMaxContinuousCount from \"../utils/get-max-continuous-count.js\";",
                    "import { hardline, markAsRoot } from \"../document/builders.js\";",
                    "import { replaceEndOfLine } from \"../document/utils.js\";",
                    "import printFrontMatter from \"../utils/front-matter/print.js\";",
                    "import inferParser from \"../utils/infer-parser.js\";",
                    "import { getFencedCodeBlockValue } from \"./utils.js\";",
                    "",
                    "function embed(path, options) {",
                    "  const { node } = path;",
                    "",
                    "  if (node.type === \"code\" && node.lang !== null) {",
                    "    const parser = inferParser(options, { language: node.lang });",
                    "    if (parser) {",
                    "      return async (textToDoc) => {",
                    "        const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "        const style = styleUnit.repeat(",
                    "          Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "        );",
                    "        const newOptions = { parser };",
                    "        if (node.lang === \"tsx\") {",
                    "          newOptions.filepath = \"dummy.tsx\";",
                    "        }",
                    "",
                    "        const doc = await textToDoc(",
                    "          getFencedCodeBlockValue(node, options.originalText),",
                    "          newOptions",
                    "        );",
                    "",
                    "        return markAsRoot([",
                    "          style,",
                    "          node.lang,",
                    "          node.meta ? \" \" + node.meta : \"\",",
                    "          hardline,",
                    "          replaceEndOfLine(doc),",
                    "          hardline,",
                    "          style,",
                    "        ]);",
                    "      };",
                    "    }",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return (textToDoc) => printFrontMatter(node, textToDoc);",
                    "",
                    "    // MDX",
                    "    case \"import\":",
                    "    case \"export\":",
                    "      return (textToDoc) => textToDoc(node.value, { parser: \"babel\" });",
                    "    case \"jsx\":",
                    "      return (textToDoc) =>",
                    "        textToDoc(`<$>${node.value}</$>`, {",
                    "          parser: \"__js_expression\",",
                    "          rootMarker: \"mdx\",",
                    "        });",
                    "  }",
                    "",
                    "  return null;",
                    "}",
                    "",
                    "export default embed;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-markdown.js\";",
                    "",
                    "export const printers = {",
                    "  mdast: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-markdown.js\"),",
                    "    parserNames: [\"remark\", \"markdown\", \"mdx\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.Markdown, (data) => ({",
                    "    parsers: [\"markdown\"],",
                    "    vscodeLanguageIds: [\"markdown\"],",
                    "    filenames: [...data.filenames, \"README\"],",
                    "    extensions: data.extensions.filter((extension) => extension !== \".mdx\"),",
                    "  })),",
                    "  createLanguage(linguistLanguages.Markdown, () => ({",
                    "    name: \"MDX\",",
                    "    parsers: [\"mdx\"],",
                    "    vscodeLanguageIds: [\"mdx\"],",
                    "    filenames: [],",
                    "    extensions: [\".mdx\"],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(node) {",
                    "  return node.position.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.position.end.offset;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "mdx.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * modified from https://github.com/mdx-js/mdx/blob/master/packages/mdx",
                    " *",
                    " * The MIT License (MIT)",
                    " *",
                    " * Copyright (c) 2017-2018 Compositor and Zeit, Inc.",
                    " *",
                    " * Permission is hereby granted, free of charge, to any person obtaining a copy",
                    " * of this software and associated documentation files (the \"Software\"), to deal",
                    " * in the Software without restriction, including without limitation the rights",
                    " * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
                    " * copies of the Software, and to permit persons to whom the Software is",
                    " * furnished to do so, subject to the following conditions:",
                    " * The above copyright notice and this permission notice shall be included in",
                    " * all copies or substantial portions of the Software.",
                    " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
                    " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
                    " * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
                    " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
                    " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
                    " * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN",
                    " * THE SOFTWARE.",
                    " */",
                    "",
                    "const IMPORT_REGEX = /^import\\s/;",
                    "const EXPORT_REGEX = /^export\\s/;",
                    "const BLOCKS_REGEX = \"[a-z][a-z0-9]*(\\\\.[a-z][a-z0-9]*)*|\";",
                    "const COMMENT_REGEX = /<!---->|<!---?[^>-](?:-?[^-])*-->/;",
                    "const ES_COMMENT_REGEX = /^{\\s*\\/\\*(.*)\\*\\/\\s*}/;",
                    "const EMPTY_NEWLINE = \"\\n\\n\";",
                    "",
                    "const isImport = (text) => IMPORT_REGEX.test(text);",
                    "const isExport = (text) => EXPORT_REGEX.test(text);",
                    "",
                    "const tokenizeEsSyntax = (eat, value) => {",
                    "  const index = value.indexOf(EMPTY_NEWLINE);",
                    "  const subvalue = value.slice(0, index);",
                    "",
                    "  if (isExport(subvalue) || isImport(subvalue)) {",
                    "    return eat(subvalue)({",
                    "      type: isExport(subvalue) ? \"export\" : \"import\",",
                    "      value: subvalue,",
                    "    });",
                    "  }",
                    "};",
                    "",
                    "const tokenizeEsComment = (eat, value) => {",
                    "  const match = ES_COMMENT_REGEX.exec(value);",
                    "",
                    "  if (match) {",
                    "    return eat(match[0])({",
                    "      type: \"esComment\",",
                    "      value: match[1].trim(),",
                    "    });",
                    "  }",
                    "};",
                    "",
                    "/* c8 ignore next 2 */",
                    "tokenizeEsSyntax.locator = (value /*, fromIndex*/) =>",
                    "  isExport(value) || isImport(value) ? -1 : 1;",
                    "",
                    "tokenizeEsComment.locator = (value, fromIndex) => value.indexOf(\"{\", fromIndex);",
                    "",
                    "function esSyntax() {",
                    "  const { Parser } = this;",
                    "  const { blockTokenizers, blockMethods, inlineTokenizers, inlineMethods } =",
                    "    Parser.prototype;",
                    "",
                    "  blockTokenizers.esSyntax = tokenizeEsSyntax;",
                    "  inlineTokenizers.esComment = tokenizeEsComment;",
                    "",
                    "  blockMethods.splice(blockMethods.indexOf(\"paragraph\"), 0, \"esSyntax\");",
                    "  inlineMethods.splice(inlineMethods.indexOf(\"text\"), 0, \"esComment\");",
                    "}",
                    "",
                    "export { esSyntax, BLOCKS_REGEX, COMMENT_REGEX };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  proseWrap: commonOptions.proseWrap,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import remarkParse from \"remark-parse\";",
                    "import unified from \"unified\";",
                    "import remarkMath from \"remark-math\";",
                    "import footnotes from \"remark-footnotes\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import { BLOCKS_REGEX, esSyntax } from \"./mdx.js\";",
                    "import htmlToJsx from \"./unified-plugins/html-to-jsx.js\";",
                    "import frontMatter from \"./unified-plugins/front-matter.js\";",
                    "import liquid from \"./unified-plugins/liquid.js\";",
                    "import wikiLink from \"./unified-plugins/wiki-link.js\";",
                    "",
                    "/**",
                    " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                    " *",
                    " * 1. restore unescaped character (Text)",
                    " * 2. merge continuous Texts",
                    " * 3. replace whitespaces in InlineCode#value with one whitespace",
                    " *    reference: http://spec.commonmark.org/0.25/#example-605",
                    " * 4. split Text into Sentence",
                    " *",
                    " * interface Word { value: string }",
                    " * interface Whitespace { value: string }",
                    " * interface Sentence { children: Array<Word | Whitespace> }",
                    " * interface InlineCode { children: Array<Sentence> }",
                    " */",
                    "function createParse({ isMDX }) {",
                    "  return (text) => {",
                    "    const processor = unified()",
                    "      .use(remarkParse, {",
                    "        commonmark: true,",
                    "        ...(isMDX && { blocks: [BLOCKS_REGEX] }),",
                    "      })",
                    "      .use(footnotes)",
                    "      .use(frontMatter)",
                    "      .use(remarkMath)",
                    "      .use(isMDX ? esSyntax : identity)",
                    "      .use(liquid)",
                    "      .use(isMDX ? htmlToJsx : identity)",
                    "      .use(wikiLink);",
                    "    return processor.run(processor.parse(text));",
                    "  };",
                    "}",
                    "",
                    "function identity(x) {",
                    "  return x;",
                    "}",
                    "",
                    "const baseParser = {",
                    "  astFormat: \"mdast\",",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};",
                    "",
                    "export const markdown = { ...baseParser, parse: createParse({ isMDX: false }) };",
                    "export const mdx = { ...baseParser, parse: createParse({ isMDX: true }) };",
                    "export { markdown as remark };"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import parseFrontMatter from \"../utils/front-matter/parse.js\";",
                    "",
                    "const pragmas = [\"format\", \"prettier\"];",
                    "",
                    "function startWithPragma(text) {",
                    "  const pragma = `@(${pragmas.join(\"|\")})`;",
                    "  const regex = new RegExp(",
                    "    [",
                    "      `<!--\\\\s*${pragma}\\\\s*-->`,",
                    "      `{\\\\s*\\\\/\\\\*\\\\s*${pragma}\\\\s*\\\\*\\\\/\\\\s*}`,",
                    "      `<!--.*\\r?\\n[\\\\s\\\\S]*(^|\\n)[^\\\\S\\n]*${pragma}[^\\\\S\\n]*($|\\n)[\\\\s\\\\S]*\\n.*-->`,",
                    "    ].join(\"|\"),",
                    "    \"m\"",
                    "  );",
                    "  const matched = text.match(regex);",
                    "  return matched?.index === 0;",
                    "}",
                    "",
                    "const hasPragma = (text) =>",
                    "  startWithPragma(parseFrontMatter(text).content.trimStart());",
                    "",
                    "const insertPragma = (text) => {",
                    "  const extracted = parseFrontMatter(text);",
                    "  const pragma = `<!-- @${pragmas[0]} -->`;",
                    "  return extracted.frontMatter",
                    "    ? `${extracted.frontMatter.raw}\\n\\n${pragma}\\n\\n${extracted.content}`",
                    "    : `${pragma}\\n\\n${extracted.content}`;",
                    "};",
                    "",
                    "export { startWithPragma, hasPragma, insertPragma };"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { getOrderedListItemInfo, mapAst, splitText } from \"./utils.js\";",
                    "",
                    "// 0x0 ~ 0x10ffff",
                    "const isSingleCharRegex = /^.$/su;",
                    "",
                    "function preprocess(ast, options) {",
                    "  ast = restoreUnescapedCharacter(ast, options);",
                    "  ast = mergeContinuousTexts(ast);",
                    "  ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);",
                    "  ast = markAlignedList(ast, options);",
                    "  ast = splitTextIntoSentences(ast);",
                    "  return ast;",
                    "}",
                    "",
                    "function restoreUnescapedCharacter(ast, options) {",
                    "  return mapAst(ast, (node) =>",
                    "    node.type !== \"text\" ||",
                    "    node.value === \"*\" ||",
                    "    node.value === \"_\" || // handle these cases in printer",
                    "    !isSingleCharRegex.test(node.value) ||",
                    "    node.position.end.offset - node.position.start.offset === node.value.length",
                    "      ? node",
                    "      : {",
                    "          ...node,",
                    "          value: options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          ),",
                    "        }",
                    "  );",
                    "}",
                    "",
                    "function mergeChildren(ast, shouldMerge, mergeNode) {",
                    "  return mapAst(ast, (node) => {",
                    "    if (!node.children) {",
                    "      return node;",
                    "    }",
                    "    const children = node.children.reduce((current, child) => {",
                    "      const lastChild = current.at(-1);",
                    "      if (lastChild && shouldMerge(lastChild, child)) {",
                    "        current.splice(-1, 1, mergeNode(lastChild, child));",
                    "      } else {",
                    "        current.push(child);",
                    "      }",
                    "      return current;",
                    "    }, []);",
                    "    return { ...node, children };",
                    "  });",
                    "}",
                    "",
                    "function mergeContinuousTexts(ast) {",
                    "  return mergeChildren(",
                    "    ast,",
                    "    (prevNode, node) => prevNode.type === \"text\" && node.type === \"text\",",
                    "    (prevNode, node) => ({",
                    "      type: \"text\",",
                    "      value: prevNode.value + node.value,",
                    "      position: {",
                    "        start: prevNode.position.start,",
                    "        end: node.position.end,",
                    "      },",
                    "    })",
                    "  );",
                    "}",
                    "",
                    "function splitTextIntoSentences(ast) {",
                    "  return mapAst(ast, (node, index, [parentNode]) => {",
                    "    if (node.type !== \"text\") {",
                    "      return node;",
                    "    }",
                    "",
                    "    let { value } = node;",
                    "",
                    "    if (parentNode.type === \"paragraph\") {",
                    "      if (index === 0) {",
                    "        value = value.trimStart();",
                    "      }",
                    "      if (index === parentNode.children.length - 1) {",
                    "        value = value.trimEnd();",
                    "      }",
                    "    }",
                    "",
                    "    return {",
                    "      type: \"sentence\",",
                    "      position: node.position,",
                    "      children: splitText(value),",
                    "    };",
                    "  });",
                    "}",
                    "",
                    "function transformIndentedCodeblockAndMarkItsParentList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"code\") {",
                    "      // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it",
                    "      const isIndented = /^\\n?(?: {4,}|\\t)/.test(",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        )",
                    "      );",
                    "",
                    "      node.isIndented = isIndented;",
                    "",
                    "      if (isIndented) {",
                    "        for (let i = 0; i < parentStack.length; i++) {",
                    "          const parent = parentStack[i];",
                    "",
                    "          // no need to check checked items",
                    "          if (parent.hasIndentedCodeblock) {",
                    "            break;",
                    "          }",
                    "",
                    "          if (parent.type === \"list\") {",
                    "            parent.hasIndentedCodeblock = true;",
                    "          }",
                    "        }",
                    "      }",
                    "    }",
                    "    return node;",
                    "  });",
                    "}",
                    "",
                    "function markAlignedList(ast, options) {",
                    "  return mapAst(ast, (node, index, parentStack) => {",
                    "    if (node.type === \"list\" && node.children.length > 0) {",
                    "      // if one of its parents is not aligned, it's not possible to be aligned in sub-lists",
                    "      for (let i = 0; i < parentStack.length; i++) {",
                    "        const parent = parentStack[i];",
                    "        if (parent.type === \"list\" && !parent.isAligned) {",
                    "          node.isAligned = false;",
                    "          return node;",
                    "        }",
                    "      }",
                    "",
                    "      node.isAligned = isAligned(node);",
                    "    }",
                    "",
                    "    return node;",
                    "  });",
                    "",
                    "  function getListItemStart(listItem) {",
                    "    return listItem.children.length === 0",
                    "      ? -1",
                    "      : listItem.children[0].position.start.column - 1;",
                    "  }",
                    "",
                    "  function isAligned(list) {",
                    "    if (!list.ordered) {",
                    "      /**",
                    "       * - 123",
                    "       * - 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const [firstItem, secondItem] = list.children;",
                    "",
                    "    const firstInfo = getOrderedListItemInfo(firstItem, options.originalText);",
                    "",
                    "    if (firstInfo.leadingSpaces.length > 1) {",
                    "      /**",
                    "       * 1.   123",
                    "       *",
                    "       * 1.   123",
                    "       * 1. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    const firstStart = getListItemStart(firstItem);",
                    "",
                    "    if (firstStart === -1) {",
                    "      /**",
                    "       * 1.",
                    "       *",
                    "       * 1.",
                    "       * 1.",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (list.children.length === 1) {",
                    "      /**",
                    "       * aligned:",
                    "       *",
                    "       * 11. 123",
                    "       *",
                    "       * not aligned:",
                    "       *",
                    "       * 1. 123",
                    "       */",
                    "      return firstStart % options.tabWidth === 0;",
                    "    }",
                    "",
                    "    const secondStart = getListItemStart(secondItem);",
                    "",
                    "    if (firstStart !== secondStart) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 1. 123",
                    "       *",
                    "       * 1. 123",
                    "       * 11. 123",
                    "       */",
                    "      return false;",
                    "    }",
                    "",
                    "    if (firstStart % options.tabWidth === 0) {",
                    "      /**",
                    "       * 11. 123",
                    "       * 12. 123",
                    "       */",
                    "      return true;",
                    "    }",
                    "",
                    "    /**",
                    "     * aligned:",
                    "     *",
                    "     * 11. 123",
                    "     * 1.  123",
                    "     *",
                    "     * not aligned:",
                    "     *",
                    "     * 1. 123",
                    "     * 2. 123",
                    "     */",
                    "    const secondInfo = getOrderedListItemInfo(secondItem, options.originalText);",
                    "    return secondInfo.leadingSpaces.length > 1;",
                    "  }",
                    "}",
                    "",
                    "export default preprocess;"
                ]
            },
            "print-whitespace.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { hardline, line, softline } from \"../document/builders.js\";",
                    "import {",
                    "  KIND_CJK_PUNCTUATION,",
                    "  KIND_CJ_LETTER,",
                    "  KIND_K_LETTER,",
                    "  KIND_NON_CJK,",
                    "} from \"./utils.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./utils.js\").WordNode} WordNode",
                    " * @typedef {import(\"./utils.js\").WhitespaceValue} WhitespaceValue",
                    " * @typedef {import(\"./utils.js\").WordKind} WordKind",
                    " * @typedef {import(\"../common/ast-path.js\").default} AstPath",
                    " * @typedef {\"always\" | \"never\" | \"preserve\"} ProseWrap",
                    " * @typedef {{ next?: WordNode | null, previous?: WordNode | null }}",
                    " * AdjacentNodes Nodes adjacent to a `whitespace` node. Are always of type",
                    " * `word`.",
                    " */",
                    "",
                    "const SINGLE_LINE_NODE_TYPES = new Set([",
                    "  \"heading\",",
                    "  \"tableCell\",",
                    "  \"link\",",
                    "  \"wikiLink\",",
                    "]);",
                    "",
                    "/**",
                    " * These characters must not immediately precede a line break.",
                    " *",
                    " * e.g. `\"\"`:",
                    " *",
                    " * - Bad:  `\"\\n\"`",
                    " * - Good: `\"\\n\"` or",
                    " *         `\"\\n\"`",
                    " */",
                    "const noBreakAfter = new Set(",
                    "  \"$('\\\"[{\"",
                    ");",
                    "",
                    "/**",
                    " * These characters must not immediately follow a line break.",
                    " *",
                    " * e.g. `\"\"`:",
                    " *",
                    " * - Bad:  `\"\\n\"`",
                    " * - Good: `\"\\n\"` or",
                    " *         `\"\\n\"`",
                    " */",
                    "const noBreakBefore = new Set(",
                    "  \"!%),.:;?]}'\\\"\"",
                    ");",
                    "",
                    "/**",
                    " * A line break between a character from this set and CJ can be converted to a",
                    " * space. Includes only ASCII punctuation marks for now.",
                    " */",
                    "const lineBreakBetweenTheseAndCJConvertsToSpace = new Set(",
                    "  \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"",
                    ");",
                    "",
                    "/**",
                    " * Determine the preferred style of spacing between Chinese or Japanese and non-CJK",
                    " * characters in the parent `sentence` node.",
                    " *",
                    " * @param {AstPath} path",
                    " * @returns {boolean} `true` if Space tends to be inserted between CJ and",
                    " * non-CJK, `false` otherwise.",
                    " */",
                    "function isInSentenceWithCJSpaces({ parent: sentenceNode }) {",
                    "  if (sentenceNode.usesCJSpaces === undefined) {",
                    "    const stats = { \" \": 0, \"\": 0 };",
                    "    const { children } = sentenceNode;",
                    "",
                    "    for (let i = 1; i < children.length - 1; ++i) {",
                    "      const node = children[i];",
                    "      if (",
                    "        node.type === \"whitespace\" &&",
                    "        (node.value === \" \" || node.value === \"\")",
                    "      ) {",
                    "        const previousKind = children[i - 1].kind;",
                    "        const nextKind = children[i + 1].kind;",
                    "        if (",
                    "          (previousKind === KIND_CJ_LETTER && nextKind === KIND_NON_CJK) ||",
                    "          (previousKind === KIND_NON_CJK && nextKind === KIND_CJ_LETTER)",
                    "        ) {",
                    "          ++stats[node.value];",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    // Inject a property to cache the result.",
                    "    sentenceNode.usesCJSpaces = stats[\" \"] > stats[\"\"];",
                    "  }",
                    "",
                    "  return sentenceNode.usesCJSpaces;",
                    "}",
                    "",
                    "/**",
                    " * Check whether the given `\"\\n\"` node can be converted to a space.",
                    " *",
                    " * For example, if you would like to squash English text",
                    " *",
                    " *     \"You might want\\nto use Prettier.\"",
                    " *",
                    " * into a single line, you would replace `\"\\n\"` with `\" \"`:",
                    " *",
                    " *     \"You might want to use Prettier.\"",
                    " *",
                    " * However, Chinese and Japanese don't use U+0020 Space to divide words, so line",
                    " * breaks shouldn't be replaced with spaces for those languages.",
                    " *",
                    " * PRs are welcome to support line breaking rules for other languages.",
                    " *",
                    " * @param {AstPath} path",
                    " * @param {boolean} isLink",
                    " * @returns {boolean}",
                    " */",
                    "function lineBreakCanBeConvertedToSpace(path, isLink) {",
                    "  if (isLink) {",
                    "    return true;",
                    "  }",
                    "",
                    "  /** @type {AdjacentNodes} */",
                    "  const { previous, next } = path;",
                    "",
                    "  // e.g. \" \\nletter\"",
                    "  if (!previous || !next) {",
                    "    return true;",
                    "  }",
                    "",
                    "  const previousKind = previous.kind;",
                    "  const nextKind = next.kind;",
                    "",
                    "  if (",
                    "    // \"\\n\" between non-CJK or Korean characters always can be converted to a",
                    "    // space. Korean Hangul simulates Latin words. See",
                    "    // https://github.com/prettier/prettier/issues/6516",
                    "    (isNonCJKOrKoreanLetter(previousKind) &&",
                    "      isNonCJKOrKoreanLetter(nextKind)) ||",
                    "    // Han & Hangul: same way preferred",
                    "    (previousKind === KIND_K_LETTER && nextKind === KIND_CJ_LETTER) ||",
                    "    (nextKind === KIND_K_LETTER && previousKind === KIND_CJ_LETTER)",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Do not convert \\n to a space:",
                    "  if (",
                    "    // around CJK punctuation",
                    "    previousKind === KIND_CJK_PUNCTUATION ||",
                    "    nextKind === KIND_CJK_PUNCTUATION ||",
                    "    // between CJ",
                    "    (previousKind === KIND_CJ_LETTER && nextKind === KIND_CJ_LETTER)",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // The rest of this function deals only with line breaks between CJ and",
                    "  // non-CJK characters.",
                    "",
                    "  // Convert a line break between CJ and certain non-letter characters (e.g.",
                    "  // ASCII punctuation) to a space.",
                    "  //",
                    "  // E.g. :::\\n\\n:::  :::  :::",
                    "  //",
                    "  // Note: line breaks like \"(\\n\\n)\" or \"\\n.\" are suppressed in",
                    "  // `isBreakable(...)`.",
                    "  if (",
                    "    lineBreakBetweenTheseAndCJConvertsToSpace.has(next.value[0]) ||",
                    "    lineBreakBetweenTheseAndCJConvertsToSpace.has(previous.value.at(-1))",
                    "  ) {",
                    "    return true;",
                    "  }",
                    "",
                    "  // Converting a line break between CJ and non-ASCII punctuation to a space is",
                    "  // undesired in many cases. PRs are welcome to fine-tune this logic.",
                    "  //",
                    "  // Examples where \\n must not be converted to a space:",
                    "  //",
                    "  // 1. \"\" (U+301C, belongs to Pd) in",
                    "  //",
                    "  //     \"\\n1\"",
                    "  //",
                    "  // 2. \"\" (U+2026, belongs to Po) in",
                    "  //",
                    "  //     \"\\n\"",
                    "  if (previous.hasTrailingPunctuation || next.hasLeadingPunctuation) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // If the sentence uses the style with spaces between CJ and non-CJK, \"\\n\" can",
                    "  // be converted to a space.",
                    "  return isInSentenceWithCJSpaces(path);",
                    "}",
                    "",
                    "/**",
                    " * @param {WordKind | undefined} kind",
                    " * @returns {boolean} `true` if `kind` is defined and not CJK punctuation",
                    " */",
                    "function isLetter(kind) {",
                    "  return (",
                    "    kind === KIND_NON_CJK || kind === KIND_CJ_LETTER || kind === KIND_K_LETTER",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {WordKind | undefined} kind",
                    " * @returns {boolean} `true` if `kind` is Korean letter or non-CJK",
                    " */",
                    "function isNonCJKOrKoreanLetter(kind) {",
                    "  return kind === KIND_NON_CJK || kind === KIND_K_LETTER;",
                    "}",
                    "",
                    "/**",
                    " * Check whether whitespace can be printed as a line break.",
                    " *",
                    " * @param {AstPath} path",
                    " * @param {WhitespaceValue} value",
                    " * @param {ProseWrap} proseWrap",
                    " * @param {boolean} isLink",
                    " * @param {boolean} canBeSpace",
                    " * @returns {boolean}",
                    " */",
                    "function isBreakable(path, value, proseWrap, isLink, canBeSpace) {",
                    "  if (",
                    "    proseWrap !== \"always\" ||",
                    "    path.hasAncestor((node) => SINGLE_LINE_NODE_TYPES.has(node.type))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (isLink) {",
                    "    return value !== \"\";",
                    "  }",
                    "",
                    "  // Spaces are always breakable",
                    "  if (value === \" \") {",
                    "    return true;",
                    "  }",
                    "",
                    "  /** @type {AdjacentNodes} */",
                    "  const { previous, next } = path;",
                    "",
                    "  // Simulates Latin words; see https://github.com/prettier/prettier/issues/6516",
                    "  // [Latin][\"\"][Hangul] & vice versa => Don't break",
                    "  // [Han & Kana][\"\"][Hangul], either",
                    "  if (",
                    "    value === \"\" &&",
                    "    ((previous?.kind === KIND_K_LETTER && isLetter(next?.kind)) ||",
                    "      (next?.kind === KIND_K_LETTER && isLetter(previous?.kind)))",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  // https://en.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages",
                    "  const violatesCJKLineBreakingRules =",
                    "    !canBeSpace &&",
                    "    ((next && noBreakBefore.has(next.value[0])) ||",
                    "      (previous && noBreakAfter.has(previous.value.at(-1))));",
                    "",
                    "  if (violatesCJKLineBreakingRules) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "/**",
                    " * @param {AstPath} path",
                    " * @param {WhitespaceValue} value",
                    " * @param {ProseWrap} proseWrap",
                    " * @param {boolean} [isLink] Special mode of (un)wrapping that preserves the",
                    " * normalized form of link labels. https://spec.commonmark.org/0.30/#matches",
                    " */",
                    "function printWhitespace(path, value, proseWrap, isLink) {",
                    "  if (proseWrap === \"preserve\" && value === \"\\n\") {",
                    "    return hardline;",
                    "  }",
                    "",
                    "  const canBeSpace =",
                    "    value === \" \" ||",
                    "    (value === \"\\n\" && lineBreakCanBeConvertedToSpace(path, isLink));",
                    "",
                    "  if (isBreakable(path, value, proseWrap, isLink, canBeSpace)) {",
                    "    return canBeSpace ? line : softline;",
                    "  }",
                    "",
                    "  return canBeSpace ? \" \" : \"\";",
                    "}",
                    "",
                    "export { printWhitespace };"
                ]
            },
            "printer-markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import collapseWhiteSpace from \"collapse-white-space\";",
                    "import getMinNotPresentContinuousCount from \"../utils/get-min-not-present-continuous-count.js\";",
                    "import getMaxContinuousCount from \"../utils/get-max-continuous-count.js\";",
                    "import getStringWidth from \"../utils/get-string-width.js\";",
                    "import getPreferredQuote from \"../utils/get-preferred-quote.js\";",
                    "import {",
                    "  breakParent,",
                    "  join,",
                    "  line,",
                    "  literalline,",
                    "  markAsRoot,",
                    "  hardline,",
                    "  softline,",
                    "  ifBreak,",
                    "  fill,",
                    "  align,",
                    "  indent,",
                    "  group,",
                    "  hardlineWithoutBreakParent,",
                    "} from \"../document/builders.js\";",
                    "import { normalizeDoc, replaceEndOfLine } from \"../document/utils.js\";",
                    "import { printDocToString } from \"../document/printer.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import embed from \"./embed.js\";",
                    "import { insertPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import preprocess from \"./print-preprocess.js\";",
                    "import clean from \"./clean.js\";",
                    "import {",
                    "  getFencedCodeBlockValue,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "  isAutolink,",
                    "} from \"./utils.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "import { printWhitespace } from \"./print-whitespace.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"../document/builders.js\").Doc} Doc",
                    " */",
                    "",
                    "const SIBLING_NODE_TYPES = new Set([",
                    "  \"listItem\",",
                    "  \"definition\",",
                    "  \"footnoteDefinition\",",
                    "]);",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  if (shouldRemainTheSameContent(path)) {",
                    "    return splitText(",
                    "      options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      )",
                    "    ).map((node) =>",
                    "      node.type === \"word\"",
                    "        ? node.value",
                    "        : printWhitespace(path, node.value, options.proseWrap, true)",
                    "    );",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"front-matter\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"root\":",
                    "      /* c8 ignore next 3 */",
                    "      if (node.children.length === 0) {",
                    "        return \"\";",
                    "      }",
                    "      return [normalizeDoc(printRoot(path, options, print)), hardline];",
                    "    case \"paragraph\":",
                    "      return printChildren(path, options, print, {",
                    "        postprocessor: fill,",
                    "      });",
                    "    case \"sentence\":",
                    "      return printChildren(path, options, print);",
                    "    case \"word\": {",
                    "      let escapedValue = node.value",
                    "        .replaceAll(\"*\", \"\\\\*\") // escape all `*`",
                    "        .replaceAll(",
                    "          new RegExp(",
                    "            [",
                    "              `(^|${punctuationPattern})(_+)`,",
                    "              `(_+)(${punctuationPattern}|$)`,",
                    "            ].join(\"|\"),",
                    "            \"g\"",
                    "          ),",
                    "          (_, text1, underscore1, underscore2, text2) =>",
                    "            (underscore1",
                    "              ? `${text1}${underscore1}`",
                    "              : `${underscore2}${text2}`",
                    "            ).replaceAll(\"_\", \"\\\\_\")",
                    "        ); // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis",
                    "",
                    "      const isFirstSentence = (node, name, index) =>",
                    "        node.type === \"sentence\" && index === 0;",
                    "      const isLastChildAutolink = (node, name, index) =>",
                    "        isAutolink(node.children[index - 1]);",
                    "",
                    "      if (",
                    "        escapedValue !== node.value &&",
                    "        (path.match(undefined, isFirstSentence, isLastChildAutolink) ||",
                    "          path.match(",
                    "            undefined,",
                    "            isFirstSentence,",
                    "            (node, name, index) => node.type === \"emphasis\" && index === 0,",
                    "            isLastChildAutolink",
                    "          ))",
                    "      ) {",
                    "        // backslash is parsed as part of autolinks, so we need to remove it",
                    "        escapedValue = escapedValue.replace(/^(\\\\?[*_])+/, (prefix) =>",
                    "          prefix.replaceAll(\"\\\\\", \"\")",
                    "        );",
                    "      }",
                    "",
                    "      return escapedValue;",
                    "    }",
                    "    case \"whitespace\": {",
                    "      const { next } = path;",
                    "",
                    "      const proseWrap =",
                    "        // leading char that may cause different syntax",
                    "        next && /^>|^(?:[*+-]|#{1,6}|\\d+[).])$/.test(next.value)",
                    "          ? \"never\"",
                    "          : options.proseWrap;",
                    "",
                    "      return printWhitespace(path, node.value, proseWrap);",
                    "    }",
                    "    case \"emphasis\": {",
                    "      let style;",
                    "      if (isAutolink(node.children[0])) {",
                    "        style = options.originalText[node.position.start.offset];",
                    "      } else {",
                    "        const { previous, next } = path;",
                    "        const hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not",
                    "          (previous?.type === \"sentence\" &&",
                    "            previous.children.at(-1)?.type === \"word\" &&",
                    "            !previous.children.at(-1).hasTrailingPunctuation) ||",
                    "          (next?.type === \"sentence\" &&",
                    "            next.children[0]?.type === \"word\" &&",
                    "            !next.children[0].hasLeadingPunctuation);",
                    "        style =",
                    "          hasPrevOrNextWord ||",
                    "          path.hasAncestor((node) => node.type === \"emphasis\")",
                    "            ? \"*\"",
                    "            : \"_\";",
                    "      }",
                    "      return [style, printChildren(path, options, print), style];",
                    "    }",
                    "    case \"strong\":",
                    "      return [\"**\", printChildren(path, options, print), \"**\"];",
                    "    case \"delete\":",
                    "      return [\"~~\", printChildren(path, options, print), \"~~\"];",
                    "    case \"inlineCode\": {",
                    "      const code =",
                    "        options.proseWrap === \"preserve\"",
                    "          ? node.value",
                    "          : node.value.replaceAll(\"\\n\", \" \");",
                    "      const backtickCount = getMinNotPresentContinuousCount(code, \"`\");",
                    "      const backtickString = \"`\".repeat(backtickCount || 1);",
                    "      const padding =",
                    "        code.startsWith(\"`\") ||",
                    "        code.endsWith(\"`\") ||",
                    "        (/^[\\n ]/.test(code) && /[\\n ]$/.test(code) && /[^\\n ]/.test(code))",
                    "          ? \" \"",
                    "          : \"\";",
                    "      return [backtickString, padding, code, padding, backtickString];",
                    "    }",
                    "    case \"wikiLink\": {",
                    "      let contents = \"\";",
                    "      if (options.proseWrap === \"preserve\") {",
                    "        contents = node.value;",
                    "      } else {",
                    "        contents = node.value.replaceAll(/[\\t\\n]+/g, \" \");",
                    "      }",
                    "",
                    "      return [\"[[\", contents, \"]]\"];",
                    "    }",
                    "    case \"link\":",
                    "      switch (options.originalText[node.position.start.offset]) {",
                    "        case \"<\": {",
                    "          const mailto = \"mailto:\";",
                    "          const url =",
                    "            // <hello@example.com> is parsed as { url: \"mailto:hello@example.com\" }",
                    "            node.url.startsWith(mailto) &&",
                    "            options.originalText.slice(",
                    "              node.position.start.offset + 1,",
                    "              node.position.start.offset + 1 + mailto.length",
                    "            ) !== mailto",
                    "              ? node.url.slice(mailto.length)",
                    "              : node.url;",
                    "          return [\"<\", url, \">\"];",
                    "        }",
                    "        case \"[\":",
                    "          return [",
                    "            \"[\",",
                    "            printChildren(path, options, print),",
                    "            \"](\",",
                    "            printUrl(node.url, \")\"),",
                    "            printTitle(node.title, options),",
                    "            \")\",",
                    "          ];",
                    "        default:",
                    "          return options.originalText.slice(",
                    "            node.position.start.offset,",
                    "            node.position.end.offset",
                    "          );",
                    "      }",
                    "    case \"image\":",
                    "      return [",
                    "        \"![\",",
                    "        node.alt || \"\",",
                    "        \"](\",",
                    "        printUrl(node.url, \")\"),",
                    "        printTitle(node.title, options),",
                    "        \")\",",
                    "      ];",
                    "    case \"blockquote\":",
                    "      return [\"> \", align(\"> \", printChildren(path, options, print))];",
                    "    case \"heading\":",
                    "      return [",
                    "        \"#\".repeat(node.depth) + \" \",",
                    "        printChildren(path, options, print),",
                    "      ];",
                    "    case \"code\": {",
                    "      if (node.isIndented) {",
                    "        // indented code block",
                    "        const alignment = \" \".repeat(4);",
                    "        return align(alignment, [",
                    "          alignment,",
                    "          replaceEndOfLine(node.value, hardline),",
                    "        ]);",
                    "      }",
                    "",
                    "      // fenced code block",
                    "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                    "      const style = styleUnit.repeat(",
                    "        Math.max(3, getMaxContinuousCount(node.value, styleUnit) + 1)",
                    "      );",
                    "      return [",
                    "        style,",
                    "        node.lang || \"\",",
                    "        node.meta ? \" \" + node.meta : \"\",",
                    "        hardline,",
                    "        replaceEndOfLine(",
                    "          getFencedCodeBlockValue(node, options.originalText),",
                    "          hardline",
                    "        ),",
                    "        hardline,",
                    "        style,",
                    "      ];",
                    "    }",
                    "    case \"html\": {",
                    "      const { parent, isLast } = path;",
                    "      const value =",
                    "        parent.type === \"root\" && isLast ? node.value.trimEnd() : node.value;",
                    "      const isHtmlComment = /^<!--.*-->$/s.test(value);",
                    "",
                    "      return replaceEndOfLine(",
                    "        value,",
                    "        // @ts-expect-error",
                    "        isHtmlComment ? hardline : markAsRoot(literalline)",
                    "      );",
                    "    }",
                    "    case \"list\": {",
                    "      const nthSiblingIndex = getNthListSiblingIndex(node, path.parent);",
                    "",
                    "      const isGitDiffFriendlyOrderedList = hasGitDiffFriendlyOrderedList(",
                    "        node,",
                    "        options",
                    "      );",
                    "",
                    "      return printChildren(path, options, print, {",
                    "        processor(childPath) {",
                    "          const prefix = getPrefix();",
                    "          const childNode = childPath.node;",
                    "",
                    "          if (",
                    "            childNode.children.length === 2 &&",
                    "            childNode.children[1].type === \"html\" &&",
                    "            childNode.children[0].position.start.column !==",
                    "              childNode.children[1].position.start.column",
                    "          ) {",
                    "            return [prefix, printListItem(childPath, options, print, prefix)];",
                    "          }",
                    "",
                    "          return [",
                    "            prefix,",
                    "            align(",
                    "              \" \".repeat(prefix.length),",
                    "              printListItem(childPath, options, print, prefix)",
                    "            ),",
                    "          ];",
                    "",
                    "          function getPrefix() {",
                    "            const rawPrefix = node.ordered",
                    "              ? (childPath.isFirst",
                    "                  ? node.start",
                    "                  : isGitDiffFriendlyOrderedList",
                    "                  ? 1",
                    "                  : node.start + childPath.index) +",
                    "                (nthSiblingIndex % 2 === 0 ? \". \" : \") \")",
                    "              : nthSiblingIndex % 2 === 0",
                    "              ? \"- \"",
                    "              : \"* \";",
                    "",
                    "            return node.isAligned ||",
                    "              /* workaround for https://github.com/remarkjs/remark/issues/315 */ node.hasIndentedCodeblock",
                    "              ? alignListPrefix(rawPrefix, options)",
                    "              : rawPrefix;",
                    "          }",
                    "        },",
                    "      });",
                    "    }",
                    "    case \"thematicBreak\": {",
                    "      const { ancestors } = path;",
                    "      const counter = ancestors.findIndex((node) => node.type === \"list\");",
                    "      if (counter === -1) {",
                    "        return \"---\";",
                    "      }",
                    "      const nthSiblingIndex = getNthListSiblingIndex(",
                    "        ancestors[counter],",
                    "        ancestors[counter + 1]",
                    "      );",
                    "      return nthSiblingIndex % 2 === 0 ? \"***\" : \"---\";",
                    "    }",
                    "    case \"linkReference\":",
                    "      return [",
                    "        \"[\",",
                    "        printChildren(path, options, print),",
                    "        \"]\",",
                    "        node.referenceType === \"full\"",
                    "          ? printLinkReference(node)",
                    "          : node.referenceType === \"collapsed\"",
                    "          ? \"[]\"",
                    "          : \"\",",
                    "      ];",
                    "    case \"imageReference\":",
                    "      switch (node.referenceType) {",
                    "        case \"full\":",
                    "          return [\"![\", node.alt || \"\", \"]\", printLinkReference(node)];",
                    "        default:",
                    "          return [",
                    "            \"![\",",
                    "            node.alt,",
                    "            \"]\",",
                    "            node.referenceType === \"collapsed\" ? \"[]\" : \"\",",
                    "          ];",
                    "      }",
                    "    case \"definition\": {",
                    "      const lineOrSpace = options.proseWrap === \"always\" ? line : \" \";",
                    "      return group([",
                    "        printLinkReference(node),",
                    "        \":\",",
                    "        indent([",
                    "          lineOrSpace,",
                    "          printUrl(node.url),",
                    "          node.title === null",
                    "            ? \"\"",
                    "            : [lineOrSpace, printTitle(node.title, options, false)],",
                    "        ]),",
                    "      ]);",
                    "    }",
                    "    // `footnote` requires `.use(footnotes, {inlineNotes: true})`, we are not using this option",
                    "    // https://github.com/remarkjs/remark-footnotes#optionsinlinenotes",
                    "    /* c8 ignore next 2 */",
                    "    case \"footnote\":",
                    "      return [\"[^\", printChildren(path, options, print), \"]\"];",
                    "    case \"footnoteReference\":",
                    "      return printFootnoteReference(node);",
                    "    case \"footnoteDefinition\": {",
                    "      const shouldInlineFootnote =",
                    "        node.children.length === 1 &&",
                    "        node.children[0].type === \"paragraph\" &&",
                    "        (options.proseWrap === \"never\" ||",
                    "          (options.proseWrap === \"preserve\" &&",
                    "            node.children[0].position.start.line ===",
                    "              node.children[0].position.end.line));",
                    "      return [",
                    "        printFootnoteReference(node),",
                    "        \": \",",
                    "        shouldInlineFootnote",
                    "          ? printChildren(path, options, print)",
                    "          : group([",
                    "              align(",
                    "                \" \".repeat(4),",
                    "                printChildren(path, options, print, {",
                    "                  processor: ({ isFirst }) =>",
                    "                    isFirst ? group([softline, print()]) : print(),",
                    "                })",
                    "              ),",
                    "              path.next?.type === \"footnoteDefinition\" ? softline : \"\",",
                    "            ]),",
                    "      ];",
                    "    }",
                    "    case \"table\":",
                    "      return printTable(path, options, print);",
                    "    case \"tableCell\":",
                    "      return printChildren(path, options, print);",
                    "    case \"break\":",
                    "      return /\\s/.test(options.originalText[node.position.start.offset])",
                    "        ? [\"  \", markAsRoot(literalline)]",
                    "        : [\"\\\\\", hardline];",
                    "    case \"liquidNode\":",
                    "      return replaceEndOfLine(node.value, hardline);",
                    "    // MDX",
                    "    // fallback to the original text if multiparser failed",
                    "    // or `embeddedLanguageFormatting: \"off\"`",
                    "    case \"import\":",
                    "    case \"export\":",
                    "    case \"jsx\":",
                    "      return node.value;",
                    "    case \"esComment\":",
                    "      return [\"{/* \", node.value, \" */}\"];",
                    "    case \"math\":",
                    "      return [",
                    "        \"$$\",",
                    "        hardline,",
                    "        node.value ? [replaceEndOfLine(node.value, hardline), hardline] : \"\",",
                    "        \"$$\",",
                    "      ];",
                    "    case \"inlineMath\":",
                    "      // remark-math trims content but we don't want to remove whitespaces",
                    "      // since it's very possible that it's recognized as math accidentally",
                    "      return options.originalText.slice(locStart(node), locEnd(node));",
                    "",
                    "    case \"tableRow\": // handled in \"table\"",
                    "    case \"listItem\": // handled in \"list\"",
                    "    case \"text\": // handled in other types",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"Markdown\");",
                    "  }",
                    "}",
                    "",
                    "function printListItem(path, options, print, listPrefix) {",
                    "  const { node } = path;",
                    "  const prefix = node.checked === null ? \"\" : node.checked ? \"[x] \" : \"[ ] \";",
                    "  return [",
                    "    prefix,",
                    "    printChildren(path, options, print, {",
                    "      processor({ node, isFirst }) {",
                    "        if (isFirst && node.type !== \"list\") {",
                    "          return align(\" \".repeat(prefix.length), print());",
                    "        }",
                    "",
                    "        const alignment = \" \".repeat(",
                    "          clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block",
                    "        );",
                    "        return [alignment, align(alignment, print())];",
                    "      },",
                    "    }),",
                    "  ];",
                    "}",
                    "",
                    "function alignListPrefix(prefix, options) {",
                    "  const additionalSpaces = getAdditionalSpaces();",
                    "  return (",
                    "    prefix +",
                    "    \" \".repeat(",
                    "      additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block",
                    "    )",
                    "  );",
                    "",
                    "  function getAdditionalSpaces() {",
                    "    const restSpaces = prefix.length % options.tabWidth;",
                    "    return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;",
                    "  }",
                    "}",
                    "",
                    "function getNthListSiblingIndex(node, parentNode) {",
                    "  return getNthSiblingIndex(",
                    "    node,",
                    "    parentNode,",
                    "    (siblingNode) => siblingNode.ordered === node.ordered",
                    "  );",
                    "}",
                    "",
                    "function getNthSiblingIndex(node, parentNode, condition) {",
                    "  let index = -1;",
                    "",
                    "  for (const childNode of parentNode.children) {",
                    "    if (childNode.type === node.type && condition(childNode)) {",
                    "      index++;",
                    "    } else {",
                    "      index = -1;",
                    "    }",
                    "",
                    "    if (childNode === node) {",
                    "      return index;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function printTable(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  const columnMaxWidths = [];",
                    "  // { [rowIndex: number]: { [columnIndex: number]: {text: string, width: number} } }",
                    "  const contents = path.map(",
                    "    () =>",
                    "      path.map(({ index: columnIndex }) => {",
                    "        const text = printDocToString(print(), options).formatted;",
                    "        const width = getStringWidth(text);",
                    "        columnMaxWidths[columnIndex] = Math.max(",
                    "          columnMaxWidths[columnIndex] || 3, // minimum width = 3 (---, :--, :-:, --:)",
                    "          width",
                    "        );",
                    "        return { text, width };",
                    "      }, \"children\"),",
                    "    \"children\"",
                    "  );",
                    "",
                    "  const alignedTable = printTableContents(/* isCompact */ false);",
                    "  if (options.proseWrap !== \"never\") {",
                    "    return [breakParent, alignedTable];",
                    "  }",
                    "",
                    "  // Only if the --prose-wrap never is set and it exceeds the print width.",
                    "  const compactTable = printTableContents(/* isCompact */ true);",
                    "  return [breakParent, group(ifBreak(compactTable, alignedTable))];",
                    "",
                    "  function printTableContents(isCompact) {",
                    "    /** @type{Doc[]} */",
                    "    const parts = [printRow(contents[0], isCompact), printAlign(isCompact)];",
                    "    if (contents.length > 1) {",
                    "      parts.push(",
                    "        join(",
                    "          hardlineWithoutBreakParent,",
                    "          contents",
                    "            .slice(1)",
                    "            .map((rowContents) => printRow(rowContents, isCompact))",
                    "        )",
                    "      );",
                    "    }",
                    "    return join(hardlineWithoutBreakParent, parts);",
                    "  }",
                    "",
                    "  function printAlign(isCompact) {",
                    "    const align = columnMaxWidths.map((width, index) => {",
                    "      const align = node.align[index];",
                    "      const first = align === \"center\" || align === \"left\" ? \":\" : \"-\";",
                    "      const last = align === \"center\" || align === \"right\" ? \":\" : \"-\";",
                    "      const middle = isCompact ? \"-\" : \"-\".repeat(width - 2);",
                    "      return `${first}${middle}${last}`;",
                    "    });",
                    "",
                    "    return `| ${align.join(\" | \")} |`;",
                    "  }",
                    "",
                    "  function printRow(rowContents, isCompact) {",
                    "    const columns = rowContents.map(({ text, width }, columnIndex) => {",
                    "      if (isCompact) {",
                    "        return text;",
                    "      }",
                    "      const spaces = columnMaxWidths[columnIndex] - width;",
                    "      const align = node.align[columnIndex];",
                    "      let before = 0;",
                    "      if (align === \"right\") {",
                    "        before = spaces;",
                    "      } else if (align === \"center\") {",
                    "        before = Math.floor(spaces / 2);",
                    "      }",
                    "      const after = spaces - before;",
                    "      return `${\" \".repeat(before)}${text}${\" \".repeat(after)}`;",
                    "    });",
                    "",
                    "    return `| ${columns.join(\" | \")} |`;",
                    "  }",
                    "}",
                    "",
                    "function printRoot(path, options, print) {",
                    "  /** @typedef {{ index: number, offset: number }} IgnorePosition */",
                    "  /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */",
                    "  const ignoreRanges = [];",
                    "",
                    "  /** @type {IgnorePosition | null} */",
                    "  let ignoreStart = null;",
                    "",
                    "  const { children } = path.node;",
                    "  for (const [index, childNode] of children.entries()) {",
                    "    switch (isPrettierIgnore(childNode)) {",
                    "      case \"start\":",
                    "        if (ignoreStart === null) {",
                    "          ignoreStart = { index, offset: childNode.position.end.offset };",
                    "        }",
                    "        break;",
                    "      case \"end\":",
                    "        if (ignoreStart !== null) {",
                    "          ignoreRanges.push({",
                    "            start: ignoreStart,",
                    "            end: { index, offset: childNode.position.start.offset },",
                    "          });",
                    "          ignoreStart = null;",
                    "        }",
                    "        break;",
                    "      default:",
                    "        // do nothing",
                    "        break;",
                    "    }",
                    "  }",
                    "",
                    "  return printChildren(path, options, print, {",
                    "    processor({ index }) {",
                    "      if (ignoreRanges.length > 0) {",
                    "        const ignoreRange = ignoreRanges[0];",
                    "",
                    "        if (index === ignoreRange.start.index) {",
                    "          return [",
                    "            printIgnoreComment(children[ignoreRange.start.index]),",
                    "            options.originalText.slice(",
                    "              ignoreRange.start.offset,",
                    "              ignoreRange.end.offset",
                    "            ),",
                    "            printIgnoreComment(children[ignoreRange.end.index]),",
                    "          ];",
                    "        }",
                    "",
                    "        if (ignoreRange.start.index < index && index < ignoreRange.end.index) {",
                    "          return false;",
                    "        }",
                    "",
                    "        if (index === ignoreRange.end.index) {",
                    "          ignoreRanges.shift();",
                    "          return false;",
                    "        }",
                    "      }",
                    "",
                    "      return print();",
                    "    },",
                    "  });",
                    "}",
                    "",
                    "function printChildren(path, options, print, events = {}) {",
                    "  const { postprocessor = (parts) => parts, processor = () => print() } =",
                    "    events;",
                    "",
                    "  const parts = [];",
                    "",
                    "  path.each(() => {",
                    "    const result = processor(path);",
                    "    if (result !== false) {",
                    "      if (parts.length > 0 && shouldPrePrintHardline(path)) {",
                    "        parts.push(hardline);",
                    "",
                    "        if (",
                    "          shouldPrePrintDoubleHardline(path, options) ||",
                    "          shouldPrePrintTripleHardline(path)",
                    "        ) {",
                    "          parts.push(hardline);",
                    "        }",
                    "",
                    "        if (shouldPrePrintTripleHardline(path)) {",
                    "          parts.push(hardline);",
                    "        }",
                    "      }",
                    "",
                    "      parts.push(result);",
                    "    }",
                    "  }, \"children\");",
                    "",
                    "  return postprocessor(parts);",
                    "}",
                    "",
                    "function printIgnoreComment(node) {",
                    "  if (node.type === \"html\") {",
                    "    return node.value;",
                    "  }",
                    "",
                    "  if (",
                    "    node.type === \"paragraph\" &&",
                    "    Array.isArray(node.children) &&",
                    "    node.children.length === 1 &&",
                    "    node.children[0].type === \"esComment\"",
                    "  ) {",
                    "    return [\"{/* \", node.children[0].value, \" */}\"];",
                    "  }",
                    "}",
                    "",
                    "/** @return {false | 'next' | 'start' | 'end'} */",
                    "function isPrettierIgnore(node) {",
                    "  let match;",
                    "",
                    "  if (node.type === \"html\") {",
                    "    match = node.value.match(/^<!--\\s*prettier-ignore(?:-(start|end))?\\s*-->$/);",
                    "  } else {",
                    "    let comment;",
                    "",
                    "    if (node.type === \"esComment\") {",
                    "      comment = node;",
                    "    } else if (",
                    "      node.type === \"paragraph\" &&",
                    "      node.children.length === 1 &&",
                    "      node.children[0].type === \"esComment\"",
                    "    ) {",
                    "      comment = node.children[0];",
                    "    }",
                    "",
                    "    if (comment) {",
                    "      match = comment.value.match(/^prettier-ignore(?:-(start|end))?$/);",
                    "    }",
                    "  }",
                    "",
                    "  return match ? match[1] || \"next\" : false;",
                    "}",
                    "",
                    "function shouldPrePrintHardline({ node, parent }) {",
                    "  const isInlineNode = INLINE_NODE_TYPES.has(node.type);",
                    "",
                    "  const isInlineHTML =",
                    "    node.type === \"html\" && INLINE_NODE_WRAPPER_TYPES.has(parent.type);",
                    "",
                    "  return !isInlineNode && !isInlineHTML;",
                    "}",
                    "",
                    "function isLooseListItem(node, options) {",
                    "  return (",
                    "    node.type === \"listItem\" &&",
                    "    (node.spread ||",
                    "      // Check if `listItem` ends with `\\n`",
                    "      // since it can't be empty, so we only need check the last character",
                    "      options.originalText.charAt(node.position.end.offset - 1) === \"\\n\")",
                    "  );",
                    "}",
                    "",
                    "function shouldPrePrintDoubleHardline({ node, previous, parent }, options) {",
                    "  const isPrevNodeLooseListItem = isLooseListItem(previous, options);",
                    "",
                    "  if (isPrevNodeLooseListItem) {",
                    "    return true;",
                    "  }",
                    "",
                    "  const isSequence = previous.type === node.type;",
                    "  const isSiblingNode = isSequence && SIBLING_NODE_TYPES.has(node.type);",
                    "  const isInTightListItem =",
                    "    parent.type === \"listItem\" && !isLooseListItem(parent, options);",
                    "  const isPrevNodePrettierIgnore = isPrettierIgnore(previous) === \"next\";",
                    "  const isBlockHtmlWithoutBlankLineBetweenPrevHtml =",
                    "    node.type === \"html\" &&",
                    "    previous.type === \"html\" &&",
                    "    previous.position.end.line + 1 === node.position.start.line;",
                    "  const isHtmlDirectAfterListItem =",
                    "    node.type === \"html\" &&",
                    "    parent.type === \"listItem\" &&",
                    "    previous.type === \"paragraph\" &&",
                    "    previous.position.end.line + 1 === node.position.start.line;",
                    "",
                    "  return !(",
                    "    isSiblingNode ||",
                    "    isInTightListItem ||",
                    "    isPrevNodePrettierIgnore ||",
                    "    isBlockHtmlWithoutBlankLineBetweenPrevHtml ||",
                    "    isHtmlDirectAfterListItem",
                    "  );",
                    "}",
                    "",
                    "function shouldPrePrintTripleHardline({ node, previous }) {",
                    "  const isPrevNodeList = previous.type === \"list\";",
                    "  const isIndentedCode = node.type === \"code\" && node.isIndented;",
                    "",
                    "  return isPrevNodeList && isIndentedCode;",
                    "}",
                    "",
                    "function shouldRemainTheSameContent(path) {",
                    "  const node = path.findAncestor(",
                    "    (node) => node.type === \"linkReference\" || node.type === \"imageReference\"",
                    "  );",
                    "  return (",
                    "    node && (node.type !== \"linkReference\" || node.referenceType !== \"full\")",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {string} url",
                    " * @param {string[] | string} [dangerousCharOrChars]",
                    " * @returns {string}",
                    " */",
                    "function printUrl(url, dangerousCharOrChars = []) {",
                    "  const dangerousChars = [",
                    "    \" \",",
                    "    ...(Array.isArray(dangerousCharOrChars)",
                    "      ? dangerousCharOrChars",
                    "      : [dangerousCharOrChars]),",
                    "  ];",
                    "  return new RegExp(dangerousChars.map((x) => `\\\\${x}`).join(\"|\")).test(url)",
                    "    ? `<${url}>`",
                    "    : url;",
                    "}",
                    "",
                    "function printTitle(title, options, printSpace = true) {",
                    "  if (!title) {",
                    "    return \"\";",
                    "  }",
                    "  if (printSpace) {",
                    "    return \" \" + printTitle(title, options, false);",
                    "  }",
                    "",
                    "  // title is escaped after `remark-parse` v7",
                    "  title = title.replaceAll(/\\\\(?=[\"')])/g, \"\");",
                    "",
                    "  if (title.includes('\"') && title.includes(\"'\") && !title.includes(\")\")) {",
                    "    return `(${title})`; // avoid escaped quotes",
                    "  }",
                    "  const quote = getPreferredQuote(title, options.singleQuote);",
                    "  title = title.replaceAll(\"\\\\\", \"\\\\\\\\\");",
                    "  title = title.replaceAll(quote, `\\\\${quote}`);",
                    "  return `${quote}${title}${quote}`;",
                    "}",
                    "",
                    "function clamp(value, min, max) {",
                    "  return value < min ? min : value > max ? max : value;",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  return path.index > 0 && isPrettierIgnore(path.previous) === \"next\";",
                    "}",
                    "",
                    "// `remark-parse` lowercase the `label` as `identifier`, we don't want do that",
                    "// https://github.com/remarkjs/remark/blob/daddcb463af2d5b2115496c395d0571c0ff87d15/packages/remark-parse/lib/tokenize/reference.js",
                    "function printLinkReference(node) {",
                    "  return `[${collapseWhiteSpace(node.label)}]`;",
                    "}",
                    "",
                    "function printFootnoteReference(node) {",
                    "  return `[^${node.label}]`;",
                    "}",
                    "",
                    "const printer = {",
                    "  preprocess,",
                    "  print: genericPrint,",
                    "  embed,",
                    "  massageAstNode: clean,",
                    "  hasPrettierIgnore,",
                    "  insertPragma,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import assert from \"node:assert\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "import {",
                    "  cjkPattern,",
                    "  kRegex,",
                    "  punctuationPattern,",
                    "} from \"./constants.evaluate.js\";",
                    "",
                    "const INLINE_NODE_TYPES = new Set([",
                    "  \"liquidNode\",",
                    "  \"inlineCode\",",
                    "  \"emphasis\",",
                    "  \"esComment\",",
                    "  \"strong\",",
                    "  \"delete\",",
                    "  \"wikiLink\",",
                    "  \"link\",",
                    "  \"linkReference\",",
                    "  \"image\",",
                    "  \"imageReference\",",
                    "  \"footnote\",",
                    "  \"footnoteReference\",",
                    "  \"sentence\",",
                    "  \"whitespace\",",
                    "  \"word\",",
                    "  \"break\",",
                    "  \"inlineMath\",",
                    "]);",
                    "",
                    "const INLINE_NODE_WRAPPER_TYPES = new Set([",
                    "  ...INLINE_NODE_TYPES,",
                    "  \"tableCell\",",
                    "  \"paragraph\",",
                    "  \"heading\",",
                    "]);",
                    "",
                    "const punctuationRegex = new RegExp(punctuationPattern);",
                    "",
                    "const KIND_NON_CJK = \"non-cjk\";",
                    "const KIND_CJ_LETTER = \"cj-letter\";",
                    "const KIND_K_LETTER = \"k-letter\";",
                    "const KIND_CJK_PUNCTUATION = \"cjk-punctuation\";",
                    "",
                    "/**",
                    " * @typedef {\" \" | \"\\n\" | \"\"} WhitespaceValue",
                    " * @typedef { KIND_NON_CJK | KIND_CJ_LETTER | KIND_K_LETTER | KIND_CJK_PUNCTUATION } WordKind",
                    " * @typedef {{",
                    " *   type: \"whitespace\",",
                    " *   value: WhitespaceValue,",
                    " *   kind?: never",
                    " * }} WhitespaceNode",
                    " * @typedef {{",
                    " *   type: \"word\",",
                    " *   value: string,",
                    " *   kind: WordKind,",
                    " *   hasLeadingPunctuation: boolean,",
                    " *   hasTrailingPunctuation: boolean,",
                    " * }} WordNode",
                    " * Node for a single CJK character or a sequence of non-CJK characters",
                    " * @typedef {WhitespaceNode | WordNode} TextNode",
                    " */",
                    "",
                    "/**",
                    " * split text into whitespaces and words",
                    " * @param {string} text",
                    " */",
                    "function splitText(text) {",
                    "  /** @type {Array<TextNode>} */",
                    "  const nodes = [];",
                    "",
                    "  const tokens = text.split(/([\\t\\n ]+)/);",
                    "  for (const [index, token] of tokens.entries()) {",
                    "    // whitespace",
                    "    if (index % 2 === 1) {",
                    "      nodes.push({",
                    "        type: \"whitespace\",",
                    "        value: /\\n/.test(token) ? \"\\n\" : \" \",",
                    "      });",
                    "      continue;",
                    "    }",
                    "",
                    "    // word separated by whitespace",
                    "",
                    "    if ((index === 0 || index === tokens.length - 1) && token === \"\") {",
                    "      continue;",
                    "    }",
                    "",
                    "    const innerTokens = token.split(new RegExp(`(${cjkPattern})`));",
                    "    for (const [innerIndex, innerToken] of innerTokens.entries()) {",
                    "      if (",
                    "        (innerIndex === 0 || innerIndex === innerTokens.length - 1) &&",
                    "        innerToken === \"\"",
                    "      ) {",
                    "        continue;",
                    "      }",
                    "",
                    "      // non-CJK word",
                    "      if (innerIndex % 2 === 0) {",
                    "        if (innerToken !== \"\") {",
                    "          appendNode({",
                    "            type: \"word\",",
                    "            value: innerToken,",
                    "            kind: KIND_NON_CJK,",
                    "            hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),",
                    "            hasTrailingPunctuation: punctuationRegex.test(innerToken.at(-1)),",
                    "          });",
                    "        }",
                    "        continue;",
                    "      }",
                    "",
                    "      // CJK character",
                    "      appendNode(",
                    "        punctuationRegex.test(innerToken)",
                    "          ? {",
                    "              type: \"word\",",
                    "              value: innerToken,",
                    "              kind: KIND_CJK_PUNCTUATION,",
                    "              hasLeadingPunctuation: true,",
                    "              hasTrailingPunctuation: true,",
                    "            }",
                    "          : {",
                    "              type: \"word\",",
                    "              value: innerToken,",
                    "              // Korean uses space to divide words, but Chinese & Japanese do not",
                    "              kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,",
                    "              hasLeadingPunctuation: false,",
                    "              hasTrailingPunctuation: false,",
                    "            }",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  // Check for `canBeConvertedToSpace` in ./print-whitespace.js etc.",
                    "  if (process.env.NODE_ENV !== \"production\") {",
                    "    for (let i = 1; i < nodes.length; i++) {",
                    "      assert(",
                    "        !(nodes[i - 1].type === \"whitespace\" && nodes[i].type === \"whitespace\"),",
                    "        \"splitText should not create consecutive whitespace nodes\"",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return nodes;",
                    "",
                    "  function appendNode(node) {",
                    "    const lastNode = nodes.at(-1);",
                    "    if (",
                    "      lastNode?.type === \"word\" &&",
                    "      !isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) &&",
                    "      // disallow leading/trailing full-width whitespace",
                    "      ![lastNode.value, node.value].some((value) => /\\u3000/.test(value))",
                    "    ) {",
                    "      nodes.push({ type: \"whitespace\", value: \"\" });",
                    "    }",
                    "    nodes.push(node);",
                    "",
                    "    function isBetween(kind1, kind2) {",
                    "      return (",
                    "        (lastNode.kind === kind1 && node.kind === kind2) ||",
                    "        (lastNode.kind === kind2 && node.kind === kind1)",
                    "      );",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function getOrderedListItemInfo(orderListItem, originalText) {",
                    "  const [, numberText, marker, leadingSpaces] = originalText",
                    "    .slice(",
                    "      orderListItem.position.start.offset,",
                    "      orderListItem.position.end.offset",
                    "    )",
                    "    .match(/^\\s*(\\d+)(\\.|\\))(\\s*)/);",
                    "",
                    "  return { numberText, marker, leadingSpaces };",
                    "}",
                    "",
                    "function hasGitDiffFriendlyOrderedList(node, options) {",
                    "  if (!node.ordered) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (node.children.length < 2) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const firstNumber = Number(",
                    "    getOrderedListItemInfo(node.children[0], options.originalText).numberText",
                    "  );",
                    "",
                    "  const secondNumber = Number(",
                    "    getOrderedListItemInfo(node.children[1], options.originalText).numberText",
                    "  );",
                    "",
                    "  if (firstNumber === 0 && node.children.length > 2) {",
                    "    const thirdNumber = Number(",
                    "      getOrderedListItemInfo(node.children[2], options.originalText).numberText",
                    "    );",
                    "",
                    "    return secondNumber === 1 && thirdNumber === 1;",
                    "  }",
                    "",
                    "  return secondNumber === 1;",
                    "}",
                    "",
                    "// The final new line should not include in value",
                    "// https://github.com/remarkjs/remark/issues/512",
                    "function getFencedCodeBlockValue(node, originalText) {",
                    "  const { value } = node;",
                    "  if (",
                    "    node.position.end.offset === originalText.length &&",
                    "    value.endsWith(\"\\n\") &&",
                    "    // Code block has no end mark",
                    "    originalText.endsWith(\"\\n\")",
                    "  ) {",
                    "    return value.slice(0, -1);",
                    "  }",
                    "  return value;",
                    "}",
                    "",
                    "function mapAst(ast, handler) {",
                    "  return (function preorder(node, index, parentStack) {",
                    "    const newNode = { ...handler(node, index, parentStack) };",
                    "    if (newNode.children) {",
                    "      newNode.children = newNode.children.map((child, index) =>",
                    "        preorder(child, index, [newNode, ...parentStack])",
                    "      );",
                    "    }",
                    "",
                    "    return newNode;",
                    "  })(ast, null, []);",
                    "}",
                    "",
                    "function isAutolink(node) {",
                    "  if (node?.type !== \"link\" || node.children.length !== 1) {",
                    "    return false;",
                    "  }",
                    "  const [child] = node.children;",
                    "  return locStart(node) === locStart(child) && locEnd(node) === locEnd(child);",
                    "}",
                    "",
                    "export {",
                    "  mapAst,",
                    "  splitText,",
                    "  punctuationPattern,",
                    "  getFencedCodeBlockValue,",
                    "  getOrderedListItemInfo,",
                    "  hasGitDiffFriendlyOrderedList,",
                    "  INLINE_NODE_TYPES,",
                    "  INLINE_NODE_WRAPPER_TYPES,",
                    "  isAutolink,",
                    "  KIND_NON_CJK,",
                    "  KIND_CJ_LETTER,",
                    "  KIND_K_LETTER,",
                    "  KIND_CJK_PUNCTUATION,",
                    "};"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = {",
                    "  \"front-matter\": [],",
                    "  root: [\"children\"],",
                    "  paragraph: [\"children\"],",
                    "  sentence: [\"children\"],",
                    "  word: [],",
                    "  whitespace: [],",
                    "  emphasis: [\"children\"],",
                    "  strong: [\"children\"],",
                    "  delete: [\"children\"],",
                    "  inlineCode: [],",
                    "  wikiLink: [],",
                    "  link: [\"children\"],",
                    "  image: [],",
                    "  blockquote: [\"children\"],",
                    "  heading: [\"children\"],",
                    "  code: [],",
                    "  html: [],",
                    "  list: [\"children\"],",
                    "  thematicBreak: [],",
                    "  linkReference: [\"children\"],",
                    "  imageReference: [],",
                    "  definition: [],",
                    "  footnote: [\"children\"],",
                    "  footnoteReference: [],",
                    "  footnoteDefinition: [\"children\"],",
                    "  table: [\"children\"],",
                    "  tableCell: [\"children\"],",
                    "  break: [],",
                    "  liquidNode: [],",
                    "  import: [],",
                    "  export: [],",
                    "  esComment: [],",
                    "  jsx: [],",
                    "  math: [],",
                    "  inlineMath: [],",
                    "  tableRow: [\"children\"],",
                    "  listItem: [\"children\"],",
                    "  text: [],",
                    "};",
                    "",
                    "export default visitorKeys;"
                ]
            },
            "unified-plugins": {
                "front-matter.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import parseFrontMatter from \"../../utils/front-matter/parse.js\";",
                        "",
                        "function frontMatter() {",
                        "  const proto = this.Parser.prototype;",
                        "  proto.blockMethods = [\"frontMatter\", ...proto.blockMethods];",
                        "  proto.blockTokenizers.frontMatter = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const parsed = parseFrontMatter(value);",
                        "",
                        "    if (parsed.frontMatter) {",
                        "      return eat(parsed.frontMatter.raw)(parsed.frontMatter);",
                        "    }",
                        "  }",
                        "  tokenizer.onlyAtStart = true;",
                        "}",
                        "",
                        "export default frontMatter;"
                    ]
                },
                "html-to-jsx.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { COMMENT_REGEX } from \"../mdx.js\";",
                        "import { mapAst, INLINE_NODE_WRAPPER_TYPES } from \"../utils.js\";",
                        "",
                        "function htmlToJsx() {",
                        "  return (ast) =>",
                        "    mapAst(ast, (node, _index, [parent]) => {",
                        "      if (",
                        "        node.type !== \"html\" ||",
                        "        // Keep HTML-style comments (legacy MDX)",
                        "        COMMENT_REGEX.test(node.value) ||",
                        "        INLINE_NODE_WRAPPER_TYPES.has(parent.type)",
                        "      ) {",
                        "        return node;",
                        "      }",
                        "      return { ...node, type: \"jsx\" };",
                        "    });",
                        "}",
                        "",
                        "export default htmlToJsx;"
                    ]
                },
                "liquid.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function liquid() {",
                        "  const proto = this.Parser.prototype;",
                        "  const methods = proto.inlineMethods;",
                        "  methods.splice(methods.indexOf(\"text\"), 0, \"liquid\");",
                        "  proto.inlineTokenizers.liquid = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const match = value.match(/^({%.*?%}|{{.*?}})/s);",
                        "",
                        "    if (match) {",
                        "      return eat(match[0])({",
                        "        type: \"liquidNode\",",
                        "        value: match[0],",
                        "      });",
                        "    }",
                        "  }",
                        "  tokenizer.locator = function (value, fromIndex) {",
                        "    return value.indexOf(\"{\", fromIndex);",
                        "  };",
                        "}",
                        "",
                        "export default liquid;"
                    ]
                },
                "wiki-link.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function wikiLink() {",
                        "  const entityType = \"wikiLink\";",
                        "  const wikiLinkRegex = /^\\[\\[(?<linkContents>.+?)]]/s;",
                        "  const proto = this.Parser.prototype;",
                        "  const methods = proto.inlineMethods;",
                        "  methods.splice(methods.indexOf(\"link\"), 0, entityType);",
                        "  proto.inlineTokenizers.wikiLink = tokenizer;",
                        "",
                        "  function tokenizer(eat, value) {",
                        "    const match = wikiLinkRegex.exec(value);",
                        "",
                        "    if (match) {",
                        "      const linkContents = match.groups.linkContents.trim();",
                        "",
                        "      return eat(match[0])({",
                        "        type: entityType,",
                        "        value: linkContents,",
                        "      });",
                        "    }",
                        "  }",
                        "",
                        "  tokenizer.locator = function (value, fromIndex) {",
                        "    return value.indexOf(\"[\", fromIndex);",
                        "  };",
                        "}",
                        "",
                        "export default wikiLink;"
                    ]
                }
            }
        },
        "language-yaml": {
            "embed.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { hardline } from \"../document/builders.js\";",
                    "",
                    "function embed(path, options) {",
                    "  const { node } = path;",
                    "",
                    "  // Try to format `.prettierrc`, `.stylelintrc`, and `.lintstagedrc` as `json` first",
                    "  if (",
                    "    node.type === \"root\" &&",
                    "    options.filepath &&",
                    "    /(?:[/\\\\]|^)\\.(?:prettier|stylelint|lintstaged)rc$/.test(options.filepath)",
                    "  ) {",
                    "    return async (textToDoc) => {",
                    "      const doc = await textToDoc(options.originalText, { parser: \"json\" });",
                    "      return doc ? [doc, hardline] : undefined;",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "// Only \"root\" allow print as JSON",
                    "// Use `[]` to prevent `printEmbeddedLanguages` traverse deep",
                    "embed.getVisitorKeys = () => [];",
                    "",
                    "export default embed;"
                ]
            },
            "get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeys from \"../utils/create-get-visitor-keys.js\";",
                    "import visitorKeys from \"./visitor-keys.js\";",
                    "",
                    "const getVisitorKeys = createGetVisitorKeys(visitorKeys);",
                    "",
                    "export default getVisitorKeys;"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "import printer from \"./printer-yaml.js\";",
                    "",
                    "export const printers = {",
                    "  yaml: printer,",
                    "};",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"./parser-yaml.js\"),",
                    "    parserNames: [\"yaml\"],",
                    "  },",
                    "]);",
                    "export { default as languages } from \"./languages.evaluate.js\";",
                    "export { default as options } from \"./options.js\";"
                ]
            },
            "languages.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import linguistLanguages from \"linguist-languages\";",
                    "import createLanguage from \"../utils/create-language.js\";",
                    "",
                    "const languages = [",
                    "  createLanguage(linguistLanguages.YAML, (data) => ({",
                    "    parsers: [\"yaml\"],",
                    "    vscodeLanguageIds: [\"yaml\", \"ansible\", \"home-assistant\"],",
                    "    // yarn.lock is not YAML: https://github.com/yarnpkg/yarn/issues/5629",
                    "    filenames: [",
                    "      ...data.filenames.filter((filename) => filename !== \"yarn.lock\"),",
                    "      \".prettierrc\",",
                    "      \".stylelintrc\",",
                    "      \".lintstagedrc\",",
                    "    ],",
                    "  })),",
                    "];",
                    "",
                    "export default languages;"
                ]
            },
            "loc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function locStart(node) {",
                    "  return node.position.start.offset;",
                    "}",
                    "",
                    "function locEnd(node) {",
                    "  return node.position.end.offset;",
                    "}",
                    "",
                    "export { locStart, locEnd };"
                ]
            },
            "options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import commonOptions from \"../common/common-options.evaluate.js\";",
                    "",
                    "// format based on https://github.com/prettier/prettier/blob/main/src/main/core-options.evaluate.js",
                    "const options = {",
                    "  bracketSpacing: commonOptions.bracketSpacing,",
                    "  singleQuote: commonOptions.singleQuote,",
                    "  proseWrap: commonOptions.proseWrap,",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "parser-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { parse as parseYaml } from \"yaml-unist-parser/lib/parse.js\";",
                    "import createError from \"../common/parser-create-error.js\";",
                    "import { hasPragma } from \"./pragma.js\";",
                    "import { locStart, locEnd } from \"./loc.js\";",
                    "",
                    "function parse(text) {",
                    "  try {",
                    "    const root = parseYaml(text);",
                    "",
                    "    /**",
                    "     * suppress `comment not printed` error",
                    "     *",
                    "     * comments are handled in printer-yaml.js without using `printComment`",
                    "     * so that it'll always throw errors even if we printed it correctly",
                    "     */",
                    "    delete root.comments;",
                    "",
                    "    return root;",
                    "  } catch (error) {",
                    "    if (error?.position) {",
                    "      throw createError(error.message, {",
                    "        loc: error.position,",
                    "        cause: error,",
                    "      });",
                    "    }",
                    "",
                    "    /* c8 ignore next */",
                    "    throw error;",
                    "  }",
                    "}",
                    "",
                    "export const yaml = {",
                    "  astFormat: \"yaml\",",
                    "  parse,",
                    "  hasPragma,",
                    "  locStart,",
                    "  locEnd,",
                    "};"
                ]
            },
            "pragma.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function isPragma(text) {",
                    "  return /^\\s*@(?:prettier|format)\\s*$/.test(text);",
                    "}",
                    "",
                    "function hasPragma(text) {",
                    "  return /^\\s*#[^\\S\\n]*@(?:prettier|format)\\s*?(?:\\n|$)/.test(text);",
                    "}",
                    "",
                    "function insertPragma(text) {",
                    "  return `# @format\\n\\n${text}`;",
                    "}",
                    "",
                    "export { isPragma, hasPragma, insertPragma };"
                ]
            },
            "print-preprocess.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { defineShortcut, mapNode } from \"./utils.js\";",
                    "",
                    "function preprocess(ast) {",
                    "  return mapNode(ast, defineShortcuts);",
                    "}",
                    "",
                    "function defineShortcuts(node) {",
                    "  switch (node.type) {",
                    "    case \"document\":",
                    "      defineShortcut(node, \"head\", () => node.children[0]);",
                    "      defineShortcut(node, \"body\", () => node.children[1]);",
                    "      break;",
                    "    case \"documentBody\":",
                    "    case \"sequenceItem\":",
                    "    case \"flowSequenceItem\":",
                    "    case \"mappingKey\":",
                    "    case \"mappingValue\":",
                    "      defineShortcut(node, \"content\", () => node.children[0]);",
                    "      break;",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\":",
                    "      defineShortcut(node, \"key\", () => node.children[0]);",
                    "      defineShortcut(node, \"value\", () => node.children[1]);",
                    "      break;",
                    "  }",
                    "  return node;",
                    "}",
                    "",
                    "export default preprocess;"
                ]
            },
            "printer-yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/** @typedef {import(\"../document/builders.js\").Doc} Doc */",
                    "",
                    "import {",
                    "  breakParent,",
                    "  fill,",
                    "  group,",
                    "  hardline,",
                    "  join,",
                    "  line,",
                    "  lineSuffix,",
                    "} from \"../document/builders.js\";",
                    "import { replaceEndOfLine } from \"../document/utils.js\";",
                    "import isPreviousLineEmpty from \"../utils/is-previous-line-empty.js\";",
                    "import UnexpectedNodeError from \"../utils/unexpected-node-error.js\";",
                    "import { insertPragma, isPragma } from \"./pragma.js\";",
                    "import { locStart } from \"./loc.js\";",
                    "import embed from \"./embed.js\";",
                    "import {",
                    "  getFlowScalarLineContents,",
                    "  getLastDescendantNode,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "  hasPrettierIgnore,",
                    "  isLastDescendantNode,",
                    "  isNode,",
                    "  isInlineNode,",
                    "} from \"./utils.js\";",
                    "import getVisitorKeys from \"./get-visitor-keys.js\";",
                    "import preprocess from \"./print-preprocess.js\";",
                    "import {",
                    "  alignWithSpaces,",
                    "  printNextEmptyLine,",
                    "  shouldPrintEndComments,",
                    "} from \"./print/misc.js\";",
                    "import {",
                    "  printFlowMapping,",
                    "  printFlowSequence,",
                    "} from \"./print/flow-mapping-sequence.js\";",
                    "import printMappingItem from \"./print/mapping-item.js\";",
                    "import printBlock from \"./print/block.js\";",
                    "",
                    "function genericPrint(path, options, print) {",
                    "  const { node } = path;",
                    "",
                    "  /** @type {Doc[]} */",
                    "  const parts = [];",
                    "",
                    "  if (node.type !== \"mappingValue\" && hasLeadingComments(node)) {",
                    "    parts.push([join(hardline, path.map(print, \"leadingComments\")), hardline]);",
                    "  }",
                    "",
                    "  const { tag, anchor } = node;",
                    "  if (tag) {",
                    "    parts.push(print(\"tag\"));",
                    "  }",
                    "  if (tag && anchor) {",
                    "    parts.push(\" \");",
                    "  }",
                    "  if (anchor) {",
                    "    parts.push(print(\"anchor\"));",
                    "  }",
                    "",
                    "  /** @type {Doc} */",
                    "  let nextEmptyLine = \"\";",
                    "",
                    "  if (",
                    "    isNode(node, [",
                    "      \"mapping\",",
                    "      \"sequence\",",
                    "      \"comment\",",
                    "      \"directive\",",
                    "      \"mappingItem\",",
                    "      \"sequenceItem\",",
                    "    ]) &&",
                    "    !isLastDescendantNode(path)",
                    "  ) {",
                    "    nextEmptyLine = printNextEmptyLine(path, options.originalText);",
                    "  }",
                    "",
                    "  if (tag || anchor) {",
                    "    if (isNode(node, [\"sequence\", \"mapping\"]) && !hasMiddleComments(node)) {",
                    "      parts.push(hardline);",
                    "    } else {",
                    "      parts.push(\" \");",
                    "    }",
                    "  }",
                    "",
                    "  if (hasMiddleComments(node)) {",
                    "    parts.push([",
                    "      node.middleComments.length === 1 ? \"\" : hardline,",
                    "      join(hardline, path.map(print, \"middleComments\")),",
                    "      hardline,",
                    "    ]);",
                    "  }",
                    "",
                    "  if (hasPrettierIgnore(path)) {",
                    "    parts.push(",
                    "      replaceEndOfLine(",
                    "        options.originalText",
                    "          .slice(node.position.start.offset, node.position.end.offset)",
                    "          .trimEnd()",
                    "      )",
                    "    );",
                    "  } else {",
                    "    parts.push(group(printNode(path, options, print)));",
                    "  }",
                    "",
                    "  if (hasTrailingComment(node) && !isNode(node, [\"document\", \"documentHead\"])) {",
                    "    parts.push(",
                    "      lineSuffix([",
                    "        node.type === \"mappingValue\" && !node.content ? \"\" : \" \",",
                    "        path.parent.type === \"mappingKey\" &&",
                    "        path.getParentNode(2).type === \"mapping\" &&",
                    "        isInlineNode(node)",
                    "          ? \"\"",
                    "          : breakParent,",
                    "        print(\"trailingComment\"),",
                    "      ])",
                    "    );",
                    "  }",
                    "",
                    "  if (shouldPrintEndComments(node)) {",
                    "    parts.push(",
                    "      alignWithSpaces(node.type === \"sequenceItem\" ? 2 : 0, [",
                    "        hardline,",
                    "        join(",
                    "          hardline,",
                    "          path.map(",
                    "            ({ node }) => [",
                    "              isPreviousLineEmpty(options.originalText, locStart(node))",
                    "                ? hardline",
                    "                : \"\",",
                    "              print(),",
                    "            ],",
                    "            \"endComments\"",
                    "          )",
                    "        ),",
                    "      ])",
                    "    );",
                    "  }",
                    "  parts.push(nextEmptyLine);",
                    "  return parts;",
                    "}",
                    "",
                    "function printNode(path, options, print) {",
                    "  const { node } = path;",
                    "  switch (node.type) {",
                    "    case \"root\": {",
                    "      const parts = [];",
                    "      path.each(({ node: document, next: nextDocument, isFirst }) => {",
                    "        if (!isFirst) {",
                    "          parts.push(hardline);",
                    "        }",
                    "        parts.push(print());",
                    "        if (shouldPrintDocumentEndMarker(document, nextDocument)) {",
                    "          parts.push(hardline, \"...\");",
                    "          if (hasTrailingComment(document)) {",
                    "            parts.push(\" \", print(\"trailingComment\"));",
                    "          }",
                    "        } else if (nextDocument && !hasTrailingComment(nextDocument.head)) {",
                    "          parts.push(hardline, \"---\");",
                    "        }",
                    "      }, \"children\");",
                    "",
                    "      const lastDescendantNode = getLastDescendantNode(node);",
                    "      if (",
                    "        !isNode(lastDescendantNode, [\"blockLiteral\", \"blockFolded\"]) ||",
                    "        lastDescendantNode.chomping !== \"keep\"",
                    "      ) {",
                    "        parts.push(hardline);",
                    "      }",
                    "      return parts;",
                    "    }",
                    "    case \"document\": {",
                    "      const parts = [];",
                    "      if (shouldPrintDocumentHeadEndMarker(path, options) === \"head\") {",
                    "        if (node.head.children.length > 0 || node.head.endComments.length > 0) {",
                    "          parts.push(print(\"head\"));",
                    "        }",
                    "",
                    "        if (hasTrailingComment(node.head)) {",
                    "          parts.push([\"---\", \" \", print([\"head\", \"trailingComment\"])]);",
                    "        } else {",
                    "          parts.push(\"---\");",
                    "        }",
                    "      }",
                    "",
                    "      if (shouldPrintDocumentBody(node)) {",
                    "        parts.push(print(\"body\"));",
                    "      }",
                    "",
                    "      return join(hardline, parts);",
                    "    }",
                    "    case \"documentHead\":",
                    "      return join(hardline, [",
                    "        ...path.map(print, \"children\"),",
                    "        ...path.map(print, \"endComments\"),",
                    "      ]);",
                    "    case \"documentBody\": {",
                    "      const { children, endComments } = node;",
                    "      /** @type {Doc} */",
                    "      let separator = \"\";",
                    "      if (children.length > 0 && endComments.length > 0) {",
                    "        const lastDescendantNode = getLastDescendantNode(node);",
                    "        // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)",
                    "        if (isNode(lastDescendantNode, [\"blockFolded\", \"blockLiteral\"])) {",
                    "          // an extra newline for better readability",
                    "          if (lastDescendantNode.chomping !== \"keep\") {",
                    "            separator = [hardline, hardline];",
                    "          }",
                    "        } else {",
                    "          separator = hardline;",
                    "        }",
                    "      }",
                    "",
                    "      return [",
                    "        join(hardline, path.map(print, \"children\")),",
                    "        separator,",
                    "        join(hardline, path.map(print, \"endComments\")),",
                    "      ];",
                    "    }",
                    "    case \"directive\":",
                    "      return [\"%\", join(\" \", [node.name, ...node.parameters])];",
                    "    case \"comment\":",
                    "      return [\"#\", node.value];",
                    "    case \"alias\":",
                    "      return [\"*\", node.value];",
                    "    case \"tag\":",
                    "      return options.originalText.slice(",
                    "        node.position.start.offset,",
                    "        node.position.end.offset",
                    "      );",
                    "    case \"anchor\":",
                    "      return [\"&\", node.value];",
                    "    case \"plain\":",
                    "      return printFlowScalarContent(",
                    "        node.type,",
                    "        options.originalText.slice(",
                    "          node.position.start.offset,",
                    "          node.position.end.offset",
                    "        ),",
                    "        options",
                    "      );",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\": {",
                    "      const singleQuote = \"'\";",
                    "      const doubleQuote = '\"';",
                    "",
                    "      const raw = options.originalText.slice(",
                    "        node.position.start.offset + 1,",
                    "        node.position.end.offset - 1",
                    "      );",
                    "",
                    "      if (",
                    "        (node.type === \"quoteSingle\" && raw.includes(\"\\\\\")) ||",
                    "        (node.type === \"quoteDouble\" && /\\\\[^\"]/.test(raw))",
                    "      ) {",
                    "        // only quoteDouble can use escape chars",
                    "        // and quoteSingle do not need to escape backslashes",
                    "        const originalQuote =",
                    "          node.type === \"quoteDouble\" ? doubleQuote : singleQuote;",
                    "        return [",
                    "          originalQuote,",
                    "          printFlowScalarContent(node.type, raw, options),",
                    "          originalQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      if (raw.includes(doubleQuote)) {",
                    "        return [",
                    "          singleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteDouble\"",
                    "              ? raw",
                    "                  // double quote needs to be escaped by backslash in quoteDouble",
                    "                  .replaceAll('\\\\\"', doubleQuote)",
                    "                  .replaceAll(\"'\", singleQuote.repeat(2))",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          singleQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      if (raw.includes(singleQuote)) {",
                    "        return [",
                    "          doubleQuote,",
                    "          printFlowScalarContent(",
                    "            node.type,",
                    "            node.type === \"quoteSingle\"",
                    "              ? // single quote needs to be escaped by 2 single quotes in quoteSingle",
                    "                raw.replaceAll(\"''\", singleQuote)",
                    "              : raw,",
                    "            options",
                    "          ),",
                    "          doubleQuote,",
                    "        ];",
                    "      }",
                    "",
                    "      const quote = options.singleQuote ? singleQuote : doubleQuote;",
                    "      return [quote, printFlowScalarContent(node.type, raw, options), quote];",
                    "    }",
                    "    case \"blockFolded\":",
                    "    case \"blockLiteral\":",
                    "      return printBlock(path, print, options);",
                    "",
                    "    case \"mapping\":",
                    "    case \"sequence\":",
                    "      return join(hardline, path.map(print, \"children\"));",
                    "    case \"sequenceItem\":",
                    "      return [\"- \", alignWithSpaces(2, node.content ? print(\"content\") : \"\")];",
                    "    case \"mappingKey\":",
                    "    case \"mappingValue\":",
                    "      return !node.content ? \"\" : print(\"content\");",
                    "    case \"mappingItem\":",
                    "    case \"flowMappingItem\":",
                    "      return printMappingItem(path, print, options);",
                    "",
                    "    case \"flowMapping\":",
                    "      return printFlowMapping(path, print, options);",
                    "    case \"flowSequence\":",
                    "      return printFlowSequence(path, print, options);",
                    "    case \"flowSequenceItem\":",
                    "      return print(\"content\");",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new UnexpectedNodeError(node, \"YAML\");",
                    "  }",
                    "}",
                    "",
                    "function shouldPrintDocumentBody(document) {",
                    "  return document.body.children.length > 0 || hasEndComments(document.body);",
                    "}",
                    "",
                    "function shouldPrintDocumentEndMarker(document, nextDocument) {",
                    "  return (",
                    "    /**",
                    "     *... # trailingComment",
                    "     */",
                    "    hasTrailingComment(document) ||",
                    "    (nextDocument &&",
                    "      /**",
                    "       * ...",
                    "       * %DIRECTIVE",
                    "       * ---",
                    "       */",
                    "      (nextDocument.head.children.length > 0 ||",
                    "        /**",
                    "         * ...",
                    "         * # endComment",
                    "         * ---",
                    "         */",
                    "        hasEndComments(nextDocument.head)))",
                    "  );",
                    "}",
                    "",
                    "function shouldPrintDocumentHeadEndMarker(path, options) {",
                    "  const document = path.node;",
                    "  if (",
                    "    /**",
                    "     * ---",
                    "     * preserve the first document head end marker",
                    "     */",
                    "    (path.isFirst &&",
                    "      /---(?:\\s|$)/.test(",
                    "        options.originalText.slice(locStart(document), locStart(document) + 4)",
                    "      )) ||",
                    "    /**",
                    "     * %DIRECTIVE",
                    "     * ---",
                    "     */",
                    "    document.head.children.length > 0 ||",
                    "    /**",
                    "     * # end comment",
                    "     * ---",
                    "     */",
                    "    hasEndComments(document.head) ||",
                    "    /**",
                    "     * --- # trailing comment",
                    "     */",
                    "    hasTrailingComment(document.head)",
                    "  ) {",
                    "    return \"head\";",
                    "  }",
                    "",
                    "  const nextDocument = path.next;",
                    "  if (shouldPrintDocumentEndMarker(document, nextDocument)) {",
                    "    return false;",
                    "  }",
                    "",
                    "  return nextDocument ? \"root\" : false;",
                    "}",
                    "",
                    "function printFlowScalarContent(nodeType, content, options) {",
                    "  const lineContents = getFlowScalarLineContents(nodeType, content, options);",
                    "  return join(",
                    "    hardline,",
                    "    lineContents.map((lineContentWords) => fill(join(line, lineContentWords)))",
                    "  );",
                    "}",
                    "",
                    "function clean(node, newNode /*, parent */) {",
                    "  if (isNode(newNode)) {",
                    "    delete newNode.position;",
                    "    switch (newNode.type) {",
                    "      case \"comment\":",
                    "        // insert pragma",
                    "        if (isPragma(newNode.value)) {",
                    "          return null;",
                    "        }",
                    "        break;",
                    "      case \"quoteDouble\":",
                    "      case \"quoteSingle\":",
                    "        newNode.type = \"quote\";",
                    "        break;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "const printer = {",
                    "  preprocess,",
                    "  embed,",
                    "  print: genericPrint,",
                    "  massageAstNode: clean,",
                    "  insertPragma,",
                    "  getVisitorKeys,",
                    "};",
                    "",
                    "export default printer;"
                ]
            },
            "utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isNonEmptyArray from \"../utils/is-non-empty-array.js\";",
                    "",
                    "/**",
                    " * @param {any} value",
                    " * @param {string[]=} types",
                    " */",
                    "function isNode(value, types) {",
                    "  return (",
                    "    typeof value?.type === \"string\" && (!types || types.includes(value.type))",
                    "  );",
                    "}",
                    "",
                    "function mapNode(node, callback, parent) {",
                    "  return callback(",
                    "    \"children\" in node",
                    "      ? {",
                    "          ...node,",
                    "          children: node.children.map((childNode) =>",
                    "            mapNode(childNode, callback, node)",
                    "          ),",
                    "        }",
                    "      : node,",
                    "    parent",
                    "  );",
                    "}",
                    "",
                    "function defineShortcut(x, key, getter) {",
                    "  Object.defineProperty(x, key, {",
                    "    get: getter,",
                    "    enumerable: false,",
                    "  });",
                    "}",
                    "",
                    "function isNextLineEmpty(node, text) {",
                    "  let newlineCount = 0;",
                    "  const textLength = text.length;",
                    "  for (let i = node.position.end.offset - 1; i < textLength; i++) {",
                    "    const char = text[i];",
                    "",
                    "    if (char === \"\\n\") {",
                    "      newlineCount++;",
                    "    }",
                    "",
                    "    if (newlineCount === 1 && /\\S/.test(char)) {",
                    "      return false;",
                    "    }",
                    "",
                    "    if (newlineCount === 2) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "function isLastDescendantNode(path) {",
                    "  const { node } = path;",
                    "",
                    "  switch (node.type) {",
                    "    case \"tag\":",
                    "    case \"anchor\":",
                    "    case \"comment\":",
                    "      return false;",
                    "  }",
                    "",
                    "  const pathStackLength = path.stack.length;",
                    "",
                    "  for (let i = 1; i < pathStackLength; i++) {",
                    "    const item = path.stack[i];",
                    "    const parentItem = path.stack[i - 1];",
                    "",
                    "    if (",
                    "      Array.isArray(parentItem) &&",
                    "      typeof item === \"number\" &&",
                    "      item !== parentItem.length - 1",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}",
                    "",
                    "function getLastDescendantNode(node) {",
                    "  return isNonEmptyArray(node.children)",
                    "    ? getLastDescendantNode(node.children.at(-1))",
                    "    : node;",
                    "}",
                    "",
                    "function isPrettierIgnore(comment) {",
                    "  return comment.value.trim() === \"prettier-ignore\";",
                    "}",
                    "",
                    "function hasPrettierIgnore(path) {",
                    "  const { node } = path;",
                    "",
                    "  if (node.type === \"documentBody\") {",
                    "    const documentHead = path.parent.head;",
                    "    return (",
                    "      hasEndComments(documentHead) &&",
                    "      isPrettierIgnore(documentHead.endComments.at(-1))",
                    "    );",
                    "  }",
                    "",
                    "  return (",
                    "    hasLeadingComments(node) && isPrettierIgnore(node.leadingComments.at(-1))",
                    "  );",
                    "}",
                    "",
                    "function isEmptyNode(node) {",
                    "  return !isNonEmptyArray(node.children) && !hasComments(node);",
                    "}",
                    "",
                    "function hasComments(node) {",
                    "  return (",
                    "    hasLeadingComments(node) ||",
                    "    hasMiddleComments(node) ||",
                    "    hasIndicatorComment(node) ||",
                    "    hasTrailingComment(node) ||",
                    "    hasEndComments(node)",
                    "  );",
                    "}",
                    "",
                    "function hasLeadingComments(node) {",
                    "  return isNonEmptyArray(node?.leadingComments);",
                    "}",
                    "",
                    "function hasMiddleComments(node) {",
                    "  return isNonEmptyArray(node?.middleComments);",
                    "}",
                    "",
                    "function hasIndicatorComment(node) {",
                    "  return node?.indicatorComment;",
                    "}",
                    "",
                    "function hasTrailingComment(node) {",
                    "  return node?.trailingComment;",
                    "}",
                    "",
                    "function hasEndComments(node) {",
                    "  return isNonEmptyArray(node?.endComments);",
                    "}",
                    "",
                    "/**",
                    " * \" a   b c   d e   f \" -> [\" a   b\", \"c   d\", \"e   f \"]",
                    " */",
                    "function splitWithSingleSpace(text) {",
                    "  const parts = [];",
                    "",
                    "  let lastPart;",
                    "  for (const part of text.split(/( +)/)) {",
                    "    if (part !== \" \") {",
                    "      if (lastPart === \" \") {",
                    "        parts.push(part);",
                    "      } else {",
                    "        parts.push((parts.pop() || \"\") + part);",
                    "      }",
                    "    } else if (lastPart === undefined) {",
                    "      parts.unshift(\"\");",
                    "    }",
                    "",
                    "    lastPart = part;",
                    "  }",
                    "",
                    "  /* c8 ignore next 3 */",
                    "  if (lastPart === \" \") {",
                    "    parts.push((parts.pop() || \"\") + \" \");",
                    "  }",
                    "",
                    "  if (parts[0] === \"\") {",
                    "    parts.shift();",
                    "    parts.unshift(\" \" + (parts.shift() || \"\"));",
                    "  }",
                    "",
                    "  return parts;",
                    "}",
                    "",
                    "function getFlowScalarLineContents(nodeType, content, options) {",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent, index, lineContents) =>",
                    "      index === 0 && index === lineContents.length - 1",
                    "        ? lineContent",
                    "        : index !== 0 && index !== lineContents.length - 1",
                    "        ? lineContent.trim()",
                    "        : index === 0",
                    "        ? lineContent.trimEnd()",
                    "        : lineContent.trimStart()",
                    "    );",
                    "",
                    "  if (options.proseWrap === \"preserve\") {",
                    "    return rawLineContents.map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : [lineContent]",
                    "    );",
                    "  }",
                    "",
                    "  return rawLineContents",
                    "    .map((lineContent) =>",
                    "      lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "    )",
                    "    .reduce(",
                    "      (reduced, lineContentWords, index) =>",
                    "        index !== 0 &&",
                    "        rawLineContents[index - 1].length > 0 &&",
                    "        lineContentWords.length > 0 &&",
                    "        !(",
                    "          // trailing backslash in quoteDouble should be preserved",
                    "          (nodeType === \"quoteDouble\" && reduced.at(-1).at(-1).endsWith(\"\\\\\"))",
                    "        )",
                    "          ? [...reduced.slice(0, -1), [...reduced.at(-1), ...lineContentWords]]",
                    "          : [...reduced, lineContentWords],",
                    "      []",
                    "    )",
                    "    .map((lineContentWords) =>",
                    "      options.proseWrap === \"never\"",
                    "        ? [lineContentWords.join(\" \")]",
                    "        : lineContentWords",
                    "    );",
                    "}",
                    "",
                    "function getBlockValueLineContents(",
                    "  node,",
                    "  { parentIndent, isLastDescendant, options }",
                    ") {",
                    "  const content =",
                    "    node.position.start.line === node.position.end.line",
                    "      ? \"\"",
                    "      : options.originalText",
                    "          .slice(node.position.start.offset, node.position.end.offset)",
                    "          // exclude open line `>` or `|`",
                    "          .match(/^[^\\n]*\\n(.*)$/s)[1];",
                    "",
                    "  let leadingSpaceCount;",
                    "  if (node.indent === null) {",
                    "    const matches = content.match(/^(?<leadingSpace> *)[^\\n\\r ]/m);",
                    "    leadingSpaceCount = matches",
                    "      ? matches.groups.leadingSpace.length",
                    "      : Number.POSITIVE_INFINITY;",
                    "  } else {",
                    "    leadingSpaceCount = node.indent - 1 + parentIndent;",
                    "  }",
                    "",
                    "  const rawLineContents = content",
                    "    .split(\"\\n\")",
                    "    .map((lineContent) => lineContent.slice(leadingSpaceCount));",
                    "",
                    "  if (options.proseWrap === \"preserve\" || node.type === \"blockLiteral\") {",
                    "    return removeUnnecessaryTrailingNewlines(",
                    "      rawLineContents.map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : [lineContent]",
                    "      )",
                    "    );",
                    "  }",
                    "",
                    "  return removeUnnecessaryTrailingNewlines(",
                    "    rawLineContents",
                    "      .map((lineContent) =>",
                    "        lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent)",
                    "      )",
                    "      .reduce(",
                    "        (reduced, lineContentWords, index) =>",
                    "          index !== 0 &&",
                    "          rawLineContents[index - 1].length > 0 &&",
                    "          lineContentWords.length > 0 &&",
                    "          !/^\\s/.test(lineContentWords[0]) &&",
                    "          !/^\\s|\\s$/.test(reduced.at(-1))",
                    "            ? [",
                    "                ...reduced.slice(0, -1),",
                    "                [...reduced.at(-1), ...lineContentWords],",
                    "              ]",
                    "            : [...reduced, lineContentWords],",
                    "        []",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        lineContentWords.reduce(",
                    "          (reduced, word) =>",
                    "            // disallow trailing spaces",
                    "            reduced.length > 0 && /\\s$/.test(reduced.at(-1))",
                    "              ? [...reduced.slice(0, -1), reduced.at(-1) + \" \" + word]",
                    "              : [...reduced, word],",
                    "          []",
                    "        )",
                    "      )",
                    "      .map((lineContentWords) =>",
                    "        options.proseWrap === \"never\"",
                    "          ? [lineContentWords.join(\" \")]",
                    "          : lineContentWords",
                    "      )",
                    "  );",
                    "",
                    "  function removeUnnecessaryTrailingNewlines(lineContents) {",
                    "    if (node.chomping === \"keep\") {",
                    "      return lineContents.at(-1).length === 0",
                    "        ? lineContents.slice(0, -1)",
                    "        : lineContents;",
                    "    }",
                    "",
                    "    let trailingNewlineCount = 0;",
                    "    for (let i = lineContents.length - 1; i >= 0; i--) {",
                    "      if (lineContents[i].length === 0) {",
                    "        trailingNewlineCount++;",
                    "      } else {",
                    "        break;",
                    "      }",
                    "    }",
                    "",
                    "    return trailingNewlineCount === 0",
                    "      ? lineContents",
                    "      : trailingNewlineCount >= 2 && !isLastDescendant",
                    "      ? // next empty line",
                    "        lineContents.slice(0, -(trailingNewlineCount - 1))",
                    "      : lineContents.slice(0, -trailingNewlineCount);",
                    "  }",
                    "}",
                    "",
                    "function isInlineNode(node) {",
                    "  /* c8 ignore next 3 */",
                    "  if (!node) {",
                    "    return true;",
                    "  }",
                    "",
                    "  switch (node.type) {",
                    "    case \"plain\":",
                    "    case \"quoteDouble\":",
                    "    case \"quoteSingle\":",
                    "    case \"alias\":",
                    "    case \"flowMapping\":",
                    "    case \"flowSequence\":",
                    "      return true;",
                    "    default:",
                    "      return false;",
                    "  }",
                    "}",
                    "",
                    "export {",
                    "  isNode,",
                    "  isEmptyNode,",
                    "  isInlineNode,",
                    "  mapNode,",
                    "  defineShortcut,",
                    "  isNextLineEmpty,",
                    "  isLastDescendantNode,",
                    "  getBlockValueLineContents,",
                    "  getFlowScalarLineContents,",
                    "  getLastDescendantNode,",
                    "  hasPrettierIgnore,",
                    "  hasLeadingComments,",
                    "  hasMiddleComments,",
                    "  hasIndicatorComment,",
                    "  hasTrailingComment,",
                    "  hasEndComments,",
                    "};"
                ]
            },
            "visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const visitorKeys = Object.fromEntries(",
                    "  Object.entries({",
                    "    root: [\"children\"],",
                    "    document: [\"head\", \"body\", \"children\"],",
                    "    documentHead: [\"children\"],",
                    "    documentBody: [\"children\"],",
                    "    directive: [],",
                    "    alias: [],",
                    "    blockLiteral: [],",
                    "    blockFolded: [\"children\"],",
                    "    plain: [\"children\"],",
                    "    quoteSingle: [],",
                    "    quoteDouble: [],",
                    "    mapping: [\"children\"],",
                    "    mappingItem: [\"key\", \"value\", \"children\"],",
                    "    mappingKey: [\"content\", \"children\"],",
                    "    mappingValue: [\"content\", \"children\"],",
                    "    sequence: [\"children\"],",
                    "    sequenceItem: [\"content\", \"children\"],",
                    "    flowMapping: [\"children\"],",
                    "    flowMappingItem: [\"key\", \"value\", \"children\"],",
                    "    flowSequence: [\"children\"],",
                    "    flowSequenceItem: [\"content\", \"children\"],",
                    "    comment: [],",
                    "    tag: [],",
                    "    anchor: [],",
                    "  }).map(([type, keys]) => [",
                    "    type,",
                    "    [",
                    "      ...keys,",
                    "      \"anchor\",",
                    "      \"tag\",",
                    "      \"indicatorComment\",",
                    "      \"leadingComments\",",
                    "      \"middleComments\",",
                    "      \"trailingComment\",",
                    "      \"endComments\",",
                    "    ],",
                    "  ])",
                    ");",
                    "",
                    "export default visitorKeys;"
                ]
            },
            "print": {
                "block.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "import {",
                        "  dedent,",
                        "  dedentToRoot,",
                        "  fill,",
                        "  hardline,",
                        "  join,",
                        "  line,",
                        "  literalline,",
                        "  markAsRoot,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  getBlockValueLineContents,",
                        "  hasIndicatorComment,",
                        "  isLastDescendantNode,",
                        "} from \"../utils.js\";",
                        "import { alignWithSpaces } from \"./misc.js\";",
                        "",
                        "function printBlock(path, print, options) {",
                        "  const { node } = path;",
                        "  const parentIndent = path.ancestors.filter(",
                        "    (node) => node.type === \"sequence\" || node.type === \"mapping\"",
                        "  ).length;",
                        "  const isLastDescendant = isLastDescendantNode(path);",
                        "  /** @type {Doc[]} */",
                        "  const parts = [node.type === \"blockFolded\" ? \">\" : \"|\"];",
                        "  if (node.indent !== null) {",
                        "    parts.push(node.indent.toString());",
                        "  }",
                        "",
                        "  if (node.chomping !== \"clip\") {",
                        "    parts.push(node.chomping === \"keep\" ? \"+\" : \"-\");",
                        "  }",
                        "",
                        "  if (hasIndicatorComment(node)) {",
                        "    parts.push(\" \", print(\"indicatorComment\"));",
                        "  }",
                        "",
                        "  const lineContents = getBlockValueLineContents(node, {",
                        "    parentIndent,",
                        "    isLastDescendant,",
                        "    options,",
                        "  });",
                        "  /** @type {Doc[]} */",
                        "  const contentsParts = [];",
                        "  for (const [index, lineWords] of lineContents.entries()) {",
                        "    if (index === 0) {",
                        "      contentsParts.push(hardline);",
                        "    }",
                        "    contentsParts.push(fill(join(line, lineWords)));",
                        "    if (index !== lineContents.length - 1) {",
                        "      contentsParts.push(",
                        "        lineWords.length === 0 ? hardline : markAsRoot(literalline)",
                        "      );",
                        "    } else if (node.chomping === \"keep\" && isLastDescendant) {",
                        "      contentsParts.push(",
                        "        dedentToRoot(lineWords.length === 0 ? hardline : literalline)",
                        "      );",
                        "    }",
                        "  }",
                        "  if (node.indent === null) {",
                        "    parts.push(dedent(alignWithSpaces(options.tabWidth, contentsParts)));",
                        "  } else {",
                        "    parts.push(",
                        "      dedentToRoot(",
                        "        alignWithSpaces(node.indent - 1 + parentIndent, contentsParts)",
                        "      )",
                        "    );",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "export default printBlock;"
                    ]
                },
                "flow-mapping-sequence.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  ifBreak,",
                        "  line,",
                        "  softline,",
                        "  hardline,",
                        "  join,",
                        "} from \"../../document/builders.js\";",
                        "import { isEmptyNode, hasEndComments } from \"../utils.js\";",
                        "import { printNextEmptyLine, alignWithSpaces } from \"./misc.js\";",
                        "",
                        "function printFlowMapping(path, print, options) {",
                        "  const { node } = path;",
                        "  const isMapping = node.type === \"flowMapping\";",
                        "  const openMarker = isMapping ? \"{\" : \"[\";",
                        "  const closeMarker = isMapping ? \"}\" : \"]\";",
                        "",
                        "  /** @type {softline | line} */",
                        "  let bracketSpacing = softline;",
                        "  if (isMapping && node.children.length > 0 && options.bracketSpacing) {",
                        "    bracketSpacing = line;",
                        "  }",
                        "  const lastItem = node.children.at(-1);",
                        "  const isLastItemEmptyMappingItem =",
                        "    lastItem?.type === \"flowMappingItem\" &&",
                        "    isEmptyNode(lastItem.key) &&",
                        "    isEmptyNode(lastItem.value);",
                        "",
                        "  return [",
                        "    openMarker,",
                        "    alignWithSpaces(options.tabWidth, [",
                        "      bracketSpacing,",
                        "      printChildren(path, print, options),",
                        "      options.trailingComma === \"none\" ? \"\" : ifBreak(\",\"),",
                        "      hasEndComments(node)",
                        "        ? [hardline, join(hardline, path.map(print, \"endComments\"))]",
                        "        : \"\",",
                        "    ]),",
                        "    isLastItemEmptyMappingItem ? \"\" : bracketSpacing,",
                        "    closeMarker,",
                        "  ];",
                        "}",
                        "",
                        "function printChildren(path, print, options) {",
                        "  return path.map(",
                        "    ({ isLast, node, next }) => [",
                        "      print(),",
                        "      isLast",
                        "        ? \"\"",
                        "        : [",
                        "            \",\",",
                        "            line,",
                        "            node.position.start.line !== next.position.start.line",
                        "              ? printNextEmptyLine(path, options.originalText)",
                        "              : \"\",",
                        "          ],",
                        "    ],",
                        "    \"children\"",
                        "  );",
                        "}",
                        "",
                        "export {",
                        "  printFlowMapping,",
                        "  // Alias",
                        "  printFlowMapping as printFlowSequence,",
                        "};"
                    ]
                },
                "mapping-item.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/** @typedef {import(\"../../document/builders.js\").Doc} Doc */",
                        "",
                        "import {",
                        "  conditionalGroup,",
                        "  group,",
                        "  hardline,",
                        "  ifBreak,",
                        "  line,",
                        "} from \"../../document/builders.js\";",
                        "import {",
                        "  hasLeadingComments,",
                        "  hasMiddleComments,",
                        "  hasTrailingComment,",
                        "  hasEndComments,",
                        "  isNode,",
                        "  isEmptyNode,",
                        "  isInlineNode,",
                        "} from \"../utils.js\";",
                        "import { alignWithSpaces } from \"./misc.js\";",
                        "",
                        "function printMappingItem(path, print, options) {",
                        "  const { node, parent } = path;",
                        "  const { key, value } = node;",
                        "",
                        "  const isEmptyMappingKey = isEmptyNode(key);",
                        "  const isEmptyMappingValue = isEmptyNode(value);",
                        "",
                        "  if (isEmptyMappingKey && isEmptyMappingValue) {",
                        "    return \": \";",
                        "  }",
                        "",
                        "  const printedKey = print(\"key\");",
                        "  const spaceBeforeColon = needsSpaceInFrontOfMappingValue(node) ? \" \" : \"\";",
                        "",
                        "  if (isEmptyMappingValue) {",
                        "    if (node.type === \"flowMappingItem\" && parent.type === \"flowMapping\") {",
                        "      return printedKey;",
                        "    }",
                        "",
                        "    if (",
                        "      node.type === \"mappingItem\" &&",
                        "      isAbsolutelyPrintedAsSingleLineNode(key.content, options) &&",
                        "      !hasTrailingComment(key.content) &&",
                        "      parent.tag?.value !== \"tag:yaml.org,2002:set\"",
                        "    ) {",
                        "      return [printedKey, spaceBeforeColon, \":\"];",
                        "    }",
                        "",
                        "    return [\"? \", alignWithSpaces(2, printedKey)];",
                        "  }",
                        "",
                        "  const printedValue = print(\"value\");",
                        "  if (isEmptyMappingKey) {",
                        "    return [\": \", alignWithSpaces(2, printedValue)];",
                        "  }",
                        "",
                        "  // force explicit Key",
                        "  if (hasLeadingComments(value) || !isInlineNode(key.content)) {",
                        "    return [",
                        "      \"? \",",
                        "      alignWithSpaces(2, printedKey),",
                        "      hardline,",
                        "      ...path.map(() => [print(), hardline], \"value\", \"leadingComments\"),",
                        "      \": \",",
                        "      alignWithSpaces(2, printedValue),",
                        "    ];",
                        "  }",
                        "",
                        "  // force singleline",
                        "  if (",
                        "    isSingleLineNode(key.content) &&",
                        "    !hasLeadingComments(key.content) &&",
                        "    !hasMiddleComments(key.content) &&",
                        "    !hasTrailingComment(key.content) &&",
                        "    !hasEndComments(key) &&",
                        "    !hasLeadingComments(value.content) &&",
                        "    !hasMiddleComments(value.content) &&",
                        "    !hasEndComments(value) &&",
                        "    isAbsolutelyPrintedAsSingleLineNode(value.content, options)",
                        "  ) {",
                        "    return [printedKey, spaceBeforeColon, \": \", printedValue];",
                        "  }",
                        "",
                        "  const groupId = Symbol(\"mappingKey\");",
                        "  const groupedKey = group([",
                        "    ifBreak(\"? \"),",
                        "    group(alignWithSpaces(2, printedKey), { id: groupId }),",
                        "  ]);",
                        "",
                        "  // Construct both explicit and implicit mapping values.",
                        "  const explicitMappingValue = [",
                        "    hardline,",
                        "    \": \",",
                        "    alignWithSpaces(2, printedValue),",
                        "  ];",
                        "  /** @type {Doc[]} */",
                        "  // In the implicit case, it's convenient to treat everything from the key's colon",
                        "  // as part of the mapping value",
                        "  const implicitMappingValueParts = [spaceBeforeColon, \":\"];",
                        "  if (",
                        "    hasLeadingComments(value.content) ||",
                        "    (hasEndComments(value) &&",
                        "      value.content &&",
                        "      !isNode(value.content, [\"mapping\", \"sequence\"])) ||",
                        "    (parent.type === \"mapping\" &&",
                        "      hasTrailingComment(key.content) &&",
                        "      isInlineNode(value.content)) ||",
                        "    (isNode(value.content, [\"mapping\", \"sequence\"]) &&",
                        "      value.content.tag === null &&",
                        "      value.content.anchor === null)",
                        "  ) {",
                        "    implicitMappingValueParts.push(hardline);",
                        "  } else if (value.content) {",
                        "    implicitMappingValueParts.push(line);",
                        "  }",
                        "  implicitMappingValueParts.push(printedValue);",
                        "  const implicitMappingValue = alignWithSpaces(",
                        "    options.tabWidth,",
                        "    implicitMappingValueParts",
                        "  );",
                        "",
                        "  // If a key is definitely single-line, forcibly use implicit style to avoid edge cases (very long",
                        "  // keys) that would otherwise trigger explicit style as if it was multiline.",
                        "  // In those cases, explicit style makes the line even longer and causes confusion.",
                        "  if (",
                        "    isAbsolutelyPrintedAsSingleLineNode(key.content, options) &&",
                        "    !hasLeadingComments(key.content) &&",
                        "    !hasMiddleComments(key.content) &&",
                        "    !hasEndComments(key)",
                        "  ) {",
                        "    return conditionalGroup([[printedKey, implicitMappingValue]]);",
                        "  }",
                        "",
                        "  // Use explicit mapping syntax if the key breaks, implicit otherwise",
                        "  return conditionalGroup([",
                        "    [",
                        "      groupedKey,",
                        "      ifBreak(explicitMappingValue, implicitMappingValue, { groupId }),",
                        "    ],",
                        "  ]);",
                        "}",
                        "",
                        "function isAbsolutelyPrintedAsSingleLineNode(node, options) {",
                        "  if (!node) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"plain\":",
                        "    case \"quoteSingle\":",
                        "    case \"quoteDouble\":",
                        "      break;",
                        "    case \"alias\":",
                        "      return true;",
                        "",
                        "    default:",
                        "      return false;",
                        "  }",
                        "",
                        "  if (options.proseWrap === \"preserve\") {",
                        "    return node.position.start.line === node.position.end.line;",
                        "  }",
                        "",
                        "  if (",
                        "    // backslash-newline",
                        "    /\\\\$/m.test(",
                        "      options.originalText.slice(",
                        "        node.position.start.offset,",
                        "        node.position.end.offset",
                        "      )",
                        "    )",
                        "  ) {",
                        "    return false;",
                        "  }",
                        "",
                        "  switch (options.proseWrap) {",
                        "    case \"never\":",
                        "      return !node.value.includes(\"\\n\");",
                        "    case \"always\":",
                        "      return !/[\\n ]/.test(node.value);",
                        "    default:",
                        "      /* c8 ignore next */",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "function needsSpaceInFrontOfMappingValue(node) {",
                        "  return node.key.content?.type === \"alias\";",
                        "}",
                        "",
                        "function isSingleLineNode(node) {",
                        "  /* c8 ignore next 3 */",
                        "  if (!node) {",
                        "    return true;",
                        "  }",
                        "",
                        "  switch (node.type) {",
                        "    case \"plain\":",
                        "    case \"quoteDouble\":",
                        "    case \"quoteSingle\":",
                        "      return node.position.start.line === node.position.end.line;",
                        "    case \"alias\":",
                        "      return true;",
                        "    default:",
                        "      return false;",
                        "  }",
                        "}",
                        "",
                        "export default printMappingItem;"
                    ]
                },
                "misc.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { softline, align } from \"../../document/builders.js\";",
                        "import { hasEndComments, isNextLineEmpty, isNode } from \"../utils.js\";",
                        "",
                        "const printedEmptyLineCache = new WeakMap();",
                        "function printNextEmptyLine(path, originalText) {",
                        "  const { node, root } = path;",
                        "",
                        "  let isNextEmptyLinePrintedSet;",
                        "  if (printedEmptyLineCache.has(root)) {",
                        "    isNextEmptyLinePrintedSet = printedEmptyLineCache.get(root);",
                        "  } else {",
                        "    isNextEmptyLinePrintedSet = new Set();",
                        "    printedEmptyLineCache.set(root, isNextEmptyLinePrintedSet);",
                        "  }",
                        "",
                        "  if (!isNextEmptyLinePrintedSet.has(node.position.end.line)) {",
                        "    isNextEmptyLinePrintedSet.add(node.position.end.line);",
                        "    if (",
                        "      isNextLineEmpty(node, originalText) &&",
                        "      !shouldPrintEndComments(path.parent)",
                        "    ) {",
                        "      return softline;",
                        "    }",
                        "  }",
                        "",
                        "  return \"\";",
                        "}",
                        "",
                        "function shouldPrintEndComments(node) {",
                        "  return (",
                        "    hasEndComments(node) &&",
                        "    !isNode(node, [",
                        "      \"documentHead\",",
                        "      \"documentBody\",",
                        "      \"flowMapping\",",
                        "      \"flowSequence\",",
                        "    ])",
                        "  );",
                        "}",
                        "",
                        "function alignWithSpaces(width, doc) {",
                        "  return align(\" \".repeat(width), doc);",
                        "}",
                        "",
                        "export { alignWithSpaces, shouldPrintEndComments, printNextEmptyLine };"
                    ]
                }
            }
        },
        "main": {
            "ast-to-doc.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import AstPath from \"../common/ast-path.js\";",
                    "import { cursor } from \"../document/builders.js\";",
                    "import { inheritLabel } from \"../document/utils.js\";",
                    "import { attachComments } from \"./comments/attach.js\";",
                    "import { printComments, ensureAllCommentsPrinted } from \"./comments/print.js\";",
                    "import { printEmbeddedLanguages } from \"./multiparser.js\";",
                    "import createPrintPreCheckFunction from \"./create-print-pre-check-function.js\";",
                    "import printIgnored from \"./print-ignored.js\";",
                    "",
                    "/**",
                    " * Takes an abstract syntax tree (AST) and recursively converts it to a",
                    " * document (series of printing primitives).",
                    " *",
                    " * This is done by descending down the AST recursively. The recursion",
                    " * involves two functions that call each other:",
                    " *",
                    " * 1. mainPrint(), which is defined as an inner function here.",
                    " *    It basically takes care of node caching.",
                    " * 2. callPluginPrintFunction(), which checks for some options, and",
                    " *    ultimately calls the print() function provided by the plugin.",
                    " *",
                    " * The plugin function will call mainPrint() again for child nodes",
                    " * of the current node. mainPrint() will do its housekeeping, then call",
                    " * the plugin function again, and so on.",
                    " *",
                    " * All the while, these functions pass a \"path\" variable around, which",
                    " * is a stack-like data structure (AstPath) that maintains the current",
                    " * state of the recursion. It is called \"path\", because it represents",
                    " * the path to the current node through the Abstract Syntax Tree.",
                    " */",
                    "async function printAstToDoc(ast, options) {",
                    "  ({ ast } = await prepareToPrint(ast, options));",
                    "",
                    "  const cache = new Map();",
                    "  const path = new AstPath(ast);",
                    "",
                    "  const ensurePrintingNode = createPrintPreCheckFunction(options);",
                    "  const embeds = new Map();",
                    "",
                    "  await printEmbeddedLanguages(path, mainPrint, options, printAstToDoc, embeds);",
                    "",
                    "  // Only the root call of the print method is awaited.",
                    "  // This is done to make things simpler for plugins that don't use recursive printing.",
                    "  const doc = await callPluginPrintFunction(",
                    "    path,",
                    "    options,",
                    "    mainPrint,",
                    "    undefined,",
                    "    embeds",
                    "  );",
                    "",
                    "  ensureAllCommentsPrinted(options);",
                    "",
                    "  return doc;",
                    "",
                    "  function mainPrint(selector, args) {",
                    "    if (selector === undefined || selector === path) {",
                    "      return mainPrintInternal(args);",
                    "    }",
                    "",
                    "    if (Array.isArray(selector)) {",
                    "      return path.call(() => mainPrintInternal(args), ...selector);",
                    "    }",
                    "",
                    "    return path.call(() => mainPrintInternal(args), selector);",
                    "  }",
                    "",
                    "  function mainPrintInternal(args) {",
                    "    ensurePrintingNode(path);",
                    "",
                    "    const value = path.node;",
                    "",
                    "    if (value === undefined || value === null) {",
                    "      return \"\";",
                    "    }",
                    "",
                    "    const shouldCache =",
                    "      value && typeof value === \"object\" && args === undefined;",
                    "",
                    "    if (shouldCache && cache.has(value)) {",
                    "      return cache.get(value);",
                    "    }",
                    "",
                    "    const doc = callPluginPrintFunction(path, options, mainPrint, args, embeds);",
                    "",
                    "    if (shouldCache) {",
                    "      cache.set(value, doc);",
                    "    }",
                    "",
                    "    return doc;",
                    "  }",
                    "}",
                    "",
                    "function callPluginPrintFunction(path, options, printPath, args, embeds) {",
                    "  const { node } = path;",
                    "  const { printer } = options;",
                    "",
                    "  let doc;",
                    "",
                    "  // Escape hatch",
                    "  if (printer.hasPrettierIgnore?.(path)) {",
                    "    doc = printIgnored(path, options);",
                    "  } else if (embeds.has(node)) {",
                    "    doc = embeds.get(node);",
                    "  } else {",
                    "    doc = printer.print(path, options, printPath, args);",
                    "  }",
                    "",
                    "  // We let JSXElement print its comments itself because it adds () around",
                    "  // UnionTypeAnnotation has to align the child without the comments",
                    "  if (",
                    "    printer.printComment &&",
                    "    (!printer.willPrintOwnComments ||",
                    "      !printer.willPrintOwnComments(path, options))",
                    "  ) {",
                    "    // printComments will call the plugin print function and check for",
                    "    // comments to print",
                    "    doc = printComments(path, doc, options);",
                    "  }",
                    "",
                    "  if (node === options.cursorNode) {",
                    "    doc = inheritLabel(doc, (doc) => [cursor, doc, cursor]);",
                    "  }",
                    "",
                    "  return doc;",
                    "}",
                    "",
                    "async function prepareToPrint(ast, options) {",
                    "  const comments = ast.comments ?? [];",
                    "  options[Symbol.for(\"comments\")] = comments;",
                    "  options[Symbol.for(\"tokens\")] = ast.tokens ?? [];",
                    "  // For JS printer to ignore attached comments",
                    "  options[Symbol.for(\"printedComments\")] = new Set();",
                    "",
                    "  attachComments(ast, options);",
                    "",
                    "  const {",
                    "    printer: { preprocess },",
                    "  } = options;",
                    "",
                    "  ast = preprocess ? await preprocess(ast, options) : ast;",
                    "",
                    "  return { ast, comments };",
                    "}",
                    "",
                    "export { printAstToDoc, prepareToPrint };"
                ]
            },
            "core-options.evaluate.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { outdent } from \"outdent\";",
                    "import {",
                    "  CATEGORY_CONFIG,",
                    "  CATEGORY_EDITOR,",
                    "  CATEGORY_OTHER,",
                    "  CATEGORY_GLOBAL,",
                    "  CATEGORY_SPECIAL,",
                    "} from \"./option-categories.js\";",
                    "",
                    "/**",
                    " * @typedef {Object} OptionInfo",
                    " * @property {string} category",
                    " * @property {'int' | 'boolean' | 'choice' | 'path' | 'string' | 'flag'} type",
                    " * @property {boolean} [array] - indicate it's an array of the specified type",
                    " * @property {OptionValueInfo} [default]",
                    " * @property {OptionRangeInfo} [range] - for type int",
                    " * @property {string} description",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionRedirectInfo} [redirect] - redirect deprecated option",
                    " * @property {(value: any) => boolean} [exception]",
                    " * @property {OptionChoiceInfo[]} [choices] - for type choice",
                    " * @property {string} [cliName]",
                    " * @property {string} [cliCategory]",
                    " * @property {string} [cliDescription]",
                    " *",
                    " * @typedef {number | boolean | string | []} OptionValue",
                    " * @typedef {OptionValue | [{ value: OptionValue }]} OptionValueInfo",
                    " *",
                    " * @typedef {Object} OptionRedirectInfo",
                    " * @property {string} option",
                    " * @property {OptionValue} value",
                    " *",
                    " * @typedef {Object} OptionRangeInfo",
                    " * @property {number} start - recommended range start",
                    " * @property {number} end - recommended range end",
                    " * @property {number} step - recommended range step",
                    " *",
                    " * @typedef {Object} OptionChoiceInfo",
                    " * @property {boolean | string} value - boolean for the option that is originally boolean type",
                    " * @property {string} description",
                    " * @property {string} [deprecated] - deprecated since version",
                    " * @property {OptionValueInfo} [redirect] - redirect deprecated value",
                    " */",
                    "",
                    "/** @type {{ [name: string]: OptionInfo }} */",
                    "const options = {",
                    "  cursorOffset: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: -1,",
                    "    range: { start: -1, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Print (to stderr) where a cursor at the given position would move to after formatting.",
                    "      This option cannot be used with --range-start and --range-end.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  endOfLine: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: \"lf\",",
                    "    description: \"Which end of line characters to apply.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"lf\",",
                    "        description:",
                    "          \"Line Feed only (\\\\n), common on Linux and macOS as well as inside git repos\",",
                    "      },",
                    "      {",
                    "        value: \"crlf\",",
                    "        description:",
                    "          \"Carriage Return + Line Feed characters (\\\\r\\\\n), common on Windows\",",
                    "      },",
                    "      {",
                    "        value: \"cr\",",
                    "        description: \"Carriage Return character only (\\\\r), used very rarely\",",
                    "      },",
                    "      {",
                    "        value: \"auto\",",
                    "        description: outdent`",
                    "          Maintain existing",
                    "          (mixed values within one file are normalised by looking at what's used after the first line)",
                    "        `,",
                    "      },",
                    "    ],",
                    "  },",
                    "  filepath: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"path\",",
                    "    description:",
                    "      \"Specify the input filepath. This will be used to do parser inference.\",",
                    "    cliName: \"stdin-filepath\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "    cliDescription: \"Path to the file to pretend that stdin comes from.\",",
                    "  },",
                    "  insertPragma: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Insert @format pragma into file's first docblock comment.\",",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  parser: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: undefined,",
                    "    description: \"Which parser to use.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"function\",",
                    "    choices: [",
                    "      { value: \"flow\", description: \"Flow\" },",
                    "      { value: \"babel\", description: \"JavaScript\" },",
                    "      { value: \"babel-flow\", description: \"Flow\" },",
                    "      { value: \"babel-ts\", description: \"TypeScript\" },",
                    "      { value: \"typescript\", description: \"TypeScript\" },",
                    "      { value: \"acorn\", description: \"JavaScript\" },",
                    "      { value: \"espree\", description: \"JavaScript\" },",
                    "      { value: \"meriyah\", description: \"JavaScript\" },",
                    "      { value: \"css\", description: \"CSS\" },",
                    "      { value: \"less\", description: \"Less\" },",
                    "      { value: \"scss\", description: \"SCSS\" },",
                    "      { value: \"json\", description: \"JSON\" },",
                    "      { value: \"json5\", description: \"JSON5\" },",
                    "      { value: \"json-stringify\", description: \"JSON.stringify\" },",
                    "      { value: \"graphql\", description: \"GraphQL\" },",
                    "      { value: \"markdown\", description: \"Markdown\" },",
                    "      { value: \"mdx\", description: \"MDX\" },",
                    "      { value: \"vue\", description: \"Vue\" },",
                    "      { value: \"yaml\", description: \"YAML\" },",
                    "      { value: \"glimmer\", description: \"Ember / Handlebars\" },",
                    "      { value: \"html\", description: \"HTML\" },",
                    "      { value: \"angular\", description: \"Angular\" },",
                    "      { value: \"lwc\", description: \"Lightning Web Components\" },",
                    "    ],",
                    "  },",
                    "  plugins: {",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description:",
                    "      \"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.\",",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  pluginSearchDirs: {",
                    "    type: \"path\",",
                    "    array: true,",
                    "    default: [{ value: [] }],",
                    "    category: CATEGORY_GLOBAL,",
                    "    description: outdent`",
                    "      Custom directory that contains prettier plugins in node_modules subdirectory.",
                    "      Overrides default behavior when plugins are searched relatively to the location of Prettier.",
                    "      Multiple values are accepted.",
                    "    `,",
                    "    exception: (value) =>",
                    "      typeof value === \"string\" || typeof value === \"object\",",
                    "    cliName: \"plugin-search-dir\",",
                    "    cliCategory: CATEGORY_CONFIG,",
                    "  },",
                    "  printWidth: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"int\",",
                    "    default: 80,",
                    "    description: \"The line length where Prettier will try wrap.\",",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "  },",
                    "  rangeEnd: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: Number.POSITIVE_INFINITY,",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Format code ending at a given character offset (exclusive).",
                    "      The range will extend forwards to the end of the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  rangeStart: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"int\",",
                    "    default: 0,",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "    description: outdent`",
                    "      Format code starting at a given character offset.",
                    "      The range will extend backwards to the start of the first line containing the selected statement.",
                    "      This option cannot be used with --cursor-offset.",
                    "    `,",
                    "    cliCategory: CATEGORY_EDITOR,",
                    "  },",
                    "  requirePragma: {",
                    "    category: CATEGORY_SPECIAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: outdent`",
                    "      Require either '@prettier' or '@format' to be present in the file's first docblock comment",
                    "      in order for it to be formatted.",
                    "    `,",
                    "    cliCategory: CATEGORY_OTHER,",
                    "  },",
                    "  tabWidth: {",
                    "    type: \"int\",",
                    "    category: CATEGORY_GLOBAL,",
                    "    default: 2,",
                    "    description: \"Number of spaces per indentation level.\",",
                    "    range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 },",
                    "  },",
                    "  useTabs: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"boolean\",",
                    "    default: false,",
                    "    description: \"Indent with tabs instead of spaces.\",",
                    "  },",
                    "  embeddedLanguageFormatting: {",
                    "    category: CATEGORY_GLOBAL,",
                    "    type: \"choice\",",
                    "    default: \"auto\",",
                    "    description:",
                    "      \"Control how Prettier formats quoted code embedded in the file.\",",
                    "    choices: [",
                    "      {",
                    "        value: \"auto\",",
                    "        description:",
                    "          \"Format embedded code if Prettier can automatically identify it.\",",
                    "      },",
                    "      {",
                    "        value: \"off\",",
                    "        description: \"Never automatically format embedded code.\",",
                    "      },",
                    "    ],",
                    "  },",
                    "};",
                    "",
                    "export default options;"
                ]
            },
            "core.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { diffArrays } from \"diff\";",
                    "",
                    "import { hardline, addAlignmentToDoc } from \"../document/builders.js\";",
                    "import { printDocToString as printDocToStringWithoutNormalizeOptions } from \"../document/printer.js\";",
                    "import { printDocToDebug } from \"../document/debug.js\";",
                    "import getAlignmentSize from \"../utils/get-alignment-size.js\";",
                    "import {",
                    "  guessEndOfLine,",
                    "  convertEndOfLineToChars,",
                    "  countEndOfLineChars,",
                    "  normalizeEndOfLine,",
                    "} from \"../common/end-of-line.js\";",
                    "import normalizeFormatOptions from \"./normalize-format-options.js\";",
                    "import massageAst from \"./massage-ast.js\";",
                    "import { resolveParser } from \"./parser-and-printer.js\";",
                    "import parseText from \"./parse.js\";",
                    "import { printAstToDoc, prepareToPrint } from \"./ast-to-doc.js\";",
                    "import { calculateRange } from \"./range-util.js\";",
                    "import getCursorNode from \"./get-cursor-node.js\";",
                    "",
                    "const BOM = \"\\uFEFF\";",
                    "",
                    "const CURSOR = Symbol(\"cursor\");",
                    "",
                    "async function coreFormat(originalText, opts, addAlignmentSize = 0) {",
                    "  if (!originalText || originalText.trim().length === 0) {",
                    "    return { formatted: \"\", cursorOffset: -1, comments: [] };",
                    "  }",
                    "",
                    "  const { ast, text } = await parseText(originalText, opts);",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    opts.cursorNode = getCursorNode(ast, opts);",
                    "  }",
                    "",
                    "  let doc = await printAstToDoc(ast, opts, addAlignmentSize);",
                    "",
                    "  if (addAlignmentSize > 0) {",
                    "    // Add a hardline to make the indents take effect, it will be removed later",
                    "    doc = addAlignmentToDoc([hardline, doc], addAlignmentSize, opts.tabWidth);",
                    "  }",
                    "",
                    "  const result = printDocToStringWithoutNormalizeOptions(doc, opts);",
                    "",
                    "  // Remove extra leading indentation as well as the added indentation after last newline",
                    "  if (addAlignmentSize > 0) {",
                    "    const trimmed = result.formatted.trim();",
                    "",
                    "    if (result.cursorNodeStart !== undefined) {",
                    "      result.cursorNodeStart -= result.formatted.indexOf(trimmed);",
                    "    }",
                    "",
                    "    result.formatted = trimmed + convertEndOfLineToChars(opts.endOfLine);",
                    "  }",
                    "",
                    "  const comments = opts[Symbol.for(\"comments\")];",
                    "",
                    "  if (opts.cursorOffset >= 0) {",
                    "    let oldCursorNodeStart;",
                    "    let oldCursorNodeText;",
                    "",
                    "    let cursorOffsetRelativeToOldCursorNode;",
                    "",
                    "    let newCursorNodeStart;",
                    "    let newCursorNodeText;",
                    "",
                    "    if (opts.cursorNode && result.cursorNodeText) {",
                    "      oldCursorNodeStart = opts.locStart(opts.cursorNode);",
                    "      oldCursorNodeText = text.slice(",
                    "        oldCursorNodeStart,",
                    "        opts.locEnd(opts.cursorNode)",
                    "      );",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode =",
                    "        opts.cursorOffset - oldCursorNodeStart;",
                    "",
                    "      newCursorNodeStart = result.cursorNodeStart;",
                    "      newCursorNodeText = result.cursorNodeText;",
                    "    } else {",
                    "      oldCursorNodeStart = 0;",
                    "      oldCursorNodeText = text;",
                    "",
                    "      cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;",
                    "",
                    "      newCursorNodeStart = 0;",
                    "      newCursorNodeText = result.formatted;",
                    "    }",
                    "",
                    "    if (oldCursorNodeText === newCursorNodeText) {",
                    "      return {",
                    "        formatted: result.formatted,",
                    "        cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode,",
                    "        comments,",
                    "      };",
                    "    }",
                    "",
                    "    // diff old and new cursor node texts, with a special cursor",
                    "    // symbol inserted to find out where it moves to",
                    "",
                    "    // eslint-disable-next-line unicorn/prefer-spread",
                    "    const oldCursorNodeCharArray = oldCursorNodeText.split(\"\");",
                    "    oldCursorNodeCharArray.splice(",
                    "      cursorOffsetRelativeToOldCursorNode,",
                    "      0,",
                    "      CURSOR",
                    "    );",
                    "",
                    "    // eslint-disable-next-line unicorn/prefer-spread",
                    "    const newCursorNodeCharArray = newCursorNodeText.split(\"\");",
                    "",
                    "    const cursorNodeDiff = diffArrays(",
                    "      oldCursorNodeCharArray,",
                    "      newCursorNodeCharArray",
                    "    );",
                    "",
                    "    let cursorOffset = newCursorNodeStart;",
                    "    for (const entry of cursorNodeDiff) {",
                    "      if (entry.removed) {",
                    "        if (entry.value.includes(CURSOR)) {",
                    "          break;",
                    "        }",
                    "      } else {",
                    "        cursorOffset += entry.count;",
                    "      }",
                    "    }",
                    "",
                    "    return { formatted: result.formatted, cursorOffset, comments };",
                    "  }",
                    "",
                    "  return { formatted: result.formatted, cursorOffset: -1, comments };",
                    "}",
                    "",
                    "async function formatRange(originalText, opts) {",
                    "  const { ast, text } = await parseText(originalText, opts);",
                    "  const { rangeStart, rangeEnd } = calculateRange(text, opts, ast);",
                    "  const rangeString = text.slice(rangeStart, rangeEnd);",
                    "",
                    "  // Try to extend the range backwards to the beginning of the line.",
                    "  // This is so we can detect indentation correctly and restore it.",
                    "  // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0",
                    "  const rangeStart2 = Math.min(",
                    "    rangeStart,",
                    "    text.lastIndexOf(\"\\n\", rangeStart) + 1",
                    "  );",
                    "  const indentString = text.slice(rangeStart2, rangeStart).match(/^\\s*/)[0];",
                    "",
                    "  const alignmentSize = getAlignmentSize(indentString, opts.tabWidth);",
                    "",
                    "  const rangeResult = await coreFormat(",
                    "    rangeString,",
                    "    {",
                    "      ...opts,",
                    "      rangeStart: 0,",
                    "      rangeEnd: Number.POSITIVE_INFINITY,",
                    "      // Track the cursor offset only if it's within our range",
                    "      cursorOffset:",
                    "        opts.cursorOffset > rangeStart && opts.cursorOffset <= rangeEnd",
                    "          ? opts.cursorOffset - rangeStart",
                    "          : -1,",
                    "      // Always use `lf` to format, we'll replace it later",
                    "      endOfLine: \"lf\",",
                    "    },",
                    "    alignmentSize",
                    "  );",
                    "",
                    "  // Since the range contracts to avoid trailing whitespace,",
                    "  // we need to remove the newline that was inserted by the `format` call.",
                    "  const rangeTrimmed = rangeResult.formatted.trimEnd();",
                    "",
                    "  let { cursorOffset } = opts;",
                    "  if (cursorOffset > rangeEnd) {",
                    "    // handle the case where the cursor was past the end of the range",
                    "    cursorOffset += rangeTrimmed.length - rangeString.length;",
                    "  } else if (rangeResult.cursorOffset >= 0) {",
                    "    // handle the case where the cursor was in the range",
                    "    cursorOffset = rangeResult.cursorOffset + rangeStart;",
                    "  }",
                    "  // keep the cursor as it was if it was before the start of the range",
                    "",
                    "  let formatted =",
                    "    text.slice(0, rangeStart) + rangeTrimmed + text.slice(rangeEnd);",
                    "  if (opts.endOfLine !== \"lf\") {",
                    "    const eol = convertEndOfLineToChars(opts.endOfLine);",
                    "    if (cursorOffset >= 0 && eol === \"\\r\\n\") {",
                    "      cursorOffset += countEndOfLineChars(",
                    "        formatted.slice(0, cursorOffset),",
                    "        \"\\n\"",
                    "      );",
                    "    }",
                    "",
                    "    formatted = formatted.replaceAll(\"\\n\", eol);",
                    "  }",
                    "",
                    "  return { formatted, cursorOffset, comments: rangeResult.comments };",
                    "}",
                    "",
                    "function ensureIndexInText(text, index, defaultValue) {",
                    "  if (",
                    "    typeof index !== \"number\" ||",
                    "    Number.isNaN(index) ||",
                    "    index < 0 ||",
                    "    index > text.length",
                    "  ) {",
                    "    return defaultValue;",
                    "  }",
                    "",
                    "  return index;",
                    "}",
                    "",
                    "function normalizeIndexes(text, options) {",
                    "  let { cursorOffset, rangeStart, rangeEnd } = options;",
                    "  cursorOffset = ensureIndexInText(text, cursorOffset, -1);",
                    "  rangeStart = ensureIndexInText(text, rangeStart, 0);",
                    "  rangeEnd = ensureIndexInText(text, rangeEnd, text.length);",
                    "",
                    "  return { ...options, cursorOffset, rangeStart, rangeEnd };",
                    "}",
                    "",
                    "function normalizeInputAndOptions(text, options) {",
                    "  let { cursorOffset, rangeStart, rangeEnd, endOfLine } = normalizeIndexes(",
                    "    text,",
                    "    options",
                    "  );",
                    "",
                    "  const hasBOM = text.charAt(0) === BOM;",
                    "",
                    "  if (hasBOM) {",
                    "    text = text.slice(1);",
                    "    cursorOffset--;",
                    "    rangeStart--;",
                    "    rangeEnd--;",
                    "  }",
                    "",
                    "  if (endOfLine === \"auto\") {",
                    "    endOfLine = guessEndOfLine(text);",
                    "  }",
                    "",
                    "  // get rid of CR/CRLF parsing",
                    "  if (text.includes(\"\\r\")) {",
                    "    const countCrlfBefore = (index) =>",
                    "      countEndOfLineChars(text.slice(0, Math.max(index, 0)), \"\\r\\n\");",
                    "",
                    "    cursorOffset -= countCrlfBefore(cursorOffset);",
                    "    rangeStart -= countCrlfBefore(rangeStart);",
                    "    rangeEnd -= countCrlfBefore(rangeEnd);",
                    "",
                    "    text = normalizeEndOfLine(text);",
                    "  }",
                    "",
                    "  return {",
                    "    hasBOM,",
                    "    text,",
                    "    options: normalizeIndexes(text, {",
                    "      ...options,",
                    "      cursorOffset,",
                    "      rangeStart,",
                    "      rangeEnd,",
                    "      endOfLine,",
                    "    }),",
                    "  };",
                    "}",
                    "",
                    "async function hasPragma(text, options) {",
                    "  const selectedParser = await resolveParser(options);",
                    "  return !selectedParser.hasPragma || selectedParser.hasPragma(text);",
                    "}",
                    "",
                    "async function formatWithCursor(originalText, originalOptions) {",
                    "  let { hasBOM, text, options } = normalizeInputAndOptions(",
                    "    originalText,",
                    "    await normalizeFormatOptions(originalOptions)",
                    "  );",
                    "",
                    "  if (",
                    "    (options.rangeStart >= options.rangeEnd && text !== \"\") ||",
                    "    (options.requirePragma && !(await hasPragma(text, options)))",
                    "  ) {",
                    "    return {",
                    "      formatted: originalText,",
                    "      cursorOffset: originalOptions.cursorOffset,",
                    "      comments: [],",
                    "    };",
                    "  }",
                    "",
                    "  let result;",
                    "",
                    "  if (options.rangeStart > 0 || options.rangeEnd < text.length) {",
                    "    result = await formatRange(text, options);",
                    "  } else {",
                    "    if (",
                    "      !options.requirePragma &&",
                    "      options.insertPragma &&",
                    "      options.printer.insertPragma &&",
                    "      !(await hasPragma(text, options))",
                    "    ) {",
                    "      text = options.printer.insertPragma(text);",
                    "    }",
                    "    result = await coreFormat(text, options);",
                    "  }",
                    "",
                    "  if (hasBOM) {",
                    "    result.formatted = BOM + result.formatted;",
                    "",
                    "    if (result.cursorOffset >= 0) {",
                    "      result.cursorOffset++;",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "async function parse(originalText, originalOptions, devOptions) {",
                    "  const { text, options } = normalizeInputAndOptions(",
                    "    originalText,",
                    "    await normalizeFormatOptions(originalOptions)",
                    "  );",
                    "  const parsed = await parseText(text, options);",
                    "  if (devOptions) {",
                    "    if (devOptions.preprocessForPrint) {",
                    "      parsed.ast = await prepareToPrint(parsed.ast, options);",
                    "    }",
                    "    if (devOptions.massage) {",
                    "      parsed.ast = massageAst(parsed.ast, options);",
                    "    }",
                    "  }",
                    "  return parsed;",
                    "}",
                    "",
                    "async function formatAst(ast, options) {",
                    "  options = await normalizeFormatOptions(options);",
                    "  const doc = await printAstToDoc(ast, options);",
                    "  return printDocToStringWithoutNormalizeOptions(doc, options);",
                    "}",
                    "",
                    "// Doesn't handle shebang for now",
                    "async function formatDoc(doc, options) {",
                    "  const text = printDocToDebug(doc);",
                    "  const { formatted } = await formatWithCursor(text, {",
                    "    ...options,",
                    "    parser: \"__js_expression\",",
                    "  });",
                    "",
                    "  return formatted;",
                    "}",
                    "",
                    "async function printToDoc(originalText, options) {",
                    "  options = await normalizeFormatOptions(options);",
                    "  const { ast } = await parseText(originalText, options);",
                    "  return printAstToDoc(ast, options);",
                    "}",
                    "",
                    "async function printDocToString(doc, options) {",
                    "  return printDocToStringWithoutNormalizeOptions(",
                    "    doc,",
                    "    await normalizeFormatOptions(options)",
                    "  );",
                    "}",
                    "",
                    "export {",
                    "  formatWithCursor,",
                    "  parse,",
                    "  formatAst,",
                    "  formatDoc,",
                    "  printToDoc,",
                    "  printDocToString,",
                    "};"
                ]
            },
            "create-get-visitor-keys-function.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "const nonTraversableKeys = new Set([",
                    "  \"tokens\",",
                    "  \"comments\",",
                    "  \"parent\",",
                    "  \"enclosingNode\",",
                    "  \"precedingNode\",",
                    "  \"followingNode\",",
                    "]);",
                    "",
                    "const defaultGetVisitorKeys = (node) =>",
                    "  Object.keys(node).filter((key) => !nonTraversableKeys.has(key));",
                    "",
                    "function createGetVisitorKeysFunction(printerGetVisitorKeys) {",
                    "  return printerGetVisitorKeys",
                    "    ? (node) => printerGetVisitorKeys(node, nonTraversableKeys)",
                    "    : defaultGetVisitorKeys;",
                    "}",
                    "",
                    "export default createGetVisitorKeysFunction;"
                ]
            },
            "create-print-pre-check-function.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeysFunction from \"./create-get-visitor-keys-function.js\";",
                    "",
                    "function createPrintPreCheckFunction(options) {",
                    "  if (process.env.NODE_ENV === \"production\") {",
                    "    return () => {};",
                    "  }",
                    "",
                    "  // All core plugins have full list of keys for possible child nodes",
                    "  // Ensure we only pass node to `print`",
                    "  const getVisitorKeys = createGetVisitorKeysFunction(",
                    "    options.printer.getVisitorKeys",
                    "  );",
                    "",
                    "  return function (path) {",
                    "    if (path.isRoot) {",
                    "      return;",
                    "    }",
                    "",
                    "    const { key, parent } = path;",
                    "",
                    "    const visitorKeys = getVisitorKeys(parent);",
                    "    if (visitorKeys.includes(key)) {",
                    "      return;",
                    "    }",
                    "",
                    "    /* c8 ignore start */",
                    "    throw Object.assign(new Error(\"Calling `print()` on non-node object.\"), {",
                    "      parentNode: parent,",
                    "      allowedProperties: visitorKeys,",
                    "      printingProperty: key,",
                    "      printingValue: path.node,",
                    "      pathStack:",
                    "        path.stack.length > 5",
                    "          ? [\"...\", ...path.stack.slice(-5)]",
                    "          : [...path.stack],",
                    "    });",
                    "    /* c8 ignore stop */",
                    "  };",
                    "}",
                    "",
                    "export default createPrintPreCheckFunction;"
                ]
            },
            "get-cursor-node.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { getDescendants } from \"../utils/ast-utils.js\";",
                    "import createGetVisitorKeysFunction from \"./create-get-visitor-keys-function.js\";",
                    "",
                    "function getCursorNode(ast, options) {",
                    "  const { cursorOffset, locStart, locEnd } = options;",
                    "  const getVisitorKeys = createGetVisitorKeysFunction(",
                    "    options.printer.getVisitorKeys",
                    "  );",
                    "  const nodeContainsCursor = (node) =>",
                    "    locStart(node) <= cursorOffset && locEnd(node) >= cursorOffset;",
                    "",
                    "  let cursorNode = ast;",
                    "  for (const node of getDescendants(ast, {",
                    "    getVisitorKeys,",
                    "    filter: nodeContainsCursor,",
                    "  })) {",
                    "    cursorNode = node;",
                    "  }",
                    "",
                    "  return cursorNode;",
                    "}",
                    "",
                    "export default getCursorNode;"
                ]
            },
            "massage-ast.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createGetVisitorKeysFunction from \"./create-get-visitor-keys-function.js\";",
                    "",
                    "function massageAst(ast, options) {",
                    "  const {",
                    "    printer: {",
                    "      massageAstNode: cleanFunction,",
                    "      getVisitorKeys: printerGetVisitorKeys,",
                    "    },",
                    "  } = options;",
                    "",
                    "  if (!cleanFunction) {",
                    "    return ast;",
                    "  }",
                    "",
                    "  const getVisitorKeys = createGetVisitorKeysFunction(printerGetVisitorKeys);",
                    "  const ignoredProperties = cleanFunction.ignoredProperties ?? new Set();",
                    "",
                    "  return recurse(ast);",
                    "",
                    "  function recurse(node, parent) {",
                    "    if (!(node !== null && typeof node === \"object\")) {",
                    "      return node;",
                    "    }",
                    "",
                    "    if (Array.isArray(node)) {",
                    "      return node.map((child) => recurse(child, parent)).filter(Boolean);",
                    "    }",
                    "",
                    "    const newObj = {};",
                    "    const childrenKeys = new Set(getVisitorKeys(node));",
                    "    for (const key in node) {",
                    "      if (!Object.hasOwn(node, key) || ignoredProperties.has(key)) {",
                    "        continue;",
                    "      }",
                    "",
                    "      if (childrenKeys.has(key)) {",
                    "        newObj[key] = recurse(node[key], node);",
                    "      } else {",
                    "        newObj[key] = node[key];",
                    "      }",
                    "    }",
                    "",
                    "    const result = cleanFunction(node, newObj, parent);",
                    "    if (result === null) {",
                    "      return;",
                    "    }",
                    "",
                    "    return result ?? newObj;",
                    "  }",
                    "}",
                    "",
                    "export default massageAst;"
                ]
            },
            "multiparser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { stripTrailingHardline } from \"../document/utils.js\";",
                    "import normalizeFormatOptions from \"./normalize-format-options.js\";",
                    "import parse from \"./parse.js\";",
                    "import createGetVisitorKeysFunction from \"./create-get-visitor-keys-function.js\";",
                    "",
                    "async function printEmbeddedLanguages(",
                    "  /** @type {import(\"../common/ast-path.js\").default} */ path,",
                    "  genericPrint,",
                    "  options,",
                    "  printAstToDoc,",
                    "  embeds",
                    ") {",
                    "  const {",
                    "    embeddedLanguageFormatting,",
                    "    printer: {",
                    "      embed,",
                    "      hasPrettierIgnore = () => false,",
                    "      getVisitorKeys: printerGetVisitorKeys,",
                    "    },",
                    "  } = options;",
                    "",
                    "  if (!embed || embeddedLanguageFormatting !== \"auto\") {",
                    "    return;",
                    "  }",
                    "",
                    "  if (embed.length > 2) {",
                    "    throw new Error(",
                    "      \"printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/en/plugins.html#optional-embed\"",
                    "    );",
                    "  }",
                    "",
                    "  const getVisitorKeys = createGetVisitorKeysFunction(",
                    "    embed.getVisitorKeys ?? printerGetVisitorKeys",
                    "  );",
                    "  const embedCallResults = [];",
                    "",
                    "  recurse();",
                    "",
                    "  const originalPathStack = path.stack;",
                    "",
                    "  for (const { print, node, pathStack } of embedCallResults) {",
                    "    try {",
                    "      path.stack = pathStack;",
                    "      const doc = await print(textToDocForEmbed, genericPrint, path, options);",
                    "",
                    "      if (doc) {",
                    "        embeds.set(node, doc);",
                    "      }",
                    "    } catch (error) {",
                    "      /* c8 ignore next 3 */",
                    "      if (process.env.PRETTIER_DEBUG) {",
                    "        throw error;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  path.stack = originalPathStack;",
                    "",
                    "  function textToDocForEmbed(text, partialNextOptions) {",
                    "    return textToDoc(text, partialNextOptions, options, printAstToDoc);",
                    "  }",
                    "",
                    "  function recurse() {",
                    "    const { node } = path;",
                    "    if (node === null || typeof node !== \"object\" || hasPrettierIgnore(path)) {",
                    "      return;",
                    "    }",
                    "",
                    "    for (const key of getVisitorKeys(node)) {",
                    "      if (Array.isArray(node[key])) {",
                    "        path.each(recurse, key);",
                    "      } else {",
                    "        path.call(recurse, key);",
                    "      }",
                    "    }",
                    "",
                    "    const result = embed(path, options);",
                    "",
                    "    if (!result) {",
                    "      return;",
                    "    }",
                    "",
                    "    if (typeof result === \"function\") {",
                    "      embedCallResults.push({",
                    "        print: result,",
                    "        node,",
                    "        pathStack: [...path.stack],",
                    "      });",
                    "      return;",
                    "    }",
                    "",
                    "    if (",
                    "      process.env.NODE_ENV !== \"production\" &&",
                    "      typeof result.then === \"function\"",
                    "    ) {",
                    "      throw new Error(",
                    "        \"`embed` should return an async function instead of Promise.\"",
                    "      );",
                    "    }",
                    "",
                    "    embeds.set(node, result);",
                    "  }",
                    "}",
                    "",
                    "async function textToDoc(",
                    "  text,",
                    "  partialNextOptions,",
                    "  parentOptions,",
                    "  printAstToDoc",
                    ") {",
                    "  const options = await normalizeFormatOptions(",
                    "    {",
                    "      ...parentOptions,",
                    "      ...partialNextOptions,",
                    "      parentParser: parentOptions.parser,",
                    "      originalText: text,",
                    "    },",
                    "    { passThrough: true }",
                    "  );",
                    "",
                    "  const { ast } = await parse(text, options);",
                    "  const doc = await printAstToDoc(ast, options);",
                    "",
                    "  return stripTrailingHardline(doc);",
                    "}",
                    "",
                    "export { printEmbeddedLanguages };"
                ]
            },
            "normalize-format-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { UndefinedParserError } from \"../common/errors.js\";",
                    "import { getSupportInfo } from \"../main/support.js\";",
                    "import inferParser from \"../utils/infer-parser.js\";",
                    "import normalizeOptions from \"./normalize-options.js\";",
                    "import {",
                    "  getParserPluginByParserName,",
                    "  getPrinterPluginByAstFormat,",
                    "  initParser,",
                    "} from \"./parser-and-printer.js\";",
                    "",
                    "const formatOptionsHiddenDefaults = {",
                    "  astFormat: \"estree\",",
                    "  printer: {},",
                    "  originalText: undefined,",
                    "  locStart: null,",
                    "  locEnd: null,",
                    "};",
                    "",
                    "// Copy options and fill in default values.",
                    "async function normalizeFormatOptions(options, opts = {}) {",
                    "  const rawOptions = { ...options };",
                    "",
                    "  const supportOptions = getSupportInfo({",
                    "    plugins: options.plugins,",
                    "    showDeprecated: true,",
                    "  }).options;",
                    "",
                    "  const defaults = {",
                    "    ...formatOptionsHiddenDefaults,",
                    "    ...Object.fromEntries(",
                    "      supportOptions",
                    "        .filter((optionInfo) => optionInfo.default !== undefined)",
                    "        .map((option) => [option.name, option.default])",
                    "    ),",
                    "  };",
                    "  if (!rawOptions.parser) {",
                    "    if (!rawOptions.filepath) {",
                    "      const logger = opts.logger || console;",
                    "      logger.warn(",
                    "        \"No parser and no filepath given, using 'babel' the parser now \" +",
                    "          \"but this will throw an error in the future. \" +",
                    "          \"Please specify a parser or a filepath so one can be inferred.\"",
                    "      );",
                    "      rawOptions.parser = \"babel\";",
                    "    } else {",
                    "      rawOptions.parser = inferParser(rawOptions, {",
                    "        physicalFile: rawOptions.filepath,",
                    "      });",
                    "      if (!rawOptions.parser) {",
                    "        throw new UndefinedParserError(",
                    "          `No parser could be inferred for file \"${rawOptions.filepath}\".`",
                    "        );",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const parserPlugin = getParserPluginByParserName(",
                    "    rawOptions.plugins,",
                    "    rawOptions.parser",
                    "  );",
                    "",
                    "  const parser = await initParser(parserPlugin, rawOptions.parser);",
                    "  rawOptions.astFormat = parser.astFormat;",
                    "  rawOptions.locEnd = parser.locEnd;",
                    "  rawOptions.locStart = parser.locStart;",
                    "",
                    "  const printerPlugin = parserPlugin.printers?.[parser.astFormat]",
                    "    ? parserPlugin",
                    "    : getPrinterPluginByAstFormat(rawOptions.plugins, parser.astFormat);",
                    "  const printer = printerPlugin.printers[parser.astFormat];",
                    "",
                    "  rawOptions.printer = printer;",
                    "",
                    "  const pluginDefaults = printerPlugin.defaultOptions",
                    "    ? Object.fromEntries(",
                    "        Object.entries(printerPlugin.defaultOptions).filter(",
                    "          ([, value]) => value !== undefined",
                    "        )",
                    "      )",
                    "    : {};",
                    "",
                    "  const mixedDefaults = { ...defaults, ...pluginDefaults };",
                    "",
                    "  for (const [k, value] of Object.entries(mixedDefaults)) {",
                    "    if (rawOptions[k] === null || rawOptions[k] === undefined) {",
                    "      rawOptions[k] = value;",
                    "    }",
                    "  }",
                    "",
                    "  if (rawOptions.parser === \"json\") {",
                    "    rawOptions.trailingComma = \"none\";",
                    "  }",
                    "",
                    "  return normalizeOptions(rawOptions, supportOptions, {",
                    "    passThrough: Object.keys(formatOptionsHiddenDefaults),",
                    "    ...opts,",
                    "  });",
                    "}",
                    "",
                    "export default normalizeFormatOptions;",
                    "export { formatOptionsHiddenDefaults };"
                ]
            },
            "normalize-options.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import vnopts from \"vnopts\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./support.js\").NamedOptionInfo} NamedOptionInfo",
                    " */",
                    "",
                    "let hasDeprecationWarned;",
                    "",
                    "/**",
                    " * @param {*} options",
                    " * @param {*} optionInfos",
                    " * @param {{ logger?: false; isCLI?: boolean; passThrough?: string[] | boolean; FlagSchema?: any; descriptor?: any }} param2",
                    " */",
                    "function normalizeOptions(",
                    "  options,",
                    "  optionInfos,",
                    "  {",
                    "    logger = false,",
                    "    isCLI = false,",
                    "    passThrough = false,",
                    "    FlagSchema,",
                    "    descriptor,",
                    "  } = {}",
                    ") {",
                    "  // TODO: Move CLI related part into `/src/cli`",
                    "  if (isCLI) {",
                    "    /* c8 ignore start */",
                    "    if (!FlagSchema) {",
                    "      throw new Error(\"'FlagSchema' option is required.\");",
                    "    }",
                    "",
                    "    if (!descriptor) {",
                    "      throw new Error(\"'descriptor' option is required.\");",
                    "    }",
                    "    /* c8 ignore stop */",
                    "  } else {",
                    "    descriptor = vnopts.apiDescriptor;",
                    "  }",
                    "",
                    "  const unknown = !passThrough",
                    "    ? (key, value, options) => {",
                    "        // Don't suggest `_` for unknown flags",
                    "        const { _, ...schemas } = options.schemas;",
                    "        return vnopts.levenUnknownHandler(key, value, {",
                    "          ...options,",
                    "          schemas,",
                    "        });",
                    "      }",
                    "    : Array.isArray(passThrough)",
                    "    ? (key, value) =>",
                    "        !passThrough.includes(key) ? undefined : { [key]: value }",
                    "    : (key, value) => ({ [key]: value });",
                    "",
                    "  const schemas = optionInfosToSchemas(optionInfos, { isCLI, FlagSchema });",
                    "  const normalizer = new vnopts.Normalizer(schemas, {",
                    "    logger,",
                    "    unknown,",
                    "    descriptor,",
                    "  });",
                    "",
                    "  const shouldSuppressDuplicateDeprecationWarnings = logger !== false;",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {",
                    "    // @ts-expect-error",
                    "    normalizer._hasDeprecationWarned = hasDeprecationWarned;",
                    "  }",
                    "",
                    "  const normalized = normalizer.normalize(options);",
                    "",
                    "  if (shouldSuppressDuplicateDeprecationWarnings) {",
                    "    // @ts-expect-error",
                    "    hasDeprecationWarned = normalizer._hasDeprecationWarned;",
                    "  }",
                    "",
                    "  if (isCLI && normalized[\"plugin-search\"] === false) {",
                    "    normalized[\"plugin-search-dir\"] = false;",
                    "  }",
                    "",
                    "  return normalized;",
                    "}",
                    "",
                    "function optionInfosToSchemas(optionInfos, { isCLI, FlagSchema }) {",
                    "  const schemas = [];",
                    "",
                    "  if (isCLI) {",
                    "    schemas.push(vnopts.AnySchema.create({ name: \"_\" }));",
                    "  }",
                    "",
                    "  for (const optionInfo of optionInfos) {",
                    "    schemas.push(",
                    "      optionInfoToSchema(optionInfo, {",
                    "        isCLI,",
                    "        optionInfos,",
                    "        FlagSchema,",
                    "      })",
                    "    );",
                    "",
                    "    if (optionInfo.alias && isCLI) {",
                    "      schemas.push(",
                    "        vnopts.AliasSchema.create({",
                    "          // @ts-expect-error",
                    "          name: optionInfo.alias,",
                    "          sourceName: optionInfo.name,",
                    "        })",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  return schemas;",
                    "}",
                    "",
                    "/**",
                    " * @param {NamedOptionInfo} optionInfo",
                    " * @param {any} param1",
                    " * @returns",
                    " */",
                    "function optionInfoToSchema(optionInfo, { isCLI, optionInfos, FlagSchema }) {",
                    "  const { name } = optionInfo;",
                    "",
                    "  if (name === \"plugin-search-dir\" || name === \"pluginSearchDirs\") {",
                    "    return vnopts.AnySchema.create({",
                    "      // @ts-expect-error",
                    "      name,",
                    "      preprocess(value) {",
                    "        if (value === false) {",
                    "          return value;",
                    "        }",
                    "        value = Array.isArray(value) ? value : [value];",
                    "        return value;",
                    "      },",
                    "      /**",
                    "       * @param {Array<unknown> | false} value",
                    "       */",
                    "      validate(value) {",
                    "        if (value === false) {",
                    "          return true;",
                    "        }",
                    "        return value.every((dir) => typeof dir === \"string\");",
                    "      },",
                    "      expected() {",
                    "        return \"false or paths to plugin search dir\";",
                    "      },",
                    "    });",
                    "  }",
                    "",
                    "  const parameters = { name };",
                    "  let SchemaConstructor;",
                    "  const handlers = {};",
                    "",
                    "  switch (optionInfo.type) {",
                    "    case \"int\":",
                    "      SchemaConstructor = vnopts.IntegerSchema;",
                    "      if (isCLI) {",
                    "        parameters.preprocess = Number;",
                    "      }",
                    "      break;",
                    "    case \"string\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    case \"choice\":",
                    "      SchemaConstructor = vnopts.ChoiceSchema;",
                    "      parameters.choices = optionInfo.choices.map((choiceInfo) =>",
                    "        choiceInfo?.redirect",
                    "          ? {",
                    "              ...choiceInfo,",
                    "              redirect: {",
                    "                to: { key: optionInfo.name, value: choiceInfo.redirect },",
                    "              },",
                    "            }",
                    "          : choiceInfo",
                    "      );",
                    "      break;",
                    "    case \"boolean\":",
                    "      SchemaConstructor = vnopts.BooleanSchema;",
                    "      break;",
                    "    case \"flag\":",
                    "      // Only available when normalizing CLI options",
                    "      SchemaConstructor = FlagSchema;",
                    "      parameters.flags = optionInfos.flatMap((optionInfo) =>",
                    "        [",
                    "          optionInfo.alias,",
                    "          optionInfo.description && optionInfo.name,",
                    "          optionInfo.oppositeDescription && `no-${optionInfo.name}`,",
                    "        ].filter(Boolean)",
                    "      );",
                    "      break;",
                    "    case \"path\":",
                    "      SchemaConstructor = vnopts.StringSchema;",
                    "      break;",
                    "    default:",
                    "      /* c8 ignore next */",
                    "      throw new Error(`Unexpected type ${optionInfo.type}`);",
                    "  }",
                    "",
                    "  if (optionInfo.exception) {",
                    "    parameters.validate = (value, schema, utils) =>",
                    "      optionInfo.exception(value) || schema.validate(value, utils);",
                    "  } else {",
                    "    parameters.validate = (value, schema, utils) =>",
                    "      value === undefined || schema.validate(value, utils);",
                    "  }",
                    "",
                    "  /* c8 ignore start */",
                    "  if (optionInfo.redirect) {",
                    "    handlers.redirect = (value) =>",
                    "      !value",
                    "        ? undefined",
                    "        : {",
                    "            to: {",
                    "              key: optionInfo.redirect.option,",
                    "              value: optionInfo.redirect.value,",
                    "            },",
                    "          };",
                    "  }",
                    "  /* c8 ignore stop */",
                    "",
                    "  /* c8 ignore next 3 */",
                    "  if (optionInfo.deprecated) {",
                    "    handlers.deprecated = true;",
                    "  }",
                    "",
                    "  // allow CLI overriding, e.g., prettier package.json --tab-width 1 --tab-width 2",
                    "  if (isCLI && !optionInfo.array) {",
                    "    const originalPreprocess = parameters.preprocess || ((x) => x);",
                    "    parameters.preprocess = (value, schema, utils) =>",
                    "      schema.preprocess(",
                    "        originalPreprocess(Array.isArray(value) ? value.at(-1) : value),",
                    "        utils",
                    "      );",
                    "  }",
                    "",
                    "  return optionInfo.array",
                    "    ? vnopts.ArraySchema.create({",
                    "        ...(isCLI ? { preprocess: (v) => (Array.isArray(v) ? v : [v]) } : {}),",
                    "        ...handlers,",
                    "        // @ts-expect-error",
                    "        valueSchema: SchemaConstructor.create(parameters),",
                    "      })",
                    "    : SchemaConstructor.create({ ...parameters, ...handlers });",
                    "}",
                    "",
                    "export default normalizeOptions;"
                ]
            },
            "option-categories.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export const CATEGORY_CONFIG = \"Config\";",
                    "export const CATEGORY_EDITOR = \"Editor\";",
                    "export const CATEGORY_FORMAT = \"Format\";",
                    "export const CATEGORY_OTHER = \"Other\";",
                    "export const CATEGORY_OUTPUT = \"Output\";",
                    "export const CATEGORY_GLOBAL = \"Global\";",
                    "export const CATEGORY_SPECIAL = \"Special\";"
                ]
            },
            "parse.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { codeFrameColumns } from \"@babel/code-frame\";",
                    "import { resolveParser } from \"./parser-and-printer.js\";",
                    "",
                    "async function parse(originalText, options) {",
                    "  const parser = await resolveParser(options);",
                    "  const text = parser.preprocess",
                    "    ? parser.preprocess(originalText, options)",
                    "    : originalText;",
                    "  options.originalText = text;",
                    "",
                    "  let ast;",
                    "  try {",
                    "    ast = await parser.parse(",
                    "      text,",
                    "      options,",
                    "      // TODO: remove the third argument in v4",
                    "      // The duplicated argument is passed as intended, see #10156",
                    "      options",
                    "    );",
                    "  } catch (error) {",
                    "    handleParseError(error, originalText);",
                    "  }",
                    "",
                    "  return { text, ast };",
                    "}",
                    "",
                    "function handleParseError(error, text) {",
                    "  const { loc } = error;",
                    "",
                    "  if (loc) {",
                    "    const codeFrame = codeFrameColumns(text, loc, { highlightCode: true });",
                    "    error.message += \"\\n\" + codeFrame;",
                    "    error.codeFrame = codeFrame;",
                    "    throw error;",
                    "  }",
                    "",
                    "  /* c8 ignore next */",
                    "  throw error;",
                    "}",
                    "",
                    "export default parse;"
                ]
            },
            "parser-and-printer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { ConfigError } from \"../common/errors.js\";",
                    "",
                    "// TODO: Improve coverage",
                    "",
                    "function getParserPluginByParserName(plugins, parserName) {",
                    "  /* c8 ignore start */",
                    "  if (!parserName) {",
                    "    throw new Error(\"parserName is required.\");",
                    "  }",
                    "  /* c8 ignore stop */",
                    "",
                    "  /*",
                    "  Loop from end to allow plugins override builtin plugins,",
                    "  this is how `resolveParser` works in v2.",
                    "  This is a temporarily solution, see #13729",
                    "  */",
                    "  for (let index = plugins.length - 1; index >= 0; index--) {",
                    "    const plugin = plugins[index];",
                    "    if (plugin.parsers && Object.hasOwn(plugin.parsers, parserName)) {",
                    "      return plugin;",
                    "    }",
                    "  }",
                    "",
                    "  /* c8 ignore start */",
                    "  let message = `Couldn't resolve parser \"${parserName}\".`;",
                    "  if (process.env.PRETTIER_TARGET === \"universal\") {",
                    "    message += \" Plugins must be explicitly added to the standalone bundle.\";",
                    "  }",
                    "",
                    "  throw new ConfigError(message);",
                    "  /* c8 ignore stop */",
                    "}",
                    "",
                    "function getPrinterPluginByAstFormat(plugins, astFormat) {",
                    "  /* c8 ignore start */",
                    "  if (!astFormat) {",
                    "    throw new Error(\"astFormat is required.\");",
                    "  }",
                    "  /* c8 ignore stop */",
                    "",
                    "  // Loop from end to consistent with parser resolve logic",
                    "  for (let index = plugins.length - 1; index >= 0; index--) {",
                    "    const plugin = plugins[index];",
                    "    if (plugin.printers && Object.hasOwn(plugin.printers, astFormat)) {",
                    "      return plugin;",
                    "    }",
                    "  }",
                    "",
                    "  /* c8 ignore start */",
                    "  let message = `Couldn't find plugin for AST format \"${astFormat}\".`;",
                    "  if (process.env.PRETTIER_TARGET === \"universal\") {",
                    "    message += \" Plugins must be explicitly added to the standalone bundle.\";",
                    "  }",
                    "",
                    "  throw new ConfigError(message);",
                    "  /* c8 ignore stop */",
                    "}",
                    "",
                    "function resolveParser({ plugins, parser }) {",
                    "  const plugin = getParserPluginByParserName(plugins, parser);",
                    "  return initParser(plugin, parser);",
                    "}",
                    "",
                    "function initParser(plugin, parserName) {",
                    "  const parserOrParserInitFunction = plugin.parsers[parserName];",
                    "  return typeof parserOrParserInitFunction === \"function\"",
                    "    ? parserOrParserInitFunction()",
                    "    : parserOrParserInitFunction;",
                    "}",
                    "",
                    "export {",
                    "  getParserPluginByParserName,",
                    "  getPrinterPluginByAstFormat,",
                    "  initParser,",
                    "  resolveParser,",
                    "};"
                ]
            },
            "print-ignored.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function printIgnored(path, options) {",
                    "  const {",
                    "    originalText,",
                    "    [Symbol.for(\"comments\")]: comments,",
                    "    locStart,",
                    "    locEnd,",
                    "    [Symbol.for(\"printedComments\")]: printedComments,",
                    "  } = options;",
                    "",
                    "  const { node } = path;",
                    "  const start = locStart(node);",
                    "  const end = locEnd(node);",
                    "",
                    "  for (const comment of comments) {",
                    "    if (locStart(comment) >= start && locEnd(comment) <= end) {",
                    "      printedComments.add(comment);",
                    "    }",
                    "  }",
                    "",
                    "  return originalText.slice(start, end);",
                    "}",
                    "",
                    "export default printIgnored;"
                ]
            },
            "range-util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import assert from \"node:assert\";",
                    "import { getSortedChildNodes } from \"./comments/attach.js\";",
                    "",
                    "const isJsonParser = ({ parser }) =>",
                    "  parser === \"json\" || parser === \"json5\" || parser === \"json-stringify\";",
                    "",
                    "function findCommonAncestor(startNodeAndParents, endNodeAndParents) {",
                    "  const startNodeAndAncestors = [",
                    "    startNodeAndParents.node,",
                    "    ...startNodeAndParents.parentNodes,",
                    "  ];",
                    "  const endNodeAndAncestors = new Set([",
                    "    endNodeAndParents.node,",
                    "    ...endNodeAndParents.parentNodes,",
                    "  ]);",
                    "  return startNodeAndAncestors.find(",
                    "    (node) => jsonSourceElements.has(node.type) && endNodeAndAncestors.has(node)",
                    "  );",
                    "}",
                    "",
                    "function dropRootParents(parents) {",
                    "  let lastParentIndex = parents.length - 1;",
                    "  for (;;) {",
                    "    const parent = parents[lastParentIndex];",
                    "    if (parent?.type === \"Program\" || parent?.type === \"File\") {",
                    "      lastParentIndex--;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "  return parents.slice(0, lastParentIndex + 1);",
                    "}",
                    "",
                    "function findSiblingAncestors(",
                    "  startNodeAndParents,",
                    "  endNodeAndParents,",
                    "  { locStart, locEnd }",
                    ") {",
                    "  let resultStartNode = startNodeAndParents.node;",
                    "  let resultEndNode = endNodeAndParents.node;",
                    "",
                    "  if (resultStartNode === resultEndNode) {",
                    "    return {",
                    "      startNode: resultStartNode,",
                    "      endNode: resultEndNode,",
                    "    };",
                    "  }",
                    "",
                    "  const startNodeStart = locStart(startNodeAndParents.node);",
                    "  for (const endParent of dropRootParents(endNodeAndParents.parentNodes)) {",
                    "    if (locStart(endParent) >= startNodeStart) {",
                    "      resultEndNode = endParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  const endNodeEnd = locEnd(endNodeAndParents.node);",
                    "  for (const startParent of dropRootParents(startNodeAndParents.parentNodes)) {",
                    "    if (locEnd(startParent) <= endNodeEnd) {",
                    "      resultStartNode = startParent;",
                    "    } else {",
                    "      break;",
                    "    }",
                    "    if (resultStartNode === resultEndNode) {",
                    "      break;",
                    "    }",
                    "  }",
                    "",
                    "  return {",
                    "    startNode: resultStartNode,",
                    "    endNode: resultEndNode,",
                    "  };",
                    "}",
                    "",
                    "function findNodeAtOffset(",
                    "  node,",
                    "  offset,",
                    "  options,",
                    "  predicate,",
                    "  parentNodes = [],",
                    "  type",
                    ") {",
                    "  const { locStart, locEnd } = options;",
                    "  const start = locStart(node);",
                    "  const end = locEnd(node);",
                    "",
                    "  if (",
                    "    offset > end ||",
                    "    offset < start ||",
                    "    (type === \"rangeEnd\" && offset === start) ||",
                    "    (type === \"rangeStart\" && offset === end)",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  for (const childNode of getSortedChildNodes(node, options)) {",
                    "    const childResult = findNodeAtOffset(",
                    "      childNode,",
                    "      offset,",
                    "      options,",
                    "      predicate,",
                    "      [node, ...parentNodes],",
                    "      type",
                    "    );",
                    "    if (childResult) {",
                    "      return childResult;",
                    "    }",
                    "  }",
                    "",
                    "  if (!predicate || predicate(node, parentNodes[0])) {",
                    "    return {",
                    "      node,",
                    "      parentNodes,",
                    "    };",
                    "  }",
                    "}",
                    "",
                    "// See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5",
                    "function isJsSourceElement(type, parentType) {",
                    "  return (",
                    "    parentType !== \"DeclareExportDeclaration\" &&",
                    "    type !== \"TypeParameterDeclaration\" &&",
                    "    (type === \"Directive\" ||",
                    "      type === \"TypeAlias\" ||",
                    "      type === \"TSExportAssignment\" ||",
                    "      type.startsWith(\"Declare\") ||",
                    "      type.startsWith(\"TSDeclare\") ||",
                    "      type.endsWith(\"Statement\") ||",
                    "      type.endsWith(\"Declaration\"))",
                    "  );",
                    "}",
                    "",
                    "const jsonSourceElements = new Set([",
                    "  \"JsonRoot\",",
                    "  \"ObjectExpression\",",
                    "  \"ArrayExpression\",",
                    "  \"StringLiteral\",",
                    "  \"NumericLiteral\",",
                    "  \"BooleanLiteral\",",
                    "  \"NullLiteral\",",
                    "  \"UnaryExpression\",",
                    "  \"TemplateLiteral\",",
                    "]);",
                    "const graphqlSourceElements = new Set([",
                    "  \"OperationDefinition\",",
                    "  \"FragmentDefinition\",",
                    "  \"VariableDefinition\",",
                    "  \"TypeExtensionDefinition\",",
                    "  \"ObjectTypeDefinition\",",
                    "  \"FieldDefinition\",",
                    "  \"DirectiveDefinition\",",
                    "  \"EnumTypeDefinition\",",
                    "  \"EnumValueDefinition\",",
                    "  \"InputValueDefinition\",",
                    "  \"InputObjectTypeDefinition\",",
                    "  \"SchemaDefinition\",",
                    "  \"OperationTypeDefinition\",",
                    "  \"InterfaceTypeDefinition\",",
                    "  \"UnionTypeDefinition\",",
                    "  \"ScalarTypeDefinition\",",
                    "]);",
                    "function isSourceElement(opts, node, parentNode) {",
                    "  /* c8 ignore next 3 */",
                    "  if (!node) {",
                    "    return false;",
                    "  }",
                    "  switch (opts.parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"__babel_estree\":",
                    "      return isJsSourceElement(node.type, parentNode?.type);",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      return jsonSourceElements.has(node.type);",
                    "    case \"graphql\":",
                    "      return graphqlSourceElements.has(node.kind);",
                    "    case \"vue\":",
                    "      return node.tag !== \"root\";",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "function calculateRange(text, opts, ast) {",
                    "  let { rangeStart: start, rangeEnd: end, locStart, locEnd } = opts;",
                    "  assert.ok(end > start);",
                    "  // Contract the range so that it has non-whitespace characters at its endpoints.",
                    "  // This ensures we can format a range that doesn't end on a node.",
                    "  const firstNonWhitespaceCharacterIndex = text.slice(start, end).search(/\\S/);",
                    "  const isAllWhitespace = firstNonWhitespaceCharacterIndex === -1;",
                    "  if (!isAllWhitespace) {",
                    "    start += firstNonWhitespaceCharacterIndex;",
                    "    for (; end > start; --end) {",
                    "      if (/\\S/.test(text[end - 1])) {",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  const startNodeAndParents = findNodeAtOffset(",
                    "    ast,",
                    "    start,",
                    "    opts,",
                    "    (node, parentNode) => isSourceElement(opts, node, parentNode),",
                    "    [],",
                    "    \"rangeStart\"",
                    "  );",
                    "  const endNodeAndParents =",
                    "    // No need find Node at `end`, it will be the same as `startNodeAndParents`",
                    "    isAllWhitespace",
                    "      ? startNodeAndParents",
                    "      : findNodeAtOffset(",
                    "          ast,",
                    "          end,",
                    "          opts,",
                    "          (node) => isSourceElement(opts, node),",
                    "          [],",
                    "          \"rangeEnd\"",
                    "        );",
                    "  if (!startNodeAndParents || !endNodeAndParents) {",
                    "    return {",
                    "      rangeStart: 0,",
                    "      rangeEnd: 0,",
                    "    };",
                    "  }",
                    "",
                    "  let startNode;",
                    "  let endNode;",
                    "  if (isJsonParser(opts)) {",
                    "    const commonAncestor = findCommonAncestor(",
                    "      startNodeAndParents,",
                    "      endNodeAndParents",
                    "    );",
                    "    startNode = commonAncestor;",
                    "    endNode = commonAncestor;",
                    "  } else {",
                    "    ({ startNode, endNode } = findSiblingAncestors(",
                    "      startNodeAndParents,",
                    "      endNodeAndParents,",
                    "      opts",
                    "    ));",
                    "  }",
                    "",
                    "  return {",
                    "    rangeStart: Math.min(locStart(startNode), locStart(endNode)),",
                    "    rangeEnd: Math.max(locEnd(startNode), locEnd(endNode)),",
                    "  };",
                    "}",
                    "",
                    "export { calculateRange, findNodeAtOffset };"
                ]
            },
            "support.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import coreOptions from \"./core-options.evaluate.js\";",
                    "",
                    "/**",
                    " * @typedef {import(\"./core-options.evaluate.js\").OptionInfo} OptionInfo",
                    " * @typedef {{ name: string; pluginDefaults: Array<any> } & OptionInfo} NamedOptionInfo",
                    " */",
                    "",
                    "/**",
                    " * Strings in `plugins` and `pluginSearchDirs` are handled by a wrapped version",
                    " * of this function created by `withPlugins`. Don't pass them here directly.",
                    " * @param {object} param0",
                    " * @param {(string | object)[]=} param0.plugins Strings are resolved by `withPlugins`.",
                    " * @param {string[]=} param0.pluginSearchDirs Added by `withPlugins`.",
                    " * @param {boolean=} param0.showDeprecated",
                    " * @return {{ languages: Array<any>, options: Array<NamedOptionInfo> }}",
                    " */",
                    "function getSupportInfo({ plugins = [], showDeprecated = false } = {}) {",
                    "  const languages = plugins.flatMap((plugin) => plugin.languages ?? []);",
                    "",
                    "  const options = [];",
                    "  for (const option of normalizeOptionSettings(",
                    "    Object.assign({}, ...plugins.map(({ options }) => options), coreOptions)",
                    "  )) {",
                    "    if (!showDeprecated && option.deprecated) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (Array.isArray(option.choices)) {",
                    "      if (!showDeprecated) {",
                    "        option.choices = option.choices.filter((choice) => !choice.deprecated);",
                    "      }",
                    "",
                    "      if (option.name === \"parser\") {",
                    "        option.choices = [",
                    "          ...option.choices,",
                    "          ...collectParsersFromLanguages(option.choices, languages, plugins),",
                    "        ];",
                    "      }",
                    "    }",
                    "",
                    "    option.pluginDefaults = Object.fromEntries(",
                    "      plugins",
                    "        .filter((plugin) => plugin.defaultOptions?.[option.name] !== undefined)",
                    "        .map((plugin) => [plugin.name, plugin.defaultOptions[option.name]])",
                    "    );",
                    "",
                    "    options.push(option);",
                    "  }",
                    "",
                    "  return { languages, options };",
                    "}",
                    "",
                    "function* collectParsersFromLanguages(parserChoices, languages, plugins) {",
                    "  const existingParsers = new Set(parserChoices.map((choice) => choice.value));",
                    "",
                    "  for (const language of languages) {",
                    "    if (language.parsers) {",
                    "      for (const parserName of language.parsers) {",
                    "        if (!existingParsers.has(parserName)) {",
                    "          existingParsers.add(parserName);",
                    "          const plugin = plugins.find(",
                    "            (plugin) =>",
                    "              plugin.parsers && Object.hasOwn(plugin.parsers, parserName)",
                    "          );",
                    "",
                    "          let description = language.name;",
                    "          if (plugin?.name) {",
                    "            description += ` (plugin: ${plugin.name})`;",
                    "          }",
                    "          yield { value: parserName, description };",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "function normalizeOptionSettings(settings) {",
                    "  const options = [];",
                    "  for (const [name, originalOption] of Object.entries(settings)) {",
                    "    const option = { name, ...originalOption };",
                    "",
                    "    // This work this way because we used support `[{value: [], since: '0.0.0'}]`",
                    "    if (Array.isArray(option.default)) {",
                    "      option.default = option.default.at(-1).value;",
                    "    }",
                    "",
                    "    options.push(option);",
                    "  }",
                    "",
                    "  return options;",
                    "}",
                    "",
                    "export { getSupportInfo, normalizeOptionSettings };"
                ]
            },
            "version.evaluate.cjs": {},
            "comments": {
                "attach.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import assert from \"node:assert\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "import { getChildren } from \"../../utils/ast-utils.js\";",
                        "import createGetVisitorKeysFunction from \"../create-get-visitor-keys-function.js\";",
                        "import {",
                        "  addLeadingComment,",
                        "  addDanglingComment,",
                        "  addTrailingComment,",
                        "} from \"./utils.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " */",
                        "",
                        "const childNodesCache = new WeakMap();",
                        "function getSortedChildNodes(node, options) {",
                        "  if (childNodesCache.has(node)) {",
                        "    return childNodesCache.get(node);",
                        "  }",
                        "",
                        "  const {",
                        "    printer: {",
                        "      getCommentChildNodes,",
                        "      canAttachComment,",
                        "      getVisitorKeys: printerGetVisitorKeys,",
                        "    },",
                        "    locStart,",
                        "    locEnd,",
                        "  } = options;",
                        "",
                        "  if (!canAttachComment) {",
                        "    return [];",
                        "  }",
                        "",
                        "  const childNodes = (",
                        "    getCommentChildNodes?.(node, options) ?? [",
                        "      ...getChildren(node, {",
                        "        getVisitorKeys: createGetVisitorKeysFunction(printerGetVisitorKeys),",
                        "      }),",
                        "    ]",
                        "  ).flatMap((node) =>",
                        "    canAttachComment(node) ? [node] : getSortedChildNodes(node, options)",
                        "  );",
                        "  // Sort by `start` location first, then `end` location",
                        "  childNodes.sort(",
                        "    (nodeA, nodeB) =>",
                        "      locStart(nodeA) - locStart(nodeB) || locEnd(nodeA) - locEnd(nodeB)",
                        "  );",
                        "",
                        "  childNodesCache.set(node, childNodes);",
                        "  return childNodes;",
                        "}",
                        "",
                        "// As efficiently as possible, decorate the comment object with",
                        "// .precedingNode, .enclosingNode, and/or .followingNode properties, at",
                        "// least one of which is guaranteed to be defined.",
                        "function decorateComment(node, comment, options, enclosingNode) {",
                        "  const { locStart, locEnd } = options;",
                        "  const commentStart = locStart(comment);",
                        "  const commentEnd = locEnd(comment);",
                        "",
                        "  const childNodes = getSortedChildNodes(node, options);",
                        "  let precedingNode;",
                        "  let followingNode;",
                        "  // Time to dust off the old binary search robes and wizard hat.",
                        "  let left = 0;",
                        "  let right = childNodes.length;",
                        "  while (left < right) {",
                        "    const middle = (left + right) >> 1;",
                        "    const child = childNodes[middle];",
                        "    const start = locStart(child);",
                        "    const end = locEnd(child);",
                        "",
                        "    // The comment is completely contained by this child node.",
                        "    if (start <= commentStart && commentEnd <= end) {",
                        "      // Abandon the binary search at this level.",
                        "      return decorateComment(child, comment, options, child);",
                        "    }",
                        "",
                        "    if (end <= commentStart) {",
                        "      // This child node falls completely before the comment.",
                        "      // Because we will never consider this node or any nodes",
                        "      // before it again, this node must be the closest preceding",
                        "      // node we have encountered so far.",
                        "      precedingNode = child;",
                        "      left = middle + 1;",
                        "      continue;",
                        "    }",
                        "",
                        "    if (commentEnd <= start) {",
                        "      // This child node falls completely after the comment.",
                        "      // Because we will never consider this node or any nodes after",
                        "      // it again, this node must be the closest following node we",
                        "      // have encountered so far.",
                        "      followingNode = child;",
                        "      right = middle;",
                        "      continue;",
                        "    }",
                        "",
                        "    /* c8 ignore next */",
                        "    throw new Error(\"Comment location overlaps with node location\");",
                        "  }",
                        "",
                        "  // We don't want comments inside of different expressions inside of the same",
                        "  // template literal to move to another expression.",
                        "  if (enclosingNode?.type === \"TemplateLiteral\") {",
                        "    const { quasis } = enclosingNode;",
                        "    const commentIndex = findExpressionIndexForComment(",
                        "      quasis,",
                        "      comment,",
                        "      options",
                        "    );",
                        "",
                        "    if (",
                        "      precedingNode &&",
                        "      findExpressionIndexForComment(quasis, precedingNode, options) !==",
                        "        commentIndex",
                        "    ) {",
                        "      precedingNode = null;",
                        "    }",
                        "    if (",
                        "      followingNode &&",
                        "      findExpressionIndexForComment(quasis, followingNode, options) !==",
                        "        commentIndex",
                        "    ) {",
                        "      followingNode = null;",
                        "    }",
                        "  }",
                        "",
                        "  return { enclosingNode, precedingNode, followingNode };",
                        "}",
                        "",
                        "const returnFalse = () => false;",
                        "function attachComments(ast, options) {",
                        "  const { comments } = ast;",
                        "  delete ast.comments;",
                        "",
                        "  if (!isNonEmptyArray(comments) || !options.printer.canAttachComment) {",
                        "    return;",
                        "  }",
                        "",
                        "  const tiesToBreak = [];",
                        "  const {",
                        "    locStart,",
                        "    locEnd,",
                        "    printer: {",
                        "      experimentalFeatures: {",
                        "        // TODO: Make this as default behavior",
                        "        avoidAstMutation = false,",
                        "      } = {},",
                        "      handleComments = {},",
                        "    },",
                        "    originalText: text,",
                        "  } = options;",
                        "  const {",
                        "    ownLine: handleOwnLineComment = returnFalse,",
                        "    endOfLine: handleEndOfLineComment = returnFalse,",
                        "    remaining: handleRemainingComment = returnFalse,",
                        "  } = handleComments;",
                        "",
                        "  const decoratedComments = comments.map((comment, index) => ({",
                        "    ...decorateComment(ast, comment, options),",
                        "    comment,",
                        "    text,",
                        "    options,",
                        "    ast,",
                        "    isLastComment: comments.length - 1 === index,",
                        "  }));",
                        "",
                        "  for (const [index, context] of decoratedComments.entries()) {",
                        "    const {",
                        "      comment,",
                        "      precedingNode,",
                        "      enclosingNode,",
                        "      followingNode,",
                        "      text,",
                        "      options,",
                        "      ast,",
                        "      isLastComment,",
                        "    } = context;",
                        "",
                        "    if (",
                        "      options.parser === \"json\" ||",
                        "      options.parser === \"json5\" ||",
                        "      options.parser === \"__js_expression\" ||",
                        "      options.parser === \"__ts_expression\" ||",
                        "      options.parser === \"__vue_expression\" ||",
                        "      options.parser === \"__vue_ts_expression\"",
                        "    ) {",
                        "      if (locStart(comment) - locStart(ast) <= 0) {",
                        "        addLeadingComment(ast, comment);",
                        "        continue;",
                        "      }",
                        "      if (locEnd(comment) - locEnd(ast) >= 0) {",
                        "        addTrailingComment(ast, comment);",
                        "        continue;",
                        "      }",
                        "    }",
                        "",
                        "    let args;",
                        "    if (avoidAstMutation) {",
                        "      args = [context];",
                        "    } else {",
                        "      comment.enclosingNode = enclosingNode;",
                        "      comment.precedingNode = precedingNode;",
                        "      comment.followingNode = followingNode;",
                        "      args = [comment, text, options, ast, isLastComment];",
                        "    }",
                        "",
                        "    if (isOwnLineComment(text, options, decoratedComments, index)) {",
                        "      comment.placement = \"ownLine\";",
                        "      // If a comment exists on its own line, prefer a leading comment.",
                        "      // We also need to check if it's the first line of the file.",
                        "      if (handleOwnLineComment(...args)) {",
                        "        // We're good",
                        "      } else if (followingNode) {",
                        "        // Always a leading comment.",
                        "        addLeadingComment(followingNode, comment);",
                        "      } else if (precedingNode) {",
                        "        addTrailingComment(precedingNode, comment);",
                        "      } else if (enclosingNode) {",
                        "        addDanglingComment(enclosingNode, comment);",
                        "      } else {",
                        "        // There are no nodes, let's attach it to the root of the ast",
                        "        /* c8 ignore next */",
                        "        addDanglingComment(ast, comment);",
                        "      }",
                        "    } else if (isEndOfLineComment(text, options, decoratedComments, index)) {",
                        "      comment.placement = \"endOfLine\";",
                        "      if (handleEndOfLineComment(...args)) {",
                        "        // We're good",
                        "      } else if (precedingNode) {",
                        "        // There is content before this comment on the same line, but",
                        "        // none after it, so prefer a trailing comment of the previous node.",
                        "        addTrailingComment(precedingNode, comment);",
                        "      } else if (followingNode) {",
                        "        addLeadingComment(followingNode, comment);",
                        "      } else if (enclosingNode) {",
                        "        addDanglingComment(enclosingNode, comment);",
                        "      } else {",
                        "        // There are no nodes, let's attach it to the root of the ast",
                        "        /* c8 ignore next */",
                        "        addDanglingComment(ast, comment);",
                        "      }",
                        "    } else {",
                        "      comment.placement = \"remaining\";",
                        "      if (handleRemainingComment(...args)) {",
                        "        // We're good",
                        "      } else if (precedingNode && followingNode) {",
                        "        // Otherwise, text exists both before and after the comment on",
                        "        // the same line. If there is both a preceding and following",
                        "        // node, use a tie-breaking algorithm to determine if it should",
                        "        // be attached to the next or previous node. In the last case,",
                        "        // simply attach the right node;",
                        "        const tieCount = tiesToBreak.length;",
                        "        if (tieCount > 0) {",
                        "          const lastTie = tiesToBreak[tieCount - 1];",
                        "          if (lastTie.followingNode !== followingNode) {",
                        "            breakTies(tiesToBreak, options);",
                        "          }",
                        "        }",
                        "        tiesToBreak.push(context);",
                        "      } else if (precedingNode) {",
                        "        addTrailingComment(precedingNode, comment);",
                        "      } else if (followingNode) {",
                        "        addLeadingComment(followingNode, comment);",
                        "      } else if (enclosingNode) {",
                        "        addDanglingComment(enclosingNode, comment);",
                        "      } else {",
                        "        // There are no nodes, let's attach it to the root of the ast",
                        "        /* c8 ignore next */",
                        "        addDanglingComment(ast, comment);",
                        "      }",
                        "    }",
                        "  }",
                        "",
                        "  breakTies(tiesToBreak, options);",
                        "",
                        "  if (!avoidAstMutation) {",
                        "    for (const comment of comments) {",
                        "      // These node references were useful for breaking ties, but we",
                        "      // don't need them anymore, and they create cycles in the AST that",
                        "      // may lead to infinite recursion if we don't delete them here.",
                        "      delete comment.precedingNode;",
                        "      delete comment.enclosingNode;",
                        "      delete comment.followingNode;",
                        "    }",
                        "  }",
                        "}",
                        "",
                        "const isAllEmptyAndNoLineBreak = (text) => !/[\\S\\n\\u2028\\u2029]/.test(text);",
                        "function isOwnLineComment(text, options, decoratedComments, commentIndex) {",
                        "  const { comment, precedingNode } = decoratedComments[commentIndex];",
                        "  const { locStart, locEnd } = options;",
                        "  let start = locStart(comment);",
                        "",
                        "  if (precedingNode) {",
                        "    // Find first comment on the same line",
                        "    for (let index = commentIndex - 1; index >= 0; index--) {",
                        "      const { comment, precedingNode: currentCommentPrecedingNode } =",
                        "        decoratedComments[index];",
                        "      if (",
                        "        currentCommentPrecedingNode !== precedingNode ||",
                        "        !isAllEmptyAndNoLineBreak(text.slice(locEnd(comment), start))",
                        "      ) {",
                        "        break;",
                        "      }",
                        "      start = locStart(comment);",
                        "    }",
                        "  }",
                        "",
                        "  return hasNewline(text, start, { backwards: true });",
                        "}",
                        "",
                        "function isEndOfLineComment(text, options, decoratedComments, commentIndex) {",
                        "  const { comment, followingNode } = decoratedComments[commentIndex];",
                        "  const { locStart, locEnd } = options;",
                        "  let end = locEnd(comment);",
                        "",
                        "  if (followingNode) {",
                        "    // Find last comment on the same line",
                        "    for (",
                        "      let index = commentIndex + 1;",
                        "      index < decoratedComments.length;",
                        "      index++",
                        "    ) {",
                        "      const { comment, followingNode: currentCommentFollowingNode } =",
                        "        decoratedComments[index];",
                        "      if (",
                        "        currentCommentFollowingNode !== followingNode ||",
                        "        !isAllEmptyAndNoLineBreak(text.slice(end, locStart(comment)))",
                        "      ) {",
                        "        break;",
                        "      }",
                        "      end = locEnd(comment);",
                        "    }",
                        "  }",
                        "",
                        "  return hasNewline(text, end);",
                        "}",
                        "",
                        "function breakTies(tiesToBreak, options) {",
                        "  const tieCount = tiesToBreak.length;",
                        "  if (tieCount === 0) {",
                        "    return;",
                        "  }",
                        "  const { precedingNode, followingNode } = tiesToBreak[0];",
                        "",
                        "  let gapEndPos = options.locStart(followingNode);",
                        "",
                        "  // Iterate backwards through tiesToBreak, examining the gaps between the tied",
                        "  // comments. In order to qualify as leading, a comment must be separated from",
                        "  // followingNode by an unbroken series of gaps (or other comments). By",
                        "  // default, gaps should only contain whitespace or open parentheses.",
                        "  // printer.isGap can be used to define custom logic for checking gaps.",
                        "  let indexOfFirstLeadingComment;",
                        "  for (",
                        "    indexOfFirstLeadingComment = tieCount;",
                        "    indexOfFirstLeadingComment > 0;",
                        "    --indexOfFirstLeadingComment",
                        "  ) {",
                        "    const {",
                        "      comment,",
                        "      precedingNode: currentCommentPrecedingNode,",
                        "      followingNode: currentCommentFollowingNode,",
                        "    } = tiesToBreak[indexOfFirstLeadingComment - 1];",
                        "    assert.strictEqual(currentCommentPrecedingNode, precedingNode);",
                        "    assert.strictEqual(currentCommentFollowingNode, followingNode);",
                        "",
                        "    const gap = options.originalText.slice(options.locEnd(comment), gapEndPos);",
                        "",
                        "    if (options.printer.isGap?.(gap, options) ?? /^[\\s(]*$/.test(gap)) {",
                        "      gapEndPos = options.locStart(comment);",
                        "    } else {",
                        "      // The gap string contained something other than whitespace or open",
                        "      // parentheses.",
                        "      break;",
                        "    }",
                        "  }",
                        "",
                        "  for (const [i, { comment }] of tiesToBreak.entries()) {",
                        "    if (i < indexOfFirstLeadingComment) {",
                        "      addTrailingComment(precedingNode, comment);",
                        "    } else {",
                        "      addLeadingComment(followingNode, comment);",
                        "    }",
                        "  }",
                        "",
                        "  for (const node of [precedingNode, followingNode]) {",
                        "    if (node.comments && node.comments.length > 1) {",
                        "      node.comments.sort((a, b) => options.locStart(a) - options.locStart(b));",
                        "    }",
                        "  }",
                        "",
                        "  tiesToBreak.length = 0;",
                        "}",
                        "",
                        "function findExpressionIndexForComment(quasis, comment, options) {",
                        "  const startPos = options.locStart(comment) - 1;",
                        "",
                        "  for (let i = 1; i < quasis.length; ++i) {",
                        "    if (startPos < options.locStart(quasis[i])) {",
                        "      return i - 1;",
                        "    }",
                        "  }",
                        "",
                        "  // We haven't found it, it probably means that some of the locations are off.",
                        "  // Let's just return the first one.",
                        "  /* c8 ignore next */",
                        "  return 0;",
                        "}",
                        "",
                        "export { attachComments, getSortedChildNodes };"
                    ]
                },
                "print.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import {",
                        "  line,",
                        "  hardline,",
                        "  breakParent,",
                        "  indent,",
                        "  lineSuffix,",
                        "  join,",
                        "} from \"../../document/builders.js\";",
                        "import { inheritLabel } from \"../../document/utils.js\";",
                        "import hasNewline from \"../../utils/has-newline.js\";",
                        "import skipNewline from \"../../utils/skip-newline.js\";",
                        "import { skipSpaces } from \"../../utils/skip.js\";",
                        "import isPreviousLineEmpty from \"../../utils/is-previous-line-empty.js\";",
                        "import isNonEmptyArray from \"../../utils/is-non-empty-array.js\";",
                        "",
                        "/**",
                        " * @typedef {import(\"../../common/ast-path.js\").default} AstPath",
                        " * @typedef {import(\"../../document/builders.js\").Doc} Doc",
                        " */",
                        "",
                        "const returnTrue = () => true;",
                        "",
                        "function printComment(path, options) {",
                        "  const comment = path.node;",
                        "  comment.printed = true;",
                        "  return options.printer.printComment(path, options);",
                        "}",
                        "",
                        "function printLeadingComment(path, options) {",
                        "  const comment = path.node;",
                        "  const parts = [printComment(path, options)];",
                        "",
                        "  const { printer, originalText, locStart, locEnd } = options;",
                        "  const isBlock = printer.isBlockComment?.(comment);",
                        "",
                        "  // Leading block comments should see if they need to stay on the",
                        "  // same line or not.",
                        "  if (isBlock) {",
                        "    const lineBreak = hasNewline(originalText, locEnd(comment))",
                        "      ? hasNewline(originalText, locStart(comment), {",
                        "          backwards: true,",
                        "        })",
                        "        ? hardline",
                        "        : line",
                        "      : \" \";",
                        "",
                        "    parts.push(lineBreak);",
                        "  } else {",
                        "    parts.push(hardline);",
                        "  }",
                        "",
                        "  const index = skipNewline(",
                        "    originalText,",
                        "    skipSpaces(originalText, locEnd(comment))",
                        "  );",
                        "",
                        "  if (index !== false && hasNewline(originalText, index)) {",
                        "    parts.push(hardline);",
                        "  }",
                        "",
                        "  return parts;",
                        "}",
                        "",
                        "function printTrailingComment(path, options, previousComment) {",
                        "  const comment = path.node;",
                        "  const printed = printComment(path, options);",
                        "",
                        "  const { printer, originalText, locStart } = options;",
                        "  const isBlock = printer.isBlockComment?.(comment);",
                        "",
                        "  if (",
                        "    (previousComment?.hasLineSuffix && !previousComment?.isBlock) ||",
                        "    hasNewline(originalText, locStart(comment), { backwards: true })",
                        "  ) {",
                        "    // This allows comments at the end of nested structures:",
                        "    // {",
                        "    //   x: 1,",
                        "    //   y: 2",
                        "    //   // A comment",
                        "    // }",
                        "    // Those kinds of comments are almost always leading comments, but",
                        "    // here it doesn't go \"outside\" the block and turns it into a",
                        "    // trailing comment for `2`. We can simulate the above by checking",
                        "    // if this a comment on its own line; normal trailing comments are",
                        "    // always at the end of another expression.",
                        "",
                        "    const isLineBeforeEmpty = isPreviousLineEmpty(",
                        "      originalText,",
                        "      locStart(comment)",
                        "    );",
                        "",
                        "    return {",
                        "      doc: lineSuffix([hardline, isLineBeforeEmpty ? hardline : \"\", printed]),",
                        "      isBlock,",
                        "      hasLineSuffix: true,",
                        "    };",
                        "  }",
                        "",
                        "  if (!isBlock || previousComment?.hasLineSuffix) {",
                        "    return {",
                        "      doc: [lineSuffix([\" \", printed]), breakParent],",
                        "      isBlock,",
                        "      hasLineSuffix: true,",
                        "    };",
                        "  }",
                        "",
                        "  return { doc: [\" \", printed], isBlock, hasLineSuffix: false };",
                        "}",
                        "",
                        "/**",
                        " * @param {AstPath} path",
                        " * @param {{",
                        " *  indent?: boolean,",
                        " *  marker?: symbol,",
                        " *  filter?: (comment) => boolean,",
                        " * }} [danglingCommentsPrintOptions]",
                        " * @returns {Doc}",
                        " */",
                        "function printDanglingComments(",
                        "  path,",
                        "  options,",
                        "  danglingCommentsPrintOptions = {}",
                        ") {",
                        "  const { node } = path;",
                        "",
                        "  if (!isNonEmptyArray(node?.comments)) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const {",
                        "    indent: shouldIndent = false,",
                        "    marker,",
                        "    filter = returnTrue,",
                        "  } = danglingCommentsPrintOptions;",
                        "",
                        "  const parts = [];",
                        "  path.each(({ node: comment }) => {",
                        "    if (",
                        "      comment.leading ||",
                        "      comment.trailing ||",
                        "      comment.marker !== marker ||",
                        "      !filter(comment)",
                        "    ) {",
                        "      return;",
                        "    }",
                        "",
                        "    parts.push(printComment(path, options));",
                        "  }, \"comments\");",
                        "",
                        "  if (parts.length === 0) {",
                        "    return \"\";",
                        "  }",
                        "",
                        "  const doc = join(hardline, parts);",
                        "  return shouldIndent ? indent([hardline, doc]) : doc;",
                        "}",
                        "",
                        "function printCommentsSeparately(path, options) {",
                        "  const value = path.node;",
                        "  if (!value) {",
                        "    return {};",
                        "  }",
                        "",
                        "  const ignored = options[Symbol.for(\"printedComments\")];",
                        "  const comments = (value.comments || []).filter(",
                        "    (comment) => !ignored.has(comment)",
                        "  );",
                        "",
                        "  if (comments.length === 0) {",
                        "    return { leading: \"\", trailing: \"\" };",
                        "  }",
                        "",
                        "  const leadingParts = [];",
                        "  const trailingParts = [];",
                        "  let printedTrailingComment;",
                        "  path.each(() => {",
                        "    const comment = path.node;",
                        "    if (ignored?.has(comment)) {",
                        "      return;",
                        "    }",
                        "",
                        "    const { leading, trailing } = comment;",
                        "    if (leading) {",
                        "      leadingParts.push(printLeadingComment(path, options));",
                        "    } else if (trailing) {",
                        "      printedTrailingComment = printTrailingComment(",
                        "        path,",
                        "        options,",
                        "        printedTrailingComment",
                        "      );",
                        "      trailingParts.push(printedTrailingComment.doc);",
                        "    }",
                        "  }, \"comments\");",
                        "",
                        "  return { leading: leadingParts, trailing: trailingParts };",
                        "}",
                        "",
                        "function printComments(path, doc, options) {",
                        "  const { leading, trailing } = printCommentsSeparately(path, options);",
                        "  if (!leading && !trailing) {",
                        "    return doc;",
                        "  }",
                        "  return inheritLabel(doc, (doc) => [leading, doc, trailing]);",
                        "}",
                        "",
                        "function ensureAllCommentsPrinted(options) {",
                        "  const {",
                        "    [Symbol.for(\"comments\")]: comments,",
                        "    [Symbol.for(\"printedComments\")]: printedComments,",
                        "  } = options;",
                        "",
                        "  for (const comment of comments) {",
                        "    if (!comment.printed && !printedComments.has(comment)) {",
                        "      throw new Error(",
                        "        'Comment \"' +",
                        "          comment.value.trim() +",
                        "          '\" was not printed. Please report this error!'",
                        "      );",
                        "    }",
                        "    delete comment.printed;",
                        "  }",
                        "}",
                        "",
                        "export {",
                        "  printComments,",
                        "  printCommentsSeparately,",
                        "  printDanglingComments,",
                        "  ensureAllCommentsPrinted,",
                        "};"
                    ]
                },
                "utils.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function describeNodeForDebugging(node) {",
                        "  const nodeType = node.type || node.kind || \"(unknown type)\";",
                        "  let nodeName = String(",
                        "    node.name ||",
                        "      (node.id && (typeof node.id === \"object\" ? node.id.name : node.id)) ||",
                        "      (node.key && (typeof node.key === \"object\" ? node.key.name : node.key)) ||",
                        "      (node.value &&",
                        "        (typeof node.value === \"object\" ? \"\" : String(node.value))) ||",
                        "      node.operator ||",
                        "      \"\"",
                        "  );",
                        "  if (nodeName.length > 20) {",
                        "    nodeName = nodeName.slice(0, 19) + \"\";",
                        "  }",
                        "  return nodeType + (nodeName ? \" \" + nodeName : \"\");",
                        "}",
                        "",
                        "function addCommentHelper(node, comment) {",
                        "  const comments = (node.comments ??= []);",
                        "  comments.push(comment);",
                        "  comment.printed = false;",
                        "  comment.nodeDescription = describeNodeForDebugging(node);",
                        "}",
                        "",
                        "function addLeadingComment(node, comment) {",
                        "  comment.leading = true;",
                        "  comment.trailing = false;",
                        "  addCommentHelper(node, comment);",
                        "}",
                        "",
                        "function addDanglingComment(node, comment, marker) {",
                        "  comment.leading = false;",
                        "  comment.trailing = false;",
                        "  if (marker) {",
                        "    comment.marker = marker;",
                        "  }",
                        "  addCommentHelper(node, comment);",
                        "}",
                        "",
                        "function addTrailingComment(node, comment) {",
                        "  comment.leading = false;",
                        "  comment.trailing = true;",
                        "  addCommentHelper(node, comment);",
                        "}",
                        "",
                        "export { addLeadingComment, addDanglingComment, addTrailingComment };"
                    ]
                }
            },
            "plugins": {
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { clearCache as clearPluginLoadCache } from \"./load-plugin.js\";",
                        "import { clearCache as clearPluginSearchCache } from \"./search-plugins.js\";",
                        "",
                        "export function clearCache() {",
                        "  clearPluginLoadCache();",
                        "  clearPluginSearchCache();",
                        "}",
                        "export { default as loadBuiltinPlugins } from \"./load-builtin-plugins.js\";",
                        "export { default as loadPlugins } from \"./load-plugins.js\";",
                        "export { searchPlugins } from \"./search-plugins.js\";"
                    ]
                },
                "load-builtin-plugins.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "let builtinPlugins;",
                        "",
                        "async function loadBuiltinPlugins() {",
                        "  builtinPlugins ??= await Promise.all([",
                        "    import(\"../../plugins/estree.js\"),",
                        "    import(\"../../plugins/babel.js\"),",
                        "    import(\"../../plugins/flow.js\"),",
                        "    import(\"../../plugins/typescript.js\"),",
                        "    import(\"../../plugins/acorn.js\"),",
                        "    import(\"../../plugins/meriyah.js\"),",
                        "    import(\"../../plugins/angular.js\"),",
                        "    import(\"../../plugins/postcss.js\"),",
                        "    import(\"../../plugins/graphql.js\"),",
                        "    import(\"../../plugins/markdown.js\"),",
                        "    import(\"../../plugins/glimmer.js\"),",
                        "    import(\"../../plugins/html.js\"),",
                        "    import(\"../../plugins/yaml.js\"),",
                        "  ]);",
                        "",
                        "  return builtinPlugins;",
                        "}",
                        "",
                        "export default loadBuiltinPlugins;"
                    ]
                },
                "load-plugin.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { pathToFileURL } from \"node:url\";",
                        "import path from \"node:path\";",
                        "import mem, { memClear } from \"mem\";",
                        "import importFromDirectory from \"../../utils/import-from-directory.js\";",
                        "",
                        "function normalizePlugin(pluginInstanceOfPluginModule, name) {",
                        "  const plugin =",
                        "    pluginInstanceOfPluginModule.default ?? pluginInstanceOfPluginModule;",
                        "  return { name, ...plugin };",
                        "}",
                        "",
                        "const loadPluginFromDirectory = mem(",
                        "  async (name, directory) =>",
                        "    normalizePlugin(await importFromDirectory(name, directory), name),",
                        "  { cacheKey: JSON.stringify }",
                        ");",
                        "",
                        "const importPlugin = mem(async (name) => {",
                        "  try {",
                        "    // try local files",
                        "    return await import(pathToFileURL(path.resolve(name)).href);",
                        "  } catch {",
                        "    // try node modules",
                        "    return importFromDirectory(name, process.cwd());",
                        "  }",
                        "});",
                        "",
                        "async function loadPlugin(plugin) {",
                        "  if (typeof plugin === \"string\") {",
                        "    return normalizePlugin(await importPlugin(plugin), plugin);",
                        "  }",
                        "",
                        "  return plugin;",
                        "}",
                        "",
                        "function clearCache() {",
                        "  memClear(loadPluginFromDirectory);",
                        "  memClear(importPlugin);",
                        "}",
                        "",
                        "export { loadPlugin, loadPluginFromDirectory, clearCache };"
                    ]
                },
                "load-plugins.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { loadPlugin } from \"./load-plugin.js\";",
                        "",
                        "function loadPlugins(plugins = []) {",
                        "  return Promise.all(plugins.map((plugin) => loadPlugin(plugin)));",
                        "}",
                        "",
                        "export default loadPlugins;"
                    ]
                },
                "search-plugins.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import path from \"node:path\";",
                        "import { fileURLToPath } from \"node:url\";",
                        "import mem, { memClear } from \"mem\";",
                        "import fastGlob from \"fast-glob\";",
                        "import isDirectory from \"../../utils/is-directory.js\";",
                        "import mockable from \"../../common/mockable.js\";",
                        "import { loadPluginFromDirectory } from \"./load-plugin.js\";",
                        "",
                        "const __dirname = path.dirname(fileURLToPath(import.meta.url));",
                        "",
                        "const findNodeModules = mem((directory) =>",
                        "  mockable.findParentDir(directory, \"node_modules\")",
                        ");",
                        "",
                        "const findPluginsInNodeModules = mem(async (nodeModulesDir) => {",
                        "  const pluginPackageJsonPaths = await fastGlob(",
                        "    [",
                        "      \"prettier-plugin-*/package.json\",",
                        "      \"@*/prettier-plugin-*/package.json\",",
                        "      \"@prettier/plugin-*/package.json\",",
                        "    ],",
                        "    {",
                        "      cwd: nodeModulesDir,",
                        "    }",
                        "  );",
                        "  return pluginPackageJsonPaths.map(path.dirname);",
                        "});",
                        "",
                        "const searchPluginsInDirectory = mem(async (directory) => {",
                        "  const absolutePath = path.resolve(process.cwd(), directory);",
                        "  const nodeModulesDir = path.join(absolutePath, \"node_modules\");",
                        "",
                        "  // In some fringe cases (ex: files \"mounted\" as virtual directories), the",
                        "  // isDirectory(absolutePath) check might be false even though",
                        "  // the node_modules actually exists.",
                        "  if (",
                        "    !(await isDirectory(nodeModulesDir)) &&",
                        "    !(await isDirectory(absolutePath))",
                        "  ) {",
                        "    throw new Error(`${directory} does not exist or is not a directory`);",
                        "  }",
                        "",
                        "  const pluginNames = await findPluginsInNodeModules(nodeModulesDir);",
                        "",
                        "  return Promise.all(",
                        "    pluginNames.map((name) => loadPluginFromDirectory(name, nodeModulesDir))",
                        "  );",
                        "});",
                        "",
                        "const searchPlugins = mem(",
                        "  async (directories = []) => {",
                        "    // unless pluginSearchDirs are provided, auto-load plugins from node_modules that are parent to Prettier",
                        "    if (directories.length === 0) {",
                        "      const nodeModulesDirectory = findNodeModules(__dirname);",
                        "      if (nodeModulesDirectory) {",
                        "        directories = [nodeModulesDirectory];",
                        "      }",
                        "    }",
                        "",
                        "    return (",
                        "      await Promise.all(",
                        "        directories.map((directory) => searchPluginsInDirectory(directory))",
                        "      )",
                        "    ).flat();",
                        "  },",
                        "  { cacheKey: JSON.stringify }",
                        ");",
                        "",
                        "function clearCache() {",
                        "  memClear(searchPlugins);",
                        "  memClear(searchPluginsInDirectory);",
                        "  memClear(findPluginsInNodeModules);",
                        "  memClear(findNodeModules);",
                        "}",
                        "",
                        "export { searchPlugins, clearCache };"
                    ]
                }
            }
        },
        "plugins": {
            "acorn.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/acorn.js\"),",
                    "    parserNames: [\"acorn\"],",
                    "  },",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/espree.js\"),",
                    "    parserNames: [\"espree\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "angular.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/angular.js\"),",
                    "    parserNames: [",
                    "      \"__ng_action\",",
                    "      \"__ng_binding\",",
                    "      \"__ng_interpolation\",",
                    "      \"__ng_directive\",",
                    "    ],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "babel.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: async () =>",
                    "      (await import(\"../language-js/parse/babel.js\")).default,",
                    "    parserNames: [",
                    "      \"babel\",",
                    "      \"babel-flow\",",
                    "      \"babel-ts\",",
                    "      \"__js_expression\",",
                    "      \"__ts_expression\",",
                    "      \"__vue_expression\",",
                    "      \"__vue_ts_expression\",",
                    "      \"__vue_event_binding\",",
                    "      \"__vue_ts_event_binding\",",
                    "      \"__babel_estree\",",
                    "    ],",
                    "  },",
                    "  // JSON parsers are based on babel, bundle together to reduce package size",
                    "  {",
                    "    importParsers: async () =>",
                    "      (await import(\"../language-json/parser-json.js\")).default,",
                    "    parserNames: [\"json\", \"json5\", \"json-stringify\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "estree.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as estreePrinter from \"../language-js/printer-estree.js\";",
                    "import jsLanguages from \"../language-js/languages.evaluate.js\";",
                    "import * as estreeJsonPrinter from \"../language-json/printer-estree-json.js\";",
                    "import jsonLanguages from \"../language-json/languages.evaluate.js\";",
                    "import options from \"../language-js/options.js\";",
                    "",
                    "export const printers = {",
                    "  estree: estreePrinter,",
                    "  \"estree-json\": estreeJsonPrinter,",
                    "};",
                    "export const languages = [...jsLanguages, ...jsonLanguages];",
                    "export { options };",
                    "export default { printers, languages, options };"
                ]
            },
            "flow.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/flow.js\"),",
                    "    parserNames: [\"flow\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "glimmer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-handlebars/index.js\";",
                    "export * as default from \"../language-handlebars/index.js\";"
                ]
            },
            "graphql.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-graphql/index.js\";",
                    "export * as default from \"../language-graphql/index.js\";"
                ]
            },
            "html.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-html/index.js\";",
                    "export * as default from \"../language-html/index.js\";"
                ]
            },
            "markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-markdown/index.js\";",
                    "export * as default from \"../language-markdown/index.js\";"
                ]
            },
            "meriyah.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/meriyah.js\"),",
                    "    parserNames: [\"meriyah\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "postcss.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-css/index.js\";",
                    "export * as default from \"../language-css/index.js\";"
                ]
            },
            "typescript.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import createParsers from \"../utils/create-parsers.js\";",
                    "",
                    "export const parsers = createParsers([",
                    "  {",
                    "    importParsers: () => import(\"../language-js/parse/typescript.js\"),",
                    "    parserNames: [\"typescript\"],",
                    "  },",
                    "]);",
                    "export default { parsers };"
                ]
            },
            "yaml.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export * from \"../language-yaml/index.js\";",
                    "export * as default from \"../language-yaml/index.js\";"
                ]
            }
        },
        "utils": {
            "ast-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import isObject from \"./is-object.js\";",
                    "",
                    "/**",
                    " * @typedef {NonNullable<object>} Node",
                    " * @typedef {(unknown) => string[]} GetVisitorKeys",
                    " * @typedef {(unknown) => boolean} Predicate",
                    " */",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @param {{getVisitorKeys: GetVisitorKeys, filter?: Predicate}} options",
                    " */",
                    "function* getChildren(node, options) {",
                    "  const { getVisitorKeys, filter = () => true } = options;",
                    "  const isMatchedNode = (node) => isObject(node) && filter(node);",
                    "",
                    "  for (const key of getVisitorKeys(node)) {",
                    "    const value = node[key];",
                    "",
                    "    if (Array.isArray(value)) {",
                    "      for (const child of value) {",
                    "        if (isMatchedNode(child)) {",
                    "          yield child;",
                    "        }",
                    "      }",
                    "    } else if (isMatchedNode(value)) {",
                    "      yield value;",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @param {{getVisitorKeys: GetVisitorKeys, filter?: Predicate}} options",
                    " */",
                    "function* getDescendants(node, options) {",
                    "  const queue = [node];",
                    "  for (let index = 0; index < queue.length; index++) {",
                    "    const node = queue[index];",
                    "",
                    "    for (const child of getChildren(node, options)) {",
                    "      yield child;",
                    "      queue.push(child);",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "/**",
                    " * @param {Node} node",
                    " * @param {{getVisitorKeys: GetVisitorKeys, predicate: Predicate}} options",
                    " */",
                    "function hasDescendant(node, { getVisitorKeys, predicate }) {",
                    "  for (const descendant of getDescendants(node, { getVisitorKeys })) {",
                    "    if (predicate(descendant)) {",
                    "      return true;",
                    "    }",
                    "  }",
                    "",
                    "  return false;",
                    "}",
                    "",
                    "export { hasDescendant, getDescendants, getChildren };"
                ]
            },
            "create-get-visitor-keys.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import toFastProperties from \"to-fast-properties\";",
                    "",
                    "function createGetVisitorKeys(visitorKeys, typeProperty = \"type\") {",
                    "  toFastProperties(visitorKeys);",
                    "",
                    "  function getVisitorKeys(node) {",
                    "    const type = node[typeProperty];",
                    "",
                    "    /* c8 ignore next 5 */",
                    "    if (process.env.NODE_ENV !== \"production\" && type === undefined) {",
                    "      throw new Error(",
                    "        `Can't get node type, you must pass the wrong typeProperty '${typeProperty}'`",
                    "      );",
                    "    }",
                    "",
                    "    const keys = visitorKeys[type];",
                    "    /* c8 ignore next 5 */",
                    "    if (!Array.isArray(keys)) {",
                    "      throw Object.assign(new Error(`Missing visitor keys for '${type}'.`), {",
                    "        node,",
                    "      });",
                    "    }",
                    "",
                    "    return keys;",
                    "  }",
                    "",
                    "  return getVisitorKeys;",
                    "}",
                    "",
                    "export default createGetVisitorKeys;"
                ]
            },
            "create-group-id-mapper.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {string} description",
                    " * @returns {(node: any) => symbol}",
                    " */",
                    "function createGroupIdMapper(description) {",
                    "  const groupIds = new WeakMap();",
                    "  return function (node) {",
                    "    if (!groupIds.has(node)) {",
                    "      groupIds.set(node, Symbol(description));",
                    "    }",
                    "    return groupIds.get(node);",
                    "  };",
                    "}",
                    "",
                    "export default createGroupIdMapper;"
                ]
            },
            "create-language.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function createLanguage(linguistData, override) {",
                    "  const { languageId, ...rest } = linguistData;",
                    "  return {",
                    "    linguistLanguageId: languageId,",
                    "    ...rest,",
                    "    ...override(linguistData),",
                    "  };",
                    "}",
                    "",
                    "export default createLanguage;"
                ]
            },
            "create-parsers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function createParsers(modules) {",
                    "  const parsers = Object.create(null);",
                    "",
                    "  for (const { importParsers, parserNames } of modules) {",
                    "    for (const parserName of parserNames) {",
                    "      parsers[parserName] = async () =>",
                    "        Object.assign(parsers, await importParsers())[parserName];",
                    "    }",
                    "  }",
                    "",
                    "  return parsers;",
                    "}",
                    "",
                    "export default createParsers;"
                ]
            },
            "get-alignment-size.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {string} text",
                    " * @param {number} tabWidth",
                    " * @param {number=} startIndex",
                    " * @returns {number}",
                    " */",
                    "function getAlignmentSize(text, tabWidth, startIndex = 0) {",
                    "  let size = 0;",
                    "  for (let i = startIndex; i < text.length; ++i) {",
                    "    if (text[i] === \"\\t\") {",
                    "      // Tabs behave in a way that they are aligned to the nearest",
                    "      // multiple of tabWidth:",
                    "      // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4",
                    "      // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...",
                    "      size = size + tabWidth - (size % tabWidth);",
                    "    } else {",
                    "      size++;",
                    "    }",
                    "  }",
                    "",
                    "  return size;",
                    "}",
                    "",
                    "export default getAlignmentSize;"
                ]
            },
            "get-indent-size.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getAlignmentSize from \"./get-alignment-size.js\";",
                    "",
                    "/**",
                    " * @param {string} value",
                    " * @param {number} tabWidth",
                    " * @returns {number}",
                    " */",
                    "function getIndentSize(value, tabWidth) {",
                    "  const lastNewlineIndex = value.lastIndexOf(\"\\n\");",
                    "  /* c8 ignore next 3 */",
                    "  if (lastNewlineIndex === -1) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return getAlignmentSize(",
                    "    // All the leading whitespaces",
                    "    value.slice(lastNewlineIndex + 1).match(/^[\\t ]*/)[0],",
                    "    tabWidth",
                    "  );",
                    "}",
                    "",
                    "export default getIndentSize;"
                ]
            },
            "get-interpreter.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs\";",
                    "import readlines from \"n-readlines\";",
                    "",
                    "function getInterpreter(filepath) {",
                    "  /* c8 ignore next 3 */",
                    "  if (typeof filepath !== \"string\") {",
                    "    return \"\";",
                    "  }",
                    "",
                    "  let fd;",
                    "  try {",
                    "    fd = fs.openSync(filepath, \"r\");",
                    "  } catch {",
                    "    /* c8 ignore next */",
                    "    return \"\";",
                    "  }",
                    "",
                    "  try {",
                    "    const liner = new readlines(fd);",
                    "    const firstLine = liner.next().toString(\"utf8\");",
                    "",
                    "    // #!/bin/env node, #!/usr/bin/env node",
                    "    const m1 = firstLine.match(/^#!\\/(?:usr\\/)?bin\\/env\\s+(\\S+)/);",
                    "    if (m1) {",
                    "      return m1[1];",
                    "    }",
                    "",
                    "    // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node",
                    "    const m2 = firstLine.match(/^#!\\/(?:usr\\/(?:local\\/)?)?bin\\/(\\S+)/);",
                    "    if (m2) {",
                    "      return m2[1];",
                    "    }",
                    "    return \"\";",
                    "  } catch {",
                    "    // There are some weird cases where paths are missing, causing Jest",
                    "    // failures. It's unclear what these correspond to in the real world.",
                    "    /* c8 ignore next */",
                    "    return \"\";",
                    "  } finally {",
                    "    try {",
                    "      // There are some weird cases where paths are missing, causing Jest",
                    "      // failures. It's unclear what these correspond to in the real world.",
                    "      fs.closeSync(fd);",
                    "    } catch {",
                    "      // nop",
                    "    }",
                    "  }",
                    "}",
                    "",
                    "export default getInterpreter;"
                ]
            },
            "get-max-continuous-count.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import escapeStringRegexp from \"escape-string-regexp\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {string} searchString",
                    " * @returns {number}",
                    " */",
                    "function getMaxContinuousCount(text, searchString) {",
                    "  const results = text.match(",
                    "    new RegExp(`(${escapeStringRegexp(searchString)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (results === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  return results.reduce(",
                    "    (maxCount, result) =>",
                    "      Math.max(maxCount, result.length / searchString.length),",
                    "    0",
                    "  );",
                    "}",
                    "",
                    "export default getMaxContinuousCount;"
                ]
            },
            "get-min-not-present-continuous-count.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import escapeStringRegexp from \"escape-string-regexp\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {string} searchString",
                    " * @returns {number}",
                    " */",
                    "function getMinNotPresentContinuousCount(text, searchString) {",
                    "  const matches = text.match(",
                    "    new RegExp(`(${escapeStringRegexp(searchString)})+`, \"g\")",
                    "  );",
                    "",
                    "  if (matches === null) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  const countPresent = new Map();",
                    "  let max = 0;",
                    "",
                    "  for (const match of matches) {",
                    "    const count = match.length / searchString.length;",
                    "    countPresent.set(count, true);",
                    "    if (count > max) {",
                    "      max = count;",
                    "    }",
                    "  }",
                    "",
                    "  for (let i = 1; i < max; i++) {",
                    "    if (!countPresent.get(i)) {",
                    "      return i;",
                    "    }",
                    "  }",
                    "",
                    "  return max + 1;",
                    "}",
                    "",
                    "export default getMinNotPresentContinuousCount;"
                ]
            },
            "get-next-non-space-non-comment-character-index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import skipInlineComment from \"./skip-inline-comment.js\";",
                    "import skipNewline from \"./skip-newline.js\";",
                    "import skipTrailingComment from \"./skip-trailing-comment.js\";",
                    "import { skipSpaces } from \"./skip.js\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {number | false}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacterIndex(text, startIndex) {",
                    "  /** @type {number | false} */",
                    "  let oldIdx = null;",
                    "  /** @type {number | false} */",
                    "  let nextIdx = startIndex;",
                    "  while (nextIdx !== oldIdx) {",
                    "    oldIdx = nextIdx;",
                    "    nextIdx = skipSpaces(text, nextIdx);",
                    "    nextIdx = skipInlineComment(text, nextIdx);",
                    "    nextIdx = skipTrailingComment(text, nextIdx);",
                    "    nextIdx = skipNewline(text, nextIdx);",
                    "  }",
                    "  return nextIdx;",
                    "}",
                    "",
                    "export default getNextNonSpaceNonCommentCharacterIndex;"
                ]
            },
            "get-next-non-space-non-comment-character.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getNextNonSpaceNonCommentCharacterIndex from \"./get-next-non-space-non-comment-character-index.js\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {string}",
                    " */",
                    "function getNextNonSpaceNonCommentCharacter(text, startIndex) {",
                    "  const index = getNextNonSpaceNonCommentCharacterIndex(text, startIndex);",
                    "  return index === false ? \"\" : text.charAt(index);",
                    "}",
                    "",
                    "export default getNextNonSpaceNonCommentCharacter;"
                ]
            },
            "get-preferred-quote.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @typedef {SINGLE_QUOTE | DOUBLE_QUOTE} Quote",
                    " */",
                    "",
                    "const SINGLE_QUOTE = \"'\";",
                    "const DOUBLE_QUOTE = '\"';",
                    "",
                    "/**",
                    " *",
                    " * @param {string} rawContent",
                    " * @param {Quote | boolean} preferredQuoteOrPreferSingleQuote",
                    " * @returns {Quote}",
                    " */",
                    "function getPreferredQuote(rawContent, preferredQuoteOrPreferSingleQuote) {",
                    "  const preferred =",
                    "    preferredQuoteOrPreferSingleQuote === true ||",
                    "    preferredQuoteOrPreferSingleQuote === SINGLE_QUOTE",
                    "      ? SINGLE_QUOTE",
                    "      : DOUBLE_QUOTE;",
                    "  const alternate = preferred === SINGLE_QUOTE ? DOUBLE_QUOTE : SINGLE_QUOTE;",
                    "",
                    "  let preferredQuoteCount = 0;",
                    "  let alternateQuoteCount = 0;",
                    "  for (const character of rawContent) {",
                    "    if (character === preferred) {",
                    "      preferredQuoteCount++;",
                    "    } else if (character === alternate) {",
                    "      alternateQuoteCount++;",
                    "    }",
                    "  }",
                    "",
                    "  return preferredQuoteCount > alternateQuoteCount ? alternate : preferred;",
                    "}",
                    "",
                    "export default getPreferredQuote;"
                ]
            },
            "get-string-width.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import stringWidth from \"string-width\";",
                    "",
                    "const notAsciiRegex = /[^\\x20-\\x7F]/;",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @returns {number}",
                    " */",
                    "function getStringWidth(text) {",
                    "  if (!text) {",
                    "    return 0;",
                    "  }",
                    "",
                    "  // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`",
                    "  if (!notAsciiRegex.test(text)) {",
                    "    return text.length;",
                    "  }",
                    "",
                    "  return stringWidth(text);",
                    "}",
                    "",
                    "export default getStringWidth;"
                ]
            },
            "has-newline-in-range.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @param {number} endIndex",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewlineInRange(text, startIndex, endIndex) {",
                    "  for (let i = startIndex; i < endIndex; ++i) {",
                    "    if (text.charAt(i) === \"\\n\") {",
                    "      return true;",
                    "    }",
                    "  }",
                    "  return false;",
                    "}",
                    "",
                    "export default hasNewlineInRange;"
                ]
            },
            "has-newline.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { skipSpaces } from \"./skip.js\";",
                    "import skipNewline from \"./skip-newline.js\";",
                    "",
                    "/** @typedef {import(\"./skip.js\").SkipOptions} SkipOptions */",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @param {SkipOptions=} options",
                    " * @returns {boolean}",
                    " */",
                    "function hasNewline(text, startIndex, options = {}) {",
                    "  const idx = skipSpaces(",
                    "    text,",
                    "    options.backwards ? startIndex - 1 : startIndex,",
                    "    options",
                    "  );",
                    "  const idx2 = skipNewline(text, idx, options);",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "export default hasNewline;"
                ]
            },
            "has-spaces.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { skipSpaces } from \"./skip.js\";",
                    "",
                    "/** @typedef {import(\"./skip.js\").SkipOptions} SkipOptions */",
                    "",
                    "// Not using, but it's public utils",
                    "/* c8 ignore start */",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @param {SkipOptions=} options",
                    " * @returns {boolean}",
                    " */",
                    "function hasSpaces(text, startIndex, options = {}) {",
                    "  const idx = skipSpaces(",
                    "    text,",
                    "    options.backwards ? startIndex - 1 : startIndex,",
                    "    options",
                    "  );",
                    "  return idx !== startIndex;",
                    "}",
                    "/* c8 ignore stop */",
                    "",
                    "export default hasSpaces;"
                ]
            },
            "html-whitespace-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import WhitespaceUtils from \"./whitespace-utils.js\";",
                    "",
                    "// https://infra.spec.whatwg.org/#ascii-whitespace",
                    "const HTML_WHITESPACE_CHARACTERS = [\"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"];",
                    "const htmlWhitespaceUtils = new WhitespaceUtils(HTML_WHITESPACE_CHARACTERS);",
                    "",
                    "export default htmlWhitespaceUtils;"
                ]
            },
            "ignore.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import ignoreModule from \"ignore\";",
                    "import readFile from \"../utils/read-file.js\";",
                    "",
                    "const createIgnore = ignoreModule.default;",
                    "const slash =",
                    "  path.sep === \"\\\\\"",
                    "    ? (filepath) => filepath.replaceAll(\"\\\\\", \"/\")",
                    "    : (filepath) => filepath;",
                    "",
                    "/**",
                    " * @param {string?} ignoreFilePath",
                    " * @param {boolean?} withNodeModules",
                    " * @returns {Promise<(string) => boolean>}",
                    " */",
                    "async function createSingleIsIgnoredFunction(ignoreFilePath, withNodeModules) {",
                    "  let content = \"\";",
                    "",
                    "  if (ignoreFilePath) {",
                    "    content += (await readFile(ignoreFilePath)) ?? \"\";",
                    "  }",
                    "",
                    "  if (!withNodeModules) {",
                    "    content += \"\\n\" + \"node_modules\";",
                    "  }",
                    "",
                    "  if (!content) {",
                    "    return;",
                    "  }",
                    "",
                    "  const ignore = createIgnore({ allowRelativePaths: true }).add(content);",
                    "",
                    "  return (filepath) => {",
                    "    filepath = path.resolve(filepath);",
                    "",
                    "    // If there's an ignore-path set, the filename must be relative to the",
                    "    // ignore path, not the current working directory.",
                    "    const relativePath = ignoreFilePath",
                    "      ? path.relative(path.dirname(ignoreFilePath), filepath)",
                    "      : path.relative(process.cwd(), filepath);",
                    "",
                    "    return ignore.ignores(slash(relativePath));",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @param {string[]} ignoreFilePaths",
                    " * @param {boolean?} withNodeModules",
                    " * @returns {Promise<(string) => boolean>}",
                    " */",
                    "async function createIsIgnoredFunction(ignoreFilePaths, withNodeModules) {",
                    "  // If `ignoreFilePaths` is empty, we still want `withNodeModules` to work",
                    "  if (ignoreFilePaths.length === 0 && !withNodeModules) {",
                    "    ignoreFilePaths = [undefined];",
                    "  }",
                    "",
                    "  const isIgnoredFunctions = (",
                    "    await Promise.all(",
                    "      ignoreFilePaths.map((ignoreFilePath) =>",
                    "        createSingleIsIgnoredFunction(ignoreFilePath, withNodeModules)",
                    "      )",
                    "    )",
                    "  ).filter(Boolean);",
                    "",
                    "  return (filepath) =>",
                    "    isIgnoredFunctions.some((isIgnored) => isIgnored(filepath));",
                    "}",
                    "",
                    "/**",
                    " * @param {string[]} filepath",
                    " * @param {{ignorePath: string[], withNodeModules?: boolean}} options",
                    " * @returns {Promise<boolean>}",
                    " */",
                    "async function isIgnored(filepath, options) {",
                    "  const { ignorePath, withNodeModules } = options;",
                    "  const isIgnored = await createIsIgnoredFunction(ignorePath, withNodeModules);",
                    "  return isIgnored(filepath);",
                    "}",
                    "",
                    "export { createIsIgnoredFunction, isIgnored };"
                ]
            },
            "import-from-directory.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import path from \"node:path\";",
                    "import importFromFile from \"./import-from-file.js\";",
                    "",
                    "function importFromDirectory(specifier, directory) {",
                    "  return importFromFile(specifier, path.join(directory, \"noop.js\"));",
                    "}",
                    "",
                    "export default importFromDirectory;"
                ]
            },
            "import-from-file.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { pathToFileURL } from \"node:url\";",
                    "// TODO: Use `import.meta.resolve` when it's available",
                    "import { resolve } from \"import-meta-resolve\";",
                    "",
                    "async function importFromFile(specifier, parent) {",
                    "  const url = await resolve(specifier, pathToFileURL(parent).href);",
                    "  return import(url);",
                    "}",
                    "",
                    "export default importFromFile;"
                ]
            },
            "infer-parser.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getInterpreter from \"./get-interpreter.js\";",
                    "",
                    "// Didn't use `path.basename` since this module need work in browsers too",
                    "const getFileBasename = (file) => file.split(/[/\\\\]/).pop();",
                    "",
                    "function getLanguageByFilename(languages, filename) {",
                    "  if (!filename) {",
                    "    return;",
                    "  }",
                    "",
                    "  const basename = getFileBasename(filename).toLowerCase();",
                    "",
                    "  return languages.find(",
                    "    (language) =>",
                    "      language.extensions?.some((extension) => basename.endsWith(extension)) ||",
                    "      language.filenames?.some((name) => name.toLowerCase() === basename)",
                    "  );",
                    "}",
                    "",
                    "function getLanguageByName(languages, languageName) {",
                    "  if (!languageName) {",
                    "    return;",
                    "  }",
                    "",
                    "  return (",
                    "    languages.find(({ name }) => name.toLowerCase() === languageName) ??",
                    "    languages.find(({ aliases }) => aliases?.includes(languageName)) ??",
                    "    languages.find(({ extensions }) => extensions?.includes(`.${languageName}`))",
                    "  );",
                    "}",
                    "",
                    "function getLanguageByInterpreter(languages, file) {",
                    "  if (",
                    "    process.env.PRETTIER_TARGET === \"universal\" ||",
                    "    !file ||",
                    "    getFileBasename(file).includes(\".\")",
                    "  ) {",
                    "    return;",
                    "  }",
                    "",
                    "  const interpreter = getInterpreter(file);",
                    "",
                    "  if (!interpreter) {",
                    "    return;",
                    "  }",
                    "",
                    "  return languages.find((language) =>",
                    "    language.interpreters?.includes(interpreter)",
                    "  );",
                    "}",
                    "",
                    "/**",
                    " * @param {import(\"../index.js\").Options} options",
                    " * @param {{physicalFile?: string, file?: string, language?: string}} fileInfo",
                    " * @returns {string | void} matched parser name if found",
                    " */",
                    "function inferParser(options, fileInfo) {",
                    "  const languages = options.plugins.flatMap(",
                    "    (plugin) =>",
                    "      // @ts-expect-error -- Safe",
                    "      plugin.languages ?? []",
                    "  );",
                    "",
                    "  // If the file has no extension, we can try to infer the language from the",
                    "  // interpreter in the shebang line, if any; but since this requires FS access,",
                    "  // do it last.",
                    "  const language =",
                    "    getLanguageByName(languages, fileInfo.language) ??",
                    "    getLanguageByFilename(languages, fileInfo.physicalFile) ??",
                    "    getLanguageByFilename(languages, fileInfo.file) ??",
                    "    getLanguageByInterpreter(languages, fileInfo.physicalFile);",
                    "",
                    "  return language?.parsers[0];",
                    "}",
                    "",
                    "export default inferParser;"
                ]
            },
            "is-directory.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "",
                    "async function isDirectory(directory) {",
                    "  let stat;",
                    "",
                    "  try {",
                    "    stat = await fs.stat(directory);",
                    "  } catch {",
                    "    return false;",
                    "  }",
                    "",
                    "  return stat.isDirectory();",
                    "}",
                    "",
                    "export default isDirectory;"
                ]
            },
            "is-next-line-empty.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import skipNewline from \"./skip-newline.js\";",
                    "import { skipSpaces, skipToLineEnd } from \"./skip.js\";",
                    "import skipInlineComment from \"./skip-inline-comment.js\";",
                    "import skipTrailingComment from \"./skip-trailing-comment.js\";",
                    "import hasNewline from \"./has-newline.js\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {boolean}",
                    " */",
                    "function isNextLineEmpty(text, startIndex) {",
                    "  /** @type {number | false} */",
                    "  let oldIdx = null;",
                    "  /** @type {number | false} */",
                    "  let idx = startIndex;",
                    "  while (idx !== oldIdx) {",
                    "    // We need to skip all the potential trailing inline comments",
                    "    oldIdx = idx;",
                    "    idx = skipToLineEnd(text, idx);",
                    "    idx = skipInlineComment(text, idx);",
                    "    idx = skipSpaces(text, idx);",
                    "  }",
                    "  idx = skipTrailingComment(text, idx);",
                    "  idx = skipNewline(text, idx);",
                    "  return idx !== false && hasNewline(text, idx);",
                    "}",
                    "",
                    "export default isNextLineEmpty;"
                ]
            },
            "is-non-empty-array.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {unknown} object",
                    " * @returns {object is Array<any>}",
                    " */",
                    "function isNonEmptyArray(object) {",
                    "  return Array.isArray(object) && object.length > 0;",
                    "}",
                    "",
                    "export default isNonEmptyArray;"
                ]
            },
            "is-object.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {unknown} object",
                    " * @returns {object is NonNullable<object>}",
                    " */",
                    "function isObject(object) {",
                    "  return object !== null && typeof object === \"object\";",
                    "}",
                    "",
                    "export default isObject;"
                ]
            },
            "is-previous-line-empty.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import skipNewline from \"./skip-newline.js\";",
                    "import { skipSpaces } from \"./skip.js\";",
                    "",
                    "// Note: this function doesn't ignore leading comments unlike isNextLineEmpty",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {boolean}",
                    " */",
                    "function isPreviousLineEmpty(text, startIndex) {",
                    "  /** @type {number | false} */",
                    "  let idx = startIndex - 1;",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  idx = skipNewline(text, idx, { backwards: true });",
                    "  idx = skipSpaces(text, idx, { backwards: true });",
                    "  const idx2 = skipNewline(text, idx, { backwards: true });",
                    "  return idx !== idx2;",
                    "}",
                    "",
                    "export default isPreviousLineEmpty;"
                ]
            },
            "line-column-to-index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "// Super inefficient, needs to be cached.",
                    "function lineColumnToIndex(lineColumn, text) {",
                    "  let index = 0;",
                    "  for (let i = 0; i < lineColumn.line - 1; ++i) {",
                    "    index = text.indexOf(\"\\n\", index) + 1;",
                    "  }",
                    "  return index + lineColumn.column;",
                    "}",
                    "",
                    "export default lineColumnToIndex;"
                ]
            },
            "make-string.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/** @typedef {import(\"./get-preferred-quote.js\").Quote} Quote */",
                    "",
                    "/**",
                    " * @param {string} rawText",
                    " * @param {Quote} enclosingQuote",
                    " * @param {boolean=} unescapeUnnecessaryEscapes",
                    " * @returns {string}",
                    " */",
                    "function makeString(rawText, enclosingQuote, unescapeUnnecessaryEscapes) {",
                    "  const otherQuote = enclosingQuote === '\"' ? \"'\" : '\"';",
                    "",
                    "  // Matches _any_ escape and unescaped quotes (both single and double).",
                    "  const regex = /\\\\(.)|([\"'])/gs;",
                    "",
                    "  // Escape and unescape single and double quotes as needed to be able to",
                    "  // enclose `rawText` with `enclosingQuote`.",
                    "  const raw = rawText.replaceAll(regex, (match, escaped, quote) => {",
                    "    // If we matched an escape, and the escaped character is a quote of the",
                    "    // other type than we intend to enclose the string with, there's no need for",
                    "    // it to be escaped, so return it _without_ the backslash.",
                    "    if (escaped === otherQuote) {",
                    "      return escaped;",
                    "    }",
                    "",
                    "    // If we matched an unescaped quote and it is of the _same_ type as we",
                    "    // intend to enclose the string with, it must be escaped, so return it with",
                    "    // a backslash.",
                    "    if (quote === enclosingQuote) {",
                    "      return \"\\\\\" + quote;",
                    "    }",
                    "",
                    "    if (quote) {",
                    "      return quote;",
                    "    }",
                    "",
                    "    // Unescape any unnecessarily escaped character.",
                    "    // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27",
                    "    return unescapeUnnecessaryEscapes &&",
                    "      /^[^\\n\\r\"'0-7\\\\bfnrt-vx\\u2028\\u2029]$/.test(escaped)",
                    "      ? escaped",
                    "      : \"\\\\\" + escaped;",
                    "  });",
                    "",
                    "  return enclosingQuote + raw + enclosingQuote;",
                    "}",
                    "",
                    "export default makeString;"
                ]
            },
            "object-omit.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function omit(object, keys) {",
                    "  keys = new Set(keys);",
                    "  return Object.fromEntries(",
                    "    Object.entries(object).filter(([key]) => !keys.has(key))",
                    "  );",
                    "}",
                    "",
                    "export default omit;"
                ]
            },
            "partition.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @template Element",
                    " * @param {Array<Element>} array",
                    " * @param {(value: Element) => boolean} predicate",
                    " * @returns {[Array<Element>, Array<Element>]}",
                    " */",
                    "function partition(array, predicate) {",
                    "  /** @type {[Array<Element>, Array<Element>]} */",
                    "  const result = [[], []];",
                    "",
                    "  for (const value of array) {",
                    "    result[predicate(value) ? 0 : 1].push(value);",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "export default partition;"
                ]
            },
            "print-number.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function printNumber(rawNumber) {",
                    "  return (",
                    "    rawNumber",
                    "      .toLowerCase()",
                    "      // Remove unnecessary plus and zeroes from scientific notation.",
                    "      .replace(/^([+-]?[\\d.]+e)(?:\\+|(-))?0*(?=\\d)/, \"$1$2\")",
                    "      // Remove unnecessary scientific notation (1e0).",
                    "      .replace(/^([+-]?[\\d.]+)e[+-]?0+$/, \"$1\")",
                    "      // Make sure numbers always start with a digit.",
                    "      .replace(/^([+-])?\\./, \"$10.\")",
                    "      // Remove extraneous trailing decimal zeroes.",
                    "      .replace(/(\\.\\d+?)0+(?=e|$)/, \"$1\")",
                    "      // Remove trailing dot.",
                    "      .replace(/\\.(?=e|$)/, \"\")",
                    "  );",
                    "}",
                    "",
                    "export default printNumber;"
                ]
            },
            "print-string.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getPreferredQuote from \"./get-preferred-quote.js\";",
                    "import makeString from \"./make-string.js\";",
                    "",
                    "/** @typedef {import(\"./get-preferred-quote.js\").Quote} Quote */",
                    "",
                    "function printString(raw, options) {",
                    "  // `rawContent` is the string exactly like it appeared in the input source",
                    "  // code, without its enclosing quotes.",
                    "  const rawContent = raw.slice(1, -1);",
                    "",
                    "  /** @type {Quote} */",
                    "  const enclosingQuote =",
                    "    options.parser === \"json\" ||",
                    "    (options.parser === \"json5\" &&",
                    "      options.quoteProps === \"preserve\" &&",
                    "      !options.singleQuote)",
                    "      ? '\"'",
                    "      : options.__isInHtmlAttribute",
                    "      ? \"'\"",
                    "      : getPreferredQuote(rawContent, options.singleQuote);",
                    "",
                    "  // It might sound unnecessary to use `makeString` even if the string already",
                    "  // is enclosed with `enclosingQuote`, but it isn't. The string could contain",
                    "  // unnecessary escapes (such as in `\"\\'\"`). Always using `makeString` makes",
                    "  // sure that we consistently output the minimum amount of escaped quotes.",
                    "  return makeString(",
                    "    rawContent,",
                    "    enclosingQuote,",
                    "    !(",
                    "      options.parser === \"css\" ||",
                    "      options.parser === \"less\" ||",
                    "      options.parser === \"scss\" ||",
                    "      options.__embeddedInHtml",
                    "    )",
                    "  );",
                    "}",
                    "",
                    "export default printString;"
                ]
            },
            "public.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import getNextNonSpaceNonCommentCharacterIndexWithStartIndex from \"./get-next-non-space-non-comment-character-index.js\";",
                    "import isPreviousLineEmptyWithStartIndex from \"./is-previous-line-empty.js\";",
                    "import isNextLineEmptyAfterIndex from \"./is-next-line-empty.js\";",
                    "",
                    "// Legacy version of `getNextNonSpaceNonCommentCharacterIndex`",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {number | false}",
                    " */",
                    "function legacyGetNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {",
                    "  return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(",
                    "    text,",
                    "    locEnd(node)",
                    "  );",
                    "}",
                    "",
                    "// TODO: export `getNextNonSpaceNonCommentCharacterIndex` directly in v4",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {number | false}",
                    " */",
                    "export function getNextNonSpaceNonCommentCharacterIndex(text, startIndex) {",
                    "  return arguments.length === 2 || typeof startIndex === \"number\"",
                    "    ? getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, startIndex)",
                    "    : // @ts-expect-error -- expected",
                    "      // eslint-disable-next-line prefer-rest-params",
                    "      legacyGetNextNonSpaceNonCommentCharacterIndex(...arguments);",
                    "}",
                    "",
                    "// Legacy version of `isPreviousLineEmpty`",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locStart",
                    " */",
                    "function legacyIsPreviousLineEmpty(text, node, locStart) {",
                    "  return isPreviousLineEmptyWithStartIndex(text, locStart(node));",
                    "}",
                    "",
                    "// TODO: export `isPreviousLineEmpty` directly in v4",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {boolean}",
                    " */",
                    "export function isPreviousLineEmpty(text, startIndex) {",
                    "  return arguments.length === 2 || typeof startIndex === \"number\"",
                    "    ? isPreviousLineEmptyWithStartIndex(text, startIndex)",
                    "    : // @ts-expect-error -- expected",
                    "      // eslint-disable-next-line prefer-rest-params",
                    "      legacyIsPreviousLineEmpty(...arguments);",
                    "}",
                    "",
                    "// Legacy version of `isNextLineEmpty`",
                    "/**",
                    " * @template N",
                    " * @param {string} text",
                    " * @param {N} node",
                    " * @param {(node: N) => number} locEnd",
                    " * @returns {boolean}",
                    " */",
                    "function legacyIsNextLineEmpty(text, node, locEnd) {",
                    "  return isNextLineEmptyAfterIndex(text, locEnd(node));",
                    "}",
                    "",
                    "// TODO: export `isNextLineEmpty` directly in v4",
                    "/**",
                    " * @param {string} text",
                    " * @param {number} startIndex",
                    " * @returns {boolean}",
                    " */",
                    "export function isNextLineEmpty(text, startIndex) {",
                    "  return arguments.length === 2 || typeof startIndex === \"number\"",
                    "    ? isNextLineEmptyAfterIndex(text, startIndex)",
                    "    : // @ts-expect-error -- expected",
                    "      // eslint-disable-next-line prefer-rest-params",
                    "      legacyIsNextLineEmpty(...arguments);",
                    "}",
                    "",
                    "export { default as getMaxContinuousCount } from \"./get-max-continuous-count.js\";",
                    "export { default as getStringWidth } from \"./get-string-width.js\";",
                    "export { default as getAlignmentSize } from \"./get-alignment-size.js\";",
                    "export { default as getIndentSize } from \"./get-indent-size.js\";",
                    "export { default as skipNewline } from \"./skip-newline.js\";",
                    "export { default as skipInlineComment } from \"./skip-inline-comment.js\";",
                    "export { default as skipTrailingComment } from \"./skip-trailing-comment.js\";",
                    "export { default as hasNewline } from \"./has-newline.js\";",
                    "export { default as hasNewlineInRange } from \"./has-newline-in-range.js\";",
                    "export { default as hasSpaces } from \"./has-spaces.js\";",
                    "export { default as getNextNonSpaceNonCommentCharacter } from \"./get-next-non-space-non-comment-character.js\";",
                    "export { default as makeString } from \"./make-string.js\";",
                    "export {",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "} from \"./skip.js\";",
                    "export {",
                    "  addLeadingComment,",
                    "  addDanglingComment,",
                    "  addTrailingComment,",
                    "} from \"../main/comments/utils.js\";",
                    "",
                    "// TODO: Remove this in v4",
                    "export { isNextLineEmptyAfterIndex };"
                ]
            },
            "read-file.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import fs from \"node:fs/promises\";",
                    "",
                    "/**",
                    " * @param {string} filename",
                    " * @returns {Promise<undefined | string>}",
                    " */",
                    "async function readFile(filename) {",
                    "  try {",
                    "    return await fs.readFile(filename, \"utf8\");",
                    "  } catch (error) {",
                    "    if (error.code === \"ENOENT\") {",
                    "      return;",
                    "    }",
                    "",
                    "    throw new Error(`Unable to read '${filename}': ${error.message}`);",
                    "  }",
                    "}",
                    "",
                    "export default readFile;"
                ]
            },
            "require-from-file.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { createRequire } from \"node:module\";",
                    "",
                    "function requireFromFile(id, parent) {",
                    "  const require = createRequire(parent);",
                    "  return require(id);",
                    "}",
                    "",
                    "export default requireFromFile;"
                ]
            },
            "skip-inline-comment.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} startIndex",
                    " * @returns {number | false}",
                    " */",
                    "function skipInlineComment(text, startIndex) {",
                    "  /* c8 ignore next 3 */",
                    "  if (startIndex === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(startIndex) === \"/\" && text.charAt(startIndex + 1) === \"*\") {",
                    "    for (let i = startIndex + 2; i < text.length; ++i) {",
                    "      if (text.charAt(i) === \"*\" && text.charAt(i + 1) === \"/\") {",
                    "        return i + 2;",
                    "      }",
                    "    }",
                    "  }",
                    "  return startIndex;",
                    "}",
                    "",
                    "export default skipInlineComment;"
                ]
            },
            "skip-newline.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/** @typedef {import(\"./skip.js\").SkipOptions} SkipOptions */",
                    "",
                    "// This one doesn't use the above helper function because it wants to",
                    "// test \\r\\n in order and `skip` doesn't support ordering and we only",
                    "// want to skip one newline. It's simple to implement.",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} startIndex",
                    " * @param {SkipOptions=} options",
                    " * @returns {number | false}",
                    " */",
                    "function skipNewline(text, startIndex, options) {",
                    "  const backwards = Boolean(options?.backwards);",
                    "  if (startIndex === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const character = text.charAt(startIndex);",
                    "  if (backwards) {",
                    "    // We already replace `\\r\\n` with `\\n` before parsing",
                    "    /* c8 ignore next 3 */",
                    "    if (text.charAt(startIndex - 1) === \"\\r\" && character === \"\\n\") {",
                    "      return startIndex - 2;",
                    "    }",
                    "    if (",
                    "      character === \"\\n\" ||",
                    "      character === \"\\r\" ||",
                    "      character === \"\\u2028\" ||",
                    "      character === \"\\u2029\"",
                    "    ) {",
                    "      return startIndex - 1;",
                    "    }",
                    "  } else {",
                    "    // We already replace `\\r\\n` with `\\n` before parsing",
                    "    /* c8 ignore next 3 */",
                    "    if (character === \"\\r\" && text.charAt(startIndex + 1) === \"\\n\") {",
                    "      return startIndex + 2;",
                    "    }",
                    "    if (",
                    "      character === \"\\n\" ||",
                    "      character === \"\\r\" ||",
                    "      character === \"\\u2028\" ||",
                    "      character === \"\\u2029\"",
                    "    ) {",
                    "      return startIndex + 1;",
                    "    }",
                    "  }",
                    "",
                    "  return startIndex;",
                    "}",
                    "",
                    "export default skipNewline;"
                ]
            },
            "skip-trailing-comment.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import { skipEverythingButNewLine } from \"./skip.js\";",
                    "",
                    "/**",
                    " * @param {string} text",
                    " * @param {number | false} startIndex",
                    " * @returns {number | false}",
                    " */",
                    "function skipTrailingComment(text, startIndex) {",
                    "  /* c8 ignore next 3 */",
                    "  if (startIndex === false) {",
                    "    return false;",
                    "  }",
                    "",
                    "  if (text.charAt(startIndex) === \"/\" && text.charAt(startIndex + 1) === \"/\") {",
                    "    return skipEverythingButNewLine(text, startIndex);",
                    "  }",
                    "  return startIndex;",
                    "}",
                    "",
                    "export default skipTrailingComment;"
                ]
            },
            "skip.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/**",
                    " * @typedef {{backwards?: boolean}} SkipOptions",
                    " */",
                    "",
                    "/**",
                    " * @param {string | RegExp} characters",
                    " * @returns {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "function skip(characters) {",
                    "  return (text, startIndex, options) => {",
                    "    const backwards = Boolean(options?.backwards);",
                    "",
                    "    // Allow `skip` functions to be threaded together without having",
                    "    // to check for failures (did someone say monads?).",
                    "    /* c8 ignore next 3 */",
                    "    if (startIndex === false) {",
                    "      return false;",
                    "    }",
                    "",
                    "    const { length } = text;",
                    "    let cursor = startIndex;",
                    "    while (cursor >= 0 && cursor < length) {",
                    "      const character = text.charAt(cursor);",
                    "      if (characters instanceof RegExp) {",
                    "        if (!characters.test(character)) {",
                    "          return cursor;",
                    "        }",
                    "      } else if (!characters.includes(character)) {",
                    "        return cursor;",
                    "      }",
                    "",
                    "      backwards ? cursor-- : cursor++;",
                    "    }",
                    "",
                    "    if (cursor === -1 || cursor === length) {",
                    "      // If we reached the beginning or end of the file, return the",
                    "      // out-of-bounds cursor. It's up to the caller to handle this",
                    "      // correctly. We don't want to indicate `false` though if it",
                    "      // actually skipped valid characters.",
                    "      return cursor;",
                    "    }",
                    "    return false;",
                    "  };",
                    "}",
                    "",
                    "/**",
                    " * @type {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "const skipWhitespace = skip(/\\s/);",
                    "/**",
                    " * @type {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "const skipSpaces = skip(\" \\t\");",
                    "/**",
                    " * @type {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "const skipToLineEnd = skip(\",; \\t\");",
                    "/**",
                    " * @type {(text: string, startIndex: number | false, options?: SkipOptions) => number | false}",
                    " */",
                    "const skipEverythingButNewLine = skip(/[^\\n\\r]/);",
                    "",
                    "export {",
                    "  skip,",
                    "  skipWhitespace,",
                    "  skipSpaces,",
                    "  skipToLineEnd,",
                    "  skipEverythingButNewLine,",
                    "};"
                ]
            },
            "try-combinations.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function tryCombinations(combinations) {",
                    "  const errors = [];",
                    "  for (const fn of combinations) {",
                    "    try {",
                    "      return fn();",
                    "    } catch (error) {",
                    "      errors.push(error);",
                    "    }",
                    "  }",
                    "",
                    "  // TODO: Use `AggregateError` when we drop Node.js v14",
                    "  // throw new AggregateError(errors, \"All combinations failed\");",
                    "  throw Object.assign(new Error(\"All combinations failed\"), { errors });",
                    "}",
                    "",
                    "export default tryCombinations;"
                ]
            },
            "unexpected-node-error.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "class UnexpectedNodeError extends Error {",
                    "  name = \"UnexpectedNodeError\";",
                    "",
                    "  constructor(node, language, typeProperty = \"type\") {",
                    "    super(",
                    "      `Unexpected ${language} node ${typeProperty}: ${JSON.stringify(",
                    "        node[typeProperty]",
                    "      )}.`",
                    "    );",
                    "    this.node = node;",
                    "  }",
                    "}",
                    "",
                    "export default UnexpectedNodeError;"
                ]
            },
            "whitespace-utils.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import escapeStringRegexp from \"escape-string-regexp\";",
                    "",
                    "class WhitespaceUtils {",
                    "  #whitespaceCharacters;",
                    "",
                    "  constructor(whitespaceCharacters) {",
                    "    this.#whitespaceCharacters = new Set(whitespaceCharacters);",
                    "",
                    "    if (",
                    "      process.env.NODE_ENV !== \"production\" &&",
                    "      (this.#whitespaceCharacters.size === 0 ||",
                    "        Array.prototype.some.call(",
                    "          whitespaceCharacters,",
                    "          (character) => !/^\\s$/.test(character)",
                    "        ))",
                    "    ) {",
                    "      throw new TypeError(",
                    "        `Invalid characters: ${JSON.stringify(whitespaceCharacters)}`",
                    "      );",
                    "    }",
                    "  }",
                    "",
                    "  getLeadingWhitespaceCount(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    let count = 0;",
                    "",
                    "    for (",
                    "      let index = 0;",
                    "      index < text.length && whitespaceCharacters.has(text.charAt(index));",
                    "      index++",
                    "    ) {",
                    "      count++;",
                    "    }",
                    "",
                    "    return count;",
                    "  }",
                    "",
                    "  getTrailingWhitespaceCount(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    let count = 0;",
                    "",
                    "    for (",
                    "      let index = text.length - 1;",
                    "      index >= 0 && whitespaceCharacters.has(text.charAt(index));",
                    "      index--",
                    "    ) {",
                    "      count++;",
                    "    }",
                    "",
                    "    return count;",
                    "  }",
                    "",
                    "  getLeadingWhitespace(text) {",
                    "    const count = this.getLeadingWhitespaceCount(text);",
                    "    return text.slice(0, count);",
                    "  }",
                    "",
                    "  getTrailingWhitespace(text) {",
                    "    const count = this.getTrailingWhitespaceCount(text);",
                    "    return text.slice(text.length - count);",
                    "  }",
                    "",
                    "  hasLeadingWhitespace(text) {",
                    "    return this.#whitespaceCharacters.has(text.charAt(0));",
                    "  }",
                    "",
                    "  hasTrailingWhitespace(text) {",
                    "    return this.#whitespaceCharacters.has(text.at(-1));",
                    "  }",
                    "",
                    "  trimStart(text) {",
                    "    const count = this.getLeadingWhitespaceCount(text);",
                    "    return text.slice(count);",
                    "  }",
                    "",
                    "  trimEnd(text) {",
                    "    const count = this.getTrailingWhitespaceCount(text);",
                    "    return text.slice(0, text.length - count);",
                    "  }",
                    "",
                    "  trim(text) {",
                    "    return this.trimEnd(this.trimStart(text));",
                    "  }",
                    "",
                    "  split(text, captureWhitespace = false) {",
                    "    const pattern = `[${escapeStringRegexp(",
                    "      [...this.#whitespaceCharacters].join(\"\")",
                    "    )}]+`;",
                    "    const regexp = new RegExp(captureWhitespace ? `(${pattern})` : pattern);",
                    "    return text.split(regexp);",
                    "  }",
                    "",
                    "  hasWhitespaceCharacter(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    return Array.prototype.some.call(text, (character) =>",
                    "      whitespaceCharacters.has(character)",
                    "    );",
                    "  }",
                    "",
                    "  hasNonWhitespaceCharacter(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    return Array.prototype.some.call(",
                    "      text,",
                    "      (character) => !whitespaceCharacters.has(character)",
                    "    );",
                    "  }",
                    "",
                    "  isWhitespaceOnly(text) {",
                    "    const whitespaceCharacters = this.#whitespaceCharacters;",
                    "    return Array.prototype.every.call(text, (character) =>",
                    "      whitespaceCharacters.has(character)",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "export default WhitespaceUtils;"
                ]
            },
            "front-matter": {
                "is-front-matter.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "function isFrontMatter(node) {",
                        "  return node?.type === \"front-matter\";",
                        "}",
                        "",
                        "export default isFrontMatter;"
                    ]
                },
                "parse.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "const frontMatterRegex = new RegExp(",
                        "  \"^(?<startDelimiter>-{3}|\\\\+{3})\" +",
                        "    // trailing spaces after delimiters are allowed",
                        "    \"(?<language>[^\\\\n]*)\" +",
                        "    \"\\\\n(?:|(?<value>.*?)\\\\n)\" +",
                        "    // In some markdown processors such as pandoc,",
                        "    // \"...\" can be used as the end delimiter for YAML front-matter.",
                        "    // Adding `\\.{3}` make the regex matches `+++\\n...`, but we'll exclude it later",
                        "    \"(?<endDelimiter>\\\\k<startDelimiter>|\\\\.{3})\" +",
                        "    \"[^\\\\S\\\\n]*(?:\\\\n|$)\",",
                        "  \"s\"",
                        ");",
                        "",
                        "function parse(text) {",
                        "  const match = text.match(frontMatterRegex);",
                        "  if (!match) {",
                        "    return { content: text };",
                        "  }",
                        "",
                        "  const { startDelimiter, language, value = \"\", endDelimiter } = match.groups;",
                        "",
                        "  let lang = language.trim() || \"yaml\";",
                        "  if (startDelimiter === \"+++\") {",
                        "    lang = \"toml\";",
                        "  }",
                        "",
                        "  // Only allow yaml to parse with a different end delimiter",
                        "  if (lang !== \"yaml\" && startDelimiter !== endDelimiter) {",
                        "    return { content: text };",
                        "  }",
                        "",
                        "  const [raw] = match;",
                        "  const frontMatter = {",
                        "    type: \"front-matter\",",
                        "    lang,",
                        "    value,",
                        "    startDelimiter,",
                        "    endDelimiter,",
                        "    raw: raw.replace(/\\n$/, \"\"),",
                        "  };",
                        "",
                        "  return {",
                        "    frontMatter,",
                        "    content: raw.replaceAll(/[^\\n]/g, \" \") + text.slice(raw.length),",
                        "  };",
                        "}",
                        "",
                        "export default parse;"
                    ]
                },
                "print.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import { hardline, markAsRoot } from \"../../document/builders.js\";",
                        "",
                        "async function print(node, textToDoc) {",
                        "  if (node.lang === \"yaml\") {",
                        "    const value = node.value.trim();",
                        "    const doc = value ? await textToDoc(value, { parser: \"yaml\" }) : \"\";",
                        "    return markAsRoot([",
                        "      node.startDelimiter,",
                        "      hardline,",
                        "      doc,",
                        "      doc ? hardline : \"\",",
                        "      node.endDelimiter,",
                        "    ]);",
                        "  }",
                        "}",
                        "",
                        "export default print;"
                    ]
                }
            }
        }
    },
    "types": {
        "angular-html-parser": {
            "index.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "import \"angular-html-parser/lib/compiler/src/ml_parser/ast\";",
                    "import { HtmlTagDefinition } from \"angular-html-parser/lib/compiler/src/ml_parser/html_tags.js\";",
                    "",
                    "declare module \"angular-html-parser/lib/compiler/src/ml_parser/ast.js\" {",
                    "  interface Attribute {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "    // see restoreName in parser-html.js",
                    "    namespace?: string | null;",
                    "    hasExplicitNamespace?: boolean;",
                    "  }",
                    "",
                    "  interface CDATA {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface Comment {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface DocType {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "",
                    "  interface Element {",
                    "    tagDefinition: HtmlTagDefinition;",
                    "    // see restoreName in parser-html.js",
                    "    namespace?: string | null;",
                    "    hasExplicitNamespace?: boolean;",
                    "  }",
                    "",
                    "  interface Text {",
                    "    startSourceSpan: never;",
                    "    endSourceSpan: never;",
                    "  }",
                    "}"
                ]
            }
        },
        "espree": {
            "index.d.ts": {
                "classes": [],
                "functions": [],
                "text": [
                    "declare module \"espree\" {",
                    "  // https://github.com/eslint/espree#options",
                    "  export interface Options {",
                    "    range?: boolean;",
                    "    loc?: boolean;",
                    "    comment?: boolean;",
                    "    tokens?: boolean;",
                    "    ecmaVersion?: \"latest\";",
                    "    sourceType?: \"script\" | \"module\";",
                    "    ecmaFeatures?: {",
                    "      jsx?: boolean;",
                    "      globalReturn?: boolean;",
                    "      impliedStrict?: boolean;",
                    "    };",
                    "  }",
                    "  // https://github.com/eslint/espree#parse",
                    "  export function parse(code: string, options?: Options): any;",
                    "  // https://github.com/eslint/espree#tokenize",
                    "  export function tokenize(code: string, options?: Options): any;",
                    "}"
                ]
            }
        }
    },
    "website": {
        "README.md": {},
        "package.json": {},
        "sidebars.json": {},
        "siteConfig.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "",
                "// Docs: https://docusaurus.io/docs/en/site-config.html",
                "",
                "const path = require(\"path\");",
                "const fs = require(\"fs\");",
                "const { load: parseYaml } = require(\"js-yaml\");",
                "",
                "const PACKAGE = require(\"../package.json\");",
                "const GITHUB_URL = `https://github.com/${PACKAGE.repository}`;",
                "",
                "function loadYaml(fsPath) {",
                "  return parseYaml(fs.readFileSync(path.join(__dirname, fsPath), \"utf8\"));",
                "}",
                "",
                "const users = loadYaml(\"./data/users.yml\");",
                "const editors = loadYaml(\"./data/editors.yml\");",
                "const supportedLanguages = loadYaml(\"./data/languages.yml\");",
                "",
                "const siteConfig = {",
                "  title: \"Prettier\",",
                "  tagline: \"Opinionated Code Formatter\",",
                "  githubUrl: GITHUB_URL,",
                "  url: PACKAGE.homepage,",
                "  baseUrl: \"/\",",
                "  projectName: PACKAGE.name,",
                "  repo: PACKAGE.repository,",
                "  cname: \"prettier.io\",",
                "  users,",
                "  editors,",
                "  supportedLanguages,",
                "  tideliftUrl:",
                "    \"https://tidelift.com/subscription/pkg/npm-prettier?utm_source=npm-prettier&utm_medium=referral&utm_campaign=website\",",
                "  /* base url for editing docs, usage example: editUrl + 'en/doc1.md' */",
                "  editUrl: `${GITHUB_URL}/edit/main/docs/`,",
                "  headerLinks: [",
                "    { href: \"/playground/\", label: \"Playground\" },",
                "    { doc: \"index\", label: \"Docs\" },",
                "    { blog: true, label: \"Blog\" },",
                "    { search: true },",
                "    { href: \"https://opencollective.com/prettier\", label: \"Donate\" },",
                "    { href: GITHUB_URL, label: \"GitHub\" },",
                "  ],",
                "  /* path to images for header/footer */",
                "  headerIcon: \"icon.png\",",
                "  footerIcon: \"icon.png\",",
                "  favicon: \"icon.png\",",
                "  /* colors for website */",
                "  colors: {",
                "    primaryColor: \"#1A2B34\",",
                "    secondaryColor: \"#808080\",",
                "  },",
                "  highlight: {",
                "    theme: \"default\",",
                "    // eslint-disable-next-line import/no-extraneous-dependencies -- This is a docusaurus dependency",
                "    version: require(\"highlight.js/package.json\").version,",
                "  },",
                "  usePrism: [\"javascript\", \"jsx\", \"typescript\", \"ts\", \"js\", \"html\", \"css\"],",
                "  useEnglishUrl: true,",
                "  scripts: [",
                "    \"https://buttons.github.io/buttons.js\",",
                "    \"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js\",",
                "    \"/js/code-block-buttons.js\",",
                "  ],",
                "  stylesheets: [",
                "    \"//unpkg.com/@sandhose/prettier-animated-logo@1.0.3/dist/wide.css\",",
                "  ],",
                "  algolia: {",
                "    apiKey: process.env.ALGOLIA_PRETTIER_API_KEY,",
                "    indexName: \"prettier\",",
                "  },",
                "  markdownPlugins: [",
                "    // ignore `<!-- prettier-ignore -->` before passing into Docusaurus to avoid mis-parsing (#3322)",
                "    (md) => {",
                "      md.block.ruler.before(",
                "        \"htmlblock\",",
                "        \"prettierignore\",",
                "        (state, startLine) => {",
                "          const pos = state.bMarks[startLine];",
                "          const max = state.eMarks[startLine];",
                "          if (/<!-- prettier-ignore -->/.test(state.src.slice(pos, max))) {",
                "            state.line += 1;",
                "            return true;",
                "          }",
                "          return false;",
                "        }",
                "      );",
                "    },",
                "  ],",
                "  separateCss: [\"static/separate-css\"],",
                "  gaTrackingId: \"UA-111350464-1\",",
                "  twitter: true,",
                "  twitterUsername: \"PrettierCode\",",
                "  twitterImage: \"icon.png\",",
                "  ogImage: \"icon.png\",",
                "  onPageNav: \"separate\",",
                "};",
                "",
                "module.exports = siteConfig;"
            ]
        },
        "versions.json": {},
        "webpack.config.js": {
            "classes": [],
            "functions": [],
            "text": [
                "\"use strict\";",
                "const path = require(\"node:path\");",
                "",
                "module.exports = {",
                "  entry: {",
                "    playground: \"./playground/index.js\",",
                "  },",
                "  output: {",
                "    filename: \"[name].js\",",
                "    path: path.join(__dirname, \"static\"),",
                "  },",
                "  module: {",
                "    rules: [",
                "      {",
                "        test: /\\.js$/,",
                "        exclude: /node_modules/,",
                "        loader: \"babel-loader\",",
                "        options: {",
                "          presets: [\"@babel/env\", \"@babel/react\"],",
                "        },",
                "      },",
                "    ],",
                "  },",
                "  externals: {",
                "    clipboard: \"ClipboardJS\",",
                "    codemirror: \"CodeMirror\",",
                "    react: \"React\",",
                "    \"react-dom\": \"ReactDOM\",",
                "  },",
                "};"
            ]
        },
        "yarn.lock": {},
        "blog": {
            "2017-04-13-1.0.0.md": {},
            "2017-04-20-1.2.0.md": {},
            "2017-05-03-1.3.0.md": {},
            "2017-06-03-1.4.0.md": {},
            "2017-06-28-1.5.0.md": {},
            "2017-08-29-1.6.0.md": {},
            "2017-09-15-1.7.0.md": {},
            "2017-11-07-1.8.0.md": {},
            "2017-12-05-1.9.0.md": {},
            "2018-01-10-1.10.0.md": {},
            "2018-02-26-1.11.0.md": {},
            "2018-04-09-plugin-php-0.1.md": {},
            "2018-04-11-1.12.0.md": {},
            "2018-05-27-1.13.0.md": {},
            "2018-07-29-1.14.0.md": {},
            "2018-11-07-1.15.0.md": {},
            "2019-01-20-1.16.0.md": {},
            "2019-04-12-1.17.0.md": {},
            "2019-06-06-1.18.0.md": {},
            "2019-11-09-1.19.0.md": {},
            "2020-03-21-2.0.0.md": {},
            "2020-08-24-2.1.0.md": {},
            "2020-11-20-2.2.0.md": {},
            "2020-12-11-plugin-ruby-1.0.md": {},
            "2021-05-09-2.3.0.md": {},
            "2021-09-09-2.4.0.md": {},
            "2021-11-25-2.5.0.md": {},
            "2022-01-06-prettier-begins-paying-maintainers.md": {},
            "2022-03-16-2.6.0.md": {},
            "2022-06-14-2.7.0.md": {},
            "2022-11-23-2.8.0.md": {}
        },
        "core": {
            "Footer.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "const React = require(\"react\");",
                    "const PropTypes = require(\"prop-types\");",
                    "",
                    "const GithubButton = (props) => (",
                    "  <a",
                    "    className=\"github-button\"",
                    "    href={props.config.githubUrl}",
                    "    data-icon=\"octicon-star\"",
                    "    data-show-count=\"true\"",
                    "    aria-label=\"Star this project on GitHub\"",
                    "  >",
                    "    Star",
                    "  </a>",
                    ");",
                    "",
                    "GithubButton.propTypes = {",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "class Footer extends React.Component {",
                    "  url(path) {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}docs/${language}${path}`;",
                    "  }",
                    "",
                    "  usersUrl() {",
                    "    const language = this.props.language || \"en\";",
                    "    return `${this.props.config.baseUrl}${language}/users`;",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <footer className=\"footerSection nav-footer\" id=\"footer\">",
                    "        <section className=\"sitemap\">",
                    "          <a href={this.props.config.baseUrl} className=\"nav-home\">",
                    "            <img",
                    "              src={this.props.config.baseUrl + this.props.config.footerIcon}",
                    "              alt={this.props.config.title}",
                    "            />",
                    "          </a>",
                    "          <div>",
                    "            <h5>Docs</h5>",
                    "            <a href={this.url(\"/index.html\")}>About</a>",
                    "            <a href={this.url(\"/install.html\")}>Usage</a>",
                    "            <br />",
                    "            <a href=\"https://www.netlify.com\">",
                    "              <img src=\"https://www.netlify.com/img/global/badges/netlify-color-accent.svg\" />",
                    "            </a>",
                    "          </div>",
                    "          <div>",
                    "            <h5>Community</h5>",
                    "            <a href={this.usersUrl()}>User Showcase</a>",
                    "            <a",
                    "              href=\"http://stackoverflow.com/questions/tagged/prettier\"",
                    "              target=\"_blank\"",
                    "              rel=\"noopener noreferrer\"",
                    "            >",
                    "              Stack Overflow",
                    "            </a>",
                    "            <a href=\"https://twitter.com/PrettierCode\">",
                    "              @PrettierCode on Twitter",
                    "            </a>",
                    "            <object",
                    "              type=\"image/svg+xml\"",
                    "              data=\"https://img.shields.io/twitter/follow/prettiercode.svg?label=Follow+Prettier&style=social\"",
                    "            >",
                    "              <a href=\"https://twitter.com/intent/follow?screen_name=prettiercode\">",
                    "                <img",
                    "                  alt=\"Follow Prettier on Twitter\"",
                    "                  src=\"https://img.shields.io/twitter/follow/prettiercode.png?label=Follow+Prettier&style=social\"",
                    "                />",
                    "              </a>",
                    "            </object>",
                    "          </div>",
                    "          <div>",
                    "            <h5>More</h5>",
                    "            <a href={this.props.config.baseUrl + \"blog\"}>Blog</a>",
                    "            <a href={this.props.config.githubUrl}>GitHub</a>",
                    "            <a href={this.props.config.githubUrl + \"/issues\"}>Issues</a>",
                    "            <GithubButton config={this.props.config} />",
                    "          </div>",
                    "        </section>",
                    "      </footer>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "Footer.propTypes = {",
                    "  language: PropTypes.string,",
                    "  config: PropTypes.object,",
                    "};",
                    "",
                    "module.exports = Footer;"
                ]
            }
        },
        "data": {
            "editors.yml": {},
            "languages.yml": {},
            "users.yml": {}
        },
        "pages": {
            "googlefe164a33bda4034b.html": {},
            "playground-redirect.html": {},
            "en": {
                "index.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "const React = require(\"react\");",
                        "const PropTypes = require(\"prop-types\");",
                        "const AnimatedLogo = require(\"@sandhose/prettier-animated-logo\");",
                        "const { MarkdownBlock, Container } = require(\"../../core/CompLibrary.js\");",
                        "",
                        "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                        "",
                        "const ButtonGroup = (props) => (",
                        "  <div className=\"buttonGroup buttonWrapper\">{props.children}</div>",
                        ");",
                        "",
                        "ButtonGroup.propTypes = {",
                        "  children: PropTypes.node,",
                        "};",
                        "",
                        "class Button extends React.Component {",
                        "  render() {",
                        "    return (",
                        "      <div className=\"pluginWrapper buttonWrapper\">",
                        "        <a className=\"button\" href={this.props.href} target={this.props.target}>",
                        "          {this.props.children}",
                        "        </a>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Button.defaultProps = {",
                        "  target: \"_self\",",
                        "};",
                        "",
                        "Button.propTypes = {",
                        "  href: PropTypes.string,",
                        "  target: PropTypes.string,",
                        "  children: PropTypes.any,",
                        "};",
                        "",
                        "function Tidelift() {",
                        "  return (",
                        "    <a className=\"tidelift\" href={siteConfig.tideliftUrl}>",
                        "      PRETTIER FOR ENTERPRISE",
                        "    </a>",
                        "  );",
                        "}",
                        "",
                        "const HomeSplash = (props) => (",
                        "  <div className=\"homeContainer\">",
                        "    <Tidelift />",
                        "    <div className=\"homeSplashFade\">",
                        "      <div className=\"wrapper homeWrapper\">",
                        "        <div className=\"animatedLogoWrapper\">",
                        "          <AnimatedLogo version=\"wide\" />",
                        "        </div>",
                        "        <div className=\"inner\">",
                        "          <div className=\"section promoSection\">",
                        "            <div className=\"promoRow\">",
                        "              <div className=\"pluginRowBlock\">",
                        "                <Button href=\"/playground/\">Try It Online</Button>&nbsp;",
                        "                <Button href={\"/docs/\" + props.language + \"/install.html\"}>",
                        "                  Install Prettier",
                        "                </Button>",
                        "              </div>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </div>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "HomeSplash.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const TldrSection = ({ language }) => (",
                        "  <div className=\"tldrSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-evenly\",",
                        "        }}",
                        "      >",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>What is Prettier?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>An opinionated code formatter</li>",
                        "            <li>Supports many languages</li>",
                        "            <li>Integrates with most editors</li>",
                        "            <li>",
                        "              <a href={\"/docs/\" + language + \"/option-philosophy.html\"}>",
                        "                Has few options &raquo;",
                        "              </a>",
                        "            </li>",
                        "          </ul>",
                        "        </div>",
                        "        <div style={{ display: \"flex\", flexDirection: \"column\" }}>",
                        "          <h2>Why?</h2>",
                        "          <ul style={{ flex: \"1\" }}>",
                        "            <li>Your code is formatted on save</li>",
                        "            <li>No need to discuss style in code review</li>",
                        "            <li>Saves you time and energy</li>",
                        "            <li>",
                        "              <a href={\"/docs/\" + language + \"/why-prettier.html\"}>",
                        "                And more &raquo;",
                        "              </a>",
                        "            </li>",
                        "          </ul>",
                        "        </div>",
                        "      </div>",
                        "    </Container>",
                        "  </div>",
                        ");",
                        "",
                        "TldrSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "const Language = ({ name, nameLink, showName, image, variants }) => (",
                        "  <div",
                        "    className=\"languageCategory\"",
                        "    style={{",
                        "      display: \"flex\",",
                        "      alignItems: \"flex-start\",",
                        "      paddingBottom: \"1em\",",
                        "    }}",
                        "  >",
                        "    <img src={image} style={{ width: \"50px\", padding: \"0 20px\" }} />",
                        "    <ul>",
                        "      {showName && (",
                        "        <li className=\"accented\">",
                        "          {nameLink ? <a href={nameLink}>{name}</a> : name}",
                        "        </li>",
                        "      )}",
                        "      {variants.map((variant) => (",
                        "        <li key={variant}>",
                        "          <MarkdownBlock>{variant}</MarkdownBlock>",
                        "        </li>",
                        "      ))}",
                        "    </ul>",
                        "  </div>",
                        ");",
                        "",
                        "Language.propTypes = {",
                        "  name: PropTypes.string,",
                        "  nameLink: PropTypes.string,",
                        "  showName: PropTypes.bool,",
                        "  image: PropTypes.string,",
                        "  variants: PropTypes.array,",
                        "};",
                        "",
                        "const LanguagesSection = () => {",
                        "  const languageChunks = siteConfig.supportedLanguages.reduce(",
                        "    (acc, language) => {",
                        "      const last = acc.at(-1);",
                        "      if (",
                        "        last &&",
                        "        last.length < 2 &&",
                        "        last.reduce((sum, lang) => sum + lang.variants.length, 0) +",
                        "          language.variants.length <",
                        "          9",
                        "      ) {",
                        "        last.push(language);",
                        "      } else {",
                        "        acc.push([language]);",
                        "      }",
                        "      return acc;",
                        "    },",
                        "    []",
                        "  );",
                        "",
                        "  return (",
                        "    <div",
                        "      className=\"languagesSection productShowcaseSection\"",
                        "      style={{ textAlign: \"center\" }}",
                        "    >",
                        "      <Container>",
                        "        <h2>Works with the Tools You Use</h2>",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {languageChunks.map((languageChunk, index) => (",
                        "            <div key={index} style={{ flex: \"1 1 auto\" }}>",
                        "              {languageChunk.map((language) => (",
                        "                <Language key={language.name} {...language} />",
                        "              ))}",
                        "            </div>",
                        "          ))}",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "const Editor = ({ content = \"\", image, name }) => (",
                        "  <div className=\"editor\">",
                        "    <img className=\"editorImage\" src={image} />",
                        "    <div className=\"editorInfo\">",
                        "      <h3 className=\"editorName\">{name}</h3>",
                        "      <MarkdownBlock>{content.replaceAll(\"\\n\", \"  \\n\")}</MarkdownBlock>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "Editor.propTypes = {",
                        "  content: PropTypes.string,",
                        "  image: PropTypes.string.isRequired,",
                        "  name: PropTypes.string.isRequired,",
                        "};",
                        "",
                        "const EditorSupportSection = () => (",
                        "  <div className=\"editorSupportSection productShowcaseSection lightBackground\">",
                        "    <Container>",
                        "      <h2>Editor Support</h2>",
                        "      <div",
                        "        style={{",
                        "          display: \"flex\",",
                        "          flexFlow: \"row wrap\",",
                        "          justifyContent: \"space-around\",",
                        "        }}",
                        "      >",
                        "        {siteConfig.editors.map((editor) => (",
                        "          <Editor key={editor.name} {...editor} />",
                        "        ))}",
                        "      </div>",
                        "    </Container>",
                        "",
                        "    <div style={{ float: \"right\" }}>",
                        "      <span>Got more? </span>",
                        "      <a",
                        "        href={`${siteConfig.githubUrl}/edit/main/website/data/editors.yml`}",
                        "        className=\"button\"",
                        "      >",
                        "        Send a PR",
                        "      </a>",
                        "    </div>",
                        "  </div>",
                        ");",
                        "",
                        "const UsersSection = ({ language }) => {",
                        "  const showcase = siteConfig.users",
                        "    .filter((user) => user.pinned)",
                        "    .map((user, i) => (",
                        "      <a key={i} className=\"growOnHover alignCenter\" href={user.infoLink}>",
                        "        <img className=\"user\" src={user.greyImage} title={user.caption} />",
                        "      </a>",
                        "    ));",
                        "",
                        "  return (",
                        "    <div className=\"usersSection productShowcaseSection\">",
                        "      <Container>",
                        "        <h2>Used By People You Rely On</h2>",
                        "        <div style={{ textAlign: \"right\" }} />",
                        "        <div",
                        "          style={{",
                        "            display: \"flex\",",
                        "            flexFlow: \"row wrap\",",
                        "            justifyContent: \"space-around\",",
                        "          }}",
                        "        >",
                        "          {showcase}",
                        "        </div>",
                        "        <div className=\"more-users\">",
                        "          <a",
                        "            className=\"button\"",
                        "            href={siteConfig.baseUrl + language + \"/users/\"}",
                        "            target=\"_self\"",
                        "            style={{ marginRight: \"10px\" }}",
                        "          >",
                        "            See Others",
                        "          </a>",
                        "        </div>",
                        "",
                        "        <h2 className=\"ecosystemSubHeader\">Established in the Ecosystem</h2>",
                        "        <div",
                        "          className=\"ecosystemSubSection\"",
                        "          style={{",
                        "            display: \"flex\",",
                        "            justifyContent: \"space-around\",",
                        "            flexFlow: \"row wrap\",",
                        "          }}",
                        "        >",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a",
                        "              href=\"https://2021.stateofjs.com/en-US/other-tools/utilities\"",
                        "              style={{ marginTop: \"15px\" }}",
                        "            >",
                        "              <img",
                        "                src=\"/images/state_of_js_grey.svg\"",
                        "                style={{ width: \"80px\" }}",
                        "              />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>Regularly used by:</p>",
                        "              <ul style={{ marginBottom: \"0\" }}>",
                        "                <li>",
                        "                  <a href=\"https://2021.stateofjs.com/en-US/other-tools/#utilities\">",
                        "                    More than 83% of respondents to State of JS 2021.",
                        "                  </a>",
                        "                </li>",
                        "                <li>",
                        "                  <a href=\"https://2020.stateofjs.com/en-US/other-tools/#utilities\">",
                        "                    More than 70% of respondents to State of JS 2020.",
                        "                  </a>",
                        "                </li>",
                        "              </ul>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a href=\"https://github.com/prettier/prettier\">",
                        "              <img src=\"/images/github_grey.svg\" style={{ width: \"80px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than{\" \"}",
                        "                <strong data-placeholder=\"dependent-github\">5.2 million</strong>{\" \"}",
                        "                dependent repositories on GitHub",
                        "              </p>",
                        "              <Button href=\"https://github.com/prettier/prettier/network/dependents\">",
                        "                Check Them Out",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "",
                        "          <div style={{ display: \"flex\", marginTop: \"22px\" }}>",
                        "            <a href=\"https://npmjs.com/package/prettier\">",
                        "              <img src=\"/images/npm_grey.svg\" style={{ width: \"80px\" }} />",
                        "            </a>",
                        "            <div style={{ marginLeft: \".7em\", width: \"260px\" }}>",
                        "              <p>",
                        "                More than <strong data-placeholder=\"dependent-npm\">13k</strong>{\" \"}",
                        "                dependent packages on npm",
                        "              </p>",
                        "              <Button href=\"https://www.npmjs.com/browse/depended/prettier\">",
                        "                See them all",
                        "              </Button>",
                        "            </div>",
                        "          </div>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "};",
                        "",
                        "UsersSection.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "class Index extends React.Component {",
                        "  render() {",
                        "    const language = this.props.language || \"en\";",
                        "",
                        "    return (",
                        "      <div>",
                        "        <script src=\"landing.js\" />",
                        "        <HomeSplash language={language} />",
                        "        <div className=\"mainContainer landingContainer\">",
                        "          <TldrSection language={language} />",
                        "          <LanguagesSection />",
                        "          <EditorSupportSection />",
                        "          <UsersSection language={language} />",
                        "        </div>",
                        "      </div>",
                        "    );",
                        "  }",
                        "}",
                        "",
                        "Index.propTypes = {",
                        "  language: PropTypes.string,",
                        "};",
                        "",
                        "module.exports = Index;"
                    ]
                },
                "versions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "\"use strict\";",
                        "",
                        "/**",
                        " * Copyright (c) 2017-present, Facebook, Inc.",
                        " *",
                        " * This source code is licensed under the MIT license found in the",
                        " * LICENSE file in the root directory of this source tree.",
                        " */",
                        "",
                        "const React = require(\"react\");",
                        "const { Container } = require(\"../../core/CompLibrary.js\");",
                        "",
                        "const CWD = process.cwd();",
                        "",
                        "const versions = require(`${CWD}/versions.json`);",
                        "",
                        "const rootPackageJson = require(`${CWD}/../package.json`);",
                        "const defaultBranchVersion = rootPackageJson.version;",
                        "const isDefaultBranchDevVersion = defaultBranchVersion.endsWith(\"-dev\");",
                        "const devVersion = isDefaultBranchDevVersion ? defaultBranchVersion : null;",
                        "const latestVersion = isDefaultBranchDevVersion",
                        "  ? rootPackageJson.devDependencies.prettier",
                        "  : defaultBranchVersion;",
                        "const [latestDocsVersion, ...pastDocsVersions] = versions;",
                        "",
                        "function Versions(props) {",
                        "  const { config: siteConfig } = props;",
                        "  return (",
                        "    <div className=\"docMainWrapper wrapper\">",
                        "      <Container className=\"mainContainer versionsContainer\">",
                        "        <div className=\"post\">",
                        "          <header className=\"postHeader\">",
                        "            <h1>{siteConfig.title} Versions</h1>",
                        "          </header>",
                        "          <table className=\"versions\">",
                        "            <tbody>",
                        "              <tr>",
                        "                <th>Version</th>",
                        "                <th>Install with</th>",
                        "                <th>Documentation</th>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{latestVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/index.html`}>",
                        "                    {latestDocsVersion}",
                        "                  </a>{\" \"}",
                        "                  (latest)",
                        "                </td>",
                        "              </tr>",
                        "              <tr>",
                        "                <td>{devVersion}</td>",
                        "                <td>",
                        "                  <code>npm install prettier/prettier</code>",
                        "                </td>",
                        "                <td>",
                        "                  <a href={`${siteConfig.baseUrl}docs/en/next/index.html`}>",
                        "                    next",
                        "                  </a>{\" \"}",
                        "                  (main)",
                        "                </td>",
                        "              </tr>",
                        "              {pastDocsVersions.length > 0 &&",
                        "                pastDocsVersions.map((pastDocsVersion, index) => {",
                        "                  const pastMajorVersion = pastDocsVersion.replace(/^v/, \"\");",
                        "                  return (",
                        "                    <tr key={index}>",
                        "                      <td>{pastMajorVersion}.x</td>",
                        "                      <td>",
                        "                        <code>",
                        "                          npm install prettier@",
                        "                          {pastMajorVersion}",
                        "                        </code>",
                        "                      </td>",
                        "                      <td>",
                        "                        <a",
                        "                          href={`${siteConfig.baseUrl}docs/en/${pastDocsVersion}/index.html`}",
                        "                        >",
                        "                          {pastDocsVersion}",
                        "                        </a>",
                        "                      </td>",
                        "                    </tr>",
                        "                  );",
                        "                })}",
                        "            </tbody>",
                        "          </table>",
                        "        </div>",
                        "      </Container>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "module.exports = Versions;"
                    ]
                },
                "help": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container, GridBlock } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "class Help extends React.Component {",
                            "  render() {",
                            "    const supportLinks = [",
                            "      {",
                            "        content:",
                            "          \"Learn more using the [documentation on this site.](/docs/en/why-prettier.html)\\n\",",
                            "        title: \"Browse Docs\",",
                            "      },",
                            "      {",
                            "        content: \"Ask questions about the documentation and project\\n\",",
                            "        title: \"Join the community\",",
                            "      },",
                            "      {",
                            "        content: \"Find out what's new with this project\\n\",",
                            "        title: \"Stay up to date\",",
                            "      },",
                            "    ];",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"docMainWrapper wrapper\">",
                            "          <Container className=\"mainContainer documentContainer postContainer\">",
                            "            <div className=\"post\">",
                            "              <header className=\"postHeader\">",
                            "                <h2>Need help?</h2>",
                            "              </header>",
                            "              <p>This project is maintained by a dedicated group of people;</p>",
                            "              <GridBlock contents={supportLinks} layout=\"threeColumn\" />",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Help.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "module.exports = Help;"
                        ]
                    }
                },
                "users": {
                    "index.js": {
                        "classes": [],
                        "functions": [],
                        "text": [
                            "\"use strict\";",
                            "",
                            "const React = require(\"react\");",
                            "const { Container } = require(\"../../../core/CompLibrary.js\");",
                            "",
                            "const siteConfig = require(process.cwd() + \"/siteConfig.js\");",
                            "",
                            "class Users extends React.Component {",
                            "  render() {",
                            "    const showcase = siteConfig.users.map((user, i) => (",
                            "      <a key={i} href={user.infoLink}>",
                            "        <img src={user.image} title={user.caption} />",
                            "      </a>",
                            "    ));",
                            "",
                            "    return (",
                            "      <div>",
                            "        <div className=\"mainContainer\">",
                            "          <Container padding={[\"bottom\", \"top\"]}>",
                            "            <div className=\"showcaseSection\">",
                            "              <div className=\"prose\">",
                            "                <h1>Whos Using This?</h1>",
                            "              </div>",
                            "              <blockquote",
                            "                style={{",
                            "                  fontSize: \"125%\",",
                            "                  textAlign: \"left\",",
                            "                }}",
                            "              >",
                            "                <p>Prettier is regularly used by:</p>",
                            "                <ul>",
                            "                  <li>",
                            "                    <a href=\"https://2021.stateofjs.com/en-US/other-tools/#utilities\">",
                            "                      More than <strong>83%</strong> of respondents to State of",
                            "                      JS 2021 (10282 developers out of 12360).",
                            "                    </a>",
                            "                  </li>",
                            "                  <li>",
                            "                    <a href=\"https://2020.stateofjs.com/en-US/other-tools/#utilities\">",
                            "                      More than <strong>70%</strong> of respondents to State of",
                            "                      JS 2020 (14880 developers out of 20974).",
                            "                    </a>",
                            "                  </li>",
                            "                </ul>",
                            "              </blockquote>",
                            "              <div className=\"logos\">{showcase}</div>",
                            "              <div className=\"prose\">",
                            "                ...and{\" \"}",
                            "                <a href=\"https://www.npmjs.com/browse/depended/prettier\">",
                            "                  many more projects",
                            "                </a>",
                            "              </div>",
                            "            </div>",
                            "          </Container>",
                            "        </div>",
                            "      </div>",
                            "    );",
                            "  }",
                            "}",
                            "",
                            "Users.defaultProps = {",
                            "  language: \"en\",",
                            "};",
                            "",
                            "Users.title = \"Who's using Prettier?\";",
                            "",
                            "module.exports = Users;"
                        ]
                    }
                }
            },
            "playground": {
                "index.html": {}
            }
        },
        "playground": {
            "BottomBar.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"bottom-bar\");",
                    "",
                    "export default function BottomBar({ left, right }) {",
                    "  return ReactDOM.createPortal(",
                    "    <React.Fragment>",
                    "      <div className=\"bottom-bar-buttons\">{left}</div>",
                    "      <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">{right}</div>",
                    "    </React.Fragment>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "EditorState.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { stateToggler, shallowEqual } from \"./helpers.js\";",
                    "import * as storage from \"./storage.js\";",
                    "",
                    "export default class EditorState extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = {",
                    "      showSidebar: window.innerWidth > window.innerHeight,",
                    "      showAst: false,",
                    "      showPreprocessedAst: false,",
                    "      showDoc: false,",
                    "      showComments: false,",
                    "      showSecondFormat: false,",
                    "      showInput: true,",
                    "      showOutput: true,",
                    "      rethrowEmbedErrors: false,",
                    "      toggleSidebar: () => this.setState(stateToggler(\"showSidebar\")),",
                    "      toggleAst: () => this.setState(stateToggler(\"showAst\")),",
                    "      togglePreprocessedAst: () =>",
                    "        this.setState(stateToggler(\"showPreprocessedAst\")),",
                    "      toggleDoc: () => this.setState(stateToggler(\"showDoc\")),",
                    "      toggleComments: () => this.setState(stateToggler(\"showComments\")),",
                    "      toggleSecondFormat: () => this.setState(stateToggler(\"showSecondFormat\")),",
                    "      toggleInput: () => this.setState(stateToggler(\"showInput\")),",
                    "      toggleOutput: () => this.setState(stateToggler(\"showOutput\")),",
                    "      toggleEmbedErrors: () =>",
                    "        this.setState(stateToggler(\"rethrowEmbedErrors\")),",
                    "      ...storage.get(\"editor_state\"),",
                    "    };",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    if (!shallowEqual(this.state, prevState)) {",
                    "      storage.set(\"editor_state\", this.state);",
                    "    }",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "Playground.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "import { Button, ClipboardButton } from \"./buttons.js\";",
                    "import EditorState from \"./EditorState.js\";",
                    "import { DebugPanel, InputPanel, OutputPanel } from \"./panels.js\";",
                    "import PrettierFormat from \"./PrettierFormat.js\";",
                    "import { shallowEqual } from \"./helpers.js\";",
                    "import * as urlHash from \"./urlHash.js\";",
                    "import formatMarkdown from \"./markdown.js\";",
                    "import * as util from \"./util.js\";",
                    "import generateDummyId from \"./dummyId.js\";",
                    "import getCodeSample from \"./codeSamples.mjs\";",
                    "",
                    "import { Sidebar, SidebarCategory } from \"./sidebar/components.js\";",
                    "import SidebarOptions from \"./sidebar/SidebarOptions.js\";",
                    "import Option from \"./sidebar/options.js\";",
                    "import { Checkbox } from \"./sidebar/inputs.js\";",
                    "",
                    "const CATEGORIES_ORDER = [",
                    "  \"Global\",",
                    "  \"Common\",",
                    "  \"JavaScript\",",
                    "  \"Markdown\",",
                    "  \"HTML\",",
                    "  \"Special\",",
                    "];",
                    "const ISSUES_URL = \"https://github.com/prettier/prettier/issues/new?body=\";",
                    "const MAX_LENGTH = 8000 - ISSUES_URL.length; // it seems that GitHub limit is 8195",
                    "const COPY_MESSAGE =",
                    "  \"<!-- The issue body has been saved to the clipboard. Please paste it after this line!  -->\\n\";",
                    "",
                    "const ENABLED_OPTIONS = [",
                    "  \"parser\",",
                    "  \"printWidth\",",
                    "  \"tabWidth\",",
                    "  \"useTabs\",",
                    "  \"semi\",",
                    "  \"singleQuote\",",
                    "  \"bracketSpacing\",",
                    "  \"jsxSingleQuote\",",
                    "  \"quoteProps\",",
                    "  \"arrowParens\",",
                    "  \"trailingComma\",",
                    "  \"proseWrap\",",
                    "  \"htmlWhitespaceSensitivity\",",
                    "  \"insertPragma\",",
                    "  \"requirePragma\",",
                    "  \"vueIndentScriptAndStyle\",",
                    "  \"embeddedLanguageFormatting\",",
                    "  \"bracketSameLine\",",
                    "  \"singleAttributePerLine\",",
                    "];",
                    "",
                    "class Playground extends React.Component {",
                    "  constructor(props) {",
                    "    super();",
                    "",
                    "    const original = urlHash.read();",
                    "",
                    "    const defaultOptions = util.getDefaults(",
                    "      props.availableOptions,",
                    "      ENABLED_OPTIONS",
                    "    );",
                    "",
                    "    const options = Object.assign(defaultOptions, original.options);",
                    "",
                    "    // 0.0.0 ~ 0.0.10",
                    "    if (options.parser === \"babylon\") {",
                    "      options.parser = \"babel\";",
                    "    }",
                    "",
                    "    // 0.0.0 ~ 0.0.10",
                    "    if (options.useFlowParser) {",
                    "      options.parser ??= \"flow\";",
                    "    }",
                    "",
                    "    // 1.8.2 ~ 1.9.0",
                    "    if (typeof options.proseWrap === \"boolean\") {",
                    "      options.proseWrap = options.proseWrap ? \"always\" : \"never\";",
                    "    }",
                    "",
                    "    // 0.0.0 ~ 1.9.0",
                    "    if (typeof options.trailingComma === \"boolean\") {",
                    "      options.trailingComma = options.trailingComma ? \"es5\" : \"none\";",
                    "    }",
                    "",
                    "    // 0.17.0 ~ 2.4.0",
                    "    if (options.jsxBracketSameLine) {",
                    "      delete options.jsxBracketSameLine;",
                    "      options.bracketSameLine ??= options.jsxBracketSameLine;",
                    "    }",
                    "",
                    "    const codeSample = getCodeSample(options.parser);",
                    "    const content = original.content || codeSample;",
                    "    const needsClickForFirstRun =",
                    "      options.parser === \"doc-explorer\" && content !== codeSample;",
                    "    const selection = {};",
                    "",
                    "    this.state = { content, options, selection, needsClickForFirstRun };",
                    "",
                    "    this.handleOptionValueChange = this.handleOptionValueChange.bind(this);",
                    "",
                    "    this.setContent = (content) => this.setState({ content });",
                    "    this.clearContent = this.setContent.bind(this, \"\");",
                    "    this.resetOptions = () => this.setState({ options: defaultOptions });",
                    "    this.setSelection = (selection) => this.setState({ selection });",
                    "    this.setSelectionAsRange = () => {",
                    "      const { selection, content, options } = this.state;",
                    "      const [rangeStart, rangeEnd] = util.convertSelectionToRange(",
                    "        selection,",
                    "        content",
                    "      );",
                    "      const updatedOptions = { ...options, rangeStart, rangeEnd };",
                    "      if (rangeStart === rangeEnd) {",
                    "        delete updatedOptions.rangeStart;",
                    "        delete updatedOptions.rangeEnd;",
                    "      }",
                    "      this.setState({ options: updatedOptions });",
                    "    };",
                    "",
                    "    this.enabledOptions = orderOptions(props.availableOptions, ENABLED_OPTIONS);",
                    "    this.rangeStartOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeStart\"",
                    "    );",
                    "    this.rangeEndOption = props.availableOptions.find(",
                    "      (opt) => opt.name === \"rangeEnd\"",
                    "    );",
                    "",
                    "    this.formatInput = this.formatInput.bind(this);",
                    "    this.insertDummyId = this.insertDummyId.bind(this);",
                    "  }",
                    "",
                    "  componentDidUpdate(_, prevState) {",
                    "    const { content, options } = this.state;",
                    "    if (",
                    "      !shallowEqual(prevState.options, this.state.options) ||",
                    "      prevState.content !== content",
                    "    ) {",
                    "      urlHash.replace({ content, options });",
                    "    }",
                    "  }",
                    "",
                    "  handleOptionValueChange(option, value) {",
                    "    this.setState((state) => {",
                    "      const options = { ...state.options };",
                    "",
                    "      if (option.type === \"int\" && Number.isNaN(value)) {",
                    "        delete options[option.name];",
                    "      } else {",
                    "        options[option.name] = value;",
                    "      }",
                    "",
                    "      const content =",
                    "        state.content === \"\" ||",
                    "        state.content === getCodeSample(state.options.parser)",
                    "          ? getCodeSample(options.parser)",
                    "          : state.content;",
                    "",
                    "      if (option.name === \"parser\") {",
                    "        state.needsClickForFirstRun = false;",
                    "      }",
                    "",
                    "      return { options, content };",
                    "    });",
                    "  }",
                    "",
                    "  getMarkdown({ formatted, reformatted, full, doc }) {",
                    "    const { content, options } = this.state;",
                    "    const { availableOptions, version } = this.props;",
                    "    const orderedOptions = orderOptions(availableOptions, [",
                    "      ...ENABLED_OPTIONS,",
                    "      \"rangeStart\",",
                    "      \"rangeEnd\",",
                    "    ]);",
                    "    const cliOptions = util.buildCliArgs(orderedOptions, options);",
                    "",
                    "    return formatMarkdown({",
                    "      input: content,",
                    "      output: formatted,",
                    "      output2: reformatted,",
                    "      doc,",
                    "      version,",
                    "      url: window.location.href,",
                    "      options,",
                    "      cliOptions,",
                    "      full,",
                    "    });",
                    "  }",
                    "",
                    "  formatInput() {",
                    "    if (this.state.options.parser !== \"doc-explorer\") {",
                    "      return;",
                    "    }",
                    "",
                    "    const { content, selection } = this.state;",
                    "",
                    "    return this.props.worker",
                    "      .format(content, {",
                    "        parser: \"__js_expression\",",
                    "        cursorOffset: util.convertSelectionToRange(selection, content)[0],",
                    "      })",
                    "      .then(({ error, formatted, cursorOffset }) => {",
                    "        if (error) {",
                    "          return;",
                    "        }",
                    "",
                    "        this.setState({",
                    "          content: formatted,",
                    "          selection: util.convertOffsetToSelection(cursorOffset, formatted),",
                    "        });",
                    "      });",
                    "  }",
                    "",
                    "  insertDummyId() {",
                    "    const { content, selection } = this.state;",
                    "    const dummyId = generateDummyId();",
                    "    const range = util.convertSelectionToRange(selection, content);",
                    "    const modifiedContent =",
                    "      content.slice(0, range[0]) + dummyId + content.slice(range[1]);",
                    "",
                    "    this.setState({",
                    "      content: modifiedContent,",
                    "      selection: util.convertOffsetToSelection(",
                    "        range[0] + dummyId.length,",
                    "        modifiedContent",
                    "      ),",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { worker } = this.props;",
                    "    const { content, options } = this.state;",
                    "",
                    "    return (",
                    "      <EditorState>",
                    "        {(editorState) => (",
                    "          <PrettierFormat",
                    "            enabled={!this.state.needsClickForFirstRun}",
                    "            worker={worker}",
                    "            code={content}",
                    "            options={options}",
                    "            debugAst={editorState.showAst}",
                    "            debugPreprocessedAst={editorState.showPreprocessedAst}",
                    "            debugDoc={editorState.showDoc}",
                    "            debugComments={editorState.showComments}",
                    "            reformat={editorState.showSecondFormat}",
                    "            rethrowEmbedErrors={editorState.rethrowEmbedErrors}",
                    "          >",
                    "            {({ formatted, debug }) => {",
                    "              const fullReport = this.getMarkdown({",
                    "                formatted,",
                    "                reformatted: debug.reformatted,",
                    "                full: true,",
                    "              });",
                    "              const showFullReport =",
                    "                encodeURIComponent(fullReport).length < MAX_LENGTH;",
                    "              return (",
                    "                <React.Fragment>",
                    "                  <div className=\"editors-container\">",
                    "                    <Sidebar visible={editorState.showSidebar}>",
                    "                      <SidebarOptions",
                    "                        categories={CATEGORIES_ORDER}",
                    "                        availableOptions={this.enabledOptions}",
                    "                        optionValues={options}",
                    "                        onOptionValueChange={this.handleOptionValueChange}",
                    "                      />",
                    "                      <SidebarCategory title=\"Range\">",
                    "                        <label>",
                    "                          The selected range will be highlighted in yellow in",
                    "                          the input editor",
                    "                        </label>",
                    "                        <Option",
                    "                          option={this.rangeStartOption}",
                    "                          value={",
                    "                            typeof options.rangeStart === \"number\"",
                    "                              ? options.rangeStart",
                    "                              : \"\"",
                    "                          }",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "                        <Option",
                    "                          option={this.rangeEndOption}",
                    "                          value={",
                    "                            typeof options.rangeEnd === \"number\"",
                    "                              ? options.rangeEnd",
                    "                              : \"\"",
                    "                          }",
                    "                          overrideMax={content.length}",
                    "                          onChange={this.handleOptionValueChange}",
                    "                        />",
                    "",
                    "                        <Button onClick={this.setSelectionAsRange}>",
                    "                          Set selected text as range",
                    "                        </Button>",
                    "                      </SidebarCategory>",
                    "                      <SidebarCategory title=\"Debug\">",
                    "                        <Checkbox",
                    "                          label=\"show input\"",
                    "                          checked={editorState.showInput}",
                    "                          onChange={editorState.toggleInput}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show AST\"",
                    "                          checked={editorState.showAst}",
                    "                          onChange={editorState.toggleAst}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show preprocessed AST\"",
                    "                          checked={editorState.showPreprocessedAst}",
                    "                          onChange={editorState.togglePreprocessedAst}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show doc\"",
                    "                          checked={editorState.showDoc}",
                    "                          onChange={editorState.toggleDoc}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show comments\"",
                    "                          checked={editorState.showComments}",
                    "                          onChange={editorState.toggleComments}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show output\"",
                    "                          checked={editorState.showOutput}",
                    "                          onChange={editorState.toggleOutput}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"show second format\"",
                    "                          checked={editorState.showSecondFormat}",
                    "                          onChange={editorState.toggleSecondFormat}",
                    "                        />",
                    "                        <Checkbox",
                    "                          label=\"rethrow embed errors\"",
                    "                          checked={editorState.rethrowEmbedErrors}",
                    "                          onChange={editorState.toggleEmbedErrors}",
                    "                        />",
                    "                        {editorState.showDoc && (",
                    "                          <ClipboardButton",
                    "                            copy={() => this.getMarkdown({ doc: debug.doc })}",
                    "                            disabled={!debug.doc}",
                    "                          >",
                    "                            Copy doc",
                    "                          </ClipboardButton>",
                    "                        )}",
                    "                      </SidebarCategory>",
                    "                      <div className=\"sub-options\">",
                    "                        <Button onClick={this.resetOptions}>",
                    "                          Reset to defaults",
                    "                        </Button>",
                    "                      </div>",
                    "                    </Sidebar>",
                    "                    <div className=\"editors\">",
                    "                      {editorState.showInput ? (",
                    "                        <InputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          ruler={options.printWidth}",
                    "                          value={content}",
                    "                          selection={this.state.selection}",
                    "                          codeSample={getCodeSample(options.parser)}",
                    "                          overlayStart={options.rangeStart}",
                    "                          overlayEnd={options.rangeEnd}",
                    "                          onChange={this.setContent}",
                    "                          onSelectionChange={this.setSelection}",
                    "                          extraKeys={{",
                    "                            \"Shift-Alt-F\": this.formatInput,",
                    "                            \"Ctrl-Q\": this.insertDummyId,",
                    "                          }}",
                    "                          foldGutter={options.parser === \"doc-explorer\"}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showAst ? (",
                    "                        <DebugPanel",
                    "                          value={debug.ast || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showPreprocessedAst ? (",
                    "                        <DebugPanel",
                    "                          value={debug.preprocessedAst || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showDoc ? (",
                    "                        <DebugPanel value={debug.doc || \"\"} />",
                    "                      ) : null}",
                    "                      {editorState.showComments ? (",
                    "                        <DebugPanel",
                    "                          value={debug.comments || \"\"}",
                    "                          autoFold={util.getAstAutoFold(options.parser)}",
                    "                        />",
                    "                      ) : null}",
                    "                      {editorState.showOutput ? (",
                    "                        this.state.needsClickForFirstRun ? (",
                    "                          <div className=\"editor disabled-output-panel\">",
                    "                            <div className=\"explanation\">",
                    "                              <code>doc-explorer</code> involves running code",
                    "                              provided by users.",
                    "                            </div>",
                    "                            <div className=\"explanation\">",
                    "                              To stay on the safe side and prevent abuse, an",
                    "                              explicit user action is required when a direct",
                    "                              link to a <code>doc-explorer</code> playground is",
                    "                              opened.",
                    "                            </div>",
                    "                            <div className=\"explanation\">",
                    "                              Click the button below to start the playground.",
                    "                            </div>",
                    "                            <Button",
                    "                              onClick={() =>",
                    "                                this.setState({ needsClickForFirstRun: false })",
                    "                              }",
                    "                            >",
                    "                              Start",
                    "                            </Button>",
                    "                          </div>",
                    "                        ) : (",
                    "                          <OutputPanel",
                    "                            mode={util.getCodemirrorMode(options.parser)}",
                    "                            value={formatted}",
                    "                            ruler={options.printWidth}",
                    "                          />",
                    "                        )",
                    "                      ) : null}",
                    "                      {editorState.showSecondFormat ? (",
                    "                        <OutputPanel",
                    "                          mode={util.getCodemirrorMode(options.parser)}",
                    "                          value={getSecondFormat(formatted, debug.reformatted)}",
                    "                          ruler={options.printWidth}",
                    "                        />",
                    "                      ) : null}",
                    "                    </div>",
                    "                  </div>",
                    "                  <div className=\"bottom-bar\">",
                    "                    <div className=\"bottom-bar-buttons\">",
                    "                      <Button onClick={editorState.toggleSidebar}>",
                    "                        {editorState.showSidebar ? \"Hide\" : \"Show\"} options",
                    "                      </Button>",
                    "                      <Button onClick={this.clearContent}>Clear</Button>",
                    "                      <ClipboardButton",
                    "                        copy={JSON.stringify(",
                    "                          // Remove `parser` since people usually paste this",
                    "                          // into their .prettierrc and specifying a top-level",
                    "                          // parser there is an anti-pattern. Note:",
                    "                          // `JSON.stringify` omits keys whose values are",
                    "                          // `undefined`.",
                    "                          { ...options, parser: undefined },",
                    "                          null,",
                    "                          2",
                    "                        )}",
                    "                      >",
                    "                        Copy config JSON",
                    "                      </ClipboardButton>",
                    "                      <Button",
                    "                        onClick={this.insertDummyId}",
                    "                        onMouseDown={(event) => event.preventDefault()} // prevent button from focusing",
                    "                        title=\"Generate a nonsense variable name (Ctrl-Q)\"",
                    "                      >",
                    "                        Insert dummy id",
                    "                      </Button>",
                    "                    </div>",
                    "                    <div className=\"bottom-bar-buttons bottom-bar-buttons-right\">",
                    "                      <ClipboardButton copy={window.location.href}>",
                    "                        Copy link",
                    "                      </ClipboardButton>",
                    "                      <ClipboardButton",
                    "                        copy={() =>",
                    "                          this.getMarkdown({",
                    "                            formatted,",
                    "                            reformatted: debug.reformatted,",
                    "                          })",
                    "                        }",
                    "                      >",
                    "                        Copy markdown",
                    "                      </ClipboardButton>",
                    "                      <a",
                    "                        href={getReportLink(",
                    "                          showFullReport ? fullReport : COPY_MESSAGE",
                    "                        )}",
                    "                        target=\"_blank\"",
                    "                        rel=\"noopener noreferrer\"",
                    "                      >",
                    "                        <ClipboardButton",
                    "                          copy={() => (showFullReport ? \"\" : fullReport)}",
                    "                        >",
                    "                          Report issue",
                    "                        </ClipboardButton>",
                    "                      </a>",
                    "                    </div>",
                    "                  </div>",
                    "                </React.Fragment>",
                    "              );",
                    "            }}",
                    "          </PrettierFormat>",
                    "        )}",
                    "      </EditorState>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function orderOptions(availableOptions, order) {",
                    "  const optionsByName = {};",
                    "  for (const option of availableOptions) {",
                    "    optionsByName[option.name] = option;",
                    "  }",
                    "",
                    "  return order.map((name) => optionsByName[name]);",
                    "}",
                    "",
                    "function getReportLink(reportBody) {",
                    "  return `${ISSUES_URL}${encodeURIComponent(reportBody)}`;",
                    "}",
                    "",
                    "function getSecondFormat(formatted, reformatted) {",
                    "  return formatted === \"\"",
                    "    ? \"\"",
                    "    : formatted === reformatted",
                    "    ? \" Second format is unchanged.\"",
                    "    : reformatted;",
                    "}",
                    "",
                    "export default Playground;"
                ]
            },
            "PrettierFormat.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "",
                    "export default class PrettierFormat extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { formatted: \"\", debug: {} };",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.format();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    for (const key of [",
                    "      \"enabled\",",
                    "      \"code\",",
                    "      \"options\",",
                    "      \"debugAst\",",
                    "      \"debugPreprocessedAst\",",
                    "      \"debugDoc\",",
                    "      \"debugComments\",",
                    "      \"reformat\",",
                    "      \"rethrowEmbedErrors\",",
                    "    ]) {",
                    "      if (prevProps[key] !== this.props[key]) {",
                    "        this.format();",
                    "        break;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  async format() {",
                    "    const {",
                    "      enabled,",
                    "      worker,",
                    "      code,",
                    "      options,",
                    "      debugAst: ast,",
                    "      debugPreprocessedAst: preprocessedAst,",
                    "      debugDoc: doc,",
                    "      debugComments: comments,",
                    "      reformat,",
                    "      rethrowEmbedErrors,",
                    "    } = this.props;",
                    "",
                    "    if (!enabled) {",
                    "      return;",
                    "    }",
                    "",
                    "    const result = await worker.format(code, options, {",
                    "      ast,",
                    "      preprocessedAst,",
                    "      doc,",
                    "      comments,",
                    "      reformat,",
                    "      rethrowEmbedErrors,",
                    "    });",
                    "",
                    "    this.setState(result);",
                    "  }",
                    "",
                    "  render() {",
                    "    return this.props.children(this.state);",
                    "  }",
                    "}"
                ]
            },
            "VersionLink.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "const root = document.getElementById(\"version\");",
                    "",
                    "export default function VersionLink({ version }) {",
                    "  const match = version.match(/^pr-(\\d+)$/);",
                    "  let href;",
                    "  if (match) {",
                    "    href = `pull/${match[1]}`;",
                    "  } else if (/\\.0$/.test(version)) {",
                    "    href = `releases/tag/${version}`;",
                    "  } else {",
                    "    href = `blob/main/CHANGELOG.md#${version.replaceAll(\".\", \"\")}`;",
                    "  }",
                    "",
                    "  const formattedVersion = match ? `PR #${match[1]}` : `v${version}`;",
                    "",
                    "  React.useEffect(() => {",
                    "    document.title = `Prettier ${formattedVersion}`;",
                    "  }, [formattedVersion]);",
                    "",
                    "  return ReactDOM.createPortal(",
                    "    <a",
                    "      href={`https://github.com/prettier/prettier/${href}`}",
                    "      target=\"_blank\"",
                    "      rel=\"noreferrer noopener\"",
                    "    >",
                    "      {formattedVersion}",
                    "    </a>,",
                    "    root",
                    "  );",
                    "}"
                ]
            },
            "WorkerApi.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export default function WorkerApi(source) {",
                    "  const worker = new Worker(source);",
                    "  let counter = 0;",
                    "  const handlers = {};",
                    "",
                    "  worker.addEventListener(\"message\", (event) => {",
                    "    const { uid, message, error } = event.data;",
                    "",
                    "    if (!handlers[uid]) {",
                    "      return;",
                    "    }",
                    "",
                    "    const [resolve, reject] = handlers[uid];",
                    "    delete handlers[uid];",
                    "",
                    "    if (error) {",
                    "      reject(error);",
                    "    } else {",
                    "      resolve(message);",
                    "    }",
                    "  });",
                    "",
                    "  function postMessage(message) {",
                    "    const uid = ++counter;",
                    "    return new Promise((resolve, reject) => {",
                    "      handlers[uid] = [resolve, reject];",
                    "      worker.postMessage({ uid, message });",
                    "    });",
                    "  }",
                    "",
                    "  return {",
                    "    getMetadata() {",
                    "      return postMessage({ type: \"meta\" });",
                    "    },",
                    "    format(code, options, debug = {}) {",
                    "      return postMessage({ type: \"format\", code, options, debug });",
                    "    },",
                    "    postMessage,",
                    "  };",
                    "}"
                ]
            },
            "buttons.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import * as React from \"react\";",
                    "import ClipboardJS from \"clipboard\";",
                    "",
                    "export const Button = React.forwardRef((props, ref) => (",
                    "  <button type=\"button\" className=\"btn\" ref={ref} {...props} />",
                    "));",
                    "",
                    "export class ClipboardButton extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { showTooltip: false, tooltipText: \"\" };",
                    "    this.timer = null;",
                    "    this.ref = React.createRef();",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    this.clipboard = new ClipboardJS(this.ref.current, {",
                    "      text: () => {",
                    "        const { copy } = this.props;",
                    "        return typeof copy === \"function\" ? copy() : copy;",
                    "      },",
                    "    });",
                    "    this.clipboard.on(\"success\", () => this.showTooltip(\"Copied!\"));",
                    "    this.clipboard.on(\"error\", () => this.showTooltip(\"Press ctrl+c to copy\"));",
                    "  }",
                    "",
                    "  showTooltip(text) {",
                    "    this.setState({ showTooltip: true, tooltipText: text }, () => {",
                    "      if (this.timer) {",
                    "        clearTimeout(this.timer);",
                    "      }",
                    "      this.timer = setTimeout(() => {",
                    "        this.timer = null;",
                    "        this.setState({ showTooltip: false });",
                    "      }, 2000);",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { children, copy, ...rest } = this.props;",
                    "    const { showTooltip, tooltipText } = this.state;",
                    "",
                    "    return (",
                    "      <Button ref={this.ref} {...rest}>",
                    "        {showTooltip ? <span className=\"tooltip\">{tooltipText}</span> : null}",
                    "        {children}",
                    "      </Button>",
                    "    );",
                    "  }",
                    "}"
                ]
            },
            "codeSamples.mjs": {},
            "dummyId.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* cSpell:disable */",
                    "const dummyAdjectives = [",
                    "  \"annular\",",
                    "  \"abugidic\",",
                    "  \"cantilevered\",",
                    "  \"equidistant\",",
                    "  \"hippopotamic\",",
                    "  \"octahedral\",",
                    "  \"particolored\",",
                    "  \"quadrupedal\",",
                    "  \"stellated\",",
                    "  \"transdecimal\",",
                    "];",
                    "",
                    "const dummyNouns = [",
                    "  \"anteater\",",
                    "  \"dingbat\",",
                    "  \"dinosaur\",",
                    "  \"fossil\",",
                    "  \"kangaroo\",",
                    "  \"palimpsest\",",
                    "  \"platypus\",",
                    "  \"rhinoceros\",",
                    "  \"rhubarb\",",
                    "  \"romanocastor\",",
                    "  \"smorgasbord\",",
                    "  \"thingamabob\",",
                    "  \"weevil\",",
                    "  \"zamazingo\",",
                    "];",
                    "",
                    "const dummyFinalNouns = [",
                    "  \"factory\",",
                    "  \"generator\",",
                    "  \"mutator\",",
                    "  \"processor\",",
                    "  \"provider\",",
                    "  \"replacer\",",
                    "  \"resolver\",",
                    "  \"service\",",
                    "  \"transformer\",",
                    "  \"wrapper\",",
                    "];",
                    "// cSpell:enable",
                    "",
                    "function getRandomElement(array) {",
                    "  return array[Math.floor(Math.random() * array.length)];",
                    "}",
                    "",
                    "function camelCase(string) {",
                    "  return string.replaceAll(/_(\\w)/g, (_, c) => c.toUpperCase());",
                    "}",
                    "",
                    "export default function generateDummyId() {",
                    "  return camelCase(",
                    "    [dummyAdjectives, dummyNouns, dummyFinalNouns]",
                    "      .map(getRandomElement)",
                    "      .join(\"_\")",
                    "  );",
                    "}"
                ]
            },
            "helpers.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function stateToggler(key) {",
                    "  return (state) => ({ [key]: !state[key] });",
                    "}",
                    "",
                    "const { hasOwnProperty } = Object.prototype;",
                    "",
                    "function is(x, y) {",
                    "  // SameValue algorithm",
                    "  if (x === y) {",
                    "    // Steps 1-5, 7-10",
                    "    // Steps 6.b-6.e: +0 != -0",
                    "    return x !== 0 || 1 / x === 1 / y;",
                    "  }",
                    "  // Step 6.a: NaN == NaN",
                    "  return x !== x && y !== y;",
                    "}",
                    "",
                    "export function shallowEqual(objA, objB) {",
                    "  if (is(objA, objB)) {",
                    "    return true;",
                    "  }",
                    "",
                    "  if (",
                    "    typeof objA !== \"object\" ||",
                    "    objA === null ||",
                    "    typeof objB !== \"object\" ||",
                    "    objB === null",
                    "  ) {",
                    "    return false;",
                    "  }",
                    "",
                    "  const keysA = Object.keys(objA);",
                    "  const keysB = Object.keys(objB);",
                    "",
                    "  if (keysA.length !== keysB.length) {",
                    "    return false;",
                    "  }",
                    "",
                    "  for (let i = 0; i < keysA.length; i++) {",
                    "    if (",
                    "      !hasOwnProperty.call(objB, keysA[i]) ||",
                    "      !is(objA[keysA[i]], objB[keysA[i]])",
                    "    ) {",
                    "      return false;",
                    "    }",
                    "  }",
                    "",
                    "  return true;",
                    "}"
                ]
            },
            "index.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import \"codemirror-graphql/mode\";",
                    "",
                    "import * as React from \"react\";",
                    "import * as ReactDOM from \"react-dom\";",
                    "",
                    "import Playground from \"./Playground.js\";",
                    "import VersionLink from \"./VersionLink.js\";",
                    "import WorkerApi from \"./WorkerApi.js\";",
                    "import { fixPrettierVersion } from \"./util.js\";",
                    "",
                    "class App extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this.state = { loaded: false };",
                    "    this.worker = new WorkerApi(\"/worker.js\");",
                    "  }",
                    "",
                    "  async componentDidMount() {",
                    "    const { supportInfo, version } = await this.worker.getMetadata();",
                    "",
                    "    this.setState({",
                    "      loaded: true,",
                    "      availableOptions: supportInfo.options.map(augmentOption),",
                    "      version: fixPrettierVersion(version),",
                    "    });",
                    "  }",
                    "",
                    "  render() {",
                    "    const { loaded, availableOptions, version } = this.state;",
                    "",
                    "    if (!loaded) {",
                    "      return \"Loading...\";",
                    "    }",
                    "",
                    "    return (",
                    "      <React.Fragment>",
                    "        <VersionLink version={version} />",
                    "        <Playground",
                    "          worker={this.worker}",
                    "          availableOptions={availableOptions}",
                    "          version={version}",
                    "        />",
                    "      </React.Fragment>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function augmentOption(option) {",
                    "  if (option.type === \"boolean\" && option.default === true) {",
                    "    option.inverted = true;",
                    "  }",
                    "",
                    "  option.cliName =",
                    "    \"--\" +",
                    "    (option.inverted ? \"no-\" : \"\") +",
                    "    option.name.replaceAll(/(?<=[a-z])(?=[A-Z])/g, \"-\").toLowerCase();",
                    "",
                    "  return option;",
                    "}",
                    "",
                    "ReactDOM.render(<App />, document.getElementById(\"root\"));"
                ]
            },
            "markdown.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "function formatMarkdown({",
                    "  input,",
                    "  output,",
                    "  output2,",
                    "  doc,",
                    "  version,",
                    "  url,",
                    "  options,",
                    "  cliOptions,",
                    "  full,",
                    "}) {",
                    "  const syntax = getMarkdownSyntax(options);",
                    "  const optionsString = formatCLIOptions(cliOptions);",
                    "  const isIdempotent = !output2 || output === output2;",
                    "",
                    "  return [",
                    "    `**Prettier ${version}**`,",
                    "    `[Playground link](${url})`,",
                    "    optionsString === \"\" ? null : codeBlock(optionsString, \"sh\"),",
                    "    \"\",",
                    "    \"**Input:**\",",
                    "    codeBlock(input, syntax),",
                    "    ...(doc ? [\"\", \"**Doc:**\", codeBlock(doc, \"js\")] : []),",
                    "    ...(output === undefined",
                    "      ? []",
                    "      : [\"\", \"**Output:**\", codeBlock(output, syntax)]),",
                    "    ...(isIdempotent",
                    "      ? []",
                    "      : [\"\", \"**Second Output:**\", codeBlock(output2, syntax)]),",
                    "    ...(full ? [\"\", \"**Expected behavior:**\", \"\"] : []),",
                    "  ]",
                    "    .filter((part) => part !== null)",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function getMarkdownSyntax(options) {",
                    "  switch (options.parser) {",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"flow\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"doc-explorer\":",
                    "      return \"jsx\";",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "      return \"tsx\";",
                    "    case \"json\":",
                    "    case \"json-stringify\":",
                    "      return \"jsonc\";",
                    "    case \"glimmer\":",
                    "      return \"hbs\";",
                    "    case \"angular\":",
                    "    case \"lwc\":",
                    "      return \"html\";",
                    "    default:",
                    "      return options.parser;",
                    "  }",
                    "}",
                    "",
                    "function formatCLIOptions(cliOptions) {",
                    "  return cliOptions",
                    "    .map(([name, value]) => (value === true ? name : `${name} ${value}`))",
                    "    .join(\"\\n\");",
                    "}",
                    "",
                    "function codeBlock(content, syntax) {",
                    "  const backtickSequences = content.match(/`+/g) || [];",
                    "  const longestBacktickSequenceLength = Math.max(",
                    "    ...backtickSequences.map(({ length }) => length)",
                    "  );",
                    "  const prettierIgnoreComment = \"<!-- prettier-ignore -->\";",
                    "  const fenceLength = Math.max(3, longestBacktickSequenceLength + 1);",
                    "  const fence = \"`\".repeat(fenceLength);",
                    "  return [prettierIgnoreComment, fence + (syntax || \"\"), content, fence].join(",
                    "    \"\\n\"",
                    "  );",
                    "}",
                    "",
                    "module.exports = formatMarkdown;"
                ]
            },
            "panels.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import CodeMirror from \"codemirror\";",
                    "import * as React from \"react\";",
                    "",
                    "class CodeMirrorPanel extends React.Component {",
                    "  constructor() {",
                    "    super();",
                    "    this._textareaRef = React.createRef();",
                    "    this._codeMirror = null;",
                    "    this._cached = \"\";",
                    "    this._overlay = null;",
                    "    this.handleChange = this.handleChange.bind(this);",
                    "    this.handleFocus = this.handleFocus.bind(this);",
                    "    this.handleSelectionChange = this.handleSelectionChange.bind(this);",
                    "  }",
                    "",
                    "  componentDidMount() {",
                    "    const options = { ...this.props };",
                    "    delete options.ruler;",
                    "    delete options.rulerColor;",
                    "    delete options.value;",
                    "    delete options.selection;",
                    "    delete options.onChange;",
                    "",
                    "    options.rulers = [makeRuler(this.props)];",
                    "    options.gutters = makeGutters(this.props);",
                    "",
                    "    this._codeMirror = CodeMirror.fromTextArea(",
                    "      this._textareaRef.current,",
                    "      options",
                    "    );",
                    "    this._codeMirror.on(\"change\", this.handleChange);",
                    "    this._codeMirror.on(\"focus\", this.handleFocus);",
                    "    this._codeMirror.on(\"beforeSelectionChange\", this.handleSelectionChange);",
                    "",
                    "    window.CodeMirror.keyMap.pcSublime[\"Ctrl-L\"] = false;",
                    "    window.CodeMirror.keyMap.sublime[\"Ctrl-L\"] = false;",
                    "",
                    "    this.updateValue(this.props.value || \"\");",
                    "    this.updateSelection();",
                    "    this.updateOverlay();",
                    "  }",
                    "",
                    "  componentWillUnmount() {",
                    "    this._codeMirror && this._codeMirror.toTextArea();",
                    "  }",
                    "",
                    "  componentDidUpdate(prevProps) {",
                    "    if (this.props.value !== this._cached) {",
                    "      this.updateValue(this.props.value);",
                    "    }",
                    "    if (",
                    "      !isEqualSelection(this.props.selection, prevProps.selection) &&",
                    "      !isEqualSelection(",
                    "        this.props.selection,",
                    "        this._codeMirror.listSelections()[0]",
                    "      )",
                    "    ) {",
                    "      this.updateSelection();",
                    "    }",
                    "    if (",
                    "      this.props.overlayStart !== prevProps.overlayStart ||",
                    "      this.props.overlayEnd !== prevProps.overlayEnd",
                    "    ) {",
                    "      this.updateOverlay();",
                    "    }",
                    "    if (this.props.mode !== prevProps.mode) {",
                    "      this._codeMirror.setOption(\"mode\", this.props.mode);",
                    "    }",
                    "    if (this.props.ruler !== prevProps.ruler) {",
                    "      this._codeMirror.setOption(\"rulers\", [makeRuler(this.props)]);",
                    "    }",
                    "    if (this.props.foldGutter !== prevProps.foldGutter) {",
                    "      this._codeMirror.setOption(\"gutters\", makeGutters(this.props));",
                    "    }",
                    "  }",
                    "",
                    "  updateValue(value) {",
                    "    this._cached = value;",
                    "    this._codeMirror.setValue(value);",
                    "",
                    "    if (this.props.autoFold instanceof RegExp) {",
                    "      const lines = value.split(\"\\n\");",
                    "      // going backwards to prevent unfolding folds created earlier",
                    "      for (let i = lines.length - 1; i >= 0; i--) {",
                    "        if (this.props.autoFold.test(lines[i])) {",
                    "          this._codeMirror.foldCode(i);",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  updateSelection() {",
                    "    this._codeMirror.setSelection(",
                    "      this.props.selection?.anchor ?? { line: 0, ch: 0 },",
                    "      this.props.selection?.head",
                    "    );",
                    "  }",
                    "",
                    "  updateOverlay() {",
                    "    if (!this.props.readOnly) {",
                    "      if (this._overlay) {",
                    "        this._codeMirror.removeOverlay(this._overlay);",
                    "      }",
                    "      const [start, end] = getIndexPosition(this.props.value, [",
                    "        this.props.overlayStart,",
                    "        this.props.overlayEnd,",
                    "      ]);",
                    "      this._overlay = createOverlay(start, end);",
                    "      this._codeMirror.addOverlay(this._overlay);",
                    "    }",
                    "  }",
                    "",
                    "  handleFocus(/* codeMirror, event */) {",
                    "    if (this._codeMirror.getValue() === this.props.codeSample) {",
                    "      this._codeMirror.execCommand(\"selectAll\");",
                    "    }",
                    "  }",
                    "",
                    "  handleChange(doc, change) {",
                    "    if (change.origin !== \"setValue\") {",
                    "      this._cached = doc.getValue();",
                    "      this.props.onChange(this._cached);",
                    "      this.updateOverlay();",
                    "    }",
                    "  }",
                    "",
                    "  handleSelectionChange(doc, change) {",
                    "    this.props.onSelectionChange?.(change.ranges[0]);",
                    "  }",
                    "",
                    "  render() {",
                    "    return (",
                    "      <div className=\"editor input\">",
                    "        <textarea ref={this._textareaRef} />",
                    "      </div>",
                    "    );",
                    "  }",
                    "}",
                    "",
                    "function getIndexPosition(text, indexes) {",
                    "  indexes = [...indexes];",
                    "  let line = 0;",
                    "  let count = 0;",
                    "  let lineStart = 0;",
                    "  const result = [];",
                    "",
                    "  while (indexes.length > 0) {",
                    "    const index = indexes.shift();",
                    "",
                    "    while (count < index && count < text.length) {",
                    "      if (text[count] === \"\\n\") {",
                    "        line++;",
                    "        lineStart = count + 1;",
                    "      }",
                    "      count++;",
                    "    }",
                    "",
                    "    result.push({ line, pos: count - lineStart });",
                    "  }",
                    "",
                    "  return result;",
                    "}",
                    "",
                    "function createOverlay(start, end) {",
                    "  return {",
                    "    token(stream) {",
                    "      const { line } = stream.lineOracle;",
                    "",
                    "      if (line < start.line || line > end.line) {",
                    "        stream.skipToEnd();",
                    "      } else if (line === start.line && stream.pos < start.pos) {",
                    "        stream.pos = start.pos;",
                    "      } else if (line === end.line) {",
                    "        if (stream.pos < end.pos) {",
                    "          stream.pos = end.pos;",
                    "          return \"searching\";",
                    "        }",
                    "        stream.skipToEnd();",
                    "      } else {",
                    "        stream.skipToEnd();",
                    "        return \"searching\";",
                    "      }",
                    "    },",
                    "  };",
                    "}",
                    "",
                    "function makeRuler(props) {",
                    "  return { column: props.ruler, color: props.rulerColor };",
                    "}",
                    "",
                    "function makeGutters(props) {",
                    "  return props.foldGutter",
                    "    ? [\"CodeMirror-linenumbers\", \"CodeMirror-foldgutter\"]",
                    "    : [];",
                    "}",
                    "",
                    "function isEqualSelection(selection1, selection2) {",
                    "  const anchor1 = selection1?.anchor ?? { line: 0, ch: 0 };",
                    "  const head1 = selection1?.head ?? anchor1;",
                    "  const anchor2 = selection2?.anchor ?? { line: 0, ch: 0 };",
                    "  const head2 = selection2?.head ?? anchor2;",
                    "  return (",
                    "    head1.line === head2.line &&",
                    "    head1.ch === head2.ch &&",
                    "    anchor1.line === anchor2.line &&",
                    "    anchor1.ch === anchor2.ch",
                    "  );",
                    "}",
                    "",
                    "export function InputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      lineNumbers={true}",
                    "      keyMap=\"sublime\"",
                    "      autoCloseBrackets={true}",
                    "      matchBrackets={true}",
                    "      showCursorWhenSelecting={true}",
                    "      tabSize={4}",
                    "      rulerColor=\"#eeeeee\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function OutputPanel(props) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={true}",
                    "      rulerColor=\"#444444\"",
                    "      {...props}",
                    "    />",
                    "  );",
                    "}",
                    "",
                    "export function DebugPanel({ value, autoFold }) {",
                    "  return (",
                    "    <CodeMirrorPanel",
                    "      readOnly={true}",
                    "      lineNumbers={false}",
                    "      foldGutter={true}",
                    "      autoFold={autoFold}",
                    "      mode=\"jsx\"",
                    "      value={value}",
                    "    />",
                    "  );",
                    "}"
                ]
            },
            "storage.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function get(key) {",
                    "  try {",
                    "    return JSON.parse(window.localStorage.getItem(key));",
                    "  } catch {",
                    "    // noop",
                    "  }",
                    "}",
                    "",
                    "export function set(key, value) {",
                    "  try {",
                    "    window.localStorage.setItem(key, JSON.stringify(value));",
                    "  } catch {",
                    "    // noop",
                    "  }",
                    "}"
                ]
            },
            "urlHash.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "import LZString from \"lz-string\";",
                    "",
                    "export function read() {",
                    "  const hash = document.location.hash.slice(1);",
                    "  if (!hash) {",
                    "    return {};",
                    "  }",
                    "",
                    "  // backwards support for old json encoded URIComponent",
                    "  const decode = hash.includes(\"%7B%22\")",
                    "    ? decodeURIComponent",
                    "    : LZString.decompressFromEncodedURIComponent;",
                    "",
                    "  try {",
                    "    return JSON.parse(decode(hash));",
                    "  } catch {",
                    "    return {};",
                    "  }",
                    "}",
                    "",
                    "export function replace(state) {",
                    "  const hash = LZString.compressToEncodedURIComponent(JSON.stringify(state));",
                    "  if (",
                    "    typeof URL === \"function\" &&",
                    "    typeof history === \"object\" &&",
                    "    typeof history.replaceState === \"function\"",
                    "  ) {",
                    "    const url = new URL(location);",
                    "    url.hash = hash;",
                    "    history.replaceState(null, null, url);",
                    "  } else {",
                    "    location.hash = hash;",
                    "  }",
                    "}"
                ]
            },
            "util.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "export function fixPrettierVersion(version) {",
                    "  const match = version.match(/^\\d+\\.\\d+\\.\\d+-pr.(\\d+)$/);",
                    "  if (match) {",
                    "    return `pr-${match[1]}`;",
                    "  }",
                    "  return version;",
                    "}",
                    "",
                    "export function getDefaults(availableOptions, optionNames) {",
                    "  const defaults = {};",
                    "  for (const option of availableOptions) {",
                    "    if (optionNames.includes(option.name)) {",
                    "      defaults[option.name] =",
                    "        option.name === \"parser\" ? \"babel\" : option.default;",
                    "    }",
                    "  }",
                    "  return defaults;",
                    "}",
                    "",
                    "export function buildCliArgs(availableOptions, options) {",
                    "  const args = [];",
                    "  for (const option of availableOptions) {",
                    "    const value = options[option.name];",
                    "",
                    "    if (value === undefined) {",
                    "      continue;",
                    "    }",
                    "",
                    "    if (option.type === \"boolean\") {",
                    "      if ((value && !option.inverted) || (!value && option.inverted)) {",
                    "        args.push([option.cliName, true]);",
                    "      }",
                    "    } else if (value !== option.default || option.name === \"rangeStart\") {",
                    "      args.push([option.cliName, value]);",
                    "    }",
                    "  }",
                    "  return args;",
                    "}",
                    "",
                    "export function getCodemirrorMode(parser) {",
                    "  switch (parser) {",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return \"css\";",
                    "    case \"graphql\":",
                    "      return \"graphql\";",
                    "    case \"markdown\":",
                    "      return \"markdown\";",
                    "    default:",
                    "      return \"jsx\";",
                    "  }",
                    "}",
                    "",
                    "const astAutoFold = {",
                    "  estree: /^\\s*\"(loc|start|end|tokens|\\w+Comments|comments)\":/,",
                    "  postcss: /^\\s*\"(source|input|raws|file)\":/,",
                    "  html: /^\\s*\"(\\w+Span|valueTokens|tokens|file|tagDefinition)\":/,",
                    "  mdast: /^\\s*\"position\":/,",
                    "  yaml: /^\\s*\"position\":/,",
                    "  glimmer: /^\\s*\"loc\":/,",
                    "  graphql: /^\\s*\"loc\":/,",
                    "};",
                    "",
                    "export function getAstAutoFold(parser) {",
                    "  switch (parser) {",
                    "    case \"flow\":",
                    "    case \"babel\":",
                    "    case \"babel-flow\":",
                    "    case \"babel-ts\":",
                    "    case \"typescript\":",
                    "    case \"acorn\":",
                    "    case \"espree\":",
                    "    case \"meriyah\":",
                    "    case \"json\":",
                    "    case \"json5\":",
                    "    case \"json-stringify\":",
                    "      return astAutoFold.estree;",
                    "    case \"css\":",
                    "    case \"less\":",
                    "    case \"scss\":",
                    "      return astAutoFold.postcss;",
                    "    case \"html\":",
                    "    case \"angular\":",
                    "    case \"vue\":",
                    "    case \"lwc\":",
                    "      return astAutoFold.html;",
                    "    case \"markdown\":",
                    "    case \"mdx\":",
                    "      return astAutoFold.mdast;",
                    "    case \"yaml\":",
                    "      return astAutoFold.yaml;",
                    "    default:",
                    "      return astAutoFold[parser];",
                    "  }",
                    "}",
                    "",
                    "export function convertSelectionToRange({ head, anchor }, content) {",
                    "  const lines = content.split(\"\\n\");",
                    "  return [head, anchor]",
                    "    .map(",
                    "      ({ ch, line }) =>",
                    "        lines.slice(0, line).join(\"\\n\").length + ch + (line ? 1 : 0)",
                    "    )",
                    "    .sort((a, b) => a - b);",
                    "}",
                    "",
                    "export function convertOffsetToSelection(offset, content) {",
                    "  let line = 0;",
                    "  let ch = 0;",
                    "  for (let i = 0; i < offset && i <= content.length; i++) {",
                    "    if (content[i] === \"\\n\") {",
                    "      line++;",
                    "      ch = 0;",
                    "    } else {",
                    "      ch++;",
                    "    }",
                    "  }",
                    "  return { anchor: { line, ch } };",
                    "}",
                    "",
                    "/**",
                    " * Copied from https://github.com/prettier/prettier/blob/6fe21780115cf5f74f83876d64b03a727fbab220/src/cli/utils.js#L6-L27",
                    " * @template Obj",
                    " * @template Key",
                    " * @param {Array<Obj>} array",
                    " * @param {(value: Obj) => Key} iteratee",
                    " * @returns {{[p in Key]: T}}",
                    " */",
                    "export function groupBy(array, iteratee) {",
                    "  const result = Object.create(null);",
                    "",
                    "  for (const value of array) {",
                    "    const key = iteratee(value);",
                    "",
                    "    if (Array.isArray(result[key])) {",
                    "      result[key].push(value);",
                    "    } else {",
                    "      result[key] = [value];",
                    "    }",
                    "  }",
                    "",
                    "  return result;",
                    "}"
                ]
            },
            "sidebar": {
                "SidebarOptions.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "import { SidebarCategory } from \"./components.js\";",
                        "import Option from \"./options.js\";",
                        "",
                        "// Copied from `/src/cli/utils.js`",
                        "function groupBy(array, iteratee) {",
                        "  const result = Object.create(null);",
                        "",
                        "  for (const value of array) {",
                        "    const key = iteratee(value);",
                        "",
                        "    if (Array.isArray(result[key])) {",
                        "      result[key].push(value);",
                        "    } else {",
                        "      result[key] = [value];",
                        "    }",
                        "  }",
                        "",
                        "  return result;",
                        "}",
                        "",
                        "export default function SidebarOptions({",
                        "  categories,",
                        "  availableOptions,",
                        "  optionValues,",
                        "  onOptionValueChange,",
                        "}) {",
                        "  const options = groupBy(availableOptions, (option) => option.category);",
                        "  return categories.map((category) =>",
                        "    options[category] ? (",
                        "      <SidebarCategory key={category} title={category}>",
                        "        {options[category].map((option) => (",
                        "          <Option",
                        "            key={option.name}",
                        "            option={option}",
                        "            value={optionValues[option.name]}",
                        "            onChange={onOptionValueChange}",
                        "          />",
                        "        ))}",
                        "      </SidebarCategory>",
                        "    ) : null",
                        "  );",
                        "}"
                    ]
                },
                "components.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Sidebar({ visible, children }) {",
                        "  return (",
                        "    <div className={`options-container ${visible ? \"open\" : \"\"}`}>",
                        "      <div className=\"options\">{children}</div>",
                        "    </div>",
                        "  );",
                        "}",
                        "",
                        "export function SidebarCategory({ title, children }) {",
                        "  return (",
                        "    <details className=\"sub-options\" open=\"true\">",
                        "      <summary>{title}</summary>",
                        "      {children}",
                        "    </details>",
                        "  );",
                        "}"
                    ]
                },
                "inputs.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "export function Checkbox({ label: _label, title, checked, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      <input",
                        "        type=\"checkbox\"",
                        "        checked={checked}",
                        "        onChange={(ev) => onChange(ev.target.checked)}",
                        "      />{\" \"}",
                        "      {_label}",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function Select({ label: _label, title, values, selected, onChange }) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <select value={selected} onChange={(ev) => onChange(ev.target.value)}>",
                        "        {values.map((val) => (",
                        "          <option key={val} value={val}>",
                        "            {val}",
                        "          </option>",
                        "        ))}",
                        "      </select>",
                        "    </label>",
                        "  );",
                        "}",
                        "",
                        "export function NumberInput({",
                        "  label: _label,",
                        "  title,",
                        "  value,",
                        "  min,",
                        "  max,",
                        "  step,",
                        "  onChange,",
                        "}) {",
                        "  return (",
                        "    <label title={title}>",
                        "      {_label}{\" \"}",
                        "      <input",
                        "        type=\"number\"",
                        "        min={min}",
                        "        max={max}",
                        "        step={step}",
                        "        value={value}",
                        "        onChange={(ev) => onChange(Number.parseInt(ev.target.value, 10))}",
                        "      />",
                        "    </label>",
                        "  );",
                        "}"
                    ]
                },
                "options.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "import * as React from \"react\";",
                        "",
                        "import { Checkbox, Select, NumberInput } from \"./inputs.js\";",
                        "",
                        "export function BooleanOption({ option, value, onChange }) {",
                        "  function maybeInvert(value) {",
                        "    return option.inverted ? !value : value;",
                        "  }",
                        "  return (",
                        "    <Checkbox",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      checked={maybeInvert(value)}",
                        "      onChange={(checked) => onChange(option, maybeInvert(checked))}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function ChoiceOption({ option, value, onChange }) {",
                        "  return (",
                        "    <Select",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      values={option.choices.map((choice) => choice.value)}",
                        "      selected={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export function NumberOption({ option, value, onChange }) {",
                        "  return (",
                        "    <NumberInput",
                        "      label={option.cliName}",
                        "      title={getDescription(option)}",
                        "      min={option.range.start}",
                        "      max={option.range.end}",
                        "      step={option.range.step}",
                        "      value={value}",
                        "      onChange={(val) => onChange(option, val)}",
                        "    />",
                        "  );",
                        "}",
                        "",
                        "export default function Option(props) {",
                        "  switch (props.option.type) {",
                        "    case \"boolean\":",
                        "      return <BooleanOption {...props} />;",
                        "    case \"int\":",
                        "      return <NumberOption {...props} />;",
                        "    case \"choice\":",
                        "      return <ChoiceOption {...props} />;",
                        "    default:",
                        "      throw new Error(\"unsupported type\");",
                        "  }",
                        "}",
                        "",
                        "function getDescription(option) {",
                        "  const description = option.inverted",
                        "    ? option.oppositeDescription",
                        "    : option.description;",
                        "  return description && description.replaceAll(\"\\n\", \" \");",
                        "}"
                    ]
                }
            }
        },
        "static": {
            "_redirects": {},
            "icon.png": {},
            "install-service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "if (\"serviceWorker\" in navigator) {",
                    "  navigator.serviceWorker.register(\"/service-worker.js\", {",
                    "    scope: \"/playground/\",",
                    "  });",
                    "}"
                ]
            },
            "landing.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "\"use strict\";",
                    "",
                    "if (location.hash.slice(1).startsWith(encodeURIComponent(\"{\"))) {",
                    "  location.pathname = \"/playground/\";",
                    "}",
                    "",
                    "window.addEventListener(\"load\", () => {",
                    "  // We don't have access to a unique body css attribute for just the homepage",
                    "  // so instead it is set on load. It's only really visible on a vertical overscroll",
                    "  document.body.style.backgroundColor = \"rgb(24, 32, 37)\";",
                    "",
                    "  const logoWrapper = document.querySelector(\".animatedLogoWrapper\");",
                    "  const logo = document.querySelector(\".prettier-logo-wide\");",
                    "  const lastDash = logo.querySelector(\"g:last-of-type path:last-of-type\");",
                    "",
                    "  function handleLogoDrag(event) {",
                    "    logo.classList.add(\"rolling\");",
                    "    event.preventDefault();",
                    "  }",
                    "",
                    "  logoWrapper.setAttribute(\"draggable\", \"true\");",
                    "  logoWrapper.addEventListener(\"touchstart\", handleLogoDrag);",
                    "  logoWrapper.addEventListener(\"dragstart\", handleLogoDrag);",
                    "",
                    "  lastDash.addEventListener(\"animationend\", (event) => {",
                    "    if (/roll/.test(event.animationName)) {",
                    "      logo.classList.remove(\"rolling\");",
                    "    }",
                    "  });",
                    "});"
                ]
            },
            "manifest.json": {},
            "overrides.css": {},
            "prettier-centered-logo-static.svg": {},
            "prettier.png": {},
            "service-worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* global toolbox prettierPackageManifest */",
                    "",
                    "\"use strict\";",
                    "",
                    "importScripts(\"lib/package-manifest.js\");",
                    "importScripts(",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/sw-toolbox/3.6.0/sw-toolbox.js\"",
                    ");",
                    "",
                    "const plugins = prettierPackageManifest.builtinPlugins.map(",
                    "  ({ file }) => `lib/${file}`",
                    ");",
                    "",
                    "toolbox.precache([",
                    "  // Scripts",
                    "  \"lib/standalone.js\",",
                    "  ...plugins,",
                    "  \"playground.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/sw-toolbox/3.6.0/sw-toolbox.js\",",
                    "",
                    "  // CodeMirror; keep this in sync with website/pages/playground/index.html",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/codemirror.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/fold/foldgutter.min.css\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/codemirror.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/javascript/javascript.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/xml/xml.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/jsx/jsx.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/css/css.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/mode/markdown/markdown.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/display/placeholder.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/display/rulers.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/search/searchcursor.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/edit/matchbrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/edit/closebrackets.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/comment/comment.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/wrap/hardwrap.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/fold/foldcode.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/fold/foldgutter.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/addon/fold/brace-fold.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.9/keymap/sublime.min.js\",",
                    "",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js\",",
                    "  \"https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js\",",
                    "",
                    "  // Images",
                    "  \"/prettier.png\",",
                    "]);",
                    "",
                    "// Default to hit the cache only if there's a network error",
                    "toolbox.router.default = toolbox.networkFirst;",
                    "",
                    "// For scripts, stylesheets and images, we can use the \"fastest\" strategy",
                    "// This means you need to reload twice to get new changes",
                    "toolbox.router.get(/\\.(js|css|png|svg)$/, toolbox.fastest);"
                ]
            },
            "worker.js": {
                "classes": [],
                "functions": [],
                "text": [
                    "/* globals prettier prettierPlugins prettierPackageManifest */",
                    "",
                    "\"use strict\";",
                    "",
                    "importScripts(\"lib/package-manifest.js\");",
                    "importScripts(\"lib/standalone.js\");",
                    "",
                    "// TODO[@fisker]: Lazy load plugins",
                    "for (const { file } of prettierPackageManifest.builtinPlugins) {",
                    "  importScripts(`lib/${file}`);",
                    "}",
                    "",
                    "const docExplorerPlugin = {",
                    "  parsers: {",
                    "    \"doc-explorer\": {",
                    "      parse: (text) =>",
                    "        new Function(",
                    "          `{ ${Object.keys(prettier.doc.builders)} }`,",
                    "          `const result = (${text || \"''\"}\\n); return result;`",
                    "        )(prettier.doc.builders),",
                    "      astFormat: \"doc-explorer\",",
                    "    },",
                    "  },",
                    "  printers: {",
                    "    \"doc-explorer\": {",
                    "      print: (path) => path.getValue(),",
                    "    },",
                    "  },",
                    "  languages: [{ name: \"doc-explorer\", parsers: [\"doc-explorer\"] }],",
                    "};",
                    "",
                    "const plugins = [...Object.values(prettierPlugins), docExplorerPlugin];",
                    "",
                    "self.onmessage = async function (event) {",
                    "  self.postMessage({",
                    "    uid: event.data.uid,",
                    "    message: await handleMessage(event.data.message),",
                    "  });",
                    "};",
                    "",
                    "function serializeAst(ast) {",
                    "  return JSON.stringify(",
                    "    ast,",
                    "    (_, value) =>",
                    "      value instanceof Error",
                    "        ? { name: value.name, message: value.message, ...value }",
                    "        : typeof value === \"bigint\"",
                    "        ? `BigInt('${String(value)}')`",
                    "        : typeof value === \"symbol\"",
                    "        ? String(value)",
                    "        : value,",
                    "    2",
                    "  );",
                    "}",
                    "",
                    "function handleMessage(message) {",
                    "  switch (message.type) {",
                    "    case \"meta\":",
                    "      return handleMetaMessage();",
                    "    case \"format\":",
                    "      return handleFormatMessage(message);",
                    "  }",
                    "}",
                    "",
                    "async function handleMetaMessage() {",
                    "  const supportInfo = await prettier.getSupportInfo({ plugins });",
                    "",
                    "  return {",
                    "    type: \"meta\",",
                    "    supportInfo: JSON.parse(JSON.stringify(supportInfo)),",
                    "    version: prettier.version,",
                    "  };",
                    "}",
                    "",
                    "async function handleFormatMessage(message) {",
                    "  const options = { ...message.options, plugins };",
                    "",
                    "  delete options.ast;",
                    "  delete options.doc;",
                    "  delete options.output2;",
                    "",
                    "  const formatResult = await formatCode(",
                    "    message.code,",
                    "    options,",
                    "    message.debug.rethrowEmbedErrors",
                    "  );",
                    "",
                    "  const response = {",
                    "    formatted: formatResult.formatted,",
                    "    cursorOffset: formatResult.cursorOffset,",
                    "    error: formatResult.error,",
                    "    debug: {",
                    "      ast: null,",
                    "      doc: null,",
                    "      comments: null,",
                    "      reformatted: null,",
                    "    },",
                    "  };",
                    "",
                    "  for (const key of [\"ast\", \"preprocessedAst\"]) {",
                    "    if (!message.debug[key]) {",
                    "      continue;",
                    "    }",
                    "    let ast;",
                    "    let errored = false;",
                    "    try {",
                    "      const parsed = await prettier.__debug.parse(message.code, options, {",
                    "        preprocessForPrint: key === \"preprocessedAst\",",
                    "      });",
                    "      ast = serializeAst(parsed.ast);",
                    "    } catch (e) {",
                    "      errored = true;",
                    "      ast = String(e);",
                    "    }",
                    "",
                    "    if (!errored) {",
                    "      try {",
                    "        ast = (await formatCode(ast, { parser: \"json\", plugins })).formatted;",
                    "      } catch {",
                    "        ast = serializeAst(ast);",
                    "      }",
                    "    }",
                    "    response.debug[key] = ast;",
                    "  }",
                    "",
                    "  if (message.debug.doc) {",
                    "    try {",
                    "      response.debug.doc = await prettier.__debug.formatDoc(",
                    "        await prettier.__debug.printToDoc(message.code, options),",
                    "        { plugins }",
                    "      );",
                    "    } catch {",
                    "      response.debug.doc = \"\";",
                    "    }",
                    "  }",
                    "",
                    "  if (message.debug.comments) {",
                    "    response.debug.comments = (",
                    "      await formatCode(JSON.stringify(formatResult.comments || []), {",
                    "        parser: \"json\",",
                    "        plugins,",
                    "      })",
                    "    ).formatted;",
                    "  }",
                    "",
                    "  if (message.debug.reformat) {",
                    "    response.debug.reformatted = (",
                    "      await formatCode(response.formatted, options)",
                    "    ).formatted;",
                    "  }",
                    "",
                    "  return response;",
                    "}",
                    "",
                    "async function formatCode(text, options, rethrowEmbedErrors) {",
                    "  try {",
                    "    self.PRETTIER_DEBUG = rethrowEmbedErrors;",
                    "    return await prettier.formatWithCursor(text, options);",
                    "  } catch (e) {",
                    "    if (e.constructor && e.constructor.name === \"SyntaxError\") {",
                    "      // Likely something wrong with the user's code",
                    "      return { formatted: String(e), error: true };",
                    "    }",
                    "    // Likely a bug in Prettier",
                    "    // Provide the whole stack for debugging",
                    "    return { formatted: stringifyError(e), error: true };",
                    "  } finally {",
                    "    self.PRETTIER_DEBUG = undefined;",
                    "  }",
                    "}",
                    "",
                    "function stringifyError(e) {",
                    "  const stringified = String(e);",
                    "  if (typeof e.stack !== \"string\") {",
                    "    return stringified;",
                    "  }",
                    "  if (e.stack.includes(stringified)) {",
                    "    // Chrome",
                    "    return e.stack;",
                    "  }",
                    "  // Firefox",
                    "  return stringified + \"\\n\" + e.stack;",
                    "}"
                ]
            },
            "css": {
                "code-block-buttons.css": {}
            },
            "images": {
                "get_started_rects.svg": {},
                "github.svg": {},
                "github_grey.svg": {},
                "npm.svg": {},
                "npm_grey.svg": {},
                "state_of_js_grey.svg": {},
                "tidelift-small.png": {},
                "editors": {
                    "atom-128px.png": {},
                    "editor_atom.svg": {},
                    "editor_emacs.svg": {},
                    "editor_espresso.svg": {},
                    "editor_nova.svg": {},
                    "editor_sublime.svg": {},
                    "editor_vim.svg": {},
                    "editor_vs.svg": {},
                    "editor_vscode.svg": {},
                    "editor_webstorm.svg": {},
                    "emacs-128px.png": {},
                    "espresso-128px.png": {},
                    "sublimetext-128px.png": {},
                    "vim-128px.png": {},
                    "visualstudio-128px.png": {},
                    "vscode-128px.png": {},
                    "webstorm-128px.png": {}
                },
                "languages": {
                    "css-128px.png": {},
                    "css_small_grey.svg": {},
                    "graphql-128px.png": {},
                    "graphql_small_grey.svg": {},
                    "js-128px.png": {},
                    "js_small_grey.svg": {},
                    "markdown-128px.png": {},
                    "markdown_small_grey.svg": {},
                    "python_small_grey.svg": {},
                    "swift_small_grey.svg": {},
                    "tools_css.svg": {},
                    "tools_gql.svg": {},
                    "tools_html.svg": {},
                    "tools_js.svg": {},
                    "tools_md.svg": {},
                    "tools_wip.svg": {},
                    "tools_yaml.svg": {}
                },
                "users": {
                    "3yourmind.svg": {},
                    "aircall.svg": {},
                    "algolia-200x100.png": {},
                    "assertible-200x100.png": {},
                    "babel-200x100.png": {},
                    "brigad-200x100.png": {},
                    "buildcom.svg": {},
                    "campusjaeger.svg": {},
                    "charlietango-200x100.png": {},
                    "chillicream.svg": {},
                    "codecarrot.svg": {},
                    "codemix-200x100.png": {},
                    "computerbase.svg": {},
                    "contiamo-200x100.png": {},
                    "danger-200x100.png": {},
                    "dev-it-jobs-200-100.jpg": {},
                    "discord-200x100.png": {},
                    "drizly-200x100.png": {},
                    "dropbox.svg": {},
                    "dropbox_grey.svg": {},
                    "escrow-200x100.png": {},
                    "estalee.svg": {},
                    "eventstag-200x100.png": {},
                    "exponea.svg": {},
                    "eyesquare-200x100.png": {},
                    "facebook-200x100.png": {},
                    "freelancer-200x100.png": {},
                    "getonboard-200x100.png": {},
                    "gumgum-200x100.png": {},
                    "hackclub-200x100.png": {},
                    "hasura-200x100.png": {},
                    "hearthsim-200x100.png": {},
                    "heroku.svg": {},
                    "holidaycheck-200x100.png": {},
                    "housinganywhere.svg": {},
                    "hudl-200x100.png": {},
                    "icons8.svg": {},
                    "ideati-200x100.png": {},
                    "iress-200x100.png": {},
                    "jane-200x100.png": {},
                    "jest-200x100.png": {},
                    "leesa.svg": {},
                    "lifesum-200x100.png": {},
                    "loyaltylion-200x100.png": {},
                    "m6web-200x100.png": {},
                    "materialui-200x100.png": {},
                    "mathrioshka-200x100.png": {},
                    "metric-ai-white.svg": {},
                    "monei-200x100.png": {},
                    "mongodb-200x100.png": {},
                    "moonmail-200x100.png": {},
                    "n26-200x100.png": {},
                    "nhl-200x100.png": {},
                    "nrwl-200x100.png": {},
                    "openbravo-200x100.png": {},
                    "outreach-200x100.png": {},
                    "paypal-200x100.png": {},
                    "quip.svg": {},
                    "react-200x100.png": {},
                    "researchanddesign.svg": {},
                    "rnfirebase-200x100.png": {},
                    "salesforce.svg": {},
                    "sevenspan-200x100.png": {},
                    "shelf-200x100.png": {},
                    "smooth-code-200x100.png": {},
                    "storybook-200x100.png": {},
                    "swissdev-devops-jobs-200-100.png": {},
                    "talkable-200x100.png": {},
                    "toptal.png": {},
                    "tradeshift-200x100.png": {},
                    "tradie-training.png": {},
                    "transloadit-200x100.png": {},
                    "troops-200x100.png": {},
                    "used_by_babel.svg": {},
                    "used_by_danger.svg": {},
                    "used_by_facebook.svg": {},
                    "used_by_jest.svg": {},
                    "used_by_react.svg": {},
                    "used_by_spotify.svg": {},
                    "used_by_storybook.svg": {},
                    "used_by_webpack.svg": {},
                    "used_by_yarn.svg": {},
                    "used_by_zeit.svg": {},
                    "vercel-logotype-dark.svg": {},
                    "webflow-200x100.png": {},
                    "webpack-200x100.png": {},
                    "wingify-200x100.png": {},
                    "wire-200x100.png": {},
                    "yarn-200x100.png": {},
                    "yelp-200x100.png": {},
                    "zipch-200x100.png": {}
                }
            },
            "js": {
                "code-block-buttons.js": {
                    "classes": [],
                    "functions": [],
                    "text": [
                        "/* global ClipboardJS */",
                        "",
                        "\"use strict\";",
                        "",
                        "(function () {",
                        "  const CONTAINER_CLASS_NAME = \"code-block-with-actions\";",
                        "  const ACTIONS_CONTAINER_CLASS_NAME = \"code-block-actions\";",
                        "  const COPY_BUTTON_CLASS_NAME = \"code-block-copy-button\";",
                        "  const COPY_BUTTON_COPIED_CLASS_NAME = `${COPY_BUTTON_CLASS_NAME}--copied`;",
                        "  const COPY_BUTTON_ICON_CLASS_NAME = `${COPY_BUTTON_CLASS_NAME}__icon`;",
                        "  const COPY_BUTTON_COPY_ICON_CLASS_NAME = `${COPY_BUTTON_ICON_CLASS_NAME}--copy`;",
                        "  const COPY_BUTTON_COPIED_ICON_CLASS_NAME = `${COPY_BUTTON_ICON_CLASS_NAME}--copied`;",
                        "  const ARIA_LABEL = \"Copy code to clipboard\";",
                        "  const ARIA_LABEL_COPIED = \"Copied\";",
                        "",
                        "  function init(codeBlock) {",
                        "    const container = codeBlock.parentNode;",
                        "    container.classList.add(CONTAINER_CLASS_NAME);",
                        "",
                        "    const actionsContainer = Object.assign(document.createElement(\"div\"), {",
                        "      className: ACTIONS_CONTAINER_CLASS_NAME,",
                        "    });",
                        "    const copyButton = Object.assign(document.createElement(\"button\"), {",
                        "      className: COPY_BUTTON_CLASS_NAME,",
                        "      type: \"button\",",
                        "      innerHTML:",
                        "        `<svg class=\"${COPY_BUTTON_ICON_CLASS_NAME} ${COPY_BUTTON_COPY_ICON_CLASS_NAME}\" viewBox=\"0 0 24 24\"><path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path></svg>` +",
                        "        `<svg class=\"${COPY_BUTTON_ICON_CLASS_NAME} ${COPY_BUTTON_COPIED_ICON_CLASS_NAME}\" viewBox=\"0 0 24 24\"><path d=\"M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z\"></path></svg>`,",
                        "    });",
                        "    copyButton.setAttribute(\"aria-label\", ARIA_LABEL);",
                        "",
                        "    new ClipboardJS(copyButton, { target: () => codeBlock }).on(",
                        "      \"success\",",
                        "      (event) => {",
                        "        event.clearSelection();",
                        "        copyButton.classList.add(COPY_BUTTON_COPIED_CLASS_NAME);",
                        "        copyButton.setAttribute(\"aria-label\", ARIA_LABEL_COPIED);",
                        "        copyButton.disabled = true;",
                        "",
                        "        setTimeout(() => {",
                        "          copyButton.classList.remove(COPY_BUTTON_COPIED_CLASS_NAME);",
                        "          copyButton.setAttribute(\"aria-label\", ARIA_LABEL);",
                        "          copyButton.disabled = false;",
                        "        }, 2000);",
                        "      }",
                        "    );",
                        "",
                        "    actionsContainer.appendChild(copyButton);",
                        "    container.appendChild(actionsContainer);",
                        "  }",
                        "",
                        "  window.addEventListener(\"load\", () => {",
                        "    for (const codeBlock of document.querySelectorAll(\"pre > code.hljs\")) {",
                        "      init(codeBlock);",
                        "    }",
                        "  });",
                        "})();"
                    ]
                }
            },
            "separate-css": {
                "playground.css": {}
            }
        },
        "versioned_docs": {
            "version-stable": {
                "api.md": {},
                "browser.md": {},
                "cli.md": {},
                "comparison.md": {},
                "configuration.md": {},
                "editors.md": {},
                "for-enterprise.md": {},
                "ignore.md": {},
                "index.md": {},
                "install.md": {},
                "integrating-with-linters.md": {},
                "option-philosophy.md": {},
                "options.md": {},
                "plugins.md": {},
                "precommit.md": {},
                "rationale.md": {},
                "related-projects.md": {},
                "technical-details.md": {},
                "vim.md": {},
                "watching-files.md": {},
                "webstorm.md": {},
                "why-prettier.md": {}
            }
        },
        "versioned_sidebars": {
            "version-stable-sidebars.json": {}
        }
    }
}