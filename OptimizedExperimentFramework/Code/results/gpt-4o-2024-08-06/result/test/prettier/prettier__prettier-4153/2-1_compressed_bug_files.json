{
    "1": {
        "bug_file": "src/language-markdown/parser-markdown.js",
        "compressed": "NO",
        "line_numbers": 130,
        "compressed_line_numbers": 130,
        "compressed_bug_file_content": "\"use strict\";\n\nconst remarkFrontmatter = require(\"remark-frontmatter\");\nconst remarkParse = require(\"remark-parse\");\nconst unified = require(\"unified\");\nconst util = require(\"../common/util\");\n\n/**\n * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:\n *\n * 1. restore unescaped character (Text)\n * 2. merge continuous Texts\n * 3. replace whitespaces in InlineCode#value with one whitespace\n *    reference: http://spec.commonmark.org/0.25/#example-605\n * 4. split Text into Sentence\n *\n * interface Word { value: string }\n * interface Whitespace { value: string }\n * interface Sentence { children: Array<Word | Whitespace> }\n * interface InlineCode { children: Array<Sentence> }\n */\nfunction parse(text /*, parsers, opts*/) {\n  const processor = unified()\n    .use(remarkParse, { footnotes: true, commonmark: true })\n    .use(remarkFrontmatter, [\"yaml\", \"toml\"])\n    .use(restoreUnescapedCharacter(text))\n    .use(mergeContinuousTexts)\n    .use(transformInlineCode)\n    .use(splitText);\n  return processor.runSync(processor.parse(text));\n}\n\nfunction map(ast, handler) {\n  return (function preorder(node, index, parentNode) {\n    const newNode = Object.assign({}, handler(node, index, parentNode));\n    if (newNode.children) {\n      newNode.children = newNode.children.map((child, index) => {\n        return preorder(child, index, newNode);\n      });\n    }\n    return newNode;\n  })(ast, null, null);\n}\n\nfunction transformInlineCode() {\n  return ast =>\n    map(ast, node => {\n      if (node.type !== \"inlineCode\") {\n        return node;\n      }\n\n      return Object.assign({}, node, {\n        value: node.value.replace(/\\s+/g, \" \")\n      });\n    });\n}\n\nfunction restoreUnescapedCharacter(originalText) {\n  return () => ast =>\n    map(ast, node => {\n      return node.type !== \"text\"\n        ? node\n        : Object.assign({}, node, {\n            value:\n              node.value !== \"*\" &&\n              node.value !== \"_\" && // handle these two cases in printer\n              node.value.length === 1 &&\n              node.position.end.offset - node.position.start.offset > 1\n                ? originalText.slice(\n                    node.position.start.offset,\n                    node.position.end.offset\n                  )\n                : node.value\n          });\n    });\n}\n\nfunction mergeContinuousTexts() {\n  return ast =>\n    map(ast, node => {\n      if (!node.children) {\n        return node;\n      }\n      const children = node.children.reduce((current, child) => {\n        const lastChild = current[current.length - 1];\n        if (lastChild && lastChild.type === \"text\" && child.type === \"text\") {\n          current.splice(-1, 1, {\n            type: \"text\",\n            value: lastChild.value + child.value,\n            position: {\n              start: lastChild.position.start,\n              end: child.position.end\n            }\n          });\n        } else {\n          current.push(child);\n        }\n        return current;\n      }, []);\n      return Object.assign({}, node, { children });\n    });\n}\n\nfunction splitText() {\n  return ast =>\n    map(ast, (node, index, parentNode) => {\n      if (node.type !== \"text\") {\n        return node;\n      }\n\n      let value = node.value;\n\n      if (parentNode.type === \"paragraph\") {\n        if (index === 0) {\n          value = value.trimLeft();\n        }\n        if (index === parentNode.children.length - 1) {\n          value = value.trimRight();\n        }\n      }\n\n      return {\n        type: \"sentence\",\n        position: node.position,\n        children: util.splitText(value)\n      };\n    });\n}\n\nmodule.exports = parse;"
    },
    "2": {
        "bug_file": "src/language-markdown/printer-markdown.js",
        "compressed": "YES",
        "line_numbers": 739,
        "compressed_line_numbers": 28,
        "compressed_bug_file_content": "\n\n        // leading char that may cause different syntax\n\n\n        // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it\n\n\n        // indented code block\n\n\n      // fenced code block\n\n\n            // do not print trailing spaces for empty list item since it might be treated as `break` node\n            // by [doc-printer](https://github.com/prettier/prettier/blob/1.10.2/src/doc/doc-printer.js#L395-L405),\n            // we don't want to preserve unnecessary trailing spaces.\n\n\n  // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split\n\n\n  // for markdown codeblock\n\n\n  // for markdown whitespace: \"\\n\" and \" \" are considered the same\n\n\n"
    },
    "3": {
        "bug_file": "src/main/parser.js",
        "compressed": "NO",
        "line_numbers": 94,
        "compressed_line_numbers": 94,
        "compressed_bug_file_content": "\"use strict\";\n\nconst path = require(\"path\");\nconst ConfigError = require(\"../common/errors\").ConfigError;\nconst js = require(\"../language-js/index.js\");\n\nconst locStart = js.locStart;\nconst locEnd = js.locEnd;\n\nfunction getParsers(options) {\n  return options.plugins.reduce(\n    (parsers, plugin) => Object.assign({}, parsers, plugin.parsers),\n    {}\n  );\n}\n\nfunction resolveParser(opts, parsers) {\n  parsers = parsers || getParsers(opts);\n\n  if (typeof opts.parser === \"function\") {\n    // Custom parser API always works with JavaScript.\n    return {\n      parse: opts.parser,\n      astFormat: \"estree\",\n      locStart,\n      locEnd\n    };\n  }\n\n  if (typeof opts.parser === \"string\") {\n    if (parsers.hasOwnProperty(opts.parser)) {\n      return parsers[opts.parser];\n    }\n    try {\n      return {\n        parse: eval(\"require\")(path.resolve(process.cwd(), opts.parser)),\n        astFormat: \"estree\",\n        locStart,\n        locEnd\n      };\n    } catch (err) {\n      /* istanbul ignore next */\n      throw new ConfigError(`Couldn't resolve parser \"${opts.parser}\"`);\n    }\n  }\n  /* istanbul ignore next */\n  return parsers.babylon;\n}\n\nfunction parse(text, opts) {\n  const parsers = getParsers(opts);\n\n  // Copy the \"parse\" function from parser to a new object whose values are\n  // functions. Use defineProperty()/getOwnPropertyDescriptor() such that we\n  // don't invoke the parser.parse getters.\n  const parsersForCustomParserApi = Object.keys(parsers).reduce(\n    (object, parserName) =>\n      Object.defineProperty(\n        object,\n        parserName,\n        Object.getOwnPropertyDescriptor(parsers[parserName], \"parse\")\n      ),\n    {}\n  );\n\n  const parser = resolveParser(opts, parsers);\n\n  try {\n    if (parser.preprocess) {\n      text = parser.preprocess(text, opts);\n    }\n\n    return {\n      text,\n      ast: parser.parse(text, parsersForCustomParserApi, opts)\n    };\n  } catch (error) {\n    const loc = error.loc;\n\n    if (loc) {\n      const codeFrame = require(\"@babel/code-frame\");\n      error.codeFrame = codeFrame.codeFrameColumns(text, loc, {\n        highlightCode: true\n      });\n      error.message += \"\\n\" + error.codeFrame;\n      throw error;\n    }\n\n    /* istanbul ignore next */\n    throw error.stack;\n  }\n}\n\nmodule.exports = { parse, resolveParser };"
    },
    "4": {
        "bug_file": "src/language-markdown/index.js",
        "compressed": "NO",
        "line_numbers": 59,
        "compressed_line_numbers": 59,
        "compressed_bug_file_content": "\"use strict\";\n\nconst printer = require(\"./printer-markdown\");\nconst options = require(\"./options\");\n\n// Based on:\n// https://github.com/github/linguist/blob/master/lib/linguist/languages.yml\n\nconst languages = [\n  {\n    name: \"Markdown\",\n    since: \"1.8.0\",\n    parsers: [\"remark\"],\n    aliases: [\"pandoc\"],\n    aceMode: \"markdown\",\n    codemirrorMode: \"gfm\",\n    codemirrorMimeType: \"text/x-gfm\",\n    wrap: true,\n    extensions: [\n      \".md\",\n      \".markdown\",\n      \".mdown\",\n      \".mdwn\",\n      \".mkd\",\n      \".mkdn\",\n      \".mkdown\",\n      \".ron\",\n      \".workbook\"\n    ],\n    filenames: [\"README\"],\n    tmScope: \"source.gfm\",\n    linguistLanguageId: 222,\n    vscodeLanguageIds: [\"markdown\"]\n  }\n];\n\nconst remark = {\n  get parse() {\n    return eval(\"require\")(\"./parser-markdown\");\n  },\n  astFormat: \"mdast\"\n};\n\nconst parsers = {\n  remark,\n  // TODO: Delete this in 2.0\n  markdown: remark\n};\n\nconst printers = {\n  mdast: printer\n};\n\nmodule.exports = {\n  languages,\n  options,\n  parsers,\n  printers\n};"
    }
}