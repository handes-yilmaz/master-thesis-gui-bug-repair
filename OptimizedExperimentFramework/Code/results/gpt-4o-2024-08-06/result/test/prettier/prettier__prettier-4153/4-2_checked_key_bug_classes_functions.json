{
    "bug_classes": {
        "1": {
            "class_name": "parse (not found) ",
            "file_path": "src/language-markdown/parser-markdown.js",
            "class_details": [
                {
                    "name": "parse",
                    "start_line": 1,
                    "end_line": 130
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const remarkFrontmatter = require(\"remark-frontmatter\");",
                "const remarkParse = require(\"remark-parse\");",
                "const unified = require(\"unified\");",
                "const util = require(\"../common/util\");",
                "",
                "/**",
                " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                " *",
                " * 1. restore unescaped character (Text)",
                " * 2. merge continuous Texts",
                " * 3. replace whitespaces in InlineCode#value with one whitespace",
                " *    reference: http://spec.commonmark.org/0.25/#example-605",
                " * 4. split Text into Sentence",
                " *",
                " * interface Word { value: string }",
                " * interface Whitespace { value: string }",
                " * interface Sentence { children: Array<Word | Whitespace> }",
                " * interface InlineCode { children: Array<Sentence> }",
                " */",
                "function parse(text /*, parsers, opts*/) {",
                "  const processor = unified()",
                "    .use(remarkParse, { footnotes: true, commonmark: true })",
                "    .use(remarkFrontmatter, [\"yaml\", \"toml\"])",
                "    .use(restoreUnescapedCharacter(text))",
                "    .use(mergeContinuousTexts)",
                "    .use(transformInlineCode)",
                "    .use(splitText);",
                "  return processor.runSync(processor.parse(text));",
                "}",
                "",
                "function map(ast, handler) {",
                "  return (function preorder(node, index, parentNode) {",
                "    const newNode = Object.assign({}, handler(node, index, parentNode));",
                "    if (newNode.children) {",
                "      newNode.children = newNode.children.map((child, index) => {",
                "        return preorder(child, index, newNode);",
                "      });",
                "    }",
                "    return newNode;",
                "  })(ast, null, null);",
                "}",
                "",
                "function transformInlineCode() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (node.type !== \"inlineCode\") {",
                "        return node;",
                "      }",
                "",
                "      return Object.assign({}, node, {",
                "        value: node.value.replace(/\\s+/g, \" \")",
                "      });",
                "    });",
                "}",
                "",
                "function restoreUnescapedCharacter(originalText) {",
                "  return () => ast =>",
                "    map(ast, node => {",
                "      return node.type !== \"text\"",
                "        ? node",
                "        : Object.assign({}, node, {",
                "            value:",
                "              node.value !== \"*\" &&",
                "              node.value !== \"_\" && // handle these two cases in printer",
                "              node.value.length === 1 &&",
                "              node.position.end.offset - node.position.start.offset > 1",
                "                ? originalText.slice(",
                "                    node.position.start.offset,",
                "                    node.position.end.offset",
                "                  )",
                "                : node.value",
                "          });",
                "    });",
                "}",
                "",
                "function mergeContinuousTexts() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (!node.children) {",
                "        return node;",
                "      }",
                "      const children = node.children.reduce((current, child) => {",
                "        const lastChild = current[current.length - 1];",
                "        if (lastChild && lastChild.type === \"text\" && child.type === \"text\") {",
                "          current.splice(-1, 1, {",
                "            type: \"text\",",
                "            value: lastChild.value + child.value,",
                "            position: {",
                "              start: lastChild.position.start,",
                "              end: child.position.end",
                "            }",
                "          });",
                "        } else {",
                "          current.push(child);",
                "        }",
                "        return current;",
                "      }, []);",
                "      return Object.assign({}, node, { children });",
                "    });",
                "}",
                "",
                "function splitText() {",
                "  return ast =>",
                "    map(ast, (node, index, parentNode) => {",
                "      if (node.type !== \"text\") {",
                "        return node;",
                "      }",
                "",
                "      let value = node.value;",
                "",
                "      if (parentNode.type === \"paragraph\") {",
                "        if (index === 0) {",
                "          value = value.trimLeft();",
                "        }",
                "        if (index === parentNode.children.length - 1) {",
                "          value = value.trimRight();",
                "        }",
                "      }",
                "",
                "      return {",
                "        type: \"sentence\",",
                "        position: node.position,",
                "        children: util.splitText(value)",
                "      };",
                "    });",
                "}",
                "",
                "module.exports = parse;"
            ]
        },
        "2": {
            "class_name": "  (not found) 1-501",
            "file_path": "src/language-markdown/printer-markdown.js",
            "class_details": [
                {
                    "name": " ",
                    "start_line": 1,
                    "end_line": 501
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const privateUtil = require(\"../common/util\");",
                "const embed = require(\"./embed\");",
                "const doc = require(\"../doc\");",
                "const docBuilders = doc.builders;",
                "const concat = docBuilders.concat;",
                "const join = docBuilders.join;",
                "const line = docBuilders.line;",
                "const hardline = docBuilders.hardline;",
                "const softline = docBuilders.softline;",
                "const fill = docBuilders.fill;",
                "const align = docBuilders.align;",
                "const group = docBuilders.group;",
                "const printDocToString = doc.printer.printDocToString;",
                "",
                "const SINGLE_LINE_NODE_TYPES = [\"heading\", \"tableCell\", \"link\"];",
                "",
                "const SIBLING_NODE_TYPES = [\"listItem\", \"definition\", \"footnoteDefinition\"];",
                "",
                "const INLINE_NODE_TYPES = [",
                "  \"inlineCode\",",
                "  \"emphasis\",",
                "  \"strong\",",
                "  \"delete\",",
                "  \"link\",",
                "  \"linkReference\",",
                "  \"image\",",
                "  \"imageReference\",",
                "  \"footnote\",",
                "  \"footnoteReference\",",
                "  \"sentence\",",
                "  \"whitespace\",",
                "  \"word\",",
                "  \"break\"",
                "];",
                "",
                "const INLINE_NODE_WRAPPER_TYPES = INLINE_NODE_TYPES.concat([",
                "  \"tableCell\",",
                "  \"paragraph\",",
                "  \"heading\"",
                "]);",
                "",
                "function genericPrint(path, options, print) {",
                "  const node = path.getValue();",
                "",
                "  if (shouldRemainTheSameContent(path)) {",
                "    return concat(",
                "      privateUtil",
                "        .splitText(",
                "          options.originalText.slice(",
                "            node.position.start.offset,",
                "            node.position.end.offset",
                "          )",
                "        )",
                "        .map(",
                "          node =>",
                "            node.type === \"word\"",
                "              ? node.value",
                "              : node.value === \"\" ? \"\" : printLine(path, node.value, options)",
                "        )",
                "    );",
                "  }",
                "",
                "  switch (node.type) {",
                "    case \"root\":",
                "      return concat([",
                "        normalizeDoc(printChildren(path, options, print)),",
                "        hardline",
                "      ]);",
                "    case \"paragraph\":",
                "      return printChildren(path, options, print, {",
                "        postprocessor: fill",
                "      });",
                "    case \"sentence\":",
                "      return printChildren(path, options, print);",
                "    case \"word\":",
                "      return node.value",
                "        .replace(/[*]/g, \"\\\\*\") // escape all `*`",
                "        .replace(",
                "          new RegExp(",
                "            [",
                "              `(^|[${privateUtil.punctuationCharRange}])(_+)`,",
                "              `(_+)([${privateUtil.punctuationCharRange}]|$)`",
                "            ].join(\"|\"),",
                "            \"g\"",
                "          ),",
                "          (_, text1, underscore1, underscore2, text2) =>",
                "            (underscore1",
                "              ? `${text1}${underscore1}`",
                "              : `${underscore2}${text2}`",
                "            ).replace(/_/g, \"\\\\_\")",
                "        ); // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis",
                "    case \"whitespace\": {",
                "      const parentNode = path.getParentNode();",
                "      const index = parentNode.children.indexOf(node);",
                "      const nextNode = parentNode.children[index + 1];",
                "",
                "      const proseWrap =",
                "        // leading char that may cause different syntax",
                "        nextNode && /^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(nextNode.value)",
                "          ? \"never\"",
                "          : options.proseWrap;",
                "",
                "      return printLine(path, node.value, { proseWrap });",
                "    }",
                "    case \"emphasis\": {",
                "      const parentNode = path.getParentNode();",
                "      const index = parentNode.children.indexOf(node);",
                "      const prevNode = parentNode.children[index - 1];",
                "      const nextNode = parentNode.children[index + 1];",
                "      const hasPrevOrNextWord = // `1*2*3` is considered emphais but `1_2_3` is not",
                "        (prevNode &&",
                "          prevNode.type === \"sentence\" &&",
                "          prevNode.children.length > 0 &&",
                "          privateUtil.getLast(prevNode.children).type === \"word\" &&",
                "          !privateUtil.getLast(prevNode.children).hasTrailingPunctuation) ||",
                "        (nextNode &&",
                "          nextNode.type === \"sentence\" &&",
                "          nextNode.children.length > 0 &&",
                "          nextNode.children[0].type === \"word\" &&",
                "          !nextNode.children[0].hasLeadingPunctuation);",
                "      const style =",
                "        hasPrevOrNextWord || getAncestorNode(path, \"emphasis\") ? \"*\" : \"_\";",
                "      return concat([style, printChildren(path, options, print), style]);",
                "    }",
                "    case \"strong\":",
                "      return concat([\"**\", printChildren(path, options, print), \"**\"]);",
                "    case \"delete\":",
                "      return concat([\"~~\", printChildren(path, options, print), \"~~\"]);",
                "    case \"inlineCode\": {",
                "      const backtickCount = privateUtil.getMaxContinuousCount(node.value, \"`\");",
                "      const style = backtickCount === 1 ? \"``\" : \"`\";",
                "      const gap = backtickCount ? \" \" : \"\";",
                "      return concat([style, gap, node.value, gap, style]);",
                "    }",
                "    case \"link\":",
                "      switch (options.originalText[node.position.start.offset]) {",
                "        case \"<\":",
                "          return concat([\"<\", node.url, \">\"]);",
                "        case \"[\":",
                "          return concat([",
                "            \"[\",",
                "            printChildren(path, options, print),",
                "            \"](\",",
                "            printUrl(node.url, \")\"),",
                "            printTitle(node.title, options),",
                "            \")\"",
                "          ]);",
                "        default:",
                "          return options.originalText.slice(",
                "            node.position.start.offset,",
                "            node.position.end.offset",
                "          );",
                "      }",
                "    case \"image\":",
                "      return concat([",
                "        \"![\",",
                "        node.alt || \"\",",
                "        \"](\",",
                "        printUrl(node.url, \")\"),",
                "        printTitle(node.title, options),",
                "        \")\"",
                "      ]);",
                "    case \"blockquote\":",
                "      return concat([\"> \", align(\"> \", printChildren(path, options, print))]);",
                "    case \"heading\":",
                "      return concat([",
                "        \"#\".repeat(node.depth) + \" \",",
                "        printChildren(path, options, print)",
                "      ]);",
                "    case \"code\": {",
                "      if (",
                "        // the first char may point to `\\n`, e.g. `\\n\\t\\tbar`, just ignore it",
                "        /^\\n?( {4,}|\\t)/.test(",
                "          options.originalText.slice(",
                "            node.position.start.offset,",
                "            node.position.end.offset",
                "          )",
                "        )",
                "      ) {",
                "        // indented code block",
                "        const alignment = \" \".repeat(4);",
                "        return align(",
                "          alignment,",
                "          concat([alignment, join(hardline, node.value.split(\"\\n\"))])",
                "        );",
                "      }",
                "",
                "      // fenced code block",
                "      const styleUnit = options.__inJsTemplate ? \"~\" : \"`\";",
                "      const style = styleUnit.repeat(",
                "        Math.max(",
                "          3,",
                "          privateUtil.getMaxContinuousCount(node.value, styleUnit) + 1",
                "        )",
                "      );",
                "      return concat([",
                "        style,",
                "        node.lang || \"\",",
                "        hardline,",
                "        join(hardline, node.value.split(\"\\n\")),",
                "        hardline,",
                "        style",
                "      ]);",
                "    }",
                "    case \"yaml\":",
                "      return concat([\"---\", hardline, node.value, hardline, \"---\"]);",
                "    case \"toml\":",
                "      return concat([\"+++\", hardline, node.value, hardline, \"+++\"]);",
                "    case \"html\": {",
                "      const parentNode = path.getParentNode();",
                "      return replaceNewlinesWithHardlines(",
                "        parentNode.type === \"root\" &&",
                "        privateUtil.getLast(parentNode.children) === node",
                "          ? node.value.trimRight()",
                "          : node.value",
                "      );",
                "    }",
                "    case \"list\": {",
                "      const nthSiblingIndex = getNthListSiblingIndex(",
                "        node,",
                "        path.getParentNode()",
                "      );",
                "",
                "      const isGitDiffFriendlyOrderedList =",
                "        node.ordered &&",
                "        node.children.length > 1 &&",
                "        /^\\s*1(\\.|\\))/.test(",
                "          options.originalText.slice(",
                "            node.children[1].position.start.offset,",
                "            node.children[1].position.end.offset",
                "          )",
                "        );",
                "",
                "      return printChildren(path, options, print, {",
                "        processor: (childPath, index) => {",
                "          const prefix = getPrefix();",
                "          return concat([",
                "            prefix,",
                "            align(",
                "              \" \".repeat(prefix.length),",
                "              printListItem(childPath, options, print, prefix)",
                "            )",
                "          ]);",
                "",
                "          function getPrefix() {",
                "            const rawPrefix = node.ordered",
                "              ? (index === 0",
                "                  ? node.start",
                "                  : isGitDiffFriendlyOrderedList ? 1 : node.start + index) +",
                "                (nthSiblingIndex % 2 === 0 ? \". \" : \") \")",
                "              : nthSiblingIndex % 2 === 0 ? \"* \" : \"- \";",
                "",
                "            // do not print trailing spaces for empty list item since it might be treated as `break` node",
                "            // by [doc-printer](https://github.com/prettier/prettier/blob/1.10.2/src/doc/doc-printer.js#L395-L405),",
                "            // we don't want to preserve unnecessary trailing spaces.",
                "            const listItem = childPath.getValue();",
                "            return listItem.children.length",
                "              ? alignListPrefix(rawPrefix, options)",
                "              : rawPrefix;",
                "          }",
                "        }",
                "      });",
                "    }",
                "    case \"thematicBreak\": {",
                "      const counter = getAncestorCounter(path, \"list\");",
                "      if (counter === -1) {",
                "        return \"---\";",
                "      }",
                "      const nthSiblingIndex = getNthListSiblingIndex(",
                "        path.getParentNode(counter),",
                "        path.getParentNode(counter + 1)",
                "      );",
                "      return nthSiblingIndex % 2 === 0 ? \"---\" : \"***\";",
                "    }",
                "    case \"linkReference\":",
                "      return concat([",
                "        \"[\",",
                "        printChildren(path, options, print),",
                "        \"]\",",
                "        node.referenceType === \"full\"",
                "          ? concat([\"[\", node.identifier, \"]\"])",
                "          : node.referenceType === \"collapsed\" ? \"[]\" : \"\"",
                "      ]);",
                "    case \"imageReference\":",
                "      switch (node.referenceType) {",
                "        case \"full\":",
                "          return concat([\"![\", node.alt || \"\", \"][\", node.identifier, \"]\"]);",
                "        default:",
                "          return concat([",
                "            \"![\",",
                "            node.alt,",
                "            \"]\",",
                "            node.referenceType === \"collapsed\" ? \"[]\" : \"\"",
                "          ]);",
                "      }",
                "    case \"definition\":",
                "      return concat([",
                "        \"[\",",
                "        node.identifier,",
                "        \"]: \",",
                "        printUrl(node.url),",
                "        printTitle(node.title, options)",
                "      ]);",
                "    case \"footnote\":",
                "      return concat([\"[^\", printChildren(path, options, print), \"]\"]);",
                "    case \"footnoteReference\":",
                "      return concat([\"[^\", node.identifier, \"]\"]);",
                "    case \"footnoteDefinition\": {",
                "      const nextNode = path.getParentNode().children[path.getName() + 1];",
                "      return concat([",
                "        \"[^\",",
                "        node.identifier,",
                "        \"]: \",",
                "        group(",
                "          concat([",
                "            align(",
                "              \" \".repeat(options.tabWidth),",
                "              printChildren(path, options, print, {",
                "                processor: (childPath, index) =>",
                "                  index === 0",
                "                    ? group(concat([softline, softline, childPath.call(print)]))",
                "                    : childPath.call(print)",
                "              })",
                "            ),",
                "            nextNode && nextNode.type === \"footnoteDefinition\" ? softline : \"\"",
                "          ])",
                "        )",
                "      ]);",
                "    }",
                "    case \"table\":",
                "      return printTable(path, options, print);",
                "    case \"tableCell\":",
                "      return printChildren(path, options, print);",
                "    case \"break\":",
                "      return concat([",
                "        /\\s/.test(options.originalText[node.position.start.offset])",
                "          ? \"  \"",
                "          : \"\\\\\",",
                "        hardline",
                "      ]);",
                "    case \"tableRow\": // handled in \"table\"",
                "    case \"listItem\": // handled in \"list\"",
                "    default:",
                "      throw new Error(`Unknown markdown type ${JSON.stringify(node.type)}`);",
                "  }",
                "}",
                "",
                "function printListItem(path, options, print, listPrefix) {",
                "  const node = path.getValue();",
                "  const prefix = node.checked === null ? \"\" : node.checked ? \"[x] \" : \"[ ] \";",
                "  return concat([",
                "    prefix,",
                "    printChildren(path, options, print, {",
                "      processor: (childPath, index) => {",
                "        if (index === 0 && childPath.getValue().type !== \"list\") {",
                "          return align(\" \".repeat(prefix.length), childPath.call(print));",
                "        }",
                "",
                "        const alignment = \" \".repeat(",
                "          clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block",
                "        );",
                "        return concat([alignment, align(alignment, childPath.call(print))]);",
                "      }",
                "    })",
                "  ]);",
                "}",
                "",
                "function alignListPrefix(prefix, options) {",
                "  const additionalSpaces = getAdditionalSpaces();",
                "  return (",
                "    prefix +",
                "    \" \".repeat(",
                "      additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block",
                "    )",
                "  );",
                "",
                "  function getAdditionalSpaces() {",
                "    const restSpaces = prefix.length % options.tabWidth;",
                "    return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;",
                "  }",
                "}",
                "",
                "function getNthListSiblingIndex(node, parentNode) {",
                "  return getNthSiblingIndex(",
                "    node,",
                "    parentNode,",
                "    siblingNode => siblingNode.ordered === node.ordered",
                "  );",
                "}",
                "",
                "function replaceNewlinesWithHardlines(str) {",
                "  return join(hardline, str.split(\"\\n\"));",
                "}",
                "",
                "function getNthSiblingIndex(node, parentNode, condition) {",
                "  condition = condition || (() => true);",
                "",
                "  let index = -1;",
                "",
                "  for (const childNode of parentNode.children) {",
                "    if (childNode.type === node.type && condition(childNode)) {",
                "      index++;",
                "    } else {",
                "      index = -1;",
                "    }",
                "",
                "    if (childNode === node) {",
                "      return index;",
                "    }",
                "  }",
                "}",
                "",
                "function getAncestorCounter(path, typeOrTypes) {",
                "  const types = [].concat(typeOrTypes);",
                "",
                "  let counter = -1;",
                "  let ancestorNode;",
                "",
                "  while ((ancestorNode = path.getParentNode(++counter))) {",
                "    if (types.indexOf(ancestorNode.type) !== -1) {",
                "      return counter;",
                "    }",
                "  }",
                "",
                "  return -1;",
                "}",
                "",
                "function getAncestorNode(path, typeOrTypes) {",
                "  const counter = getAncestorCounter(path, typeOrTypes);",
                "  return counter === -1 ? null : path.getParentNode(counter);",
                "}",
                "",
                "function printLine(path, value, options) {",
                "  if (options.proseWrap === \"preserve\" && value === \"\\n\") {",
                "    return hardline;",
                "  }",
                "",
                "  const isBreakable =",
                "    options.proseWrap === \"always\" &&",
                "    !getAncestorNode(path, SINGLE_LINE_NODE_TYPES);",
                "  return value !== \"\"",
                "    ? isBreakable ? line : \" \"",
                "    : isBreakable ? softline : \"\";",
                "}",
                "",
                "function printTable(path, options, print) {",
                "  const node = path.getValue();",
                "  const contents = []; // { [rowIndex: number]: { [columnIndex: number]: string } }",
                "",
                "  path.map(rowPath => {",
                "    const rowContents = [];",
                "",
                "    rowPath.map(cellPath => {",
                "      rowContents.push(",
                "        printDocToString(cellPath.call(print), options).formatted",
                "      );",
                "    }, \"children\");",
                "",
                "    contents.push(rowContents);",
                "  }, \"children\");",
                "",
                "  const columnMaxWidths = contents.reduce(",
                "    (currentWidths, rowContents) =>",
                "      currentWidths.map((width, columnIndex) =>",
                "        Math.max(width, privateUtil.getStringWidth(rowContents[columnIndex]))",
                "      ),",
                "    contents[0].map(() => 3) // minimum width = 3 (---, :--, :-:, --:)",
                "  );",
                "",
                "  return join(hardline, [",
                "    printRow(contents[0]),",
                "    printSeparator(),",
                "    join(hardline, contents.slice(1).map(printRow))",
                "  ]);",
                "",
                "  function printSeparator() {",
                "    return concat([",
                "      \"| \",",
                "      join(",
                "        \" | \",",
                "        columnMaxWidths.map((width, index) => {",
                "          switch (node.align[index]) {",
                "            case \"left\":",
                "              return \":\" + \"-\".repeat(width - 1);",
                "            case \"right\":",
                "              return \"-\".repeat(width - 1) + \":\";",
                "            case \"center\":",
                "              return \":\" + \"-\".repeat(width - 2) + \":\";",
                "            default:",
                "              return \"-\".repeat(width);",
                "          }",
                "        })",
                "      ),",
                "      \" |\"",
                "    ]);",
                "  }",
                "",
                "  function printRow(rowContents) {",
                "    return concat(["
            ]
        },
        "3": {
            "class_name": "parse (not found) ",
            "file_path": "src/main/parser.js",
            "class_details": [
                {
                    "name": "parse",
                    "start_line": 1,
                    "end_line": 94
                }
            ],
            "class_code": [
                "\"use strict\";",
                "",
                "const path = require(\"path\");",
                "const ConfigError = require(\"../common/errors\").ConfigError;",
                "const js = require(\"../language-js/index.js\");",
                "",
                "const locStart = js.locStart;",
                "const locEnd = js.locEnd;",
                "",
                "function getParsers(options) {",
                "  return options.plugins.reduce(",
                "    (parsers, plugin) => Object.assign({}, parsers, plugin.parsers),",
                "    {}",
                "  );",
                "}",
                "",
                "function resolveParser(opts, parsers) {",
                "  parsers = parsers || getParsers(opts);",
                "",
                "  if (typeof opts.parser === \"function\") {",
                "    // Custom parser API always works with JavaScript.",
                "    return {",
                "      parse: opts.parser,",
                "      astFormat: \"estree\",",
                "      locStart,",
                "      locEnd",
                "    };",
                "  }",
                "",
                "  if (typeof opts.parser === \"string\") {",
                "    if (parsers.hasOwnProperty(opts.parser)) {",
                "      return parsers[opts.parser];",
                "    }",
                "    try {",
                "      return {",
                "        parse: eval(\"require\")(path.resolve(process.cwd(), opts.parser)),",
                "        astFormat: \"estree\",",
                "        locStart,",
                "        locEnd",
                "      };",
                "    } catch (err) {",
                "      /* istanbul ignore next */",
                "      throw new ConfigError(`Couldn't resolve parser \"${opts.parser}\"`);",
                "    }",
                "  }",
                "  /* istanbul ignore next */",
                "  return parsers.babylon;",
                "}",
                "",
                "function parse(text, opts) {",
                "  const parsers = getParsers(opts);",
                "",
                "  // Copy the \"parse\" function from parser to a new object whose values are",
                "  // functions. Use defineProperty()/getOwnPropertyDescriptor() such that we",
                "  // don't invoke the parser.parse getters.",
                "  const parsersForCustomParserApi = Object.keys(parsers).reduce(",
                "    (object, parserName) =>",
                "      Object.defineProperty(",
                "        object,",
                "        parserName,",
                "        Object.getOwnPropertyDescriptor(parsers[parserName], \"parse\")",
                "      ),",
                "    {}",
                "  );",
                "",
                "  const parser = resolveParser(opts, parsers);",
                "",
                "  try {",
                "    if (parser.preprocess) {",
                "      text = parser.preprocess(text, opts);",
                "    }",
                "",
                "    return {",
                "      text,",
                "      ast: parser.parse(text, parsersForCustomParserApi, opts)",
                "    };",
                "  } catch (error) {",
                "    const loc = error.loc;",
                "",
                "    if (loc) {",
                "      const codeFrame = require(\"@babel/code-frame\");",
                "      error.codeFrame = codeFrame.codeFrameColumns(text, loc, {",
                "        highlightCode: true",
                "      });",
                "      error.message += \"\\n\" + error.codeFrame;",
                "      throw error;",
                "    }",
                "",
                "    /* istanbul ignore next */",
                "    throw error.stack;",
                "  }",
                "}",
                "",
                "module.exports = { parse, resolveParser };"
            ]
        }
    },
    "bug_functions": {
        "4": {
            "function_name": "parse (not found) ",
            "file_path": "src/language-markdown/parser-markdown.js",
            "function_details": [
                {
                    "name": "parse",
                    "start_line": 1,
                    "end_line": 130
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const remarkFrontmatter = require(\"remark-frontmatter\");",
                "const remarkParse = require(\"remark-parse\");",
                "const unified = require(\"unified\");",
                "const util = require(\"../common/util\");",
                "",
                "/**",
                " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                " *",
                " * 1. restore unescaped character (Text)",
                " * 2. merge continuous Texts",
                " * 3. replace whitespaces in InlineCode#value with one whitespace",
                " *    reference: http://spec.commonmark.org/0.25/#example-605",
                " * 4. split Text into Sentence",
                " *",
                " * interface Word { value: string }",
                " * interface Whitespace { value: string }",
                " * interface Sentence { children: Array<Word | Whitespace> }",
                " * interface InlineCode { children: Array<Sentence> }",
                " */",
                "function parse(text /*, parsers, opts*/) {",
                "  const processor = unified()",
                "    .use(remarkParse, { footnotes: true, commonmark: true })",
                "    .use(remarkFrontmatter, [\"yaml\", \"toml\"])",
                "    .use(restoreUnescapedCharacter(text))",
                "    .use(mergeContinuousTexts)",
                "    .use(transformInlineCode)",
                "    .use(splitText);",
                "  return processor.runSync(processor.parse(text));",
                "}",
                "",
                "function map(ast, handler) {",
                "  return (function preorder(node, index, parentNode) {",
                "    const newNode = Object.assign({}, handler(node, index, parentNode));",
                "    if (newNode.children) {",
                "      newNode.children = newNode.children.map((child, index) => {",
                "        return preorder(child, index, newNode);",
                "      });",
                "    }",
                "    return newNode;",
                "  })(ast, null, null);",
                "}",
                "",
                "function transformInlineCode() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (node.type !== \"inlineCode\") {",
                "        return node;",
                "      }",
                "",
                "      return Object.assign({}, node, {",
                "        value: node.value.replace(/\\s+/g, \" \")",
                "      });",
                "    });",
                "}",
                "",
                "function restoreUnescapedCharacter(originalText) {",
                "  return () => ast =>",
                "    map(ast, node => {",
                "      return node.type !== \"text\"",
                "        ? node",
                "        : Object.assign({}, node, {",
                "            value:",
                "              node.value !== \"*\" &&",
                "              node.value !== \"_\" && // handle these two cases in printer",
                "              node.value.length === 1 &&",
                "              node.position.end.offset - node.position.start.offset > 1",
                "                ? originalText.slice(",
                "                    node.position.start.offset,",
                "                    node.position.end.offset",
                "                  )",
                "                : node.value",
                "          });",
                "    });",
                "}",
                "",
                "function mergeContinuousTexts() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (!node.children) {",
                "        return node;",
                "      }",
                "      const children = node.children.reduce((current, child) => {",
                "        const lastChild = current[current.length - 1];",
                "        if (lastChild && lastChild.type === \"text\" && child.type === \"text\") {",
                "          current.splice(-1, 1, {",
                "            type: \"text\",",
                "            value: lastChild.value + child.value,",
                "            position: {",
                "              start: lastChild.position.start,",
                "              end: child.position.end",
                "            }",
                "          });",
                "        } else {",
                "          current.push(child);",
                "        }",
                "        return current;",
                "      }, []);",
                "      return Object.assign({}, node, { children });",
                "    });",
                "}",
                "",
                "function splitText() {",
                "  return ast =>",
                "    map(ast, (node, index, parentNode) => {",
                "      if (node.type !== \"text\") {",
                "        return node;",
                "      }",
                "",
                "      let value = node.value;",
                "",
                "      if (parentNode.type === \"paragraph\") {",
                "        if (index === 0) {",
                "          value = value.trimLeft();",
                "        }",
                "        if (index === parentNode.children.length - 1) {",
                "          value = value.trimRight();",
                "        }",
                "      }",
                "",
                "      return {",
                "        type: \"sentence\",",
                "        position: node.position,",
                "        children: util.splitText(value)",
                "      };",
                "    });",
                "}",
                "",
                "module.exports = parse;"
            ]
        },
        "5": {
            "function_name": "transformInlineCode (not found) ",
            "file_path": "src/language-markdown/parser-markdown.js",
            "function_details": [
                {
                    "name": "transformInlineCode",
                    "start_line": 1,
                    "end_line": 130
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const remarkFrontmatter = require(\"remark-frontmatter\");",
                "const remarkParse = require(\"remark-parse\");",
                "const unified = require(\"unified\");",
                "const util = require(\"../common/util\");",
                "",
                "/**",
                " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                " *",
                " * 1. restore unescaped character (Text)",
                " * 2. merge continuous Texts",
                " * 3. replace whitespaces in InlineCode#value with one whitespace",
                " *    reference: http://spec.commonmark.org/0.25/#example-605",
                " * 4. split Text into Sentence",
                " *",
                " * interface Word { value: string }",
                " * interface Whitespace { value: string }",
                " * interface Sentence { children: Array<Word | Whitespace> }",
                " * interface InlineCode { children: Array<Sentence> }",
                " */",
                "function parse(text /*, parsers, opts*/) {",
                "  const processor = unified()",
                "    .use(remarkParse, { footnotes: true, commonmark: true })",
                "    .use(remarkFrontmatter, [\"yaml\", \"toml\"])",
                "    .use(restoreUnescapedCharacter(text))",
                "    .use(mergeContinuousTexts)",
                "    .use(transformInlineCode)",
                "    .use(splitText);",
                "  return processor.runSync(processor.parse(text));",
                "}",
                "",
                "function map(ast, handler) {",
                "  return (function preorder(node, index, parentNode) {",
                "    const newNode = Object.assign({}, handler(node, index, parentNode));",
                "    if (newNode.children) {",
                "      newNode.children = newNode.children.map((child, index) => {",
                "        return preorder(child, index, newNode);",
                "      });",
                "    }",
                "    return newNode;",
                "  })(ast, null, null);",
                "}",
                "",
                "function transformInlineCode() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (node.type !== \"inlineCode\") {",
                "        return node;",
                "      }",
                "",
                "      return Object.assign({}, node, {",
                "        value: node.value.replace(/\\s+/g, \" \")",
                "      });",
                "    });",
                "}",
                "",
                "function restoreUnescapedCharacter(originalText) {",
                "  return () => ast =>",
                "    map(ast, node => {",
                "      return node.type !== \"text\"",
                "        ? node",
                "        : Object.assign({}, node, {",
                "            value:",
                "              node.value !== \"*\" &&",
                "              node.value !== \"_\" && // handle these two cases in printer",
                "              node.value.length === 1 &&",
                "              node.position.end.offset - node.position.start.offset > 1",
                "                ? originalText.slice(",
                "                    node.position.start.offset,",
                "                    node.position.end.offset",
                "                  )",
                "                : node.value",
                "          });",
                "    });",
                "}",
                "",
                "function mergeContinuousTexts() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (!node.children) {",
                "        return node;",
                "      }",
                "      const children = node.children.reduce((current, child) => {",
                "        const lastChild = current[current.length - 1];",
                "        if (lastChild && lastChild.type === \"text\" && child.type === \"text\") {",
                "          current.splice(-1, 1, {",
                "            type: \"text\",",
                "            value: lastChild.value + child.value,",
                "            position: {",
                "              start: lastChild.position.start,",
                "              end: child.position.end",
                "            }",
                "          });",
                "        } else {",
                "          current.push(child);",
                "        }",
                "        return current;",
                "      }, []);",
                "      return Object.assign({}, node, { children });",
                "    });",
                "}",
                "",
                "function splitText() {",
                "  return ast =>",
                "    map(ast, (node, index, parentNode) => {",
                "      if (node.type !== \"text\") {",
                "        return node;",
                "      }",
                "",
                "      let value = node.value;",
                "",
                "      if (parentNode.type === \"paragraph\") {",
                "        if (index === 0) {",
                "          value = value.trimLeft();",
                "        }",
                "        if (index === parentNode.children.length - 1) {",
                "          value = value.trimRight();",
                "        }",
                "      }",
                "",
                "      return {",
                "        type: \"sentence\",",
                "        position: node.position,",
                "        children: util.splitText(value)",
                "      };",
                "    });",
                "}",
                "",
                "module.exports = parse;"
            ]
        },
        "6": {
            "function_name": "restoreUnescapedCharacter (not found) ",
            "file_path": "src/language-markdown/parser-markdown.js",
            "function_details": [
                {
                    "name": "restoreUnescapedCharacter",
                    "start_line": 1,
                    "end_line": 130
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const remarkFrontmatter = require(\"remark-frontmatter\");",
                "const remarkParse = require(\"remark-parse\");",
                "const unified = require(\"unified\");",
                "const util = require(\"../common/util\");",
                "",
                "/**",
                " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                " *",
                " * 1. restore unescaped character (Text)",
                " * 2. merge continuous Texts",
                " * 3. replace whitespaces in InlineCode#value with one whitespace",
                " *    reference: http://spec.commonmark.org/0.25/#example-605",
                " * 4. split Text into Sentence",
                " *",
                " * interface Word { value: string }",
                " * interface Whitespace { value: string }",
                " * interface Sentence { children: Array<Word | Whitespace> }",
                " * interface InlineCode { children: Array<Sentence> }",
                " */",
                "function parse(text /*, parsers, opts*/) {",
                "  const processor = unified()",
                "    .use(remarkParse, { footnotes: true, commonmark: true })",
                "    .use(remarkFrontmatter, [\"yaml\", \"toml\"])",
                "    .use(restoreUnescapedCharacter(text))",
                "    .use(mergeContinuousTexts)",
                "    .use(transformInlineCode)",
                "    .use(splitText);",
                "  return processor.runSync(processor.parse(text));",
                "}",
                "",
                "function map(ast, handler) {",
                "  return (function preorder(node, index, parentNode) {",
                "    const newNode = Object.assign({}, handler(node, index, parentNode));",
                "    if (newNode.children) {",
                "      newNode.children = newNode.children.map((child, index) => {",
                "        return preorder(child, index, newNode);",
                "      });",
                "    }",
                "    return newNode;",
                "  })(ast, null, null);",
                "}",
                "",
                "function transformInlineCode() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (node.type !== \"inlineCode\") {",
                "        return node;",
                "      }",
                "",
                "      return Object.assign({}, node, {",
                "        value: node.value.replace(/\\s+/g, \" \")",
                "      });",
                "    });",
                "}",
                "",
                "function restoreUnescapedCharacter(originalText) {",
                "  return () => ast =>",
                "    map(ast, node => {",
                "      return node.type !== \"text\"",
                "        ? node",
                "        : Object.assign({}, node, {",
                "            value:",
                "              node.value !== \"*\" &&",
                "              node.value !== \"_\" && // handle these two cases in printer",
                "              node.value.length === 1 &&",
                "              node.position.end.offset - node.position.start.offset > 1",
                "                ? originalText.slice(",
                "                    node.position.start.offset,",
                "                    node.position.end.offset",
                "                  )",
                "                : node.value",
                "          });",
                "    });",
                "}",
                "",
                "function mergeContinuousTexts() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (!node.children) {",
                "        return node;",
                "      }",
                "      const children = node.children.reduce((current, child) => {",
                "        const lastChild = current[current.length - 1];",
                "        if (lastChild && lastChild.type === \"text\" && child.type === \"text\") {",
                "          current.splice(-1, 1, {",
                "            type: \"text\",",
                "            value: lastChild.value + child.value,",
                "            position: {",
                "              start: lastChild.position.start,",
                "              end: child.position.end",
                "            }",
                "          });",
                "        } else {",
                "          current.push(child);",
                "        }",
                "        return current;",
                "      }, []);",
                "      return Object.assign({}, node, { children });",
                "    });",
                "}",
                "",
                "function splitText() {",
                "  return ast =>",
                "    map(ast, (node, index, parentNode) => {",
                "      if (node.type !== \"text\") {",
                "        return node;",
                "      }",
                "",
                "      let value = node.value;",
                "",
                "      if (parentNode.type === \"paragraph\") {",
                "        if (index === 0) {",
                "          value = value.trimLeft();",
                "        }",
                "        if (index === parentNode.children.length - 1) {",
                "          value = value.trimRight();",
                "        }",
                "      }",
                "",
                "      return {",
                "        type: \"sentence\",",
                "        position: node.position,",
                "        children: util.splitText(value)",
                "      };",
                "    });",
                "}",
                "",
                "module.exports = parse;"
            ]
        },
        "7": {
            "function_name": "mergeContinuousTexts (not found) ",
            "file_path": "src/language-markdown/parser-markdown.js",
            "function_details": [
                {
                    "name": "mergeContinuousTexts",
                    "start_line": 1,
                    "end_line": 130
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const remarkFrontmatter = require(\"remark-frontmatter\");",
                "const remarkParse = require(\"remark-parse\");",
                "const unified = require(\"unified\");",
                "const util = require(\"../common/util\");",
                "",
                "/**",
                " * based on [MDAST](https://github.com/syntax-tree/mdast) with following modifications:",
                " *",
                " * 1. restore unescaped character (Text)",
                " * 2. merge continuous Texts",
                " * 3. replace whitespaces in InlineCode#value with one whitespace",
                " *    reference: http://spec.commonmark.org/0.25/#example-605",
                " * 4. split Text into Sentence",
                " *",
                " * interface Word { value: string }",
                " * interface Whitespace { value: string }",
                " * interface Sentence { children: Array<Word | Whitespace> }",
                " * interface InlineCode { children: Array<Sentence> }",
                " */",
                "function parse(text /*, parsers, opts*/) {",
                "  const processor = unified()",
                "    .use(remarkParse, { footnotes: true, commonmark: true })",
                "    .use(remarkFrontmatter, [\"yaml\", \"toml\"])",
                "    .use(restoreUnescapedCharacter(text))",
                "    .use(mergeContinuousTexts)",
                "    .use(transformInlineCode)",
                "    .use(splitText);",
                "  return processor.runSync(processor.parse(text));",
                "}",
                "",
                "function map(ast, handler) {",
                "  return (function preorder(node, index, parentNode) {",
                "    const newNode = Object.assign({}, handler(node, index, parentNode));",
                "    if (newNode.children) {",
                "      newNode.children = newNode.children.map((child, index) => {",
                "        return preorder(child, index, newNode);",
                "      });",
                "    }",
                "    return newNode;",
                "  })(ast, null, null);",
                "}",
                "",
                "function transformInlineCode() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (node.type !== \"inlineCode\") {",
                "        return node;",
                "      }",
                "",
                "      return Object.assign({}, node, {",
                "        value: node.value.replace(/\\s+/g, \" \")",
                "      });",
                "    });",
                "}",
                "",
                "function restoreUnescapedCharacter(originalText) {",
                "  return () => ast =>",
                "    map(ast, node => {",
                "      return node.type !== \"text\"",
                "        ? node",
                "        : Object.assign({}, node, {",
                "            value:",
                "              node.value !== \"*\" &&",
                "              node.value !== \"_\" && // handle these two cases in printer",
                "              node.value.length === 1 &&",
                "              node.position.end.offset - node.position.start.offset > 1",
                "                ? originalText.slice(",
                "                    node.position.start.offset,",
                "                    node.position.end.offset",
                "                  )",
                "                : node.value",
                "          });",
                "    });",
                "}",
                "",
                "function mergeContinuousTexts() {",
                "  return ast =>",
                "    map(ast, node => {",
                "      if (!node.children) {",
                "        return node;",
                "      }",
                "      const children = node.children.reduce((current, child) => {",
                "        const lastChild = current[current.length - 1];",
                "        if (lastChild && lastChild.type === \"text\" && child.type === \"text\") {",
                "          current.splice(-1, 1, {",
                "            type: \"text\",",
                "            value: lastChild.value + child.value,",
                "            position: {",
                "              start: lastChild.position.start,",
                "              end: child.position.end",
                "            }",
                "          });",
                "        } else {",
                "          current.push(child);",
                "        }",
                "        return current;",
                "      }, []);",
                "      return Object.assign({}, node, { children });",
                "    });",
                "}",
                "",
                "function splitText() {",
                "  return ast =>",
                "    map(ast, (node, index, parentNode) => {",
                "      if (node.type !== \"text\") {",
                "        return node;",
                "      }",
                "",
                "      let value = node.value;",
                "",
                "      if (parentNode.type === \"paragraph\") {",
                "        if (index === 0) {",
                "          value = value.trimLeft();",
                "        }",
                "        if (index === parentNode.children.length - 1) {",
                "          value = value.trimRight();",
                "        }",
                "      }",
                "",
                "      return {",
                "        type: \"sentence\",",
                "        position: node.position,",
                "        children: util.splitText(value)",
                "      };",
                "    });",
                "}",
                "",
                "module.exports = parse;"
            ]
        },
        "8": {
            "function_name": "resolveParser (not found) ",
            "file_path": "src/main/parser.js",
            "function_details": [
                {
                    "name": "resolveParser",
                    "start_line": 1,
                    "end_line": 94
                }
            ],
            "function_code": [
                "\"use strict\";",
                "",
                "const path = require(\"path\");",
                "const ConfigError = require(\"../common/errors\").ConfigError;",
                "const js = require(\"../language-js/index.js\");",
                "",
                "const locStart = js.locStart;",
                "const locEnd = js.locEnd;",
                "",
                "function getParsers(options) {",
                "  return options.plugins.reduce(",
                "    (parsers, plugin) => Object.assign({}, parsers, plugin.parsers),",
                "    {}",
                "  );",
                "}",
                "",
                "function resolveParser(opts, parsers) {",
                "  parsers = parsers || getParsers(opts);",
                "",
                "  if (typeof opts.parser === \"function\") {",
                "    // Custom parser API always works with JavaScript.",
                "    return {",
                "      parse: opts.parser,",
                "      astFormat: \"estree\",",
                "      locStart,",
                "      locEnd",
                "    };",
                "  }",
                "",
                "  if (typeof opts.parser === \"string\") {",
                "    if (parsers.hasOwnProperty(opts.parser)) {",
                "      return parsers[opts.parser];",
                "    }",
                "    try {",
                "      return {",
                "        parse: eval(\"require\")(path.resolve(process.cwd(), opts.parser)),",
                "        astFormat: \"estree\",",
                "        locStart,",
                "        locEnd",
                "      };",
                "    } catch (err) {",
                "      /* istanbul ignore next */",
                "      throw new ConfigError(`Couldn't resolve parser \"${opts.parser}\"`);",
                "    }",
                "  }",
                "  /* istanbul ignore next */",
                "  return parsers.babylon;",
                "}",
                "",
                "function parse(text, opts) {",
                "  const parsers = getParsers(opts);",
                "",
                "  // Copy the \"parse\" function from parser to a new object whose values are",
                "  // functions. Use defineProperty()/getOwnPropertyDescriptor() such that we",
                "  // don't invoke the parser.parse getters.",
                "  const parsersForCustomParserApi = Object.keys(parsers).reduce(",
                "    (object, parserName) =>",
                "      Object.defineProperty(",
                "        object,",
                "        parserName,",
                "        Object.getOwnPropertyDescriptor(parsers[parserName], \"parse\")",
                "      ),",
                "    {}",
                "  );",
                "",
                "  const parser = resolveParser(opts, parsers);",
                "",
                "  try {",
                "    if (parser.preprocess) {",
                "      text = parser.preprocess(text, opts);",
                "    }",
                "",
                "    return {",
                "      text,",
                "      ast: parser.parse(text, parsersForCustomParserApi, opts)",
                "    };",
                "  } catch (error) {",
                "    const loc = error.loc;",
                "",
                "    if (loc) {",
                "      const codeFrame = require(\"@babel/code-frame\");",
                "      error.codeFrame = codeFrame.codeFrameColumns(text, loc, {",
                "        highlightCode: true",
                "      });",
                "      error.message += \"\\n\" + error.codeFrame;",
                "      throw error;",
                "    }",
                "",
                "    /* istanbul ignore next */",
                "    throw error.stack;",
                "  }",
                "}",
                "",
                "module.exports = { parse, resolveParser };"
            ]
        }
    }
}